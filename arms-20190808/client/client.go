// This file is auto-generated, don't edit it. Thanks.
/**
 *
 */
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	endpointutil "github.com/alibabacloud-go/endpoint-util/service"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
)

type CallChainInfo struct {
	AdditionalInfo *string                           `json:"AdditionalInfo,omitempty" xml:"AdditionalInfo,omitempty"`
	AppName        *string                           `json:"AppName,omitempty" xml:"AppName,omitempty"`
	AppType        *string                           `json:"AppType,omitempty" xml:"AppType,omitempty"`
	Children       []*CallChainInfo                  `json:"Children,omitempty" xml:"Children,omitempty" type:"Repeated"`
	HaveSpan       *bool                             `json:"HaveSpan,omitempty" xml:"HaveSpan,omitempty"`
	LogMap         map[string]map[string]interface{} `json:"LogMap,omitempty" xml:"LogMap,omitempty"`
	LogTime        *int64                            `json:"LogTime,omitempty" xml:"LogTime,omitempty"`
	ParentSpanId   *string                           `json:"ParentSpanId,omitempty" xml:"ParentSpanId,omitempty"`
	Pid            *string                           `json:"Pid,omitempty" xml:"Pid,omitempty"`
	RegionId       *string                           `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResultCode     *string                           `json:"ResultCode,omitempty" xml:"ResultCode,omitempty"`
	Rpc            *string                           `json:"Rpc,omitempty" xml:"Rpc,omitempty"`
	RpcId          *string                           `json:"RpcId,omitempty" xml:"RpcId,omitempty"`
	RpcType        *int64                            `json:"RpcType,omitempty" xml:"RpcType,omitempty"`
	ServerIp       *string                           `json:"ServerIp,omitempty" xml:"ServerIp,omitempty"`
	Span           *int64                            `json:"Span,omitempty" xml:"Span,omitempty"`
	SpanId         *string                           `json:"SpanId,omitempty" xml:"SpanId,omitempty"`
	TagMap         map[string]*string                `json:"TagMap,omitempty" xml:"TagMap,omitempty"`
	TraceId        *string                           `json:"TraceId,omitempty" xml:"TraceId,omitempty"`
}

func (s CallChainInfo) String() string {
	return tea.Prettify(s)
}

func (s CallChainInfo) GoString() string {
	return s.String()
}

func (s *CallChainInfo) SetAdditionalInfo(v string) *CallChainInfo {
	s.AdditionalInfo = &v
	return s
}

func (s *CallChainInfo) SetAppName(v string) *CallChainInfo {
	s.AppName = &v
	return s
}

func (s *CallChainInfo) SetAppType(v string) *CallChainInfo {
	s.AppType = &v
	return s
}

func (s *CallChainInfo) SetChildren(v []*CallChainInfo) *CallChainInfo {
	s.Children = v
	return s
}

func (s *CallChainInfo) SetHaveSpan(v bool) *CallChainInfo {
	s.HaveSpan = &v
	return s
}

func (s *CallChainInfo) SetLogMap(v map[string]map[string]interface{}) *CallChainInfo {
	s.LogMap = v
	return s
}

func (s *CallChainInfo) SetLogTime(v int64) *CallChainInfo {
	s.LogTime = &v
	return s
}

func (s *CallChainInfo) SetParentSpanId(v string) *CallChainInfo {
	s.ParentSpanId = &v
	return s
}

func (s *CallChainInfo) SetPid(v string) *CallChainInfo {
	s.Pid = &v
	return s
}

func (s *CallChainInfo) SetRegionId(v string) *CallChainInfo {
	s.RegionId = &v
	return s
}

func (s *CallChainInfo) SetResultCode(v string) *CallChainInfo {
	s.ResultCode = &v
	return s
}

func (s *CallChainInfo) SetRpc(v string) *CallChainInfo {
	s.Rpc = &v
	return s
}

func (s *CallChainInfo) SetRpcId(v string) *CallChainInfo {
	s.RpcId = &v
	return s
}

func (s *CallChainInfo) SetRpcType(v int64) *CallChainInfo {
	s.RpcType = &v
	return s
}

func (s *CallChainInfo) SetServerIp(v string) *CallChainInfo {
	s.ServerIp = &v
	return s
}

func (s *CallChainInfo) SetSpan(v int64) *CallChainInfo {
	s.Span = &v
	return s
}

func (s *CallChainInfo) SetSpanId(v string) *CallChainInfo {
	s.SpanId = &v
	return s
}

func (s *CallChainInfo) SetTagMap(v map[string]*string) *CallChainInfo {
	s.TagMap = v
	return s
}

func (s *CallChainInfo) SetTraceId(v string) *CallChainInfo {
	s.TraceId = &v
	return s
}

type GrafanaWorkspace struct {
	Commercial              *bool                   `json:"commercial,omitempty" xml:"commercial,omitempty"`
	DeployType              *string                 `json:"deployType,omitempty" xml:"deployType,omitempty"`
	Description             *string                 `json:"description,omitempty" xml:"description,omitempty"`
	EndTime                 *float32                `json:"endTime,omitempty" xml:"endTime,omitempty"`
	GmtCreate               *float32                `json:"gmtCreate,omitempty" xml:"gmtCreate,omitempty"`
	GrafanaVersion          *string                 `json:"grafanaVersion,omitempty" xml:"grafanaVersion,omitempty"`
	GrafanaWorkspaceDomain  *string                 `json:"grafanaWorkspaceDomain,omitempty" xml:"grafanaWorkspaceDomain,omitempty"`
	GrafanaWorkspaceEdition *string                 `json:"grafanaWorkspaceEdition,omitempty" xml:"grafanaWorkspaceEdition,omitempty"`
	GrafanaWorkspaceId      *string                 `json:"grafanaWorkspaceId,omitempty" xml:"grafanaWorkspaceId,omitempty"`
	GrafanaWorkspaceIp      *string                 `json:"grafanaWorkspaceIp,omitempty" xml:"grafanaWorkspaceIp,omitempty"`
	GrafanaWorkspaceName    *string                 `json:"grafanaWorkspaceName,omitempty" xml:"grafanaWorkspaceName,omitempty"`
	MaxAccount              *string                 `json:"maxAccount,omitempty" xml:"maxAccount,omitempty"`
	NtmId                   *string                 `json:"ntmId,omitempty" xml:"ntmId,omitempty"`
	PersonalDomain          *string                 `json:"personalDomain,omitempty" xml:"personalDomain,omitempty"`
	PersonalDomainPrefix    *string                 `json:"personalDomainPrefix,omitempty" xml:"personalDomainPrefix,omitempty"`
	PrivateDomain           *string                 `json:"privateDomain,omitempty" xml:"privateDomain,omitempty"`
	PrivateIp               *string                 `json:"privateIp,omitempty" xml:"privateIp,omitempty"`
	Protocol                *string                 `json:"protocol,omitempty" xml:"protocol,omitempty"`
	RegionId                *string                 `json:"regionId,omitempty" xml:"regionId,omitempty"`
	ResourceGroupId         *string                 `json:"resourceGroupId,omitempty" xml:"resourceGroupId,omitempty"`
	ShareSynced             *bool                   `json:"shareSynced,omitempty" xml:"shareSynced,omitempty"`
	SnatIp                  *string                 `json:"snatIp,omitempty" xml:"snatIp,omitempty"`
	Status                  *string                 `json:"status,omitempty" xml:"status,omitempty"`
	Tags                    []*GrafanaWorkspaceTags `json:"tags,omitempty" xml:"tags,omitempty" type:"Repeated"`
	UpgradeVersion          []*string               `json:"upgradeVersion,omitempty" xml:"upgradeVersion,omitempty" type:"Repeated"`
	UserId                  *string                 `json:"userId,omitempty" xml:"userId,omitempty"`
}

func (s GrafanaWorkspace) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspace) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspace) SetCommercial(v bool) *GrafanaWorkspace {
	s.Commercial = &v
	return s
}

func (s *GrafanaWorkspace) SetDeployType(v string) *GrafanaWorkspace {
	s.DeployType = &v
	return s
}

func (s *GrafanaWorkspace) SetDescription(v string) *GrafanaWorkspace {
	s.Description = &v
	return s
}

func (s *GrafanaWorkspace) SetEndTime(v float32) *GrafanaWorkspace {
	s.EndTime = &v
	return s
}

func (s *GrafanaWorkspace) SetGmtCreate(v float32) *GrafanaWorkspace {
	s.GmtCreate = &v
	return s
}

func (s *GrafanaWorkspace) SetGrafanaVersion(v string) *GrafanaWorkspace {
	s.GrafanaVersion = &v
	return s
}

func (s *GrafanaWorkspace) SetGrafanaWorkspaceDomain(v string) *GrafanaWorkspace {
	s.GrafanaWorkspaceDomain = &v
	return s
}

func (s *GrafanaWorkspace) SetGrafanaWorkspaceEdition(v string) *GrafanaWorkspace {
	s.GrafanaWorkspaceEdition = &v
	return s
}

func (s *GrafanaWorkspace) SetGrafanaWorkspaceId(v string) *GrafanaWorkspace {
	s.GrafanaWorkspaceId = &v
	return s
}

func (s *GrafanaWorkspace) SetGrafanaWorkspaceIp(v string) *GrafanaWorkspace {
	s.GrafanaWorkspaceIp = &v
	return s
}

func (s *GrafanaWorkspace) SetGrafanaWorkspaceName(v string) *GrafanaWorkspace {
	s.GrafanaWorkspaceName = &v
	return s
}

func (s *GrafanaWorkspace) SetMaxAccount(v string) *GrafanaWorkspace {
	s.MaxAccount = &v
	return s
}

func (s *GrafanaWorkspace) SetNtmId(v string) *GrafanaWorkspace {
	s.NtmId = &v
	return s
}

func (s *GrafanaWorkspace) SetPersonalDomain(v string) *GrafanaWorkspace {
	s.PersonalDomain = &v
	return s
}

func (s *GrafanaWorkspace) SetPersonalDomainPrefix(v string) *GrafanaWorkspace {
	s.PersonalDomainPrefix = &v
	return s
}

func (s *GrafanaWorkspace) SetPrivateDomain(v string) *GrafanaWorkspace {
	s.PrivateDomain = &v
	return s
}

func (s *GrafanaWorkspace) SetPrivateIp(v string) *GrafanaWorkspace {
	s.PrivateIp = &v
	return s
}

func (s *GrafanaWorkspace) SetProtocol(v string) *GrafanaWorkspace {
	s.Protocol = &v
	return s
}

func (s *GrafanaWorkspace) SetRegionId(v string) *GrafanaWorkspace {
	s.RegionId = &v
	return s
}

func (s *GrafanaWorkspace) SetResourceGroupId(v string) *GrafanaWorkspace {
	s.ResourceGroupId = &v
	return s
}

func (s *GrafanaWorkspace) SetShareSynced(v bool) *GrafanaWorkspace {
	s.ShareSynced = &v
	return s
}

func (s *GrafanaWorkspace) SetSnatIp(v string) *GrafanaWorkspace {
	s.SnatIp = &v
	return s
}

func (s *GrafanaWorkspace) SetStatus(v string) *GrafanaWorkspace {
	s.Status = &v
	return s
}

func (s *GrafanaWorkspace) SetTags(v []*GrafanaWorkspaceTags) *GrafanaWorkspace {
	s.Tags = v
	return s
}

func (s *GrafanaWorkspace) SetUpgradeVersion(v []*string) *GrafanaWorkspace {
	s.UpgradeVersion = v
	return s
}

func (s *GrafanaWorkspace) SetUserId(v string) *GrafanaWorkspace {
	s.UserId = &v
	return s
}

type GrafanaWorkspaceTags struct {
	Key   *string `json:"key,omitempty" xml:"key,omitempty"`
	Value *string `json:"value,omitempty" xml:"value,omitempty"`
}

func (s GrafanaWorkspaceTags) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceTags) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceTags) SetKey(v string) *GrafanaWorkspaceTags {
	s.Key = &v
	return s
}

func (s *GrafanaWorkspaceTags) SetValue(v string) *GrafanaWorkspaceTags {
	s.Value = &v
	return s
}

type GrafanaWorkspaceAccount struct {
	AccountId      *int64                     `json:"accountId,omitempty" xml:"accountId,omitempty"`
	AccountNotes   *string                    `json:"accountNotes,omitempty" xml:"accountNotes,omitempty"`
	AliyunUid      *string                    `json:"aliyunUid,omitempty" xml:"aliyunUid,omitempty"`
	AliyunUserName *string                    `json:"aliyunUserName,omitempty" xml:"aliyunUserName,omitempty"`
	GmtCreate      *float32                   `json:"gmtCreate,omitempty" xml:"gmtCreate,omitempty"`
	Orgs           []*GrafanaWorkspaceUserOrg `json:"orgs,omitempty" xml:"orgs,omitempty" type:"Repeated"`
	Type           *string                    `json:"type,omitempty" xml:"type,omitempty"`
}

func (s GrafanaWorkspaceAccount) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceAccount) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceAccount) SetAccountId(v int64) *GrafanaWorkspaceAccount {
	s.AccountId = &v
	return s
}

func (s *GrafanaWorkspaceAccount) SetAccountNotes(v string) *GrafanaWorkspaceAccount {
	s.AccountNotes = &v
	return s
}

func (s *GrafanaWorkspaceAccount) SetAliyunUid(v string) *GrafanaWorkspaceAccount {
	s.AliyunUid = &v
	return s
}

func (s *GrafanaWorkspaceAccount) SetAliyunUserName(v string) *GrafanaWorkspaceAccount {
	s.AliyunUserName = &v
	return s
}

func (s *GrafanaWorkspaceAccount) SetGmtCreate(v float32) *GrafanaWorkspaceAccount {
	s.GmtCreate = &v
	return s
}

func (s *GrafanaWorkspaceAccount) SetOrgs(v []*GrafanaWorkspaceUserOrg) *GrafanaWorkspaceAccount {
	s.Orgs = v
	return s
}

func (s *GrafanaWorkspaceAccount) SetType(v string) *GrafanaWorkspaceAccount {
	s.Type = &v
	return s
}

type GrafanaWorkspaceAlertNotification struct {
	Id           *int64  `json:"id,omitempty" xml:"id,omitempty"`
	IsArms       *bool   `json:"isArms,omitempty" xml:"isArms,omitempty"`
	IsDefault    *bool   `json:"isDefault,omitempty" xml:"isDefault,omitempty"`
	Name         *string `json:"name,omitempty" xml:"name,omitempty"`
	SendReminder *bool   `json:"sendReminder,omitempty" xml:"sendReminder,omitempty"`
	Settings     *string `json:"settings,omitempty" xml:"settings,omitempty"`
	Type         *string `json:"type,omitempty" xml:"type,omitempty"`
	Uid          *string `json:"uid,omitempty" xml:"uid,omitempty"`
}

func (s GrafanaWorkspaceAlertNotification) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceAlertNotification) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceAlertNotification) SetId(v int64) *GrafanaWorkspaceAlertNotification {
	s.Id = &v
	return s
}

func (s *GrafanaWorkspaceAlertNotification) SetIsArms(v bool) *GrafanaWorkspaceAlertNotification {
	s.IsArms = &v
	return s
}

func (s *GrafanaWorkspaceAlertNotification) SetIsDefault(v bool) *GrafanaWorkspaceAlertNotification {
	s.IsDefault = &v
	return s
}

func (s *GrafanaWorkspaceAlertNotification) SetName(v string) *GrafanaWorkspaceAlertNotification {
	s.Name = &v
	return s
}

func (s *GrafanaWorkspaceAlertNotification) SetSendReminder(v bool) *GrafanaWorkspaceAlertNotification {
	s.SendReminder = &v
	return s
}

func (s *GrafanaWorkspaceAlertNotification) SetSettings(v string) *GrafanaWorkspaceAlertNotification {
	s.Settings = &v
	return s
}

func (s *GrafanaWorkspaceAlertNotification) SetType(v string) *GrafanaWorkspaceAlertNotification {
	s.Type = &v
	return s
}

func (s *GrafanaWorkspaceAlertNotification) SetUid(v string) *GrafanaWorkspaceAlertNotification {
	s.Uid = &v
	return s
}

type GrafanaWorkspaceArmsAlertConfig struct {
	ArmsAlertsEnable     *string `json:"armsAlertsEnable,omitempty" xml:"armsAlertsEnable,omitempty"`
	ArmsAlertsWebhookUrl *string `json:"armsAlertsWebhookUrl,omitempty" xml:"armsAlertsWebhookUrl,omitempty"`
}

func (s GrafanaWorkspaceArmsAlertConfig) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceArmsAlertConfig) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceArmsAlertConfig) SetArmsAlertsEnable(v string) *GrafanaWorkspaceArmsAlertConfig {
	s.ArmsAlertsEnable = &v
	return s
}

func (s *GrafanaWorkspaceArmsAlertConfig) SetArmsAlertsWebhookUrl(v string) *GrafanaWorkspaceArmsAlertConfig {
	s.ArmsAlertsWebhookUrl = &v
	return s
}

type GrafanaWorkspaceCustomDomain struct {
	Cert               *string `json:"cert,omitempty" xml:"cert,omitempty"`
	Date               *int64  `json:"date,omitempty" xml:"date,omitempty"`
	Domain             *string `json:"domain,omitempty" xml:"domain,omitempty"`
	GrafanaWorkspaceId *string `json:"grafanaWorkspaceId,omitempty" xml:"grafanaWorkspaceId,omitempty"`
	Id                 *int64  `json:"id,omitempty" xml:"id,omitempty"`
	Key                *string `json:"key,omitempty" xml:"key,omitempty"`
	PrivateZone        *string `json:"privateZone,omitempty" xml:"privateZone,omitempty"`
	Protocol           *string `json:"protocol,omitempty" xml:"protocol,omitempty"`
	Status             *string `json:"status,omitempty" xml:"status,omitempty"`
	Uri                *string `json:"uri,omitempty" xml:"uri,omitempty"`
}

func (s GrafanaWorkspaceCustomDomain) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceCustomDomain) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceCustomDomain) SetCert(v string) *GrafanaWorkspaceCustomDomain {
	s.Cert = &v
	return s
}

func (s *GrafanaWorkspaceCustomDomain) SetDate(v int64) *GrafanaWorkspaceCustomDomain {
	s.Date = &v
	return s
}

func (s *GrafanaWorkspaceCustomDomain) SetDomain(v string) *GrafanaWorkspaceCustomDomain {
	s.Domain = &v
	return s
}

func (s *GrafanaWorkspaceCustomDomain) SetGrafanaWorkspaceId(v string) *GrafanaWorkspaceCustomDomain {
	s.GrafanaWorkspaceId = &v
	return s
}

func (s *GrafanaWorkspaceCustomDomain) SetId(v int64) *GrafanaWorkspaceCustomDomain {
	s.Id = &v
	return s
}

func (s *GrafanaWorkspaceCustomDomain) SetKey(v string) *GrafanaWorkspaceCustomDomain {
	s.Key = &v
	return s
}

func (s *GrafanaWorkspaceCustomDomain) SetPrivateZone(v string) *GrafanaWorkspaceCustomDomain {
	s.PrivateZone = &v
	return s
}

func (s *GrafanaWorkspaceCustomDomain) SetProtocol(v string) *GrafanaWorkspaceCustomDomain {
	s.Protocol = &v
	return s
}

func (s *GrafanaWorkspaceCustomDomain) SetStatus(v string) *GrafanaWorkspaceCustomDomain {
	s.Status = &v
	return s
}

func (s *GrafanaWorkspaceCustomDomain) SetUri(v string) *GrafanaWorkspaceCustomDomain {
	s.Uri = &v
	return s
}

type GrafanaWorkspaceDashboardReport struct {
	GmtCreate           *int64  `json:"gmtCreate,omitempty" xml:"gmtCreate,omitempty"`
	GrafanaWorkspaceId  *string `json:"grafanaWorkspaceId,omitempty" xml:"grafanaWorkspaceId,omitempty"`
	Id                  *int64  `json:"id,omitempty" xml:"id,omitempty"`
	LastSendTime        *int64  `json:"lastSendTime,omitempty" xml:"lastSendTime,omitempty"`
	Msg                 *string `json:"msg,omitempty" xml:"msg,omitempty"`
	Name                *string `json:"name,omitempty" xml:"name,omitempty"`
	ReportChannelTarget *string `json:"reportChannelTarget,omitempty" xml:"reportChannelTarget,omitempty"`
	ReportChannelType   *string `json:"reportChannelType,omitempty" xml:"reportChannelType,omitempty"`
	ReportStyle         *string `json:"reportStyle,omitempty" xml:"reportStyle,omitempty"`
	ReportType          *string `json:"reportType,omitempty" xml:"reportType,omitempty"`
	Status              *string `json:"status,omitempty" xml:"status,omitempty"`
	TriggerDay          *string `json:"triggerDay,omitempty" xml:"triggerDay,omitempty"`
	TriggerTime         *string `json:"triggerTime,omitempty" xml:"triggerTime,omitempty"`
	TriggerType         *string `json:"triggerType,omitempty" xml:"triggerType,omitempty"`
	Url                 *string `json:"url,omitempty" xml:"url,omitempty"`
	UserId              *string `json:"userId,omitempty" xml:"userId,omitempty"`
}

func (s GrafanaWorkspaceDashboardReport) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceDashboardReport) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceDashboardReport) SetGmtCreate(v int64) *GrafanaWorkspaceDashboardReport {
	s.GmtCreate = &v
	return s
}

func (s *GrafanaWorkspaceDashboardReport) SetGrafanaWorkspaceId(v string) *GrafanaWorkspaceDashboardReport {
	s.GrafanaWorkspaceId = &v
	return s
}

func (s *GrafanaWorkspaceDashboardReport) SetId(v int64) *GrafanaWorkspaceDashboardReport {
	s.Id = &v
	return s
}

func (s *GrafanaWorkspaceDashboardReport) SetLastSendTime(v int64) *GrafanaWorkspaceDashboardReport {
	s.LastSendTime = &v
	return s
}

func (s *GrafanaWorkspaceDashboardReport) SetMsg(v string) *GrafanaWorkspaceDashboardReport {
	s.Msg = &v
	return s
}

func (s *GrafanaWorkspaceDashboardReport) SetName(v string) *GrafanaWorkspaceDashboardReport {
	s.Name = &v
	return s
}

func (s *GrafanaWorkspaceDashboardReport) SetReportChannelTarget(v string) *GrafanaWorkspaceDashboardReport {
	s.ReportChannelTarget = &v
	return s
}

func (s *GrafanaWorkspaceDashboardReport) SetReportChannelType(v string) *GrafanaWorkspaceDashboardReport {
	s.ReportChannelType = &v
	return s
}

func (s *GrafanaWorkspaceDashboardReport) SetReportStyle(v string) *GrafanaWorkspaceDashboardReport {
	s.ReportStyle = &v
	return s
}

func (s *GrafanaWorkspaceDashboardReport) SetReportType(v string) *GrafanaWorkspaceDashboardReport {
	s.ReportType = &v
	return s
}

func (s *GrafanaWorkspaceDashboardReport) SetStatus(v string) *GrafanaWorkspaceDashboardReport {
	s.Status = &v
	return s
}

func (s *GrafanaWorkspaceDashboardReport) SetTriggerDay(v string) *GrafanaWorkspaceDashboardReport {
	s.TriggerDay = &v
	return s
}

func (s *GrafanaWorkspaceDashboardReport) SetTriggerTime(v string) *GrafanaWorkspaceDashboardReport {
	s.TriggerTime = &v
	return s
}

func (s *GrafanaWorkspaceDashboardReport) SetTriggerType(v string) *GrafanaWorkspaceDashboardReport {
	s.TriggerType = &v
	return s
}

func (s *GrafanaWorkspaceDashboardReport) SetUrl(v string) *GrafanaWorkspaceDashboardReport {
	s.Url = &v
	return s
}

func (s *GrafanaWorkspaceDashboardReport) SetUserId(v string) *GrafanaWorkspaceDashboardReport {
	s.UserId = &v
	return s
}

type GrafanaWorkspaceDashboardSync struct {
	DashboardTitle *string `json:"dashboardTitle,omitempty" xml:"dashboardTitle,omitempty"`
	DashboardURL   *string `json:"dashboardURL,omitempty" xml:"dashboardURL,omitempty"`
	DashboardUid   *string `json:"dashboardUid,omitempty" xml:"dashboardUid,omitempty"`
	FolderId       *string `json:"folderId,omitempty" xml:"folderId,omitempty"`
	FolderTitle    *string `json:"folderTitle,omitempty" xml:"folderTitle,omitempty"`
	FolderURL      *string `json:"folderURL,omitempty" xml:"folderURL,omitempty"`
	FolderUid      *string `json:"folderUid,omitempty" xml:"folderUid,omitempty"`
	OrgId          *string `json:"orgId,omitempty" xml:"orgId,omitempty"`
	OrgName        *string `json:"orgName,omitempty" xml:"orgName,omitempty"`
	Type           *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s GrafanaWorkspaceDashboardSync) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceDashboardSync) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceDashboardSync) SetDashboardTitle(v string) *GrafanaWorkspaceDashboardSync {
	s.DashboardTitle = &v
	return s
}

func (s *GrafanaWorkspaceDashboardSync) SetDashboardURL(v string) *GrafanaWorkspaceDashboardSync {
	s.DashboardURL = &v
	return s
}

func (s *GrafanaWorkspaceDashboardSync) SetDashboardUid(v string) *GrafanaWorkspaceDashboardSync {
	s.DashboardUid = &v
	return s
}

func (s *GrafanaWorkspaceDashboardSync) SetFolderId(v string) *GrafanaWorkspaceDashboardSync {
	s.FolderId = &v
	return s
}

func (s *GrafanaWorkspaceDashboardSync) SetFolderTitle(v string) *GrafanaWorkspaceDashboardSync {
	s.FolderTitle = &v
	return s
}

func (s *GrafanaWorkspaceDashboardSync) SetFolderURL(v string) *GrafanaWorkspaceDashboardSync {
	s.FolderURL = &v
	return s
}

func (s *GrafanaWorkspaceDashboardSync) SetFolderUid(v string) *GrafanaWorkspaceDashboardSync {
	s.FolderUid = &v
	return s
}

func (s *GrafanaWorkspaceDashboardSync) SetOrgId(v string) *GrafanaWorkspaceDashboardSync {
	s.OrgId = &v
	return s
}

func (s *GrafanaWorkspaceDashboardSync) SetOrgName(v string) *GrafanaWorkspaceDashboardSync {
	s.OrgName = &v
	return s
}

func (s *GrafanaWorkspaceDashboardSync) SetType(v string) *GrafanaWorkspaceDashboardSync {
	s.Type = &v
	return s
}

type GrafanaWorkspaceDataBackup struct {
	GmtCreate          *int64  `json:"gmtCreate,omitempty" xml:"gmtCreate,omitempty"`
	GmtModified        *int64  `json:"gmtModified,omitempty" xml:"gmtModified,omitempty"`
	GrafanaWorkspaceId *string `json:"grafanaWorkspaceId,omitempty" xml:"grafanaWorkspaceId,omitempty"`
	Id                 *int64  `json:"id,omitempty" xml:"id,omitempty"`
	Msg                *string `json:"msg,omitempty" xml:"msg,omitempty"`
	ProcessName        *string `json:"processName,omitempty" xml:"processName,omitempty"`
	ProcessStatus      *string `json:"processStatus,omitempty" xml:"processStatus,omitempty"`
	SubType            *string `json:"subType,omitempty" xml:"subType,omitempty"`
	UserId             *string `json:"userId,omitempty" xml:"userId,omitempty"`
}

func (s GrafanaWorkspaceDataBackup) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceDataBackup) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceDataBackup) SetGmtCreate(v int64) *GrafanaWorkspaceDataBackup {
	s.GmtCreate = &v
	return s
}

func (s *GrafanaWorkspaceDataBackup) SetGmtModified(v int64) *GrafanaWorkspaceDataBackup {
	s.GmtModified = &v
	return s
}

func (s *GrafanaWorkspaceDataBackup) SetGrafanaWorkspaceId(v string) *GrafanaWorkspaceDataBackup {
	s.GrafanaWorkspaceId = &v
	return s
}

func (s *GrafanaWorkspaceDataBackup) SetId(v int64) *GrafanaWorkspaceDataBackup {
	s.Id = &v
	return s
}

func (s *GrafanaWorkspaceDataBackup) SetMsg(v string) *GrafanaWorkspaceDataBackup {
	s.Msg = &v
	return s
}

func (s *GrafanaWorkspaceDataBackup) SetProcessName(v string) *GrafanaWorkspaceDataBackup {
	s.ProcessName = &v
	return s
}

func (s *GrafanaWorkspaceDataBackup) SetProcessStatus(v string) *GrafanaWorkspaceDataBackup {
	s.ProcessStatus = &v
	return s
}

func (s *GrafanaWorkspaceDataBackup) SetSubType(v string) *GrafanaWorkspaceDataBackup {
	s.SubType = &v
	return s
}

func (s *GrafanaWorkspaceDataBackup) SetUserId(v string) *GrafanaWorkspaceDataBackup {
	s.UserId = &v
	return s
}

type GrafanaWorkspaceIniBackup struct {
	Ext                *string `json:"ext,omitempty" xml:"ext,omitempty"`
	GmtCreate          *int64  `json:"gmtCreate,omitempty" xml:"gmtCreate,omitempty"`
	GmtModified        *int64  `json:"gmtModified,omitempty" xml:"gmtModified,omitempty"`
	GrafanaWorkspaceId *string `json:"grafanaWorkspaceId,omitempty" xml:"grafanaWorkspaceId,omitempty"`
	Id                 *int64  `json:"id,omitempty" xml:"id,omitempty"`
	Msg                *string `json:"msg,omitempty" xml:"msg,omitempty"`
	ProcessName        *string `json:"processName,omitempty" xml:"processName,omitempty"`
	ProcessStatus      *string `json:"processStatus,omitempty" xml:"processStatus,omitempty"`
	SubType            *string `json:"subType,omitempty" xml:"subType,omitempty"`
	UserId             *string `json:"userId,omitempty" xml:"userId,omitempty"`
}

func (s GrafanaWorkspaceIniBackup) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceIniBackup) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceIniBackup) SetExt(v string) *GrafanaWorkspaceIniBackup {
	s.Ext = &v
	return s
}

func (s *GrafanaWorkspaceIniBackup) SetGmtCreate(v int64) *GrafanaWorkspaceIniBackup {
	s.GmtCreate = &v
	return s
}

func (s *GrafanaWorkspaceIniBackup) SetGmtModified(v int64) *GrafanaWorkspaceIniBackup {
	s.GmtModified = &v
	return s
}

func (s *GrafanaWorkspaceIniBackup) SetGrafanaWorkspaceId(v string) *GrafanaWorkspaceIniBackup {
	s.GrafanaWorkspaceId = &v
	return s
}

func (s *GrafanaWorkspaceIniBackup) SetId(v int64) *GrafanaWorkspaceIniBackup {
	s.Id = &v
	return s
}

func (s *GrafanaWorkspaceIniBackup) SetMsg(v string) *GrafanaWorkspaceIniBackup {
	s.Msg = &v
	return s
}

func (s *GrafanaWorkspaceIniBackup) SetProcessName(v string) *GrafanaWorkspaceIniBackup {
	s.ProcessName = &v
	return s
}

func (s *GrafanaWorkspaceIniBackup) SetProcessStatus(v string) *GrafanaWorkspaceIniBackup {
	s.ProcessStatus = &v
	return s
}

func (s *GrafanaWorkspaceIniBackup) SetSubType(v string) *GrafanaWorkspaceIniBackup {
	s.SubType = &v
	return s
}

func (s *GrafanaWorkspaceIniBackup) SetUserId(v string) *GrafanaWorkspaceIniBackup {
	s.UserId = &v
	return s
}

type GrafanaWorkspaceIniProperty struct {
	DefaultValue *string `json:"defaultValue,omitempty" xml:"defaultValue,omitempty"`
	Description  *string `json:"description,omitempty" xml:"description,omitempty"`
	Example      *string `json:"example,omitempty" xml:"example,omitempty"`
	Key          *string `json:"key,omitempty" xml:"key,omitempty"`
	Secret       *bool   `json:"secret,omitempty" xml:"secret,omitempty"`
	Value        *string `json:"value,omitempty" xml:"value,omitempty"`
}

func (s GrafanaWorkspaceIniProperty) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceIniProperty) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceIniProperty) SetDefaultValue(v string) *GrafanaWorkspaceIniProperty {
	s.DefaultValue = &v
	return s
}

func (s *GrafanaWorkspaceIniProperty) SetDescription(v string) *GrafanaWorkspaceIniProperty {
	s.Description = &v
	return s
}

func (s *GrafanaWorkspaceIniProperty) SetExample(v string) *GrafanaWorkspaceIniProperty {
	s.Example = &v
	return s
}

func (s *GrafanaWorkspaceIniProperty) SetKey(v string) *GrafanaWorkspaceIniProperty {
	s.Key = &v
	return s
}

func (s *GrafanaWorkspaceIniProperty) SetSecret(v bool) *GrafanaWorkspaceIniProperty {
	s.Secret = &v
	return s
}

func (s *GrafanaWorkspaceIniProperty) SetValue(v string) *GrafanaWorkspaceIniProperty {
	s.Value = &v
	return s
}

type GrafanaWorkspaceIniSection struct {
	Propertys []*GrafanaWorkspaceIniProperty `json:"propertys,omitempty" xml:"propertys,omitempty" type:"Repeated"`
	Section   *string                        `json:"section,omitempty" xml:"section,omitempty"`
}

func (s GrafanaWorkspaceIniSection) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceIniSection) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceIniSection) SetPropertys(v []*GrafanaWorkspaceIniProperty) *GrafanaWorkspaceIniSection {
	s.Propertys = v
	return s
}

func (s *GrafanaWorkspaceIniSection) SetSection(v string) *GrafanaWorkspaceIniSection {
	s.Section = &v
	return s
}

type GrafanaWorkspaceIntegration struct {
	DatasourceAmount *int64                                `json:"datasourceAmount,omitempty" xml:"datasourceAmount,omitempty"`
	IntegrationId    *string                               `json:"integrationId,omitempty" xml:"integrationId,omitempty"`
	IntegrationName  *string                               `json:"integrationName,omitempty" xml:"integrationName,omitempty"`
	Previews         []*GrafanaWorkspaceIntegrationPreview `json:"previews,omitempty" xml:"previews,omitempty" type:"Repeated"`
	Status           *string                               `json:"status,omitempty" xml:"status,omitempty"`
	SupportRegions   []*string                             `json:"supportRegions,omitempty" xml:"supportRegions,omitempty" type:"Repeated"`
}

func (s GrafanaWorkspaceIntegration) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceIntegration) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceIntegration) SetDatasourceAmount(v int64) *GrafanaWorkspaceIntegration {
	s.DatasourceAmount = &v
	return s
}

func (s *GrafanaWorkspaceIntegration) SetIntegrationId(v string) *GrafanaWorkspaceIntegration {
	s.IntegrationId = &v
	return s
}

func (s *GrafanaWorkspaceIntegration) SetIntegrationName(v string) *GrafanaWorkspaceIntegration {
	s.IntegrationName = &v
	return s
}

func (s *GrafanaWorkspaceIntegration) SetPreviews(v []*GrafanaWorkspaceIntegrationPreview) *GrafanaWorkspaceIntegration {
	s.Previews = v
	return s
}

func (s *GrafanaWorkspaceIntegration) SetStatus(v string) *GrafanaWorkspaceIntegration {
	s.Status = &v
	return s
}

func (s *GrafanaWorkspaceIntegration) SetSupportRegions(v []*string) *GrafanaWorkspaceIntegration {
	s.SupportRegions = v
	return s
}

type GrafanaWorkspaceIntegrationDataSource struct {
	ClusterType    *string `json:"clusterType,omitempty" xml:"clusterType,omitempty"`
	DatasourceId   *string `json:"datasourceId,omitempty" xml:"datasourceId,omitempty"`
	DatasourceName *string `json:"datasourceName,omitempty" xml:"datasourceName,omitempty"`
	DatasourceUrl  *string `json:"datasourceUrl,omitempty" xml:"datasourceUrl,omitempty"`
	Description    *string `json:"description,omitempty" xml:"description,omitempty"`
	ExploreUrl     *string `json:"exploreUrl,omitempty" xml:"exploreUrl,omitempty"`
	FolderUrl      *string `json:"folderUrl,omitempty" xml:"folderUrl,omitempty"`
	RegionId       *string `json:"regionId,omitempty" xml:"regionId,omitempty"`
	Status         *string `json:"status,omitempty" xml:"status,omitempty"`
	Type           *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s GrafanaWorkspaceIntegrationDataSource) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceIntegrationDataSource) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceIntegrationDataSource) SetClusterType(v string) *GrafanaWorkspaceIntegrationDataSource {
	s.ClusterType = &v
	return s
}

func (s *GrafanaWorkspaceIntegrationDataSource) SetDatasourceId(v string) *GrafanaWorkspaceIntegrationDataSource {
	s.DatasourceId = &v
	return s
}

func (s *GrafanaWorkspaceIntegrationDataSource) SetDatasourceName(v string) *GrafanaWorkspaceIntegrationDataSource {
	s.DatasourceName = &v
	return s
}

func (s *GrafanaWorkspaceIntegrationDataSource) SetDatasourceUrl(v string) *GrafanaWorkspaceIntegrationDataSource {
	s.DatasourceUrl = &v
	return s
}

func (s *GrafanaWorkspaceIntegrationDataSource) SetDescription(v string) *GrafanaWorkspaceIntegrationDataSource {
	s.Description = &v
	return s
}

func (s *GrafanaWorkspaceIntegrationDataSource) SetExploreUrl(v string) *GrafanaWorkspaceIntegrationDataSource {
	s.ExploreUrl = &v
	return s
}

func (s *GrafanaWorkspaceIntegrationDataSource) SetFolderUrl(v string) *GrafanaWorkspaceIntegrationDataSource {
	s.FolderUrl = &v
	return s
}

func (s *GrafanaWorkspaceIntegrationDataSource) SetRegionId(v string) *GrafanaWorkspaceIntegrationDataSource {
	s.RegionId = &v
	return s
}

func (s *GrafanaWorkspaceIntegrationDataSource) SetStatus(v string) *GrafanaWorkspaceIntegrationDataSource {
	s.Status = &v
	return s
}

func (s *GrafanaWorkspaceIntegrationDataSource) SetType(v string) *GrafanaWorkspaceIntegrationDataSource {
	s.Type = &v
	return s
}

type GrafanaWorkspaceIntegrationDetail struct {
	DataSources   []*GrafanaWorkspaceIntegrationDataSource `json:"dataSources,omitempty" xml:"dataSources,omitempty" type:"Repeated"`
	IntegrationId *string                                  `json:"integrationId,omitempty" xml:"integrationId,omitempty"`
	Status        *string                                  `json:"status,omitempty" xml:"status,omitempty"`
}

func (s GrafanaWorkspaceIntegrationDetail) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceIntegrationDetail) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceIntegrationDetail) SetDataSources(v []*GrafanaWorkspaceIntegrationDataSource) *GrafanaWorkspaceIntegrationDetail {
	s.DataSources = v
	return s
}

func (s *GrafanaWorkspaceIntegrationDetail) SetIntegrationId(v string) *GrafanaWorkspaceIntegrationDetail {
	s.IntegrationId = &v
	return s
}

func (s *GrafanaWorkspaceIntegrationDetail) SetStatus(v string) *GrafanaWorkspaceIntegrationDetail {
	s.Status = &v
	return s
}

type GrafanaWorkspaceIntegrationPreview struct {
	Id        *string `json:"id,omitempty" xml:"id,omitempty"`
	Image     *string `json:"image,omitempty" xml:"image,omitempty"`
	Name      *string `json:"name,omitempty" xml:"name,omitempty"`
	Thumbnail *string `json:"thumbnail,omitempty" xml:"thumbnail,omitempty"`
}

func (s GrafanaWorkspaceIntegrationPreview) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceIntegrationPreview) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceIntegrationPreview) SetId(v string) *GrafanaWorkspaceIntegrationPreview {
	s.Id = &v
	return s
}

func (s *GrafanaWorkspaceIntegrationPreview) SetImage(v string) *GrafanaWorkspaceIntegrationPreview {
	s.Image = &v
	return s
}

func (s *GrafanaWorkspaceIntegrationPreview) SetName(v string) *GrafanaWorkspaceIntegrationPreview {
	s.Name = &v
	return s
}

func (s *GrafanaWorkspaceIntegrationPreview) SetThumbnail(v string) *GrafanaWorkspaceIntegrationPreview {
	s.Thumbnail = &v
	return s
}

type GrafanaWorkspaceMoveProcess struct {
	GmtCreate          *int64  `json:"gmtCreate,omitempty" xml:"gmtCreate,omitempty"`
	GmtModified        *int64  `json:"gmtModified,omitempty" xml:"gmtModified,omitempty"`
	GrafanaWorkspaceId *string `json:"grafanaWorkspaceId,omitempty" xml:"grafanaWorkspaceId,omitempty"`
	Id                 *int64  `json:"id,omitempty" xml:"id,omitempty"`
	Msg                *string `json:"msg,omitempty" xml:"msg,omitempty"`
	ProcessName        *string `json:"processName,omitempty" xml:"processName,omitempty"`
	ProcessStatus      *string `json:"processStatus,omitempty" xml:"processStatus,omitempty"`
	SubType            *string `json:"subType,omitempty" xml:"subType,omitempty"`
	UserId             *string `json:"userId,omitempty" xml:"userId,omitempty"`
}

func (s GrafanaWorkspaceMoveProcess) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceMoveProcess) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceMoveProcess) SetGmtCreate(v int64) *GrafanaWorkspaceMoveProcess {
	s.GmtCreate = &v
	return s
}

func (s *GrafanaWorkspaceMoveProcess) SetGmtModified(v int64) *GrafanaWorkspaceMoveProcess {
	s.GmtModified = &v
	return s
}

func (s *GrafanaWorkspaceMoveProcess) SetGrafanaWorkspaceId(v string) *GrafanaWorkspaceMoveProcess {
	s.GrafanaWorkspaceId = &v
	return s
}

func (s *GrafanaWorkspaceMoveProcess) SetId(v int64) *GrafanaWorkspaceMoveProcess {
	s.Id = &v
	return s
}

func (s *GrafanaWorkspaceMoveProcess) SetMsg(v string) *GrafanaWorkspaceMoveProcess {
	s.Msg = &v
	return s
}

func (s *GrafanaWorkspaceMoveProcess) SetProcessName(v string) *GrafanaWorkspaceMoveProcess {
	s.ProcessName = &v
	return s
}

func (s *GrafanaWorkspaceMoveProcess) SetProcessStatus(v string) *GrafanaWorkspaceMoveProcess {
	s.ProcessStatus = &v
	return s
}

func (s *GrafanaWorkspaceMoveProcess) SetSubType(v string) *GrafanaWorkspaceMoveProcess {
	s.SubType = &v
	return s
}

func (s *GrafanaWorkspaceMoveProcess) SetUserId(v string) *GrafanaWorkspaceMoveProcess {
	s.UserId = &v
	return s
}

type GrafanaWorkspaceNews struct {
	Date        *int64  `json:"date,omitempty" xml:"date,omitempty"`
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	Image       *string `json:"image,omitempty" xml:"image,omitempty"`
	Link        *string `json:"link,omitempty" xml:"link,omitempty"`
	Title       *string `json:"title,omitempty" xml:"title,omitempty"`
}

func (s GrafanaWorkspaceNews) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceNews) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceNews) SetDate(v int64) *GrafanaWorkspaceNews {
	s.Date = &v
	return s
}

func (s *GrafanaWorkspaceNews) SetDescription(v string) *GrafanaWorkspaceNews {
	s.Description = &v
	return s
}

func (s *GrafanaWorkspaceNews) SetImage(v string) *GrafanaWorkspaceNews {
	s.Image = &v
	return s
}

func (s *GrafanaWorkspaceNews) SetLink(v string) *GrafanaWorkspaceNews {
	s.Link = &v
	return s
}

func (s *GrafanaWorkspaceNews) SetTitle(v string) *GrafanaWorkspaceNews {
	s.Title = &v
	return s
}

type GrafanaWorkspaceOperateLog struct {
	Date               *float32 `json:"date,omitempty" xml:"date,omitempty"`
	Detail             *string  `json:"detail,omitempty" xml:"detail,omitempty"`
	GrafanaWorkspaceId *string  `json:"grafanaWorkspaceId,omitempty" xml:"grafanaWorkspaceId,omitempty"`
	Id                 *int64   `json:"id,omitempty" xml:"id,omitempty"`
	OperatorId         *string  `json:"operatorId,omitempty" xml:"operatorId,omitempty"`
}

func (s GrafanaWorkspaceOperateLog) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceOperateLog) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceOperateLog) SetDate(v float32) *GrafanaWorkspaceOperateLog {
	s.Date = &v
	return s
}

func (s *GrafanaWorkspaceOperateLog) SetDetail(v string) *GrafanaWorkspaceOperateLog {
	s.Detail = &v
	return s
}

func (s *GrafanaWorkspaceOperateLog) SetGrafanaWorkspaceId(v string) *GrafanaWorkspaceOperateLog {
	s.GrafanaWorkspaceId = &v
	return s
}

func (s *GrafanaWorkspaceOperateLog) SetId(v int64) *GrafanaWorkspaceOperateLog {
	s.Id = &v
	return s
}

func (s *GrafanaWorkspaceOperateLog) SetOperatorId(v string) *GrafanaWorkspaceOperateLog {
	s.OperatorId = &v
	return s
}

type GrafanaWorkspaceOrg struct {
	Id   *int64  `json:"id,omitempty" xml:"id,omitempty"`
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
}

func (s GrafanaWorkspaceOrg) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceOrg) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceOrg) SetId(v int64) *GrafanaWorkspaceOrg {
	s.Id = &v
	return s
}

func (s *GrafanaWorkspaceOrg) SetName(v string) *GrafanaWorkspaceOrg {
	s.Name = &v
	return s
}

type GrafanaWorkspaceTrans struct {
	ApiUrl             *string                        `json:"apiUrl,omitempty" xml:"apiUrl,omitempty"`
	AuthType           *string                        `json:"authType,omitempty" xml:"authType,omitempty"`
	GmtCreate          *float32                       `json:"gmtCreate,omitempty" xml:"gmtCreate,omitempty"`
	GmtModified        *float32                       `json:"gmtModified,omitempty" xml:"gmtModified,omitempty"`
	GrafanaWorkspaceId *string                        `json:"grafanaWorkspaceId,omitempty" xml:"grafanaWorkspaceId,omitempty"`
	Id                 *int64                         `json:"id,omitempty" xml:"id,omitempty"`
	Msg                *string                        `json:"msg,omitempty" xml:"msg,omitempty"`
	ProcessStatus      *string                        `json:"processStatus,omitempty" xml:"processStatus,omitempty"`
	TransDetails       []*GrafanaWorkspaceTransDetail `json:"transDetails,omitempty" xml:"transDetails,omitempty" type:"Repeated"`
	UserId             *string                        `json:"userId,omitempty" xml:"userId,omitempty"`
}

func (s GrafanaWorkspaceTrans) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceTrans) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceTrans) SetApiUrl(v string) *GrafanaWorkspaceTrans {
	s.ApiUrl = &v
	return s
}

func (s *GrafanaWorkspaceTrans) SetAuthType(v string) *GrafanaWorkspaceTrans {
	s.AuthType = &v
	return s
}

func (s *GrafanaWorkspaceTrans) SetGmtCreate(v float32) *GrafanaWorkspaceTrans {
	s.GmtCreate = &v
	return s
}

func (s *GrafanaWorkspaceTrans) SetGmtModified(v float32) *GrafanaWorkspaceTrans {
	s.GmtModified = &v
	return s
}

func (s *GrafanaWorkspaceTrans) SetGrafanaWorkspaceId(v string) *GrafanaWorkspaceTrans {
	s.GrafanaWorkspaceId = &v
	return s
}

func (s *GrafanaWorkspaceTrans) SetId(v int64) *GrafanaWorkspaceTrans {
	s.Id = &v
	return s
}

func (s *GrafanaWorkspaceTrans) SetMsg(v string) *GrafanaWorkspaceTrans {
	s.Msg = &v
	return s
}

func (s *GrafanaWorkspaceTrans) SetProcessStatus(v string) *GrafanaWorkspaceTrans {
	s.ProcessStatus = &v
	return s
}

func (s *GrafanaWorkspaceTrans) SetTransDetails(v []*GrafanaWorkspaceTransDetail) *GrafanaWorkspaceTrans {
	s.TransDetails = v
	return s
}

func (s *GrafanaWorkspaceTrans) SetUserId(v string) *GrafanaWorkspaceTrans {
	s.UserId = &v
	return s
}

type GrafanaWorkspaceTransDetail struct {
	DashboardAmount  *int32  `json:"dashboardAmount,omitempty" xml:"dashboardAmount,omitempty"`
	DataSourceAmount *int32  `json:"dataSourceAmount,omitempty" xml:"dataSourceAmount,omitempty"`
	Original         *int64  `json:"original,omitempty" xml:"original,omitempty"`
	OriginalName     *string `json:"originalName,omitempty" xml:"originalName,omitempty"`
	Target           *int64  `json:"target,omitempty" xml:"target,omitempty"`
	TargetName       *string `json:"targetName,omitempty" xml:"targetName,omitempty"`
}

func (s GrafanaWorkspaceTransDetail) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceTransDetail) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceTransDetail) SetDashboardAmount(v int32) *GrafanaWorkspaceTransDetail {
	s.DashboardAmount = &v
	return s
}

func (s *GrafanaWorkspaceTransDetail) SetDataSourceAmount(v int32) *GrafanaWorkspaceTransDetail {
	s.DataSourceAmount = &v
	return s
}

func (s *GrafanaWorkspaceTransDetail) SetOriginal(v int64) *GrafanaWorkspaceTransDetail {
	s.Original = &v
	return s
}

func (s *GrafanaWorkspaceTransDetail) SetOriginalName(v string) *GrafanaWorkspaceTransDetail {
	s.OriginalName = &v
	return s
}

func (s *GrafanaWorkspaceTransDetail) SetTarget(v int64) *GrafanaWorkspaceTransDetail {
	s.Target = &v
	return s
}

func (s *GrafanaWorkspaceTransDetail) SetTargetName(v string) *GrafanaWorkspaceTransDetail {
	s.TargetName = &v
	return s
}

type GrafanaWorkspaceUserCert struct {
	Id   *string `json:"id,omitempty" xml:"id,omitempty"`
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
}

func (s GrafanaWorkspaceUserCert) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceUserCert) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceUserCert) SetId(v string) *GrafanaWorkspaceUserCert {
	s.Id = &v
	return s
}

func (s *GrafanaWorkspaceUserCert) SetName(v string) *GrafanaWorkspaceUserCert {
	s.Name = &v
	return s
}

type GrafanaWorkspaceUserOrg struct {
	OrgId   *int64  `json:"orgId,omitempty" xml:"orgId,omitempty"`
	OrgName *string `json:"orgName,omitempty" xml:"orgName,omitempty"`
	Role    *string `json:"role,omitempty" xml:"role,omitempty"`
}

func (s GrafanaWorkspaceUserOrg) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceUserOrg) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceUserOrg) SetOrgId(v int64) *GrafanaWorkspaceUserOrg {
	s.OrgId = &v
	return s
}

func (s *GrafanaWorkspaceUserOrg) SetOrgName(v string) *GrafanaWorkspaceUserOrg {
	s.OrgName = &v
	return s
}

func (s *GrafanaWorkspaceUserOrg) SetRole(v string) *GrafanaWorkspaceUserOrg {
	s.Role = &v
	return s
}

type GrafanaWorkspaceVpcConfig struct {
	FcConfig        *string `json:"fcConfig,omitempty" xml:"fcConfig,omitempty"`
	Id              *int64  `json:"id,omitempty" xml:"id,omitempty"`
	InstallMsg      *string `json:"installMsg,omitempty" xml:"installMsg,omitempty"`
	InstallStatus   *string `json:"installStatus,omitempty" xml:"installStatus,omitempty"`
	Name            *string `json:"name,omitempty" xml:"name,omitempty"`
	RegionId        *string `json:"regionId,omitempty" xml:"regionId,omitempty"`
	SecurityGroupId *string `json:"securityGroupId,omitempty" xml:"securityGroupId,omitempty"`
	UserId          *string `json:"userId,omitempty" xml:"userId,omitempty"`
	VSwitchId       *string `json:"vSwitchId,omitempty" xml:"vSwitchId,omitempty"`
	VpcId           *string `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
}

func (s GrafanaWorkspaceVpcConfig) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceVpcConfig) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceVpcConfig) SetFcConfig(v string) *GrafanaWorkspaceVpcConfig {
	s.FcConfig = &v
	return s
}

func (s *GrafanaWorkspaceVpcConfig) SetId(v int64) *GrafanaWorkspaceVpcConfig {
	s.Id = &v
	return s
}

func (s *GrafanaWorkspaceVpcConfig) SetInstallMsg(v string) *GrafanaWorkspaceVpcConfig {
	s.InstallMsg = &v
	return s
}

func (s *GrafanaWorkspaceVpcConfig) SetInstallStatus(v string) *GrafanaWorkspaceVpcConfig {
	s.InstallStatus = &v
	return s
}

func (s *GrafanaWorkspaceVpcConfig) SetName(v string) *GrafanaWorkspaceVpcConfig {
	s.Name = &v
	return s
}

func (s *GrafanaWorkspaceVpcConfig) SetRegionId(v string) *GrafanaWorkspaceVpcConfig {
	s.RegionId = &v
	return s
}

func (s *GrafanaWorkspaceVpcConfig) SetSecurityGroupId(v string) *GrafanaWorkspaceVpcConfig {
	s.SecurityGroupId = &v
	return s
}

func (s *GrafanaWorkspaceVpcConfig) SetUserId(v string) *GrafanaWorkspaceVpcConfig {
	s.UserId = &v
	return s
}

func (s *GrafanaWorkspaceVpcConfig) SetVSwitchId(v string) *GrafanaWorkspaceVpcConfig {
	s.VSwitchId = &v
	return s
}

func (s *GrafanaWorkspaceVpcConfig) SetVpcId(v string) *GrafanaWorkspaceVpcConfig {
	s.VpcId = &v
	return s
}

type GrafanaWorkspaceVpcRegion struct {
	RegionId   *string `json:"regionId,omitempty" xml:"regionId,omitempty"`
	RegionName *string `json:"regionName,omitempty" xml:"regionName,omitempty"`
}

func (s GrafanaWorkspaceVpcRegion) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceVpcRegion) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceVpcRegion) SetRegionId(v string) *GrafanaWorkspaceVpcRegion {
	s.RegionId = &v
	return s
}

func (s *GrafanaWorkspaceVpcRegion) SetRegionName(v string) *GrafanaWorkspaceVpcRegion {
	s.RegionName = &v
	return s
}

type GrafanaWorkspaceVpcRegionDetail struct {
	FcConfig         *string   `json:"fcConfig,omitempty" xml:"fcConfig,omitempty"`
	Id               *int64    `json:"id,omitempty" xml:"id,omitempty"`
	InstallStatus    *string   `json:"installStatus,omitempty" xml:"installStatus,omitempty"`
	Name             *string   `json:"name,omitempty" xml:"name,omitempty"`
	RegionId         *string   `json:"regionId,omitempty" xml:"regionId,omitempty"`
	SecurityGroupId  *string   `json:"securityGroupId,omitempty" xml:"securityGroupId,omitempty"`
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" xml:"securityGroupIds,omitempty" type:"Repeated"`
	UserId           *string   `json:"userId,omitempty" xml:"userId,omitempty"`
	VSwitchId        *string   `json:"vSwitchId,omitempty" xml:"vSwitchId,omitempty"`
	VSwitchIds       []*string `json:"vSwitchIds,omitempty" xml:"vSwitchIds,omitempty" type:"Repeated"`
	VpcId            *string   `json:"vpcId,omitempty" xml:"vpcId,omitempty"`
}

func (s GrafanaWorkspaceVpcRegionDetail) String() string {
	return tea.Prettify(s)
}

func (s GrafanaWorkspaceVpcRegionDetail) GoString() string {
	return s.String()
}

func (s *GrafanaWorkspaceVpcRegionDetail) SetFcConfig(v string) *GrafanaWorkspaceVpcRegionDetail {
	s.FcConfig = &v
	return s
}

func (s *GrafanaWorkspaceVpcRegionDetail) SetId(v int64) *GrafanaWorkspaceVpcRegionDetail {
	s.Id = &v
	return s
}

func (s *GrafanaWorkspaceVpcRegionDetail) SetInstallStatus(v string) *GrafanaWorkspaceVpcRegionDetail {
	s.InstallStatus = &v
	return s
}

func (s *GrafanaWorkspaceVpcRegionDetail) SetName(v string) *GrafanaWorkspaceVpcRegionDetail {
	s.Name = &v
	return s
}

func (s *GrafanaWorkspaceVpcRegionDetail) SetRegionId(v string) *GrafanaWorkspaceVpcRegionDetail {
	s.RegionId = &v
	return s
}

func (s *GrafanaWorkspaceVpcRegionDetail) SetSecurityGroupId(v string) *GrafanaWorkspaceVpcRegionDetail {
	s.SecurityGroupId = &v
	return s
}

func (s *GrafanaWorkspaceVpcRegionDetail) SetSecurityGroupIds(v []*string) *GrafanaWorkspaceVpcRegionDetail {
	s.SecurityGroupIds = v
	return s
}

func (s *GrafanaWorkspaceVpcRegionDetail) SetUserId(v string) *GrafanaWorkspaceVpcRegionDetail {
	s.UserId = &v
	return s
}

func (s *GrafanaWorkspaceVpcRegionDetail) SetVSwitchId(v string) *GrafanaWorkspaceVpcRegionDetail {
	s.VSwitchId = &v
	return s
}

func (s *GrafanaWorkspaceVpcRegionDetail) SetVSwitchIds(v []*string) *GrafanaWorkspaceVpcRegionDetail {
	s.VSwitchIds = v
	return s
}

func (s *GrafanaWorkspaceVpcRegionDetail) SetVpcId(v string) *GrafanaWorkspaceVpcRegionDetail {
	s.VpcId = &v
	return s
}

type QueryDataResponse struct {
	Results *string `json:"results,omitempty" xml:"results,omitempty"`
}

func (s QueryDataResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDataResponse) GoString() string {
	return s.String()
}

func (s *QueryDataResponse) SetResults(v string) *QueryDataResponse {
	s.Results = &v
	return s
}

type AddAliClusterIdsToPrometheusGlobalViewRequest struct {
	// The IDs of clusters. Separate multiple IDs with commas (,).
	ClusterIds *string `json:"ClusterIds,omitempty" xml:"ClusterIds,omitempty"`
	// The ID of the global aggregation instance.
	GlobalViewClusterId *string `json:"GlobalViewClusterId,omitempty" xml:"GlobalViewClusterId,omitempty"`
	// The name of the global aggregation instance.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s AddAliClusterIdsToPrometheusGlobalViewRequest) String() string {
	return tea.Prettify(s)
}

func (s AddAliClusterIdsToPrometheusGlobalViewRequest) GoString() string {
	return s.String()
}

func (s *AddAliClusterIdsToPrometheusGlobalViewRequest) SetClusterIds(v string) *AddAliClusterIdsToPrometheusGlobalViewRequest {
	s.ClusterIds = &v
	return s
}

func (s *AddAliClusterIdsToPrometheusGlobalViewRequest) SetGlobalViewClusterId(v string) *AddAliClusterIdsToPrometheusGlobalViewRequest {
	s.GlobalViewClusterId = &v
	return s
}

func (s *AddAliClusterIdsToPrometheusGlobalViewRequest) SetGroupName(v string) *AddAliClusterIdsToPrometheusGlobalViewRequest {
	s.GroupName = &v
	return s
}

func (s *AddAliClusterIdsToPrometheusGlobalViewRequest) SetRegionId(v string) *AddAliClusterIdsToPrometheusGlobalViewRequest {
	s.RegionId = &v
	return s
}

type AddAliClusterIdsToPrometheusGlobalViewResponseBody struct {
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about the array object.
	Data    *AddAliClusterIdsToPrometheusGlobalViewResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	Message *string                                                 `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddAliClusterIdsToPrometheusGlobalViewResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddAliClusterIdsToPrometheusGlobalViewResponseBody) GoString() string {
	return s.String()
}

func (s *AddAliClusterIdsToPrometheusGlobalViewResponseBody) SetCode(v int32) *AddAliClusterIdsToPrometheusGlobalViewResponseBody {
	s.Code = &v
	return s
}

func (s *AddAliClusterIdsToPrometheusGlobalViewResponseBody) SetData(v *AddAliClusterIdsToPrometheusGlobalViewResponseBodyData) *AddAliClusterIdsToPrometheusGlobalViewResponseBody {
	s.Data = v
	return s
}

func (s *AddAliClusterIdsToPrometheusGlobalViewResponseBody) SetMessage(v string) *AddAliClusterIdsToPrometheusGlobalViewResponseBody {
	s.Message = &v
	return s
}

func (s *AddAliClusterIdsToPrometheusGlobalViewResponseBody) SetRequestId(v string) *AddAliClusterIdsToPrometheusGlobalViewResponseBody {
	s.RequestId = &v
	return s
}

type AddAliClusterIdsToPrometheusGlobalViewResponseBodyData struct {
	// The Info-level information.
	Info *string `json:"Info,omitempty" xml:"Info,omitempty"`
	// The additional information.
	Msg *string `json:"Msg,omitempty" xml:"Msg,omitempty"`
	// Indicates whether the request was successful.
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddAliClusterIdsToPrometheusGlobalViewResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s AddAliClusterIdsToPrometheusGlobalViewResponseBodyData) GoString() string {
	return s.String()
}

func (s *AddAliClusterIdsToPrometheusGlobalViewResponseBodyData) SetInfo(v string) *AddAliClusterIdsToPrometheusGlobalViewResponseBodyData {
	s.Info = &v
	return s
}

func (s *AddAliClusterIdsToPrometheusGlobalViewResponseBodyData) SetMsg(v string) *AddAliClusterIdsToPrometheusGlobalViewResponseBodyData {
	s.Msg = &v
	return s
}

func (s *AddAliClusterIdsToPrometheusGlobalViewResponseBodyData) SetSuccess(v bool) *AddAliClusterIdsToPrometheusGlobalViewResponseBodyData {
	s.Success = &v
	return s
}

type AddAliClusterIdsToPrometheusGlobalViewResponse struct {
	Headers    map[string]*string                                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddAliClusterIdsToPrometheusGlobalViewResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddAliClusterIdsToPrometheusGlobalViewResponse) String() string {
	return tea.Prettify(s)
}

func (s AddAliClusterIdsToPrometheusGlobalViewResponse) GoString() string {
	return s.String()
}

func (s *AddAliClusterIdsToPrometheusGlobalViewResponse) SetHeaders(v map[string]*string) *AddAliClusterIdsToPrometheusGlobalViewResponse {
	s.Headers = v
	return s
}

func (s *AddAliClusterIdsToPrometheusGlobalViewResponse) SetStatusCode(v int32) *AddAliClusterIdsToPrometheusGlobalViewResponse {
	s.StatusCode = &v
	return s
}

func (s *AddAliClusterIdsToPrometheusGlobalViewResponse) SetBody(v *AddAliClusterIdsToPrometheusGlobalViewResponseBody) *AddAliClusterIdsToPrometheusGlobalViewResponse {
	s.Body = v
	return s
}

type AddGrafanaRequest struct {
	// The ID of the Container Service for Kubernetes (ACK) cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The abbreviation of the software that is supported by Application Real-Time Monitoring Service (ARMS). Valid values (case-insensitive): `ASM`, `IoT`, and `Flink`.
	Integration *string `json:"Integration,omitempty" xml:"Integration,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s AddGrafanaRequest) String() string {
	return tea.Prettify(s)
}

func (s AddGrafanaRequest) GoString() string {
	return s.String()
}

func (s *AddGrafanaRequest) SetClusterId(v string) *AddGrafanaRequest {
	s.ClusterId = &v
	return s
}

func (s *AddGrafanaRequest) SetIntegration(v string) *AddGrafanaRequest {
	s.Integration = &v
	return s
}

func (s *AddGrafanaRequest) SetRegionId(v string) *AddGrafanaRequest {
	s.RegionId = &v
	return s
}

type AddGrafanaResponseBody struct {
	// Indicates whether the call was successful.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddGrafanaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddGrafanaResponseBody) GoString() string {
	return s.String()
}

func (s *AddGrafanaResponseBody) SetData(v string) *AddGrafanaResponseBody {
	s.Data = &v
	return s
}

func (s *AddGrafanaResponseBody) SetRequestId(v string) *AddGrafanaResponseBody {
	s.RequestId = &v
	return s
}

type AddGrafanaResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddGrafanaResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddGrafanaResponse) String() string {
	return tea.Prettify(s)
}

func (s AddGrafanaResponse) GoString() string {
	return s.String()
}

func (s *AddGrafanaResponse) SetHeaders(v map[string]*string) *AddGrafanaResponse {
	s.Headers = v
	return s
}

func (s *AddGrafanaResponse) SetStatusCode(v int32) *AddGrafanaResponse {
	s.StatusCode = &v
	return s
}

func (s *AddGrafanaResponse) SetBody(v *AddGrafanaResponseBody) *AddGrafanaResponse {
	s.Body = v
	return s
}

type AddIntegrationRequest struct {
	// The ID of an Alibaba Cloud Container Service for Kubernetes cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The software abbreviation that is supported by ARMS. Valid values (case-insensitive): `ASM`, `IoT`, and `Flink`.
	Integration *string `json:"Integration,omitempty" xml:"Integration,omitempty"`
	// The region ID of the instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s AddIntegrationRequest) String() string {
	return tea.Prettify(s)
}

func (s AddIntegrationRequest) GoString() string {
	return s.String()
}

func (s *AddIntegrationRequest) SetClusterId(v string) *AddIntegrationRequest {
	s.ClusterId = &v
	return s
}

func (s *AddIntegrationRequest) SetIntegration(v string) *AddIntegrationRequest {
	s.Integration = &v
	return s
}

func (s *AddIntegrationRequest) SetRegionId(v string) *AddIntegrationRequest {
	s.RegionId = &v
	return s
}

type AddIntegrationResponseBody struct {
	// 状态码。200为成功，其他状态码为异常。
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the integration was successful.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// 返回结果的提示信息。
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddIntegrationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddIntegrationResponseBody) GoString() string {
	return s.String()
}

func (s *AddIntegrationResponseBody) SetCode(v int32) *AddIntegrationResponseBody {
	s.Code = &v
	return s
}

func (s *AddIntegrationResponseBody) SetData(v string) *AddIntegrationResponseBody {
	s.Data = &v
	return s
}

func (s *AddIntegrationResponseBody) SetMessage(v string) *AddIntegrationResponseBody {
	s.Message = &v
	return s
}

func (s *AddIntegrationResponseBody) SetRequestId(v string) *AddIntegrationResponseBody {
	s.RequestId = &v
	return s
}

type AddIntegrationResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddIntegrationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddIntegrationResponse) String() string {
	return tea.Prettify(s)
}

func (s AddIntegrationResponse) GoString() string {
	return s.String()
}

func (s *AddIntegrationResponse) SetHeaders(v map[string]*string) *AddIntegrationResponse {
	s.Headers = v
	return s
}

func (s *AddIntegrationResponse) SetStatusCode(v int32) *AddIntegrationResponse {
	s.StatusCode = &v
	return s
}

func (s *AddIntegrationResponse) SetBody(v *AddIntegrationResponseBody) *AddIntegrationResponse {
	s.Body = v
	return s
}

type AddPrometheusGlobalViewRequest struct {
	// The queried global aggregation instances. The value is a JSON string.
	Clusters *string `json:"Clusters,omitempty" xml:"Clusters,omitempty"`
	// The name of the aggregation instance.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource group ID.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The list of tags.
	Tag []*AddPrometheusGlobalViewRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s AddPrometheusGlobalViewRequest) String() string {
	return tea.Prettify(s)
}

func (s AddPrometheusGlobalViewRequest) GoString() string {
	return s.String()
}

func (s *AddPrometheusGlobalViewRequest) SetClusters(v string) *AddPrometheusGlobalViewRequest {
	s.Clusters = &v
	return s
}

func (s *AddPrometheusGlobalViewRequest) SetGroupName(v string) *AddPrometheusGlobalViewRequest {
	s.GroupName = &v
	return s
}

func (s *AddPrometheusGlobalViewRequest) SetRegionId(v string) *AddPrometheusGlobalViewRequest {
	s.RegionId = &v
	return s
}

func (s *AddPrometheusGlobalViewRequest) SetResourceGroupId(v string) *AddPrometheusGlobalViewRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *AddPrometheusGlobalViewRequest) SetTag(v []*AddPrometheusGlobalViewRequestTag) *AddPrometheusGlobalViewRequest {
	s.Tag = v
	return s
}

type AddPrometheusGlobalViewRequestTag struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s AddPrometheusGlobalViewRequestTag) String() string {
	return tea.Prettify(s)
}

func (s AddPrometheusGlobalViewRequestTag) GoString() string {
	return s.String()
}

func (s *AddPrometheusGlobalViewRequestTag) SetKey(v string) *AddPrometheusGlobalViewRequestTag {
	s.Key = &v
	return s
}

func (s *AddPrometheusGlobalViewRequestTag) SetValue(v string) *AddPrometheusGlobalViewRequestTag {
	s.Value = &v
	return s
}

type AddPrometheusGlobalViewResponseBody struct {
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about the array object.
	Data    *AddPrometheusGlobalViewResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	Message *string                                  `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddPrometheusGlobalViewResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddPrometheusGlobalViewResponseBody) GoString() string {
	return s.String()
}

func (s *AddPrometheusGlobalViewResponseBody) SetCode(v int32) *AddPrometheusGlobalViewResponseBody {
	s.Code = &v
	return s
}

func (s *AddPrometheusGlobalViewResponseBody) SetData(v *AddPrometheusGlobalViewResponseBodyData) *AddPrometheusGlobalViewResponseBody {
	s.Data = v
	return s
}

func (s *AddPrometheusGlobalViewResponseBody) SetMessage(v string) *AddPrometheusGlobalViewResponseBody {
	s.Message = &v
	return s
}

func (s *AddPrometheusGlobalViewResponseBody) SetRequestId(v string) *AddPrometheusGlobalViewResponseBody {
	s.RequestId = &v
	return s
}

type AddPrometheusGlobalViewResponseBodyData struct {
	// The Info-level information.
	Info *AddPrometheusGlobalViewResponseBodyDataInfo `json:"Info,omitempty" xml:"Info,omitempty" type:"Struct"`
	// The additional information.
	Msg *string `json:"Msg,omitempty" xml:"Msg,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`
	// *   `false`
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddPrometheusGlobalViewResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s AddPrometheusGlobalViewResponseBodyData) GoString() string {
	return s.String()
}

func (s *AddPrometheusGlobalViewResponseBodyData) SetInfo(v *AddPrometheusGlobalViewResponseBodyDataInfo) *AddPrometheusGlobalViewResponseBodyData {
	s.Info = v
	return s
}

func (s *AddPrometheusGlobalViewResponseBodyData) SetMsg(v string) *AddPrometheusGlobalViewResponseBodyData {
	s.Msg = &v
	return s
}

func (s *AddPrometheusGlobalViewResponseBodyData) SetSuccess(v bool) *AddPrometheusGlobalViewResponseBodyData {
	s.Success = &v
	return s
}

type AddPrometheusGlobalViewResponseBodyDataInfo struct {
	// The list of instances that failed to be added.
	FailedInstances *string `json:"FailedInstances,omitempty" xml:"FailedInstances,omitempty"`
	// The ID of the global aggregation instance.
	GlobalViewClusterId *string `json:"GlobalViewClusterId,omitempty" xml:"GlobalViewClusterId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s AddPrometheusGlobalViewResponseBodyDataInfo) String() string {
	return tea.Prettify(s)
}

func (s AddPrometheusGlobalViewResponseBodyDataInfo) GoString() string {
	return s.String()
}

func (s *AddPrometheusGlobalViewResponseBodyDataInfo) SetFailedInstances(v string) *AddPrometheusGlobalViewResponseBodyDataInfo {
	s.FailedInstances = &v
	return s
}

func (s *AddPrometheusGlobalViewResponseBodyDataInfo) SetGlobalViewClusterId(v string) *AddPrometheusGlobalViewResponseBodyDataInfo {
	s.GlobalViewClusterId = &v
	return s
}

func (s *AddPrometheusGlobalViewResponseBodyDataInfo) SetRegionId(v string) *AddPrometheusGlobalViewResponseBodyDataInfo {
	s.RegionId = &v
	return s
}

type AddPrometheusGlobalViewResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddPrometheusGlobalViewResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddPrometheusGlobalViewResponse) String() string {
	return tea.Prettify(s)
}

func (s AddPrometheusGlobalViewResponse) GoString() string {
	return s.String()
}

func (s *AddPrometheusGlobalViewResponse) SetHeaders(v map[string]*string) *AddPrometheusGlobalViewResponse {
	s.Headers = v
	return s
}

func (s *AddPrometheusGlobalViewResponse) SetStatusCode(v int32) *AddPrometheusGlobalViewResponse {
	s.StatusCode = &v
	return s
}

func (s *AddPrometheusGlobalViewResponse) SetBody(v *AddPrometheusGlobalViewResponseBody) *AddPrometheusGlobalViewResponse {
	s.Body = v
	return s
}

type AddPrometheusGlobalViewByAliClusterIdsRequest struct {
	ClusterIds  *string `json:"ClusterIds,omitempty" xml:"ClusterIds,omitempty"`
	GroupName   *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	ProductCode *string `json:"ProductCode,omitempty" xml:"ProductCode,omitempty"`
	RegionId    *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s AddPrometheusGlobalViewByAliClusterIdsRequest) String() string {
	return tea.Prettify(s)
}

func (s AddPrometheusGlobalViewByAliClusterIdsRequest) GoString() string {
	return s.String()
}

func (s *AddPrometheusGlobalViewByAliClusterIdsRequest) SetClusterIds(v string) *AddPrometheusGlobalViewByAliClusterIdsRequest {
	s.ClusterIds = &v
	return s
}

func (s *AddPrometheusGlobalViewByAliClusterIdsRequest) SetGroupName(v string) *AddPrometheusGlobalViewByAliClusterIdsRequest {
	s.GroupName = &v
	return s
}

func (s *AddPrometheusGlobalViewByAliClusterIdsRequest) SetProductCode(v string) *AddPrometheusGlobalViewByAliClusterIdsRequest {
	s.ProductCode = &v
	return s
}

func (s *AddPrometheusGlobalViewByAliClusterIdsRequest) SetRegionId(v string) *AddPrometheusGlobalViewByAliClusterIdsRequest {
	s.RegionId = &v
	return s
}

type AddPrometheusGlobalViewByAliClusterIdsResponseBody struct {
	Code      *int32                                                  `json:"Code,omitempty" xml:"Code,omitempty"`
	Data      *AddPrometheusGlobalViewByAliClusterIdsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	Message   *string                                                 `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId *string                                                 `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddPrometheusGlobalViewByAliClusterIdsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddPrometheusGlobalViewByAliClusterIdsResponseBody) GoString() string {
	return s.String()
}

func (s *AddPrometheusGlobalViewByAliClusterIdsResponseBody) SetCode(v int32) *AddPrometheusGlobalViewByAliClusterIdsResponseBody {
	s.Code = &v
	return s
}

func (s *AddPrometheusGlobalViewByAliClusterIdsResponseBody) SetData(v *AddPrometheusGlobalViewByAliClusterIdsResponseBodyData) *AddPrometheusGlobalViewByAliClusterIdsResponseBody {
	s.Data = v
	return s
}

func (s *AddPrometheusGlobalViewByAliClusterIdsResponseBody) SetMessage(v string) *AddPrometheusGlobalViewByAliClusterIdsResponseBody {
	s.Message = &v
	return s
}

func (s *AddPrometheusGlobalViewByAliClusterIdsResponseBody) SetRequestId(v string) *AddPrometheusGlobalViewByAliClusterIdsResponseBody {
	s.RequestId = &v
	return s
}

type AddPrometheusGlobalViewByAliClusterIdsResponseBodyData struct {
	Info    *string `json:"Info,omitempty" xml:"Info,omitempty"`
	Msg     *string `json:"Msg,omitempty" xml:"Msg,omitempty"`
	Success *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddPrometheusGlobalViewByAliClusterIdsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s AddPrometheusGlobalViewByAliClusterIdsResponseBodyData) GoString() string {
	return s.String()
}

func (s *AddPrometheusGlobalViewByAliClusterIdsResponseBodyData) SetInfo(v string) *AddPrometheusGlobalViewByAliClusterIdsResponseBodyData {
	s.Info = &v
	return s
}

func (s *AddPrometheusGlobalViewByAliClusterIdsResponseBodyData) SetMsg(v string) *AddPrometheusGlobalViewByAliClusterIdsResponseBodyData {
	s.Msg = &v
	return s
}

func (s *AddPrometheusGlobalViewByAliClusterIdsResponseBodyData) SetSuccess(v bool) *AddPrometheusGlobalViewByAliClusterIdsResponseBodyData {
	s.Success = &v
	return s
}

type AddPrometheusGlobalViewByAliClusterIdsResponse struct {
	Headers    map[string]*string                                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddPrometheusGlobalViewByAliClusterIdsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddPrometheusGlobalViewByAliClusterIdsResponse) String() string {
	return tea.Prettify(s)
}

func (s AddPrometheusGlobalViewByAliClusterIdsResponse) GoString() string {
	return s.String()
}

func (s *AddPrometheusGlobalViewByAliClusterIdsResponse) SetHeaders(v map[string]*string) *AddPrometheusGlobalViewByAliClusterIdsResponse {
	s.Headers = v
	return s
}

func (s *AddPrometheusGlobalViewByAliClusterIdsResponse) SetStatusCode(v int32) *AddPrometheusGlobalViewByAliClusterIdsResponse {
	s.StatusCode = &v
	return s
}

func (s *AddPrometheusGlobalViewByAliClusterIdsResponse) SetBody(v *AddPrometheusGlobalViewByAliClusterIdsResponseBody) *AddPrometheusGlobalViewByAliClusterIdsResponse {
	s.Body = v
	return s
}

type AddPrometheusInstanceRequest struct {
	Name     *string `json:"Name,omitempty" xml:"Name,omitempty"`
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	Type     *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s AddPrometheusInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s AddPrometheusInstanceRequest) GoString() string {
	return s.String()
}

func (s *AddPrometheusInstanceRequest) SetName(v string) *AddPrometheusInstanceRequest {
	s.Name = &v
	return s
}

func (s *AddPrometheusInstanceRequest) SetRegionId(v string) *AddPrometheusInstanceRequest {
	s.RegionId = &v
	return s
}

func (s *AddPrometheusInstanceRequest) SetType(v string) *AddPrometheusInstanceRequest {
	s.Type = &v
	return s
}

type AddPrometheusInstanceResponseBody struct {
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned struct. { "RequestId": the request ID, "Data": "{ "clusterType": the cluster type, "remoteWriteUrl": the public URL for remote write, "internetGrafanaUrl": the internal URL for Grafana, "authToken": indicates whether authentication is enabled, "internetPushGatewayUrl": the internal URL for Pushgateway, "clusterId": the cluster ID, "internetRemoteReadUrl": the internal URL for remote read, "remoteReadUrl": the public URL for remote read, "grafanaUrl": the public URL for Grafana, "pushGatewayUrl": the public URL for Pushgateway, "internetRemoteWriteUrl": the internal URL for remote write}" }
	Data    *string `json:"Data,omitempty" xml:"Data,omitempty"`
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddPrometheusInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddPrometheusInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *AddPrometheusInstanceResponseBody) SetCode(v int32) *AddPrometheusInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *AddPrometheusInstanceResponseBody) SetData(v string) *AddPrometheusInstanceResponseBody {
	s.Data = &v
	return s
}

func (s *AddPrometheusInstanceResponseBody) SetMessage(v string) *AddPrometheusInstanceResponseBody {
	s.Message = &v
	return s
}

func (s *AddPrometheusInstanceResponseBody) SetRequestId(v string) *AddPrometheusInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddPrometheusInstanceResponseBody) SetSuccess(v bool) *AddPrometheusInstanceResponseBody {
	s.Success = &v
	return s
}

type AddPrometheusInstanceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddPrometheusInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddPrometheusInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s AddPrometheusInstanceResponse) GoString() string {
	return s.String()
}

func (s *AddPrometheusInstanceResponse) SetHeaders(v map[string]*string) *AddPrometheusInstanceResponse {
	s.Headers = v
	return s
}

func (s *AddPrometheusInstanceResponse) SetStatusCode(v int32) *AddPrometheusInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *AddPrometheusInstanceResponse) SetBody(v *AddPrometheusInstanceResponseBody) *AddPrometheusInstanceResponse {
	s.Body = v
	return s
}

type AddPrometheusIntegrationRequest struct {
	// The ID of the Prometheus instance. Only a Prometheus instance for Container Service or a Prometheus instance for ECS is supported.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The type of the integration.
	IntegrationType *string `json:"IntegrationType,omitempty" xml:"IntegrationType,omitempty"`
	// The configurations of the exporter. The value is a JSON string.
	Param *string `json:"Param,omitempty" xml:"Param,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s AddPrometheusIntegrationRequest) String() string {
	return tea.Prettify(s)
}

func (s AddPrometheusIntegrationRequest) GoString() string {
	return s.String()
}

func (s *AddPrometheusIntegrationRequest) SetClusterId(v string) *AddPrometheusIntegrationRequest {
	s.ClusterId = &v
	return s
}

func (s *AddPrometheusIntegrationRequest) SetIntegrationType(v string) *AddPrometheusIntegrationRequest {
	s.IntegrationType = &v
	return s
}

func (s *AddPrometheusIntegrationRequest) SetParam(v string) *AddPrometheusIntegrationRequest {
	s.Param = &v
	return s
}

func (s *AddPrometheusIntegrationRequest) SetRegionId(v string) *AddPrometheusIntegrationRequest {
	s.RegionId = &v
	return s
}

type AddPrometheusIntegrationResponseBody struct {
	// The status code or error code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The struct returned.
	Data *AddPrometheusIntegrationResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddPrometheusIntegrationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddPrometheusIntegrationResponseBody) GoString() string {
	return s.String()
}

func (s *AddPrometheusIntegrationResponseBody) SetCode(v int32) *AddPrometheusIntegrationResponseBody {
	s.Code = &v
	return s
}

func (s *AddPrometheusIntegrationResponseBody) SetData(v *AddPrometheusIntegrationResponseBodyData) *AddPrometheusIntegrationResponseBody {
	s.Data = v
	return s
}

func (s *AddPrometheusIntegrationResponseBody) SetMessage(v string) *AddPrometheusIntegrationResponseBody {
	s.Message = &v
	return s
}

func (s *AddPrometheusIntegrationResponseBody) SetRequestId(v string) *AddPrometheusIntegrationResponseBody {
	s.RequestId = &v
	return s
}

type AddPrometheusIntegrationResponseBodyData struct {
	// The ID of the exporter.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the exporter.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
}

func (s AddPrometheusIntegrationResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s AddPrometheusIntegrationResponseBodyData) GoString() string {
	return s.String()
}

func (s *AddPrometheusIntegrationResponseBodyData) SetInstanceId(v int64) *AddPrometheusIntegrationResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *AddPrometheusIntegrationResponseBodyData) SetInstanceName(v string) *AddPrometheusIntegrationResponseBodyData {
	s.InstanceName = &v
	return s
}

type AddPrometheusIntegrationResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddPrometheusIntegrationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddPrometheusIntegrationResponse) String() string {
	return tea.Prettify(s)
}

func (s AddPrometheusIntegrationResponse) GoString() string {
	return s.String()
}

func (s *AddPrometheusIntegrationResponse) SetHeaders(v map[string]*string) *AddPrometheusIntegrationResponse {
	s.Headers = v
	return s
}

func (s *AddPrometheusIntegrationResponse) SetStatusCode(v int32) *AddPrometheusIntegrationResponse {
	s.StatusCode = &v
	return s
}

func (s *AddPrometheusIntegrationResponse) SetBody(v *AddPrometheusIntegrationResponseBody) *AddPrometheusIntegrationResponse {
	s.Body = v
	return s
}

type AddPrometheusRemoteWriteRequest struct {
	// The ID of the Prometheus instance. Only a Prometheus instance for Container Service or a Prometheus instance for ECS is supported.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The details of the remote write configuration item. Specify the value in the YAML format.
	RemoteWriteYaml *string `json:"RemoteWriteYaml,omitempty" xml:"RemoteWriteYaml,omitempty"`
}

func (s AddPrometheusRemoteWriteRequest) String() string {
	return tea.Prettify(s)
}

func (s AddPrometheusRemoteWriteRequest) GoString() string {
	return s.String()
}

func (s *AddPrometheusRemoteWriteRequest) SetClusterId(v string) *AddPrometheusRemoteWriteRequest {
	s.ClusterId = &v
	return s
}

func (s *AddPrometheusRemoteWriteRequest) SetRegionId(v string) *AddPrometheusRemoteWriteRequest {
	s.RegionId = &v
	return s
}

func (s *AddPrometheusRemoteWriteRequest) SetRemoteWriteYaml(v string) *AddPrometheusRemoteWriteRequest {
	s.RemoteWriteYaml = &v
	return s
}

type AddPrometheusRemoteWriteResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The name of the remote write configuration item. If the request fails, an error message is returned.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`
	// *   `false`
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddPrometheusRemoteWriteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddPrometheusRemoteWriteResponseBody) GoString() string {
	return s.String()
}

func (s *AddPrometheusRemoteWriteResponseBody) SetCode(v int32) *AddPrometheusRemoteWriteResponseBody {
	s.Code = &v
	return s
}

func (s *AddPrometheusRemoteWriteResponseBody) SetData(v string) *AddPrometheusRemoteWriteResponseBody {
	s.Data = &v
	return s
}

func (s *AddPrometheusRemoteWriteResponseBody) SetMessage(v string) *AddPrometheusRemoteWriteResponseBody {
	s.Message = &v
	return s
}

func (s *AddPrometheusRemoteWriteResponseBody) SetRequestId(v string) *AddPrometheusRemoteWriteResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddPrometheusRemoteWriteResponseBody) SetSuccess(v bool) *AddPrometheusRemoteWriteResponseBody {
	s.Success = &v
	return s
}

type AddPrometheusRemoteWriteResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddPrometheusRemoteWriteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddPrometheusRemoteWriteResponse) String() string {
	return tea.Prettify(s)
}

func (s AddPrometheusRemoteWriteResponse) GoString() string {
	return s.String()
}

func (s *AddPrometheusRemoteWriteResponse) SetHeaders(v map[string]*string) *AddPrometheusRemoteWriteResponse {
	s.Headers = v
	return s
}

func (s *AddPrometheusRemoteWriteResponse) SetStatusCode(v int32) *AddPrometheusRemoteWriteResponse {
	s.StatusCode = &v
	return s
}

func (s *AddPrometheusRemoteWriteResponse) SetBody(v *AddPrometheusRemoteWriteResponseBody) *AddPrometheusRemoteWriteResponse {
	s.Body = v
	return s
}

type AddRecordingRuleRequest struct {
	// The cluster ID.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The custom recording rule. The value is in the YAML format.
	RuleYaml *string `json:"RuleYaml,omitempty" xml:"RuleYaml,omitempty"`
}

func (s AddRecordingRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s AddRecordingRuleRequest) GoString() string {
	return s.String()
}

func (s *AddRecordingRuleRequest) SetClusterId(v string) *AddRecordingRuleRequest {
	s.ClusterId = &v
	return s
}

func (s *AddRecordingRuleRequest) SetRegionId(v string) *AddRecordingRuleRequest {
	s.RegionId = &v
	return s
}

func (s *AddRecordingRuleRequest) SetRuleYaml(v string) *AddRecordingRuleRequest {
	s.RuleYaml = &v
	return s
}

type AddRecordingRuleResponseBody struct {
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The status of the response.
	Data    *string `json:"Data,omitempty" xml:"Data,omitempty"`
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddRecordingRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddRecordingRuleResponseBody) GoString() string {
	return s.String()
}

func (s *AddRecordingRuleResponseBody) SetCode(v int32) *AddRecordingRuleResponseBody {
	s.Code = &v
	return s
}

func (s *AddRecordingRuleResponseBody) SetData(v string) *AddRecordingRuleResponseBody {
	s.Data = &v
	return s
}

func (s *AddRecordingRuleResponseBody) SetMessage(v string) *AddRecordingRuleResponseBody {
	s.Message = &v
	return s
}

func (s *AddRecordingRuleResponseBody) SetRequestId(v string) *AddRecordingRuleResponseBody {
	s.RequestId = &v
	return s
}

type AddRecordingRuleResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddRecordingRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddRecordingRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s AddRecordingRuleResponse) GoString() string {
	return s.String()
}

func (s *AddRecordingRuleResponse) SetHeaders(v map[string]*string) *AddRecordingRuleResponse {
	s.Headers = v
	return s
}

func (s *AddRecordingRuleResponse) SetStatusCode(v int32) *AddRecordingRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *AddRecordingRuleResponse) SetBody(v *AddRecordingRuleResponseBody) *AddRecordingRuleResponse {
	s.Body = v
	return s
}

type AddTagToFlinkClusterRequest struct {
	ClusterId          *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	FlinkWorkSpaceId   *string `json:"FlinkWorkSpaceId,omitempty" xml:"FlinkWorkSpaceId,omitempty"`
	FlinkWorkSpaceName *string `json:"FlinkWorkSpaceName,omitempty" xml:"FlinkWorkSpaceName,omitempty"`
	RegionId           *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId    *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	TargetUserId       *string `json:"TargetUserId,omitempty" xml:"TargetUserId,omitempty"`
}

func (s AddTagToFlinkClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s AddTagToFlinkClusterRequest) GoString() string {
	return s.String()
}

func (s *AddTagToFlinkClusterRequest) SetClusterId(v string) *AddTagToFlinkClusterRequest {
	s.ClusterId = &v
	return s
}

func (s *AddTagToFlinkClusterRequest) SetFlinkWorkSpaceId(v string) *AddTagToFlinkClusterRequest {
	s.FlinkWorkSpaceId = &v
	return s
}

func (s *AddTagToFlinkClusterRequest) SetFlinkWorkSpaceName(v string) *AddTagToFlinkClusterRequest {
	s.FlinkWorkSpaceName = &v
	return s
}

func (s *AddTagToFlinkClusterRequest) SetRegionId(v string) *AddTagToFlinkClusterRequest {
	s.RegionId = &v
	return s
}

func (s *AddTagToFlinkClusterRequest) SetResourceGroupId(v string) *AddTagToFlinkClusterRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *AddTagToFlinkClusterRequest) SetTargetUserId(v string) *AddTagToFlinkClusterRequest {
	s.TargetUserId = &v
	return s
}

type AddTagToFlinkClusterResponseBody struct {
	Code *int32  `json:"Code,omitempty" xml:"Code,omitempty"`
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddTagToFlinkClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddTagToFlinkClusterResponseBody) GoString() string {
	return s.String()
}

func (s *AddTagToFlinkClusterResponseBody) SetCode(v int32) *AddTagToFlinkClusterResponseBody {
	s.Code = &v
	return s
}

func (s *AddTagToFlinkClusterResponseBody) SetData(v string) *AddTagToFlinkClusterResponseBody {
	s.Data = &v
	return s
}

func (s *AddTagToFlinkClusterResponseBody) SetRequestId(v string) *AddTagToFlinkClusterResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddTagToFlinkClusterResponseBody) SetSuccess(v bool) *AddTagToFlinkClusterResponseBody {
	s.Success = &v
	return s
}

type AddTagToFlinkClusterResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddTagToFlinkClusterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddTagToFlinkClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s AddTagToFlinkClusterResponse) GoString() string {
	return s.String()
}

func (s *AddTagToFlinkClusterResponse) SetHeaders(v map[string]*string) *AddTagToFlinkClusterResponse {
	s.Headers = v
	return s
}

func (s *AddTagToFlinkClusterResponse) SetStatusCode(v int32) *AddTagToFlinkClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *AddTagToFlinkClusterResponse) SetBody(v *AddTagToFlinkClusterResponseBody) *AddTagToFlinkClusterResponse {
	s.Body = v
	return s
}

type AppendInstancesToPrometheusGlobalViewRequest struct {
	// The list of global aggregation instances. The value is a JSON string.
	Clusters *string `json:"Clusters,omitempty" xml:"Clusters,omitempty"`
	// The ID of the global aggregation instance.
	GlobalViewClusterId *string `json:"GlobalViewClusterId,omitempty" xml:"GlobalViewClusterId,omitempty"`
	// The name of the global aggregation instance.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s AppendInstancesToPrometheusGlobalViewRequest) String() string {
	return tea.Prettify(s)
}

func (s AppendInstancesToPrometheusGlobalViewRequest) GoString() string {
	return s.String()
}

func (s *AppendInstancesToPrometheusGlobalViewRequest) SetClusters(v string) *AppendInstancesToPrometheusGlobalViewRequest {
	s.Clusters = &v
	return s
}

func (s *AppendInstancesToPrometheusGlobalViewRequest) SetGlobalViewClusterId(v string) *AppendInstancesToPrometheusGlobalViewRequest {
	s.GlobalViewClusterId = &v
	return s
}

func (s *AppendInstancesToPrometheusGlobalViewRequest) SetGroupName(v string) *AppendInstancesToPrometheusGlobalViewRequest {
	s.GroupName = &v
	return s
}

func (s *AppendInstancesToPrometheusGlobalViewRequest) SetRegionId(v string) *AppendInstancesToPrometheusGlobalViewRequest {
	s.RegionId = &v
	return s
}

type AppendInstancesToPrometheusGlobalViewResponseBody struct {
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about the array object.
	Data    *AppendInstancesToPrometheusGlobalViewResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	Message *string                                                `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AppendInstancesToPrometheusGlobalViewResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AppendInstancesToPrometheusGlobalViewResponseBody) GoString() string {
	return s.String()
}

func (s *AppendInstancesToPrometheusGlobalViewResponseBody) SetCode(v int32) *AppendInstancesToPrometheusGlobalViewResponseBody {
	s.Code = &v
	return s
}

func (s *AppendInstancesToPrometheusGlobalViewResponseBody) SetData(v *AppendInstancesToPrometheusGlobalViewResponseBodyData) *AppendInstancesToPrometheusGlobalViewResponseBody {
	s.Data = v
	return s
}

func (s *AppendInstancesToPrometheusGlobalViewResponseBody) SetMessage(v string) *AppendInstancesToPrometheusGlobalViewResponseBody {
	s.Message = &v
	return s
}

func (s *AppendInstancesToPrometheusGlobalViewResponseBody) SetRequestId(v string) *AppendInstancesToPrometheusGlobalViewResponseBody {
	s.RequestId = &v
	return s
}

type AppendInstancesToPrometheusGlobalViewResponseBodyData struct {
	// The Info-level information.
	Info *string `json:"Info,omitempty" xml:"Info,omitempty"`
	// The additional information.
	Msg *string `json:"Msg,omitempty" xml:"Msg,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   `true`: The call was successful.
	// *   `false`: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AppendInstancesToPrometheusGlobalViewResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s AppendInstancesToPrometheusGlobalViewResponseBodyData) GoString() string {
	return s.String()
}

func (s *AppendInstancesToPrometheusGlobalViewResponseBodyData) SetInfo(v string) *AppendInstancesToPrometheusGlobalViewResponseBodyData {
	s.Info = &v
	return s
}

func (s *AppendInstancesToPrometheusGlobalViewResponseBodyData) SetMsg(v string) *AppendInstancesToPrometheusGlobalViewResponseBodyData {
	s.Msg = &v
	return s
}

func (s *AppendInstancesToPrometheusGlobalViewResponseBodyData) SetSuccess(v bool) *AppendInstancesToPrometheusGlobalViewResponseBodyData {
	s.Success = &v
	return s
}

type AppendInstancesToPrometheusGlobalViewResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AppendInstancesToPrometheusGlobalViewResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AppendInstancesToPrometheusGlobalViewResponse) String() string {
	return tea.Prettify(s)
}

func (s AppendInstancesToPrometheusGlobalViewResponse) GoString() string {
	return s.String()
}

func (s *AppendInstancesToPrometheusGlobalViewResponse) SetHeaders(v map[string]*string) *AppendInstancesToPrometheusGlobalViewResponse {
	s.Headers = v
	return s
}

func (s *AppendInstancesToPrometheusGlobalViewResponse) SetStatusCode(v int32) *AppendInstancesToPrometheusGlobalViewResponse {
	s.StatusCode = &v
	return s
}

func (s *AppendInstancesToPrometheusGlobalViewResponse) SetBody(v *AppendInstancesToPrometheusGlobalViewResponseBody) *AppendInstancesToPrometheusGlobalViewResponse {
	s.Body = v
	return s
}

type ApplyScenarioRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The configuration of the business monitoring job. The value is a JSON string. For more information about this parameter, see the following additional information about the **Config** parameter.
	Config map[string]interface{} `json:"Config,omitempty" xml:"Config,omitempty"`
	// The name of the business monitoring job.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The scenario where you want to use the business monitoring job. Valid values:
	//
	// *   `USER-DEFINED`: user-defined. This is the default value.
	// *   `EDAS-ROLLOUT`: application release in Enterprise Distributed Application Service (EDAS)
	// *   `OAM-ROLLOUT`: application release based on Open Application Model (OAM)
	// *   `MSC-CANARY`: canary release based on Microservice Engine (MSE)
	Scenario *string `json:"Scenario,omitempty" xml:"Scenario,omitempty"`
	// The code of the business monitoring job. This parameter is not required when you create a business monitoring job. However, this parameter is required when you update a business monitoring job.
	Sign *string `json:"Sign,omitempty" xml:"Sign,omitempty"`
	// Specifies whether to record business parameters to the trace marked with the coloring sign.
	//
	// *   `true`
	// *   `false`: This is the default value.
	SnDump *bool `json:"SnDump,omitempty" xml:"SnDump,omitempty"`
	// Specifies whether traffic in the trace marked with the coloring sign is all collected.
	//
	// *   `true`
	// *   `false`: This is the default value.
	SnForce *bool `json:"SnForce,omitempty" xml:"SnForce,omitempty"`
	// Specifies whether to count traffic based on the coloring sign.
	//
	// *   `true`
	// *   `false`: This is the default value.
	SnStat *bool `json:"SnStat,omitempty" xml:"SnStat,omitempty"`
	// Specifies whether the coloring sign is transparently passed down to downstream application nodes in the trace.
	//
	// *   `true`
	// *   `false`: This is the default value.
	SnTransfer *bool `json:"SnTransfer,omitempty" xml:"SnTransfer,omitempty"`
	// Specifies whether the operation is an update operation.
	//
	// *   `true`: update
	// *   `false`: insert
	UpdateOption *bool `json:"UpdateOption,omitempty" xml:"UpdateOption,omitempty"`
}

func (s ApplyScenarioRequest) String() string {
	return tea.Prettify(s)
}

func (s ApplyScenarioRequest) GoString() string {
	return s.String()
}

func (s *ApplyScenarioRequest) SetAppId(v string) *ApplyScenarioRequest {
	s.AppId = &v
	return s
}

func (s *ApplyScenarioRequest) SetConfig(v map[string]interface{}) *ApplyScenarioRequest {
	s.Config = v
	return s
}

func (s *ApplyScenarioRequest) SetName(v string) *ApplyScenarioRequest {
	s.Name = &v
	return s
}

func (s *ApplyScenarioRequest) SetRegionId(v string) *ApplyScenarioRequest {
	s.RegionId = &v
	return s
}

func (s *ApplyScenarioRequest) SetScenario(v string) *ApplyScenarioRequest {
	s.Scenario = &v
	return s
}

func (s *ApplyScenarioRequest) SetSign(v string) *ApplyScenarioRequest {
	s.Sign = &v
	return s
}

func (s *ApplyScenarioRequest) SetSnDump(v bool) *ApplyScenarioRequest {
	s.SnDump = &v
	return s
}

func (s *ApplyScenarioRequest) SetSnForce(v bool) *ApplyScenarioRequest {
	s.SnForce = &v
	return s
}

func (s *ApplyScenarioRequest) SetSnStat(v bool) *ApplyScenarioRequest {
	s.SnStat = &v
	return s
}

func (s *ApplyScenarioRequest) SetSnTransfer(v bool) *ApplyScenarioRequest {
	s.SnTransfer = &v
	return s
}

func (s *ApplyScenarioRequest) SetUpdateOption(v bool) *ApplyScenarioRequest {
	s.UpdateOption = &v
	return s
}

type ApplyScenarioShrinkRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The configuration of the business monitoring job. The value is a JSON string. For more information about this parameter, see the following additional information about the **Config** parameter.
	ConfigShrink *string `json:"Config,omitempty" xml:"Config,omitempty"`
	// The name of the business monitoring job.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The scenario where you want to use the business monitoring job. Valid values:
	//
	// *   `USER-DEFINED`: user-defined. This is the default value.
	// *   `EDAS-ROLLOUT`: application release in Enterprise Distributed Application Service (EDAS)
	// *   `OAM-ROLLOUT`: application release based on Open Application Model (OAM)
	// *   `MSC-CANARY`: canary release based on Microservice Engine (MSE)
	Scenario *string `json:"Scenario,omitempty" xml:"Scenario,omitempty"`
	// The code of the business monitoring job. This parameter is not required when you create a business monitoring job. However, this parameter is required when you update a business monitoring job.
	Sign *string `json:"Sign,omitempty" xml:"Sign,omitempty"`
	// Specifies whether to record business parameters to the trace marked with the coloring sign.
	//
	// *   `true`
	// *   `false`: This is the default value.
	SnDump *bool `json:"SnDump,omitempty" xml:"SnDump,omitempty"`
	// Specifies whether traffic in the trace marked with the coloring sign is all collected.
	//
	// *   `true`
	// *   `false`: This is the default value.
	SnForce *bool `json:"SnForce,omitempty" xml:"SnForce,omitempty"`
	// Specifies whether to count traffic based on the coloring sign.
	//
	// *   `true`
	// *   `false`: This is the default value.
	SnStat *bool `json:"SnStat,omitempty" xml:"SnStat,omitempty"`
	// Specifies whether the coloring sign is transparently passed down to downstream application nodes in the trace.
	//
	// *   `true`
	// *   `false`: This is the default value.
	SnTransfer *bool `json:"SnTransfer,omitempty" xml:"SnTransfer,omitempty"`
	// Specifies whether the operation is an update operation.
	//
	// *   `true`: update
	// *   `false`: insert
	UpdateOption *bool `json:"UpdateOption,omitempty" xml:"UpdateOption,omitempty"`
}

func (s ApplyScenarioShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ApplyScenarioShrinkRequest) GoString() string {
	return s.String()
}

func (s *ApplyScenarioShrinkRequest) SetAppId(v string) *ApplyScenarioShrinkRequest {
	s.AppId = &v
	return s
}

func (s *ApplyScenarioShrinkRequest) SetConfigShrink(v string) *ApplyScenarioShrinkRequest {
	s.ConfigShrink = &v
	return s
}

func (s *ApplyScenarioShrinkRequest) SetName(v string) *ApplyScenarioShrinkRequest {
	s.Name = &v
	return s
}

func (s *ApplyScenarioShrinkRequest) SetRegionId(v string) *ApplyScenarioShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *ApplyScenarioShrinkRequest) SetScenario(v string) *ApplyScenarioShrinkRequest {
	s.Scenario = &v
	return s
}

func (s *ApplyScenarioShrinkRequest) SetSign(v string) *ApplyScenarioShrinkRequest {
	s.Sign = &v
	return s
}

func (s *ApplyScenarioShrinkRequest) SetSnDump(v bool) *ApplyScenarioShrinkRequest {
	s.SnDump = &v
	return s
}

func (s *ApplyScenarioShrinkRequest) SetSnForce(v bool) *ApplyScenarioShrinkRequest {
	s.SnForce = &v
	return s
}

func (s *ApplyScenarioShrinkRequest) SetSnStat(v bool) *ApplyScenarioShrinkRequest {
	s.SnStat = &v
	return s
}

func (s *ApplyScenarioShrinkRequest) SetSnTransfer(v bool) *ApplyScenarioShrinkRequest {
	s.SnTransfer = &v
	return s
}

func (s *ApplyScenarioShrinkRequest) SetUpdateOption(v bool) *ApplyScenarioShrinkRequest {
	s.UpdateOption = &v
	return s
}

type ApplyScenarioResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The code of the business monitoring job, which is the coloring sign.
	Result *string `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s ApplyScenarioResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ApplyScenarioResponseBody) GoString() string {
	return s.String()
}

func (s *ApplyScenarioResponseBody) SetRequestId(v string) *ApplyScenarioResponseBody {
	s.RequestId = &v
	return s
}

func (s *ApplyScenarioResponseBody) SetResult(v string) *ApplyScenarioResponseBody {
	s.Result = &v
	return s
}

type ApplyScenarioResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ApplyScenarioResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ApplyScenarioResponse) String() string {
	return tea.Prettify(s)
}

func (s ApplyScenarioResponse) GoString() string {
	return s.String()
}

func (s *ApplyScenarioResponse) SetHeaders(v map[string]*string) *ApplyScenarioResponse {
	s.Headers = v
	return s
}

func (s *ApplyScenarioResponse) SetStatusCode(v int32) *ApplyScenarioResponse {
	s.StatusCode = &v
	return s
}

func (s *ApplyScenarioResponse) SetBody(v *ApplyScenarioResponseBody) *ApplyScenarioResponse {
	s.Body = v
	return s
}

type BindPrometheusGrafanaInstanceRequest struct {
	// The ID of the Prometheus instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the Grafana workspace.
	GrafanaInstanceId *string `json:"GrafanaInstanceId,omitempty" xml:"GrafanaInstanceId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the Prometheus instance belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s BindPrometheusGrafanaInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s BindPrometheusGrafanaInstanceRequest) GoString() string {
	return s.String()
}

func (s *BindPrometheusGrafanaInstanceRequest) SetClusterId(v string) *BindPrometheusGrafanaInstanceRequest {
	s.ClusterId = &v
	return s
}

func (s *BindPrometheusGrafanaInstanceRequest) SetGrafanaInstanceId(v string) *BindPrometheusGrafanaInstanceRequest {
	s.GrafanaInstanceId = &v
	return s
}

func (s *BindPrometheusGrafanaInstanceRequest) SetRegionId(v string) *BindPrometheusGrafanaInstanceRequest {
	s.RegionId = &v
	return s
}

func (s *BindPrometheusGrafanaInstanceRequest) SetResourceGroupId(v string) *BindPrometheusGrafanaInstanceRequest {
	s.ResourceGroupId = &v
	return s
}

type BindPrometheusGrafanaInstanceResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the request was successful.
	//
	// *   true
	// *   false
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BindPrometheusGrafanaInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BindPrometheusGrafanaInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *BindPrometheusGrafanaInstanceResponseBody) SetCode(v int32) *BindPrometheusGrafanaInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *BindPrometheusGrafanaInstanceResponseBody) SetData(v bool) *BindPrometheusGrafanaInstanceResponseBody {
	s.Data = &v
	return s
}

func (s *BindPrometheusGrafanaInstanceResponseBody) SetMessage(v string) *BindPrometheusGrafanaInstanceResponseBody {
	s.Message = &v
	return s
}

func (s *BindPrometheusGrafanaInstanceResponseBody) SetRequestId(v string) *BindPrometheusGrafanaInstanceResponseBody {
	s.RequestId = &v
	return s
}

type BindPrometheusGrafanaInstanceResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BindPrometheusGrafanaInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BindPrometheusGrafanaInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s BindPrometheusGrafanaInstanceResponse) GoString() string {
	return s.String()
}

func (s *BindPrometheusGrafanaInstanceResponse) SetHeaders(v map[string]*string) *BindPrometheusGrafanaInstanceResponse {
	s.Headers = v
	return s
}

func (s *BindPrometheusGrafanaInstanceResponse) SetStatusCode(v int32) *BindPrometheusGrafanaInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *BindPrometheusGrafanaInstanceResponse) SetBody(v *BindPrometheusGrafanaInstanceResponseBody) *BindPrometheusGrafanaInstanceResponse {
	s.Body = v
	return s
}

type BlockAlarmNotificationRequest struct {
	AlarmId   *int64  `json:"AlarmId,omitempty" xml:"AlarmId,omitempty"`
	HandlerId *int64  `json:"HandlerId,omitempty" xml:"HandlerId,omitempty"`
	RegionId  *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	Timeout   *int64  `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
}

func (s BlockAlarmNotificationRequest) String() string {
	return tea.Prettify(s)
}

func (s BlockAlarmNotificationRequest) GoString() string {
	return s.String()
}

func (s *BlockAlarmNotificationRequest) SetAlarmId(v int64) *BlockAlarmNotificationRequest {
	s.AlarmId = &v
	return s
}

func (s *BlockAlarmNotificationRequest) SetHandlerId(v int64) *BlockAlarmNotificationRequest {
	s.HandlerId = &v
	return s
}

func (s *BlockAlarmNotificationRequest) SetRegionId(v string) *BlockAlarmNotificationRequest {
	s.RegionId = &v
	return s
}

func (s *BlockAlarmNotificationRequest) SetTimeout(v int64) *BlockAlarmNotificationRequest {
	s.Timeout = &v
	return s
}

type BlockAlarmNotificationResponseBody struct {
	Code      *int64  `json:"Code,omitempty" xml:"Code,omitempty"`
	Message   *string `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *bool   `json:"Result,omitempty" xml:"Result,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BlockAlarmNotificationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BlockAlarmNotificationResponseBody) GoString() string {
	return s.String()
}

func (s *BlockAlarmNotificationResponseBody) SetCode(v int64) *BlockAlarmNotificationResponseBody {
	s.Code = &v
	return s
}

func (s *BlockAlarmNotificationResponseBody) SetMessage(v string) *BlockAlarmNotificationResponseBody {
	s.Message = &v
	return s
}

func (s *BlockAlarmNotificationResponseBody) SetRequestId(v string) *BlockAlarmNotificationResponseBody {
	s.RequestId = &v
	return s
}

func (s *BlockAlarmNotificationResponseBody) SetResult(v bool) *BlockAlarmNotificationResponseBody {
	s.Result = &v
	return s
}

func (s *BlockAlarmNotificationResponseBody) SetSuccess(v bool) *BlockAlarmNotificationResponseBody {
	s.Success = &v
	return s
}

type BlockAlarmNotificationResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BlockAlarmNotificationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BlockAlarmNotificationResponse) String() string {
	return tea.Prettify(s)
}

func (s BlockAlarmNotificationResponse) GoString() string {
	return s.String()
}

func (s *BlockAlarmNotificationResponse) SetHeaders(v map[string]*string) *BlockAlarmNotificationResponse {
	s.Headers = v
	return s
}

func (s *BlockAlarmNotificationResponse) SetStatusCode(v int32) *BlockAlarmNotificationResponse {
	s.StatusCode = &v
	return s
}

func (s *BlockAlarmNotificationResponse) SetBody(v *BlockAlarmNotificationResponseBody) *BlockAlarmNotificationResponse {
	s.Body = v
	return s
}

type ChangeAlarmSeverityRequest struct {
	AlarmId   *int64  `json:"AlarmId,omitempty" xml:"AlarmId,omitempty"`
	HandlerId *int64  `json:"HandlerId,omitempty" xml:"HandlerId,omitempty"`
	RegionId  *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	Severity  *string `json:"Severity,omitempty" xml:"Severity,omitempty"`
}

func (s ChangeAlarmSeverityRequest) String() string {
	return tea.Prettify(s)
}

func (s ChangeAlarmSeverityRequest) GoString() string {
	return s.String()
}

func (s *ChangeAlarmSeverityRequest) SetAlarmId(v int64) *ChangeAlarmSeverityRequest {
	s.AlarmId = &v
	return s
}

func (s *ChangeAlarmSeverityRequest) SetHandlerId(v int64) *ChangeAlarmSeverityRequest {
	s.HandlerId = &v
	return s
}

func (s *ChangeAlarmSeverityRequest) SetRegionId(v string) *ChangeAlarmSeverityRequest {
	s.RegionId = &v
	return s
}

func (s *ChangeAlarmSeverityRequest) SetSeverity(v string) *ChangeAlarmSeverityRequest {
	s.Severity = &v
	return s
}

type ChangeAlarmSeverityResponseBody struct {
	Code      *int64  `json:"Code,omitempty" xml:"Code,omitempty"`
	Message   *string `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *bool   `json:"Result,omitempty" xml:"Result,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ChangeAlarmSeverityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ChangeAlarmSeverityResponseBody) GoString() string {
	return s.String()
}

func (s *ChangeAlarmSeverityResponseBody) SetCode(v int64) *ChangeAlarmSeverityResponseBody {
	s.Code = &v
	return s
}

func (s *ChangeAlarmSeverityResponseBody) SetMessage(v string) *ChangeAlarmSeverityResponseBody {
	s.Message = &v
	return s
}

func (s *ChangeAlarmSeverityResponseBody) SetRequestId(v string) *ChangeAlarmSeverityResponseBody {
	s.RequestId = &v
	return s
}

func (s *ChangeAlarmSeverityResponseBody) SetResult(v bool) *ChangeAlarmSeverityResponseBody {
	s.Result = &v
	return s
}

func (s *ChangeAlarmSeverityResponseBody) SetSuccess(v bool) *ChangeAlarmSeverityResponseBody {
	s.Success = &v
	return s
}

type ChangeAlarmSeverityResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ChangeAlarmSeverityResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ChangeAlarmSeverityResponse) String() string {
	return tea.Prettify(s)
}

func (s ChangeAlarmSeverityResponse) GoString() string {
	return s.String()
}

func (s *ChangeAlarmSeverityResponse) SetHeaders(v map[string]*string) *ChangeAlarmSeverityResponse {
	s.Headers = v
	return s
}

func (s *ChangeAlarmSeverityResponse) SetStatusCode(v int32) *ChangeAlarmSeverityResponse {
	s.StatusCode = &v
	return s
}

func (s *ChangeAlarmSeverityResponse) SetBody(v *ChangeAlarmSeverityResponseBody) *ChangeAlarmSeverityResponse {
	s.Body = v
	return s
}

type ChangeResourceGroupRequest struct {
	// The ID of the new resource group. You can view the available resource groups in the Resource Management console.
	NewResourceGroupId *string `json:"NewResourceGroupId,omitempty" xml:"NewResourceGroupId,omitempty"`
	// The region ID of the resource.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource ID.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The resource type.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s ChangeResourceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceGroupRequest) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupRequest) SetNewResourceGroupId(v string) *ChangeResourceGroupRequest {
	s.NewResourceGroupId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetRegionId(v string) *ChangeResourceGroupRequest {
	s.RegionId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetResourceId(v string) *ChangeResourceGroupRequest {
	s.ResourceId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetResourceType(v string) *ChangeResourceGroupRequest {
	s.ResourceType = &v
	return s
}

type ChangeResourceGroupResponseBody struct {
	// The status code or error code.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned struct.
	Data *ChangeResourceGroupResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ChangeResourceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupResponseBody) SetCode(v string) *ChangeResourceGroupResponseBody {
	s.Code = &v
	return s
}

func (s *ChangeResourceGroupResponseBody) SetData(v *ChangeResourceGroupResponseBodyData) *ChangeResourceGroupResponseBody {
	s.Data = v
	return s
}

func (s *ChangeResourceGroupResponseBody) SetMessage(v string) *ChangeResourceGroupResponseBody {
	s.Message = &v
	return s
}

func (s *ChangeResourceGroupResponseBody) SetRequestId(v string) *ChangeResourceGroupResponseBody {
	s.RequestId = &v
	return s
}

type ChangeResourceGroupResponseBodyData struct {
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The resource ID.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
}

func (s ChangeResourceGroupResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceGroupResponseBodyData) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupResponseBodyData) SetResourceGroupId(v string) *ChangeResourceGroupResponseBodyData {
	s.ResourceGroupId = &v
	return s
}

func (s *ChangeResourceGroupResponseBodyData) SetResourceId(v string) *ChangeResourceGroupResponseBodyData {
	s.ResourceId = &v
	return s
}

type ChangeResourceGroupResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ChangeResourceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ChangeResourceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceGroupResponse) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupResponse) SetHeaders(v map[string]*string) *ChangeResourceGroupResponse {
	s.Headers = v
	return s
}

func (s *ChangeResourceGroupResponse) SetStatusCode(v int32) *ChangeResourceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ChangeResourceGroupResponse) SetBody(v *ChangeResourceGroupResponseBody) *ChangeResourceGroupResponse {
	s.Body = v
	return s
}

type CheckCommercialStatusRequest struct {
	// The region ID. Default value: cn-hangzhou.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Sub-services:
	// - apm: Application Monitoring
	// - rum: Real User Monitoring
	// - prometheus: Managed Service for Prometheus
	// - xtrace: Managed Service for OpenTelemetry
	Service *string `json:"Service,omitempty" xml:"Service,omitempty"`
}

func (s CheckCommercialStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s CheckCommercialStatusRequest) GoString() string {
	return s.String()
}

func (s *CheckCommercialStatusRequest) SetRegionId(v string) *CheckCommercialStatusRequest {
	s.RegionId = &v
	return s
}

func (s *CheckCommercialStatusRequest) SetService(v string) *CheckCommercialStatusRequest {
	s.Service = &v
	return s
}

type CheckCommercialStatusResponseBody struct {
	// The returned struct.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CheckCommercialStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CheckCommercialStatusResponseBody) GoString() string {
	return s.String()
}

func (s *CheckCommercialStatusResponseBody) SetData(v string) *CheckCommercialStatusResponseBody {
	s.Data = &v
	return s
}

func (s *CheckCommercialStatusResponseBody) SetRequestId(v string) *CheckCommercialStatusResponseBody {
	s.RequestId = &v
	return s
}

type CheckCommercialStatusResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CheckCommercialStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CheckCommercialStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s CheckCommercialStatusResponse) GoString() string {
	return s.String()
}

func (s *CheckCommercialStatusResponse) SetHeaders(v map[string]*string) *CheckCommercialStatusResponse {
	s.Headers = v
	return s
}

func (s *CheckCommercialStatusResponse) SetStatusCode(v int32) *CheckCommercialStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *CheckCommercialStatusResponse) SetBody(v *CheckCommercialStatusResponseBody) *CheckCommercialStatusResponse {
	s.Body = v
	return s
}

type CheckServiceStatusRequest struct {
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The service code of an Alibaba Cloud service. The service code of Managed Service for Prometheus is prometheus.
	SvcCode *string `json:"SvcCode,omitempty" xml:"SvcCode,omitempty"`
}

func (s CheckServiceStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s CheckServiceStatusRequest) GoString() string {
	return s.String()
}

func (s *CheckServiceStatusRequest) SetRegionId(v string) *CheckServiceStatusRequest {
	s.RegionId = &v
	return s
}

func (s *CheckServiceStatusRequest) SetSvcCode(v string) *CheckServiceStatusRequest {
	s.SvcCode = &v
	return s
}

type CheckServiceStatusResponseBody struct {
	// Indicates whether the request was successful. Valid values:
	//
	// *   true.
	// *   false.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The request ID. You can use the ID to find logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CheckServiceStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CheckServiceStatusResponseBody) GoString() string {
	return s.String()
}

func (s *CheckServiceStatusResponseBody) SetData(v string) *CheckServiceStatusResponseBody {
	s.Data = &v
	return s
}

func (s *CheckServiceStatusResponseBody) SetRequestId(v string) *CheckServiceStatusResponseBody {
	s.RequestId = &v
	return s
}

type CheckServiceStatusResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CheckServiceStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CheckServiceStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s CheckServiceStatusResponse) GoString() string {
	return s.String()
}

func (s *CheckServiceStatusResponse) SetHeaders(v map[string]*string) *CheckServiceStatusResponse {
	s.Headers = v
	return s
}

func (s *CheckServiceStatusResponse) SetStatusCode(v int32) *CheckServiceStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *CheckServiceStatusResponse) SetBody(v *CheckServiceStatusResponseBody) *CheckServiceStatusResponse {
	s.Body = v
	return s
}

type ClaimAlarmRequest struct {
	AlarmId   *int64  `json:"AlarmId,omitempty" xml:"AlarmId,omitempty"`
	HandlerId *int64  `json:"HandlerId,omitempty" xml:"HandlerId,omitempty"`
	RegionId  *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ClaimAlarmRequest) String() string {
	return tea.Prettify(s)
}

func (s ClaimAlarmRequest) GoString() string {
	return s.String()
}

func (s *ClaimAlarmRequest) SetAlarmId(v int64) *ClaimAlarmRequest {
	s.AlarmId = &v
	return s
}

func (s *ClaimAlarmRequest) SetHandlerId(v int64) *ClaimAlarmRequest {
	s.HandlerId = &v
	return s
}

func (s *ClaimAlarmRequest) SetRegionId(v string) *ClaimAlarmRequest {
	s.RegionId = &v
	return s
}

type ClaimAlarmResponseBody struct {
	Code      *int64  `json:"Code,omitempty" xml:"Code,omitempty"`
	Message   *string `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *bool   `json:"Result,omitempty" xml:"Result,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ClaimAlarmResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ClaimAlarmResponseBody) GoString() string {
	return s.String()
}

func (s *ClaimAlarmResponseBody) SetCode(v int64) *ClaimAlarmResponseBody {
	s.Code = &v
	return s
}

func (s *ClaimAlarmResponseBody) SetMessage(v string) *ClaimAlarmResponseBody {
	s.Message = &v
	return s
}

func (s *ClaimAlarmResponseBody) SetRequestId(v string) *ClaimAlarmResponseBody {
	s.RequestId = &v
	return s
}

func (s *ClaimAlarmResponseBody) SetResult(v bool) *ClaimAlarmResponseBody {
	s.Result = &v
	return s
}

func (s *ClaimAlarmResponseBody) SetSuccess(v bool) *ClaimAlarmResponseBody {
	s.Success = &v
	return s
}

type ClaimAlarmResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ClaimAlarmResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ClaimAlarmResponse) String() string {
	return tea.Prettify(s)
}

func (s ClaimAlarmResponse) GoString() string {
	return s.String()
}

func (s *ClaimAlarmResponse) SetHeaders(v map[string]*string) *ClaimAlarmResponse {
	s.Headers = v
	return s
}

func (s *ClaimAlarmResponse) SetStatusCode(v int32) *ClaimAlarmResponse {
	s.StatusCode = &v
	return s
}

func (s *ClaimAlarmResponse) SetBody(v *ClaimAlarmResponseBody) *ClaimAlarmResponse {
	s.Body = v
	return s
}

type CloseAlarmRequest struct {
	AlarmId   *int64  `json:"AlarmId,omitempty" xml:"AlarmId,omitempty"`
	HandlerId *int64  `json:"HandlerId,omitempty" xml:"HandlerId,omitempty"`
	RegionId  *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	Solution  *string `json:"Solution,omitempty" xml:"Solution,omitempty"`
}

func (s CloseAlarmRequest) String() string {
	return tea.Prettify(s)
}

func (s CloseAlarmRequest) GoString() string {
	return s.String()
}

func (s *CloseAlarmRequest) SetAlarmId(v int64) *CloseAlarmRequest {
	s.AlarmId = &v
	return s
}

func (s *CloseAlarmRequest) SetHandlerId(v int64) *CloseAlarmRequest {
	s.HandlerId = &v
	return s
}

func (s *CloseAlarmRequest) SetRegionId(v string) *CloseAlarmRequest {
	s.RegionId = &v
	return s
}

func (s *CloseAlarmRequest) SetSolution(v string) *CloseAlarmRequest {
	s.Solution = &v
	return s
}

type CloseAlarmResponseBody struct {
	Code      *int64  `json:"Code,omitempty" xml:"Code,omitempty"`
	Message   *string `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *bool   `json:"Result,omitempty" xml:"Result,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CloseAlarmResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CloseAlarmResponseBody) GoString() string {
	return s.String()
}

func (s *CloseAlarmResponseBody) SetCode(v int64) *CloseAlarmResponseBody {
	s.Code = &v
	return s
}

func (s *CloseAlarmResponseBody) SetMessage(v string) *CloseAlarmResponseBody {
	s.Message = &v
	return s
}

func (s *CloseAlarmResponseBody) SetRequestId(v string) *CloseAlarmResponseBody {
	s.RequestId = &v
	return s
}

func (s *CloseAlarmResponseBody) SetResult(v bool) *CloseAlarmResponseBody {
	s.Result = &v
	return s
}

func (s *CloseAlarmResponseBody) SetSuccess(v bool) *CloseAlarmResponseBody {
	s.Success = &v
	return s
}

type CloseAlarmResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CloseAlarmResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CloseAlarmResponse) String() string {
	return tea.Prettify(s)
}

func (s CloseAlarmResponse) GoString() string {
	return s.String()
}

func (s *CloseAlarmResponse) SetHeaders(v map[string]*string) *CloseAlarmResponse {
	s.Headers = v
	return s
}

func (s *CloseAlarmResponse) SetStatusCode(v int32) *CloseAlarmResponse {
	s.StatusCode = &v
	return s
}

func (s *CloseAlarmResponse) SetBody(v *CloseAlarmResponseBody) *CloseAlarmResponse {
	s.Body = v
	return s
}

type ConfigAppRequest struct {
	// The process identifier (PID) of the application. Separate multiple PIDs with commas (,).
	AppIds *string `json:"AppIds,omitempty" xml:"AppIds,omitempty"`
	// Specifies whether to turn on or off the main switch of the ARMS agent. The monitoring stops after the switch is turned off. If you do not specify this parameter, the main switch status of the ARMS agent is queried.
	//
	// *   `true`: turns on the switch
	// *   `false`: turns off the switch
	Enable *string `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The type of the application. Set the value to **TRACE**.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ConfigAppRequest) String() string {
	return tea.Prettify(s)
}

func (s ConfigAppRequest) GoString() string {
	return s.String()
}

func (s *ConfigAppRequest) SetAppIds(v string) *ConfigAppRequest {
	s.AppIds = &v
	return s
}

func (s *ConfigAppRequest) SetEnable(v string) *ConfigAppRequest {
	s.Enable = &v
	return s
}

func (s *ConfigAppRequest) SetRegionId(v string) *ConfigAppRequest {
	s.RegionId = &v
	return s
}

func (s *ConfigAppRequest) SetType(v string) *ConfigAppRequest {
	s.Type = &v
	return s
}

type ConfigAppResponseBody struct {
	// The result of turning on or off the main switch of the ARMS agent or the main switch status of the ARMS agent. Indicates whether the request was successful. Valid values: success failed The main switch status of the ARMS agent. Valid values: true false
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ConfigAppResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ConfigAppResponseBody) GoString() string {
	return s.String()
}

func (s *ConfigAppResponseBody) SetData(v string) *ConfigAppResponseBody {
	s.Data = &v
	return s
}

func (s *ConfigAppResponseBody) SetRequestId(v string) *ConfigAppResponseBody {
	s.RequestId = &v
	return s
}

type ConfigAppResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ConfigAppResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ConfigAppResponse) String() string {
	return tea.Prettify(s)
}

func (s ConfigAppResponse) GoString() string {
	return s.String()
}

func (s *ConfigAppResponse) SetHeaders(v map[string]*string) *ConfigAppResponse {
	s.Headers = v
	return s
}

func (s *ConfigAppResponse) SetStatusCode(v int32) *ConfigAppResponse {
	s.StatusCode = &v
	return s
}

func (s *ConfigAppResponse) SetBody(v *ConfigAppResponseBody) *ConfigAppResponse {
	s.Body = v
	return s
}

type CreateAlertContactRequest struct {
	// The name of the alert contact.
	ContactName *string `json:"ContactName,omitempty" xml:"ContactName,omitempty"`
	// The webhook URL of the DingTalk chatbot. For more information about how to obtain the URL, see [Configure a DingTalk chatbot to send alert notifications](https://www.alibabacloud.com/help/zh/doc-detail/106247.htm). You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.
	//
	// >  Enter `alert` in the custom keyword field of DingTalk chatbot security settings.
	DingRobotWebhookUrl *string `json:"DingRobotWebhookUrl,omitempty" xml:"DingRobotWebhookUrl,omitempty"`
	// The email address of the alert contact. You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.
	Email *string `json:"Email,omitempty" xml:"Email,omitempty"`
	// The mobile number of the alert contact. You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.
	PhoneNum *string `json:"PhoneNum,omitempty" xml:"PhoneNum,omitempty"`
	// The ID of the region. Set the value to `cn-hangzhou`.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group. You can obtain the resource group ID in the **Resource Management** console.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Specifies whether the alert contact receives system notifications. Valid values:
	//
	// *   `true`: The alert contact receives system notifications.
	// *   `false`: The alert contact does not receive system notifications.
	SystemNoc *bool `json:"SystemNoc,omitempty" xml:"SystemNoc,omitempty"`
}

func (s CreateAlertContactRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAlertContactRequest) GoString() string {
	return s.String()
}

func (s *CreateAlertContactRequest) SetContactName(v string) *CreateAlertContactRequest {
	s.ContactName = &v
	return s
}

func (s *CreateAlertContactRequest) SetDingRobotWebhookUrl(v string) *CreateAlertContactRequest {
	s.DingRobotWebhookUrl = &v
	return s
}

func (s *CreateAlertContactRequest) SetEmail(v string) *CreateAlertContactRequest {
	s.Email = &v
	return s
}

func (s *CreateAlertContactRequest) SetPhoneNum(v string) *CreateAlertContactRequest {
	s.PhoneNum = &v
	return s
}

func (s *CreateAlertContactRequest) SetRegionId(v string) *CreateAlertContactRequest {
	s.RegionId = &v
	return s
}

func (s *CreateAlertContactRequest) SetResourceGroupId(v string) *CreateAlertContactRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateAlertContactRequest) SetSystemNoc(v bool) *CreateAlertContactRequest {
	s.SystemNoc = &v
	return s
}

type CreateAlertContactResponseBody struct {
	// The ID of the alert contact.
	ContactId *string `json:"ContactId,omitempty" xml:"ContactId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAlertContactResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateAlertContactResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAlertContactResponseBody) SetContactId(v string) *CreateAlertContactResponseBody {
	s.ContactId = &v
	return s
}

func (s *CreateAlertContactResponseBody) SetRequestId(v string) *CreateAlertContactResponseBody {
	s.RequestId = &v
	return s
}

type CreateAlertContactResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateAlertContactResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateAlertContactResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAlertContactResponse) GoString() string {
	return s.String()
}

func (s *CreateAlertContactResponse) SetHeaders(v map[string]*string) *CreateAlertContactResponse {
	s.Headers = v
	return s
}

func (s *CreateAlertContactResponse) SetStatusCode(v int32) *CreateAlertContactResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAlertContactResponse) SetBody(v *CreateAlertContactResponseBody) *CreateAlertContactResponse {
	s.Body = v
	return s
}

type CreateAlertContactGroupRequest struct {
	ContactGroupName *string `json:"ContactGroupName,omitempty" xml:"ContactGroupName,omitempty"`
	ContactIds       *string `json:"ContactIds,omitempty" xml:"ContactIds,omitempty"`
	RegionId         *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateAlertContactGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAlertContactGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateAlertContactGroupRequest) SetContactGroupName(v string) *CreateAlertContactGroupRequest {
	s.ContactGroupName = &v
	return s
}

func (s *CreateAlertContactGroupRequest) SetContactIds(v string) *CreateAlertContactGroupRequest {
	s.ContactIds = &v
	return s
}

func (s *CreateAlertContactGroupRequest) SetRegionId(v string) *CreateAlertContactGroupRequest {
	s.RegionId = &v
	return s
}

type CreateAlertContactGroupResponseBody struct {
	ContactGroupId *string `json:"ContactGroupId,omitempty" xml:"ContactGroupId,omitempty"`
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAlertContactGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateAlertContactGroupResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAlertContactGroupResponseBody) SetContactGroupId(v string) *CreateAlertContactGroupResponseBody {
	s.ContactGroupId = &v
	return s
}

func (s *CreateAlertContactGroupResponseBody) SetRequestId(v string) *CreateAlertContactGroupResponseBody {
	s.RequestId = &v
	return s
}

type CreateAlertContactGroupResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateAlertContactGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateAlertContactGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAlertContactGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateAlertContactGroupResponse) SetHeaders(v map[string]*string) *CreateAlertContactGroupResponse {
	s.Headers = v
	return s
}

func (s *CreateAlertContactGroupResponse) SetStatusCode(v int32) *CreateAlertContactGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAlertContactGroupResponse) SetBody(v *CreateAlertContactGroupResponseBody) *CreateAlertContactGroupResponse {
	s.Body = v
	return s
}

type CreateDispatchRuleRequest struct {
	// ## Additional information about the **DispatchRule** parameter
	//
	// **JSON string example and description**
	//
	// ```
	//
	// {
	//   "system": false,        // Specifies whether the dispatch rule is editable. Valid values: true: not editable. false: editable.
	//   "ruleid": 10282,           // The ID of the dispatch rule.
	//   "name": "Prometheus Alert",   // The name of the dispatch policy.
	//   "labelMatchExpressionGrid": {
	//     "labelMatchExpressionGroups": [     // Sets the dispatch rule.
	//       {
	//         "labelMatchExpressions": [
	//           {
	//             "key": "_aliyun_arms_involvedObject_kind", // The key of the tag of the dispatch rule. For more information, see the next section.
	//             "value": "app",                              // The value of the tag.
	//             "operator": "eq"                             // The operator used in the dispatch rule. Valid values: eq: equals to. re: matches a regular expression.
	//           }
	//         ]
	//       }
	//     ]
	//   },
	//   "dispatchType": "CREATE_ALERT/DISCARD_ALERT",    // The alert handling method. Valid values: CREATE_ALERT: generates an alert. DISCARD_ALERT: discards the alert event and generates no alert.
	//   "isRecover": true,               // Specifies whether to send the restored alert. Valid values: true: sends the alert. false: does not send the alert.
	//   "groupRules": [                  // Sets the event group.
	//     {
	//       "groupId": 1,               // The ID of the group.
	//       "groupingFields": [         // The fields that are used to group events. Events with the same field content are assigned to a group. Alerts with the same specified grouping field are sent to the handler in separate notifications.
	//         "alertname"
	//       ],
	//       "groupWait": 10,                 // The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
	//       "groupInterval": 15,             // The grouping interval. During the silence period of repeated alerts, if new alerts are generated, they will be sent after the group waiting time.
	//       "repeatInterval": 20             // The silence period of repeated alerts. All alerts are repeatedly sent at specified intervals until the alerts are cleared.
	//     }
	//   ],
	//   "notifyRules": [            // Sets the notification rule.
	//     {
	//       "notifyObjects": [
	//         {
	//           "notifyType": "ARMS_CONTACT",     // The type of the alert contact. Valid values: ARMS_CONTACT: contact. ARMS_CONTACT_GROUP: contact group.
	//           "name": "JohnDoe",                // The name of the contact or contact group.
	//           "notifyObjectId": 1               // The ID of the contact or contact group.
	//         },
	//         {
	//           "notifyType": "ARMS_CONTACT_GROUP",
	//           "name": "JohnDoe_group",
	//           "notifyObjectId": 2
	//         }
	//       ],
	//       "notifyChannels":["dingTalk","wechat","webhook","email"]     // The notification method. Valid values: dingTalk, sms, webhook, email, and wechat.
	//     },
	//   ],
	// }
	// ```
	//
	// **Enumerated keys of the tag of the dispatch rule**
	//
	// *   `_aliyun_arms_userid`: user ID
	// *   `_aliyun_arms_involvedObject_kind`: type of the associated object
	// *   `_aliyun_arms_involvedObject_id`: ID of the associated object
	// *   `_aliyun_arms_involvedObject_name`: name of the associated object
	// *   `_aliyun_arms_alert_name`: alert name
	// *   `_aliyun_arms_alert_rule_id`: alert rule ID
	// *   `_aliyun_arms_alert_type`: alert type
	// *   `_aliyun_arms_alert_level`: alert severity
	DispatchRule *string `json:"DispatchRule,omitempty" xml:"DispatchRule,omitempty"`
	RegionId     *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateDispatchRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDispatchRuleRequest) GoString() string {
	return s.String()
}

func (s *CreateDispatchRuleRequest) SetDispatchRule(v string) *CreateDispatchRuleRequest {
	s.DispatchRule = &v
	return s
}

func (s *CreateDispatchRuleRequest) SetRegionId(v string) *CreateDispatchRuleRequest {
	s.RegionId = &v
	return s
}

type CreateDispatchRuleResponseBody struct {
	DispatchRuleId *int64  `json:"DispatchRuleId,omitempty" xml:"DispatchRuleId,omitempty"`
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDispatchRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDispatchRuleResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDispatchRuleResponseBody) SetDispatchRuleId(v int64) *CreateDispatchRuleResponseBody {
	s.DispatchRuleId = &v
	return s
}

func (s *CreateDispatchRuleResponseBody) SetRequestId(v string) *CreateDispatchRuleResponseBody {
	s.RequestId = &v
	return s
}

type CreateDispatchRuleResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDispatchRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDispatchRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDispatchRuleResponse) GoString() string {
	return s.String()
}

func (s *CreateDispatchRuleResponse) SetHeaders(v map[string]*string) *CreateDispatchRuleResponse {
	s.Headers = v
	return s
}

func (s *CreateDispatchRuleResponse) SetStatusCode(v int32) *CreateDispatchRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDispatchRuleResponse) SetBody(v *CreateDispatchRuleResponseBody) *CreateDispatchRuleResponse {
	s.Body = v
	return s
}

type CreateEnvCustomJobRequest struct {
	// The language. Valid values: zh and en. Default value: zh.
	AliyunLang *string `json:"AliyunLang,omitempty" xml:"AliyunLang,omitempty"`
	// The YAML configuration string of the custom job.
	ConfigYaml *string `json:"ConfigYaml,omitempty" xml:"ConfigYaml,omitempty"`
	// The name of the custom job.
	CustomJobName *string `json:"CustomJobName,omitempty" xml:"CustomJobName,omitempty"`
	// The ID of the environment instance.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateEnvCustomJobRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateEnvCustomJobRequest) GoString() string {
	return s.String()
}

func (s *CreateEnvCustomJobRequest) SetAliyunLang(v string) *CreateEnvCustomJobRequest {
	s.AliyunLang = &v
	return s
}

func (s *CreateEnvCustomJobRequest) SetConfigYaml(v string) *CreateEnvCustomJobRequest {
	s.ConfigYaml = &v
	return s
}

func (s *CreateEnvCustomJobRequest) SetCustomJobName(v string) *CreateEnvCustomJobRequest {
	s.CustomJobName = &v
	return s
}

func (s *CreateEnvCustomJobRequest) SetEnvironmentId(v string) *CreateEnvCustomJobRequest {
	s.EnvironmentId = &v
	return s
}

func (s *CreateEnvCustomJobRequest) SetRegionId(v string) *CreateEnvCustomJobRequest {
	s.RegionId = &v
	return s
}

type CreateEnvCustomJobResponseBody struct {
	// The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The name of the custom job that was created, or the exception information.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateEnvCustomJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateEnvCustomJobResponseBody) GoString() string {
	return s.String()
}

func (s *CreateEnvCustomJobResponseBody) SetCode(v int32) *CreateEnvCustomJobResponseBody {
	s.Code = &v
	return s
}

func (s *CreateEnvCustomJobResponseBody) SetData(v string) *CreateEnvCustomJobResponseBody {
	s.Data = &v
	return s
}

func (s *CreateEnvCustomJobResponseBody) SetMessage(v string) *CreateEnvCustomJobResponseBody {
	s.Message = &v
	return s
}

func (s *CreateEnvCustomJobResponseBody) SetRequestId(v string) *CreateEnvCustomJobResponseBody {
	s.RequestId = &v
	return s
}

type CreateEnvCustomJobResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateEnvCustomJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateEnvCustomJobResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateEnvCustomJobResponse) GoString() string {
	return s.String()
}

func (s *CreateEnvCustomJobResponse) SetHeaders(v map[string]*string) *CreateEnvCustomJobResponse {
	s.Headers = v
	return s
}

func (s *CreateEnvCustomJobResponse) SetStatusCode(v int32) *CreateEnvCustomJobResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateEnvCustomJobResponse) SetBody(v *CreateEnvCustomJobResponseBody) *CreateEnvCustomJobResponse {
	s.Body = v
	return s
}

type CreateEnvPodMonitorRequest struct {
	// The language. Valid values: zh and en. Default value: zh.
	AliyunLang *string `json:"AliyunLang,omitempty" xml:"AliyunLang,omitempty"`
	// The YAML configuration string of the PodMonitor.
	ConfigYaml *string `json:"ConfigYaml,omitempty" xml:"ConfigYaml,omitempty"`
	// Specifies whether to perform only a dry run, without performing the actual request.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the environment instance.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateEnvPodMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateEnvPodMonitorRequest) GoString() string {
	return s.String()
}

func (s *CreateEnvPodMonitorRequest) SetAliyunLang(v string) *CreateEnvPodMonitorRequest {
	s.AliyunLang = &v
	return s
}

func (s *CreateEnvPodMonitorRequest) SetConfigYaml(v string) *CreateEnvPodMonitorRequest {
	s.ConfigYaml = &v
	return s
}

func (s *CreateEnvPodMonitorRequest) SetDryRun(v bool) *CreateEnvPodMonitorRequest {
	s.DryRun = &v
	return s
}

func (s *CreateEnvPodMonitorRequest) SetEnvironmentId(v string) *CreateEnvPodMonitorRequest {
	s.EnvironmentId = &v
	return s
}

func (s *CreateEnvPodMonitorRequest) SetRegionId(v string) *CreateEnvPodMonitorRequest {
	s.RegionId = &v
	return s
}

type CreateEnvPodMonitorResponseBody struct {
	// The HTTP status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned result, which indicates whether the operation was successful.
	Data *CreateEnvPodMonitorResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateEnvPodMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateEnvPodMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *CreateEnvPodMonitorResponseBody) SetCode(v int32) *CreateEnvPodMonitorResponseBody {
	s.Code = &v
	return s
}

func (s *CreateEnvPodMonitorResponseBody) SetData(v *CreateEnvPodMonitorResponseBodyData) *CreateEnvPodMonitorResponseBody {
	s.Data = v
	return s
}

func (s *CreateEnvPodMonitorResponseBody) SetMessage(v string) *CreateEnvPodMonitorResponseBody {
	s.Message = &v
	return s
}

func (s *CreateEnvPodMonitorResponseBody) SetRequestId(v string) *CreateEnvPodMonitorResponseBody {
	s.RequestId = &v
	return s
}

type CreateEnvPodMonitorResponseBodyData struct {
	// Indicates whether targets are matched.
	MatchedMsg *string `json:"MatchedMsg,omitempty" xml:"MatchedMsg,omitempty"`
	// The number of matched targets.
	MatchedTargetCount *string `json:"MatchedTargetCount,omitempty" xml:"MatchedTargetCount,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The name of the created PodMonitor.
	PodMonitorName *string `json:"PodMonitorName,omitempty" xml:"PodMonitorName,omitempty"`
}

func (s CreateEnvPodMonitorResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateEnvPodMonitorResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateEnvPodMonitorResponseBodyData) SetMatchedMsg(v string) *CreateEnvPodMonitorResponseBodyData {
	s.MatchedMsg = &v
	return s
}

func (s *CreateEnvPodMonitorResponseBodyData) SetMatchedTargetCount(v string) *CreateEnvPodMonitorResponseBodyData {
	s.MatchedTargetCount = &v
	return s
}

func (s *CreateEnvPodMonitorResponseBodyData) SetNamespace(v string) *CreateEnvPodMonitorResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *CreateEnvPodMonitorResponseBodyData) SetPodMonitorName(v string) *CreateEnvPodMonitorResponseBodyData {
	s.PodMonitorName = &v
	return s
}

type CreateEnvPodMonitorResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateEnvPodMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateEnvPodMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateEnvPodMonitorResponse) GoString() string {
	return s.String()
}

func (s *CreateEnvPodMonitorResponse) SetHeaders(v map[string]*string) *CreateEnvPodMonitorResponse {
	s.Headers = v
	return s
}

func (s *CreateEnvPodMonitorResponse) SetStatusCode(v int32) *CreateEnvPodMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateEnvPodMonitorResponse) SetBody(v *CreateEnvPodMonitorResponseBody) *CreateEnvPodMonitorResponse {
	s.Body = v
	return s
}

type CreateEnvServiceMonitorRequest struct {
	// The language. Valid values: zh and en. Default value: zh.
	AliyunLang *string `json:"AliyunLang,omitempty" xml:"AliyunLang,omitempty"`
	// The YAML configuration string of the ServiceMonitor.
	ConfigYaml *string `json:"ConfigYaml,omitempty" xml:"ConfigYaml,omitempty"`
	// Specifies whether to perform only a dry run, without performing the actual request.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the environment instance.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateEnvServiceMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateEnvServiceMonitorRequest) GoString() string {
	return s.String()
}

func (s *CreateEnvServiceMonitorRequest) SetAliyunLang(v string) *CreateEnvServiceMonitorRequest {
	s.AliyunLang = &v
	return s
}

func (s *CreateEnvServiceMonitorRequest) SetConfigYaml(v string) *CreateEnvServiceMonitorRequest {
	s.ConfigYaml = &v
	return s
}

func (s *CreateEnvServiceMonitorRequest) SetDryRun(v bool) *CreateEnvServiceMonitorRequest {
	s.DryRun = &v
	return s
}

func (s *CreateEnvServiceMonitorRequest) SetEnvironmentId(v string) *CreateEnvServiceMonitorRequest {
	s.EnvironmentId = &v
	return s
}

func (s *CreateEnvServiceMonitorRequest) SetRegionId(v string) *CreateEnvServiceMonitorRequest {
	s.RegionId = &v
	return s
}

type CreateEnvServiceMonitorResponseBody struct {
	// The HTTP status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned struct.
	Data *CreateEnvServiceMonitorResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateEnvServiceMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateEnvServiceMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *CreateEnvServiceMonitorResponseBody) SetCode(v int32) *CreateEnvServiceMonitorResponseBody {
	s.Code = &v
	return s
}

func (s *CreateEnvServiceMonitorResponseBody) SetData(v *CreateEnvServiceMonitorResponseBodyData) *CreateEnvServiceMonitorResponseBody {
	s.Data = v
	return s
}

func (s *CreateEnvServiceMonitorResponseBody) SetMessage(v string) *CreateEnvServiceMonitorResponseBody {
	s.Message = &v
	return s
}

func (s *CreateEnvServiceMonitorResponseBody) SetRequestId(v string) *CreateEnvServiceMonitorResponseBody {
	s.RequestId = &v
	return s
}

type CreateEnvServiceMonitorResponseBodyData struct {
	// Indicates whether targets are matched.
	MatchedMsg *string `json:"MatchedMsg,omitempty" xml:"MatchedMsg,omitempty"`
	// The number of matched targets.
	MatchedTargetCount *int32 `json:"MatchedTargetCount,omitempty" xml:"MatchedTargetCount,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The name of the created ServiceMonitor.
	ServiceMonitorName *string `json:"ServiceMonitorName,omitempty" xml:"ServiceMonitorName,omitempty"`
}

func (s CreateEnvServiceMonitorResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateEnvServiceMonitorResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateEnvServiceMonitorResponseBodyData) SetMatchedMsg(v string) *CreateEnvServiceMonitorResponseBodyData {
	s.MatchedMsg = &v
	return s
}

func (s *CreateEnvServiceMonitorResponseBodyData) SetMatchedTargetCount(v int32) *CreateEnvServiceMonitorResponseBodyData {
	s.MatchedTargetCount = &v
	return s
}

func (s *CreateEnvServiceMonitorResponseBodyData) SetNamespace(v string) *CreateEnvServiceMonitorResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *CreateEnvServiceMonitorResponseBodyData) SetServiceMonitorName(v string) *CreateEnvServiceMonitorResponseBodyData {
	s.ServiceMonitorName = &v
	return s
}

type CreateEnvServiceMonitorResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateEnvServiceMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateEnvServiceMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateEnvServiceMonitorResponse) GoString() string {
	return s.String()
}

func (s *CreateEnvServiceMonitorResponse) SetHeaders(v map[string]*string) *CreateEnvServiceMonitorResponse {
	s.Headers = v
	return s
}

func (s *CreateEnvServiceMonitorResponse) SetStatusCode(v int32) *CreateEnvServiceMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateEnvServiceMonitorResponse) SetBody(v *CreateEnvServiceMonitorResponseBody) *CreateEnvServiceMonitorResponse {
	s.Body = v
	return s
}

type CreateEnvironmentRequest struct {
	// The language. Valid values: zh and en. Default value: zh.
	AliyunLang *string `json:"AliyunLang,omitempty" xml:"AliyunLang,omitempty"`
	// The ID of the resource bound to the environment, such as the container ID or VPC ID. For a Cloud environment, specify the region ID.
	BindResourceId *string `json:"BindResourceId,omitempty" xml:"BindResourceId,omitempty"`
	// The name of the environment.
	EnvironmentName *string `json:"EnvironmentName,omitempty" xml:"EnvironmentName,omitempty"`
	// The subtype of the environment. Valid values:
	//
	// *   CS: Container Service for Kubernetes (ACK)
	// *   ECS: Elastic Compute Service (ECS)
	// *   Cloud: cloud service
	EnvironmentSubType *string `json:"EnvironmentSubType,omitempty" xml:"EnvironmentSubType,omitempty"`
	// The type of the environment. Valid values:
	//
	// *   CS: Container Service
	// *   ECS: Elastic Compute Service
	// *   Cloud: cloud service
	EnvironmentType *string `json:"EnvironmentType,omitempty" xml:"EnvironmentType,omitempty"`
	// type of managed：
	// - none: not managed. default value of prometheus for ACK.
	// - agent: managed agent. default value of  promehtues for ASK/ACS/AckOne.
	// - agent-exproter: maanged agent and exporter. default of prometheus for Cloud.
	ManagedType *string `json:"ManagedType,omitempty" xml:"ManagedType,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The tags of the instance. You can specify this parameter to manage tags for the instance.
	Tags []*CreateEnvironmentRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s CreateEnvironmentRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateEnvironmentRequest) GoString() string {
	return s.String()
}

func (s *CreateEnvironmentRequest) SetAliyunLang(v string) *CreateEnvironmentRequest {
	s.AliyunLang = &v
	return s
}

func (s *CreateEnvironmentRequest) SetBindResourceId(v string) *CreateEnvironmentRequest {
	s.BindResourceId = &v
	return s
}

func (s *CreateEnvironmentRequest) SetEnvironmentName(v string) *CreateEnvironmentRequest {
	s.EnvironmentName = &v
	return s
}

func (s *CreateEnvironmentRequest) SetEnvironmentSubType(v string) *CreateEnvironmentRequest {
	s.EnvironmentSubType = &v
	return s
}

func (s *CreateEnvironmentRequest) SetEnvironmentType(v string) *CreateEnvironmentRequest {
	s.EnvironmentType = &v
	return s
}

func (s *CreateEnvironmentRequest) SetManagedType(v string) *CreateEnvironmentRequest {
	s.ManagedType = &v
	return s
}

func (s *CreateEnvironmentRequest) SetRegionId(v string) *CreateEnvironmentRequest {
	s.RegionId = &v
	return s
}

func (s *CreateEnvironmentRequest) SetResourceGroupId(v string) *CreateEnvironmentRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateEnvironmentRequest) SetTags(v []*CreateEnvironmentRequestTags) *CreateEnvironmentRequest {
	s.Tags = v
	return s
}

type CreateEnvironmentRequestTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateEnvironmentRequestTags) String() string {
	return tea.Prettify(s)
}

func (s CreateEnvironmentRequestTags) GoString() string {
	return s.String()
}

func (s *CreateEnvironmentRequestTags) SetKey(v string) *CreateEnvironmentRequestTags {
	s.Key = &v
	return s
}

func (s *CreateEnvironmentRequestTags) SetValue(v string) *CreateEnvironmentRequestTags {
	s.Value = &v
	return s
}

type CreateEnvironmentResponseBody struct {
	// The HTTP status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the created environment.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateEnvironmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateEnvironmentResponseBody) GoString() string {
	return s.String()
}

func (s *CreateEnvironmentResponseBody) SetCode(v int32) *CreateEnvironmentResponseBody {
	s.Code = &v
	return s
}

func (s *CreateEnvironmentResponseBody) SetData(v string) *CreateEnvironmentResponseBody {
	s.Data = &v
	return s
}

func (s *CreateEnvironmentResponseBody) SetMessage(v string) *CreateEnvironmentResponseBody {
	s.Message = &v
	return s
}

func (s *CreateEnvironmentResponseBody) SetRequestId(v string) *CreateEnvironmentResponseBody {
	s.RequestId = &v
	return s
}

type CreateEnvironmentResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateEnvironmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateEnvironmentResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateEnvironmentResponse) GoString() string {
	return s.String()
}

func (s *CreateEnvironmentResponse) SetHeaders(v map[string]*string) *CreateEnvironmentResponse {
	s.Headers = v
	return s
}

func (s *CreateEnvironmentResponse) SetStatusCode(v int32) *CreateEnvironmentResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateEnvironmentResponse) SetBody(v *CreateEnvironmentResponseBody) *CreateEnvironmentResponse {
	s.Body = v
	return s
}

type CreateGrafanaWorkspaceRequest struct {
	AliyunLang              *string                              `json:"AliyunLang,omitempty" xml:"AliyunLang,omitempty"`
	Description             *string                              `json:"Description,omitempty" xml:"Description,omitempty"`
	GrafanaVersion          *string                              `json:"GrafanaVersion,omitempty" xml:"GrafanaVersion,omitempty"`
	GrafanaWorkspaceEdition *string                              `json:"GrafanaWorkspaceEdition,omitempty" xml:"GrafanaWorkspaceEdition,omitempty"`
	GrafanaWorkspaceName    *string                              `json:"GrafanaWorkspaceName,omitempty" xml:"GrafanaWorkspaceName,omitempty"`
	Password                *string                              `json:"Password,omitempty" xml:"Password,omitempty"`
	RegionId                *string                              `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId         *string                              `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	Tags                    []*CreateGrafanaWorkspaceRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s CreateGrafanaWorkspaceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateGrafanaWorkspaceRequest) GoString() string {
	return s.String()
}

func (s *CreateGrafanaWorkspaceRequest) SetAliyunLang(v string) *CreateGrafanaWorkspaceRequest {
	s.AliyunLang = &v
	return s
}

func (s *CreateGrafanaWorkspaceRequest) SetDescription(v string) *CreateGrafanaWorkspaceRequest {
	s.Description = &v
	return s
}

func (s *CreateGrafanaWorkspaceRequest) SetGrafanaVersion(v string) *CreateGrafanaWorkspaceRequest {
	s.GrafanaVersion = &v
	return s
}

func (s *CreateGrafanaWorkspaceRequest) SetGrafanaWorkspaceEdition(v string) *CreateGrafanaWorkspaceRequest {
	s.GrafanaWorkspaceEdition = &v
	return s
}

func (s *CreateGrafanaWorkspaceRequest) SetGrafanaWorkspaceName(v string) *CreateGrafanaWorkspaceRequest {
	s.GrafanaWorkspaceName = &v
	return s
}

func (s *CreateGrafanaWorkspaceRequest) SetPassword(v string) *CreateGrafanaWorkspaceRequest {
	s.Password = &v
	return s
}

func (s *CreateGrafanaWorkspaceRequest) SetRegionId(v string) *CreateGrafanaWorkspaceRequest {
	s.RegionId = &v
	return s
}

func (s *CreateGrafanaWorkspaceRequest) SetResourceGroupId(v string) *CreateGrafanaWorkspaceRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateGrafanaWorkspaceRequest) SetTags(v []*CreateGrafanaWorkspaceRequestTags) *CreateGrafanaWorkspaceRequest {
	s.Tags = v
	return s
}

type CreateGrafanaWorkspaceRequestTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateGrafanaWorkspaceRequestTags) String() string {
	return tea.Prettify(s)
}

func (s CreateGrafanaWorkspaceRequestTags) GoString() string {
	return s.String()
}

func (s *CreateGrafanaWorkspaceRequestTags) SetKey(v string) *CreateGrafanaWorkspaceRequestTags {
	s.Key = &v
	return s
}

func (s *CreateGrafanaWorkspaceRequestTags) SetValue(v string) *CreateGrafanaWorkspaceRequestTags {
	s.Value = &v
	return s
}

type CreateGrafanaWorkspaceShrinkRequest struct {
	AliyunLang              *string `json:"AliyunLang,omitempty" xml:"AliyunLang,omitempty"`
	Description             *string `json:"Description,omitempty" xml:"Description,omitempty"`
	GrafanaVersion          *string `json:"GrafanaVersion,omitempty" xml:"GrafanaVersion,omitempty"`
	GrafanaWorkspaceEdition *string `json:"GrafanaWorkspaceEdition,omitempty" xml:"GrafanaWorkspaceEdition,omitempty"`
	GrafanaWorkspaceName    *string `json:"GrafanaWorkspaceName,omitempty" xml:"GrafanaWorkspaceName,omitempty"`
	Password                *string `json:"Password,omitempty" xml:"Password,omitempty"`
	RegionId                *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId         *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	TagsShrink              *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s CreateGrafanaWorkspaceShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateGrafanaWorkspaceShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateGrafanaWorkspaceShrinkRequest) SetAliyunLang(v string) *CreateGrafanaWorkspaceShrinkRequest {
	s.AliyunLang = &v
	return s
}

func (s *CreateGrafanaWorkspaceShrinkRequest) SetDescription(v string) *CreateGrafanaWorkspaceShrinkRequest {
	s.Description = &v
	return s
}

func (s *CreateGrafanaWorkspaceShrinkRequest) SetGrafanaVersion(v string) *CreateGrafanaWorkspaceShrinkRequest {
	s.GrafanaVersion = &v
	return s
}

func (s *CreateGrafanaWorkspaceShrinkRequest) SetGrafanaWorkspaceEdition(v string) *CreateGrafanaWorkspaceShrinkRequest {
	s.GrafanaWorkspaceEdition = &v
	return s
}

func (s *CreateGrafanaWorkspaceShrinkRequest) SetGrafanaWorkspaceName(v string) *CreateGrafanaWorkspaceShrinkRequest {
	s.GrafanaWorkspaceName = &v
	return s
}

func (s *CreateGrafanaWorkspaceShrinkRequest) SetPassword(v string) *CreateGrafanaWorkspaceShrinkRequest {
	s.Password = &v
	return s
}

func (s *CreateGrafanaWorkspaceShrinkRequest) SetRegionId(v string) *CreateGrafanaWorkspaceShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *CreateGrafanaWorkspaceShrinkRequest) SetResourceGroupId(v string) *CreateGrafanaWorkspaceShrinkRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateGrafanaWorkspaceShrinkRequest) SetTagsShrink(v string) *CreateGrafanaWorkspaceShrinkRequest {
	s.TagsShrink = &v
	return s
}

type CreateGrafanaWorkspaceResponseBody struct {
	Code      *int32            `json:"Code,omitempty" xml:"Code,omitempty"`
	Data      *GrafanaWorkspace `json:"Data,omitempty" xml:"Data,omitempty"`
	Message   *string           `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId *string           `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool             `json:"Success,omitempty" xml:"Success,omitempty"`
	TraceId   *string           `json:"TraceId,omitempty" xml:"TraceId,omitempty"`
}

func (s CreateGrafanaWorkspaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateGrafanaWorkspaceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateGrafanaWorkspaceResponseBody) SetCode(v int32) *CreateGrafanaWorkspaceResponseBody {
	s.Code = &v
	return s
}

func (s *CreateGrafanaWorkspaceResponseBody) SetData(v *GrafanaWorkspace) *CreateGrafanaWorkspaceResponseBody {
	s.Data = v
	return s
}

func (s *CreateGrafanaWorkspaceResponseBody) SetMessage(v string) *CreateGrafanaWorkspaceResponseBody {
	s.Message = &v
	return s
}

func (s *CreateGrafanaWorkspaceResponseBody) SetRequestId(v string) *CreateGrafanaWorkspaceResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateGrafanaWorkspaceResponseBody) SetSuccess(v bool) *CreateGrafanaWorkspaceResponseBody {
	s.Success = &v
	return s
}

func (s *CreateGrafanaWorkspaceResponseBody) SetTraceId(v string) *CreateGrafanaWorkspaceResponseBody {
	s.TraceId = &v
	return s
}

type CreateGrafanaWorkspaceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateGrafanaWorkspaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateGrafanaWorkspaceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateGrafanaWorkspaceResponse) GoString() string {
	return s.String()
}

func (s *CreateGrafanaWorkspaceResponse) SetHeaders(v map[string]*string) *CreateGrafanaWorkspaceResponse {
	s.Headers = v
	return s
}

func (s *CreateGrafanaWorkspaceResponse) SetStatusCode(v int32) *CreateGrafanaWorkspaceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateGrafanaWorkspaceResponse) SetBody(v *CreateGrafanaWorkspaceResponseBody) *CreateGrafanaWorkspaceResponse {
	s.Body = v
	return s
}

type CreateIntegrationRequest struct {
	AutoRecover            *bool   `json:"AutoRecover,omitempty" xml:"AutoRecover,omitempty"`
	Description            *string `json:"Description,omitempty" xml:"Description,omitempty"`
	IntegrationName        *string `json:"IntegrationName,omitempty" xml:"IntegrationName,omitempty"`
	IntegrationProductType *string `json:"IntegrationProductType,omitempty" xml:"IntegrationProductType,omitempty"`
	RecoverTime            *int64  `json:"RecoverTime,omitempty" xml:"RecoverTime,omitempty"`
}

func (s CreateIntegrationRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateIntegrationRequest) GoString() string {
	return s.String()
}

func (s *CreateIntegrationRequest) SetAutoRecover(v bool) *CreateIntegrationRequest {
	s.AutoRecover = &v
	return s
}

func (s *CreateIntegrationRequest) SetDescription(v string) *CreateIntegrationRequest {
	s.Description = &v
	return s
}

func (s *CreateIntegrationRequest) SetIntegrationName(v string) *CreateIntegrationRequest {
	s.IntegrationName = &v
	return s
}

func (s *CreateIntegrationRequest) SetIntegrationProductType(v string) *CreateIntegrationRequest {
	s.IntegrationProductType = &v
	return s
}

func (s *CreateIntegrationRequest) SetRecoverTime(v int64) *CreateIntegrationRequest {
	s.RecoverTime = &v
	return s
}

type CreateIntegrationResponseBody struct {
	Integration *CreateIntegrationResponseBodyIntegration `json:"Integration,omitempty" xml:"Integration,omitempty" type:"Struct"`
	RequestId   *string                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateIntegrationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateIntegrationResponseBody) GoString() string {
	return s.String()
}

func (s *CreateIntegrationResponseBody) SetIntegration(v *CreateIntegrationResponseBodyIntegration) *CreateIntegrationResponseBody {
	s.Integration = v
	return s
}

func (s *CreateIntegrationResponseBody) SetRequestId(v string) *CreateIntegrationResponseBody {
	s.RequestId = &v
	return s
}

type CreateIntegrationResponseBodyIntegration struct {
	AutoRecover            *bool   `json:"AutoRecover,omitempty" xml:"AutoRecover,omitempty"`
	Description            *string `json:"Description,omitempty" xml:"Description,omitempty"`
	IntegrationId          *int64  `json:"IntegrationId,omitempty" xml:"IntegrationId,omitempty"`
	IntegrationName        *string `json:"IntegrationName,omitempty" xml:"IntegrationName,omitempty"`
	IntegrationProductType *string `json:"IntegrationProductType,omitempty" xml:"IntegrationProductType,omitempty"`
	RecoverTime            *int64  `json:"RecoverTime,omitempty" xml:"RecoverTime,omitempty"`
}

func (s CreateIntegrationResponseBodyIntegration) String() string {
	return tea.Prettify(s)
}

func (s CreateIntegrationResponseBodyIntegration) GoString() string {
	return s.String()
}

func (s *CreateIntegrationResponseBodyIntegration) SetAutoRecover(v bool) *CreateIntegrationResponseBodyIntegration {
	s.AutoRecover = &v
	return s
}

func (s *CreateIntegrationResponseBodyIntegration) SetDescription(v string) *CreateIntegrationResponseBodyIntegration {
	s.Description = &v
	return s
}

func (s *CreateIntegrationResponseBodyIntegration) SetIntegrationId(v int64) *CreateIntegrationResponseBodyIntegration {
	s.IntegrationId = &v
	return s
}

func (s *CreateIntegrationResponseBodyIntegration) SetIntegrationName(v string) *CreateIntegrationResponseBodyIntegration {
	s.IntegrationName = &v
	return s
}

func (s *CreateIntegrationResponseBodyIntegration) SetIntegrationProductType(v string) *CreateIntegrationResponseBodyIntegration {
	s.IntegrationProductType = &v
	return s
}

func (s *CreateIntegrationResponseBodyIntegration) SetRecoverTime(v int64) *CreateIntegrationResponseBodyIntegration {
	s.RecoverTime = &v
	return s
}

type CreateIntegrationResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateIntegrationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateIntegrationResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateIntegrationResponse) GoString() string {
	return s.String()
}

func (s *CreateIntegrationResponse) SetHeaders(v map[string]*string) *CreateIntegrationResponse {
	s.Headers = v
	return s
}

func (s *CreateIntegrationResponse) SetStatusCode(v int32) *CreateIntegrationResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateIntegrationResponse) SetBody(v *CreateIntegrationResponseBody) *CreateIntegrationResponse {
	s.Body = v
	return s
}

type CreateOrUpdateAlertRuleRequest struct {
	// The alert check type of the Prometheus alert rule. Valid values:
	//
	// *   STATIC: a static threshold value. If you set the parameter to STATIC, you must specify the **MetricsKey** parameter. For more information, see the **Correspondence between AlertGroup and MetricsKey for Prometheus Service** table.
	// *   CUSTOM: a custom PromQL statement. If you set the parameter to CUSTOM, you must specify the **PromQL**, **Duration**, and **Message** parameters to create a Prometheus alert rule.
	AlertCheckType *string `json:"AlertCheckType,omitempty" xml:"AlertCheckType,omitempty"`
	// The alert contact group ID of the Prometheus alert rule. Valid values:
	//
	// *   \-1: custom PromQL
	// *   1: Kubernetes load
	// *   15: Kubernetes node
	AlertGroup *int64 `json:"AlertGroup,omitempty" xml:"AlertGroup,omitempty"`
	// The ID of the alert rule.
	//
	// *   If you do not specify this parameter, a new alert rule is created.
	// *   If you specify this parameter, the specified alert rule is modified.
	AlertId *int64 `json:"AlertId,omitempty" xml:"AlertId,omitempty"`
	// The name of the alert rule.
	AlertName *string `json:"AlertName,omitempty" xml:"AlertName,omitempty"`
	// Alarm Notification Channel Configuration. Used for compatibility with legacy rules.
	AlertPiplines *string `json:"AlertPiplines,omitempty" xml:"AlertPiplines,omitempty"`
	// The content of the Application Monitoring or Browser Monitoring alert rule. The following code provides an example of the **AlertRuleContent** parameter. For more information about the meaning of each field, see the supplementary description.
	//
	// ```json
	// {
	//     "Condition": "OR",
	//      "AlertRuleItems": [
	//              { "Operator": "CURRENT_LTE",
	//                  "MetricKey": "appstat.jvm.threadcount",
	//                  "Value": 1000,
	//                  "Aggregate": "AVG",
	//                   "N": 1
	//             }
	//        ]
	//   }
	// ```
	//
	// > The conditional fields vary depending on the values of the **MetricsType** and **AlertRuleItems.MetricKey** parameters. For more information about the types of metrics supported by Application Monitoring and Browser Monitoring and the alert rule fields corresponding to each metric, see the supplementary description.
	AlertRuleContent *string `json:"AlertRuleContent,omitempty" xml:"AlertRuleContent,omitempty"`
	// The status of the alert rule. Valid values:
	//
	// *   RUNNING (default)
	// *   STOPPED
	AlertStatus *string `json:"AlertStatus,omitempty" xml:"AlertStatus,omitempty"`
	// The type of the alert rule. Valid values:
	//
	// *   APPLICATION_MONITORING_ALERT_RULE: alert rule for Application Monitoring
	// *   BROWSER_MONITORING_ALERT_RULE: alert rule for Browser Monitoring
	// *   PROMETHEUS_MONITORING_ALERT_RULE: alert rule for Prometheus Service
	//
	// Valid values:
	//
	// *   PROMETHEUS_MONITORING_ALERT_RULE
	// *   APPLICATION_MONITORING_ALERT_RULE
	// *   BROWSER_MONITORING_ALERT_RULE
	// *   prometheus monitoring alert
	// *   application monitoring alert
	// *   browser monitoring alert
	AlertType *string `json:"AlertType,omitempty" xml:"AlertType,omitempty"`
	// The annotations of the Prometheus alert rule.
	Annotations *string `json:"Annotations,omitempty" xml:"Annotations,omitempty"`
	// Specifies whether to apply the alert rule to new applications that are created in Application Monitoring or Browser Monitoring. Valid values:
	//
	// *   `true`: enables the health check feature.
	// *   `false`: disables the automatic backup feature.
	AutoAddNewApplication *bool `json:"AutoAddNewApplication,omitempty" xml:"AutoAddNewApplication,omitempty"`
	// The ID of the monitored cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// Data Configuration. The dataRevision field specifies the data repair method when there is no data for the metric.
	//
	// - Fill with zero: 0
	// - Fill with one: 1
	// - Fill with null: 2 (default, does not trigger an alarm)
	DataConfig *string `json:"DataConfig,omitempty" xml:"DataConfig,omitempty"`
	// The duration of the Prometheus alert rule. Unit: minutes.
	Duration *int64 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The filter conditions of the Application Monitoring or Browser Monitoring alert rule. The following code shows the format of matching rules:
	//
	//     "DimFilters": [
	//     {
	//      "FilterOpt": "ALL",
	//      "FilterValues": [],         // The value of the filter condition.
	//      "FilterKey": "rootIp"     // The key of the filter condition.
	//     }
	//     ]
	//
	// Valid values of **FilterOpt**:
	//
	// *   STATIC: matches the value of the specified dimension.
	// *   ALL: matches the values of all dimensions.
	// *   DISABLE: aggregates the values of all dimensions.
	Filters *string `json:"Filters,omitempty" xml:"Filters,omitempty"`
	// The tags of the Prometheus alert rule.
	Labels *string `json:"Labels,omitempty" xml:"Labels,omitempty"`
	// The severity level of the Prometheus alert rule.
	//
	// *   P1: Alert notifications are sent for major issues that affect the availability of core business, have a huge impact, and may lead to serious consequences.
	// *   P2: Alert notifications are sent for service errors that affect the system availability with relatively limited impact.
	// *   P3: Alert notifications are sent for issues that may cause service errors or negative effects, or alert notifications for services that are relatively less important.
	// *   P4: Alert notifications are sent for low-priority issues that do not affect your business.
	// *   Default: Alert notifications are sent regardless of alert levels.
	Level *string `json:"Level,omitempty" xml:"Level,omitempty"`
	// Application Tags. Used for application monitoring alert rules, to filter applications associated with alert rules.
	MarkTags []*CreateOrUpdateAlertRuleRequestMarkTags `json:"MarkTags,omitempty" xml:"MarkTags,omitempty" type:"Repeated"`
	// The alert message of the Prometheus alert rule.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The alert metrics. If you set the **AlertCheckType** parameter to **STATIC** when you create a Prometheus alert rule, you must specify the **MetricsKey** parameter.
	//
	// > Alert metrics vary depending on the value of the **AlertGroup** parameter. For more information about the correspondence between **AlertGroup** and **MetricsKey**, see the supplementary description.
	MetricsKey *string `json:"MetricsKey,omitempty" xml:"MetricsKey,omitempty"`
	// The metric type of the Application Monitoring or Browser Monitoring alert rule. For more information, see the following table.
	MetricsType *string `json:"MetricsType,omitempty" xml:"MetricsType,omitempty"`
	// Effective Time and Notification Time. Used for compatibility with legacy rules.
	Notice *string `json:"Notice,omitempty" xml:"Notice,omitempty"`
	// Notification Mode. Normal mode or Simplified mode.
	NotifyMode *string `json:"NotifyMode,omitempty" xml:"NotifyMode,omitempty"`
	// The notification policy.
	//
	// *   If you set this parameter to null, no notification policy is specified. After you create an alert rule, you can create a notification policy and specify match rules and match conditions. For example, you can specify the name of the alert rule as the match condition. When the alert rule is triggered, an alert event is generated and an alert notification is sent to the contacts or contact groups that are specified in the notification policy.
	// *   To specify a notification policy, set this parameter to the ID of the notification policy. Application Real-Time Monitoring Service (ARMS) automatically adds a match rule to the notification policy and specifies the ID of the alert rule as the match condition. The name of the alert rule is also displayed. This way, the alert events that are generated based on the alert rule can be matched by the specified notification policy.
	NotifyStrategy *string `json:"NotifyStrategy,omitempty" xml:"NotifyStrategy,omitempty"`
	// The process ID (PID) that is associated with the Application Monitoring or Browser Monitoring alert rule.
	Pids *string `json:"Pids,omitempty" xml:"Pids,omitempty"`
	// The PromQL statement of the Prometheus alert rule.
	PromQL *string `json:"PromQL,omitempty" xml:"PromQL,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The list of tags.
	Tags []*CreateOrUpdateAlertRuleRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s CreateOrUpdateAlertRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateAlertRuleRequest) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateAlertRuleRequest) SetAlertCheckType(v string) *CreateOrUpdateAlertRuleRequest {
	s.AlertCheckType = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetAlertGroup(v int64) *CreateOrUpdateAlertRuleRequest {
	s.AlertGroup = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetAlertId(v int64) *CreateOrUpdateAlertRuleRequest {
	s.AlertId = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetAlertName(v string) *CreateOrUpdateAlertRuleRequest {
	s.AlertName = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetAlertPiplines(v string) *CreateOrUpdateAlertRuleRequest {
	s.AlertPiplines = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetAlertRuleContent(v string) *CreateOrUpdateAlertRuleRequest {
	s.AlertRuleContent = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetAlertStatus(v string) *CreateOrUpdateAlertRuleRequest {
	s.AlertStatus = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetAlertType(v string) *CreateOrUpdateAlertRuleRequest {
	s.AlertType = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetAnnotations(v string) *CreateOrUpdateAlertRuleRequest {
	s.Annotations = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetAutoAddNewApplication(v bool) *CreateOrUpdateAlertRuleRequest {
	s.AutoAddNewApplication = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetClusterId(v string) *CreateOrUpdateAlertRuleRequest {
	s.ClusterId = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetDataConfig(v string) *CreateOrUpdateAlertRuleRequest {
	s.DataConfig = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetDuration(v int64) *CreateOrUpdateAlertRuleRequest {
	s.Duration = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetFilters(v string) *CreateOrUpdateAlertRuleRequest {
	s.Filters = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetLabels(v string) *CreateOrUpdateAlertRuleRequest {
	s.Labels = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetLevel(v string) *CreateOrUpdateAlertRuleRequest {
	s.Level = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetMarkTags(v []*CreateOrUpdateAlertRuleRequestMarkTags) *CreateOrUpdateAlertRuleRequest {
	s.MarkTags = v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetMessage(v string) *CreateOrUpdateAlertRuleRequest {
	s.Message = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetMetricsKey(v string) *CreateOrUpdateAlertRuleRequest {
	s.MetricsKey = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetMetricsType(v string) *CreateOrUpdateAlertRuleRequest {
	s.MetricsType = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetNotice(v string) *CreateOrUpdateAlertRuleRequest {
	s.Notice = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetNotifyMode(v string) *CreateOrUpdateAlertRuleRequest {
	s.NotifyMode = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetNotifyStrategy(v string) *CreateOrUpdateAlertRuleRequest {
	s.NotifyStrategy = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetPids(v string) *CreateOrUpdateAlertRuleRequest {
	s.Pids = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetPromQL(v string) *CreateOrUpdateAlertRuleRequest {
	s.PromQL = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetRegionId(v string) *CreateOrUpdateAlertRuleRequest {
	s.RegionId = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequest) SetTags(v []*CreateOrUpdateAlertRuleRequestTags) *CreateOrUpdateAlertRuleRequest {
	s.Tags = v
	return s
}

type CreateOrUpdateAlertRuleRequestMarkTags struct {
	// The Tag Key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The Tag Value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateOrUpdateAlertRuleRequestMarkTags) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateAlertRuleRequestMarkTags) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateAlertRuleRequestMarkTags) SetKey(v string) *CreateOrUpdateAlertRuleRequestMarkTags {
	s.Key = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequestMarkTags) SetValue(v string) *CreateOrUpdateAlertRuleRequestMarkTags {
	s.Value = &v
	return s
}

type CreateOrUpdateAlertRuleRequestTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateOrUpdateAlertRuleRequestTags) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateAlertRuleRequestTags) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateAlertRuleRequestTags) SetKey(v string) *CreateOrUpdateAlertRuleRequestTags {
	s.Key = &v
	return s
}

func (s *CreateOrUpdateAlertRuleRequestTags) SetValue(v string) *CreateOrUpdateAlertRuleRequestTags {
	s.Value = &v
	return s
}

type CreateOrUpdateAlertRuleResponseBody struct {
	// The details of the alert rule.
	AlertRule *CreateOrUpdateAlertRuleResponseBodyAlertRule `json:"AlertRule,omitempty" xml:"AlertRule,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateOrUpdateAlertRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateAlertRuleResponseBody) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateAlertRuleResponseBody) SetAlertRule(v *CreateOrUpdateAlertRuleResponseBodyAlertRule) *CreateOrUpdateAlertRuleResponseBody {
	s.AlertRule = v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBody) SetRequestId(v string) *CreateOrUpdateAlertRuleResponseBody {
	s.RequestId = &v
	return s
}

type CreateOrUpdateAlertRuleResponseBodyAlertRule struct {
	// The alert check type of the Prometheus alert rule. Valid values:
	//
	// *   STATIC: a static threshold value.
	// *   CUSTOM: a custom PromQL statement.
	AlertCheckType *string `json:"AlertCheckType,omitempty" xml:"AlertCheckType,omitempty"`
	// The alert contact group ID of the Prometheus alert rule. Valid values:
	//
	// *   \-1: custom PromQL
	// *   1: Kubernetes load
	// *   15: Kubernetes node
	AlertGroup *int64 `json:"AlertGroup,omitempty" xml:"AlertGroup,omitempty"`
	// The ID of the alert rule.
	AlertId *float32 `json:"AlertId,omitempty" xml:"AlertId,omitempty"`
	// The name of the alert rule.
	AlertName *string `json:"AlertName,omitempty" xml:"AlertName,omitempty"`
	// The content of the Application Monitoring or Browser Monitoring alert rule.
	AlertRuleContent *CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent `json:"AlertRuleContent,omitempty" xml:"AlertRuleContent,omitempty" type:"Struct"`
	// The status of the alert rule. Valid values:
	//
	// *   RUNNING
	// *   STOPPED
	// *   PAUSED
	//
	// > The PAUSED status indicates that the alert rule is abnormal and is actively paused by the system. The alert rule may be paused because that it is not unique or the associated cluster has been deleted.
	AlertStatus *string `json:"AlertStatus,omitempty" xml:"AlertStatus,omitempty"`
	// The type of the alert rule. Valid values:
	//
	// *   APPLICATION_MONITORING_ALERT_RULE: alert rule for Application Monitoring
	// *   BROWSER_MONITORING_ALERT_RULE: alert rule for Browser Monitoring
	// *   PROMETHEUS_MONITORING_ALERT_RULE: alert rule for Prometheus Service
	AlertType *string `json:"AlertType,omitempty" xml:"AlertType,omitempty"`
	// The annotations of the Prometheus alert rule.
	Annotations []*CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations `json:"Annotations,omitempty" xml:"Annotations,omitempty" type:"Repeated"`
	// Indicates whether the alert rule was applied to new applications that were created in Application Monitoring or Browser Monitoring. Valid values:
	//
	// *   `true`: enables the health check feature.
	// *   `false`: disables the automatic backup feature.
	AutoAddNewApplication *bool `json:"AutoAddNewApplication,omitempty" xml:"AutoAddNewApplication,omitempty"`
	// The ID of the monitored cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The timestamp generated when the alert rule was created. Unit: seconds.
	CreatedTime *int64 `json:"CreatedTime,omitempty" xml:"CreatedTime,omitempty"`
	// The duration of the Prometheus alert rule. Unit: minutes.
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The extended fields.
	Extend *string `json:"Extend,omitempty" xml:"Extend,omitempty"`
	// The filter conditions of the Application Monitoring or Browser Monitoring alert rule.
	Filters *CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters `json:"Filters,omitempty" xml:"Filters,omitempty" type:"Struct"`
	// The tags of the Prometheus alert rule.
	Labels []*CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels `json:"Labels,omitempty" xml:"Labels,omitempty" type:"Repeated"`
	// The severity level of the Prometheus alert rule.
	//
	// *   P1: Alert notifications are sent for major issues that affect the availability of core business, have a huge impact, and may lead to serious consequences.
	// *   P2: Alert notifications are sent for service errors that affect the system availability with relatively limited impact.
	// *   P3: Alert notifications are sent for issues that may cause service errors or negative effects, or alert notifications for services that are relatively less important.
	// *   P4: Alert notifications are sent for low-priority issues that do not affect your business.
	// *   Default: Alert notifications are sent regardless of alert levels.
	Level *string `json:"Level,omitempty" xml:"Level,omitempty"`
	// The alert message of the Prometheus alert rule.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The metric type of the Application Monitoring or Browser Monitoring alert rule.
	MetricsType *string `json:"MetricsType,omitempty" xml:"MetricsType,omitempty"`
	// Notification Mode.
	NotifyMode *string `json:"NotifyMode,omitempty" xml:"NotifyMode,omitempty"`
	// The name of the notification policy.
	NotifyStrategy *string `json:"NotifyStrategy,omitempty" xml:"NotifyStrategy,omitempty"`
	// The process ID (PID) that was associated with the Application Monitoring or Browser Monitoring alert rule.
	Pids []*string `json:"Pids,omitempty" xml:"Pids,omitempty" type:"Repeated"`
	// The PromQL statement of the Prometheus alert rule.
	PromQL *string `json:"PromQL,omitempty" xml:"PromQL,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The list of tags.
	Tags []*CreateOrUpdateAlertRuleResponseBodyAlertRuleTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The timestamp generated when the alert rule was updated. Unit: seconds.
	UpdatedTime *int64 `json:"UpdatedTime,omitempty" xml:"UpdatedTime,omitempty"`
	// The ID of the Alibaba Cloud account.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s CreateOrUpdateAlertRuleResponseBodyAlertRule) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateAlertRuleResponseBodyAlertRule) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetAlertCheckType(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.AlertCheckType = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetAlertGroup(v int64) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.AlertGroup = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetAlertId(v float32) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.AlertId = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetAlertName(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.AlertName = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetAlertRuleContent(v *CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.AlertRuleContent = v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetAlertStatus(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.AlertStatus = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetAlertType(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.AlertType = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetAnnotations(v []*CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.Annotations = v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetAutoAddNewApplication(v bool) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.AutoAddNewApplication = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetClusterId(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.ClusterId = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetCreatedTime(v int64) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.CreatedTime = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetDuration(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.Duration = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetExtend(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.Extend = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetFilters(v *CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.Filters = v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetLabels(v []*CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.Labels = v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetLevel(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.Level = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetMessage(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.Message = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetMetricsType(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.MetricsType = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetNotifyMode(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.NotifyMode = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetNotifyStrategy(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.NotifyStrategy = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetPids(v []*string) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.Pids = v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetPromQL(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.PromQL = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetRegionId(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.RegionId = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetTags(v []*CreateOrUpdateAlertRuleResponseBodyAlertRuleTags) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.Tags = v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetUpdatedTime(v int64) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.UpdatedTime = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRule) SetUserId(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRule {
	s.UserId = &v
	return s
}

type CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent struct {
	// The trigger conditions of the Application Monitoring or Browser Monitoring alert rule.
	AlertRuleItems []*CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems `json:"AlertRuleItems,omitempty" xml:"AlertRuleItems,omitempty" type:"Repeated"`
	// The relationship between multiple alert conditions that were specified for the Application Monitoring or Browser Monitoring alert rule. Valid values:
	//
	// *   OR: meets any of the specified conditions.
	// *   AND: meets all the specified conditions.
	Condition *string `json:"Condition,omitempty" xml:"Condition,omitempty"`
}

func (s CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent) SetAlertRuleItems(v []*CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems) *CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent {
	s.AlertRuleItems = v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent) SetCondition(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContent {
	s.Condition = &v
	return s
}

type CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems struct {
	// The aggregation method of the alert condition. Valid values:
	//
	// *   AVG: calculates the average value
	// *   SUM: calculates the total value
	// *   MAX: selects the maximum value
	// *   MIN: selects the minimum value
	Aggregate *string `json:"Aggregate,omitempty" xml:"Aggregate,omitempty"`
	// The metric of the alert condition.
	MetricKey *string `json:"MetricKey,omitempty" xml:"MetricKey,omitempty"`
	// Indicates the last N minutes.
	N *float32 `json:"N,omitempty" xml:"N,omitempty"`
	// The comparison operator that was used to compare the metric value with the threshold. Valid values:
	//
	// *   CURRENT_GTE: greater than or equal to
	// *   CURRENT_LTE: less than or equal to
	// *   PREVIOUS_UP: the increase percentage compared with the last period
	// *   PREVIOUS_DOWN: the decrease percentage compared with the last period
	// *   HOH_UP: the increase percentage compared with the last hour
	// *   HOH_DOWN: the decrease percentage compared with the last hour
	// *   DOD_UP: the increase percentage compared with the last day
	// *   DOD_DOWN: the decrease percentage compared with the last day
	Operator *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
	// The threshold of the alert condition.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems) SetAggregate(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems {
	s.Aggregate = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems) SetMetricKey(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems {
	s.MetricKey = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems) SetN(v float32) *CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems {
	s.N = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems) SetOperator(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems {
	s.Operator = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems) SetValue(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRuleAlertRuleContentAlertRuleItems {
	s.Value = &v
	return s
}

type CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations struct {
	// The key of the annotation.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The value of the annotation.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations) SetName(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations {
	s.Name = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations) SetValue(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRuleAnnotations {
	s.Value = &v
	return s
}

type CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters struct {
	// The custom filter condition of the Browser Monitoring alert rule.
	CustomSLSFilters []*CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters `json:"CustomSLSFilters,omitempty" xml:"CustomSLSFilters,omitempty" type:"Repeated"`
	// The information of the aggregation dimension.
	CustomSLSGroupByDimensions []*string `json:"CustomSLSGroupByDimensions,omitempty" xml:"CustomSLSGroupByDimensions,omitempty" type:"Repeated"`
	// The details of the custom filter condition.
	CustomSLSWheres []*string `json:"CustomSLSWheres,omitempty" xml:"CustomSLSWheres,omitempty" type:"Repeated"`
	// The information about each filter condition of the Application Monitoring or Browser Monitoring alert rule.
	DimFilters []*CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters `json:"DimFilters,omitempty" xml:"DimFilters,omitempty" type:"Repeated"`
}

func (s CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters) SetCustomSLSFilters(v []*CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters) *CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters {
	s.CustomSLSFilters = v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters) SetCustomSLSGroupByDimensions(v []*string) *CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters {
	s.CustomSLSGroupByDimensions = v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters) SetCustomSLSWheres(v []*string) *CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters {
	s.CustomSLSWheres = v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters) SetDimFilters(v []*CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters) *CreateOrUpdateAlertRuleResponseBodyAlertRuleFilters {
	s.DimFilters = v
	return s
}

type CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters struct {
	// The key of the filter condition.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The logical operator of the filter condition. Valid values:
	//
	// *   \=: equal to
	// *   not: not equal to
	Opt *string `json:"Opt,omitempty" xml:"Opt,omitempty"`
	// Indicates whether this filter condition was displayed on the frontend.
	Show *bool `json:"Show,omitempty" xml:"Show,omitempty"`
	// The log type of Browser Monitoring. This field was not included in other filter conditions.
	T *string `json:"T,omitempty" xml:"T,omitempty"`
	// The value of the filter condition.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters) SetKey(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters {
	s.Key = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters) SetOpt(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters {
	s.Opt = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters) SetShow(v bool) *CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters {
	s.Show = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters) SetT(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters {
	s.T = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters) SetValue(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersCustomSLSFilters {
	s.Value = &v
	return s
}

type CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters struct {
	// The key of the filter condition.
	FilterKey *string `json:"FilterKey,omitempty" xml:"FilterKey,omitempty"`
	// The logical operator of the filter condition.
	FilterOpt *string `json:"FilterOpt,omitempty" xml:"FilterOpt,omitempty"`
	// The details of the filter condition.
	FilterValues []*string `json:"FilterValues,omitempty" xml:"FilterValues,omitempty" type:"Repeated"`
}

func (s CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters) SetFilterKey(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters {
	s.FilterKey = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters) SetFilterOpt(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters {
	s.FilterOpt = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters) SetFilterValues(v []*string) *CreateOrUpdateAlertRuleResponseBodyAlertRuleFiltersDimFilters {
	s.FilterValues = v
	return s
}

type CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels struct {
	// The tag key.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels) SetName(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels {
	s.Name = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels) SetValue(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRuleLabels {
	s.Value = &v
	return s
}

type CreateOrUpdateAlertRuleResponseBodyAlertRuleTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateOrUpdateAlertRuleResponseBodyAlertRuleTags) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateAlertRuleResponseBodyAlertRuleTags) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleTags) SetKey(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRuleTags {
	s.Key = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponseBodyAlertRuleTags) SetValue(v string) *CreateOrUpdateAlertRuleResponseBodyAlertRuleTags {
	s.Value = &v
	return s
}

type CreateOrUpdateAlertRuleResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateOrUpdateAlertRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateOrUpdateAlertRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateAlertRuleResponse) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateAlertRuleResponse) SetHeaders(v map[string]*string) *CreateOrUpdateAlertRuleResponse {
	s.Headers = v
	return s
}

func (s *CreateOrUpdateAlertRuleResponse) SetStatusCode(v int32) *CreateOrUpdateAlertRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateOrUpdateAlertRuleResponse) SetBody(v *CreateOrUpdateAlertRuleResponseBody) *CreateOrUpdateAlertRuleResponse {
	s.Body = v
	return s
}

type CreateOrUpdateContactRequest struct {
	// The ID of the alert contact.
	//
	// *   If you do not specify this parameter, a new alert contact is created.
	// *   If you specify this parameter, the specified alert contact is modified.
	ContactId *int64 `json:"ContactId,omitempty" xml:"ContactId,omitempty"`
	// The name of the alert contact.
	ContactName *string `json:"ContactName,omitempty" xml:"ContactName,omitempty"`
	// The webhook URL of the DingTalk chatbot.
	DingRobotUrl *string `json:"DingRobotUrl,omitempty" xml:"DingRobotUrl,omitempty"`
	// The email address of the alert contact.
	//
	// > You must specify at least one of the **Phone** and **Email** parameters. Each mobile number or email address can be used for only one alert contact.
	Email *string `json:"Email,omitempty" xml:"Email,omitempty"`
	// Specifies whether the email address is verified.
	IsEmailVerify *bool `json:"IsEmailVerify,omitempty" xml:"IsEmailVerify,omitempty"`
	// The mobile number of the alert contact.
	//
	// > You must specify at least one of the **Phone** and **Email** parameters. Each mobile number or email address can be used for only one alert contact.
	Phone *string `json:"Phone,omitempty" xml:"Phone,omitempty"`
	// The operation that you want to perform if phone calls fail to be answered. Valid values:
	//
	// *   0: No operation is performed.
	// *   1: A phone call is made again.
	// *   2: A text message is sent.
	// *   3 (default value): The global default value is used.
	ReissueSendNotice *int64 `json:"ReissueSendNotice,omitempty" xml:"ReissueSendNotice,omitempty"`
	// The resource group ID.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s CreateOrUpdateContactRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateContactRequest) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateContactRequest) SetContactId(v int64) *CreateOrUpdateContactRequest {
	s.ContactId = &v
	return s
}

func (s *CreateOrUpdateContactRequest) SetContactName(v string) *CreateOrUpdateContactRequest {
	s.ContactName = &v
	return s
}

func (s *CreateOrUpdateContactRequest) SetDingRobotUrl(v string) *CreateOrUpdateContactRequest {
	s.DingRobotUrl = &v
	return s
}

func (s *CreateOrUpdateContactRequest) SetEmail(v string) *CreateOrUpdateContactRequest {
	s.Email = &v
	return s
}

func (s *CreateOrUpdateContactRequest) SetIsEmailVerify(v bool) *CreateOrUpdateContactRequest {
	s.IsEmailVerify = &v
	return s
}

func (s *CreateOrUpdateContactRequest) SetPhone(v string) *CreateOrUpdateContactRequest {
	s.Phone = &v
	return s
}

func (s *CreateOrUpdateContactRequest) SetReissueSendNotice(v int64) *CreateOrUpdateContactRequest {
	s.ReissueSendNotice = &v
	return s
}

func (s *CreateOrUpdateContactRequest) SetResourceGroupId(v string) *CreateOrUpdateContactRequest {
	s.ResourceGroupId = &v
	return s
}

type CreateOrUpdateContactResponseBody struct {
	// The object of the alert contact.
	AlertContact *CreateOrUpdateContactResponseBodyAlertContact `json:"AlertContact,omitempty" xml:"AlertContact,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateOrUpdateContactResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateContactResponseBody) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateContactResponseBody) SetAlertContact(v *CreateOrUpdateContactResponseBodyAlertContact) *CreateOrUpdateContactResponseBody {
	s.AlertContact = v
	return s
}

func (s *CreateOrUpdateContactResponseBody) SetRequestId(v string) *CreateOrUpdateContactResponseBody {
	s.RequestId = &v
	return s
}

type CreateOrUpdateContactResponseBodyAlertContact struct {
	// The ID of the alert contact.
	ContactId *float32 `json:"ContactId,omitempty" xml:"ContactId,omitempty"`
	// The name of the alert contact.
	ContactName *string `json:"ContactName,omitempty" xml:"ContactName,omitempty"`
	// The webhook URL of the DingTalk chatbot.
	DingRobotUrl *string `json:"DingRobotUrl,omitempty" xml:"DingRobotUrl,omitempty"`
	// The email address of the alert contact.
	Email *string `json:"Email,omitempty" xml:"Email,omitempty"`
	// Indicates whether the mobile number was verified. Valid values:
	//
	// *   `false` (default value): No
	// *   `true`: Yes
	//
	// You can call the **SendTTSVerifyLink** operation to verify the mobile number of an alert contact. Only verified mobile numbers can be specified in a notification policy to receive phone calls.
	IsVerify *bool `json:"IsVerify,omitempty" xml:"IsVerify,omitempty"`
	// The mobile number of the alert contact.
	Phone *string `json:"Phone,omitempty" xml:"Phone,omitempty"`
	// The operation that you want to perform if phone calls fail to be answered. Valid values: 0: No operation is performed. 1: A phone call is made again. 2: A text message is sent. 3 (default value): The global default value is used.
	ReissueSendNotice *int64 `json:"ReissueSendNotice,omitempty" xml:"ReissueSendNotice,omitempty"`
	// Indicates whether the email address was verified.
	IsEmailVerify *bool `json:"isEmailVerify,omitempty" xml:"isEmailVerify,omitempty"`
}

func (s CreateOrUpdateContactResponseBodyAlertContact) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateContactResponseBodyAlertContact) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateContactResponseBodyAlertContact) SetContactId(v float32) *CreateOrUpdateContactResponseBodyAlertContact {
	s.ContactId = &v
	return s
}

func (s *CreateOrUpdateContactResponseBodyAlertContact) SetContactName(v string) *CreateOrUpdateContactResponseBodyAlertContact {
	s.ContactName = &v
	return s
}

func (s *CreateOrUpdateContactResponseBodyAlertContact) SetDingRobotUrl(v string) *CreateOrUpdateContactResponseBodyAlertContact {
	s.DingRobotUrl = &v
	return s
}

func (s *CreateOrUpdateContactResponseBodyAlertContact) SetEmail(v string) *CreateOrUpdateContactResponseBodyAlertContact {
	s.Email = &v
	return s
}

func (s *CreateOrUpdateContactResponseBodyAlertContact) SetIsVerify(v bool) *CreateOrUpdateContactResponseBodyAlertContact {
	s.IsVerify = &v
	return s
}

func (s *CreateOrUpdateContactResponseBodyAlertContact) SetPhone(v string) *CreateOrUpdateContactResponseBodyAlertContact {
	s.Phone = &v
	return s
}

func (s *CreateOrUpdateContactResponseBodyAlertContact) SetReissueSendNotice(v int64) *CreateOrUpdateContactResponseBodyAlertContact {
	s.ReissueSendNotice = &v
	return s
}

func (s *CreateOrUpdateContactResponseBodyAlertContact) SetIsEmailVerify(v bool) *CreateOrUpdateContactResponseBodyAlertContact {
	s.IsEmailVerify = &v
	return s
}

type CreateOrUpdateContactResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateOrUpdateContactResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateOrUpdateContactResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateContactResponse) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateContactResponse) SetHeaders(v map[string]*string) *CreateOrUpdateContactResponse {
	s.Headers = v
	return s
}

func (s *CreateOrUpdateContactResponse) SetStatusCode(v int32) *CreateOrUpdateContactResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateOrUpdateContactResponse) SetBody(v *CreateOrUpdateContactResponseBody) *CreateOrUpdateContactResponse {
	s.Body = v
	return s
}

type CreateOrUpdateContactGroupRequest struct {
	// The ID of the alert contact group.
	//
	// *   If you do not specify this parameter, an alert contact group is created.
	// *   If you specify this parameter, the specified alert contact group is modified.
	ContactGroupId *int64 `json:"ContactGroupId,omitempty" xml:"ContactGroupId,omitempty"`
	// The name of the alert contact group.
	ContactGroupName *string `json:"ContactGroupName,omitempty" xml:"ContactGroupName,omitempty"`
	// The ID of the contact that you want to add to the contact group. Separate multiple IDs with commas (,).
	ContactIds *string `json:"ContactIds,omitempty" xml:"ContactIds,omitempty"`
}

func (s CreateOrUpdateContactGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateContactGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateContactGroupRequest) SetContactGroupId(v int64) *CreateOrUpdateContactGroupRequest {
	s.ContactGroupId = &v
	return s
}

func (s *CreateOrUpdateContactGroupRequest) SetContactGroupName(v string) *CreateOrUpdateContactGroupRequest {
	s.ContactGroupName = &v
	return s
}

func (s *CreateOrUpdateContactGroupRequest) SetContactIds(v string) *CreateOrUpdateContactGroupRequest {
	s.ContactIds = &v
	return s
}

type CreateOrUpdateContactGroupResponseBody struct {
	// The information about the alert contact group.
	AlertContactGroup *CreateOrUpdateContactGroupResponseBodyAlertContactGroup `json:"AlertContactGroup,omitempty" xml:"AlertContactGroup,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateOrUpdateContactGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateContactGroupResponseBody) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateContactGroupResponseBody) SetAlertContactGroup(v *CreateOrUpdateContactGroupResponseBodyAlertContactGroup) *CreateOrUpdateContactGroupResponseBody {
	s.AlertContactGroup = v
	return s
}

func (s *CreateOrUpdateContactGroupResponseBody) SetRequestId(v string) *CreateOrUpdateContactGroupResponseBody {
	s.RequestId = &v
	return s
}

type CreateOrUpdateContactGroupResponseBodyAlertContactGroup struct {
	// The ID of the alert contact group.
	ContactGroupId *float32 `json:"ContactGroupId,omitempty" xml:"ContactGroupId,omitempty"`
	// The name of the alert contact group.
	ContactGroupName *string `json:"ContactGroupName,omitempty" xml:"ContactGroupName,omitempty"`
	// The IDs of the contacts that are included in the alert contact group.
	ContactIds *string `json:"ContactIds,omitempty" xml:"ContactIds,omitempty"`
}

func (s CreateOrUpdateContactGroupResponseBodyAlertContactGroup) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateContactGroupResponseBodyAlertContactGroup) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateContactGroupResponseBodyAlertContactGroup) SetContactGroupId(v float32) *CreateOrUpdateContactGroupResponseBodyAlertContactGroup {
	s.ContactGroupId = &v
	return s
}

func (s *CreateOrUpdateContactGroupResponseBodyAlertContactGroup) SetContactGroupName(v string) *CreateOrUpdateContactGroupResponseBodyAlertContactGroup {
	s.ContactGroupName = &v
	return s
}

func (s *CreateOrUpdateContactGroupResponseBodyAlertContactGroup) SetContactIds(v string) *CreateOrUpdateContactGroupResponseBodyAlertContactGroup {
	s.ContactIds = &v
	return s
}

type CreateOrUpdateContactGroupResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateOrUpdateContactGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateOrUpdateContactGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateContactGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateContactGroupResponse) SetHeaders(v map[string]*string) *CreateOrUpdateContactGroupResponse {
	s.Headers = v
	return s
}

func (s *CreateOrUpdateContactGroupResponse) SetStatusCode(v int32) *CreateOrUpdateContactGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateOrUpdateContactGroupResponse) SetBody(v *CreateOrUpdateContactGroupResponseBody) *CreateOrUpdateContactGroupResponse {
	s.Body = v
	return s
}

type CreateOrUpdateEventBridgeIntegrationRequest struct {
	// The AccessKey ID that is used to connect to EventBridge.
	AccessKey *string `json:"AccessKey,omitempty" xml:"AccessKey,omitempty"`
	// The AccessKey secret that is used to connect to EventBridge.
	AccessSecret *string `json:"AccessSecret,omitempty" xml:"AccessSecret,omitempty"`
	// The description of the EventBridge integration.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The public endpoint of EventBridge.
	Endpoint *string `json:"Endpoint,omitempty" xml:"Endpoint,omitempty"`
	// The name of the event bus.
	EventBusName *string `json:"EventBusName,omitempty" xml:"EventBusName,omitempty"`
	// The region ID of the event bus.
	EventBusRegionId *string `json:"EventBusRegionId,omitempty" xml:"EventBusRegionId,omitempty"`
	// The ID of the EventBridge integration.
	//
	// *   If you do not specify this parameter, an EventBridge integration is created.
	// *   If you specify this parameter, the specified EventBridge integration is modified.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the EventBridge integration.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The event source.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
}

func (s CreateOrUpdateEventBridgeIntegrationRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateEventBridgeIntegrationRequest) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateEventBridgeIntegrationRequest) SetAccessKey(v string) *CreateOrUpdateEventBridgeIntegrationRequest {
	s.AccessKey = &v
	return s
}

func (s *CreateOrUpdateEventBridgeIntegrationRequest) SetAccessSecret(v string) *CreateOrUpdateEventBridgeIntegrationRequest {
	s.AccessSecret = &v
	return s
}

func (s *CreateOrUpdateEventBridgeIntegrationRequest) SetDescription(v string) *CreateOrUpdateEventBridgeIntegrationRequest {
	s.Description = &v
	return s
}

func (s *CreateOrUpdateEventBridgeIntegrationRequest) SetEndpoint(v string) *CreateOrUpdateEventBridgeIntegrationRequest {
	s.Endpoint = &v
	return s
}

func (s *CreateOrUpdateEventBridgeIntegrationRequest) SetEventBusName(v string) *CreateOrUpdateEventBridgeIntegrationRequest {
	s.EventBusName = &v
	return s
}

func (s *CreateOrUpdateEventBridgeIntegrationRequest) SetEventBusRegionId(v string) *CreateOrUpdateEventBridgeIntegrationRequest {
	s.EventBusRegionId = &v
	return s
}

func (s *CreateOrUpdateEventBridgeIntegrationRequest) SetId(v int64) *CreateOrUpdateEventBridgeIntegrationRequest {
	s.Id = &v
	return s
}

func (s *CreateOrUpdateEventBridgeIntegrationRequest) SetName(v string) *CreateOrUpdateEventBridgeIntegrationRequest {
	s.Name = &v
	return s
}

func (s *CreateOrUpdateEventBridgeIntegrationRequest) SetSource(v string) *CreateOrUpdateEventBridgeIntegrationRequest {
	s.Source = &v
	return s
}

type CreateOrUpdateEventBridgeIntegrationResponseBody struct {
	// The information about the EventBridge integration.
	EventBridgeIntegration *CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration `json:"EventBridgeIntegration,omitempty" xml:"EventBridgeIntegration,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateOrUpdateEventBridgeIntegrationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateEventBridgeIntegrationResponseBody) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateEventBridgeIntegrationResponseBody) SetEventBridgeIntegration(v *CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration) *CreateOrUpdateEventBridgeIntegrationResponseBody {
	s.EventBridgeIntegration = v
	return s
}

func (s *CreateOrUpdateEventBridgeIntegrationResponseBody) SetRequestId(v string) *CreateOrUpdateEventBridgeIntegrationResponseBody {
	s.RequestId = &v
	return s
}

type CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration struct {
	// The AccessKey ID that is used to connect to EventBridge.
	AccessKey *string `json:"AccessKey,omitempty" xml:"AccessKey,omitempty"`
	// The AccessKey secret that is used to connect to EventBridge.
	AccessSecret *string `json:"AccessSecret,omitempty" xml:"AccessSecret,omitempty"`
	// The description of the EventBridge integration.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The public endpoint of EventBridge.
	Endpoint *string `json:"Endpoint,omitempty" xml:"Endpoint,omitempty"`
	// The name of the event bus.
	EventBusName *string `json:"EventBusName,omitempty" xml:"EventBusName,omitempty"`
	// The region ID of the event bus.
	EventBusRegionId *string `json:"EventBusRegionId,omitempty" xml:"EventBusRegionId,omitempty"`
	// The ID of the EventBridge integration.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the EventBridge integration.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The event source.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
}

func (s CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration) SetAccessKey(v string) *CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration {
	s.AccessKey = &v
	return s
}

func (s *CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration) SetAccessSecret(v string) *CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration {
	s.AccessSecret = &v
	return s
}

func (s *CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration) SetDescription(v string) *CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration {
	s.Description = &v
	return s
}

func (s *CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration) SetEndpoint(v string) *CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration {
	s.Endpoint = &v
	return s
}

func (s *CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration) SetEventBusName(v string) *CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration {
	s.EventBusName = &v
	return s
}

func (s *CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration) SetEventBusRegionId(v string) *CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration {
	s.EventBusRegionId = &v
	return s
}

func (s *CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration) SetId(v int64) *CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration {
	s.Id = &v
	return s
}

func (s *CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration) SetName(v string) *CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration {
	s.Name = &v
	return s
}

func (s *CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration) SetSource(v string) *CreateOrUpdateEventBridgeIntegrationResponseBodyEventBridgeIntegration {
	s.Source = &v
	return s
}

type CreateOrUpdateEventBridgeIntegrationResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateOrUpdateEventBridgeIntegrationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateOrUpdateEventBridgeIntegrationResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateEventBridgeIntegrationResponse) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateEventBridgeIntegrationResponse) SetHeaders(v map[string]*string) *CreateOrUpdateEventBridgeIntegrationResponse {
	s.Headers = v
	return s
}

func (s *CreateOrUpdateEventBridgeIntegrationResponse) SetStatusCode(v int32) *CreateOrUpdateEventBridgeIntegrationResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateOrUpdateEventBridgeIntegrationResponse) SetBody(v *CreateOrUpdateEventBridgeIntegrationResponseBody) *CreateOrUpdateEventBridgeIntegrationResponse {
	s.Body = v
	return s
}

type CreateOrUpdateIMRobotRequest struct {
	// The configurations of the alert card template. For more information about the parameters in the template, see the following section.
	CardTemplate *string `json:"CardTemplate,omitempty" xml:"CardTemplate,omitempty"`
	// Specifies whether to send daily statistics. Valid values:
	//
	// *   `false` (default): Daily statistics are not sent.
	// *   `true`: Daily statistics are sent. If you set the value to `true`, the **DailyNocTime** parameter is required.
	DailyNoc *bool `json:"DailyNoc,omitempty" xml:"DailyNoc,omitempty"`
	// The points in time at which the daily statistics are sent. Separate multiple points in time with commas (,). The points in time are in the HH:SS format. The information that ARMS sends at the specified points in time includes the total number of alerts generated on the current day, the number of cleared alerts, and the number of alerts to be cleared.
	DailyNocTime *string `json:"DailyNocTime,omitempty" xml:"DailyNocTime,omitempty"`
	// The signature key of DingTalk. If you specify a signature key, DingTalk authentication is performed by using the signature key. If you do not specify a signature key, a whitelist is used for authentication by default. The keyword of the whitelist is **Alert**.
	DingSignKey *string `json:"DingSignKey,omitempty" xml:"DingSignKey,omitempty"`
	// Specifies whether to enable the Outgoing feature.
	EnableOutgoing *bool `json:"EnableOutgoing,omitempty" xml:"EnableOutgoing,omitempty"`
	// The webhook URL of the IM chatbot.
	RobotAddress *string `json:"RobotAddress,omitempty" xml:"RobotAddress,omitempty"`
	// The ID of the IM chatbot.
	//
	// - If you do not specify the parameter, a new IM chatbot is created.
	// - If you specify this parameter, the specified IM chatbot is modified.
	RobotId *int64 `json:"RobotId,omitempty" xml:"RobotId,omitempty"`
	// The name of the IM chatbot.
	RobotName *string `json:"RobotName,omitempty" xml:"RobotName,omitempty"`
	// The token required to enable the Outgoing feature.
	Token *string `json:"Token,omitempty" xml:"Token,omitempty"`
	// The type of the IM chatbot. Valid values:
	//
	// *   `dingding`: DingTalk chatbot
	// *   `wechat`: WeCom chatbot
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateOrUpdateIMRobotRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateIMRobotRequest) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateIMRobotRequest) SetCardTemplate(v string) *CreateOrUpdateIMRobotRequest {
	s.CardTemplate = &v
	return s
}

func (s *CreateOrUpdateIMRobotRequest) SetDailyNoc(v bool) *CreateOrUpdateIMRobotRequest {
	s.DailyNoc = &v
	return s
}

func (s *CreateOrUpdateIMRobotRequest) SetDailyNocTime(v string) *CreateOrUpdateIMRobotRequest {
	s.DailyNocTime = &v
	return s
}

func (s *CreateOrUpdateIMRobotRequest) SetDingSignKey(v string) *CreateOrUpdateIMRobotRequest {
	s.DingSignKey = &v
	return s
}

func (s *CreateOrUpdateIMRobotRequest) SetEnableOutgoing(v bool) *CreateOrUpdateIMRobotRequest {
	s.EnableOutgoing = &v
	return s
}

func (s *CreateOrUpdateIMRobotRequest) SetRobotAddress(v string) *CreateOrUpdateIMRobotRequest {
	s.RobotAddress = &v
	return s
}

func (s *CreateOrUpdateIMRobotRequest) SetRobotId(v int64) *CreateOrUpdateIMRobotRequest {
	s.RobotId = &v
	return s
}

func (s *CreateOrUpdateIMRobotRequest) SetRobotName(v string) *CreateOrUpdateIMRobotRequest {
	s.RobotName = &v
	return s
}

func (s *CreateOrUpdateIMRobotRequest) SetToken(v string) *CreateOrUpdateIMRobotRequest {
	s.Token = &v
	return s
}

func (s *CreateOrUpdateIMRobotRequest) SetType(v string) *CreateOrUpdateIMRobotRequest {
	s.Type = &v
	return s
}

type CreateOrUpdateIMRobotResponseBody struct {
	// The information about the IM chatbot.
	AlertRobot *CreateOrUpdateIMRobotResponseBodyAlertRobot `json:"AlertRobot,omitempty" xml:"AlertRobot,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateOrUpdateIMRobotResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateIMRobotResponseBody) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateIMRobotResponseBody) SetAlertRobot(v *CreateOrUpdateIMRobotResponseBodyAlertRobot) *CreateOrUpdateIMRobotResponseBody {
	s.AlertRobot = v
	return s
}

func (s *CreateOrUpdateIMRobotResponseBody) SetRequestId(v string) *CreateOrUpdateIMRobotResponseBody {
	s.RequestId = &v
	return s
}

type CreateOrUpdateIMRobotResponseBodyAlertRobot struct {
	// The configurations of the alert card template.
	CardTemplate *string `json:"CardTemplate,omitempty" xml:"CardTemplate,omitempty"`
	// Indicates whether daily statistics are sent. Valid values:
	//
	// *   `false` (default): Daily statistics are not sent.
	// *   `true`: Daily statistics are sent.
	DailyNoc *bool `json:"DailyNoc,omitempty" xml:"DailyNoc,omitempty"`
	// The point in time at which the daily statistics are sent. The information that ARMS sends at the specified points in time includes the total number of alerts generated on the current day, the number of cleared alerts, and the number of alerts to be cleared.
	DailyNocTime *string `json:"DailyNocTime,omitempty" xml:"DailyNocTime,omitempty"`
	// Indicates whether the Outgoing feature is enabled.
	EnableOutgoing *bool `json:"EnableOutgoing,omitempty" xml:"EnableOutgoing,omitempty"`
	// The webhook URL of the IM chatbot.
	RobotAddress *string `json:"RobotAddress,omitempty" xml:"RobotAddress,omitempty"`
	// The ID of the IM chatbot.
	RobotId *float32 `json:"RobotId,omitempty" xml:"RobotId,omitempty"`
	// The name of the IM chatbot.
	RobotName *string `json:"RobotName,omitempty" xml:"RobotName,omitempty"`
	// The token required to enable the Outgoing feature.
	Token *string `json:"Token,omitempty" xml:"Token,omitempty"`
	// The type of the IM chatbot. Valid values:
	//
	// *   `dingding`: DingTalk chatbot
	// *   `wechat`: WeCom chatbot
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateOrUpdateIMRobotResponseBodyAlertRobot) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateIMRobotResponseBodyAlertRobot) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateIMRobotResponseBodyAlertRobot) SetCardTemplate(v string) *CreateOrUpdateIMRobotResponseBodyAlertRobot {
	s.CardTemplate = &v
	return s
}

func (s *CreateOrUpdateIMRobotResponseBodyAlertRobot) SetDailyNoc(v bool) *CreateOrUpdateIMRobotResponseBodyAlertRobot {
	s.DailyNoc = &v
	return s
}

func (s *CreateOrUpdateIMRobotResponseBodyAlertRobot) SetDailyNocTime(v string) *CreateOrUpdateIMRobotResponseBodyAlertRobot {
	s.DailyNocTime = &v
	return s
}

func (s *CreateOrUpdateIMRobotResponseBodyAlertRobot) SetEnableOutgoing(v bool) *CreateOrUpdateIMRobotResponseBodyAlertRobot {
	s.EnableOutgoing = &v
	return s
}

func (s *CreateOrUpdateIMRobotResponseBodyAlertRobot) SetRobotAddress(v string) *CreateOrUpdateIMRobotResponseBodyAlertRobot {
	s.RobotAddress = &v
	return s
}

func (s *CreateOrUpdateIMRobotResponseBodyAlertRobot) SetRobotId(v float32) *CreateOrUpdateIMRobotResponseBodyAlertRobot {
	s.RobotId = &v
	return s
}

func (s *CreateOrUpdateIMRobotResponseBodyAlertRobot) SetRobotName(v string) *CreateOrUpdateIMRobotResponseBodyAlertRobot {
	s.RobotName = &v
	return s
}

func (s *CreateOrUpdateIMRobotResponseBodyAlertRobot) SetToken(v string) *CreateOrUpdateIMRobotResponseBodyAlertRobot {
	s.Token = &v
	return s
}

func (s *CreateOrUpdateIMRobotResponseBodyAlertRobot) SetType(v string) *CreateOrUpdateIMRobotResponseBodyAlertRobot {
	s.Type = &v
	return s
}

type CreateOrUpdateIMRobotResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateOrUpdateIMRobotResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateOrUpdateIMRobotResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateIMRobotResponse) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateIMRobotResponse) SetHeaders(v map[string]*string) *CreateOrUpdateIMRobotResponse {
	s.Headers = v
	return s
}

func (s *CreateOrUpdateIMRobotResponse) SetStatusCode(v int32) *CreateOrUpdateIMRobotResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateOrUpdateIMRobotResponse) SetBody(v *CreateOrUpdateIMRobotResponseBody) *CreateOrUpdateIMRobotResponse {
	s.Body = v
	return s
}

type CreateOrUpdateNotificationPolicyRequest struct {
	// Specifies whether to enable simple mode.
	DirectedMode *bool `json:"DirectedMode,omitempty" xml:"DirectedMode,omitempty"`
	// The ID of the escalation policy.
	EscalationPolicyId *int64 `json:"EscalationPolicyId,omitempty" xml:"EscalationPolicyId,omitempty"`
	// An array of alert event group objects.
	//
	// *   If you do not specify the groupingFields field, all alerts will be sent to contacts based on `alertname`.
	//
	// *   If you specify the groupingFields field, alerts with the same field will be sent to contacts in one notification.
	//
	//     Sample statement:
	//
	// ```
	//
	// {
	// "groupWait":5,    // The waiting time for grouping.
	// "groupInterval":30,     // The time interval of grouping.
	// "groupingFields":["alertname"]       // The field that is used to group alert events.
	// }
	// ```
	GroupRule *string `json:"GroupRule,omitempty" xml:"GroupRule,omitempty"`
	// The ID of the notification policy.
	//
	// *   If you do not specify this parameter, a new notification policy is created.
	// *   If you specify this parameter, the specified notification policy is modified.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The integration ID of the ticket system to which alerts are pushed.
	IntegrationId *int64 `json:"IntegrationId,omitempty" xml:"IntegrationId,omitempty"`
	// The matching rules. Sample statement:
	//
	// ```
	//
	// [
	//  {
	//  "matchingConditions": [
	//  {
	//  "value": "test",    // The value of the matching condition.
	//  "key": "alertname",     // The key of the matching condition.
	//  "operator": "eq"   // The logical operator of the matching condition, including eq (equal to), neq (not equal to), in (contains), nin (does not contain), re (regular expression match), and nre (regular expression mismatch).
	//  }
	//  ]
	//  }
	//  ]
	// ```
	MatchingRules *string `json:"MatchingRules,omitempty" xml:"MatchingRules,omitempty"`
	// The name of the notification policy.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// An array of notification rule objects. Format:
	//
	//     {
	//      "notifyStartTime":"00:00",      // The start time of the notification window.
	//      "notifyEndTime":"23:59",       // The end time of the notification window.
	//      "notifyChannels":["dingTalk", "email", "sms", "tts", "webhook"],       // The notification methods. Valid values: dingTalk, email, sms, tts, and webhook.
	//      "notifyObjects":[{       // An array of notification objects.
	//      "notifyObjectType":"CONTACT",       // The type of the notification object. Valid values: CONTACT (contact), CONTACT_GROUP (contact group), ARMS_CONTACT (ARMS contact), ARMS_CONTACT_GROUP (ARMS contact group), DING_ROBOT_GROUP (DingTalk, Lark, WeCom, or IM chatbot), and CONTACT_SCHEDULE (user on duty defined by a schedule).
	//      "notifyObjectId":123,       // The ID of the notification object.
	//      "notifyObjectName":"test"       // The name of the notification object.
	//      "notifyChannels": [ // The notification methods specified for a contact. Valid values: email, sms, and tts.
	//                     "email",
	//                     "sms",
	//                     "tts"
	//                 ],
	//      }]
	NotifyRule *string `json:"NotifyRule,omitempty" xml:"NotifyRule,omitempty"`
	// The notification template. The default notification template is provided below the table.
	NotifyTemplate *string `json:"NotifyTemplate,omitempty" xml:"NotifyTemplate,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Specifies whether to resend a notification for a long-lasting unresolved alert. Default value: true. Valid values:
	//
	// *   `true`: If you set this parameter to `true`, you must set **RepeatInterval**.
	// *   `false`: If you set this parameter to `false`, you must set **EscalationPolicyId**.
	Repeat *bool `json:"Repeat,omitempty" xml:"Repeat,omitempty"`
	// The time interval at which a notification is resent for a long-lasting unresolved alert. Unit: seconds.
	RepeatInterval *int64 `json:"RepeatInterval,omitempty" xml:"RepeatInterval,omitempty"`
	// Indicates whether the system sends a notification to the contacts when the status of an alert changes to Resolved. Default value: true. Valid values:
	//
	// *   `true`: The system sends a notification.
	// *   `false`: The system does not send a notification.
	SendRecoverMessage *bool `json:"SendRecoverMessage,omitempty" xml:"SendRecoverMessage,omitempty"`
}

func (s CreateOrUpdateNotificationPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateNotificationPolicyRequest) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateNotificationPolicyRequest) SetDirectedMode(v bool) *CreateOrUpdateNotificationPolicyRequest {
	s.DirectedMode = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyRequest) SetEscalationPolicyId(v int64) *CreateOrUpdateNotificationPolicyRequest {
	s.EscalationPolicyId = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyRequest) SetGroupRule(v string) *CreateOrUpdateNotificationPolicyRequest {
	s.GroupRule = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyRequest) SetId(v int64) *CreateOrUpdateNotificationPolicyRequest {
	s.Id = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyRequest) SetIntegrationId(v int64) *CreateOrUpdateNotificationPolicyRequest {
	s.IntegrationId = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyRequest) SetMatchingRules(v string) *CreateOrUpdateNotificationPolicyRequest {
	s.MatchingRules = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyRequest) SetName(v string) *CreateOrUpdateNotificationPolicyRequest {
	s.Name = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyRequest) SetNotifyRule(v string) *CreateOrUpdateNotificationPolicyRequest {
	s.NotifyRule = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyRequest) SetNotifyTemplate(v string) *CreateOrUpdateNotificationPolicyRequest {
	s.NotifyTemplate = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyRequest) SetRegionId(v string) *CreateOrUpdateNotificationPolicyRequest {
	s.RegionId = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyRequest) SetRepeat(v bool) *CreateOrUpdateNotificationPolicyRequest {
	s.Repeat = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyRequest) SetRepeatInterval(v int64) *CreateOrUpdateNotificationPolicyRequest {
	s.RepeatInterval = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyRequest) SetSendRecoverMessage(v bool) *CreateOrUpdateNotificationPolicyRequest {
	s.SendRecoverMessage = &v
	return s
}

type CreateOrUpdateNotificationPolicyResponseBody struct {
	// An array of notification policy objects.
	NotificationPolicy *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy `json:"NotificationPolicy,omitempty" xml:"NotificationPolicy,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateOrUpdateNotificationPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateNotificationPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateNotificationPolicyResponseBody) SetNotificationPolicy(v *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy) *CreateOrUpdateNotificationPolicyResponseBody {
	s.NotificationPolicy = v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBody) SetRequestId(v string) *CreateOrUpdateNotificationPolicyResponseBody {
	s.RequestId = &v
	return s
}

type CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy struct {
	// 极简模式
	DirectedMode *bool `json:"DirectedMode,omitempty" xml:"DirectedMode,omitempty"`
	// The ID of the escalation policy.
	EscalationPolicyId *int64 `json:"EscalationPolicyId,omitempty" xml:"EscalationPolicyId,omitempty"`
	// An array of alert event group objects.
	GroupRule *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule `json:"GroupRule,omitempty" xml:"GroupRule,omitempty" type:"Struct"`
	// The ID of the notification policy.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The integration ID of the ticket system to which alerts are pushed.
	IntegrationId *int64 `json:"IntegrationId,omitempty" xml:"IntegrationId,omitempty"`
	// An array of alert event matching rule objects.
	MatchingRules []*CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules `json:"MatchingRules,omitempty" xml:"MatchingRules,omitempty" type:"Repeated"`
	// The name of the notification policy.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// An array of notification rule objects.
	NotifyRule *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule `json:"NotifyRule,omitempty" xml:"NotifyRule,omitempty" type:"Struct"`
	// An array of notification template objects.
	NotifyTemplate *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate `json:"NotifyTemplate,omitempty" xml:"NotifyTemplate,omitempty" type:"Struct"`
	// Indicates whether a notification is resent for a long-lasting unresolved alert. Default value: true. Valid values:
	//
	// - `true`: The system resends a notification for a long-lasting unresolved alert at a specified time interval.
	// - `false`: The system sends a notification for a long-lasting unresolved alert based on an escalation policy.
	Repeat *bool `json:"Repeat,omitempty" xml:"Repeat,omitempty"`
	// The time interval at which a notification is resent for a long-lasting unresolved alert. Unit: seconds.
	RepeatInterval *int64 `json:"RepeatInterval,omitempty" xml:"RepeatInterval,omitempty"`
	// Indicates whether the system sends a notification to the contacts when the status of an alert changes to Resolved. Default value: true. Valid values:
	//
	// - `true`: The system sends a notification.
	// - `false`: The system does not send a notification.
	SendRecoverMessage *bool `json:"SendRecoverMessage,omitempty" xml:"SendRecoverMessage,omitempty"`
}

func (s CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy) SetDirectedMode(v bool) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy {
	s.DirectedMode = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy) SetEscalationPolicyId(v int64) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy {
	s.EscalationPolicyId = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy) SetGroupRule(v *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy {
	s.GroupRule = v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy) SetId(v int64) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy {
	s.Id = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy) SetIntegrationId(v int64) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy {
	s.IntegrationId = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy) SetMatchingRules(v []*CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy {
	s.MatchingRules = v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy) SetName(v string) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy {
	s.Name = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy) SetNotifyRule(v *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy {
	s.NotifyRule = v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy) SetNotifyTemplate(v *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy {
	s.NotifyTemplate = v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy) SetRepeat(v bool) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy {
	s.Repeat = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy) SetRepeatInterval(v int64) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy {
	s.RepeatInterval = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy) SetSendRecoverMessage(v bool) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicy {
	s.SendRecoverMessage = &v
	return s
}

type CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule struct {
	// The time interval of grouping. Unit: seconds. Default value: 30.
	GroupInterval *int64 `json:"GroupInterval,omitempty" xml:"GroupInterval,omitempty"`
	// The waiting time for grouping. Unit: seconds. Default value: 5.
	GroupWait *int64 `json:"GroupWait,omitempty" xml:"GroupWait,omitempty"`
	// The field that is used for grouping.
	GroupingFields []*string `json:"GroupingFields,omitempty" xml:"GroupingFields,omitempty" type:"Repeated"`
}

func (s CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule) SetGroupInterval(v int64) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule {
	s.GroupInterval = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule) SetGroupWait(v int64) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule {
	s.GroupWait = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule) SetGroupingFields(v []*string) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyGroupRule {
	s.GroupingFields = v
	return s
}

type CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules struct {
	// An array of alert event matching condition objects.
	MatchingConditions []*CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions `json:"MatchingConditions,omitempty" xml:"MatchingConditions,omitempty" type:"Repeated"`
}

func (s CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules) SetMatchingConditions(v []*CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRules {
	s.MatchingConditions = v
	return s
}

type CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions struct {
	// The key of the matching condition.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The logical operator of the matching condition. Valid values:
	//
	// *   `eq`: equal to
	// *   `neq`: not equal to
	// *   `in`: contains
	// *   `nin`: does not contain
	// *   `re`: regular expression match
	// *   `nre`: regular expression mismatch
	Operator *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
	// The value of the matching condition.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions) SetKey(v string) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions {
	s.Key = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions) SetOperator(v string) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions {
	s.Operator = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions) SetValue(v string) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyMatchingRulesMatchingConditions {
	s.Value = &v
	return s
}

type CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule struct {
	// The notification methods. Valid values:
	//
	// - `dingTalk`: DingTalk
	// - `email`: email
	// - `sms`: text message
	// - `tts`: phone call
	// - `webhook`: webhook
	NotifyChannels []*string `json:"NotifyChannels,omitempty" xml:"NotifyChannels,omitempty" type:"Repeated"`
	// The end time of the notification window.
	NotifyEndTime *string `json:"NotifyEndTime,omitempty" xml:"NotifyEndTime,omitempty"`
	// An array of notification contact objects.
	NotifyObjects []*CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects `json:"NotifyObjects,omitempty" xml:"NotifyObjects,omitempty" type:"Repeated"`
	// The start time of the notification window.
	NotifyStartTime *string `json:"NotifyStartTime,omitempty" xml:"NotifyStartTime,omitempty"`
}

func (s CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule) SetNotifyChannels(v []*string) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule {
	s.NotifyChannels = v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule) SetNotifyEndTime(v string) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule {
	s.NotifyEndTime = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule) SetNotifyObjects(v []*CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule {
	s.NotifyObjects = v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule) SetNotifyStartTime(v string) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRule {
	s.NotifyStartTime = &v
	return s
}

type CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects struct {
	// 通知对象为联系人时的单独的联系方式
	NotifyChannels []*string `json:"NotifyChannels,omitempty" xml:"NotifyChannels,omitempty" type:"Repeated"`
	// The ID of the notification contact.
	NotifyObjectId *int64 `json:"NotifyObjectId,omitempty" xml:"NotifyObjectId,omitempty"`
	// The name of the notification contact.
	NotifyObjectName *string `json:"NotifyObjectName,omitempty" xml:"NotifyObjectName,omitempty"`
	// The type of the notification contact. Valid values:
	//
	// - CONTACT: an individual contact
	// - CONTACT_GROUP: a contact group
	// - DING_ROBOT: an instant messaging (IM) robot
	// - CONTACT_SCHEDULE: a person on duty based on an established schedule
	NotifyObjectType *string `json:"NotifyObjectType,omitempty" xml:"NotifyObjectType,omitempty"`
}

func (s CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects) SetNotifyChannels(v []*string) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects {
	s.NotifyChannels = v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects) SetNotifyObjectId(v int64) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects {
	s.NotifyObjectId = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects) SetNotifyObjectName(v string) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects {
	s.NotifyObjectName = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects) SetNotifyObjectType(v string) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyRuleNotifyObjects {
	s.NotifyObjectType = &v
	return s
}

type CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate struct {
	// The content of the alert notification sent through email.
	EmailContent *string `json:"EmailContent,omitempty" xml:"EmailContent,omitempty"`
	// The content of the alert resolution notification sent through email.
	EmailRecoverContent *string `json:"EmailRecoverContent,omitempty" xml:"EmailRecoverContent,omitempty"`
	// The title of the alert resolution notification sent through email.
	EmailRecoverTitle *string `json:"EmailRecoverTitle,omitempty" xml:"EmailRecoverTitle,omitempty"`
	// The title of the alert notification sent through email.
	EmailTitle *string `json:"EmailTitle,omitempty" xml:"EmailTitle,omitempty"`
	// The content of the alert notification sent by the IM robot.
	RobotContent *string `json:"RobotContent,omitempty" xml:"RobotContent,omitempty"`
	// The content of the alert notification sent through text message.
	SmsContent *string `json:"SmsContent,omitempty" xml:"SmsContent,omitempty"`
	// The content of the alert resolution notification sent through text message.
	SmsRecoverContent *string `json:"SmsRecoverContent,omitempty" xml:"SmsRecoverContent,omitempty"`
	// The content of the alert notification by phone.
	TtsContent *string `json:"TtsContent,omitempty" xml:"TtsContent,omitempty"`
	// The content of the alert resolution notification by phone.
	TtsRecoverContent *string `json:"TtsRecoverContent,omitempty" xml:"TtsRecoverContent,omitempty"`
}

func (s CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate) SetEmailContent(v string) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate {
	s.EmailContent = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate) SetEmailRecoverContent(v string) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate {
	s.EmailRecoverContent = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate) SetEmailRecoverTitle(v string) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate {
	s.EmailRecoverTitle = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate) SetEmailTitle(v string) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate {
	s.EmailTitle = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate) SetRobotContent(v string) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate {
	s.RobotContent = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate) SetSmsContent(v string) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate {
	s.SmsContent = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate) SetSmsRecoverContent(v string) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate {
	s.SmsRecoverContent = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate) SetTtsContent(v string) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate {
	s.TtsContent = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate) SetTtsRecoverContent(v string) *CreateOrUpdateNotificationPolicyResponseBodyNotificationPolicyNotifyTemplate {
	s.TtsRecoverContent = &v
	return s
}

type CreateOrUpdateNotificationPolicyResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateOrUpdateNotificationPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateOrUpdateNotificationPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateNotificationPolicyResponse) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateNotificationPolicyResponse) SetHeaders(v map[string]*string) *CreateOrUpdateNotificationPolicyResponse {
	s.Headers = v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponse) SetStatusCode(v int32) *CreateOrUpdateNotificationPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateOrUpdateNotificationPolicyResponse) SetBody(v *CreateOrUpdateNotificationPolicyResponseBody) *CreateOrUpdateNotificationPolicyResponse {
	s.Body = v
	return s
}

type CreateOrUpdateSilencePolicyRequest struct {
	// The ID of the silence policy.
	//
	// *   If you do not configure this parameter, a new silence policy is created.
	// *   If you configure this parameter, the specified silence policy is modified.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The matching rules. The following code shows the format of matching rules:
	//
	//     [
	//          {
	//     	 "matchingConditions": [
	//     	 {
	//     	 "value": "test", // The value of the matching condition.
	//     	 "key": "altertname", // The key of the matching condition.
	//     	 "operator": "eq" // The logical operator of the matching condition, including eq (equal to), neq (not equal to), in (contains), nin (does not contain), re (regular expression match), and nre (regular expression mismatch).
	//     	 }
	//     	 ]
	//          }
	//     	 ]
	MatchingRules *string `json:"MatchingRules,omitempty" xml:"MatchingRules,omitempty"`
	// The name of the silence policy.
	Name     *string `json:"Name,omitempty" xml:"Name,omitempty"`
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateOrUpdateSilencePolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSilencePolicyRequest) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSilencePolicyRequest) SetId(v int64) *CreateOrUpdateSilencePolicyRequest {
	s.Id = &v
	return s
}

func (s *CreateOrUpdateSilencePolicyRequest) SetMatchingRules(v string) *CreateOrUpdateSilencePolicyRequest {
	s.MatchingRules = &v
	return s
}

func (s *CreateOrUpdateSilencePolicyRequest) SetName(v string) *CreateOrUpdateSilencePolicyRequest {
	s.Name = &v
	return s
}

func (s *CreateOrUpdateSilencePolicyRequest) SetRegionId(v string) *CreateOrUpdateSilencePolicyRequest {
	s.RegionId = &v
	return s
}

type CreateOrUpdateSilencePolicyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// A list of silence policies.
	SilencePolicy *CreateOrUpdateSilencePolicyResponseBodySilencePolicy `json:"SilencePolicy,omitempty" xml:"SilencePolicy,omitempty" type:"Struct"`
}

func (s CreateOrUpdateSilencePolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSilencePolicyResponseBody) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSilencePolicyResponseBody) SetRequestId(v string) *CreateOrUpdateSilencePolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateOrUpdateSilencePolicyResponseBody) SetSilencePolicy(v *CreateOrUpdateSilencePolicyResponseBodySilencePolicy) *CreateOrUpdateSilencePolicyResponseBody {
	s.SilencePolicy = v
	return s
}

type CreateOrUpdateSilencePolicyResponseBodySilencePolicy struct {
	// The ID of the silence policy.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// A list of matching rules.
	MatchingRules []*CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules `json:"MatchingRules,omitempty" xml:"MatchingRules,omitempty" type:"Repeated"`
	// The name of the silence policy.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s CreateOrUpdateSilencePolicyResponseBodySilencePolicy) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSilencePolicyResponseBodySilencePolicy) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSilencePolicyResponseBodySilencePolicy) SetId(v int64) *CreateOrUpdateSilencePolicyResponseBodySilencePolicy {
	s.Id = &v
	return s
}

func (s *CreateOrUpdateSilencePolicyResponseBodySilencePolicy) SetMatchingRules(v []*CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules) *CreateOrUpdateSilencePolicyResponseBodySilencePolicy {
	s.MatchingRules = v
	return s
}

func (s *CreateOrUpdateSilencePolicyResponseBodySilencePolicy) SetName(v string) *CreateOrUpdateSilencePolicyResponseBodySilencePolicy {
	s.Name = &v
	return s
}

type CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules struct {
	// A list of matching conditions.
	MatchingConditions []*CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions `json:"MatchingConditions,omitempty" xml:"MatchingConditions,omitempty" type:"Repeated"`
}

func (s CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules) SetMatchingConditions(v []*CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions) *CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRules {
	s.MatchingConditions = v
	return s
}

type CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions struct {
	// The key of the matching condition.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The logical operator of the matching condition. Valid values:
	//
	// *   `eq`: equal to
	// *   `neq`: not equal to
	// *   `in`: contains
	// *   `nin`: does not contain
	// *   `re`: regular expression match
	// *   `nre`: regular expression mismatch
	Operator *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
	// The value of the matching condition.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions) SetKey(v string) *CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions {
	s.Key = &v
	return s
}

func (s *CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions) SetOperator(v string) *CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions {
	s.Operator = &v
	return s
}

func (s *CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions) SetValue(v string) *CreateOrUpdateSilencePolicyResponseBodySilencePolicyMatchingRulesMatchingConditions {
	s.Value = &v
	return s
}

type CreateOrUpdateSilencePolicyResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateOrUpdateSilencePolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateOrUpdateSilencePolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateSilencePolicyResponse) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateSilencePolicyResponse) SetHeaders(v map[string]*string) *CreateOrUpdateSilencePolicyResponse {
	s.Headers = v
	return s
}

func (s *CreateOrUpdateSilencePolicyResponse) SetStatusCode(v int32) *CreateOrUpdateSilencePolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateOrUpdateSilencePolicyResponse) SetBody(v *CreateOrUpdateSilencePolicyResponseBody) *CreateOrUpdateSilencePolicyResponse {
	s.Body = v
	return s
}

type CreateOrUpdateWebhookContactRequest struct {
	// The HTTP request headers.
	BizHeaders *string `json:"BizHeaders,omitempty" xml:"BizHeaders,omitempty"`
	// The parameters in the HTTP request.
	BizParams *string `json:"BizParams,omitempty" xml:"BizParams,omitempty"`
	// The notification template that is sent when an alert is triggered. This parameter is required if the **Method** parameter is set to **Post**. You can use the `$content` placeholder to specify the notification content. The content cannot exceed 500 characters in length. For more information, see [Variable description of a notification template](~~251834~~).\\
	Body *string `json:"Body,omitempty" xml:"Body,omitempty"`
	// The HTTP request method.
	//
	// *   Post
	// *   Get
	Method *string `json:"Method,omitempty" xml:"Method,omitempty"`
	// The notification template that is sent when an alert is resolved. This parameter is required if the **Method** parameter is set to **Post**. You can use the `$content` placeholder to specify the notification content. The content cannot exceed 500 characters in length. For more information, see [Variable description of a notification template](~~251834~~).
	RecoverBody *string `json:"RecoverBody,omitempty" xml:"RecoverBody,omitempty"`
	// The URL of the HTTP request **method**.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
	// The ID of the webhook alert contact.
	//
	// *   If you do not specify this parameter, a new webhook alert contact is created.
	// * If you specify this parameter, the specified webhook alert contact is modified.
	WebhookId *int64 `json:"WebhookId,omitempty" xml:"WebhookId,omitempty"`
	// The name of the webhook alert contact.
	WebhookName *string `json:"WebhookName,omitempty" xml:"WebhookName,omitempty"`
}

func (s CreateOrUpdateWebhookContactRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateWebhookContactRequest) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateWebhookContactRequest) SetBizHeaders(v string) *CreateOrUpdateWebhookContactRequest {
	s.BizHeaders = &v
	return s
}

func (s *CreateOrUpdateWebhookContactRequest) SetBizParams(v string) *CreateOrUpdateWebhookContactRequest {
	s.BizParams = &v
	return s
}

func (s *CreateOrUpdateWebhookContactRequest) SetBody(v string) *CreateOrUpdateWebhookContactRequest {
	s.Body = &v
	return s
}

func (s *CreateOrUpdateWebhookContactRequest) SetMethod(v string) *CreateOrUpdateWebhookContactRequest {
	s.Method = &v
	return s
}

func (s *CreateOrUpdateWebhookContactRequest) SetRecoverBody(v string) *CreateOrUpdateWebhookContactRequest {
	s.RecoverBody = &v
	return s
}

func (s *CreateOrUpdateWebhookContactRequest) SetUrl(v string) *CreateOrUpdateWebhookContactRequest {
	s.Url = &v
	return s
}

func (s *CreateOrUpdateWebhookContactRequest) SetWebhookId(v int64) *CreateOrUpdateWebhookContactRequest {
	s.WebhookId = &v
	return s
}

func (s *CreateOrUpdateWebhookContactRequest) SetWebhookName(v string) *CreateOrUpdateWebhookContactRequest {
	s.WebhookName = &v
	return s
}

type CreateOrUpdateWebhookContactResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned webhook alert contact.
	WebhookContact *CreateOrUpdateWebhookContactResponseBodyWebhookContact `json:"WebhookContact,omitempty" xml:"WebhookContact,omitempty" type:"Struct"`
}

func (s CreateOrUpdateWebhookContactResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateWebhookContactResponseBody) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateWebhookContactResponseBody) SetRequestId(v string) *CreateOrUpdateWebhookContactResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateOrUpdateWebhookContactResponseBody) SetWebhookContact(v *CreateOrUpdateWebhookContactResponseBodyWebhookContact) *CreateOrUpdateWebhookContactResponseBody {
	s.WebhookContact = v
	return s
}

type CreateOrUpdateWebhookContactResponseBodyWebhookContact struct {
	// The information about the webhook alert contact.
	Webhook *CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook `json:"Webhook,omitempty" xml:"Webhook,omitempty" type:"Struct"`
	// The ID of the webhook alert contact.
	WebhookId *float32 `json:"WebhookId,omitempty" xml:"WebhookId,omitempty"`
	// The name of the webhook alert contact.
	WebhookName *string `json:"WebhookName,omitempty" xml:"WebhookName,omitempty"`
}

func (s CreateOrUpdateWebhookContactResponseBodyWebhookContact) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateWebhookContactResponseBodyWebhookContact) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateWebhookContactResponseBodyWebhookContact) SetWebhook(v *CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook) *CreateOrUpdateWebhookContactResponseBodyWebhookContact {
	s.Webhook = v
	return s
}

func (s *CreateOrUpdateWebhookContactResponseBodyWebhookContact) SetWebhookId(v float32) *CreateOrUpdateWebhookContactResponseBodyWebhookContact {
	s.WebhookId = &v
	return s
}

func (s *CreateOrUpdateWebhookContactResponseBodyWebhookContact) SetWebhookName(v string) *CreateOrUpdateWebhookContactResponseBodyWebhookContact {
	s.WebhookName = &v
	return s
}

type CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook struct {
	// The HTTP request headers.
	BizHeaders *string `json:"BizHeaders,omitempty" xml:"BizHeaders,omitempty"`
	// The parameters in the HTTP request.
	BizParams *string `json:"BizParams,omitempty" xml:"BizParams,omitempty"`
	// The alert notification template.
	Body *string `json:"Body,omitempty" xml:"Body,omitempty"`
	// The HTTP request method.
	//
	// *   Post
	// *   Get
	Method *string `json:"Method,omitempty" xml:"Method,omitempty"`
	// The notification template for clearing alerts.
	RecoverBody *string `json:"RecoverBody,omitempty" xml:"RecoverBody,omitempty"`
	// The URL of the request method.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook) SetBizHeaders(v string) *CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook {
	s.BizHeaders = &v
	return s
}

func (s *CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook) SetBizParams(v string) *CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook {
	s.BizParams = &v
	return s
}

func (s *CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook) SetBody(v string) *CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook {
	s.Body = &v
	return s
}

func (s *CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook) SetMethod(v string) *CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook {
	s.Method = &v
	return s
}

func (s *CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook) SetRecoverBody(v string) *CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook {
	s.RecoverBody = &v
	return s
}

func (s *CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook) SetUrl(v string) *CreateOrUpdateWebhookContactResponseBodyWebhookContactWebhook {
	s.Url = &v
	return s
}

type CreateOrUpdateWebhookContactResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateOrUpdateWebhookContactResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateOrUpdateWebhookContactResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOrUpdateWebhookContactResponse) GoString() string {
	return s.String()
}

func (s *CreateOrUpdateWebhookContactResponse) SetHeaders(v map[string]*string) *CreateOrUpdateWebhookContactResponse {
	s.Headers = v
	return s
}

func (s *CreateOrUpdateWebhookContactResponse) SetStatusCode(v int32) *CreateOrUpdateWebhookContactResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateOrUpdateWebhookContactResponse) SetBody(v *CreateOrUpdateWebhookContactResponseBody) *CreateOrUpdateWebhookContactResponse {
	s.Body = v
	return s
}

type CreatePrometheusAlertRuleRequest struct {
	AlertName      *string                                 `json:"AlertName,omitempty" xml:"AlertName,omitempty"`
	Annotations    *string                                 `json:"Annotations,omitempty" xml:"Annotations,omitempty"`
	ClusterId      *string                                 `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	DispatchRuleId *int64                                  `json:"DispatchRuleId,omitempty" xml:"DispatchRuleId,omitempty"`
	Duration       *string                                 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	Expression     *string                                 `json:"Expression,omitempty" xml:"Expression,omitempty"`
	Labels         *string                                 `json:"Labels,omitempty" xml:"Labels,omitempty"`
	Message        *string                                 `json:"Message,omitempty" xml:"Message,omitempty"`
	NotifyType     *string                                 `json:"NotifyType,omitempty" xml:"NotifyType,omitempty"`
	RegionId       *string                                 `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	Tags           []*CreatePrometheusAlertRuleRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	Type           *string                                 `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreatePrometheusAlertRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s CreatePrometheusAlertRuleRequest) GoString() string {
	return s.String()
}

func (s *CreatePrometheusAlertRuleRequest) SetAlertName(v string) *CreatePrometheusAlertRuleRequest {
	s.AlertName = &v
	return s
}

func (s *CreatePrometheusAlertRuleRequest) SetAnnotations(v string) *CreatePrometheusAlertRuleRequest {
	s.Annotations = &v
	return s
}

func (s *CreatePrometheusAlertRuleRequest) SetClusterId(v string) *CreatePrometheusAlertRuleRequest {
	s.ClusterId = &v
	return s
}

func (s *CreatePrometheusAlertRuleRequest) SetDispatchRuleId(v int64) *CreatePrometheusAlertRuleRequest {
	s.DispatchRuleId = &v
	return s
}

func (s *CreatePrometheusAlertRuleRequest) SetDuration(v string) *CreatePrometheusAlertRuleRequest {
	s.Duration = &v
	return s
}

func (s *CreatePrometheusAlertRuleRequest) SetExpression(v string) *CreatePrometheusAlertRuleRequest {
	s.Expression = &v
	return s
}

func (s *CreatePrometheusAlertRuleRequest) SetLabels(v string) *CreatePrometheusAlertRuleRequest {
	s.Labels = &v
	return s
}

func (s *CreatePrometheusAlertRuleRequest) SetMessage(v string) *CreatePrometheusAlertRuleRequest {
	s.Message = &v
	return s
}

func (s *CreatePrometheusAlertRuleRequest) SetNotifyType(v string) *CreatePrometheusAlertRuleRequest {
	s.NotifyType = &v
	return s
}

func (s *CreatePrometheusAlertRuleRequest) SetRegionId(v string) *CreatePrometheusAlertRuleRequest {
	s.RegionId = &v
	return s
}

func (s *CreatePrometheusAlertRuleRequest) SetTags(v []*CreatePrometheusAlertRuleRequestTags) *CreatePrometheusAlertRuleRequest {
	s.Tags = v
	return s
}

func (s *CreatePrometheusAlertRuleRequest) SetType(v string) *CreatePrometheusAlertRuleRequest {
	s.Type = &v
	return s
}

type CreatePrometheusAlertRuleRequestTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreatePrometheusAlertRuleRequestTags) String() string {
	return tea.Prettify(s)
}

func (s CreatePrometheusAlertRuleRequestTags) GoString() string {
	return s.String()
}

func (s *CreatePrometheusAlertRuleRequestTags) SetKey(v string) *CreatePrometheusAlertRuleRequestTags {
	s.Key = &v
	return s
}

func (s *CreatePrometheusAlertRuleRequestTags) SetValue(v string) *CreatePrometheusAlertRuleRequestTags {
	s.Value = &v
	return s
}

type CreatePrometheusAlertRuleResponseBody struct {
	Code                *int64                                                    `json:"Code,omitempty" xml:"Code,omitempty"`
	Message             *string                                                   `json:"Message,omitempty" xml:"Message,omitempty"`
	PrometheusAlertRule *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule `json:"PrometheusAlertRule,omitempty" xml:"PrometheusAlertRule,omitempty" type:"Struct"`
	RequestId           *string                                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success             *bool                                                     `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreatePrometheusAlertRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreatePrometheusAlertRuleResponseBody) GoString() string {
	return s.String()
}

func (s *CreatePrometheusAlertRuleResponseBody) SetCode(v int64) *CreatePrometheusAlertRuleResponseBody {
	s.Code = &v
	return s
}

func (s *CreatePrometheusAlertRuleResponseBody) SetMessage(v string) *CreatePrometheusAlertRuleResponseBody {
	s.Message = &v
	return s
}

func (s *CreatePrometheusAlertRuleResponseBody) SetPrometheusAlertRule(v *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule) *CreatePrometheusAlertRuleResponseBody {
	s.PrometheusAlertRule = v
	return s
}

func (s *CreatePrometheusAlertRuleResponseBody) SetRequestId(v string) *CreatePrometheusAlertRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreatePrometheusAlertRuleResponseBody) SetSuccess(v bool) *CreatePrometheusAlertRuleResponseBody {
	s.Success = &v
	return s
}

type CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule struct {
	AlertId        *int64                                                                 `json:"AlertId,omitempty" xml:"AlertId,omitempty"`
	AlertName      *string                                                                `json:"AlertName,omitempty" xml:"AlertName,omitempty"`
	Annotations    []*CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations `json:"Annotations,omitempty" xml:"Annotations,omitempty" type:"Repeated"`
	ClusterId      *string                                                                `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	DispatchRuleId *int64                                                                 `json:"DispatchRuleId,omitempty" xml:"DispatchRuleId,omitempty"`
	Duration       *string                                                                `json:"Duration,omitempty" xml:"Duration,omitempty"`
	Expression     *string                                                                `json:"Expression,omitempty" xml:"Expression,omitempty"`
	Labels         []*CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels      `json:"Labels,omitempty" xml:"Labels,omitempty" type:"Repeated"`
	Message        *string                                                                `json:"Message,omitempty" xml:"Message,omitempty"`
	NotifyType     *string                                                                `json:"NotifyType,omitempty" xml:"NotifyType,omitempty"`
	Status         *int32                                                                 `json:"Status,omitempty" xml:"Status,omitempty"`
	Type           *string                                                                `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule) String() string {
	return tea.Prettify(s)
}

func (s CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule) GoString() string {
	return s.String()
}

func (s *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetAlertId(v int64) *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.AlertId = &v
	return s
}

func (s *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetAlertName(v string) *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.AlertName = &v
	return s
}

func (s *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetAnnotations(v []*CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations) *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.Annotations = v
	return s
}

func (s *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetClusterId(v string) *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.ClusterId = &v
	return s
}

func (s *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetDispatchRuleId(v int64) *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.DispatchRuleId = &v
	return s
}

func (s *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetDuration(v string) *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.Duration = &v
	return s
}

func (s *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetExpression(v string) *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.Expression = &v
	return s
}

func (s *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetLabels(v []*CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels) *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.Labels = v
	return s
}

func (s *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetMessage(v string) *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.Message = &v
	return s
}

func (s *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetNotifyType(v string) *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.NotifyType = &v
	return s
}

func (s *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetStatus(v int32) *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.Status = &v
	return s
}

func (s *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetType(v string) *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.Type = &v
	return s
}

type CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations struct {
	Name  *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations) String() string {
	return tea.Prettify(s)
}

func (s CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations) GoString() string {
	return s.String()
}

func (s *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations) SetName(v string) *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations {
	s.Name = &v
	return s
}

func (s *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations) SetValue(v string) *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations {
	s.Value = &v
	return s
}

type CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels struct {
	Name  *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels) String() string {
	return tea.Prettify(s)
}

func (s CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels) GoString() string {
	return s.String()
}

func (s *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels) SetName(v string) *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels {
	s.Name = &v
	return s
}

func (s *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels) SetValue(v string) *CreatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels {
	s.Value = &v
	return s
}

type CreatePrometheusAlertRuleResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreatePrometheusAlertRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreatePrometheusAlertRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s CreatePrometheusAlertRuleResponse) GoString() string {
	return s.String()
}

func (s *CreatePrometheusAlertRuleResponse) SetHeaders(v map[string]*string) *CreatePrometheusAlertRuleResponse {
	s.Headers = v
	return s
}

func (s *CreatePrometheusAlertRuleResponse) SetStatusCode(v int32) *CreatePrometheusAlertRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreatePrometheusAlertRuleResponse) SetBody(v *CreatePrometheusAlertRuleResponseBody) *CreatePrometheusAlertRuleResponse {
	s.Body = v
	return s
}

type CreatePrometheusInstanceRequest struct {
	// To edit a GlobalView aggregated instance, do you require all passed child instances to be verified successfully before creating a GlobalView instance (optional, default to false):
	// - true
	// - false
	AllSubClustersSuccess *bool `json:"AllSubClustersSuccess,omitempty" xml:"AllSubClustersSuccess,omitempty"`
	// The ID of the cluster. This parameter is required if you set ClusterType to aliyun-cs.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the cluster. This parameter is required if you set ClusterType to remote-write, ecs, or global-view.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// Types include:
	// - remote-write: General-purpose Instance
	// - ecs: Prometheus for ECS
	// - global-view: Global Aggregation Instance
	// - aliyun-cs: Prometheus Instance for Container Service
	// - cloud-product: Prometheus for cloud monitor
	// - cloud-monitor: Prometheus for enterprise cloud monitor
	// - flink: Prometheus for FLink
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The ID of the Grafana dedicated instance. This parameter is available if you set ClusterType to ecs.
	GrafanaInstanceId *string `json:"GrafanaInstanceId,omitempty" xml:"GrafanaInstanceId,omitempty"`
	// The region ID. If you create a Prometheus instance for a cloud service in China, set this parameter to cn-shanghai.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the custom resource group. You can specify this parameter to bind the instance to the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of the security group. This parameter is required if you set ClusterType to ecs or create an ASK managed cluster.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// The child instances of the Prometheus instance for GlobalView. The value is a JSON string.
	SubClustersJson *string `json:"SubClustersJson,omitempty" xml:"SubClustersJson,omitempty"`
	// The tags of the instance. You can specify this parameter to manage tags for the instance.
	Tags []*CreatePrometheusInstanceRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The ID of the vSwitch. This parameter is required if you set ClusterType to ecs or create an ASK managed cluster.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the virtual private cloud (VPC). This parameter is required if you set ClusterType to ecs or create a serverless Kubernetes (ASK) managed cluster.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s CreatePrometheusInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreatePrometheusInstanceRequest) GoString() string {
	return s.String()
}

func (s *CreatePrometheusInstanceRequest) SetAllSubClustersSuccess(v bool) *CreatePrometheusInstanceRequest {
	s.AllSubClustersSuccess = &v
	return s
}

func (s *CreatePrometheusInstanceRequest) SetClusterId(v string) *CreatePrometheusInstanceRequest {
	s.ClusterId = &v
	return s
}

func (s *CreatePrometheusInstanceRequest) SetClusterName(v string) *CreatePrometheusInstanceRequest {
	s.ClusterName = &v
	return s
}

func (s *CreatePrometheusInstanceRequest) SetClusterType(v string) *CreatePrometheusInstanceRequest {
	s.ClusterType = &v
	return s
}

func (s *CreatePrometheusInstanceRequest) SetGrafanaInstanceId(v string) *CreatePrometheusInstanceRequest {
	s.GrafanaInstanceId = &v
	return s
}

func (s *CreatePrometheusInstanceRequest) SetRegionId(v string) *CreatePrometheusInstanceRequest {
	s.RegionId = &v
	return s
}

func (s *CreatePrometheusInstanceRequest) SetResourceGroupId(v string) *CreatePrometheusInstanceRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreatePrometheusInstanceRequest) SetSecurityGroupId(v string) *CreatePrometheusInstanceRequest {
	s.SecurityGroupId = &v
	return s
}

func (s *CreatePrometheusInstanceRequest) SetSubClustersJson(v string) *CreatePrometheusInstanceRequest {
	s.SubClustersJson = &v
	return s
}

func (s *CreatePrometheusInstanceRequest) SetTags(v []*CreatePrometheusInstanceRequestTags) *CreatePrometheusInstanceRequest {
	s.Tags = v
	return s
}

func (s *CreatePrometheusInstanceRequest) SetVSwitchId(v string) *CreatePrometheusInstanceRequest {
	s.VSwitchId = &v
	return s
}

func (s *CreatePrometheusInstanceRequest) SetVpcId(v string) *CreatePrometheusInstanceRequest {
	s.VpcId = &v
	return s
}

type CreatePrometheusInstanceRequestTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreatePrometheusInstanceRequestTags) String() string {
	return tea.Prettify(s)
}

func (s CreatePrometheusInstanceRequestTags) GoString() string {
	return s.String()
}

func (s *CreatePrometheusInstanceRequestTags) SetKey(v string) *CreatePrometheusInstanceRequestTags {
	s.Key = &v
	return s
}

func (s *CreatePrometheusInstanceRequestTags) SetValue(v string) *CreatePrometheusInstanceRequestTags {
	s.Value = &v
	return s
}

type CreatePrometheusInstanceResponseBody struct {
	// The status code that is returned. Valid values:
	//
	// *   `2XX: The request is successful.`
	// *   `3XX: A redirection message is returned.`
	// *   `4XX: The request is invalid.`
	// *   `5XX: A server error occurred.`
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the created Prometheus instance.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error message that is returned if the request failed.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreatePrometheusInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreatePrometheusInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *CreatePrometheusInstanceResponseBody) SetCode(v int32) *CreatePrometheusInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *CreatePrometheusInstanceResponseBody) SetData(v string) *CreatePrometheusInstanceResponseBody {
	s.Data = &v
	return s
}

func (s *CreatePrometheusInstanceResponseBody) SetMessage(v string) *CreatePrometheusInstanceResponseBody {
	s.Message = &v
	return s
}

func (s *CreatePrometheusInstanceResponseBody) SetRequestId(v string) *CreatePrometheusInstanceResponseBody {
	s.RequestId = &v
	return s
}

type CreatePrometheusInstanceResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreatePrometheusInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreatePrometheusInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreatePrometheusInstanceResponse) GoString() string {
	return s.String()
}

func (s *CreatePrometheusInstanceResponse) SetHeaders(v map[string]*string) *CreatePrometheusInstanceResponse {
	s.Headers = v
	return s
}

func (s *CreatePrometheusInstanceResponse) SetStatusCode(v int32) *CreatePrometheusInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreatePrometheusInstanceResponse) SetBody(v *CreatePrometheusInstanceResponseBody) *CreatePrometheusInstanceResponse {
	s.Body = v
	return s
}

type CreatePrometheusMonitoringRequest struct {
	// The ID of the Prometheus instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The monitoring configuration. Specify a YAML string.
	ConfigYaml *string `json:"ConfigYaml,omitempty" xml:"ConfigYaml,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The status of the monitoring configuration. Valid values: run and stop. Default value: run. This parameter is not available if the Type parameter is set to Probe.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the monitoring configuration.
	// Valid values for a Prometheus instance for Container Service: serviceMonitor, podMonitor, customJob, and probe.
	// Valid values for a Prometheus instance for ECS: customJob and probe.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreatePrometheusMonitoringRequest) String() string {
	return tea.Prettify(s)
}

func (s CreatePrometheusMonitoringRequest) GoString() string {
	return s.String()
}

func (s *CreatePrometheusMonitoringRequest) SetClusterId(v string) *CreatePrometheusMonitoringRequest {
	s.ClusterId = &v
	return s
}

func (s *CreatePrometheusMonitoringRequest) SetConfigYaml(v string) *CreatePrometheusMonitoringRequest {
	s.ConfigYaml = &v
	return s
}

func (s *CreatePrometheusMonitoringRequest) SetRegionId(v string) *CreatePrometheusMonitoringRequest {
	s.RegionId = &v
	return s
}

func (s *CreatePrometheusMonitoringRequest) SetStatus(v string) *CreatePrometheusMonitoringRequest {
	s.Status = &v
	return s
}

func (s *CreatePrometheusMonitoringRequest) SetType(v string) *CreatePrometheusMonitoringRequest {
	s.Type = &v
	return s
}

type CreatePrometheusMonitoringResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The name of the monitoring configuration that was added, or the exception information.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreatePrometheusMonitoringResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreatePrometheusMonitoringResponseBody) GoString() string {
	return s.String()
}

func (s *CreatePrometheusMonitoringResponseBody) SetCode(v int32) *CreatePrometheusMonitoringResponseBody {
	s.Code = &v
	return s
}

func (s *CreatePrometheusMonitoringResponseBody) SetData(v string) *CreatePrometheusMonitoringResponseBody {
	s.Data = &v
	return s
}

func (s *CreatePrometheusMonitoringResponseBody) SetMessage(v string) *CreatePrometheusMonitoringResponseBody {
	s.Message = &v
	return s
}

func (s *CreatePrometheusMonitoringResponseBody) SetRequestId(v string) *CreatePrometheusMonitoringResponseBody {
	s.RequestId = &v
	return s
}

type CreatePrometheusMonitoringResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreatePrometheusMonitoringResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreatePrometheusMonitoringResponse) String() string {
	return tea.Prettify(s)
}

func (s CreatePrometheusMonitoringResponse) GoString() string {
	return s.String()
}

func (s *CreatePrometheusMonitoringResponse) SetHeaders(v map[string]*string) *CreatePrometheusMonitoringResponse {
	s.Headers = v
	return s
}

func (s *CreatePrometheusMonitoringResponse) SetStatusCode(v int32) *CreatePrometheusMonitoringResponse {
	s.StatusCode = &v
	return s
}

func (s *CreatePrometheusMonitoringResponse) SetBody(v *CreatePrometheusMonitoringResponseBody) *CreatePrometheusMonitoringResponse {
	s.Body = v
	return s
}

type CreateRetcodeAppRequest struct {
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group. You can obtain the resource group ID in the **Resource Management** console.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The name of the application that is monitored by Browser Monitoring.
	RetcodeAppName *string `json:"RetcodeAppName,omitempty" xml:"RetcodeAppName,omitempty"`
	// The site type.
	RetcodeAppType *string `json:"RetcodeAppType,omitempty" xml:"RetcodeAppType,omitempty"`
	// The list of tags.
	Tags []*CreateRetcodeAppRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s CreateRetcodeAppRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateRetcodeAppRequest) GoString() string {
	return s.String()
}

func (s *CreateRetcodeAppRequest) SetRegionId(v string) *CreateRetcodeAppRequest {
	s.RegionId = &v
	return s
}

func (s *CreateRetcodeAppRequest) SetResourceGroupId(v string) *CreateRetcodeAppRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateRetcodeAppRequest) SetRetcodeAppName(v string) *CreateRetcodeAppRequest {
	s.RetcodeAppName = &v
	return s
}

func (s *CreateRetcodeAppRequest) SetRetcodeAppType(v string) *CreateRetcodeAppRequest {
	s.RetcodeAppType = &v
	return s
}

func (s *CreateRetcodeAppRequest) SetTags(v []*CreateRetcodeAppRequestTags) *CreateRetcodeAppRequest {
	s.Tags = v
	return s
}

type CreateRetcodeAppRequestTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateRetcodeAppRequestTags) String() string {
	return tea.Prettify(s)
}

func (s CreateRetcodeAppRequestTags) GoString() string {
	return s.String()
}

func (s *CreateRetcodeAppRequestTags) SetKey(v string) *CreateRetcodeAppRequestTags {
	s.Key = &v
	return s
}

func (s *CreateRetcodeAppRequestTags) SetValue(v string) *CreateRetcodeAppRequestTags {
	s.Value = &v
	return s
}

type CreateRetcodeAppResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The response parameters.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The return detail.
	RetcodeAppDataBean *CreateRetcodeAppResponseBodyRetcodeAppDataBean `json:"RetcodeAppDataBean,omitempty" xml:"RetcodeAppDataBean,omitempty" type:"Struct"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   true: The call was successful.
	// *   false: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateRetcodeAppResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateRetcodeAppResponseBody) GoString() string {
	return s.String()
}

func (s *CreateRetcodeAppResponseBody) SetCode(v int32) *CreateRetcodeAppResponseBody {
	s.Code = &v
	return s
}

func (s *CreateRetcodeAppResponseBody) SetData(v string) *CreateRetcodeAppResponseBody {
	s.Data = &v
	return s
}

func (s *CreateRetcodeAppResponseBody) SetMessage(v string) *CreateRetcodeAppResponseBody {
	s.Message = &v
	return s
}

func (s *CreateRetcodeAppResponseBody) SetRequestId(v string) *CreateRetcodeAppResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateRetcodeAppResponseBody) SetRetcodeAppDataBean(v *CreateRetcodeAppResponseBodyRetcodeAppDataBean) *CreateRetcodeAppResponseBody {
	s.RetcodeAppDataBean = v
	return s
}

func (s *CreateRetcodeAppResponseBody) SetSuccess(v bool) *CreateRetcodeAppResponseBody {
	s.Success = &v
	return s
}

type CreateRetcodeAppResponseBodyRetcodeAppDataBean struct {
	// The application ID.
	AppId *int64 `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// PID.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The ID of the resource group.
	//
	// If this parameter is left empty, the default resource group is used. You can view the resource group ID on the Resource Group page in the Resource Management console.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The tags.
	Tags *CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
}

func (s CreateRetcodeAppResponseBodyRetcodeAppDataBean) String() string {
	return tea.Prettify(s)
}

func (s CreateRetcodeAppResponseBodyRetcodeAppDataBean) GoString() string {
	return s.String()
}

func (s *CreateRetcodeAppResponseBodyRetcodeAppDataBean) SetAppId(v int64) *CreateRetcodeAppResponseBodyRetcodeAppDataBean {
	s.AppId = &v
	return s
}

func (s *CreateRetcodeAppResponseBodyRetcodeAppDataBean) SetPid(v string) *CreateRetcodeAppResponseBodyRetcodeAppDataBean {
	s.Pid = &v
	return s
}

func (s *CreateRetcodeAppResponseBodyRetcodeAppDataBean) SetResourceGroupId(v string) *CreateRetcodeAppResponseBodyRetcodeAppDataBean {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateRetcodeAppResponseBodyRetcodeAppDataBean) SetTags(v *CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags) *CreateRetcodeAppResponseBodyRetcodeAppDataBean {
	s.Tags = v
	return s
}

type CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags struct {
	Tags []*CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags) String() string {
	return tea.Prettify(s)
}

func (s CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags) GoString() string {
	return s.String()
}

func (s *CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags) SetTags(v []*CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags) *CreateRetcodeAppResponseBodyRetcodeAppDataBeanTags {
	s.Tags = v
	return s
}

type CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags) String() string {
	return tea.Prettify(s)
}

func (s CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags) GoString() string {
	return s.String()
}

func (s *CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags) SetKey(v string) *CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags {
	s.Key = &v
	return s
}

func (s *CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags) SetValue(v string) *CreateRetcodeAppResponseBodyRetcodeAppDataBeanTagsTags {
	s.Value = &v
	return s
}

type CreateRetcodeAppResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateRetcodeAppResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateRetcodeAppResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateRetcodeAppResponse) GoString() string {
	return s.String()
}

func (s *CreateRetcodeAppResponse) SetHeaders(v map[string]*string) *CreateRetcodeAppResponse {
	s.Headers = v
	return s
}

func (s *CreateRetcodeAppResponse) SetStatusCode(v int32) *CreateRetcodeAppResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateRetcodeAppResponse) SetBody(v *CreateRetcodeAppResponseBody) *CreateRetcodeAppResponse {
	s.Body = v
	return s
}

type CreateSyntheticTaskRequest struct {
	CommonParam    *CreateSyntheticTaskRequestCommonParam    `json:"CommonParam,omitempty" xml:"CommonParam,omitempty" type:"Struct"`
	Download       *CreateSyntheticTaskRequestDownload       `json:"Download,omitempty" xml:"Download,omitempty" type:"Struct"`
	ExtendInterval *CreateSyntheticTaskRequestExtendInterval `json:"ExtendInterval,omitempty" xml:"ExtendInterval,omitempty" type:"Struct"`
	IntervalTime   *string                                   `json:"IntervalTime,omitempty" xml:"IntervalTime,omitempty"`
	IntervalType   *string                                   `json:"IntervalType,omitempty" xml:"IntervalType,omitempty"`
	IpType         *int64                                    `json:"IpType,omitempty" xml:"IpType,omitempty"`
	MonitorList    []*CreateSyntheticTaskRequestMonitorList  `json:"MonitorList,omitempty" xml:"MonitorList,omitempty" type:"Repeated"`
	Navigation     *CreateSyntheticTaskRequestNavigation     `json:"Navigation,omitempty" xml:"Navigation,omitempty" type:"Struct"`
	Net            *CreateSyntheticTaskRequestNet            `json:"Net,omitempty" xml:"Net,omitempty" type:"Struct"`
	Protocol       *CreateSyntheticTaskRequestProtocol       `json:"Protocol,omitempty" xml:"Protocol,omitempty" type:"Struct"`
	RegionId       *string                                   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	TaskName       *string                                   `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
	TaskType       *int64                                    `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
	UpdateTask     *bool                                     `json:"UpdateTask,omitempty" xml:"UpdateTask,omitempty"`
	Url            *string                                   `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s CreateSyntheticTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSyntheticTaskRequest) GoString() string {
	return s.String()
}

func (s *CreateSyntheticTaskRequest) SetCommonParam(v *CreateSyntheticTaskRequestCommonParam) *CreateSyntheticTaskRequest {
	s.CommonParam = v
	return s
}

func (s *CreateSyntheticTaskRequest) SetDownload(v *CreateSyntheticTaskRequestDownload) *CreateSyntheticTaskRequest {
	s.Download = v
	return s
}

func (s *CreateSyntheticTaskRequest) SetExtendInterval(v *CreateSyntheticTaskRequestExtendInterval) *CreateSyntheticTaskRequest {
	s.ExtendInterval = v
	return s
}

func (s *CreateSyntheticTaskRequest) SetIntervalTime(v string) *CreateSyntheticTaskRequest {
	s.IntervalTime = &v
	return s
}

func (s *CreateSyntheticTaskRequest) SetIntervalType(v string) *CreateSyntheticTaskRequest {
	s.IntervalType = &v
	return s
}

func (s *CreateSyntheticTaskRequest) SetIpType(v int64) *CreateSyntheticTaskRequest {
	s.IpType = &v
	return s
}

func (s *CreateSyntheticTaskRequest) SetMonitorList(v []*CreateSyntheticTaskRequestMonitorList) *CreateSyntheticTaskRequest {
	s.MonitorList = v
	return s
}

func (s *CreateSyntheticTaskRequest) SetNavigation(v *CreateSyntheticTaskRequestNavigation) *CreateSyntheticTaskRequest {
	s.Navigation = v
	return s
}

func (s *CreateSyntheticTaskRequest) SetNet(v *CreateSyntheticTaskRequestNet) *CreateSyntheticTaskRequest {
	s.Net = v
	return s
}

func (s *CreateSyntheticTaskRequest) SetProtocol(v *CreateSyntheticTaskRequestProtocol) *CreateSyntheticTaskRequest {
	s.Protocol = v
	return s
}

func (s *CreateSyntheticTaskRequest) SetRegionId(v string) *CreateSyntheticTaskRequest {
	s.RegionId = &v
	return s
}

func (s *CreateSyntheticTaskRequest) SetTaskName(v string) *CreateSyntheticTaskRequest {
	s.TaskName = &v
	return s
}

func (s *CreateSyntheticTaskRequest) SetTaskType(v int64) *CreateSyntheticTaskRequest {
	s.TaskType = &v
	return s
}

func (s *CreateSyntheticTaskRequest) SetUpdateTask(v bool) *CreateSyntheticTaskRequest {
	s.UpdateTask = &v
	return s
}

func (s *CreateSyntheticTaskRequest) SetUrl(v string) *CreateSyntheticTaskRequest {
	s.Url = &v
	return s
}

type CreateSyntheticTaskRequestCommonParam struct {
	AlarmFlag          *string                                           `json:"AlarmFlag,omitempty" xml:"AlarmFlag,omitempty"`
	AlertList          []*CreateSyntheticTaskRequestCommonParamAlertList `json:"AlertList,omitempty" xml:"AlertList,omitempty" type:"Repeated"`
	AlertNotifierId    *string                                           `json:"AlertNotifierId,omitempty" xml:"AlertNotifierId,omitempty"`
	AlertPolicyId      *string                                           `json:"AlertPolicyId,omitempty" xml:"AlertPolicyId,omitempty"`
	MonitorSamples     *int64                                            `json:"MonitorSamples,omitempty" xml:"MonitorSamples,omitempty"`
	StartExecutionTime *int64                                            `json:"StartExecutionTime,omitempty" xml:"StartExecutionTime,omitempty"`
}

func (s CreateSyntheticTaskRequestCommonParam) String() string {
	return tea.Prettify(s)
}

func (s CreateSyntheticTaskRequestCommonParam) GoString() string {
	return s.String()
}

func (s *CreateSyntheticTaskRequestCommonParam) SetAlarmFlag(v string) *CreateSyntheticTaskRequestCommonParam {
	s.AlarmFlag = &v
	return s
}

func (s *CreateSyntheticTaskRequestCommonParam) SetAlertList(v []*CreateSyntheticTaskRequestCommonParamAlertList) *CreateSyntheticTaskRequestCommonParam {
	s.AlertList = v
	return s
}

func (s *CreateSyntheticTaskRequestCommonParam) SetAlertNotifierId(v string) *CreateSyntheticTaskRequestCommonParam {
	s.AlertNotifierId = &v
	return s
}

func (s *CreateSyntheticTaskRequestCommonParam) SetAlertPolicyId(v string) *CreateSyntheticTaskRequestCommonParam {
	s.AlertPolicyId = &v
	return s
}

func (s *CreateSyntheticTaskRequestCommonParam) SetMonitorSamples(v int64) *CreateSyntheticTaskRequestCommonParam {
	s.MonitorSamples = &v
	return s
}

func (s *CreateSyntheticTaskRequestCommonParam) SetStartExecutionTime(v int64) *CreateSyntheticTaskRequestCommonParam {
	s.StartExecutionTime = &v
	return s
}

type CreateSyntheticTaskRequestCommonParamAlertList struct {
	IsCritical *int64  `json:"IsCritical,omitempty" xml:"IsCritical,omitempty"`
	Name       *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Symbols    *int64  `json:"Symbols,omitempty" xml:"Symbols,omitempty"`
}

func (s CreateSyntheticTaskRequestCommonParamAlertList) String() string {
	return tea.Prettify(s)
}

func (s CreateSyntheticTaskRequestCommonParamAlertList) GoString() string {
	return s.String()
}

func (s *CreateSyntheticTaskRequestCommonParamAlertList) SetIsCritical(v int64) *CreateSyntheticTaskRequestCommonParamAlertList {
	s.IsCritical = &v
	return s
}

func (s *CreateSyntheticTaskRequestCommonParamAlertList) SetName(v string) *CreateSyntheticTaskRequestCommonParamAlertList {
	s.Name = &v
	return s
}

func (s *CreateSyntheticTaskRequestCommonParamAlertList) SetSymbols(v int64) *CreateSyntheticTaskRequestCommonParamAlertList {
	s.Symbols = &v
	return s
}

type CreateSyntheticTaskRequestDownload struct {
	ConnectionTimeout              *float64 `json:"ConnectionTimeout,omitempty" xml:"ConnectionTimeout,omitempty"`
	DownloadCustomHeaderContent    *string  `json:"DownloadCustomHeaderContent,omitempty" xml:"DownloadCustomHeaderContent,omitempty"`
	DownloadCustomHost             *int64   `json:"DownloadCustomHost,omitempty" xml:"DownloadCustomHost,omitempty"`
	DownloadCustomHostIp           *string  `json:"DownloadCustomHostIp,omitempty" xml:"DownloadCustomHostIp,omitempty"`
	DownloadIgnoreCertificateError *string  `json:"DownloadIgnoreCertificateError,omitempty" xml:"DownloadIgnoreCertificateError,omitempty"`
	DownloadKernel                 *int64   `json:"DownloadKernel,omitempty" xml:"DownloadKernel,omitempty"`
	DownloadRedirection            *int64   `json:"DownloadRedirection,omitempty" xml:"DownloadRedirection,omitempty"`
	DownloadTransmissionSize       *int64   `json:"DownloadTransmissionSize,omitempty" xml:"DownloadTransmissionSize,omitempty"`
	MonitorTimeout                 *int64   `json:"MonitorTimeout,omitempty" xml:"MonitorTimeout,omitempty"`
	QuickProtocol                  *string  `json:"QuickProtocol,omitempty" xml:"QuickProtocol,omitempty"`
	ValidateKeywords               *string  `json:"ValidateKeywords,omitempty" xml:"ValidateKeywords,omitempty"`
	VerifyWay                      *int64   `json:"VerifyWay,omitempty" xml:"VerifyWay,omitempty"`
	WhiteList                      *string  `json:"WhiteList,omitempty" xml:"WhiteList,omitempty"`
}

func (s CreateSyntheticTaskRequestDownload) String() string {
	return tea.Prettify(s)
}

func (s CreateSyntheticTaskRequestDownload) GoString() string {
	return s.String()
}

func (s *CreateSyntheticTaskRequestDownload) SetConnectionTimeout(v float64) *CreateSyntheticTaskRequestDownload {
	s.ConnectionTimeout = &v
	return s
}

func (s *CreateSyntheticTaskRequestDownload) SetDownloadCustomHeaderContent(v string) *CreateSyntheticTaskRequestDownload {
	s.DownloadCustomHeaderContent = &v
	return s
}

func (s *CreateSyntheticTaskRequestDownload) SetDownloadCustomHost(v int64) *CreateSyntheticTaskRequestDownload {
	s.DownloadCustomHost = &v
	return s
}

func (s *CreateSyntheticTaskRequestDownload) SetDownloadCustomHostIp(v string) *CreateSyntheticTaskRequestDownload {
	s.DownloadCustomHostIp = &v
	return s
}

func (s *CreateSyntheticTaskRequestDownload) SetDownloadIgnoreCertificateError(v string) *CreateSyntheticTaskRequestDownload {
	s.DownloadIgnoreCertificateError = &v
	return s
}

func (s *CreateSyntheticTaskRequestDownload) SetDownloadKernel(v int64) *CreateSyntheticTaskRequestDownload {
	s.DownloadKernel = &v
	return s
}

func (s *CreateSyntheticTaskRequestDownload) SetDownloadRedirection(v int64) *CreateSyntheticTaskRequestDownload {
	s.DownloadRedirection = &v
	return s
}

func (s *CreateSyntheticTaskRequestDownload) SetDownloadTransmissionSize(v int64) *CreateSyntheticTaskRequestDownload {
	s.DownloadTransmissionSize = &v
	return s
}

func (s *CreateSyntheticTaskRequestDownload) SetMonitorTimeout(v int64) *CreateSyntheticTaskRequestDownload {
	s.MonitorTimeout = &v
	return s
}

func (s *CreateSyntheticTaskRequestDownload) SetQuickProtocol(v string) *CreateSyntheticTaskRequestDownload {
	s.QuickProtocol = &v
	return s
}

func (s *CreateSyntheticTaskRequestDownload) SetValidateKeywords(v string) *CreateSyntheticTaskRequestDownload {
	s.ValidateKeywords = &v
	return s
}

func (s *CreateSyntheticTaskRequestDownload) SetVerifyWay(v int64) *CreateSyntheticTaskRequestDownload {
	s.VerifyWay = &v
	return s
}

func (s *CreateSyntheticTaskRequestDownload) SetWhiteList(v string) *CreateSyntheticTaskRequestDownload {
	s.WhiteList = &v
	return s
}

type CreateSyntheticTaskRequestExtendInterval struct {
	Days        []*int64 `json:"Days,omitempty" xml:"Days,omitempty" type:"Repeated"`
	EndHour     *int64   `json:"EndHour,omitempty" xml:"EndHour,omitempty"`
	EndMinute   *int64   `json:"EndMinute,omitempty" xml:"EndMinute,omitempty"`
	EndTime     *string  `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	StartHour   *int64   `json:"StartHour,omitempty" xml:"StartHour,omitempty"`
	StartMinute *int64   `json:"StartMinute,omitempty" xml:"StartMinute,omitempty"`
	StartTime   *string  `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s CreateSyntheticTaskRequestExtendInterval) String() string {
	return tea.Prettify(s)
}

func (s CreateSyntheticTaskRequestExtendInterval) GoString() string {
	return s.String()
}

func (s *CreateSyntheticTaskRequestExtendInterval) SetDays(v []*int64) *CreateSyntheticTaskRequestExtendInterval {
	s.Days = v
	return s
}

func (s *CreateSyntheticTaskRequestExtendInterval) SetEndHour(v int64) *CreateSyntheticTaskRequestExtendInterval {
	s.EndHour = &v
	return s
}

func (s *CreateSyntheticTaskRequestExtendInterval) SetEndMinute(v int64) *CreateSyntheticTaskRequestExtendInterval {
	s.EndMinute = &v
	return s
}

func (s *CreateSyntheticTaskRequestExtendInterval) SetEndTime(v string) *CreateSyntheticTaskRequestExtendInterval {
	s.EndTime = &v
	return s
}

func (s *CreateSyntheticTaskRequestExtendInterval) SetStartHour(v int64) *CreateSyntheticTaskRequestExtendInterval {
	s.StartHour = &v
	return s
}

func (s *CreateSyntheticTaskRequestExtendInterval) SetStartMinute(v int64) *CreateSyntheticTaskRequestExtendInterval {
	s.StartMinute = &v
	return s
}

func (s *CreateSyntheticTaskRequestExtendInterval) SetStartTime(v string) *CreateSyntheticTaskRequestExtendInterval {
	s.StartTime = &v
	return s
}

type CreateSyntheticTaskRequestMonitorList struct {
	CityCode     *int64 `json:"CityCode,omitempty" xml:"CityCode,omitempty"`
	MonitorType  *int64 `json:"MonitorType,omitempty" xml:"MonitorType,omitempty"`
	NetServiceId *int64 `json:"NetServiceId,omitempty" xml:"NetServiceId,omitempty"`
}

func (s CreateSyntheticTaskRequestMonitorList) String() string {
	return tea.Prettify(s)
}

func (s CreateSyntheticTaskRequestMonitorList) GoString() string {
	return s.String()
}

func (s *CreateSyntheticTaskRequestMonitorList) SetCityCode(v int64) *CreateSyntheticTaskRequestMonitorList {
	s.CityCode = &v
	return s
}

func (s *CreateSyntheticTaskRequestMonitorList) SetMonitorType(v int64) *CreateSyntheticTaskRequestMonitorList {
	s.MonitorType = &v
	return s
}

func (s *CreateSyntheticTaskRequestMonitorList) SetNetServiceId(v int64) *CreateSyntheticTaskRequestMonitorList {
	s.NetServiceId = &v
	return s
}

type CreateSyntheticTaskRequestNavigation struct {
	DNSHijackWhiteList        *string  `json:"DNSHijackWhiteList,omitempty" xml:"DNSHijackWhiteList,omitempty"`
	ElementBlacklist          *string  `json:"ElementBlacklist,omitempty" xml:"ElementBlacklist,omitempty"`
	ExecuteActiveX            *int64   `json:"ExecuteActiveX,omitempty" xml:"ExecuteActiveX,omitempty"`
	ExecuteApplication        *int64   `json:"ExecuteApplication,omitempty" xml:"ExecuteApplication,omitempty"`
	ExecuteScript             *int64   `json:"ExecuteScript,omitempty" xml:"ExecuteScript,omitempty"`
	FilterInvalidIP           *int64   `json:"FilterInvalidIP,omitempty" xml:"FilterInvalidIP,omitempty"`
	FlowHijackJumpTimes       *int64   `json:"FlowHijackJumpTimes,omitempty" xml:"FlowHijackJumpTimes,omitempty"`
	FlowHijackLogo            *string  `json:"FlowHijackLogo,omitempty" xml:"FlowHijackLogo,omitempty"`
	MonitorTimeout            *string  `json:"MonitorTimeout,omitempty" xml:"MonitorTimeout,omitempty"`
	NavAutomaticScrolling     *string  `json:"NavAutomaticScrolling,omitempty" xml:"NavAutomaticScrolling,omitempty"`
	NavCustomHeader           *string  `json:"NavCustomHeader,omitempty" xml:"NavCustomHeader,omitempty"`
	NavCustomHeaderContent    *string  `json:"NavCustomHeaderContent,omitempty" xml:"NavCustomHeaderContent,omitempty"`
	NavCustomHost             *int64   `json:"NavCustomHost,omitempty" xml:"NavCustomHost,omitempty"`
	NavCustomHostIp           *string  `json:"NavCustomHostIp,omitempty" xml:"NavCustomHostIp,omitempty"`
	NavDisableCache           *int64   `json:"NavDisableCache,omitempty" xml:"NavDisableCache,omitempty"`
	NavDisableCompression     *string  `json:"NavDisableCompression,omitempty" xml:"NavDisableCompression,omitempty"`
	NavIgnoreCertificateError *int64   `json:"NavIgnoreCertificateError,omitempty" xml:"NavIgnoreCertificateError,omitempty"`
	NavRedirection            *int64   `json:"NavRedirection,omitempty" xml:"NavRedirection,omitempty"`
	NavReturnElement          *int64   `json:"NavReturnElement,omitempty" xml:"NavReturnElement,omitempty"`
	PageTamper                *string  `json:"PageTamper,omitempty" xml:"PageTamper,omitempty"`
	ProcessName               *string  `json:"ProcessName,omitempty" xml:"ProcessName,omitempty"`
	QUICDomain                *string  `json:"QUICDomain,omitempty" xml:"QUICDomain,omitempty"`
	QUICVersion               *int64   `json:"QUICVersion,omitempty" xml:"QUICVersion,omitempty"`
	RequestHeader             *int64   `json:"RequestHeader,omitempty" xml:"RequestHeader,omitempty"`
	ResponseHeader            *int64   `json:"ResponseHeader,omitempty" xml:"ResponseHeader,omitempty"`
	SlowElementThreshold      *float64 `json:"SlowElementThreshold,omitempty" xml:"SlowElementThreshold,omitempty"`
	VerifyStringBlacklist     *string  `json:"VerifyStringBlacklist,omitempty" xml:"VerifyStringBlacklist,omitempty"`
	VerifyStringWhiteList     *string  `json:"VerifyStringWhiteList,omitempty" xml:"VerifyStringWhiteList,omitempty"`
	WaitCompletionTime        *float64 `json:"WaitCompletionTime,omitempty" xml:"WaitCompletionTime,omitempty"`
}

func (s CreateSyntheticTaskRequestNavigation) String() string {
	return tea.Prettify(s)
}

func (s CreateSyntheticTaskRequestNavigation) GoString() string {
	return s.String()
}

func (s *CreateSyntheticTaskRequestNavigation) SetDNSHijackWhiteList(v string) *CreateSyntheticTaskRequestNavigation {
	s.DNSHijackWhiteList = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetElementBlacklist(v string) *CreateSyntheticTaskRequestNavigation {
	s.ElementBlacklist = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetExecuteActiveX(v int64) *CreateSyntheticTaskRequestNavigation {
	s.ExecuteActiveX = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetExecuteApplication(v int64) *CreateSyntheticTaskRequestNavigation {
	s.ExecuteApplication = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetExecuteScript(v int64) *CreateSyntheticTaskRequestNavigation {
	s.ExecuteScript = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetFilterInvalidIP(v int64) *CreateSyntheticTaskRequestNavigation {
	s.FilterInvalidIP = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetFlowHijackJumpTimes(v int64) *CreateSyntheticTaskRequestNavigation {
	s.FlowHijackJumpTimes = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetFlowHijackLogo(v string) *CreateSyntheticTaskRequestNavigation {
	s.FlowHijackLogo = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetMonitorTimeout(v string) *CreateSyntheticTaskRequestNavigation {
	s.MonitorTimeout = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetNavAutomaticScrolling(v string) *CreateSyntheticTaskRequestNavigation {
	s.NavAutomaticScrolling = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetNavCustomHeader(v string) *CreateSyntheticTaskRequestNavigation {
	s.NavCustomHeader = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetNavCustomHeaderContent(v string) *CreateSyntheticTaskRequestNavigation {
	s.NavCustomHeaderContent = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetNavCustomHost(v int64) *CreateSyntheticTaskRequestNavigation {
	s.NavCustomHost = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetNavCustomHostIp(v string) *CreateSyntheticTaskRequestNavigation {
	s.NavCustomHostIp = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetNavDisableCache(v int64) *CreateSyntheticTaskRequestNavigation {
	s.NavDisableCache = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetNavDisableCompression(v string) *CreateSyntheticTaskRequestNavigation {
	s.NavDisableCompression = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetNavIgnoreCertificateError(v int64) *CreateSyntheticTaskRequestNavigation {
	s.NavIgnoreCertificateError = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetNavRedirection(v int64) *CreateSyntheticTaskRequestNavigation {
	s.NavRedirection = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetNavReturnElement(v int64) *CreateSyntheticTaskRequestNavigation {
	s.NavReturnElement = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetPageTamper(v string) *CreateSyntheticTaskRequestNavigation {
	s.PageTamper = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetProcessName(v string) *CreateSyntheticTaskRequestNavigation {
	s.ProcessName = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetQUICDomain(v string) *CreateSyntheticTaskRequestNavigation {
	s.QUICDomain = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetQUICVersion(v int64) *CreateSyntheticTaskRequestNavigation {
	s.QUICVersion = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetRequestHeader(v int64) *CreateSyntheticTaskRequestNavigation {
	s.RequestHeader = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetResponseHeader(v int64) *CreateSyntheticTaskRequestNavigation {
	s.ResponseHeader = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetSlowElementThreshold(v float64) *CreateSyntheticTaskRequestNavigation {
	s.SlowElementThreshold = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetVerifyStringBlacklist(v string) *CreateSyntheticTaskRequestNavigation {
	s.VerifyStringBlacklist = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetVerifyStringWhiteList(v string) *CreateSyntheticTaskRequestNavigation {
	s.VerifyStringWhiteList = &v
	return s
}

func (s *CreateSyntheticTaskRequestNavigation) SetWaitCompletionTime(v float64) *CreateSyntheticTaskRequestNavigation {
	s.WaitCompletionTime = &v
	return s
}

type CreateSyntheticTaskRequestNet struct {
	NetDNSNs             *string `json:"NetDNSNs,omitempty" xml:"NetDNSNs,omitempty"`
	NetDNSQueryMethod    *int64  `json:"NetDNSQueryMethod,omitempty" xml:"NetDNSQueryMethod,omitempty"`
	NetDNSServer         *int64  `json:"NetDNSServer,omitempty" xml:"NetDNSServer,omitempty"`
	NetDNSSwitch         *int64  `json:"NetDNSSwitch,omitempty" xml:"NetDNSSwitch,omitempty"`
	NetDNSTimeout        *int64  `json:"NetDNSTimeout,omitempty" xml:"NetDNSTimeout,omitempty"`
	NetDigSwitch         *int64  `json:"NetDigSwitch,omitempty" xml:"NetDigSwitch,omitempty"`
	NetICMPActive        *int64  `json:"NetICMPActive,omitempty" xml:"NetICMPActive,omitempty"`
	NetICMPDataCut       *int64  `json:"NetICMPDataCut,omitempty" xml:"NetICMPDataCut,omitempty"`
	NetICMPInterval      *int64  `json:"NetICMPInterval,omitempty" xml:"NetICMPInterval,omitempty"`
	NetICMPNum           *int64  `json:"NetICMPNum,omitempty" xml:"NetICMPNum,omitempty"`
	NetICMPSize          *int64  `json:"NetICMPSize,omitempty" xml:"NetICMPSize,omitempty"`
	NetICMPSwitch        *int64  `json:"NetICMPSwitch,omitempty" xml:"NetICMPSwitch,omitempty"`
	NetICMPTimeout       *int64  `json:"NetICMPTimeout,omitempty" xml:"NetICMPTimeout,omitempty"`
	NetTraceRouteNum     *int64  `json:"NetTraceRouteNum,omitempty" xml:"NetTraceRouteNum,omitempty"`
	NetTraceRouteSwitch  *int64  `json:"NetTraceRouteSwitch,omitempty" xml:"NetTraceRouteSwitch,omitempty"`
	NetTraceRouteTimeout *int64  `json:"NetTraceRouteTimeout,omitempty" xml:"NetTraceRouteTimeout,omitempty"`
	WhiteList            *string `json:"WhiteList,omitempty" xml:"WhiteList,omitempty"`
}

func (s CreateSyntheticTaskRequestNet) String() string {
	return tea.Prettify(s)
}

func (s CreateSyntheticTaskRequestNet) GoString() string {
	return s.String()
}

func (s *CreateSyntheticTaskRequestNet) SetNetDNSNs(v string) *CreateSyntheticTaskRequestNet {
	s.NetDNSNs = &v
	return s
}

func (s *CreateSyntheticTaskRequestNet) SetNetDNSQueryMethod(v int64) *CreateSyntheticTaskRequestNet {
	s.NetDNSQueryMethod = &v
	return s
}

func (s *CreateSyntheticTaskRequestNet) SetNetDNSServer(v int64) *CreateSyntheticTaskRequestNet {
	s.NetDNSServer = &v
	return s
}

func (s *CreateSyntheticTaskRequestNet) SetNetDNSSwitch(v int64) *CreateSyntheticTaskRequestNet {
	s.NetDNSSwitch = &v
	return s
}

func (s *CreateSyntheticTaskRequestNet) SetNetDNSTimeout(v int64) *CreateSyntheticTaskRequestNet {
	s.NetDNSTimeout = &v
	return s
}

func (s *CreateSyntheticTaskRequestNet) SetNetDigSwitch(v int64) *CreateSyntheticTaskRequestNet {
	s.NetDigSwitch = &v
	return s
}

func (s *CreateSyntheticTaskRequestNet) SetNetICMPActive(v int64) *CreateSyntheticTaskRequestNet {
	s.NetICMPActive = &v
	return s
}

func (s *CreateSyntheticTaskRequestNet) SetNetICMPDataCut(v int64) *CreateSyntheticTaskRequestNet {
	s.NetICMPDataCut = &v
	return s
}

func (s *CreateSyntheticTaskRequestNet) SetNetICMPInterval(v int64) *CreateSyntheticTaskRequestNet {
	s.NetICMPInterval = &v
	return s
}

func (s *CreateSyntheticTaskRequestNet) SetNetICMPNum(v int64) *CreateSyntheticTaskRequestNet {
	s.NetICMPNum = &v
	return s
}

func (s *CreateSyntheticTaskRequestNet) SetNetICMPSize(v int64) *CreateSyntheticTaskRequestNet {
	s.NetICMPSize = &v
	return s
}

func (s *CreateSyntheticTaskRequestNet) SetNetICMPSwitch(v int64) *CreateSyntheticTaskRequestNet {
	s.NetICMPSwitch = &v
	return s
}

func (s *CreateSyntheticTaskRequestNet) SetNetICMPTimeout(v int64) *CreateSyntheticTaskRequestNet {
	s.NetICMPTimeout = &v
	return s
}

func (s *CreateSyntheticTaskRequestNet) SetNetTraceRouteNum(v int64) *CreateSyntheticTaskRequestNet {
	s.NetTraceRouteNum = &v
	return s
}

func (s *CreateSyntheticTaskRequestNet) SetNetTraceRouteSwitch(v int64) *CreateSyntheticTaskRequestNet {
	s.NetTraceRouteSwitch = &v
	return s
}

func (s *CreateSyntheticTaskRequestNet) SetNetTraceRouteTimeout(v int64) *CreateSyntheticTaskRequestNet {
	s.NetTraceRouteTimeout = &v
	return s
}

func (s *CreateSyntheticTaskRequestNet) SetWhiteList(v string) *CreateSyntheticTaskRequestNet {
	s.WhiteList = &v
	return s
}

type CreateSyntheticTaskRequestProtocol struct {
	CharacterEncoding      *int64                                            `json:"CharacterEncoding,omitempty" xml:"CharacterEncoding,omitempty"`
	CustomHost             *int64                                            `json:"CustomHost,omitempty" xml:"CustomHost,omitempty"`
	CustomHostIp           *string                                           `json:"CustomHostIp,omitempty" xml:"CustomHostIp,omitempty"`
	ProtocolConnectionTime *int64                                            `json:"ProtocolConnectionTime,omitempty" xml:"ProtocolConnectionTime,omitempty"`
	ProtocolMonitorTimeout *string                                           `json:"ProtocolMonitorTimeout,omitempty" xml:"ProtocolMonitorTimeout,omitempty"`
	ReceivedDataSize       *int64                                            `json:"ReceivedDataSize,omitempty" xml:"ReceivedDataSize,omitempty"`
	RequestContent         *CreateSyntheticTaskRequestProtocolRequestContent `json:"RequestContent,omitempty" xml:"RequestContent,omitempty" type:"Struct"`
	VerifyContent          *string                                           `json:"VerifyContent,omitempty" xml:"VerifyContent,omitempty"`
	VerifyWay              *int64                                            `json:"VerifyWay,omitempty" xml:"VerifyWay,omitempty"`
}

func (s CreateSyntheticTaskRequestProtocol) String() string {
	return tea.Prettify(s)
}

func (s CreateSyntheticTaskRequestProtocol) GoString() string {
	return s.String()
}

func (s *CreateSyntheticTaskRequestProtocol) SetCharacterEncoding(v int64) *CreateSyntheticTaskRequestProtocol {
	s.CharacterEncoding = &v
	return s
}

func (s *CreateSyntheticTaskRequestProtocol) SetCustomHost(v int64) *CreateSyntheticTaskRequestProtocol {
	s.CustomHost = &v
	return s
}

func (s *CreateSyntheticTaskRequestProtocol) SetCustomHostIp(v string) *CreateSyntheticTaskRequestProtocol {
	s.CustomHostIp = &v
	return s
}

func (s *CreateSyntheticTaskRequestProtocol) SetProtocolConnectionTime(v int64) *CreateSyntheticTaskRequestProtocol {
	s.ProtocolConnectionTime = &v
	return s
}

func (s *CreateSyntheticTaskRequestProtocol) SetProtocolMonitorTimeout(v string) *CreateSyntheticTaskRequestProtocol {
	s.ProtocolMonitorTimeout = &v
	return s
}

func (s *CreateSyntheticTaskRequestProtocol) SetReceivedDataSize(v int64) *CreateSyntheticTaskRequestProtocol {
	s.ReceivedDataSize = &v
	return s
}

func (s *CreateSyntheticTaskRequestProtocol) SetRequestContent(v *CreateSyntheticTaskRequestProtocolRequestContent) *CreateSyntheticTaskRequestProtocol {
	s.RequestContent = v
	return s
}

func (s *CreateSyntheticTaskRequestProtocol) SetVerifyContent(v string) *CreateSyntheticTaskRequestProtocol {
	s.VerifyContent = &v
	return s
}

func (s *CreateSyntheticTaskRequestProtocol) SetVerifyWay(v int64) *CreateSyntheticTaskRequestProtocol {
	s.VerifyWay = &v
	return s
}

type CreateSyntheticTaskRequestProtocolRequestContent struct {
	Body   *CreateSyntheticTaskRequestProtocolRequestContentBody     `json:"Body,omitempty" xml:"Body,omitempty" type:"Struct"`
	Header []*CreateSyntheticTaskRequestProtocolRequestContentHeader `json:"Header,omitempty" xml:"Header,omitempty" type:"Repeated"`
	Method *string                                                   `json:"Method,omitempty" xml:"Method,omitempty"`
}

func (s CreateSyntheticTaskRequestProtocolRequestContent) String() string {
	return tea.Prettify(s)
}

func (s CreateSyntheticTaskRequestProtocolRequestContent) GoString() string {
	return s.String()
}

func (s *CreateSyntheticTaskRequestProtocolRequestContent) SetBody(v *CreateSyntheticTaskRequestProtocolRequestContentBody) *CreateSyntheticTaskRequestProtocolRequestContent {
	s.Body = v
	return s
}

func (s *CreateSyntheticTaskRequestProtocolRequestContent) SetHeader(v []*CreateSyntheticTaskRequestProtocolRequestContentHeader) *CreateSyntheticTaskRequestProtocolRequestContent {
	s.Header = v
	return s
}

func (s *CreateSyntheticTaskRequestProtocolRequestContent) SetMethod(v string) *CreateSyntheticTaskRequestProtocolRequestContent {
	s.Method = &v
	return s
}

type CreateSyntheticTaskRequestProtocolRequestContentBody struct {
	FormData    []*CreateSyntheticTaskRequestProtocolRequestContentBodyFormData    `json:"FormData,omitempty" xml:"FormData,omitempty" type:"Repeated"`
	Language    *string                                                            `json:"Language,omitempty" xml:"Language,omitempty"`
	Mode        *string                                                            `json:"Mode,omitempty" xml:"Mode,omitempty"`
	Raw         *string                                                            `json:"Raw,omitempty" xml:"Raw,omitempty"`
	UrlEncoding []*CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding `json:"UrlEncoding,omitempty" xml:"UrlEncoding,omitempty" type:"Repeated"`
}

func (s CreateSyntheticTaskRequestProtocolRequestContentBody) String() string {
	return tea.Prettify(s)
}

func (s CreateSyntheticTaskRequestProtocolRequestContentBody) GoString() string {
	return s.String()
}

func (s *CreateSyntheticTaskRequestProtocolRequestContentBody) SetFormData(v []*CreateSyntheticTaskRequestProtocolRequestContentBodyFormData) *CreateSyntheticTaskRequestProtocolRequestContentBody {
	s.FormData = v
	return s
}

func (s *CreateSyntheticTaskRequestProtocolRequestContentBody) SetLanguage(v string) *CreateSyntheticTaskRequestProtocolRequestContentBody {
	s.Language = &v
	return s
}

func (s *CreateSyntheticTaskRequestProtocolRequestContentBody) SetMode(v string) *CreateSyntheticTaskRequestProtocolRequestContentBody {
	s.Mode = &v
	return s
}

func (s *CreateSyntheticTaskRequestProtocolRequestContentBody) SetRaw(v string) *CreateSyntheticTaskRequestProtocolRequestContentBody {
	s.Raw = &v
	return s
}

func (s *CreateSyntheticTaskRequestProtocolRequestContentBody) SetUrlEncoding(v []*CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding) *CreateSyntheticTaskRequestProtocolRequestContentBody {
	s.UrlEncoding = v
	return s
}

type CreateSyntheticTaskRequestProtocolRequestContentBodyFormData struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateSyntheticTaskRequestProtocolRequestContentBodyFormData) String() string {
	return tea.Prettify(s)
}

func (s CreateSyntheticTaskRequestProtocolRequestContentBodyFormData) GoString() string {
	return s.String()
}

func (s *CreateSyntheticTaskRequestProtocolRequestContentBodyFormData) SetKey(v string) *CreateSyntheticTaskRequestProtocolRequestContentBodyFormData {
	s.Key = &v
	return s
}

func (s *CreateSyntheticTaskRequestProtocolRequestContentBodyFormData) SetValue(v string) *CreateSyntheticTaskRequestProtocolRequestContentBodyFormData {
	s.Value = &v
	return s
}

type CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding) String() string {
	return tea.Prettify(s)
}

func (s CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding) GoString() string {
	return s.String()
}

func (s *CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding) SetKey(v string) *CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding {
	s.Key = &v
	return s
}

func (s *CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding) SetValue(v string) *CreateSyntheticTaskRequestProtocolRequestContentBodyUrlEncoding {
	s.Value = &v
	return s
}

type CreateSyntheticTaskRequestProtocolRequestContentHeader struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateSyntheticTaskRequestProtocolRequestContentHeader) String() string {
	return tea.Prettify(s)
}

func (s CreateSyntheticTaskRequestProtocolRequestContentHeader) GoString() string {
	return s.String()
}

func (s *CreateSyntheticTaskRequestProtocolRequestContentHeader) SetKey(v string) *CreateSyntheticTaskRequestProtocolRequestContentHeader {
	s.Key = &v
	return s
}

func (s *CreateSyntheticTaskRequestProtocolRequestContentHeader) SetValue(v string) *CreateSyntheticTaskRequestProtocolRequestContentHeader {
	s.Value = &v
	return s
}

type CreateSyntheticTaskShrinkRequest struct {
	CommonParamShrink    *string `json:"CommonParam,omitempty" xml:"CommonParam,omitempty"`
	DownloadShrink       *string `json:"Download,omitempty" xml:"Download,omitempty"`
	ExtendIntervalShrink *string `json:"ExtendInterval,omitempty" xml:"ExtendInterval,omitempty"`
	IntervalTime         *string `json:"IntervalTime,omitempty" xml:"IntervalTime,omitempty"`
	IntervalType         *string `json:"IntervalType,omitempty" xml:"IntervalType,omitempty"`
	IpType               *int64  `json:"IpType,omitempty" xml:"IpType,omitempty"`
	MonitorListShrink    *string `json:"MonitorList,omitempty" xml:"MonitorList,omitempty"`
	NavigationShrink     *string `json:"Navigation,omitempty" xml:"Navigation,omitempty"`
	NetShrink            *string `json:"Net,omitempty" xml:"Net,omitempty"`
	ProtocolShrink       *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	TaskName             *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
	TaskType             *int64  `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
	UpdateTask           *bool   `json:"UpdateTask,omitempty" xml:"UpdateTask,omitempty"`
	Url                  *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s CreateSyntheticTaskShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSyntheticTaskShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateSyntheticTaskShrinkRequest) SetCommonParamShrink(v string) *CreateSyntheticTaskShrinkRequest {
	s.CommonParamShrink = &v
	return s
}

func (s *CreateSyntheticTaskShrinkRequest) SetDownloadShrink(v string) *CreateSyntheticTaskShrinkRequest {
	s.DownloadShrink = &v
	return s
}

func (s *CreateSyntheticTaskShrinkRequest) SetExtendIntervalShrink(v string) *CreateSyntheticTaskShrinkRequest {
	s.ExtendIntervalShrink = &v
	return s
}

func (s *CreateSyntheticTaskShrinkRequest) SetIntervalTime(v string) *CreateSyntheticTaskShrinkRequest {
	s.IntervalTime = &v
	return s
}

func (s *CreateSyntheticTaskShrinkRequest) SetIntervalType(v string) *CreateSyntheticTaskShrinkRequest {
	s.IntervalType = &v
	return s
}

func (s *CreateSyntheticTaskShrinkRequest) SetIpType(v int64) *CreateSyntheticTaskShrinkRequest {
	s.IpType = &v
	return s
}

func (s *CreateSyntheticTaskShrinkRequest) SetMonitorListShrink(v string) *CreateSyntheticTaskShrinkRequest {
	s.MonitorListShrink = &v
	return s
}

func (s *CreateSyntheticTaskShrinkRequest) SetNavigationShrink(v string) *CreateSyntheticTaskShrinkRequest {
	s.NavigationShrink = &v
	return s
}

func (s *CreateSyntheticTaskShrinkRequest) SetNetShrink(v string) *CreateSyntheticTaskShrinkRequest {
	s.NetShrink = &v
	return s
}

func (s *CreateSyntheticTaskShrinkRequest) SetProtocolShrink(v string) *CreateSyntheticTaskShrinkRequest {
	s.ProtocolShrink = &v
	return s
}

func (s *CreateSyntheticTaskShrinkRequest) SetRegionId(v string) *CreateSyntheticTaskShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *CreateSyntheticTaskShrinkRequest) SetTaskName(v string) *CreateSyntheticTaskShrinkRequest {
	s.TaskName = &v
	return s
}

func (s *CreateSyntheticTaskShrinkRequest) SetTaskType(v int64) *CreateSyntheticTaskShrinkRequest {
	s.TaskType = &v
	return s
}

func (s *CreateSyntheticTaskShrinkRequest) SetUpdateTask(v bool) *CreateSyntheticTaskShrinkRequest {
	s.UpdateTask = &v
	return s
}

func (s *CreateSyntheticTaskShrinkRequest) SetUrl(v string) *CreateSyntheticTaskShrinkRequest {
	s.Url = &v
	return s
}

type CreateSyntheticTaskResponseBody struct {
	Code      *string                              `json:"Code,omitempty" xml:"Code,omitempty"`
	Data      *CreateSyntheticTaskResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	Msg       *string                              `json:"Msg,omitempty" xml:"Msg,omitempty"`
	RequestId *string                              `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateSyntheticTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateSyntheticTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CreateSyntheticTaskResponseBody) SetCode(v string) *CreateSyntheticTaskResponseBody {
	s.Code = &v
	return s
}

func (s *CreateSyntheticTaskResponseBody) SetData(v *CreateSyntheticTaskResponseBodyData) *CreateSyntheticTaskResponseBody {
	s.Data = v
	return s
}

func (s *CreateSyntheticTaskResponseBody) SetMsg(v string) *CreateSyntheticTaskResponseBody {
	s.Msg = &v
	return s
}

func (s *CreateSyntheticTaskResponseBody) SetRequestId(v string) *CreateSyntheticTaskResponseBody {
	s.RequestId = &v
	return s
}

type CreateSyntheticTaskResponseBodyData struct {
	TaskId *int64 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s CreateSyntheticTaskResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateSyntheticTaskResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateSyntheticTaskResponseBodyData) SetTaskId(v int64) *CreateSyntheticTaskResponseBodyData {
	s.TaskId = &v
	return s
}

type CreateSyntheticTaskResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateSyntheticTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateSyntheticTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSyntheticTaskResponse) GoString() string {
	return s.String()
}

func (s *CreateSyntheticTaskResponse) SetHeaders(v map[string]*string) *CreateSyntheticTaskResponse {
	s.Headers = v
	return s
}

func (s *CreateSyntheticTaskResponse) SetStatusCode(v int32) *CreateSyntheticTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateSyntheticTaskResponse) SetBody(v *CreateSyntheticTaskResponseBody) *CreateSyntheticTaskResponse {
	s.Body = v
	return s
}

type CreateTimingSyntheticTaskRequest struct {
	AvailableAssertions []*CreateTimingSyntheticTaskRequestAvailableAssertions `json:"AvailableAssertions,omitempty" xml:"AvailableAssertions,omitempty" type:"Repeated"`
	CommonSetting       *CreateTimingSyntheticTaskRequestCommonSetting         `json:"CommonSetting,omitempty" xml:"CommonSetting,omitempty" type:"Struct"`
	CustomPeriod        *CreateTimingSyntheticTaskRequestCustomPeriod          `json:"CustomPeriod,omitempty" xml:"CustomPeriod,omitempty" type:"Struct"`
	Frequency           *string                                                `json:"Frequency,omitempty" xml:"Frequency,omitempty"`
	MonitorCategory     *int32                                                 `json:"MonitorCategory,omitempty" xml:"MonitorCategory,omitempty"`
	MonitorConf         *CreateTimingSyntheticTaskRequestMonitorConf           `json:"MonitorConf,omitempty" xml:"MonitorConf,omitempty" type:"Struct"`
	Monitors            []*CreateTimingSyntheticTaskRequestMonitors            `json:"Monitors,omitempty" xml:"Monitors,omitempty" type:"Repeated"`
	Name                *string                                                `json:"Name,omitempty" xml:"Name,omitempty"`
	RegionId            *string                                                `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId     *string                                                `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	Tags                []*CreateTimingSyntheticTaskRequestTags                `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	TaskType            *int32                                                 `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s CreateTimingSyntheticTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTimingSyntheticTaskRequest) GoString() string {
	return s.String()
}

func (s *CreateTimingSyntheticTaskRequest) SetAvailableAssertions(v []*CreateTimingSyntheticTaskRequestAvailableAssertions) *CreateTimingSyntheticTaskRequest {
	s.AvailableAssertions = v
	return s
}

func (s *CreateTimingSyntheticTaskRequest) SetCommonSetting(v *CreateTimingSyntheticTaskRequestCommonSetting) *CreateTimingSyntheticTaskRequest {
	s.CommonSetting = v
	return s
}

func (s *CreateTimingSyntheticTaskRequest) SetCustomPeriod(v *CreateTimingSyntheticTaskRequestCustomPeriod) *CreateTimingSyntheticTaskRequest {
	s.CustomPeriod = v
	return s
}

func (s *CreateTimingSyntheticTaskRequest) SetFrequency(v string) *CreateTimingSyntheticTaskRequest {
	s.Frequency = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequest) SetMonitorCategory(v int32) *CreateTimingSyntheticTaskRequest {
	s.MonitorCategory = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequest) SetMonitorConf(v *CreateTimingSyntheticTaskRequestMonitorConf) *CreateTimingSyntheticTaskRequest {
	s.MonitorConf = v
	return s
}

func (s *CreateTimingSyntheticTaskRequest) SetMonitors(v []*CreateTimingSyntheticTaskRequestMonitors) *CreateTimingSyntheticTaskRequest {
	s.Monitors = v
	return s
}

func (s *CreateTimingSyntheticTaskRequest) SetName(v string) *CreateTimingSyntheticTaskRequest {
	s.Name = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequest) SetRegionId(v string) *CreateTimingSyntheticTaskRequest {
	s.RegionId = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequest) SetResourceGroupId(v string) *CreateTimingSyntheticTaskRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequest) SetTags(v []*CreateTimingSyntheticTaskRequestTags) *CreateTimingSyntheticTaskRequest {
	s.Tags = v
	return s
}

func (s *CreateTimingSyntheticTaskRequest) SetTaskType(v int32) *CreateTimingSyntheticTaskRequest {
	s.TaskType = &v
	return s
}

type CreateTimingSyntheticTaskRequestAvailableAssertions struct {
	Expect   *string `json:"Expect,omitempty" xml:"Expect,omitempty"`
	Operator *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
	Target   *string `json:"Target,omitempty" xml:"Target,omitempty"`
	Type     *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateTimingSyntheticTaskRequestAvailableAssertions) String() string {
	return tea.Prettify(s)
}

func (s CreateTimingSyntheticTaskRequestAvailableAssertions) GoString() string {
	return s.String()
}

func (s *CreateTimingSyntheticTaskRequestAvailableAssertions) SetExpect(v string) *CreateTimingSyntheticTaskRequestAvailableAssertions {
	s.Expect = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestAvailableAssertions) SetOperator(v string) *CreateTimingSyntheticTaskRequestAvailableAssertions {
	s.Operator = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestAvailableAssertions) SetTarget(v string) *CreateTimingSyntheticTaskRequestAvailableAssertions {
	s.Target = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestAvailableAssertions) SetType(v string) *CreateTimingSyntheticTaskRequestAvailableAssertions {
	s.Type = &v
	return s
}

type CreateTimingSyntheticTaskRequestCommonSetting struct {
	CustomHost      *CreateTimingSyntheticTaskRequestCommonSettingCustomHost `json:"CustomHost,omitempty" xml:"CustomHost,omitempty" type:"Struct"`
	IpType          *int32                                                   `json:"IpType,omitempty" xml:"IpType,omitempty"`
	IsOpenTrace     *bool                                                    `json:"IsOpenTrace,omitempty" xml:"IsOpenTrace,omitempty"`
	MonitorSamples  *int32                                                   `json:"MonitorSamples,omitempty" xml:"MonitorSamples,omitempty"`
	TraceClientType *int32                                                   `json:"TraceClientType,omitempty" xml:"TraceClientType,omitempty"`
	XtraceRegion    *string                                                  `json:"XtraceRegion,omitempty" xml:"XtraceRegion,omitempty"`
}

func (s CreateTimingSyntheticTaskRequestCommonSetting) String() string {
	return tea.Prettify(s)
}

func (s CreateTimingSyntheticTaskRequestCommonSetting) GoString() string {
	return s.String()
}

func (s *CreateTimingSyntheticTaskRequestCommonSetting) SetCustomHost(v *CreateTimingSyntheticTaskRequestCommonSettingCustomHost) *CreateTimingSyntheticTaskRequestCommonSetting {
	s.CustomHost = v
	return s
}

func (s *CreateTimingSyntheticTaskRequestCommonSetting) SetIpType(v int32) *CreateTimingSyntheticTaskRequestCommonSetting {
	s.IpType = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestCommonSetting) SetIsOpenTrace(v bool) *CreateTimingSyntheticTaskRequestCommonSetting {
	s.IsOpenTrace = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestCommonSetting) SetMonitorSamples(v int32) *CreateTimingSyntheticTaskRequestCommonSetting {
	s.MonitorSamples = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestCommonSetting) SetTraceClientType(v int32) *CreateTimingSyntheticTaskRequestCommonSetting {
	s.TraceClientType = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestCommonSetting) SetXtraceRegion(v string) *CreateTimingSyntheticTaskRequestCommonSetting {
	s.XtraceRegion = &v
	return s
}

type CreateTimingSyntheticTaskRequestCommonSettingCustomHost struct {
	Hosts      []*CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts `json:"Hosts,omitempty" xml:"Hosts,omitempty" type:"Repeated"`
	SelectType *int32                                                          `json:"SelectType,omitempty" xml:"SelectType,omitempty"`
}

func (s CreateTimingSyntheticTaskRequestCommonSettingCustomHost) String() string {
	return tea.Prettify(s)
}

func (s CreateTimingSyntheticTaskRequestCommonSettingCustomHost) GoString() string {
	return s.String()
}

func (s *CreateTimingSyntheticTaskRequestCommonSettingCustomHost) SetHosts(v []*CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts) *CreateTimingSyntheticTaskRequestCommonSettingCustomHost {
	s.Hosts = v
	return s
}

func (s *CreateTimingSyntheticTaskRequestCommonSettingCustomHost) SetSelectType(v int32) *CreateTimingSyntheticTaskRequestCommonSettingCustomHost {
	s.SelectType = &v
	return s
}

type CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts struct {
	Domain *string   `json:"Domain,omitempty" xml:"Domain,omitempty"`
	IpType *int32    `json:"IpType,omitempty" xml:"IpType,omitempty"`
	Ips    []*string `json:"Ips,omitempty" xml:"Ips,omitempty" type:"Repeated"`
}

func (s CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts) String() string {
	return tea.Prettify(s)
}

func (s CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts) GoString() string {
	return s.String()
}

func (s *CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts) SetDomain(v string) *CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts {
	s.Domain = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts) SetIpType(v int32) *CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts {
	s.IpType = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts) SetIps(v []*string) *CreateTimingSyntheticTaskRequestCommonSettingCustomHostHosts {
	s.Ips = v
	return s
}

type CreateTimingSyntheticTaskRequestCustomPeriod struct {
	EndHour   *int32 `json:"EndHour,omitempty" xml:"EndHour,omitempty"`
	StartHour *int32 `json:"StartHour,omitempty" xml:"StartHour,omitempty"`
}

func (s CreateTimingSyntheticTaskRequestCustomPeriod) String() string {
	return tea.Prettify(s)
}

func (s CreateTimingSyntheticTaskRequestCustomPeriod) GoString() string {
	return s.String()
}

func (s *CreateTimingSyntheticTaskRequestCustomPeriod) SetEndHour(v int32) *CreateTimingSyntheticTaskRequestCustomPeriod {
	s.EndHour = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestCustomPeriod) SetStartHour(v int32) *CreateTimingSyntheticTaskRequestCustomPeriod {
	s.StartHour = &v
	return s
}

type CreateTimingSyntheticTaskRequestMonitorConf struct {
	ApiHTTP      *CreateTimingSyntheticTaskRequestMonitorConfApiHTTP      `json:"ApiHTTP,omitempty" xml:"ApiHTTP,omitempty" type:"Struct"`
	FileDownload *CreateTimingSyntheticTaskRequestMonitorConfFileDownload `json:"FileDownload,omitempty" xml:"FileDownload,omitempty" type:"Struct"`
	NetDNS       *CreateTimingSyntheticTaskRequestMonitorConfNetDNS       `json:"NetDNS,omitempty" xml:"NetDNS,omitempty" type:"Struct"`
	NetICMP      *CreateTimingSyntheticTaskRequestMonitorConfNetICMP      `json:"NetICMP,omitempty" xml:"NetICMP,omitempty" type:"Struct"`
	NetTCP       *CreateTimingSyntheticTaskRequestMonitorConfNetTCP       `json:"NetTCP,omitempty" xml:"NetTCP,omitempty" type:"Struct"`
	Stream       *CreateTimingSyntheticTaskRequestMonitorConfStream       `json:"Stream,omitempty" xml:"Stream,omitempty" type:"Struct"`
	Website      *CreateTimingSyntheticTaskRequestMonitorConfWebsite      `json:"Website,omitempty" xml:"Website,omitempty" type:"Struct"`
}

func (s CreateTimingSyntheticTaskRequestMonitorConf) String() string {
	return tea.Prettify(s)
}

func (s CreateTimingSyntheticTaskRequestMonitorConf) GoString() string {
	return s.String()
}

func (s *CreateTimingSyntheticTaskRequestMonitorConf) SetApiHTTP(v *CreateTimingSyntheticTaskRequestMonitorConfApiHTTP) *CreateTimingSyntheticTaskRequestMonitorConf {
	s.ApiHTTP = v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConf) SetFileDownload(v *CreateTimingSyntheticTaskRequestMonitorConfFileDownload) *CreateTimingSyntheticTaskRequestMonitorConf {
	s.FileDownload = v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConf) SetNetDNS(v *CreateTimingSyntheticTaskRequestMonitorConfNetDNS) *CreateTimingSyntheticTaskRequestMonitorConf {
	s.NetDNS = v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConf) SetNetICMP(v *CreateTimingSyntheticTaskRequestMonitorConfNetICMP) *CreateTimingSyntheticTaskRequestMonitorConf {
	s.NetICMP = v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConf) SetNetTCP(v *CreateTimingSyntheticTaskRequestMonitorConfNetTCP) *CreateTimingSyntheticTaskRequestMonitorConf {
	s.NetTCP = v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConf) SetStream(v *CreateTimingSyntheticTaskRequestMonitorConfStream) *CreateTimingSyntheticTaskRequestMonitorConf {
	s.Stream = v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConf) SetWebsite(v *CreateTimingSyntheticTaskRequestMonitorConfWebsite) *CreateTimingSyntheticTaskRequestMonitorConf {
	s.Website = v
	return s
}

type CreateTimingSyntheticTaskRequestMonitorConfApiHTTP struct {
	ConnectTimeout *int64                                                         `json:"ConnectTimeout,omitempty" xml:"ConnectTimeout,omitempty"`
	Method         *string                                                        `json:"Method,omitempty" xml:"Method,omitempty"`
	RequestBody    *CreateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody `json:"RequestBody,omitempty" xml:"RequestBody,omitempty" type:"Struct"`
	RequestHeaders map[string]*string                                             `json:"RequestHeaders,omitempty" xml:"RequestHeaders,omitempty"`
	TargetUrl      *string                                                        `json:"TargetUrl,omitempty" xml:"TargetUrl,omitempty"`
	Timeout        *int64                                                         `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
}

func (s CreateTimingSyntheticTaskRequestMonitorConfApiHTTP) String() string {
	return tea.Prettify(s)
}

func (s CreateTimingSyntheticTaskRequestMonitorConfApiHTTP) GoString() string {
	return s.String()
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfApiHTTP) SetConnectTimeout(v int64) *CreateTimingSyntheticTaskRequestMonitorConfApiHTTP {
	s.ConnectTimeout = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfApiHTTP) SetMethod(v string) *CreateTimingSyntheticTaskRequestMonitorConfApiHTTP {
	s.Method = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfApiHTTP) SetRequestBody(v *CreateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody) *CreateTimingSyntheticTaskRequestMonitorConfApiHTTP {
	s.RequestBody = v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfApiHTTP) SetRequestHeaders(v map[string]*string) *CreateTimingSyntheticTaskRequestMonitorConfApiHTTP {
	s.RequestHeaders = v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfApiHTTP) SetTargetUrl(v string) *CreateTimingSyntheticTaskRequestMonitorConfApiHTTP {
	s.TargetUrl = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfApiHTTP) SetTimeout(v int64) *CreateTimingSyntheticTaskRequestMonitorConfApiHTTP {
	s.Timeout = &v
	return s
}

type CreateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody struct {
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	Type    *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody) GoString() string {
	return s.String()
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody) SetContent(v string) *CreateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody {
	s.Content = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody) SetType(v string) *CreateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody {
	s.Type = &v
	return s
}

type CreateTimingSyntheticTaskRequestMonitorConfFileDownload struct {
	ConnectionTimeout                   *int64             `json:"ConnectionTimeout,omitempty" xml:"ConnectionTimeout,omitempty"`
	CustomHeaderContent                 map[string]*string `json:"CustomHeaderContent,omitempty" xml:"CustomHeaderContent,omitempty"`
	DownloadKernel                      *int32             `json:"DownloadKernel,omitempty" xml:"DownloadKernel,omitempty"`
	IgnoreCertificateAuthError          *int32             `json:"IgnoreCertificateAuthError,omitempty" xml:"IgnoreCertificateAuthError,omitempty"`
	IgnoreCertificateCanceledError      *int32             `json:"IgnoreCertificateCanceledError,omitempty" xml:"IgnoreCertificateCanceledError,omitempty"`
	IgnoreCertificateOutOfDateError     *int32             `json:"IgnoreCertificateOutOfDateError,omitempty" xml:"IgnoreCertificateOutOfDateError,omitempty"`
	IgnoreCertificateStatusError        *int32             `json:"IgnoreCertificateStatusError,omitempty" xml:"IgnoreCertificateStatusError,omitempty"`
	IgnoreCertificateUntrustworthyError *int32             `json:"IgnoreCertificateUntrustworthyError,omitempty" xml:"IgnoreCertificateUntrustworthyError,omitempty"`
	IgnoreCertificateUsingError         *int32             `json:"IgnoreCertificateUsingError,omitempty" xml:"IgnoreCertificateUsingError,omitempty"`
	IgnoreInvalidHostError              *int32             `json:"IgnoreInvalidHostError,omitempty" xml:"IgnoreInvalidHostError,omitempty"`
	MonitorTimeout                      *int64             `json:"MonitorTimeout,omitempty" xml:"MonitorTimeout,omitempty"`
	QuickProtocol                       *int32             `json:"QuickProtocol,omitempty" xml:"QuickProtocol,omitempty"`
	Redirection                         *int32             `json:"Redirection,omitempty" xml:"Redirection,omitempty"`
	TargetUrl                           *string            `json:"TargetUrl,omitempty" xml:"TargetUrl,omitempty"`
	TransmissionSize                    *int64             `json:"TransmissionSize,omitempty" xml:"TransmissionSize,omitempty"`
	ValidateKeywords                    *string            `json:"ValidateKeywords,omitempty" xml:"ValidateKeywords,omitempty"`
	VerifyWay                           *int32             `json:"VerifyWay,omitempty" xml:"VerifyWay,omitempty"`
	WhiteList                           *string            `json:"WhiteList,omitempty" xml:"WhiteList,omitempty"`
}

func (s CreateTimingSyntheticTaskRequestMonitorConfFileDownload) String() string {
	return tea.Prettify(s)
}

func (s CreateTimingSyntheticTaskRequestMonitorConfFileDownload) GoString() string {
	return s.String()
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfFileDownload) SetConnectionTimeout(v int64) *CreateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.ConnectionTimeout = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfFileDownload) SetCustomHeaderContent(v map[string]*string) *CreateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.CustomHeaderContent = v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfFileDownload) SetDownloadKernel(v int32) *CreateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.DownloadKernel = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfFileDownload) SetIgnoreCertificateAuthError(v int32) *CreateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.IgnoreCertificateAuthError = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfFileDownload) SetIgnoreCertificateCanceledError(v int32) *CreateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.IgnoreCertificateCanceledError = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfFileDownload) SetIgnoreCertificateOutOfDateError(v int32) *CreateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.IgnoreCertificateOutOfDateError = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfFileDownload) SetIgnoreCertificateStatusError(v int32) *CreateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.IgnoreCertificateStatusError = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfFileDownload) SetIgnoreCertificateUntrustworthyError(v int32) *CreateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.IgnoreCertificateUntrustworthyError = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfFileDownload) SetIgnoreCertificateUsingError(v int32) *CreateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.IgnoreCertificateUsingError = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfFileDownload) SetIgnoreInvalidHostError(v int32) *CreateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.IgnoreInvalidHostError = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfFileDownload) SetMonitorTimeout(v int64) *CreateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.MonitorTimeout = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfFileDownload) SetQuickProtocol(v int32) *CreateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.QuickProtocol = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfFileDownload) SetRedirection(v int32) *CreateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.Redirection = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfFileDownload) SetTargetUrl(v string) *CreateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.TargetUrl = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfFileDownload) SetTransmissionSize(v int64) *CreateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.TransmissionSize = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfFileDownload) SetValidateKeywords(v string) *CreateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.ValidateKeywords = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfFileDownload) SetVerifyWay(v int32) *CreateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.VerifyWay = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfFileDownload) SetWhiteList(v string) *CreateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.WhiteList = &v
	return s
}

type CreateTimingSyntheticTaskRequestMonitorConfNetDNS struct {
	DnsServerIpType *int32  `json:"DnsServerIpType,omitempty" xml:"DnsServerIpType,omitempty"`
	NsServer        *string `json:"NsServer,omitempty" xml:"NsServer,omitempty"`
	QueryMethod     *int32  `json:"QueryMethod,omitempty" xml:"QueryMethod,omitempty"`
	TargetUrl       *string `json:"TargetUrl,omitempty" xml:"TargetUrl,omitempty"`
	Timeout         *int64  `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
}

func (s CreateTimingSyntheticTaskRequestMonitorConfNetDNS) String() string {
	return tea.Prettify(s)
}

func (s CreateTimingSyntheticTaskRequestMonitorConfNetDNS) GoString() string {
	return s.String()
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfNetDNS) SetDnsServerIpType(v int32) *CreateTimingSyntheticTaskRequestMonitorConfNetDNS {
	s.DnsServerIpType = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfNetDNS) SetNsServer(v string) *CreateTimingSyntheticTaskRequestMonitorConfNetDNS {
	s.NsServer = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfNetDNS) SetQueryMethod(v int32) *CreateTimingSyntheticTaskRequestMonitorConfNetDNS {
	s.QueryMethod = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfNetDNS) SetTargetUrl(v string) *CreateTimingSyntheticTaskRequestMonitorConfNetDNS {
	s.TargetUrl = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfNetDNS) SetTimeout(v int64) *CreateTimingSyntheticTaskRequestMonitorConfNetDNS {
	s.Timeout = &v
	return s
}

type CreateTimingSyntheticTaskRequestMonitorConfNetICMP struct {
	Interval       *int64  `json:"Interval,omitempty" xml:"Interval,omitempty"`
	PackageNum     *int32  `json:"PackageNum,omitempty" xml:"PackageNum,omitempty"`
	PackageSize    *int32  `json:"PackageSize,omitempty" xml:"PackageSize,omitempty"`
	SplitPackage   *bool   `json:"SplitPackage,omitempty" xml:"SplitPackage,omitempty"`
	TargetUrl      *string `json:"TargetUrl,omitempty" xml:"TargetUrl,omitempty"`
	Timeout        *int64  `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	TracertEnable  *bool   `json:"TracertEnable,omitempty" xml:"TracertEnable,omitempty"`
	TracertNumMax  *int32  `json:"TracertNumMax,omitempty" xml:"TracertNumMax,omitempty"`
	TracertTimeout *int64  `json:"TracertTimeout,omitempty" xml:"TracertTimeout,omitempty"`
}

func (s CreateTimingSyntheticTaskRequestMonitorConfNetICMP) String() string {
	return tea.Prettify(s)
}

func (s CreateTimingSyntheticTaskRequestMonitorConfNetICMP) GoString() string {
	return s.String()
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfNetICMP) SetInterval(v int64) *CreateTimingSyntheticTaskRequestMonitorConfNetICMP {
	s.Interval = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfNetICMP) SetPackageNum(v int32) *CreateTimingSyntheticTaskRequestMonitorConfNetICMP {
	s.PackageNum = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfNetICMP) SetPackageSize(v int32) *CreateTimingSyntheticTaskRequestMonitorConfNetICMP {
	s.PackageSize = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfNetICMP) SetSplitPackage(v bool) *CreateTimingSyntheticTaskRequestMonitorConfNetICMP {
	s.SplitPackage = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfNetICMP) SetTargetUrl(v string) *CreateTimingSyntheticTaskRequestMonitorConfNetICMP {
	s.TargetUrl = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfNetICMP) SetTimeout(v int64) *CreateTimingSyntheticTaskRequestMonitorConfNetICMP {
	s.Timeout = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfNetICMP) SetTracertEnable(v bool) *CreateTimingSyntheticTaskRequestMonitorConfNetICMP {
	s.TracertEnable = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfNetICMP) SetTracertNumMax(v int32) *CreateTimingSyntheticTaskRequestMonitorConfNetICMP {
	s.TracertNumMax = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfNetICMP) SetTracertTimeout(v int64) *CreateTimingSyntheticTaskRequestMonitorConfNetICMP {
	s.TracertTimeout = &v
	return s
}

type CreateTimingSyntheticTaskRequestMonitorConfNetTCP struct {
	ConnectTimes   *int32  `json:"ConnectTimes,omitempty" xml:"ConnectTimes,omitempty"`
	Interval       *int64  `json:"Interval,omitempty" xml:"Interval,omitempty"`
	TargetUrl      *string `json:"TargetUrl,omitempty" xml:"TargetUrl,omitempty"`
	Timeout        *int64  `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	TracertEnable  *bool   `json:"TracertEnable,omitempty" xml:"TracertEnable,omitempty"`
	TracertNumMax  *int32  `json:"TracertNumMax,omitempty" xml:"TracertNumMax,omitempty"`
	TracertTimeout *int64  `json:"TracertTimeout,omitempty" xml:"TracertTimeout,omitempty"`
}

func (s CreateTimingSyntheticTaskRequestMonitorConfNetTCP) String() string {
	return tea.Prettify(s)
}

func (s CreateTimingSyntheticTaskRequestMonitorConfNetTCP) GoString() string {
	return s.String()
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfNetTCP) SetConnectTimes(v int32) *CreateTimingSyntheticTaskRequestMonitorConfNetTCP {
	s.ConnectTimes = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfNetTCP) SetInterval(v int64) *CreateTimingSyntheticTaskRequestMonitorConfNetTCP {
	s.Interval = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfNetTCP) SetTargetUrl(v string) *CreateTimingSyntheticTaskRequestMonitorConfNetTCP {
	s.TargetUrl = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfNetTCP) SetTimeout(v int64) *CreateTimingSyntheticTaskRequestMonitorConfNetTCP {
	s.Timeout = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfNetTCP) SetTracertEnable(v bool) *CreateTimingSyntheticTaskRequestMonitorConfNetTCP {
	s.TracertEnable = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfNetTCP) SetTracertNumMax(v int32) *CreateTimingSyntheticTaskRequestMonitorConfNetTCP {
	s.TracertNumMax = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfNetTCP) SetTracertTimeout(v int64) *CreateTimingSyntheticTaskRequestMonitorConfNetTCP {
	s.TracertTimeout = &v
	return s
}

type CreateTimingSyntheticTaskRequestMonitorConfStream struct {
	CustomHeaderContent  map[string]*string `json:"CustomHeaderContent,omitempty" xml:"CustomHeaderContent,omitempty"`
	PlayerType           *int32             `json:"PlayerType,omitempty" xml:"PlayerType,omitempty"`
	StreamAddressType    *int32             `json:"StreamAddressType,omitempty" xml:"StreamAddressType,omitempty"`
	StreamMonitorTimeout *int32             `json:"StreamMonitorTimeout,omitempty" xml:"StreamMonitorTimeout,omitempty"`
	StreamType           *int32             `json:"StreamType,omitempty" xml:"StreamType,omitempty"`
	TargetUrl            *string            `json:"TargetUrl,omitempty" xml:"TargetUrl,omitempty"`
	WhiteList            *string            `json:"WhiteList,omitempty" xml:"WhiteList,omitempty"`
}

func (s CreateTimingSyntheticTaskRequestMonitorConfStream) String() string {
	return tea.Prettify(s)
}

func (s CreateTimingSyntheticTaskRequestMonitorConfStream) GoString() string {
	return s.String()
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfStream) SetCustomHeaderContent(v map[string]*string) *CreateTimingSyntheticTaskRequestMonitorConfStream {
	s.CustomHeaderContent = v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfStream) SetPlayerType(v int32) *CreateTimingSyntheticTaskRequestMonitorConfStream {
	s.PlayerType = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfStream) SetStreamAddressType(v int32) *CreateTimingSyntheticTaskRequestMonitorConfStream {
	s.StreamAddressType = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfStream) SetStreamMonitorTimeout(v int32) *CreateTimingSyntheticTaskRequestMonitorConfStream {
	s.StreamMonitorTimeout = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfStream) SetStreamType(v int32) *CreateTimingSyntheticTaskRequestMonitorConfStream {
	s.StreamType = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfStream) SetTargetUrl(v string) *CreateTimingSyntheticTaskRequestMonitorConfStream {
	s.TargetUrl = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfStream) SetWhiteList(v string) *CreateTimingSyntheticTaskRequestMonitorConfStream {
	s.WhiteList = &v
	return s
}

type CreateTimingSyntheticTaskRequestMonitorConfWebsite struct {
	AutomaticScrolling     *int32             `json:"AutomaticScrolling,omitempty" xml:"AutomaticScrolling,omitempty"`
	CustomHeader           *int32             `json:"CustomHeader,omitempty" xml:"CustomHeader,omitempty"`
	CustomHeaderContent    map[string]*string `json:"CustomHeaderContent,omitempty" xml:"CustomHeaderContent,omitempty"`
	DNSHijackWhitelist     *string            `json:"DNSHijackWhitelist,omitempty" xml:"DNSHijackWhitelist,omitempty"`
	DisableCache           *int32             `json:"DisableCache,omitempty" xml:"DisableCache,omitempty"`
	DisableCompression     *int32             `json:"DisableCompression,omitempty" xml:"DisableCompression,omitempty"`
	ElementBlacklist       *string            `json:"ElementBlacklist,omitempty" xml:"ElementBlacklist,omitempty"`
	FilterInvalidIP        *int32             `json:"FilterInvalidIP,omitempty" xml:"FilterInvalidIP,omitempty"`
	FlowHijackJumpTimes    *int32             `json:"FlowHijackJumpTimes,omitempty" xml:"FlowHijackJumpTimes,omitempty"`
	FlowHijackLogo         *string            `json:"FlowHijackLogo,omitempty" xml:"FlowHijackLogo,omitempty"`
	IgnoreCertificateError *int32             `json:"IgnoreCertificateError,omitempty" xml:"IgnoreCertificateError,omitempty"`
	MonitorTimeout         *int64             `json:"MonitorTimeout,omitempty" xml:"MonitorTimeout,omitempty"`
	PageTamper             *string            `json:"PageTamper,omitempty" xml:"PageTamper,omitempty"`
	Redirection            *int32             `json:"Redirection,omitempty" xml:"Redirection,omitempty"`
	SlowElementThreshold   *int64             `json:"SlowElementThreshold,omitempty" xml:"SlowElementThreshold,omitempty"`
	TargetUrl              *string            `json:"TargetUrl,omitempty" xml:"TargetUrl,omitempty"`
	VerifyStringBlacklist  *string            `json:"VerifyStringBlacklist,omitempty" xml:"VerifyStringBlacklist,omitempty"`
	VerifyStringWhitelist  *string            `json:"VerifyStringWhitelist,omitempty" xml:"VerifyStringWhitelist,omitempty"`
	WaitCompletionTime     *int64             `json:"WaitCompletionTime,omitempty" xml:"WaitCompletionTime,omitempty"`
}

func (s CreateTimingSyntheticTaskRequestMonitorConfWebsite) String() string {
	return tea.Prettify(s)
}

func (s CreateTimingSyntheticTaskRequestMonitorConfWebsite) GoString() string {
	return s.String()
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfWebsite) SetAutomaticScrolling(v int32) *CreateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.AutomaticScrolling = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfWebsite) SetCustomHeader(v int32) *CreateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.CustomHeader = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfWebsite) SetCustomHeaderContent(v map[string]*string) *CreateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.CustomHeaderContent = v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfWebsite) SetDNSHijackWhitelist(v string) *CreateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.DNSHijackWhitelist = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfWebsite) SetDisableCache(v int32) *CreateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.DisableCache = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfWebsite) SetDisableCompression(v int32) *CreateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.DisableCompression = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfWebsite) SetElementBlacklist(v string) *CreateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.ElementBlacklist = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfWebsite) SetFilterInvalidIP(v int32) *CreateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.FilterInvalidIP = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfWebsite) SetFlowHijackJumpTimes(v int32) *CreateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.FlowHijackJumpTimes = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfWebsite) SetFlowHijackLogo(v string) *CreateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.FlowHijackLogo = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfWebsite) SetIgnoreCertificateError(v int32) *CreateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.IgnoreCertificateError = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfWebsite) SetMonitorTimeout(v int64) *CreateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.MonitorTimeout = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfWebsite) SetPageTamper(v string) *CreateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.PageTamper = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfWebsite) SetRedirection(v int32) *CreateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.Redirection = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfWebsite) SetSlowElementThreshold(v int64) *CreateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.SlowElementThreshold = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfWebsite) SetTargetUrl(v string) *CreateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.TargetUrl = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfWebsite) SetVerifyStringBlacklist(v string) *CreateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.VerifyStringBlacklist = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfWebsite) SetVerifyStringWhitelist(v string) *CreateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.VerifyStringWhitelist = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitorConfWebsite) SetWaitCompletionTime(v int64) *CreateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.WaitCompletionTime = &v
	return s
}

type CreateTimingSyntheticTaskRequestMonitors struct {
	CityCode     *string `json:"CityCode,omitempty" xml:"CityCode,omitempty"`
	ClientType   *int32  `json:"ClientType,omitempty" xml:"ClientType,omitempty"`
	OperatorCode *string `json:"OperatorCode,omitempty" xml:"OperatorCode,omitempty"`
}

func (s CreateTimingSyntheticTaskRequestMonitors) String() string {
	return tea.Prettify(s)
}

func (s CreateTimingSyntheticTaskRequestMonitors) GoString() string {
	return s.String()
}

func (s *CreateTimingSyntheticTaskRequestMonitors) SetCityCode(v string) *CreateTimingSyntheticTaskRequestMonitors {
	s.CityCode = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitors) SetClientType(v int32) *CreateTimingSyntheticTaskRequestMonitors {
	s.ClientType = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestMonitors) SetOperatorCode(v string) *CreateTimingSyntheticTaskRequestMonitors {
	s.OperatorCode = &v
	return s
}

type CreateTimingSyntheticTaskRequestTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateTimingSyntheticTaskRequestTags) String() string {
	return tea.Prettify(s)
}

func (s CreateTimingSyntheticTaskRequestTags) GoString() string {
	return s.String()
}

func (s *CreateTimingSyntheticTaskRequestTags) SetKey(v string) *CreateTimingSyntheticTaskRequestTags {
	s.Key = &v
	return s
}

func (s *CreateTimingSyntheticTaskRequestTags) SetValue(v string) *CreateTimingSyntheticTaskRequestTags {
	s.Value = &v
	return s
}

type CreateTimingSyntheticTaskShrinkRequest struct {
	AvailableAssertionsShrink *string `json:"AvailableAssertions,omitempty" xml:"AvailableAssertions,omitempty"`
	CommonSettingShrink       *string `json:"CommonSetting,omitempty" xml:"CommonSetting,omitempty"`
	CustomPeriodShrink        *string `json:"CustomPeriod,omitempty" xml:"CustomPeriod,omitempty"`
	Frequency                 *string `json:"Frequency,omitempty" xml:"Frequency,omitempty"`
	MonitorCategory           *int32  `json:"MonitorCategory,omitempty" xml:"MonitorCategory,omitempty"`
	MonitorConfShrink         *string `json:"MonitorConf,omitempty" xml:"MonitorConf,omitempty"`
	MonitorsShrink            *string `json:"Monitors,omitempty" xml:"Monitors,omitempty"`
	Name                      *string `json:"Name,omitempty" xml:"Name,omitempty"`
	RegionId                  *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId           *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	TagsShrink                *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	TaskType                  *int32  `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s CreateTimingSyntheticTaskShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTimingSyntheticTaskShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateTimingSyntheticTaskShrinkRequest) SetAvailableAssertionsShrink(v string) *CreateTimingSyntheticTaskShrinkRequest {
	s.AvailableAssertionsShrink = &v
	return s
}

func (s *CreateTimingSyntheticTaskShrinkRequest) SetCommonSettingShrink(v string) *CreateTimingSyntheticTaskShrinkRequest {
	s.CommonSettingShrink = &v
	return s
}

func (s *CreateTimingSyntheticTaskShrinkRequest) SetCustomPeriodShrink(v string) *CreateTimingSyntheticTaskShrinkRequest {
	s.CustomPeriodShrink = &v
	return s
}

func (s *CreateTimingSyntheticTaskShrinkRequest) SetFrequency(v string) *CreateTimingSyntheticTaskShrinkRequest {
	s.Frequency = &v
	return s
}

func (s *CreateTimingSyntheticTaskShrinkRequest) SetMonitorCategory(v int32) *CreateTimingSyntheticTaskShrinkRequest {
	s.MonitorCategory = &v
	return s
}

func (s *CreateTimingSyntheticTaskShrinkRequest) SetMonitorConfShrink(v string) *CreateTimingSyntheticTaskShrinkRequest {
	s.MonitorConfShrink = &v
	return s
}

func (s *CreateTimingSyntheticTaskShrinkRequest) SetMonitorsShrink(v string) *CreateTimingSyntheticTaskShrinkRequest {
	s.MonitorsShrink = &v
	return s
}

func (s *CreateTimingSyntheticTaskShrinkRequest) SetName(v string) *CreateTimingSyntheticTaskShrinkRequest {
	s.Name = &v
	return s
}

func (s *CreateTimingSyntheticTaskShrinkRequest) SetRegionId(v string) *CreateTimingSyntheticTaskShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *CreateTimingSyntheticTaskShrinkRequest) SetResourceGroupId(v string) *CreateTimingSyntheticTaskShrinkRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateTimingSyntheticTaskShrinkRequest) SetTagsShrink(v string) *CreateTimingSyntheticTaskShrinkRequest {
	s.TagsShrink = &v
	return s
}

func (s *CreateTimingSyntheticTaskShrinkRequest) SetTaskType(v int32) *CreateTimingSyntheticTaskShrinkRequest {
	s.TaskType = &v
	return s
}

type CreateTimingSyntheticTaskResponseBody struct {
	Code    *int64                                     `json:"Code,omitempty" xml:"Code,omitempty"`
	Data    *CreateTimingSyntheticTaskResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	Message *string                                    `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateTimingSyntheticTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTimingSyntheticTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTimingSyntheticTaskResponseBody) SetCode(v int64) *CreateTimingSyntheticTaskResponseBody {
	s.Code = &v
	return s
}

func (s *CreateTimingSyntheticTaskResponseBody) SetData(v *CreateTimingSyntheticTaskResponseBodyData) *CreateTimingSyntheticTaskResponseBody {
	s.Data = v
	return s
}

func (s *CreateTimingSyntheticTaskResponseBody) SetMessage(v string) *CreateTimingSyntheticTaskResponseBody {
	s.Message = &v
	return s
}

func (s *CreateTimingSyntheticTaskResponseBody) SetRequestId(v string) *CreateTimingSyntheticTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateTimingSyntheticTaskResponseBody) SetSuccess(v bool) *CreateTimingSyntheticTaskResponseBody {
	s.Success = &v
	return s
}

type CreateTimingSyntheticTaskResponseBodyData struct {
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s CreateTimingSyntheticTaskResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateTimingSyntheticTaskResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateTimingSyntheticTaskResponseBodyData) SetStatus(v string) *CreateTimingSyntheticTaskResponseBodyData {
	s.Status = &v
	return s
}

func (s *CreateTimingSyntheticTaskResponseBodyData) SetTaskId(v string) *CreateTimingSyntheticTaskResponseBodyData {
	s.TaskId = &v
	return s
}

type CreateTimingSyntheticTaskResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateTimingSyntheticTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateTimingSyntheticTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTimingSyntheticTaskResponse) GoString() string {
	return s.String()
}

func (s *CreateTimingSyntheticTaskResponse) SetHeaders(v map[string]*string) *CreateTimingSyntheticTaskResponse {
	s.Headers = v
	return s
}

func (s *CreateTimingSyntheticTaskResponse) SetStatusCode(v int32) *CreateTimingSyntheticTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTimingSyntheticTaskResponse) SetBody(v *CreateTimingSyntheticTaskResponseBody) *CreateTimingSyntheticTaskResponse {
	s.Body = v
	return s
}

type CreateWebhookRequest struct {
	// The notification template that is sent when an alert is triggered. This parameter is required if the **Method** parameter is set to **Post**. You can use the $content placeholder to specify the notification content. The content cannot exceed 500 characters in length.
	Body *string `json:"Body,omitempty" xml:"Body,omitempty"`
	// The name of the contact.
	ContactName *string `json:"ContactName,omitempty" xml:"ContactName,omitempty"`
	// The HTTP request header.
	HttpHeaders *string `json:"HttpHeaders,omitempty" xml:"HttpHeaders,omitempty"`
	// The parameters in the HTTP request.
	HttpParams *string `json:"HttpParams,omitempty" xml:"HttpParams,omitempty"`
	// The HTTP request method.
	//
	// *   `Get`
	// *   `Post`
	Method *string `json:"Method,omitempty" xml:"Method,omitempty"`
	// The notification template that is sent when an alert is resolved. This parameter is required if the **Method** parameter is set to **Post**. You can use the $content placeholder to specify the notification content. The content cannot exceed 500 characters in length.
	RecoverBody *string `json:"RecoverBody,omitempty" xml:"RecoverBody,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The URL of the request **method**.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s CreateWebhookRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateWebhookRequest) GoString() string {
	return s.String()
}

func (s *CreateWebhookRequest) SetBody(v string) *CreateWebhookRequest {
	s.Body = &v
	return s
}

func (s *CreateWebhookRequest) SetContactName(v string) *CreateWebhookRequest {
	s.ContactName = &v
	return s
}

func (s *CreateWebhookRequest) SetHttpHeaders(v string) *CreateWebhookRequest {
	s.HttpHeaders = &v
	return s
}

func (s *CreateWebhookRequest) SetHttpParams(v string) *CreateWebhookRequest {
	s.HttpParams = &v
	return s
}

func (s *CreateWebhookRequest) SetMethod(v string) *CreateWebhookRequest {
	s.Method = &v
	return s
}

func (s *CreateWebhookRequest) SetRecoverBody(v string) *CreateWebhookRequest {
	s.RecoverBody = &v
	return s
}

func (s *CreateWebhookRequest) SetRegionId(v string) *CreateWebhookRequest {
	s.RegionId = &v
	return s
}

func (s *CreateWebhookRequest) SetUrl(v string) *CreateWebhookRequest {
	s.Url = &v
	return s
}

type CreateWebhookResponseBody struct {
	// The ID of the contact for webhook alerts.
	ContactId *string `json:"ContactId,omitempty" xml:"ContactId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateWebhookResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateWebhookResponseBody) GoString() string {
	return s.String()
}

func (s *CreateWebhookResponseBody) SetContactId(v string) *CreateWebhookResponseBody {
	s.ContactId = &v
	return s
}

func (s *CreateWebhookResponseBody) SetRequestId(v string) *CreateWebhookResponseBody {
	s.RequestId = &v
	return s
}

type CreateWebhookResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateWebhookResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateWebhookResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateWebhookResponse) GoString() string {
	return s.String()
}

func (s *CreateWebhookResponse) SetHeaders(v map[string]*string) *CreateWebhookResponse {
	s.Headers = v
	return s
}

func (s *CreateWebhookResponse) SetStatusCode(v int32) *CreateWebhookResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateWebhookResponse) SetBody(v *CreateWebhookResponseBody) *CreateWebhookResponse {
	s.Body = v
	return s
}

type DelAuthTokenRequest struct {
	// The cluster ID.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DelAuthTokenRequest) String() string {
	return tea.Prettify(s)
}

func (s DelAuthTokenRequest) GoString() string {
	return s.String()
}

func (s *DelAuthTokenRequest) SetClusterId(v string) *DelAuthTokenRequest {
	s.ClusterId = &v
	return s
}

func (s *DelAuthTokenRequest) SetRegionId(v string) *DelAuthTokenRequest {
	s.RegionId = &v
	return s
}

type DelAuthTokenResponseBody struct {
	// Indicates whether the call was successful.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DelAuthTokenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DelAuthTokenResponseBody) GoString() string {
	return s.String()
}

func (s *DelAuthTokenResponseBody) SetData(v string) *DelAuthTokenResponseBody {
	s.Data = &v
	return s
}

func (s *DelAuthTokenResponseBody) SetRequestId(v string) *DelAuthTokenResponseBody {
	s.RequestId = &v
	return s
}

type DelAuthTokenResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DelAuthTokenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DelAuthTokenResponse) String() string {
	return tea.Prettify(s)
}

func (s DelAuthTokenResponse) GoString() string {
	return s.String()
}

func (s *DelAuthTokenResponse) SetHeaders(v map[string]*string) *DelAuthTokenResponse {
	s.Headers = v
	return s
}

func (s *DelAuthTokenResponse) SetStatusCode(v int32) *DelAuthTokenResponse {
	s.StatusCode = &v
	return s
}

func (s *DelAuthTokenResponse) SetBody(v *DelAuthTokenResponseBody) *DelAuthTokenResponse {
	s.Body = v
	return s
}

type DeleteAddonReleaseRequest struct {
	// Environment ID.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// Whether to be forcibly deleted. The default value is false.
	Force *bool `json:"Force,omitempty" xml:"Force,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Name of Release.
	ReleaseName *string `json:"ReleaseName,omitempty" xml:"ReleaseName,omitempty"`
}

func (s DeleteAddonReleaseRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAddonReleaseRequest) GoString() string {
	return s.String()
}

func (s *DeleteAddonReleaseRequest) SetEnvironmentId(v string) *DeleteAddonReleaseRequest {
	s.EnvironmentId = &v
	return s
}

func (s *DeleteAddonReleaseRequest) SetForce(v bool) *DeleteAddonReleaseRequest {
	s.Force = &v
	return s
}

func (s *DeleteAddonReleaseRequest) SetRegionId(v string) *DeleteAddonReleaseRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteAddonReleaseRequest) SetReleaseName(v string) *DeleteAddonReleaseRequest {
	s.ReleaseName = &v
	return s
}

type DeleteAddonReleaseResponseBody struct {
	// Status code: 200 indicates success.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Return a message.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the alert rule was deleted. Valid values:
	//
	// *   `true`: The alert rule was deleted.
	// *   `false`: The alert rule failed to be deleted.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteAddonReleaseResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAddonReleaseResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAddonReleaseResponseBody) SetCode(v int32) *DeleteAddonReleaseResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteAddonReleaseResponseBody) SetData(v string) *DeleteAddonReleaseResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteAddonReleaseResponseBody) SetMessage(v string) *DeleteAddonReleaseResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteAddonReleaseResponseBody) SetRequestId(v string) *DeleteAddonReleaseResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteAddonReleaseResponseBody) SetSuccess(v bool) *DeleteAddonReleaseResponseBody {
	s.Success = &v
	return s
}

type DeleteAddonReleaseResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAddonReleaseResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAddonReleaseResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAddonReleaseResponse) GoString() string {
	return s.String()
}

func (s *DeleteAddonReleaseResponse) SetHeaders(v map[string]*string) *DeleteAddonReleaseResponse {
	s.Headers = v
	return s
}

func (s *DeleteAddonReleaseResponse) SetStatusCode(v int32) *DeleteAddonReleaseResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAddonReleaseResponse) SetBody(v *DeleteAddonReleaseResponseBody) *DeleteAddonReleaseResponse {
	s.Body = v
	return s
}

type DeleteAlertContactRequest struct {
	// The ID of the alert contact.
	ContactId *int64 `json:"ContactId,omitempty" xml:"ContactId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteAlertContactRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAlertContactRequest) GoString() string {
	return s.String()
}

func (s *DeleteAlertContactRequest) SetContactId(v int64) *DeleteAlertContactRequest {
	s.ContactId = &v
	return s
}

func (s *DeleteAlertContactRequest) SetRegionId(v string) *DeleteAlertContactRequest {
	s.RegionId = &v
	return s
}

type DeleteAlertContactResponseBody struct {
	// Indicates whether the call was successful.
	//
	// *   `true`: The call was successful.
	// *   `false`: The call failed.
	IsSuccess *bool `json:"IsSuccess,omitempty" xml:"IsSuccess,omitempty"`
	// The ID of the request. You can query logs and troubleshoot issues based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAlertContactResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAlertContactResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAlertContactResponseBody) SetIsSuccess(v bool) *DeleteAlertContactResponseBody {
	s.IsSuccess = &v
	return s
}

func (s *DeleteAlertContactResponseBody) SetRequestId(v string) *DeleteAlertContactResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAlertContactResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAlertContactResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAlertContactResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAlertContactResponse) GoString() string {
	return s.String()
}

func (s *DeleteAlertContactResponse) SetHeaders(v map[string]*string) *DeleteAlertContactResponse {
	s.Headers = v
	return s
}

func (s *DeleteAlertContactResponse) SetStatusCode(v int32) *DeleteAlertContactResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAlertContactResponse) SetBody(v *DeleteAlertContactResponseBody) *DeleteAlertContactResponse {
	s.Body = v
	return s
}

type DeleteAlertContactGroupRequest struct {
	// The ID of the alert contact group.
	ContactGroupId *int64 `json:"ContactGroupId,omitempty" xml:"ContactGroupId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteAlertContactGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAlertContactGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteAlertContactGroupRequest) SetContactGroupId(v int64) *DeleteAlertContactGroupRequest {
	s.ContactGroupId = &v
	return s
}

func (s *DeleteAlertContactGroupRequest) SetRegionId(v string) *DeleteAlertContactGroupRequest {
	s.RegionId = &v
	return s
}

type DeleteAlertContactGroupResponseBody struct {
	// Indicates whether the call was successful.
	//
	// *   `true`: The call was successful.
	// *   `false`: The call failed.
	IsSuccess *bool `json:"IsSuccess,omitempty" xml:"IsSuccess,omitempty"`
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAlertContactGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAlertContactGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAlertContactGroupResponseBody) SetIsSuccess(v bool) *DeleteAlertContactGroupResponseBody {
	s.IsSuccess = &v
	return s
}

func (s *DeleteAlertContactGroupResponseBody) SetRequestId(v string) *DeleteAlertContactGroupResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAlertContactGroupResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAlertContactGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAlertContactGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAlertContactGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteAlertContactGroupResponse) SetHeaders(v map[string]*string) *DeleteAlertContactGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteAlertContactGroupResponse) SetStatusCode(v int32) *DeleteAlertContactGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAlertContactGroupResponse) SetBody(v *DeleteAlertContactGroupResponseBody) *DeleteAlertContactGroupResponse {
	s.Body = v
	return s
}

type DeleteAlertRuleRequest struct {
	// Indicates whether the alert rule was successfully deleted.
	//
	// *   `true`: The specified data is deleted.
	// *   `false`: The specified data fails to be deleted.
	AlertId *int64 `json:"AlertId,omitempty" xml:"AlertId,omitempty"`
}

func (s DeleteAlertRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAlertRuleRequest) GoString() string {
	return s.String()
}

func (s *DeleteAlertRuleRequest) SetAlertId(v int64) *DeleteAlertRuleRequest {
	s.AlertId = &v
	return s
}

type DeleteAlertRuleResponseBody struct {
	// Indicates whether the call was successful.
	//
	// *   `true`: The call was successful.
	// *   `false`: The call failed.
	IsSuccess *bool `json:"IsSuccess,omitempty" xml:"IsSuccess,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAlertRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAlertRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAlertRuleResponseBody) SetIsSuccess(v bool) *DeleteAlertRuleResponseBody {
	s.IsSuccess = &v
	return s
}

func (s *DeleteAlertRuleResponseBody) SetRequestId(v string) *DeleteAlertRuleResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAlertRuleResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAlertRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAlertRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAlertRuleResponse) GoString() string {
	return s.String()
}

func (s *DeleteAlertRuleResponse) SetHeaders(v map[string]*string) *DeleteAlertRuleResponse {
	s.Headers = v
	return s
}

func (s *DeleteAlertRuleResponse) SetStatusCode(v int32) *DeleteAlertRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAlertRuleResponse) SetBody(v *DeleteAlertRuleResponseBody) *DeleteAlertRuleResponse {
	s.Body = v
	return s
}

type DeleteAlertRulesRequest struct {
	AlertIds *string `json:"AlertIds,omitempty" xml:"AlertIds,omitempty"`
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteAlertRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAlertRulesRequest) GoString() string {
	return s.String()
}

func (s *DeleteAlertRulesRequest) SetAlertIds(v string) *DeleteAlertRulesRequest {
	s.AlertIds = &v
	return s
}

func (s *DeleteAlertRulesRequest) SetRegionId(v string) *DeleteAlertRulesRequest {
	s.RegionId = &v
	return s
}

type DeleteAlertRulesResponseBody struct {
	IsSuccess *bool   `json:"IsSuccess,omitempty" xml:"IsSuccess,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAlertRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAlertRulesResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAlertRulesResponseBody) SetIsSuccess(v bool) *DeleteAlertRulesResponseBody {
	s.IsSuccess = &v
	return s
}

func (s *DeleteAlertRulesResponseBody) SetRequestId(v string) *DeleteAlertRulesResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAlertRulesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAlertRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAlertRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAlertRulesResponse) GoString() string {
	return s.String()
}

func (s *DeleteAlertRulesResponse) SetHeaders(v map[string]*string) *DeleteAlertRulesResponse {
	s.Headers = v
	return s
}

func (s *DeleteAlertRulesResponse) SetStatusCode(v int32) *DeleteAlertRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAlertRulesResponse) SetBody(v *DeleteAlertRulesResponseBody) *DeleteAlertRulesResponse {
	s.Body = v
	return s
}

type DeleteAppListRequest struct {
	// The PIDs of the applications monitored by ARMS Application Monitoring.
	Pids []*string `json:"Pids,omitempty" xml:"Pids,omitempty" type:"Repeated"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteAppListRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAppListRequest) GoString() string {
	return s.String()
}

func (s *DeleteAppListRequest) SetPids(v []*string) *DeleteAppListRequest {
	s.Pids = v
	return s
}

func (s *DeleteAppListRequest) SetRegionId(v string) *DeleteAppListRequest {
	s.RegionId = &v
	return s
}

type DeleteAppListResponseBody struct {
	// The HTTP status code. 2XX indicates that the request was successful. 3XX indicates that the request was redirected. 4XX indicates that a request error occurred. 5XX indicates that a server error occurred.
	Code *int64 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned message.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error message returned when the request parameters are invalid.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the specified applications are deleted. Valid values:
	//
	// *   `true`: The applications are deleted.
	// *   `false`: The applications failed to be deleted.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteAppListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAppListResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAppListResponseBody) SetCode(v int64) *DeleteAppListResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteAppListResponseBody) SetData(v string) *DeleteAppListResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteAppListResponseBody) SetMessage(v string) *DeleteAppListResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteAppListResponseBody) SetRequestId(v string) *DeleteAppListResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteAppListResponseBody) SetSuccess(v bool) *DeleteAppListResponseBody {
	s.Success = &v
	return s
}

type DeleteAppListResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAppListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAppListResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAppListResponse) GoString() string {
	return s.String()
}

func (s *DeleteAppListResponse) SetHeaders(v map[string]*string) *DeleteAppListResponse {
	s.Headers = v
	return s
}

func (s *DeleteAppListResponse) SetStatusCode(v int32) *DeleteAppListResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAppListResponse) SetBody(v *DeleteAppListResponseBody) *DeleteAppListResponse {
	s.Body = v
	return s
}

type DeleteCmsExporterRequest struct {
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	RegionId  *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteCmsExporterRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCmsExporterRequest) GoString() string {
	return s.String()
}

func (s *DeleteCmsExporterRequest) SetClusterId(v string) *DeleteCmsExporterRequest {
	s.ClusterId = &v
	return s
}

func (s *DeleteCmsExporterRequest) SetRegionId(v string) *DeleteCmsExporterRequest {
	s.RegionId = &v
	return s
}

type DeleteCmsExporterResponseBody struct {
	Data      *string `json:"Data,omitempty" xml:"Data,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteCmsExporterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCmsExporterResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCmsExporterResponseBody) SetData(v string) *DeleteCmsExporterResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteCmsExporterResponseBody) SetRequestId(v string) *DeleteCmsExporterResponseBody {
	s.RequestId = &v
	return s
}

type DeleteCmsExporterResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCmsExporterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCmsExporterResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCmsExporterResponse) GoString() string {
	return s.String()
}

func (s *DeleteCmsExporterResponse) SetHeaders(v map[string]*string) *DeleteCmsExporterResponse {
	s.Headers = v
	return s
}

func (s *DeleteCmsExporterResponse) SetStatusCode(v int32) *DeleteCmsExporterResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCmsExporterResponse) SetBody(v *DeleteCmsExporterResponseBody) *DeleteCmsExporterResponse {
	s.Body = v
	return s
}

type DeleteContactRequest struct {
	// The operation that you want to perform. Set the value to **DeleteContact**.
	ContactId *int64 `json:"ContactId,omitempty" xml:"ContactId,omitempty"`
}

func (s DeleteContactRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteContactRequest) GoString() string {
	return s.String()
}

func (s *DeleteContactRequest) SetContactId(v int64) *DeleteContactRequest {
	s.ContactId = &v
	return s
}

type DeleteContactResponseBody struct {
	IsSuccess *bool   `json:"IsSuccess,omitempty" xml:"IsSuccess,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteContactResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteContactResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteContactResponseBody) SetIsSuccess(v bool) *DeleteContactResponseBody {
	s.IsSuccess = &v
	return s
}

func (s *DeleteContactResponseBody) SetRequestId(v string) *DeleteContactResponseBody {
	s.RequestId = &v
	return s
}

type DeleteContactResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteContactResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteContactResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteContactResponse) GoString() string {
	return s.String()
}

func (s *DeleteContactResponse) SetHeaders(v map[string]*string) *DeleteContactResponse {
	s.Headers = v
	return s
}

func (s *DeleteContactResponse) SetStatusCode(v int32) *DeleteContactResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteContactResponse) SetBody(v *DeleteContactResponseBody) *DeleteContactResponse {
	s.Body = v
	return s
}

type DeleteContactGroupRequest struct {
	// The ID of the alert contact group.
	ContactGroupId *int64 `json:"ContactGroupId,omitempty" xml:"ContactGroupId,omitempty"`
}

func (s DeleteContactGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteContactGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteContactGroupRequest) SetContactGroupId(v int64) *DeleteContactGroupRequest {
	s.ContactGroupId = &v
	return s
}

type DeleteContactGroupResponseBody struct {
	// Indicates whether the alert contact group was deleted. Valid values:
	//
	// *   `true`
	// *   `false`
	IsSuccess *bool `json:"IsSuccess,omitempty" xml:"IsSuccess,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteContactGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteContactGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteContactGroupResponseBody) SetIsSuccess(v bool) *DeleteContactGroupResponseBody {
	s.IsSuccess = &v
	return s
}

func (s *DeleteContactGroupResponseBody) SetRequestId(v string) *DeleteContactGroupResponseBody {
	s.RequestId = &v
	return s
}

type DeleteContactGroupResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteContactGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteContactGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteContactGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteContactGroupResponse) SetHeaders(v map[string]*string) *DeleteContactGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteContactGroupResponse) SetStatusCode(v int32) *DeleteContactGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteContactGroupResponse) SetBody(v *DeleteContactGroupResponseBody) *DeleteContactGroupResponse {
	s.Body = v
	return s
}

type DeleteDispatchRuleRequest struct {
	Id       *string `json:"Id,omitempty" xml:"Id,omitempty"`
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteDispatchRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDispatchRuleRequest) GoString() string {
	return s.String()
}

func (s *DeleteDispatchRuleRequest) SetId(v string) *DeleteDispatchRuleRequest {
	s.Id = &v
	return s
}

func (s *DeleteDispatchRuleRequest) SetRegionId(v string) *DeleteDispatchRuleRequest {
	s.RegionId = &v
	return s
}

type DeleteDispatchRuleResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteDispatchRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDispatchRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDispatchRuleResponseBody) SetRequestId(v string) *DeleteDispatchRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteDispatchRuleResponseBody) SetSuccess(v bool) *DeleteDispatchRuleResponseBody {
	s.Success = &v
	return s
}

type DeleteDispatchRuleResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDispatchRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDispatchRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDispatchRuleResponse) GoString() string {
	return s.String()
}

func (s *DeleteDispatchRuleResponse) SetHeaders(v map[string]*string) *DeleteDispatchRuleResponse {
	s.Headers = v
	return s
}

func (s *DeleteDispatchRuleResponse) SetStatusCode(v int32) *DeleteDispatchRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDispatchRuleResponse) SetBody(v *DeleteDispatchRuleResponseBody) *DeleteDispatchRuleResponse {
	s.Body = v
	return s
}

type DeleteEnvCustomJobRequest struct {
	// Custom job name.
	CustomJobName *string `json:"CustomJobName,omitempty" xml:"CustomJobName,omitempty"`
	// Environment ID.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteEnvCustomJobRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteEnvCustomJobRequest) GoString() string {
	return s.String()
}

func (s *DeleteEnvCustomJobRequest) SetCustomJobName(v string) *DeleteEnvCustomJobRequest {
	s.CustomJobName = &v
	return s
}

func (s *DeleteEnvCustomJobRequest) SetEnvironmentId(v string) *DeleteEnvCustomJobRequest {
	s.EnvironmentId = &v
	return s
}

func (s *DeleteEnvCustomJobRequest) SetRegionId(v string) *DeleteEnvCustomJobRequest {
	s.RegionId = &v
	return s
}

type DeleteEnvCustomJobResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned result.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteEnvCustomJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteEnvCustomJobResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteEnvCustomJobResponseBody) SetCode(v int32) *DeleteEnvCustomJobResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteEnvCustomJobResponseBody) SetData(v string) *DeleteEnvCustomJobResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteEnvCustomJobResponseBody) SetMessage(v string) *DeleteEnvCustomJobResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteEnvCustomJobResponseBody) SetRequestId(v string) *DeleteEnvCustomJobResponseBody {
	s.RequestId = &v
	return s
}

type DeleteEnvCustomJobResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteEnvCustomJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteEnvCustomJobResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteEnvCustomJobResponse) GoString() string {
	return s.String()
}

func (s *DeleteEnvCustomJobResponse) SetHeaders(v map[string]*string) *DeleteEnvCustomJobResponse {
	s.Headers = v
	return s
}

func (s *DeleteEnvCustomJobResponse) SetStatusCode(v int32) *DeleteEnvCustomJobResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteEnvCustomJobResponse) SetBody(v *DeleteEnvCustomJobResponseBody) *DeleteEnvCustomJobResponse {
	s.Body = v
	return s
}

type DeleteEnvPodMonitorRequest struct {
	// Environment instance ID.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The namespace where podMonitor is located
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// PodMonitor name.
	PodMonitorName *string `json:"PodMonitorName,omitempty" xml:"PodMonitorName,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteEnvPodMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteEnvPodMonitorRequest) GoString() string {
	return s.String()
}

func (s *DeleteEnvPodMonitorRequest) SetEnvironmentId(v string) *DeleteEnvPodMonitorRequest {
	s.EnvironmentId = &v
	return s
}

func (s *DeleteEnvPodMonitorRequest) SetNamespace(v string) *DeleteEnvPodMonitorRequest {
	s.Namespace = &v
	return s
}

func (s *DeleteEnvPodMonitorRequest) SetPodMonitorName(v string) *DeleteEnvPodMonitorRequest {
	s.PodMonitorName = &v
	return s
}

func (s *DeleteEnvPodMonitorRequest) SetRegionId(v string) *DeleteEnvPodMonitorRequest {
	s.RegionId = &v
	return s
}

type DeleteEnvPodMonitorResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteEnvPodMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteEnvPodMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteEnvPodMonitorResponseBody) SetCode(v int32) *DeleteEnvPodMonitorResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteEnvPodMonitorResponseBody) SetData(v string) *DeleteEnvPodMonitorResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteEnvPodMonitorResponseBody) SetMessage(v string) *DeleteEnvPodMonitorResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteEnvPodMonitorResponseBody) SetRequestId(v string) *DeleteEnvPodMonitorResponseBody {
	s.RequestId = &v
	return s
}

type DeleteEnvPodMonitorResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteEnvPodMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteEnvPodMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteEnvPodMonitorResponse) GoString() string {
	return s.String()
}

func (s *DeleteEnvPodMonitorResponse) SetHeaders(v map[string]*string) *DeleteEnvPodMonitorResponse {
	s.Headers = v
	return s
}

func (s *DeleteEnvPodMonitorResponse) SetStatusCode(v int32) *DeleteEnvPodMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteEnvPodMonitorResponse) SetBody(v *DeleteEnvPodMonitorResponseBody) *DeleteEnvPodMonitorResponse {
	s.Body = v
	return s
}

type DeleteEnvServiceMonitorRequest struct {
	// Environment instance ID.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The name of the namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// ServiceMonitor name.
	ServiceMonitorName *string `json:"ServiceMonitorName,omitempty" xml:"ServiceMonitorName,omitempty"`
}

func (s DeleteEnvServiceMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteEnvServiceMonitorRequest) GoString() string {
	return s.String()
}

func (s *DeleteEnvServiceMonitorRequest) SetEnvironmentId(v string) *DeleteEnvServiceMonitorRequest {
	s.EnvironmentId = &v
	return s
}

func (s *DeleteEnvServiceMonitorRequest) SetNamespace(v string) *DeleteEnvServiceMonitorRequest {
	s.Namespace = &v
	return s
}

func (s *DeleteEnvServiceMonitorRequest) SetRegionId(v string) *DeleteEnvServiceMonitorRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteEnvServiceMonitorRequest) SetServiceMonitorName(v string) *DeleteEnvServiceMonitorRequest {
	s.ServiceMonitorName = &v
	return s
}

type DeleteEnvServiceMonitorResponseBody struct {
	// The status code or error code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteEnvServiceMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteEnvServiceMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteEnvServiceMonitorResponseBody) SetCode(v int32) *DeleteEnvServiceMonitorResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteEnvServiceMonitorResponseBody) SetData(v string) *DeleteEnvServiceMonitorResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteEnvServiceMonitorResponseBody) SetMessage(v string) *DeleteEnvServiceMonitorResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteEnvServiceMonitorResponseBody) SetRequestId(v string) *DeleteEnvServiceMonitorResponseBody {
	s.RequestId = &v
	return s
}

type DeleteEnvServiceMonitorResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteEnvServiceMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteEnvServiceMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteEnvServiceMonitorResponse) GoString() string {
	return s.String()
}

func (s *DeleteEnvServiceMonitorResponse) SetHeaders(v map[string]*string) *DeleteEnvServiceMonitorResponse {
	s.Headers = v
	return s
}

func (s *DeleteEnvServiceMonitorResponse) SetStatusCode(v int32) *DeleteEnvServiceMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteEnvServiceMonitorResponse) SetBody(v *DeleteEnvServiceMonitorResponseBody) *DeleteEnvServiceMonitorResponse {
	s.Body = v
	return s
}

type DeleteEnvironmentRequest struct {
	// cascade delete Prometheus instance.
	DeletePromInstance *bool `json:"DeletePromInstance,omitempty" xml:"DeletePromInstance,omitempty"`
	// The ID of the environment instance.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteEnvironmentRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteEnvironmentRequest) GoString() string {
	return s.String()
}

func (s *DeleteEnvironmentRequest) SetDeletePromInstance(v bool) *DeleteEnvironmentRequest {
	s.DeletePromInstance = &v
	return s
}

func (s *DeleteEnvironmentRequest) SetEnvironmentId(v string) *DeleteEnvironmentRequest {
	s.EnvironmentId = &v
	return s
}

func (s *DeleteEnvironmentRequest) SetRegionId(v string) *DeleteEnvironmentRequest {
	s.RegionId = &v
	return s
}

type DeleteEnvironmentResponseBody struct {
	// The HTTP status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result of the operation.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteEnvironmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteEnvironmentResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteEnvironmentResponseBody) SetCode(v int32) *DeleteEnvironmentResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteEnvironmentResponseBody) SetData(v string) *DeleteEnvironmentResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteEnvironmentResponseBody) SetMessage(v string) *DeleteEnvironmentResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteEnvironmentResponseBody) SetRequestId(v string) *DeleteEnvironmentResponseBody {
	s.RequestId = &v
	return s
}

type DeleteEnvironmentResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteEnvironmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteEnvironmentResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteEnvironmentResponse) GoString() string {
	return s.String()
}

func (s *DeleteEnvironmentResponse) SetHeaders(v map[string]*string) *DeleteEnvironmentResponse {
	s.Headers = v
	return s
}

func (s *DeleteEnvironmentResponse) SetStatusCode(v int32) *DeleteEnvironmentResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteEnvironmentResponse) SetBody(v *DeleteEnvironmentResponseBody) *DeleteEnvironmentResponse {
	s.Body = v
	return s
}

type DeleteEnvironmentFeatureRequest struct {
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	FeatureName   *string `json:"FeatureName,omitempty" xml:"FeatureName,omitempty"`
	RegionId      *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteEnvironmentFeatureRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteEnvironmentFeatureRequest) GoString() string {
	return s.String()
}

func (s *DeleteEnvironmentFeatureRequest) SetEnvironmentId(v string) *DeleteEnvironmentFeatureRequest {
	s.EnvironmentId = &v
	return s
}

func (s *DeleteEnvironmentFeatureRequest) SetFeatureName(v string) *DeleteEnvironmentFeatureRequest {
	s.FeatureName = &v
	return s
}

func (s *DeleteEnvironmentFeatureRequest) SetRegionId(v string) *DeleteEnvironmentFeatureRequest {
	s.RegionId = &v
	return s
}

type DeleteEnvironmentFeatureResponseBody struct {
	Code    *int32  `json:"Code,omitempty" xml:"Code,omitempty"`
	Data    *string `json:"Data,omitempty" xml:"Data,omitempty"`
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteEnvironmentFeatureResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteEnvironmentFeatureResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteEnvironmentFeatureResponseBody) SetCode(v int32) *DeleteEnvironmentFeatureResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteEnvironmentFeatureResponseBody) SetData(v string) *DeleteEnvironmentFeatureResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteEnvironmentFeatureResponseBody) SetMessage(v string) *DeleteEnvironmentFeatureResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteEnvironmentFeatureResponseBody) SetRequestId(v string) *DeleteEnvironmentFeatureResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteEnvironmentFeatureResponseBody) SetSuccess(v bool) *DeleteEnvironmentFeatureResponseBody {
	s.Success = &v
	return s
}

type DeleteEnvironmentFeatureResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteEnvironmentFeatureResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteEnvironmentFeatureResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteEnvironmentFeatureResponse) GoString() string {
	return s.String()
}

func (s *DeleteEnvironmentFeatureResponse) SetHeaders(v map[string]*string) *DeleteEnvironmentFeatureResponse {
	s.Headers = v
	return s
}

func (s *DeleteEnvironmentFeatureResponse) SetStatusCode(v int32) *DeleteEnvironmentFeatureResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteEnvironmentFeatureResponse) SetBody(v *DeleteEnvironmentFeatureResponseBody) *DeleteEnvironmentFeatureResponse {
	s.Body = v
	return s
}

type DeleteEventBridgeIntegrationRequest struct {
	// The ID of the EventBridge integration. You can call the **ListEventBridgeIntegrations** operation to query the ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s DeleteEventBridgeIntegrationRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteEventBridgeIntegrationRequest) GoString() string {
	return s.String()
}

func (s *DeleteEventBridgeIntegrationRequest) SetId(v int64) *DeleteEventBridgeIntegrationRequest {
	s.Id = &v
	return s
}

type DeleteEventBridgeIntegrationResponseBody struct {
	// Indicates whether the EventBridge integration is deleted.
	//
	// *   `true`
	// *   `false`
	IsSuccess *bool `json:"IsSuccess,omitempty" xml:"IsSuccess,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteEventBridgeIntegrationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteEventBridgeIntegrationResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteEventBridgeIntegrationResponseBody) SetIsSuccess(v bool) *DeleteEventBridgeIntegrationResponseBody {
	s.IsSuccess = &v
	return s
}

func (s *DeleteEventBridgeIntegrationResponseBody) SetRequestId(v string) *DeleteEventBridgeIntegrationResponseBody {
	s.RequestId = &v
	return s
}

type DeleteEventBridgeIntegrationResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteEventBridgeIntegrationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteEventBridgeIntegrationResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteEventBridgeIntegrationResponse) GoString() string {
	return s.String()
}

func (s *DeleteEventBridgeIntegrationResponse) SetHeaders(v map[string]*string) *DeleteEventBridgeIntegrationResponse {
	s.Headers = v
	return s
}

func (s *DeleteEventBridgeIntegrationResponse) SetStatusCode(v int32) *DeleteEventBridgeIntegrationResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteEventBridgeIntegrationResponse) SetBody(v *DeleteEventBridgeIntegrationResponseBody) *DeleteEventBridgeIntegrationResponse {
	s.Body = v
	return s
}

type DeleteGrafanaResourceRequest struct {
	// The instance ID.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The instance name.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteGrafanaResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteGrafanaResourceRequest) GoString() string {
	return s.String()
}

func (s *DeleteGrafanaResourceRequest) SetClusterId(v string) *DeleteGrafanaResourceRequest {
	s.ClusterId = &v
	return s
}

func (s *DeleteGrafanaResourceRequest) SetClusterName(v string) *DeleteGrafanaResourceRequest {
	s.ClusterName = &v
	return s
}

func (s *DeleteGrafanaResourceRequest) SetRegionId(v string) *DeleteGrafanaResourceRequest {
	s.RegionId = &v
	return s
}

type DeleteGrafanaResourceResponseBody struct {
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned message.
	Data    *string `json:"Data,omitempty" xml:"Data,omitempty"`
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteGrafanaResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteGrafanaResourceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteGrafanaResourceResponseBody) SetCode(v int32) *DeleteGrafanaResourceResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteGrafanaResourceResponseBody) SetData(v string) *DeleteGrafanaResourceResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteGrafanaResourceResponseBody) SetMessage(v string) *DeleteGrafanaResourceResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteGrafanaResourceResponseBody) SetRequestId(v string) *DeleteGrafanaResourceResponseBody {
	s.RequestId = &v
	return s
}

type DeleteGrafanaResourceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteGrafanaResourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteGrafanaResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteGrafanaResourceResponse) GoString() string {
	return s.String()
}

func (s *DeleteGrafanaResourceResponse) SetHeaders(v map[string]*string) *DeleteGrafanaResourceResponse {
	s.Headers = v
	return s
}

func (s *DeleteGrafanaResourceResponse) SetStatusCode(v int32) *DeleteGrafanaResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteGrafanaResourceResponse) SetBody(v *DeleteGrafanaResourceResponseBody) *DeleteGrafanaResourceResponse {
	s.Body = v
	return s
}

type DeleteGrafanaWorkspaceRequest struct {
	GrafanaWorkspaceId *string `json:"GrafanaWorkspaceId,omitempty" xml:"GrafanaWorkspaceId,omitempty"`
	RegionId           *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteGrafanaWorkspaceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteGrafanaWorkspaceRequest) GoString() string {
	return s.String()
}

func (s *DeleteGrafanaWorkspaceRequest) SetGrafanaWorkspaceId(v string) *DeleteGrafanaWorkspaceRequest {
	s.GrafanaWorkspaceId = &v
	return s
}

func (s *DeleteGrafanaWorkspaceRequest) SetRegionId(v string) *DeleteGrafanaWorkspaceRequest {
	s.RegionId = &v
	return s
}

type DeleteGrafanaWorkspaceResponseBody struct {
	Code      *int32  `json:"Code,omitempty" xml:"Code,omitempty"`
	Data      *bool   `json:"Data,omitempty" xml:"Data,omitempty"`
	Message   *string `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
	TraceId   *string `json:"TraceId,omitempty" xml:"TraceId,omitempty"`
}

func (s DeleteGrafanaWorkspaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteGrafanaWorkspaceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteGrafanaWorkspaceResponseBody) SetCode(v int32) *DeleteGrafanaWorkspaceResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteGrafanaWorkspaceResponseBody) SetData(v bool) *DeleteGrafanaWorkspaceResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteGrafanaWorkspaceResponseBody) SetMessage(v string) *DeleteGrafanaWorkspaceResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteGrafanaWorkspaceResponseBody) SetRequestId(v string) *DeleteGrafanaWorkspaceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteGrafanaWorkspaceResponseBody) SetSuccess(v bool) *DeleteGrafanaWorkspaceResponseBody {
	s.Success = &v
	return s
}

func (s *DeleteGrafanaWorkspaceResponseBody) SetTraceId(v string) *DeleteGrafanaWorkspaceResponseBody {
	s.TraceId = &v
	return s
}

type DeleteGrafanaWorkspaceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteGrafanaWorkspaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteGrafanaWorkspaceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteGrafanaWorkspaceResponse) GoString() string {
	return s.String()
}

func (s *DeleteGrafanaWorkspaceResponse) SetHeaders(v map[string]*string) *DeleteGrafanaWorkspaceResponse {
	s.Headers = v
	return s
}

func (s *DeleteGrafanaWorkspaceResponse) SetStatusCode(v int32) *DeleteGrafanaWorkspaceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteGrafanaWorkspaceResponse) SetBody(v *DeleteGrafanaWorkspaceResponseBody) *DeleteGrafanaWorkspaceResponse {
	s.Body = v
	return s
}

type DeleteIMRobotRequest struct {
	// The ID of the IM chatbot.
	RobotId *int64 `json:"RobotId,omitempty" xml:"RobotId,omitempty"`
}

func (s DeleteIMRobotRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteIMRobotRequest) GoString() string {
	return s.String()
}

func (s *DeleteIMRobotRequest) SetRobotId(v int64) *DeleteIMRobotRequest {
	s.RobotId = &v
	return s
}

type DeleteIMRobotResponseBody struct {
	// Indicates whether the call was successful.
	//
	// *   `true`: The call was successful.
	// *   `false`: The call failed.
	IsSuccess *bool `json:"IsSuccess,omitempty" xml:"IsSuccess,omitempty"`
	// The request ID. You can use the ID to find logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteIMRobotResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteIMRobotResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteIMRobotResponseBody) SetIsSuccess(v bool) *DeleteIMRobotResponseBody {
	s.IsSuccess = &v
	return s
}

func (s *DeleteIMRobotResponseBody) SetRequestId(v string) *DeleteIMRobotResponseBody {
	s.RequestId = &v
	return s
}

type DeleteIMRobotResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteIMRobotResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteIMRobotResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteIMRobotResponse) GoString() string {
	return s.String()
}

func (s *DeleteIMRobotResponse) SetHeaders(v map[string]*string) *DeleteIMRobotResponse {
	s.Headers = v
	return s
}

func (s *DeleteIMRobotResponse) SetStatusCode(v int32) *DeleteIMRobotResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteIMRobotResponse) SetBody(v *DeleteIMRobotResponseBody) *DeleteIMRobotResponse {
	s.Body = v
	return s
}

type DeleteIntegrationRequest struct {
	// The ID of the ACK cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The abbreviation of the software that is supported by Application Real-Time Monitoring Service (ARMS). Valid values (case-insensitive): `ASM`, `IoT`, and `Flink`.
	Integration *string `json:"Integration,omitempty" xml:"Integration,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteIntegrationRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteIntegrationRequest) GoString() string {
	return s.String()
}

func (s *DeleteIntegrationRequest) SetClusterId(v string) *DeleteIntegrationRequest {
	s.ClusterId = &v
	return s
}

func (s *DeleteIntegrationRequest) SetIntegration(v string) *DeleteIntegrationRequest {
	s.Integration = &v
	return s
}

func (s *DeleteIntegrationRequest) SetRegionId(v string) *DeleteIntegrationRequest {
	s.RegionId = &v
	return s
}

type DeleteIntegrationResponseBody struct {
	// The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the call was successful.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteIntegrationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteIntegrationResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteIntegrationResponseBody) SetCode(v int32) *DeleteIntegrationResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteIntegrationResponseBody) SetData(v string) *DeleteIntegrationResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteIntegrationResponseBody) SetMessage(v string) *DeleteIntegrationResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteIntegrationResponseBody) SetRequestId(v string) *DeleteIntegrationResponseBody {
	s.RequestId = &v
	return s
}

type DeleteIntegrationResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteIntegrationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteIntegrationResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteIntegrationResponse) GoString() string {
	return s.String()
}

func (s *DeleteIntegrationResponse) SetHeaders(v map[string]*string) *DeleteIntegrationResponse {
	s.Headers = v
	return s
}

func (s *DeleteIntegrationResponse) SetStatusCode(v int32) *DeleteIntegrationResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteIntegrationResponse) SetBody(v *DeleteIntegrationResponseBody) *DeleteIntegrationResponse {
	s.Body = v
	return s
}

type DeleteIntegrationsRequest struct {
	IntegrationId *int64 `json:"IntegrationId,omitempty" xml:"IntegrationId,omitempty"`
}

func (s DeleteIntegrationsRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteIntegrationsRequest) GoString() string {
	return s.String()
}

func (s *DeleteIntegrationsRequest) SetIntegrationId(v int64) *DeleteIntegrationsRequest {
	s.IntegrationId = &v
	return s
}

type DeleteIntegrationsResponseBody struct {
	IsSuccess *bool   `json:"IsSuccess,omitempty" xml:"IsSuccess,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteIntegrationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteIntegrationsResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteIntegrationsResponseBody) SetIsSuccess(v bool) *DeleteIntegrationsResponseBody {
	s.IsSuccess = &v
	return s
}

func (s *DeleteIntegrationsResponseBody) SetRequestId(v string) *DeleteIntegrationsResponseBody {
	s.RequestId = &v
	return s
}

type DeleteIntegrationsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteIntegrationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteIntegrationsResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteIntegrationsResponse) GoString() string {
	return s.String()
}

func (s *DeleteIntegrationsResponse) SetHeaders(v map[string]*string) *DeleteIntegrationsResponse {
	s.Headers = v
	return s
}

func (s *DeleteIntegrationsResponse) SetStatusCode(v int32) *DeleteIntegrationsResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteIntegrationsResponse) SetBody(v *DeleteIntegrationsResponseBody) *DeleteIntegrationsResponse {
	s.Body = v
	return s
}

type DeleteNotificationPolicyRequest struct {
	// Deletes a notification policy based on its ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s DeleteNotificationPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteNotificationPolicyRequest) GoString() string {
	return s.String()
}

func (s *DeleteNotificationPolicyRequest) SetId(v int64) *DeleteNotificationPolicyRequest {
	s.Id = &v
	return s
}

type DeleteNotificationPolicyResponseBody struct {
	// The ID of the request.
	IsSuccess *bool `json:"IsSuccess,omitempty" xml:"IsSuccess,omitempty"`
	// The ID of the notification policy.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteNotificationPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteNotificationPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteNotificationPolicyResponseBody) SetIsSuccess(v bool) *DeleteNotificationPolicyResponseBody {
	s.IsSuccess = &v
	return s
}

func (s *DeleteNotificationPolicyResponseBody) SetRequestId(v string) *DeleteNotificationPolicyResponseBody {
	s.RequestId = &v
	return s
}

type DeleteNotificationPolicyResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteNotificationPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteNotificationPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteNotificationPolicyResponse) GoString() string {
	return s.String()
}

func (s *DeleteNotificationPolicyResponse) SetHeaders(v map[string]*string) *DeleteNotificationPolicyResponse {
	s.Headers = v
	return s
}

func (s *DeleteNotificationPolicyResponse) SetStatusCode(v int32) *DeleteNotificationPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteNotificationPolicyResponse) SetBody(v *DeleteNotificationPolicyResponseBody) *DeleteNotificationPolicyResponse {
	s.Body = v
	return s
}

type DeletePrometheusAlertRuleRequest struct {
	// Indicates whether the alert rule was deleted. Valid values:
	//
	// *   `true`: The alert rule was deleted.
	// *   `false`: The alert rule failed to be deleted.
	AlertId   *int64  `json:"AlertId,omitempty" xml:"AlertId,omitempty"`
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
}

func (s DeletePrometheusAlertRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeletePrometheusAlertRuleRequest) GoString() string {
	return s.String()
}

func (s *DeletePrometheusAlertRuleRequest) SetAlertId(v int64) *DeletePrometheusAlertRuleRequest {
	s.AlertId = &v
	return s
}

func (s *DeletePrometheusAlertRuleRequest) SetClusterId(v string) *DeletePrometheusAlertRuleRequest {
	s.ClusterId = &v
	return s
}

type DeletePrometheusAlertRuleResponseBody struct {
	Code      *int64  `json:"Code,omitempty" xml:"Code,omitempty"`
	Message   *string `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeletePrometheusAlertRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeletePrometheusAlertRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DeletePrometheusAlertRuleResponseBody) SetCode(v int64) *DeletePrometheusAlertRuleResponseBody {
	s.Code = &v
	return s
}

func (s *DeletePrometheusAlertRuleResponseBody) SetMessage(v string) *DeletePrometheusAlertRuleResponseBody {
	s.Message = &v
	return s
}

func (s *DeletePrometheusAlertRuleResponseBody) SetRequestId(v string) *DeletePrometheusAlertRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeletePrometheusAlertRuleResponseBody) SetSuccess(v bool) *DeletePrometheusAlertRuleResponseBody {
	s.Success = &v
	return s
}

type DeletePrometheusAlertRuleResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeletePrometheusAlertRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeletePrometheusAlertRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeletePrometheusAlertRuleResponse) GoString() string {
	return s.String()
}

func (s *DeletePrometheusAlertRuleResponse) SetHeaders(v map[string]*string) *DeletePrometheusAlertRuleResponse {
	s.Headers = v
	return s
}

func (s *DeletePrometheusAlertRuleResponse) SetStatusCode(v int32) *DeletePrometheusAlertRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeletePrometheusAlertRuleResponse) SetBody(v *DeletePrometheusAlertRuleResponseBody) *DeletePrometheusAlertRuleResponse {
	s.Body = v
	return s
}

type DeletePrometheusGlobalViewRequest struct {
	// The ID of the global aggregation instance.
	GlobalViewClusterId *string `json:"GlobalViewClusterId,omitempty" xml:"GlobalViewClusterId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeletePrometheusGlobalViewRequest) String() string {
	return tea.Prettify(s)
}

func (s DeletePrometheusGlobalViewRequest) GoString() string {
	return s.String()
}

func (s *DeletePrometheusGlobalViewRequest) SetGlobalViewClusterId(v string) *DeletePrometheusGlobalViewRequest {
	s.GlobalViewClusterId = &v
	return s
}

func (s *DeletePrometheusGlobalViewRequest) SetRegionId(v string) *DeletePrometheusGlobalViewRequest {
	s.RegionId = &v
	return s
}

type DeletePrometheusGlobalViewResponseBody struct {
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The response parameters in the JSON format.
	Data    *string `json:"Data,omitempty" xml:"Data,omitempty"`
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeletePrometheusGlobalViewResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeletePrometheusGlobalViewResponseBody) GoString() string {
	return s.String()
}

func (s *DeletePrometheusGlobalViewResponseBody) SetCode(v int32) *DeletePrometheusGlobalViewResponseBody {
	s.Code = &v
	return s
}

func (s *DeletePrometheusGlobalViewResponseBody) SetData(v string) *DeletePrometheusGlobalViewResponseBody {
	s.Data = &v
	return s
}

func (s *DeletePrometheusGlobalViewResponseBody) SetMessage(v string) *DeletePrometheusGlobalViewResponseBody {
	s.Message = &v
	return s
}

func (s *DeletePrometheusGlobalViewResponseBody) SetRequestId(v string) *DeletePrometheusGlobalViewResponseBody {
	s.RequestId = &v
	return s
}

type DeletePrometheusGlobalViewResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeletePrometheusGlobalViewResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeletePrometheusGlobalViewResponse) String() string {
	return tea.Prettify(s)
}

func (s DeletePrometheusGlobalViewResponse) GoString() string {
	return s.String()
}

func (s *DeletePrometheusGlobalViewResponse) SetHeaders(v map[string]*string) *DeletePrometheusGlobalViewResponse {
	s.Headers = v
	return s
}

func (s *DeletePrometheusGlobalViewResponse) SetStatusCode(v int32) *DeletePrometheusGlobalViewResponse {
	s.StatusCode = &v
	return s
}

func (s *DeletePrometheusGlobalViewResponse) SetBody(v *DeletePrometheusGlobalViewResponseBody) *DeletePrometheusGlobalViewResponse {
	s.Body = v
	return s
}

type DeletePrometheusIntegrationRequest struct {
	// The ID of the Prometheus instance. Only a Prometheus instance for Container Service or a Prometheus instance for ECS is supported.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the exporter.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of the integration.
	IntegrationType *string `json:"IntegrationType,omitempty" xml:"IntegrationType,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeletePrometheusIntegrationRequest) String() string {
	return tea.Prettify(s)
}

func (s DeletePrometheusIntegrationRequest) GoString() string {
	return s.String()
}

func (s *DeletePrometheusIntegrationRequest) SetClusterId(v string) *DeletePrometheusIntegrationRequest {
	s.ClusterId = &v
	return s
}

func (s *DeletePrometheusIntegrationRequest) SetInstanceId(v int64) *DeletePrometheusIntegrationRequest {
	s.InstanceId = &v
	return s
}

func (s *DeletePrometheusIntegrationRequest) SetIntegrationType(v string) *DeletePrometheusIntegrationRequest {
	s.IntegrationType = &v
	return s
}

func (s *DeletePrometheusIntegrationRequest) SetRegionId(v string) *DeletePrometheusIntegrationRequest {
	s.RegionId = &v
	return s
}

type DeletePrometheusIntegrationResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// success or an error message.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeletePrometheusIntegrationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeletePrometheusIntegrationResponseBody) GoString() string {
	return s.String()
}

func (s *DeletePrometheusIntegrationResponseBody) SetCode(v int32) *DeletePrometheusIntegrationResponseBody {
	s.Code = &v
	return s
}

func (s *DeletePrometheusIntegrationResponseBody) SetData(v string) *DeletePrometheusIntegrationResponseBody {
	s.Data = &v
	return s
}

func (s *DeletePrometheusIntegrationResponseBody) SetMessage(v string) *DeletePrometheusIntegrationResponseBody {
	s.Message = &v
	return s
}

func (s *DeletePrometheusIntegrationResponseBody) SetRequestId(v string) *DeletePrometheusIntegrationResponseBody {
	s.RequestId = &v
	return s
}

type DeletePrometheusIntegrationResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeletePrometheusIntegrationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeletePrometheusIntegrationResponse) String() string {
	return tea.Prettify(s)
}

func (s DeletePrometheusIntegrationResponse) GoString() string {
	return s.String()
}

func (s *DeletePrometheusIntegrationResponse) SetHeaders(v map[string]*string) *DeletePrometheusIntegrationResponse {
	s.Headers = v
	return s
}

func (s *DeletePrometheusIntegrationResponse) SetStatusCode(v int32) *DeletePrometheusIntegrationResponse {
	s.StatusCode = &v
	return s
}

func (s *DeletePrometheusIntegrationResponse) SetBody(v *DeletePrometheusIntegrationResponseBody) *DeletePrometheusIntegrationResponse {
	s.Body = v
	return s
}

type DeletePrometheusMonitoringRequest struct {
	// The ID of the Prometheus instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the monitoring configuration.
	MonitoringName *string `json:"MonitoringName,omitempty" xml:"MonitoringName,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The type of the monitoring configuration.
	// Valid values for a Prometheus instance for Container Service: serviceMonitor, podMonitor, customJob, and probe.
	// Valid values for a Prometheus instance for ECS: customJob and probe.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DeletePrometheusMonitoringRequest) String() string {
	return tea.Prettify(s)
}

func (s DeletePrometheusMonitoringRequest) GoString() string {
	return s.String()
}

func (s *DeletePrometheusMonitoringRequest) SetClusterId(v string) *DeletePrometheusMonitoringRequest {
	s.ClusterId = &v
	return s
}

func (s *DeletePrometheusMonitoringRequest) SetMonitoringName(v string) *DeletePrometheusMonitoringRequest {
	s.MonitoringName = &v
	return s
}

func (s *DeletePrometheusMonitoringRequest) SetRegionId(v string) *DeletePrometheusMonitoringRequest {
	s.RegionId = &v
	return s
}

func (s *DeletePrometheusMonitoringRequest) SetType(v string) *DeletePrometheusMonitoringRequest {
	s.Type = &v
	return s
}

type DeletePrometheusMonitoringResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result of the operation.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeletePrometheusMonitoringResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeletePrometheusMonitoringResponseBody) GoString() string {
	return s.String()
}

func (s *DeletePrometheusMonitoringResponseBody) SetCode(v int32) *DeletePrometheusMonitoringResponseBody {
	s.Code = &v
	return s
}

func (s *DeletePrometheusMonitoringResponseBody) SetData(v string) *DeletePrometheusMonitoringResponseBody {
	s.Data = &v
	return s
}

func (s *DeletePrometheusMonitoringResponseBody) SetMessage(v string) *DeletePrometheusMonitoringResponseBody {
	s.Message = &v
	return s
}

func (s *DeletePrometheusMonitoringResponseBody) SetRequestId(v string) *DeletePrometheusMonitoringResponseBody {
	s.RequestId = &v
	return s
}

type DeletePrometheusMonitoringResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeletePrometheusMonitoringResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeletePrometheusMonitoringResponse) String() string {
	return tea.Prettify(s)
}

func (s DeletePrometheusMonitoringResponse) GoString() string {
	return s.String()
}

func (s *DeletePrometheusMonitoringResponse) SetHeaders(v map[string]*string) *DeletePrometheusMonitoringResponse {
	s.Headers = v
	return s
}

func (s *DeletePrometheusMonitoringResponse) SetStatusCode(v int32) *DeletePrometheusMonitoringResponse {
	s.StatusCode = &v
	return s
}

func (s *DeletePrometheusMonitoringResponse) SetBody(v *DeletePrometheusMonitoringResponseBody) *DeletePrometheusMonitoringResponse {
	s.Body = v
	return s
}

type DeletePrometheusRemoteWriteRequest struct {
	// The ID of the Prometheus instance. Only a Prometheus instance for Container Service or a Prometheus instance for ECS is supported.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The names of the remote write configuration items that you want to delete. Separate configuration items with commas (,).
	RemoteWriteNames *string `json:"RemoteWriteNames,omitempty" xml:"RemoteWriteNames,omitempty"`
}

func (s DeletePrometheusRemoteWriteRequest) String() string {
	return tea.Prettify(s)
}

func (s DeletePrometheusRemoteWriteRequest) GoString() string {
	return s.String()
}

func (s *DeletePrometheusRemoteWriteRequest) SetClusterId(v string) *DeletePrometheusRemoteWriteRequest {
	s.ClusterId = &v
	return s
}

func (s *DeletePrometheusRemoteWriteRequest) SetRegionId(v string) *DeletePrometheusRemoteWriteRequest {
	s.RegionId = &v
	return s
}

func (s *DeletePrometheusRemoteWriteRequest) SetRemoteWriteNames(v string) *DeletePrometheusRemoteWriteRequest {
	s.RemoteWriteNames = &v
	return s
}

type DeletePrometheusRemoteWriteResponseBody struct {
	// The status code or error code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The remote write configuration items. If the request fails, an error message is returned.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values: true and false.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeletePrometheusRemoteWriteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeletePrometheusRemoteWriteResponseBody) GoString() string {
	return s.String()
}

func (s *DeletePrometheusRemoteWriteResponseBody) SetCode(v int32) *DeletePrometheusRemoteWriteResponseBody {
	s.Code = &v
	return s
}

func (s *DeletePrometheusRemoteWriteResponseBody) SetData(v string) *DeletePrometheusRemoteWriteResponseBody {
	s.Data = &v
	return s
}

func (s *DeletePrometheusRemoteWriteResponseBody) SetMessage(v string) *DeletePrometheusRemoteWriteResponseBody {
	s.Message = &v
	return s
}

func (s *DeletePrometheusRemoteWriteResponseBody) SetRequestId(v string) *DeletePrometheusRemoteWriteResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeletePrometheusRemoteWriteResponseBody) SetSuccess(v bool) *DeletePrometheusRemoteWriteResponseBody {
	s.Success = &v
	return s
}

type DeletePrometheusRemoteWriteResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeletePrometheusRemoteWriteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeletePrometheusRemoteWriteResponse) String() string {
	return tea.Prettify(s)
}

func (s DeletePrometheusRemoteWriteResponse) GoString() string {
	return s.String()
}

func (s *DeletePrometheusRemoteWriteResponse) SetHeaders(v map[string]*string) *DeletePrometheusRemoteWriteResponse {
	s.Headers = v
	return s
}

func (s *DeletePrometheusRemoteWriteResponse) SetStatusCode(v int32) *DeletePrometheusRemoteWriteResponse {
	s.StatusCode = &v
	return s
}

func (s *DeletePrometheusRemoteWriteResponse) SetBody(v *DeletePrometheusRemoteWriteResponseBody) *DeletePrometheusRemoteWriteResponse {
	s.Body = v
	return s
}

type DeleteRetcodeAppRequest struct {
	// The application ID.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The process identifier (PID) of the application.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteRetcodeAppRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteRetcodeAppRequest) GoString() string {
	return s.String()
}

func (s *DeleteRetcodeAppRequest) SetAppId(v string) *DeleteRetcodeAppRequest {
	s.AppId = &v
	return s
}

func (s *DeleteRetcodeAppRequest) SetAppName(v string) *DeleteRetcodeAppRequest {
	s.AppName = &v
	return s
}

func (s *DeleteRetcodeAppRequest) SetPid(v string) *DeleteRetcodeAppRequest {
	s.Pid = &v
	return s
}

func (s *DeleteRetcodeAppRequest) SetRegionId(v string) *DeleteRetcodeAppRequest {
	s.RegionId = &v
	return s
}

type DeleteRetcodeAppResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the Browser Monitoring task was deleted. Valid values:
	//
	// *   `true`
	// *   `false`
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The message returned for the operation. Valid values:
	//
	// *   **Success** is returned if the operation is successful.
	// *   An error message is returned if the operation fails.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// true: The request was successful.
	//
	// false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteRetcodeAppResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteRetcodeAppResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteRetcodeAppResponseBody) SetCode(v int32) *DeleteRetcodeAppResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteRetcodeAppResponseBody) SetData(v string) *DeleteRetcodeAppResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteRetcodeAppResponseBody) SetMessage(v string) *DeleteRetcodeAppResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteRetcodeAppResponseBody) SetRequestId(v string) *DeleteRetcodeAppResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteRetcodeAppResponseBody) SetSuccess(v bool) *DeleteRetcodeAppResponseBody {
	s.Success = &v
	return s
}

type DeleteRetcodeAppResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteRetcodeAppResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteRetcodeAppResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteRetcodeAppResponse) GoString() string {
	return s.String()
}

func (s *DeleteRetcodeAppResponse) SetHeaders(v map[string]*string) *DeleteRetcodeAppResponse {
	s.Headers = v
	return s
}

func (s *DeleteRetcodeAppResponse) SetStatusCode(v int32) *DeleteRetcodeAppResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteRetcodeAppResponse) SetBody(v *DeleteRetcodeAppResponseBody) *DeleteRetcodeAppResponse {
	s.Body = v
	return s
}

type DeleteScenarioRequest struct {
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the business monitoring job. You can obtain the ID by calling the ListScenario operation.
	ScenarioId *int64 `json:"ScenarioId,omitempty" xml:"ScenarioId,omitempty"`
}

func (s DeleteScenarioRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteScenarioRequest) GoString() string {
	return s.String()
}

func (s *DeleteScenarioRequest) SetRegionId(v string) *DeleteScenarioRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteScenarioRequest) SetScenarioId(v int64) *DeleteScenarioRequest {
	s.ScenarioId = &v
	return s
}

type DeleteScenarioResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	//
	// *   `true`: successful
	// *   `false`: failed
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s DeleteScenarioResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteScenarioResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteScenarioResponseBody) SetRequestId(v string) *DeleteScenarioResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteScenarioResponseBody) SetResult(v bool) *DeleteScenarioResponseBody {
	s.Result = &v
	return s
}

type DeleteScenarioResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteScenarioResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteScenarioResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteScenarioResponse) GoString() string {
	return s.String()
}

func (s *DeleteScenarioResponse) SetHeaders(v map[string]*string) *DeleteScenarioResponse {
	s.Headers = v
	return s
}

func (s *DeleteScenarioResponse) SetStatusCode(v int32) *DeleteScenarioResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteScenarioResponse) SetBody(v *DeleteScenarioResponseBody) *DeleteScenarioResponse {
	s.Body = v
	return s
}

type DeleteSilencePolicyRequest struct {
	// The ID of the request.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s DeleteSilencePolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSilencePolicyRequest) GoString() string {
	return s.String()
}

func (s *DeleteSilencePolicyRequest) SetId(v int64) *DeleteSilencePolicyRequest {
	s.Id = &v
	return s
}

type DeleteSilencePolicyResponseBody struct {
	// Indicates whether the silence policy was deleted successfully. Valid values:
	//
	// *   `true`: The silence policy was deleted successfully.
	// *   `false`: The silence policy failed to be deleted.
	IsSuccess *bool `json:"IsSuccess,omitempty" xml:"IsSuccess,omitempty"`
	// The operation that you want to perform. Set the value to **DeleteSilencePolicy**.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteSilencePolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSilencePolicyResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSilencePolicyResponseBody) SetIsSuccess(v bool) *DeleteSilencePolicyResponseBody {
	s.IsSuccess = &v
	return s
}

func (s *DeleteSilencePolicyResponseBody) SetRequestId(v string) *DeleteSilencePolicyResponseBody {
	s.RequestId = &v
	return s
}

type DeleteSilencePolicyResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSilencePolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSilencePolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSilencePolicyResponse) GoString() string {
	return s.String()
}

func (s *DeleteSilencePolicyResponse) SetHeaders(v map[string]*string) *DeleteSilencePolicyResponse {
	s.Headers = v
	return s
}

func (s *DeleteSilencePolicyResponse) SetStatusCode(v int32) *DeleteSilencePolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSilencePolicyResponse) SetBody(v *DeleteSilencePolicyResponseBody) *DeleteSilencePolicyResponse {
	s.Body = v
	return s
}

type DeleteSourceMapRequest struct {
	FidList  []*string `json:"FidList,omitempty" xml:"FidList,omitempty" type:"Repeated"`
	Pid      *string   `json:"Pid,omitempty" xml:"Pid,omitempty"`
	RegionId *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteSourceMapRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSourceMapRequest) GoString() string {
	return s.String()
}

func (s *DeleteSourceMapRequest) SetFidList(v []*string) *DeleteSourceMapRequest {
	s.FidList = v
	return s
}

func (s *DeleteSourceMapRequest) SetPid(v string) *DeleteSourceMapRequest {
	s.Pid = &v
	return s
}

func (s *DeleteSourceMapRequest) SetRegionId(v string) *DeleteSourceMapRequest {
	s.RegionId = &v
	return s
}

type DeleteSourceMapShrinkRequest struct {
	FidListShrink *string `json:"FidList,omitempty" xml:"FidList,omitempty"`
	Pid           *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	RegionId      *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteSourceMapShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSourceMapShrinkRequest) GoString() string {
	return s.String()
}

func (s *DeleteSourceMapShrinkRequest) SetFidListShrink(v string) *DeleteSourceMapShrinkRequest {
	s.FidListShrink = &v
	return s
}

func (s *DeleteSourceMapShrinkRequest) SetPid(v string) *DeleteSourceMapShrinkRequest {
	s.Pid = &v
	return s
}

func (s *DeleteSourceMapShrinkRequest) SetRegionId(v string) *DeleteSourceMapShrinkRequest {
	s.RegionId = &v
	return s
}

type DeleteSourceMapResponseBody struct {
	Data      *string `json:"Data,omitempty" xml:"Data,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteSourceMapResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSourceMapResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSourceMapResponseBody) SetData(v string) *DeleteSourceMapResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteSourceMapResponseBody) SetRequestId(v string) *DeleteSourceMapResponseBody {
	s.RequestId = &v
	return s
}

type DeleteSourceMapResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSourceMapResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSourceMapResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSourceMapResponse) GoString() string {
	return s.String()
}

func (s *DeleteSourceMapResponse) SetHeaders(v map[string]*string) *DeleteSourceMapResponse {
	s.Headers = v
	return s
}

func (s *DeleteSourceMapResponse) SetStatusCode(v int32) *DeleteSourceMapResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSourceMapResponse) SetBody(v *DeleteSourceMapResponseBody) *DeleteSourceMapResponse {
	s.Body = v
	return s
}

type DeleteSyntheticTaskRequest struct {
	RegionId *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	TaskIds  []*string `json:"TaskIds,omitempty" xml:"TaskIds,omitempty" type:"Repeated"`
}

func (s DeleteSyntheticTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSyntheticTaskRequest) GoString() string {
	return s.String()
}

func (s *DeleteSyntheticTaskRequest) SetRegionId(v string) *DeleteSyntheticTaskRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteSyntheticTaskRequest) SetTaskIds(v []*string) *DeleteSyntheticTaskRequest {
	s.TaskIds = v
	return s
}

type DeleteSyntheticTaskResponseBody struct {
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *string `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s DeleteSyntheticTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSyntheticTaskResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSyntheticTaskResponseBody) SetRequestId(v string) *DeleteSyntheticTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteSyntheticTaskResponseBody) SetResult(v string) *DeleteSyntheticTaskResponseBody {
	s.Result = &v
	return s
}

type DeleteSyntheticTaskResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSyntheticTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSyntheticTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSyntheticTaskResponse) GoString() string {
	return s.String()
}

func (s *DeleteSyntheticTaskResponse) SetHeaders(v map[string]*string) *DeleteSyntheticTaskResponse {
	s.Headers = v
	return s
}

func (s *DeleteSyntheticTaskResponse) SetStatusCode(v int32) *DeleteSyntheticTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSyntheticTaskResponse) SetBody(v *DeleteSyntheticTaskResponseBody) *DeleteSyntheticTaskResponse {
	s.Body = v
	return s
}

type DeleteTimingSyntheticTaskRequest struct {
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource group ID.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of the synthetic monitoring task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DeleteTimingSyntheticTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTimingSyntheticTaskRequest) GoString() string {
	return s.String()
}

func (s *DeleteTimingSyntheticTaskRequest) SetRegionId(v string) *DeleteTimingSyntheticTaskRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteTimingSyntheticTaskRequest) SetResourceGroupId(v string) *DeleteTimingSyntheticTaskRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DeleteTimingSyntheticTaskRequest) SetTaskId(v string) *DeleteTimingSyntheticTaskRequest {
	s.TaskId = &v
	return s
}

type DeleteTimingSyntheticTaskResponseBody struct {
	// The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
	Code *int64 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the synthetic monitoring task was deleted. true: The synthetic monitoring task was deleted. false: The synthetic monitoring task failed to be deleted.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteTimingSyntheticTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTimingSyntheticTaskResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTimingSyntheticTaskResponseBody) SetCode(v int64) *DeleteTimingSyntheticTaskResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteTimingSyntheticTaskResponseBody) SetData(v bool) *DeleteTimingSyntheticTaskResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteTimingSyntheticTaskResponseBody) SetMessage(v string) *DeleteTimingSyntheticTaskResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteTimingSyntheticTaskResponseBody) SetRequestId(v string) *DeleteTimingSyntheticTaskResponseBody {
	s.RequestId = &v
	return s
}

type DeleteTimingSyntheticTaskResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTimingSyntheticTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTimingSyntheticTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTimingSyntheticTaskResponse) GoString() string {
	return s.String()
}

func (s *DeleteTimingSyntheticTaskResponse) SetHeaders(v map[string]*string) *DeleteTimingSyntheticTaskResponse {
	s.Headers = v
	return s
}

func (s *DeleteTimingSyntheticTaskResponse) SetStatusCode(v int32) *DeleteTimingSyntheticTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTimingSyntheticTaskResponse) SetBody(v *DeleteTimingSyntheticTaskResponseBody) *DeleteTimingSyntheticTaskResponse {
	s.Body = v
	return s
}

type DeleteTraceAppRequest struct {
	// The ID of the application that you want to delete. You can call the SearchTraceAppByName operation to query the application ID. For more information, see [SearchTraceAppByName](~~130676~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The reason(s) to delete application.
	DeleteReason *DeleteTraceAppRequestDeleteReason `json:"DeleteReason,omitempty" xml:"DeleteReason,omitempty" type:"Struct"`
	// The PID of the application. For more information about how to query the PID, see [QueryMetricByPage](https://www.alibabacloud.com/help/zh/doc-detail/186100.htm?spm=a2cdw.13409063.0.0.7a72281f0bkTfx#title-imy-7gj-qhr).
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The ID of the region in which the application is located.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The type of the application that you want to delete. You can call the SearchTraceAppByName operation to query the application type. For more information, see [SearchTraceAppByName](~~130676~~). Valid values:
	//
	// *   `TRACE`: Application Monitoring
	// *   `RETCODE`: frontend monitoring
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DeleteTraceAppRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTraceAppRequest) GoString() string {
	return s.String()
}

func (s *DeleteTraceAppRequest) SetAppId(v string) *DeleteTraceAppRequest {
	s.AppId = &v
	return s
}

func (s *DeleteTraceAppRequest) SetDeleteReason(v *DeleteTraceAppRequestDeleteReason) *DeleteTraceAppRequest {
	s.DeleteReason = v
	return s
}

func (s *DeleteTraceAppRequest) SetPid(v string) *DeleteTraceAppRequest {
	s.Pid = &v
	return s
}

func (s *DeleteTraceAppRequest) SetRegionId(v string) *DeleteTraceAppRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteTraceAppRequest) SetType(v string) *DeleteTraceAppRequest {
	s.Type = &v
	return s
}

type DeleteTraceAppRequestDeleteReason struct {
	// Reasons Ids.
	ReasonIds []*DeleteTraceAppRequestDeleteReasonReasonIds `json:"ReasonIds,omitempty" xml:"ReasonIds,omitempty" type:"Repeated"`
	// Additional remarks when none of the reasons for removal provided are met.
	Remark *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
}

func (s DeleteTraceAppRequestDeleteReason) String() string {
	return tea.Prettify(s)
}

func (s DeleteTraceAppRequestDeleteReason) GoString() string {
	return s.String()
}

func (s *DeleteTraceAppRequestDeleteReason) SetReasonIds(v []*DeleteTraceAppRequestDeleteReasonReasonIds) *DeleteTraceAppRequestDeleteReason {
	s.ReasonIds = v
	return s
}

func (s *DeleteTraceAppRequestDeleteReason) SetRemark(v string) *DeleteTraceAppRequestDeleteReason {
	s.Remark = &v
	return s
}

type DeleteTraceAppRequestDeleteReasonReasonIds struct {
	// The ID of the reason for deletion.
	Id *int32 `json:"Id,omitempty" xml:"Id,omitempty"`
	// A description of the reason for removal.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s DeleteTraceAppRequestDeleteReasonReasonIds) String() string {
	return tea.Prettify(s)
}

func (s DeleteTraceAppRequestDeleteReasonReasonIds) GoString() string {
	return s.String()
}

func (s *DeleteTraceAppRequestDeleteReasonReasonIds) SetId(v int32) *DeleteTraceAppRequestDeleteReasonReasonIds {
	s.Id = &v
	return s
}

func (s *DeleteTraceAppRequestDeleteReasonReasonIds) SetName(v string) *DeleteTraceAppRequestDeleteReasonReasonIds {
	s.Name = &v
	return s
}

type DeleteTraceAppShrinkRequest struct {
	// The ID of the application that you want to delete. You can call the SearchTraceAppByName operation to query the application ID. For more information, see [SearchTraceAppByName](~~130676~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The reason(s) to delete application.
	DeleteReasonShrink *string `json:"DeleteReason,omitempty" xml:"DeleteReason,omitempty"`
	// The PID of the application. For more information about how to query the PID, see [QueryMetricByPage](https://www.alibabacloud.com/help/zh/doc-detail/186100.htm?spm=a2cdw.13409063.0.0.7a72281f0bkTfx#title-imy-7gj-qhr).
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The ID of the region in which the application is located.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The type of the application that you want to delete. You can call the SearchTraceAppByName operation to query the application type. For more information, see [SearchTraceAppByName](~~130676~~). Valid values:
	//
	// *   `TRACE`: Application Monitoring
	// *   `RETCODE`: frontend monitoring
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DeleteTraceAppShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTraceAppShrinkRequest) GoString() string {
	return s.String()
}

func (s *DeleteTraceAppShrinkRequest) SetAppId(v string) *DeleteTraceAppShrinkRequest {
	s.AppId = &v
	return s
}

func (s *DeleteTraceAppShrinkRequest) SetDeleteReasonShrink(v string) *DeleteTraceAppShrinkRequest {
	s.DeleteReasonShrink = &v
	return s
}

func (s *DeleteTraceAppShrinkRequest) SetPid(v string) *DeleteTraceAppShrinkRequest {
	s.Pid = &v
	return s
}

func (s *DeleteTraceAppShrinkRequest) SetRegionId(v string) *DeleteTraceAppShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteTraceAppShrinkRequest) SetType(v string) *DeleteTraceAppShrinkRequest {
	s.Type = &v
	return s
}

type DeleteTraceAppResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful.
	Code *int64 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The response in JSON format, including the HTTP status code, error code, response message, and trace ID.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// true: The request was successful.
	//
	// false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteTraceAppResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTraceAppResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTraceAppResponseBody) SetCode(v int64) *DeleteTraceAppResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteTraceAppResponseBody) SetData(v string) *DeleteTraceAppResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteTraceAppResponseBody) SetMessage(v string) *DeleteTraceAppResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteTraceAppResponseBody) SetRequestId(v string) *DeleteTraceAppResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteTraceAppResponseBody) SetSuccess(v bool) *DeleteTraceAppResponseBody {
	s.Success = &v
	return s
}

type DeleteTraceAppResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTraceAppResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTraceAppResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTraceAppResponse) GoString() string {
	return s.String()
}

func (s *DeleteTraceAppResponse) SetHeaders(v map[string]*string) *DeleteTraceAppResponse {
	s.Headers = v
	return s
}

func (s *DeleteTraceAppResponse) SetStatusCode(v int32) *DeleteTraceAppResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTraceAppResponse) SetBody(v *DeleteTraceAppResponseBody) *DeleteTraceAppResponse {
	s.Body = v
	return s
}

type DeleteWebhookContactRequest struct {
	WebhookId *int64 `json:"WebhookId,omitempty" xml:"WebhookId,omitempty"`
}

func (s DeleteWebhookContactRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteWebhookContactRequest) GoString() string {
	return s.String()
}

func (s *DeleteWebhookContactRequest) SetWebhookId(v int64) *DeleteWebhookContactRequest {
	s.WebhookId = &v
	return s
}

type DeleteWebhookContactResponseBody struct {
	IsSuccess *bool   `json:"IsSuccess,omitempty" xml:"IsSuccess,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteWebhookContactResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteWebhookContactResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteWebhookContactResponseBody) SetIsSuccess(v bool) *DeleteWebhookContactResponseBody {
	s.IsSuccess = &v
	return s
}

func (s *DeleteWebhookContactResponseBody) SetRequestId(v string) *DeleteWebhookContactResponseBody {
	s.RequestId = &v
	return s
}

type DeleteWebhookContactResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteWebhookContactResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteWebhookContactResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteWebhookContactResponse) GoString() string {
	return s.String()
}

func (s *DeleteWebhookContactResponse) SetHeaders(v map[string]*string) *DeleteWebhookContactResponse {
	s.Headers = v
	return s
}

func (s *DeleteWebhookContactResponse) SetStatusCode(v int32) *DeleteWebhookContactResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteWebhookContactResponse) SetBody(v *DeleteWebhookContactResponseBody) *DeleteWebhookContactResponse {
	s.Body = v
	return s
}

type DescribeAddonReleaseRequest struct {
	// Environment ID.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Name of Release.
	ReleaseName *string `json:"ReleaseName,omitempty" xml:"ReleaseName,omitempty"`
}

func (s DescribeAddonReleaseRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAddonReleaseRequest) GoString() string {
	return s.String()
}

func (s *DescribeAddonReleaseRequest) SetEnvironmentId(v string) *DescribeAddonReleaseRequest {
	s.EnvironmentId = &v
	return s
}

func (s *DescribeAddonReleaseRequest) SetRegionId(v string) *DescribeAddonReleaseRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeAddonReleaseRequest) SetReleaseName(v string) *DescribeAddonReleaseRequest {
	s.ReleaseName = &v
	return s
}

type DescribeAddonReleaseResponseBody struct {
	// Status code: 200 indicates success.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The struct returned.
	Data *DescribeAddonReleaseResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the alert rule was deleted. Valid values:
	//
	// *   `true`: The alert rule was deleted.
	// *   `false`: The alert rule failed to be deleted.
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DescribeAddonReleaseResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAddonReleaseResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAddonReleaseResponseBody) SetCode(v string) *DescribeAddonReleaseResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeAddonReleaseResponseBody) SetData(v *DescribeAddonReleaseResponseBodyData) *DescribeAddonReleaseResponseBody {
	s.Data = v
	return s
}

func (s *DescribeAddonReleaseResponseBody) SetMessage(v string) *DescribeAddonReleaseResponseBody {
	s.Message = &v
	return s
}

func (s *DescribeAddonReleaseResponseBody) SetRequestId(v string) *DescribeAddonReleaseResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeAddonReleaseResponseBody) SetSuccess(v string) *DescribeAddonReleaseResponseBody {
	s.Success = &v
	return s
}

type DescribeAddonReleaseResponseBodyData struct {
	// Config of the Release.
	Config *string `json:"Config,omitempty" xml:"Config,omitempty"`
	// Release Detail.
	Release *DescribeAddonReleaseResponseBodyDataRelease `json:"Release,omitempty" xml:"Release,omitempty" type:"Struct"`
}

func (s DescribeAddonReleaseResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeAddonReleaseResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeAddonReleaseResponseBodyData) SetConfig(v string) *DescribeAddonReleaseResponseBodyData {
	s.Config = &v
	return s
}

func (s *DescribeAddonReleaseResponseBodyData) SetRelease(v *DescribeAddonReleaseResponseBodyDataRelease) *DescribeAddonReleaseResponseBodyData {
	s.Release = v
	return s
}

type DescribeAddonReleaseResponseBodyDataRelease struct {
	// Name of Addon.
	AddonName *string `json:"AddonName,omitempty" xml:"AddonName,omitempty"`
	// Number of alarm groups.
	AlertRuleCount *int64 `json:"AlertRuleCount,omitempty" xml:"AlertRuleCount,omitempty"`
	// Condition list.
	Conditions []*DescribeAddonReleaseResponseBodyDataReleaseConditions `json:"Conditions,omitempty" xml:"Conditions,omitempty" type:"Repeated"`
	// Create time.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// Number of dashboard.
	DashboardCount *int64 `json:"DashboardCount,omitempty" xml:"DashboardCount,omitempty"`
	// Environment ID.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// Number of Exporter.
	ExporterCount *int64 `json:"ExporterCount,omitempty" xml:"ExporterCount,omitempty"`
	// Whether there is configuration.
	HaveConfig *bool `json:"HaveConfig,omitempty" xml:"HaveConfig,omitempty"`
	// User ID of the installation.
	InstallUserId *string `json:"InstallUserId,omitempty" xml:"InstallUserId,omitempty"`
	// Language.
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Release ID.
	ReleaseId *string `json:"ReleaseId,omitempty" xml:"ReleaseId,omitempty"`
	// Name of Release.
	ReleaseName *string `json:"ReleaseName,omitempty" xml:"ReleaseName,omitempty"`
	// Scene.
	Scene *string `json:"Scene,omitempty" xml:"Scene,omitempty"`
	// Status of Release.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// Update time.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// User ID.
	UserID *string `json:"UserID,omitempty" xml:"UserID,omitempty"`
	// Version of Addon.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s DescribeAddonReleaseResponseBodyDataRelease) String() string {
	return tea.Prettify(s)
}

func (s DescribeAddonReleaseResponseBodyDataRelease) GoString() string {
	return s.String()
}

func (s *DescribeAddonReleaseResponseBodyDataRelease) SetAddonName(v string) *DescribeAddonReleaseResponseBodyDataRelease {
	s.AddonName = &v
	return s
}

func (s *DescribeAddonReleaseResponseBodyDataRelease) SetAlertRuleCount(v int64) *DescribeAddonReleaseResponseBodyDataRelease {
	s.AlertRuleCount = &v
	return s
}

func (s *DescribeAddonReleaseResponseBodyDataRelease) SetConditions(v []*DescribeAddonReleaseResponseBodyDataReleaseConditions) *DescribeAddonReleaseResponseBodyDataRelease {
	s.Conditions = v
	return s
}

func (s *DescribeAddonReleaseResponseBodyDataRelease) SetCreateTime(v string) *DescribeAddonReleaseResponseBodyDataRelease {
	s.CreateTime = &v
	return s
}

func (s *DescribeAddonReleaseResponseBodyDataRelease) SetDashboardCount(v int64) *DescribeAddonReleaseResponseBodyDataRelease {
	s.DashboardCount = &v
	return s
}

func (s *DescribeAddonReleaseResponseBodyDataRelease) SetEnvironmentId(v string) *DescribeAddonReleaseResponseBodyDataRelease {
	s.EnvironmentId = &v
	return s
}

func (s *DescribeAddonReleaseResponseBodyDataRelease) SetExporterCount(v int64) *DescribeAddonReleaseResponseBodyDataRelease {
	s.ExporterCount = &v
	return s
}

func (s *DescribeAddonReleaseResponseBodyDataRelease) SetHaveConfig(v bool) *DescribeAddonReleaseResponseBodyDataRelease {
	s.HaveConfig = &v
	return s
}

func (s *DescribeAddonReleaseResponseBodyDataRelease) SetInstallUserId(v string) *DescribeAddonReleaseResponseBodyDataRelease {
	s.InstallUserId = &v
	return s
}

func (s *DescribeAddonReleaseResponseBodyDataRelease) SetLanguage(v string) *DescribeAddonReleaseResponseBodyDataRelease {
	s.Language = &v
	return s
}

func (s *DescribeAddonReleaseResponseBodyDataRelease) SetRegionId(v string) *DescribeAddonReleaseResponseBodyDataRelease {
	s.RegionId = &v
	return s
}

func (s *DescribeAddonReleaseResponseBodyDataRelease) SetReleaseId(v string) *DescribeAddonReleaseResponseBodyDataRelease {
	s.ReleaseId = &v
	return s
}

func (s *DescribeAddonReleaseResponseBodyDataRelease) SetReleaseName(v string) *DescribeAddonReleaseResponseBodyDataRelease {
	s.ReleaseName = &v
	return s
}

func (s *DescribeAddonReleaseResponseBodyDataRelease) SetScene(v string) *DescribeAddonReleaseResponseBodyDataRelease {
	s.Scene = &v
	return s
}

func (s *DescribeAddonReleaseResponseBodyDataRelease) SetStatus(v string) *DescribeAddonReleaseResponseBodyDataRelease {
	s.Status = &v
	return s
}

func (s *DescribeAddonReleaseResponseBodyDataRelease) SetUpdateTime(v string) *DescribeAddonReleaseResponseBodyDataRelease {
	s.UpdateTime = &v
	return s
}

func (s *DescribeAddonReleaseResponseBodyDataRelease) SetUserID(v string) *DescribeAddonReleaseResponseBodyDataRelease {
	s.UserID = &v
	return s
}

func (s *DescribeAddonReleaseResponseBodyDataRelease) SetVersion(v string) *DescribeAddonReleaseResponseBodyDataRelease {
	s.Version = &v
	return s
}

type DescribeAddonReleaseResponseBodyDataReleaseConditions struct {
	// First transition time.
	FirstTransitionTime *string `json:"FirstTransitionTime,omitempty" xml:"FirstTransitionTime,omitempty"`
	// Last transition time.
	LastTransitionTime *string `json:"LastTransitionTime,omitempty" xml:"LastTransitionTime,omitempty"`
	// COndition details.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Reason of failure.
	Reason *string `json:"Reason,omitempty" xml:"Reason,omitempty"`
	// Condition status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// Condition type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeAddonReleaseResponseBodyDataReleaseConditions) String() string {
	return tea.Prettify(s)
}

func (s DescribeAddonReleaseResponseBodyDataReleaseConditions) GoString() string {
	return s.String()
}

func (s *DescribeAddonReleaseResponseBodyDataReleaseConditions) SetFirstTransitionTime(v string) *DescribeAddonReleaseResponseBodyDataReleaseConditions {
	s.FirstTransitionTime = &v
	return s
}

func (s *DescribeAddonReleaseResponseBodyDataReleaseConditions) SetLastTransitionTime(v string) *DescribeAddonReleaseResponseBodyDataReleaseConditions {
	s.LastTransitionTime = &v
	return s
}

func (s *DescribeAddonReleaseResponseBodyDataReleaseConditions) SetMessage(v string) *DescribeAddonReleaseResponseBodyDataReleaseConditions {
	s.Message = &v
	return s
}

func (s *DescribeAddonReleaseResponseBodyDataReleaseConditions) SetReason(v string) *DescribeAddonReleaseResponseBodyDataReleaseConditions {
	s.Reason = &v
	return s
}

func (s *DescribeAddonReleaseResponseBodyDataReleaseConditions) SetStatus(v string) *DescribeAddonReleaseResponseBodyDataReleaseConditions {
	s.Status = &v
	return s
}

func (s *DescribeAddonReleaseResponseBodyDataReleaseConditions) SetType(v string) *DescribeAddonReleaseResponseBodyDataReleaseConditions {
	s.Type = &v
	return s
}

type DescribeAddonReleaseResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeAddonReleaseResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeAddonReleaseResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAddonReleaseResponse) GoString() string {
	return s.String()
}

func (s *DescribeAddonReleaseResponse) SetHeaders(v map[string]*string) *DescribeAddonReleaseResponse {
	s.Headers = v
	return s
}

func (s *DescribeAddonReleaseResponse) SetStatusCode(v int32) *DescribeAddonReleaseResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAddonReleaseResponse) SetBody(v *DescribeAddonReleaseResponseBody) *DescribeAddonReleaseResponse {
	s.Body = v
	return s
}

type DescribeContactGroupsRequest struct {
	// The name of the alert contact group.
	ContactGroupName *string `json:"ContactGroupName,omitempty" xml:"ContactGroupName,omitempty"`
	// The ID of the alert contact group.
	GroupIds *string `json:"GroupIds,omitempty" xml:"GroupIds,omitempty"`
	// Specifies whether to return all the alert contacts in the queried alert contact group. Valid values:
	//
	// *   `false`
	// *   `true`
	IsDetail *bool `json:"IsDetail,omitempty" xml:"IsDetail,omitempty"`
	// The number of the page to return.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The number of alert contact groups displayed on each page.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
}

func (s DescribeContactGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeContactGroupsRequest) GoString() string {
	return s.String()
}

func (s *DescribeContactGroupsRequest) SetContactGroupName(v string) *DescribeContactGroupsRequest {
	s.ContactGroupName = &v
	return s
}

func (s *DescribeContactGroupsRequest) SetGroupIds(v string) *DescribeContactGroupsRequest {
	s.GroupIds = &v
	return s
}

func (s *DescribeContactGroupsRequest) SetIsDetail(v bool) *DescribeContactGroupsRequest {
	s.IsDetail = &v
	return s
}

func (s *DescribeContactGroupsRequest) SetPage(v int64) *DescribeContactGroupsRequest {
	s.Page = &v
	return s
}

func (s *DescribeContactGroupsRequest) SetRegionId(v string) *DescribeContactGroupsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeContactGroupsRequest) SetSize(v int64) *DescribeContactGroupsRequest {
	s.Size = &v
	return s
}

type DescribeContactGroupsResponseBody struct {
	// The objects that were returned.
	PageBean *DescribeContactGroupsResponseBodyPageBean `json:"PageBean,omitempty" xml:"PageBean,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeContactGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeContactGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeContactGroupsResponseBody) SetPageBean(v *DescribeContactGroupsResponseBodyPageBean) *DescribeContactGroupsResponseBody {
	s.PageBean = v
	return s
}

func (s *DescribeContactGroupsResponseBody) SetRequestId(v string) *DescribeContactGroupsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeContactGroupsResponseBodyPageBean struct {
	// The name of the alert contact group.
	AlertContactGroups []*DescribeContactGroupsResponseBodyPageBeanAlertContactGroups `json:"AlertContactGroups,omitempty" xml:"AlertContactGroups,omitempty" type:"Repeated"`
	// The page number of the returned page.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of alert contact groups displayed on each page.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The total number of alert contact groups.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s DescribeContactGroupsResponseBodyPageBean) String() string {
	return tea.Prettify(s)
}

func (s DescribeContactGroupsResponseBodyPageBean) GoString() string {
	return s.String()
}

func (s *DescribeContactGroupsResponseBodyPageBean) SetAlertContactGroups(v []*DescribeContactGroupsResponseBodyPageBeanAlertContactGroups) *DescribeContactGroupsResponseBodyPageBean {
	s.AlertContactGroups = v
	return s
}

func (s *DescribeContactGroupsResponseBodyPageBean) SetPage(v int64) *DescribeContactGroupsResponseBodyPageBean {
	s.Page = &v
	return s
}

func (s *DescribeContactGroupsResponseBodyPageBean) SetSize(v int64) *DescribeContactGroupsResponseBodyPageBean {
	s.Size = &v
	return s
}

func (s *DescribeContactGroupsResponseBodyPageBean) SetTotal(v int64) *DescribeContactGroupsResponseBodyPageBean {
	s.Total = &v
	return s
}

type DescribeContactGroupsResponseBodyPageBeanAlertContactGroups struct {
	// The ID of the alert contact group.
	ArmsContactGroupId *int64 `json:"ArmsContactGroupId,omitempty" xml:"ArmsContactGroupId,omitempty"`
	// The ID of the alert contact group.
	ContactGroupId *float32 `json:"ContactGroupId,omitempty" xml:"ContactGroupId,omitempty"`
	// The name of the alert contact group.
	ContactGroupName *string `json:"ContactGroupName,omitempty" xml:"ContactGroupName,omitempty"`
	// The contact information. If the **IsDetail** parameter is set to `false`, no **contact** information is displayed.
	Contacts []*DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts `json:"Contacts,omitempty" xml:"Contacts,omitempty" type:"Repeated"`
}

func (s DescribeContactGroupsResponseBodyPageBeanAlertContactGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribeContactGroupsResponseBodyPageBeanAlertContactGroups) GoString() string {
	return s.String()
}

func (s *DescribeContactGroupsResponseBodyPageBeanAlertContactGroups) SetArmsContactGroupId(v int64) *DescribeContactGroupsResponseBodyPageBeanAlertContactGroups {
	s.ArmsContactGroupId = &v
	return s
}

func (s *DescribeContactGroupsResponseBodyPageBeanAlertContactGroups) SetContactGroupId(v float32) *DescribeContactGroupsResponseBodyPageBeanAlertContactGroups {
	s.ContactGroupId = &v
	return s
}

func (s *DescribeContactGroupsResponseBodyPageBeanAlertContactGroups) SetContactGroupName(v string) *DescribeContactGroupsResponseBodyPageBeanAlertContactGroups {
	s.ContactGroupName = &v
	return s
}

func (s *DescribeContactGroupsResponseBodyPageBeanAlertContactGroups) SetContacts(v []*DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts) *DescribeContactGroupsResponseBodyPageBeanAlertContactGroups {
	s.Contacts = v
	return s
}

type DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts struct {
	// The ID of the alert contact.
	ArmsContactId *int64 `json:"ArmsContactId,omitempty" xml:"ArmsContactId,omitempty"`
	// The ID of the alert contact.
	ContactId *float32 `json:"ContactId,omitempty" xml:"ContactId,omitempty"`
	// The name of the alert contact.
	ContactName *string `json:"ContactName,omitempty" xml:"ContactName,omitempty"`
	// The email address of the alert contact.
	Email *string `json:"Email,omitempty" xml:"Email,omitempty"`
	// The mobile number of the alert contact.
	Phone *string `json:"Phone,omitempty" xml:"Phone,omitempty"`
}

func (s DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts) String() string {
	return tea.Prettify(s)
}

func (s DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts) GoString() string {
	return s.String()
}

func (s *DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts) SetArmsContactId(v int64) *DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts {
	s.ArmsContactId = &v
	return s
}

func (s *DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts) SetContactId(v float32) *DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts {
	s.ContactId = &v
	return s
}

func (s *DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts) SetContactName(v string) *DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts {
	s.ContactName = &v
	return s
}

func (s *DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts) SetEmail(v string) *DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts {
	s.Email = &v
	return s
}

func (s *DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts) SetPhone(v string) *DescribeContactGroupsResponseBodyPageBeanAlertContactGroupsContacts {
	s.Phone = &v
	return s
}

type DescribeContactGroupsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeContactGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeContactGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeContactGroupsResponse) GoString() string {
	return s.String()
}

func (s *DescribeContactGroupsResponse) SetHeaders(v map[string]*string) *DescribeContactGroupsResponse {
	s.Headers = v
	return s
}

func (s *DescribeContactGroupsResponse) SetStatusCode(v int32) *DescribeContactGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeContactGroupsResponse) SetBody(v *DescribeContactGroupsResponseBody) *DescribeContactGroupsResponse {
	s.Body = v
	return s
}

type DescribeContactsRequest struct {
	// The ID of the alert contact that you want to query. Separate multiple contact IDs with spaces.
	ContactIds *string `json:"ContactIds,omitempty" xml:"ContactIds,omitempty"`
	// The name of the alert contact.
	ContactName *string `json:"ContactName,omitempty" xml:"ContactName,omitempty"`
	// The email address of the alert contact.
	Email *string `json:"Email,omitempty" xml:"Email,omitempty"`
	// The number of the page to return.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The mobile number of the alert contact.
	Phone *string `json:"Phone,omitempty" xml:"Phone,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The number of alert contacts to return on each page.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// Specifies whether to return redundant information.
	Verbose *string `json:"Verbose,omitempty" xml:"Verbose,omitempty"`
}

func (s DescribeContactsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeContactsRequest) GoString() string {
	return s.String()
}

func (s *DescribeContactsRequest) SetContactIds(v string) *DescribeContactsRequest {
	s.ContactIds = &v
	return s
}

func (s *DescribeContactsRequest) SetContactName(v string) *DescribeContactsRequest {
	s.ContactName = &v
	return s
}

func (s *DescribeContactsRequest) SetEmail(v string) *DescribeContactsRequest {
	s.Email = &v
	return s
}

func (s *DescribeContactsRequest) SetPage(v int64) *DescribeContactsRequest {
	s.Page = &v
	return s
}

func (s *DescribeContactsRequest) SetPhone(v string) *DescribeContactsRequest {
	s.Phone = &v
	return s
}

func (s *DescribeContactsRequest) SetRegionId(v string) *DescribeContactsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeContactsRequest) SetSize(v int64) *DescribeContactsRequest {
	s.Size = &v
	return s
}

func (s *DescribeContactsRequest) SetVerbose(v string) *DescribeContactsRequest {
	s.Verbose = &v
	return s
}

type DescribeContactsResponseBody struct {
	// The objects that were returned.
	PageBean *DescribeContactsResponseBodyPageBean `json:"PageBean,omitempty" xml:"PageBean,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeContactsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeContactsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeContactsResponseBody) SetPageBean(v *DescribeContactsResponseBodyPageBean) *DescribeContactsResponseBody {
	s.PageBean = v
	return s
}

func (s *DescribeContactsResponseBody) SetRequestId(v string) *DescribeContactsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeContactsResponseBodyPageBean struct {
	// The alert contacts.
	AlertContacts []*DescribeContactsResponseBodyPageBeanAlertContacts `json:"AlertContacts,omitempty" xml:"AlertContacts,omitempty" type:"Repeated"`
	// The page number of the returned page.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of alert contacts returned per page.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The total number of alert contacts.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s DescribeContactsResponseBodyPageBean) String() string {
	return tea.Prettify(s)
}

func (s DescribeContactsResponseBodyPageBean) GoString() string {
	return s.String()
}

func (s *DescribeContactsResponseBodyPageBean) SetAlertContacts(v []*DescribeContactsResponseBodyPageBeanAlertContacts) *DescribeContactsResponseBodyPageBean {
	s.AlertContacts = v
	return s
}

func (s *DescribeContactsResponseBodyPageBean) SetPage(v int64) *DescribeContactsResponseBodyPageBean {
	s.Page = &v
	return s
}

func (s *DescribeContactsResponseBodyPageBean) SetSize(v int64) *DescribeContactsResponseBodyPageBean {
	s.Size = &v
	return s
}

func (s *DescribeContactsResponseBodyPageBean) SetTotal(v int64) *DescribeContactsResponseBodyPageBean {
	s.Total = &v
	return s
}

type DescribeContactsResponseBodyPageBeanAlertContacts struct {
	// The ID of the alert contact.
	ArmsContactId *int64 `json:"ArmsContactId,omitempty" xml:"ArmsContactId,omitempty"`
	// The ID of the alert contact.
	ContactId *float32 `json:"ContactId,omitempty" xml:"ContactId,omitempty"`
	// The name of the alert contact.
	ContactName *string `json:"ContactName,omitempty" xml:"ContactName,omitempty"`
	// The email address of the alert contact.
	Email *string `json:"Email,omitempty" xml:"Email,omitempty"`
	// Indicates whether the email address was verified.
	IsEmailVerify *bool `json:"IsEmailVerify,omitempty" xml:"IsEmailVerify,omitempty"`
	// Indicates whether the mobile number was verified. Valid values:
	//
	// *   `false`: no
	// *   `true`: yes
	IsVerify *bool `json:"IsVerify,omitempty" xml:"IsVerify,omitempty"`
	// The mobile number of the alert contact.
	Phone *string `json:"Phone,omitempty" xml:"Phone,omitempty"`
	// The operation that you want to perform if phone calls fail to be answered. Valid values:
	//
	// *   0: No operation is performed.
	// *   1: A phone call is made again.
	// *   2: A text message is sent.
	// *   3 (default value): The global default value is used.
	ReissueSendNotice *int64 `json:"ReissueSendNotice,omitempty" xml:"ReissueSendNotice,omitempty"`
}

func (s DescribeContactsResponseBodyPageBeanAlertContacts) String() string {
	return tea.Prettify(s)
}

func (s DescribeContactsResponseBodyPageBeanAlertContacts) GoString() string {
	return s.String()
}

func (s *DescribeContactsResponseBodyPageBeanAlertContacts) SetArmsContactId(v int64) *DescribeContactsResponseBodyPageBeanAlertContacts {
	s.ArmsContactId = &v
	return s
}

func (s *DescribeContactsResponseBodyPageBeanAlertContacts) SetContactId(v float32) *DescribeContactsResponseBodyPageBeanAlertContacts {
	s.ContactId = &v
	return s
}

func (s *DescribeContactsResponseBodyPageBeanAlertContacts) SetContactName(v string) *DescribeContactsResponseBodyPageBeanAlertContacts {
	s.ContactName = &v
	return s
}

func (s *DescribeContactsResponseBodyPageBeanAlertContacts) SetEmail(v string) *DescribeContactsResponseBodyPageBeanAlertContacts {
	s.Email = &v
	return s
}

func (s *DescribeContactsResponseBodyPageBeanAlertContacts) SetIsEmailVerify(v bool) *DescribeContactsResponseBodyPageBeanAlertContacts {
	s.IsEmailVerify = &v
	return s
}

func (s *DescribeContactsResponseBodyPageBeanAlertContacts) SetIsVerify(v bool) *DescribeContactsResponseBodyPageBeanAlertContacts {
	s.IsVerify = &v
	return s
}

func (s *DescribeContactsResponseBodyPageBeanAlertContacts) SetPhone(v string) *DescribeContactsResponseBodyPageBeanAlertContacts {
	s.Phone = &v
	return s
}

func (s *DescribeContactsResponseBodyPageBeanAlertContacts) SetReissueSendNotice(v int64) *DescribeContactsResponseBodyPageBeanAlertContacts {
	s.ReissueSendNotice = &v
	return s
}

type DescribeContactsResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeContactsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeContactsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeContactsResponse) GoString() string {
	return s.String()
}

func (s *DescribeContactsResponse) SetHeaders(v map[string]*string) *DescribeContactsResponse {
	s.Headers = v
	return s
}

func (s *DescribeContactsResponse) SetStatusCode(v int32) *DescribeContactsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeContactsResponse) SetBody(v *DescribeContactsResponseBody) *DescribeContactsResponse {
	s.Body = v
	return s
}

type DescribeDispatchRuleRequest struct {
	// The ID of the dispatch policy.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeDispatchRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDispatchRuleRequest) GoString() string {
	return s.String()
}

func (s *DescribeDispatchRuleRequest) SetId(v string) *DescribeDispatchRuleRequest {
	s.Id = &v
	return s
}

func (s *DescribeDispatchRuleRequest) SetRegionId(v string) *DescribeDispatchRuleRequest {
	s.RegionId = &v
	return s
}

type DescribeDispatchRuleResponseBody struct {
	// The struct returned.
	DispatchRule *DescribeDispatchRuleResponseBodyDispatchRule `json:"DispatchRule,omitempty" xml:"DispatchRule,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDispatchRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDispatchRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDispatchRuleResponseBody) SetDispatchRule(v *DescribeDispatchRuleResponseBodyDispatchRule) *DescribeDispatchRuleResponseBody {
	s.DispatchRule = v
	return s
}

func (s *DescribeDispatchRuleResponseBody) SetRequestId(v string) *DescribeDispatchRuleResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDispatchRuleResponseBodyDispatchRule struct {
	// Alarm handling method.
	//
	// CREATE_ALERT: Generate an alert.
	//
	// DISCARD_ALERT: Discard the alarm event, that is, no alarm.
	DispatchType *string `json:"DispatchType,omitempty" xml:"DispatchType,omitempty"`
	// The information about groups.
	GroupRules []*DescribeDispatchRuleResponseBodyDispatchRuleGroupRules `json:"GroupRules,omitempty" xml:"GroupRules,omitempty" type:"Repeated"`
	// Whether to send recovered alerts.
	// true: send.
	// false: do not send.
	IsRecover *bool `json:"IsRecover,omitempty" xml:"IsRecover,omitempty"`
	// The information about the dispatch rule.
	LabelMatchExpressionGrid *DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid `json:"LabelMatchExpressionGrid,omitempty" xml:"LabelMatchExpressionGrid,omitempty" type:"Struct"`
	// The name of the dispatch policy.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The collection of notification methods.
	NotifyRules []*DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules `json:"NotifyRules,omitempty" xml:"NotifyRules,omitempty" type:"Repeated"`
	// The ID of the dispatch rule.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// Indicates whether the dispatch policy is enabled. Valid values:
	//
	// - `true`: enabled
	// - `false`: disabled
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s DescribeDispatchRuleResponseBodyDispatchRule) String() string {
	return tea.Prettify(s)
}

func (s DescribeDispatchRuleResponseBodyDispatchRule) GoString() string {
	return s.String()
}

func (s *DescribeDispatchRuleResponseBodyDispatchRule) SetDispatchType(v string) *DescribeDispatchRuleResponseBodyDispatchRule {
	s.DispatchType = &v
	return s
}

func (s *DescribeDispatchRuleResponseBodyDispatchRule) SetGroupRules(v []*DescribeDispatchRuleResponseBodyDispatchRuleGroupRules) *DescribeDispatchRuleResponseBodyDispatchRule {
	s.GroupRules = v
	return s
}

func (s *DescribeDispatchRuleResponseBodyDispatchRule) SetIsRecover(v bool) *DescribeDispatchRuleResponseBodyDispatchRule {
	s.IsRecover = &v
	return s
}

func (s *DescribeDispatchRuleResponseBodyDispatchRule) SetLabelMatchExpressionGrid(v *DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid) *DescribeDispatchRuleResponseBodyDispatchRule {
	s.LabelMatchExpressionGrid = v
	return s
}

func (s *DescribeDispatchRuleResponseBodyDispatchRule) SetName(v string) *DescribeDispatchRuleResponseBodyDispatchRule {
	s.Name = &v
	return s
}

func (s *DescribeDispatchRuleResponseBodyDispatchRule) SetNotifyRules(v []*DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules) *DescribeDispatchRuleResponseBodyDispatchRule {
	s.NotifyRules = v
	return s
}

func (s *DescribeDispatchRuleResponseBodyDispatchRule) SetRuleId(v int64) *DescribeDispatchRuleResponseBodyDispatchRule {
	s.RuleId = &v
	return s
}

func (s *DescribeDispatchRuleResponseBodyDispatchRule) SetState(v string) *DescribeDispatchRuleResponseBodyDispatchRule {
	s.State = &v
	return s
}

type DescribeDispatchRuleResponseBodyDispatchRuleGroupRules struct {
	// The ID of the group.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The grouping interval.
	GroupInterval *int64 `json:"GroupInterval,omitempty" xml:"GroupInterval,omitempty"`
	// The waiting time for grouping.
	GroupWaitTime *int64 `json:"GroupWaitTime,omitempty" xml:"GroupWaitTime,omitempty"`
	// The grouping fields.
	GroupingFields []*string `json:"GroupingFields,omitempty" xml:"GroupingFields,omitempty" type:"Repeated"`
	// The time interval at which a notification is resent for a long-lasting unresolved alert. Unit: seconds.
	RepeatInterval *int64 `json:"RepeatInterval,omitempty" xml:"RepeatInterval,omitempty"`
}

func (s DescribeDispatchRuleResponseBodyDispatchRuleGroupRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeDispatchRuleResponseBodyDispatchRuleGroupRules) GoString() string {
	return s.String()
}

func (s *DescribeDispatchRuleResponseBodyDispatchRuleGroupRules) SetGroupId(v int64) *DescribeDispatchRuleResponseBodyDispatchRuleGroupRules {
	s.GroupId = &v
	return s
}

func (s *DescribeDispatchRuleResponseBodyDispatchRuleGroupRules) SetGroupInterval(v int64) *DescribeDispatchRuleResponseBodyDispatchRuleGroupRules {
	s.GroupInterval = &v
	return s
}

func (s *DescribeDispatchRuleResponseBodyDispatchRuleGroupRules) SetGroupWaitTime(v int64) *DescribeDispatchRuleResponseBodyDispatchRuleGroupRules {
	s.GroupWaitTime = &v
	return s
}

func (s *DescribeDispatchRuleResponseBodyDispatchRuleGroupRules) SetGroupingFields(v []*string) *DescribeDispatchRuleResponseBodyDispatchRuleGroupRules {
	s.GroupingFields = v
	return s
}

func (s *DescribeDispatchRuleResponseBodyDispatchRuleGroupRules) SetRepeatInterval(v int64) *DescribeDispatchRuleResponseBodyDispatchRuleGroupRules {
	s.RepeatInterval = &v
	return s
}

type DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid struct {
	// The collection of dispatch rules.
	LabelMatchExpressionGroups []*DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups `json:"LabelMatchExpressionGroups,omitempty" xml:"LabelMatchExpressionGroups,omitempty" type:"Repeated"`
}

func (s DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid) String() string {
	return tea.Prettify(s)
}

func (s DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid) GoString() string {
	return s.String()
}

func (s *DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid) SetLabelMatchExpressionGroups(v []*DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups) *DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGrid {
	s.LabelMatchExpressionGroups = v
	return s
}

type DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups struct {
	// The collection of conditions of the dispatch rule.
	LabelMatchExpressions []*DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions `json:"LabelMatchExpressions,omitempty" xml:"LabelMatchExpressions,omitempty" type:"Repeated"`
}

func (s DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups) GoString() string {
	return s.String()
}

func (s *DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups) SetLabelMatchExpressions(v []*DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions) *DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroups {
	s.LabelMatchExpressions = v
	return s
}

type DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions struct {
	// The key of the tag of the dispatch rule. Valid values:
	//
	// *   `_aliyun_arms_userid`: user ID
	// *   `_aliyun_arms_involvedObject_kind`: type of the associated object
	// *   `_aliyun_arms_involvedObject_id`: ID of the associated object
	// *   `_aliyun_arms_involvedObject_name`: name of the associated object
	// *   `_aliyun_arms_alert_name`: alert name
	// *   `_aliyun_arms_alert_rule_id`: alert rule ID
	// *   `_aliyun_arms_alert_type`: alert type
	// *   `_aliyun_arms_alert_level`: alert severity
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The operator used in the dispatch rule. Valid values:
	//
	// *   `eq`: equals to.
	// *   `re`: matches a regular expression.
	Operator *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions) String() string {
	return tea.Prettify(s)
}

func (s DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions) GoString() string {
	return s.String()
}

func (s *DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions) SetKey(v string) *DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions {
	s.Key = &v
	return s
}

func (s *DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions) SetOperator(v string) *DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions {
	s.Operator = &v
	return s
}

func (s *DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions) SetValue(v string) *DescribeDispatchRuleResponseBodyDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupsLabelMatchExpressions {
	s.Value = &v
	return s
}

type DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules struct {
	// The notification method Array.
	NotifyChannels []*string `json:"NotifyChannels,omitempty" xml:"NotifyChannels,omitempty" type:"Repeated"`
	// The collection of alert contacts.
	NotifyObjects []*DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects `json:"NotifyObjects,omitempty" xml:"NotifyObjects,omitempty" type:"Repeated"`
}

func (s DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules) GoString() string {
	return s.String()
}

func (s *DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules) SetNotifyChannels(v []*string) *DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules {
	s.NotifyChannels = v
	return s
}

func (s *DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules) SetNotifyObjects(v []*DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects) *DescribeDispatchRuleResponseBodyDispatchRuleNotifyRules {
	s.NotifyObjects = v
	return s
}

type DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects struct {
	// The name of the contact or contact group.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the contact or contact group.
	NotifyObjectId *string `json:"NotifyObjectId,omitempty" xml:"NotifyObjectId,omitempty"`
	// The type of the alert contact. Valid values:
	//
	// - `CONTACT`: contact
	// - `CONTACT_GROUP`: contact group
	NotifyType *string `json:"NotifyType,omitempty" xml:"NotifyType,omitempty"`
}

func (s DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects) String() string {
	return tea.Prettify(s)
}

func (s DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects) GoString() string {
	return s.String()
}

func (s *DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects) SetName(v string) *DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects {
	s.Name = &v
	return s
}

func (s *DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects) SetNotifyObjectId(v string) *DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects {
	s.NotifyObjectId = &v
	return s
}

func (s *DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects) SetNotifyType(v string) *DescribeDispatchRuleResponseBodyDispatchRuleNotifyRulesNotifyObjects {
	s.NotifyType = &v
	return s
}

type DescribeDispatchRuleResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDispatchRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDispatchRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDispatchRuleResponse) GoString() string {
	return s.String()
}

func (s *DescribeDispatchRuleResponse) SetHeaders(v map[string]*string) *DescribeDispatchRuleResponse {
	s.Headers = v
	return s
}

func (s *DescribeDispatchRuleResponse) SetStatusCode(v int32) *DescribeDispatchRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDispatchRuleResponse) SetBody(v *DescribeDispatchRuleResponseBody) *DescribeDispatchRuleResponse {
	s.Body = v
	return s
}

type DescribeEnvCustomJobRequest struct {
	// The name of the custom job.
	CustomJobName *string `json:"CustomJobName,omitempty" xml:"CustomJobName,omitempty"`
	// Specifies whether to return the encrypted YAML string.
	EncryptYaml *bool `json:"EncryptYaml,omitempty" xml:"EncryptYaml,omitempty"`
	// The ID of the environment instance.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeEnvCustomJobRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvCustomJobRequest) GoString() string {
	return s.String()
}

func (s *DescribeEnvCustomJobRequest) SetCustomJobName(v string) *DescribeEnvCustomJobRequest {
	s.CustomJobName = &v
	return s
}

func (s *DescribeEnvCustomJobRequest) SetEncryptYaml(v bool) *DescribeEnvCustomJobRequest {
	s.EncryptYaml = &v
	return s
}

func (s *DescribeEnvCustomJobRequest) SetEnvironmentId(v string) *DescribeEnvCustomJobRequest {
	s.EnvironmentId = &v
	return s
}

func (s *DescribeEnvCustomJobRequest) SetRegionId(v string) *DescribeEnvCustomJobRequest {
	s.RegionId = &v
	return s
}

type DescribeEnvCustomJobResponseBody struct {
	// The HTTP status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned struct.
	Data *DescribeEnvCustomJobResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeEnvCustomJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvCustomJobResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeEnvCustomJobResponseBody) SetCode(v int32) *DescribeEnvCustomJobResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeEnvCustomJobResponseBody) SetData(v *DescribeEnvCustomJobResponseBodyData) *DescribeEnvCustomJobResponseBody {
	s.Data = v
	return s
}

func (s *DescribeEnvCustomJobResponseBody) SetMessage(v string) *DescribeEnvCustomJobResponseBody {
	s.Message = &v
	return s
}

func (s *DescribeEnvCustomJobResponseBody) SetRequestId(v string) *DescribeEnvCustomJobResponseBody {
	s.RequestId = &v
	return s
}

type DescribeEnvCustomJobResponseBodyData struct {
	// If the request parameter EncryptYaml is set to true, a Base64-encoded YAML string is returned. Otherwise, a plaintext YAML string is returned.
	ConfigYaml *string `json:"ConfigYaml,omitempty" xml:"ConfigYaml,omitempty"`
	// The name of the custom job.
	CustomJobName *string `json:"CustomJobName,omitempty" xml:"CustomJobName,omitempty"`
	// The ID of the environment instance.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The status of the custom job. Valid values: run and stop.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeEnvCustomJobResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvCustomJobResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeEnvCustomJobResponseBodyData) SetConfigYaml(v string) *DescribeEnvCustomJobResponseBodyData {
	s.ConfigYaml = &v
	return s
}

func (s *DescribeEnvCustomJobResponseBodyData) SetCustomJobName(v string) *DescribeEnvCustomJobResponseBodyData {
	s.CustomJobName = &v
	return s
}

func (s *DescribeEnvCustomJobResponseBodyData) SetEnvironmentId(v string) *DescribeEnvCustomJobResponseBodyData {
	s.EnvironmentId = &v
	return s
}

func (s *DescribeEnvCustomJobResponseBodyData) SetRegionId(v string) *DescribeEnvCustomJobResponseBodyData {
	s.RegionId = &v
	return s
}

func (s *DescribeEnvCustomJobResponseBodyData) SetStatus(v string) *DescribeEnvCustomJobResponseBodyData {
	s.Status = &v
	return s
}

type DescribeEnvCustomJobResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeEnvCustomJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeEnvCustomJobResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvCustomJobResponse) GoString() string {
	return s.String()
}

func (s *DescribeEnvCustomJobResponse) SetHeaders(v map[string]*string) *DescribeEnvCustomJobResponse {
	s.Headers = v
	return s
}

func (s *DescribeEnvCustomJobResponse) SetStatusCode(v int32) *DescribeEnvCustomJobResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeEnvCustomJobResponse) SetBody(v *DescribeEnvCustomJobResponseBody) *DescribeEnvCustomJobResponse {
	s.Body = v
	return s
}

type DescribeEnvPodMonitorRequest struct {
	// The ID of the environment instance.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The namespace where the PodMonitor is located.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The name of the PodMonitor.
	PodMonitorName *string `json:"PodMonitorName,omitempty" xml:"PodMonitorName,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeEnvPodMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvPodMonitorRequest) GoString() string {
	return s.String()
}

func (s *DescribeEnvPodMonitorRequest) SetEnvironmentId(v string) *DescribeEnvPodMonitorRequest {
	s.EnvironmentId = &v
	return s
}

func (s *DescribeEnvPodMonitorRequest) SetNamespace(v string) *DescribeEnvPodMonitorRequest {
	s.Namespace = &v
	return s
}

func (s *DescribeEnvPodMonitorRequest) SetPodMonitorName(v string) *DescribeEnvPodMonitorRequest {
	s.PodMonitorName = &v
	return s
}

func (s *DescribeEnvPodMonitorRequest) SetRegionId(v string) *DescribeEnvPodMonitorRequest {
	s.RegionId = &v
	return s
}

type DescribeEnvPodMonitorResponseBody struct {
	// The HTTP status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned struct.
	Data *DescribeEnvPodMonitorResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeEnvPodMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvPodMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeEnvPodMonitorResponseBody) SetCode(v int32) *DescribeEnvPodMonitorResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeEnvPodMonitorResponseBody) SetData(v *DescribeEnvPodMonitorResponseBodyData) *DescribeEnvPodMonitorResponseBody {
	s.Data = v
	return s
}

func (s *DescribeEnvPodMonitorResponseBody) SetMessage(v string) *DescribeEnvPodMonitorResponseBody {
	s.Message = &v
	return s
}

func (s *DescribeEnvPodMonitorResponseBody) SetRequestId(v string) *DescribeEnvPodMonitorResponseBody {
	s.RequestId = &v
	return s
}

type DescribeEnvPodMonitorResponseBodyData struct {
	// The YAML configuration string of the PodMonitor.
	ConfigYaml *string `json:"ConfigYaml,omitempty" xml:"ConfigYaml,omitempty"`
	// The ID of the environment instance.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The name of the PodMonitor.
	PodMonitorName *string `json:"PodMonitorName,omitempty" xml:"PodMonitorName,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The status of the PodMonitor. Valid values: run and stop.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeEnvPodMonitorResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvPodMonitorResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeEnvPodMonitorResponseBodyData) SetConfigYaml(v string) *DescribeEnvPodMonitorResponseBodyData {
	s.ConfigYaml = &v
	return s
}

func (s *DescribeEnvPodMonitorResponseBodyData) SetEnvironmentId(v string) *DescribeEnvPodMonitorResponseBodyData {
	s.EnvironmentId = &v
	return s
}

func (s *DescribeEnvPodMonitorResponseBodyData) SetNamespace(v string) *DescribeEnvPodMonitorResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *DescribeEnvPodMonitorResponseBodyData) SetPodMonitorName(v string) *DescribeEnvPodMonitorResponseBodyData {
	s.PodMonitorName = &v
	return s
}

func (s *DescribeEnvPodMonitorResponseBodyData) SetRegionId(v string) *DescribeEnvPodMonitorResponseBodyData {
	s.RegionId = &v
	return s
}

func (s *DescribeEnvPodMonitorResponseBodyData) SetStatus(v string) *DescribeEnvPodMonitorResponseBodyData {
	s.Status = &v
	return s
}

type DescribeEnvPodMonitorResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeEnvPodMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeEnvPodMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvPodMonitorResponse) GoString() string {
	return s.String()
}

func (s *DescribeEnvPodMonitorResponse) SetHeaders(v map[string]*string) *DescribeEnvPodMonitorResponse {
	s.Headers = v
	return s
}

func (s *DescribeEnvPodMonitorResponse) SetStatusCode(v int32) *DescribeEnvPodMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeEnvPodMonitorResponse) SetBody(v *DescribeEnvPodMonitorResponseBody) *DescribeEnvPodMonitorResponse {
	s.Body = v
	return s
}

type DescribeEnvServiceMonitorRequest struct {
	// The ID of the environment instance.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The namespace where the ServiceMonitor is located.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The name of the ServiceMonitor.
	ServiceMonitorName *string `json:"ServiceMonitorName,omitempty" xml:"ServiceMonitorName,omitempty"`
}

func (s DescribeEnvServiceMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvServiceMonitorRequest) GoString() string {
	return s.String()
}

func (s *DescribeEnvServiceMonitorRequest) SetEnvironmentId(v string) *DescribeEnvServiceMonitorRequest {
	s.EnvironmentId = &v
	return s
}

func (s *DescribeEnvServiceMonitorRequest) SetNamespace(v string) *DescribeEnvServiceMonitorRequest {
	s.Namespace = &v
	return s
}

func (s *DescribeEnvServiceMonitorRequest) SetRegionId(v string) *DescribeEnvServiceMonitorRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeEnvServiceMonitorRequest) SetServiceMonitorName(v string) *DescribeEnvServiceMonitorRequest {
	s.ServiceMonitorName = &v
	return s
}

type DescribeEnvServiceMonitorResponseBody struct {
	// The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned struct.
	Data *DescribeEnvServiceMonitorResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeEnvServiceMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvServiceMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeEnvServiceMonitorResponseBody) SetCode(v int32) *DescribeEnvServiceMonitorResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeEnvServiceMonitorResponseBody) SetData(v *DescribeEnvServiceMonitorResponseBodyData) *DescribeEnvServiceMonitorResponseBody {
	s.Data = v
	return s
}

func (s *DescribeEnvServiceMonitorResponseBody) SetMessage(v string) *DescribeEnvServiceMonitorResponseBody {
	s.Message = &v
	return s
}

func (s *DescribeEnvServiceMonitorResponseBody) SetRequestId(v string) *DescribeEnvServiceMonitorResponseBody {
	s.RequestId = &v
	return s
}

type DescribeEnvServiceMonitorResponseBodyData struct {
	// The YAML configuration string of the ServiceMonitor.
	ConfigYaml *string `json:"ConfigYaml,omitempty" xml:"ConfigYaml,omitempty"`
	// The ID of the environment instance.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The name of the ServiceMonitor.
	ServiceMonitorName *string `json:"ServiceMonitorName,omitempty" xml:"ServiceMonitorName,omitempty"`
	// The status of the ServiceMonitor. Valid values: run and stop.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeEnvServiceMonitorResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvServiceMonitorResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeEnvServiceMonitorResponseBodyData) SetConfigYaml(v string) *DescribeEnvServiceMonitorResponseBodyData {
	s.ConfigYaml = &v
	return s
}

func (s *DescribeEnvServiceMonitorResponseBodyData) SetEnvironmentId(v string) *DescribeEnvServiceMonitorResponseBodyData {
	s.EnvironmentId = &v
	return s
}

func (s *DescribeEnvServiceMonitorResponseBodyData) SetNamespace(v string) *DescribeEnvServiceMonitorResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *DescribeEnvServiceMonitorResponseBodyData) SetRegionId(v string) *DescribeEnvServiceMonitorResponseBodyData {
	s.RegionId = &v
	return s
}

func (s *DescribeEnvServiceMonitorResponseBodyData) SetServiceMonitorName(v string) *DescribeEnvServiceMonitorResponseBodyData {
	s.ServiceMonitorName = &v
	return s
}

func (s *DescribeEnvServiceMonitorResponseBodyData) SetStatus(v string) *DescribeEnvServiceMonitorResponseBodyData {
	s.Status = &v
	return s
}

type DescribeEnvServiceMonitorResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeEnvServiceMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeEnvServiceMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvServiceMonitorResponse) GoString() string {
	return s.String()
}

func (s *DescribeEnvServiceMonitorResponse) SetHeaders(v map[string]*string) *DescribeEnvServiceMonitorResponse {
	s.Headers = v
	return s
}

func (s *DescribeEnvServiceMonitorResponse) SetStatusCode(v int32) *DescribeEnvServiceMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeEnvServiceMonitorResponse) SetBody(v *DescribeEnvServiceMonitorResponseBody) *DescribeEnvServiceMonitorResponse {
	s.Body = v
	return s
}

type DescribeEnvironmentRequest struct {
	// The ID of the environment instance.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeEnvironmentRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvironmentRequest) GoString() string {
	return s.String()
}

func (s *DescribeEnvironmentRequest) SetEnvironmentId(v string) *DescribeEnvironmentRequest {
	s.EnvironmentId = &v
	return s
}

func (s *DescribeEnvironmentRequest) SetRegionId(v string) *DescribeEnvironmentRequest {
	s.RegionId = &v
	return s
}

type DescribeEnvironmentResponseBody struct {
	// The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned struct.
	Data *DescribeEnvironmentResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeEnvironmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvironmentResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeEnvironmentResponseBody) SetCode(v int32) *DescribeEnvironmentResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeEnvironmentResponseBody) SetData(v *DescribeEnvironmentResponseBodyData) *DescribeEnvironmentResponseBody {
	s.Data = v
	return s
}

func (s *DescribeEnvironmentResponseBody) SetMessage(v string) *DescribeEnvironmentResponseBody {
	s.Message = &v
	return s
}

func (s *DescribeEnvironmentResponseBody) SetRequestId(v string) *DescribeEnvironmentResponseBody {
	s.RequestId = &v
	return s
}

type DescribeEnvironmentResponseBodyData struct {
	// The ID of the resource associated with the environment, such as the ACK cluster ID or VPC ID.
	BindResourceId *string `json:"BindResourceId,omitempty" xml:"BindResourceId,omitempty"`
	// The profile of the resource.
	BindResourceProfile *string `json:"BindResourceProfile,omitempty" xml:"BindResourceProfile,omitempty"`
	// The status of the resource.
	BindResourceStatus *string `json:"BindResourceStatus,omitempty" xml:"BindResourceStatus,omitempty"`
	// The retention period of the resource. Unit: days.
	BindResourceStoreDuration *string `json:"BindResourceStoreDuration,omitempty" xml:"BindResourceStoreDuration,omitempty"`
	// The resource type.
	BindResourceType *string `json:"BindResourceType,omitempty" xml:"BindResourceType,omitempty"`
	// The VPC CIDR block.
	BindVpcCidr *string `json:"BindVpcCidr,omitempty" xml:"BindVpcCidr,omitempty"`
	// The ID of the environment instance.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The environment name.
	EnvironmentName *string `json:"EnvironmentName,omitempty" xml:"EnvironmentName,omitempty"`
	// Environment subtypes:
	// - CS: Currently supports ACK.
	// - ECS: ECS is currently supported.
	// - Cloud: Currently supports Cloud.
	EnvironmentSubType *string `json:"EnvironmentSubType,omitempty" xml:"EnvironmentSubType,omitempty"`
	// The type of the environment. Valid values:
	//
	// *   CS: Container Service for Kubernetes (ACK)
	// *   ECS: Elastic Compute Service
	// *   Cloud: cloud service
	EnvironmentType *string `json:"EnvironmentType,omitempty" xml:"EnvironmentType,omitempty"`
	// The name of the Grafana data source.
	GrafaDataSourceName *string `json:"GrafaDataSourceName,omitempty" xml:"GrafaDataSourceName,omitempty"`
	// The unique ID of the Grafana data source.
	GrafanaDatasourceUid *string `json:"GrafanaDatasourceUid,omitempty" xml:"GrafanaDatasourceUid,omitempty"`
	// The name of the Grafana directory.
	GrafanaFolderTitle *string `json:"GrafanaFolderTitle,omitempty" xml:"GrafanaFolderTitle,omitempty"`
	// The unique ID of the Grafana directory.
	GrafanaFolderUid *string `json:"GrafanaFolderUid,omitempty" xml:"GrafanaFolderUid,omitempty"`
	// The URL of the Grafana directory.
	GrafanaFolderUrl *string `json:"GrafanaFolderUrl,omitempty" xml:"GrafanaFolderUrl,omitempty"`
	// The ID of the Prometheus instance.
	PrometheusInstanceId *string `json:"PrometheusInstanceId,omitempty" xml:"PrometheusInstanceId,omitempty"`
	// The name of the Prometheus instance.
	PrometheusInstanceName *string `json:"PrometheusInstanceName,omitempty" xml:"PrometheusInstanceName,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The tags.
	Tags []*DescribeEnvironmentResponseBodyDataTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The user ID.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// VPC ID.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeEnvironmentResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvironmentResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeEnvironmentResponseBodyData) SetBindResourceId(v string) *DescribeEnvironmentResponseBodyData {
	s.BindResourceId = &v
	return s
}

func (s *DescribeEnvironmentResponseBodyData) SetBindResourceProfile(v string) *DescribeEnvironmentResponseBodyData {
	s.BindResourceProfile = &v
	return s
}

func (s *DescribeEnvironmentResponseBodyData) SetBindResourceStatus(v string) *DescribeEnvironmentResponseBodyData {
	s.BindResourceStatus = &v
	return s
}

func (s *DescribeEnvironmentResponseBodyData) SetBindResourceStoreDuration(v string) *DescribeEnvironmentResponseBodyData {
	s.BindResourceStoreDuration = &v
	return s
}

func (s *DescribeEnvironmentResponseBodyData) SetBindResourceType(v string) *DescribeEnvironmentResponseBodyData {
	s.BindResourceType = &v
	return s
}

func (s *DescribeEnvironmentResponseBodyData) SetBindVpcCidr(v string) *DescribeEnvironmentResponseBodyData {
	s.BindVpcCidr = &v
	return s
}

func (s *DescribeEnvironmentResponseBodyData) SetEnvironmentId(v string) *DescribeEnvironmentResponseBodyData {
	s.EnvironmentId = &v
	return s
}

func (s *DescribeEnvironmentResponseBodyData) SetEnvironmentName(v string) *DescribeEnvironmentResponseBodyData {
	s.EnvironmentName = &v
	return s
}

func (s *DescribeEnvironmentResponseBodyData) SetEnvironmentSubType(v string) *DescribeEnvironmentResponseBodyData {
	s.EnvironmentSubType = &v
	return s
}

func (s *DescribeEnvironmentResponseBodyData) SetEnvironmentType(v string) *DescribeEnvironmentResponseBodyData {
	s.EnvironmentType = &v
	return s
}

func (s *DescribeEnvironmentResponseBodyData) SetGrafaDataSourceName(v string) *DescribeEnvironmentResponseBodyData {
	s.GrafaDataSourceName = &v
	return s
}

func (s *DescribeEnvironmentResponseBodyData) SetGrafanaDatasourceUid(v string) *DescribeEnvironmentResponseBodyData {
	s.GrafanaDatasourceUid = &v
	return s
}

func (s *DescribeEnvironmentResponseBodyData) SetGrafanaFolderTitle(v string) *DescribeEnvironmentResponseBodyData {
	s.GrafanaFolderTitle = &v
	return s
}

func (s *DescribeEnvironmentResponseBodyData) SetGrafanaFolderUid(v string) *DescribeEnvironmentResponseBodyData {
	s.GrafanaFolderUid = &v
	return s
}

func (s *DescribeEnvironmentResponseBodyData) SetGrafanaFolderUrl(v string) *DescribeEnvironmentResponseBodyData {
	s.GrafanaFolderUrl = &v
	return s
}

func (s *DescribeEnvironmentResponseBodyData) SetPrometheusInstanceId(v string) *DescribeEnvironmentResponseBodyData {
	s.PrometheusInstanceId = &v
	return s
}

func (s *DescribeEnvironmentResponseBodyData) SetPrometheusInstanceName(v string) *DescribeEnvironmentResponseBodyData {
	s.PrometheusInstanceName = &v
	return s
}

func (s *DescribeEnvironmentResponseBodyData) SetRegionId(v string) *DescribeEnvironmentResponseBodyData {
	s.RegionId = &v
	return s
}

func (s *DescribeEnvironmentResponseBodyData) SetResourceGroupId(v string) *DescribeEnvironmentResponseBodyData {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeEnvironmentResponseBodyData) SetTags(v []*DescribeEnvironmentResponseBodyDataTags) *DescribeEnvironmentResponseBodyData {
	s.Tags = v
	return s
}

func (s *DescribeEnvironmentResponseBodyData) SetUserId(v string) *DescribeEnvironmentResponseBodyData {
	s.UserId = &v
	return s
}

func (s *DescribeEnvironmentResponseBodyData) SetVpcId(v string) *DescribeEnvironmentResponseBodyData {
	s.VpcId = &v
	return s
}

type DescribeEnvironmentResponseBodyDataTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeEnvironmentResponseBodyDataTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvironmentResponseBodyDataTags) GoString() string {
	return s.String()
}

func (s *DescribeEnvironmentResponseBodyDataTags) SetKey(v string) *DescribeEnvironmentResponseBodyDataTags {
	s.Key = &v
	return s
}

func (s *DescribeEnvironmentResponseBodyDataTags) SetValue(v string) *DescribeEnvironmentResponseBodyDataTags {
	s.Value = &v
	return s
}

type DescribeEnvironmentResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeEnvironmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeEnvironmentResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvironmentResponse) GoString() string {
	return s.String()
}

func (s *DescribeEnvironmentResponse) SetHeaders(v map[string]*string) *DescribeEnvironmentResponse {
	s.Headers = v
	return s
}

func (s *DescribeEnvironmentResponse) SetStatusCode(v int32) *DescribeEnvironmentResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeEnvironmentResponse) SetBody(v *DescribeEnvironmentResponseBody) *DescribeEnvironmentResponse {
	s.Body = v
	return s
}

type DescribeEnvironmentFeatureRequest struct {
	// Environment ID.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// Name of Feature.
	FeatureName *string `json:"FeatureName,omitempty" xml:"FeatureName,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeEnvironmentFeatureRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvironmentFeatureRequest) GoString() string {
	return s.String()
}

func (s *DescribeEnvironmentFeatureRequest) SetEnvironmentId(v string) *DescribeEnvironmentFeatureRequest {
	s.EnvironmentId = &v
	return s
}

func (s *DescribeEnvironmentFeatureRequest) SetFeatureName(v string) *DescribeEnvironmentFeatureRequest {
	s.FeatureName = &v
	return s
}

func (s *DescribeEnvironmentFeatureRequest) SetRegionId(v string) *DescribeEnvironmentFeatureRequest {
	s.RegionId = &v
	return s
}

type DescribeEnvironmentFeatureResponseBody struct {
	// Status code: 200 indicates success.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The return data.
	Data *DescribeEnvironmentFeatureResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	//
	// *   `true`: successful
	// *   `false`: failed
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DescribeEnvironmentFeatureResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvironmentFeatureResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeEnvironmentFeatureResponseBody) SetCode(v int32) *DescribeEnvironmentFeatureResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeEnvironmentFeatureResponseBody) SetData(v *DescribeEnvironmentFeatureResponseBodyData) *DescribeEnvironmentFeatureResponseBody {
	s.Data = v
	return s
}

func (s *DescribeEnvironmentFeatureResponseBody) SetMessage(v string) *DescribeEnvironmentFeatureResponseBody {
	s.Message = &v
	return s
}

func (s *DescribeEnvironmentFeatureResponseBody) SetRequestId(v string) *DescribeEnvironmentFeatureResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeEnvironmentFeatureResponseBody) SetSuccess(v bool) *DescribeEnvironmentFeatureResponseBody {
	s.Success = &v
	return s
}

type DescribeEnvironmentFeatureResponseBodyData struct {
	// Feature Installation information.
	Feature *DescribeEnvironmentFeatureResponseBodyDataFeature `json:"Feature,omitempty" xml:"Feature,omitempty" type:"Struct"`
	// Running status of the Feature.
	FeatureStatus *DescribeEnvironmentFeatureResponseBodyDataFeatureStatus `json:"FeatureStatus,omitempty" xml:"FeatureStatus,omitempty" type:"Struct"`
}

func (s DescribeEnvironmentFeatureResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvironmentFeatureResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeEnvironmentFeatureResponseBodyData) SetFeature(v *DescribeEnvironmentFeatureResponseBodyDataFeature) *DescribeEnvironmentFeatureResponseBodyData {
	s.Feature = v
	return s
}

func (s *DescribeEnvironmentFeatureResponseBodyData) SetFeatureStatus(v *DescribeEnvironmentFeatureResponseBodyDataFeatureStatus) *DescribeEnvironmentFeatureResponseBodyData {
	s.FeatureStatus = v
	return s
}

type DescribeEnvironmentFeatureResponseBodyDataFeature struct {
	// Alias of Feature.
	Alias *string `json:"Alias,omitempty" xml:"Alias,omitempty"`
	// Config of Feature.
	Config map[string]*string `json:"Config,omitempty" xml:"Config,omitempty"`
	// Description of Feature.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Environment ID.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// Icon address.
	Icon *string `json:"Icon,omitempty" xml:"Icon,omitempty"`
	// Lanuage.
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// This is the latest version of Feature.
	LatestVersion *string `json:"LatestVersion,omitempty" xml:"LatestVersion,omitempty"`
	// Name of Feature.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Installation status of Feature.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// Version of Feature.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s DescribeEnvironmentFeatureResponseBodyDataFeature) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvironmentFeatureResponseBodyDataFeature) GoString() string {
	return s.String()
}

func (s *DescribeEnvironmentFeatureResponseBodyDataFeature) SetAlias(v string) *DescribeEnvironmentFeatureResponseBodyDataFeature {
	s.Alias = &v
	return s
}

func (s *DescribeEnvironmentFeatureResponseBodyDataFeature) SetConfig(v map[string]*string) *DescribeEnvironmentFeatureResponseBodyDataFeature {
	s.Config = v
	return s
}

func (s *DescribeEnvironmentFeatureResponseBodyDataFeature) SetDescription(v string) *DescribeEnvironmentFeatureResponseBodyDataFeature {
	s.Description = &v
	return s
}

func (s *DescribeEnvironmentFeatureResponseBodyDataFeature) SetEnvironmentId(v string) *DescribeEnvironmentFeatureResponseBodyDataFeature {
	s.EnvironmentId = &v
	return s
}

func (s *DescribeEnvironmentFeatureResponseBodyDataFeature) SetIcon(v string) *DescribeEnvironmentFeatureResponseBodyDataFeature {
	s.Icon = &v
	return s
}

func (s *DescribeEnvironmentFeatureResponseBodyDataFeature) SetLanguage(v string) *DescribeEnvironmentFeatureResponseBodyDataFeature {
	s.Language = &v
	return s
}

func (s *DescribeEnvironmentFeatureResponseBodyDataFeature) SetLatestVersion(v string) *DescribeEnvironmentFeatureResponseBodyDataFeature {
	s.LatestVersion = &v
	return s
}

func (s *DescribeEnvironmentFeatureResponseBodyDataFeature) SetName(v string) *DescribeEnvironmentFeatureResponseBodyDataFeature {
	s.Name = &v
	return s
}

func (s *DescribeEnvironmentFeatureResponseBodyDataFeature) SetStatus(v string) *DescribeEnvironmentFeatureResponseBodyDataFeature {
	s.Status = &v
	return s
}

func (s *DescribeEnvironmentFeatureResponseBodyDataFeature) SetVersion(v string) *DescribeEnvironmentFeatureResponseBodyDataFeature {
	s.Version = &v
	return s
}

type DescribeEnvironmentFeatureResponseBodyDataFeatureStatus struct {
	// Feature container list.
	FeatureContainers []*DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers `json:"FeatureContainers,omitempty" xml:"FeatureContainers,omitempty" type:"Repeated"`
	// K8s resource name of the Feature.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// Running status.
	// - Success: Running normal
	// - Failed: Running exception
	// - Not Found: Not installed
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeEnvironmentFeatureResponseBodyDataFeatureStatus) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvironmentFeatureResponseBodyDataFeatureStatus) GoString() string {
	return s.String()
}

func (s *DescribeEnvironmentFeatureResponseBodyDataFeatureStatus) SetFeatureContainers(v []*DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers) *DescribeEnvironmentFeatureResponseBodyDataFeatureStatus {
	s.FeatureContainers = v
	return s
}

func (s *DescribeEnvironmentFeatureResponseBodyDataFeatureStatus) SetName(v string) *DescribeEnvironmentFeatureResponseBodyDataFeatureStatus {
	s.Name = &v
	return s
}

func (s *DescribeEnvironmentFeatureResponseBodyDataFeatureStatus) SetNamespace(v string) *DescribeEnvironmentFeatureResponseBodyDataFeatureStatus {
	s.Namespace = &v
	return s
}

func (s *DescribeEnvironmentFeatureResponseBodyDataFeatureStatus) SetStatus(v string) *DescribeEnvironmentFeatureResponseBodyDataFeatureStatus {
	s.Status = &v
	return s
}

type DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers struct {
	// Container parameters.
	Args []*string `json:"Args,omitempty" xml:"Args,omitempty" type:"Repeated"`
	// Container image.
	Image *string `json:"Image,omitempty" xml:"Image,omitempty"`
	// Name of the container.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers) GoString() string {
	return s.String()
}

func (s *DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers) SetArgs(v []*string) *DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers {
	s.Args = v
	return s
}

func (s *DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers) SetImage(v string) *DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers {
	s.Image = &v
	return s
}

func (s *DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers) SetName(v string) *DescribeEnvironmentFeatureResponseBodyDataFeatureStatusFeatureContainers {
	s.Name = &v
	return s
}

type DescribeEnvironmentFeatureResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeEnvironmentFeatureResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeEnvironmentFeatureResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeEnvironmentFeatureResponse) GoString() string {
	return s.String()
}

func (s *DescribeEnvironmentFeatureResponse) SetHeaders(v map[string]*string) *DescribeEnvironmentFeatureResponse {
	s.Headers = v
	return s
}

func (s *DescribeEnvironmentFeatureResponse) SetStatusCode(v int32) *DescribeEnvironmentFeatureResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeEnvironmentFeatureResponse) SetBody(v *DescribeEnvironmentFeatureResponseBody) *DescribeEnvironmentFeatureResponse {
	s.Body = v
	return s
}

type DescribeIMRobotsRequest struct {
	// The number of the page to return.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The chatbot IDs.
	RobotIds *string `json:"RobotIds,omitempty" xml:"RobotIds,omitempty"`
	// The name of the IM chatbot.
	RobotName *string `json:"RobotName,omitempty" xml:"RobotName,omitempty"`
	// The number of IM chatbots to return on each page.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
}

func (s DescribeIMRobotsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeIMRobotsRequest) GoString() string {
	return s.String()
}

func (s *DescribeIMRobotsRequest) SetPage(v int64) *DescribeIMRobotsRequest {
	s.Page = &v
	return s
}

func (s *DescribeIMRobotsRequest) SetRobotIds(v string) *DescribeIMRobotsRequest {
	s.RobotIds = &v
	return s
}

func (s *DescribeIMRobotsRequest) SetRobotName(v string) *DescribeIMRobotsRequest {
	s.RobotName = &v
	return s
}

func (s *DescribeIMRobotsRequest) SetSize(v int64) *DescribeIMRobotsRequest {
	s.Size = &v
	return s
}

type DescribeIMRobotsResponseBody struct {
	// The returned objects.
	PageBean *DescribeIMRobotsResponseBodyPageBean `json:"PageBean,omitempty" xml:"PageBean,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeIMRobotsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeIMRobotsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeIMRobotsResponseBody) SetPageBean(v *DescribeIMRobotsResponseBodyPageBean) *DescribeIMRobotsResponseBody {
	s.PageBean = v
	return s
}

func (s *DescribeIMRobotsResponseBody) SetRequestId(v string) *DescribeIMRobotsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeIMRobotsResponseBodyPageBean struct {
	// The queried IM chatbots.
	AlertIMRobots []*DescribeIMRobotsResponseBodyPageBeanAlertIMRobots `json:"AlertIMRobots,omitempty" xml:"AlertIMRobots,omitempty" type:"Repeated"`
	// The page number of the returned page.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of IM chatbots returned per page.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The total number of queried IM chatbots.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s DescribeIMRobotsResponseBodyPageBean) String() string {
	return tea.Prettify(s)
}

func (s DescribeIMRobotsResponseBodyPageBean) GoString() string {
	return s.String()
}

func (s *DescribeIMRobotsResponseBodyPageBean) SetAlertIMRobots(v []*DescribeIMRobotsResponseBodyPageBeanAlertIMRobots) *DescribeIMRobotsResponseBodyPageBean {
	s.AlertIMRobots = v
	return s
}

func (s *DescribeIMRobotsResponseBodyPageBean) SetPage(v int64) *DescribeIMRobotsResponseBodyPageBean {
	s.Page = &v
	return s
}

func (s *DescribeIMRobotsResponseBodyPageBean) SetSize(v int64) *DescribeIMRobotsResponseBodyPageBean {
	s.Size = &v
	return s
}

func (s *DescribeIMRobotsResponseBodyPageBean) SetTotal(v int64) *DescribeIMRobotsResponseBodyPageBean {
	s.Total = &v
	return s
}

type DescribeIMRobotsResponseBodyPageBeanAlertIMRobots struct {
	// The time when the IM chatbot was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// Indicates whether daily statistics are sent. Valid values:
	//
	// *   `false` (default): Daily statistics are not sent.
	// *   `true`: Daily statistics are sent.
	DailyNoc *bool `json:"DailyNoc,omitempty" xml:"DailyNoc,omitempty"`
	// The point in time at which the daily statistics are sent. The information that ARMS sends at the specified points in time includes the total number of alerts generated on the current day, the number of cleared alerts, and the number of alerts to be cleared.
	DailyNocTime *string `json:"DailyNocTime,omitempty" xml:"DailyNocTime,omitempty"`
	// The signature key of DingTalk. If you specify a signature key, DingTalk authentication is performed by using the signature key. If you do not specify a signature key, a whitelist is used for authentication by default. The keyword of the whitelist is **Alert**.
	DingSignKey *string `json:"DingSignKey,omitempty" xml:"DingSignKey,omitempty"`
	// The notification policies.
	DispatchRules []*DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules `json:"DispatchRules,omitempty" xml:"DispatchRules,omitempty" type:"Repeated"`
	// The webhook URL of the IM chatbot.
	RobotAddr *string `json:"RobotAddr,omitempty" xml:"RobotAddr,omitempty"`
	// The ID of the IM chatbot.
	RobotId *float32 `json:"RobotId,omitempty" xml:"RobotId,omitempty"`
	// The name of the IM chatbot.
	RobotName *string `json:"RobotName,omitempty" xml:"RobotName,omitempty"`
	// The type of the IM chatbot. Valid values:
	//
	// *   `dingding`: DingTalk chatbot
	// *   `wechat`: WeCom chatbot
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeIMRobotsResponseBodyPageBeanAlertIMRobots) String() string {
	return tea.Prettify(s)
}

func (s DescribeIMRobotsResponseBodyPageBeanAlertIMRobots) GoString() string {
	return s.String()
}

func (s *DescribeIMRobotsResponseBodyPageBeanAlertIMRobots) SetCreateTime(v string) *DescribeIMRobotsResponseBodyPageBeanAlertIMRobots {
	s.CreateTime = &v
	return s
}

func (s *DescribeIMRobotsResponseBodyPageBeanAlertIMRobots) SetDailyNoc(v bool) *DescribeIMRobotsResponseBodyPageBeanAlertIMRobots {
	s.DailyNoc = &v
	return s
}

func (s *DescribeIMRobotsResponseBodyPageBeanAlertIMRobots) SetDailyNocTime(v string) *DescribeIMRobotsResponseBodyPageBeanAlertIMRobots {
	s.DailyNocTime = &v
	return s
}

func (s *DescribeIMRobotsResponseBodyPageBeanAlertIMRobots) SetDingSignKey(v string) *DescribeIMRobotsResponseBodyPageBeanAlertIMRobots {
	s.DingSignKey = &v
	return s
}

func (s *DescribeIMRobotsResponseBodyPageBeanAlertIMRobots) SetDispatchRules(v []*DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules) *DescribeIMRobotsResponseBodyPageBeanAlertIMRobots {
	s.DispatchRules = v
	return s
}

func (s *DescribeIMRobotsResponseBodyPageBeanAlertIMRobots) SetRobotAddr(v string) *DescribeIMRobotsResponseBodyPageBeanAlertIMRobots {
	s.RobotAddr = &v
	return s
}

func (s *DescribeIMRobotsResponseBodyPageBeanAlertIMRobots) SetRobotId(v float32) *DescribeIMRobotsResponseBodyPageBeanAlertIMRobots {
	s.RobotId = &v
	return s
}

func (s *DescribeIMRobotsResponseBodyPageBeanAlertIMRobots) SetRobotName(v string) *DescribeIMRobotsResponseBodyPageBeanAlertIMRobots {
	s.RobotName = &v
	return s
}

func (s *DescribeIMRobotsResponseBodyPageBeanAlertIMRobots) SetType(v string) *DescribeIMRobotsResponseBodyPageBeanAlertIMRobots {
	s.Type = &v
	return s
}

type DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules struct {
	// The ID of the notification policy.
	Id *int64 `json:"id,omitempty" xml:"id,omitempty"`
	// The name of the notification policy.
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
}

func (s DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules) GoString() string {
	return s.String()
}

func (s *DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules) SetId(v int64) *DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules {
	s.Id = &v
	return s
}

func (s *DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules) SetName(v string) *DescribeIMRobotsResponseBodyPageBeanAlertIMRobotsDispatchRules {
	s.Name = &v
	return s
}

type DescribeIMRobotsResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeIMRobotsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeIMRobotsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeIMRobotsResponse) GoString() string {
	return s.String()
}

func (s *DescribeIMRobotsResponse) SetHeaders(v map[string]*string) *DescribeIMRobotsResponse {
	s.Headers = v
	return s
}

func (s *DescribeIMRobotsResponse) SetStatusCode(v int32) *DescribeIMRobotsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeIMRobotsResponse) SetBody(v *DescribeIMRobotsResponseBody) *DescribeIMRobotsResponse {
	s.Body = v
	return s
}

type DescribePrometheusAlertRuleRequest struct {
	// The ID of the alert rule. You can call the ListPrometheusAlertRules operation to query the ID of the alert rule.
	AlertId   *int64  `json:"AlertId,omitempty" xml:"AlertId,omitempty"`
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
}

func (s DescribePrometheusAlertRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePrometheusAlertRuleRequest) GoString() string {
	return s.String()
}

func (s *DescribePrometheusAlertRuleRequest) SetAlertId(v int64) *DescribePrometheusAlertRuleRequest {
	s.AlertId = &v
	return s
}

func (s *DescribePrometheusAlertRuleRequest) SetClusterId(v string) *DescribePrometheusAlertRuleRequest {
	s.ClusterId = &v
	return s
}

type DescribePrometheusAlertRuleResponseBody struct {
	Code    *int64  `json:"Code,omitempty" xml:"Code,omitempty"`
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The returned struct.
	PrometheusAlertRule *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule `json:"PrometheusAlertRule,omitempty" xml:"PrometheusAlertRule,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DescribePrometheusAlertRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePrometheusAlertRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePrometheusAlertRuleResponseBody) SetCode(v int64) *DescribePrometheusAlertRuleResponseBody {
	s.Code = &v
	return s
}

func (s *DescribePrometheusAlertRuleResponseBody) SetMessage(v string) *DescribePrometheusAlertRuleResponseBody {
	s.Message = &v
	return s
}

func (s *DescribePrometheusAlertRuleResponseBody) SetPrometheusAlertRule(v *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule) *DescribePrometheusAlertRuleResponseBody {
	s.PrometheusAlertRule = v
	return s
}

func (s *DescribePrometheusAlertRuleResponseBody) SetRequestId(v string) *DescribePrometheusAlertRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePrometheusAlertRuleResponseBody) SetSuccess(v bool) *DescribePrometheusAlertRuleResponseBody {
	s.Success = &v
	return s
}

type DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule struct {
	// The ID of the alert rule.
	AlertId *int64 `json:"AlertId,omitempty" xml:"AlertId,omitempty"`
	// The name of the alert rule.
	AlertName *string `json:"AlertName,omitempty" xml:"AlertName,omitempty"`
	// The annotations of the alert rule.
	Annotations []*DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations `json:"Annotations,omitempty" xml:"Annotations,omitempty" type:"Repeated"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the notification policy. This parameter is returned if the **NotifyType** parameter is set to `DISPATCH_RULE`.
	DispatchRuleId *int64 `json:"DispatchRuleId,omitempty" xml:"DispatchRuleId,omitempty"`
	// The duration of the alert. Valid values: 1 to 1440. Unit: minutes.
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The expression of the alert rule.
	Expression *string `json:"Expression,omitempty" xml:"Expression,omitempty"`
	// The tags of the alert rule.
	Labels []*DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels `json:"Labels,omitempty" xml:"Labels,omitempty" type:"Repeated"`
	// The alert message. Tags can be referenced in the {{$labels.xxx}} format.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The method of that is used to send alert notifications. Valid values:
	//
	// *   `ALERT_MANAGER`: Alert notifications are sent by Operation Center.
	// *   `DISPATCH_RULE`: Alert notifications are sent based on the specified notification policy.
	NotifyType *string `json:"NotifyType,omitempty" xml:"NotifyType,omitempty"`
	// Indicates whether the alert rule is enabled. Valid values:
	//
	// *   `1`: The alert rule is enabled.
	// *   `0`: The alert rule is disabled.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the alert rule.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule) String() string {
	return tea.Prettify(s)
}

func (s DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule) GoString() string {
	return s.String()
}

func (s *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetAlertId(v int64) *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.AlertId = &v
	return s
}

func (s *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetAlertName(v string) *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.AlertName = &v
	return s
}

func (s *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetAnnotations(v []*DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations) *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.Annotations = v
	return s
}

func (s *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetClusterId(v string) *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.ClusterId = &v
	return s
}

func (s *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetDispatchRuleId(v int64) *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.DispatchRuleId = &v
	return s
}

func (s *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetDuration(v string) *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.Duration = &v
	return s
}

func (s *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetExpression(v string) *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.Expression = &v
	return s
}

func (s *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetLabels(v []*DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels) *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.Labels = v
	return s
}

func (s *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetMessage(v string) *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.Message = &v
	return s
}

func (s *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetNotifyType(v string) *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.NotifyType = &v
	return s
}

func (s *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetStatus(v int32) *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.Status = &v
	return s
}

func (s *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetType(v string) *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.Type = &v
	return s
}

type DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations struct {
	// The name of the annotation.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The value of the annotation.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations) String() string {
	return tea.Prettify(s)
}

func (s DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations) GoString() string {
	return s.String()
}

func (s *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations) SetName(v string) *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations {
	s.Name = &v
	return s
}

func (s *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations) SetValue(v string) *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations {
	s.Value = &v
	return s
}

type DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels struct {
	// The name of the tag.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels) String() string {
	return tea.Prettify(s)
}

func (s DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels) GoString() string {
	return s.String()
}

func (s *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels) SetName(v string) *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels {
	s.Name = &v
	return s
}

func (s *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels) SetValue(v string) *DescribePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels {
	s.Value = &v
	return s
}

type DescribePrometheusAlertRuleResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePrometheusAlertRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePrometheusAlertRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePrometheusAlertRuleResponse) GoString() string {
	return s.String()
}

func (s *DescribePrometheusAlertRuleResponse) SetHeaders(v map[string]*string) *DescribePrometheusAlertRuleResponse {
	s.Headers = v
	return s
}

func (s *DescribePrometheusAlertRuleResponse) SetStatusCode(v int32) *DescribePrometheusAlertRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePrometheusAlertRuleResponse) SetBody(v *DescribePrometheusAlertRuleResponseBody) *DescribePrometheusAlertRuleResponse {
	s.Body = v
	return s
}

type DescribeTraceLicenseKeyRequest struct {
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeTraceLicenseKeyRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeTraceLicenseKeyRequest) GoString() string {
	return s.String()
}

func (s *DescribeTraceLicenseKeyRequest) SetRegionId(v string) *DescribeTraceLicenseKeyRequest {
	s.RegionId = &v
	return s
}

type DescribeTraceLicenseKeyResponseBody struct {
	LicenseKey *string `json:"LicenseKey,omitempty" xml:"LicenseKey,omitempty"`
	RequestId  *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeTraceLicenseKeyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeTraceLicenseKeyResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeTraceLicenseKeyResponseBody) SetLicenseKey(v string) *DescribeTraceLicenseKeyResponseBody {
	s.LicenseKey = &v
	return s
}

func (s *DescribeTraceLicenseKeyResponseBody) SetRequestId(v string) *DescribeTraceLicenseKeyResponseBody {
	s.RequestId = &v
	return s
}

type DescribeTraceLicenseKeyResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeTraceLicenseKeyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeTraceLicenseKeyResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeTraceLicenseKeyResponse) GoString() string {
	return s.String()
}

func (s *DescribeTraceLicenseKeyResponse) SetHeaders(v map[string]*string) *DescribeTraceLicenseKeyResponse {
	s.Headers = v
	return s
}

func (s *DescribeTraceLicenseKeyResponse) SetStatusCode(v int32) *DescribeTraceLicenseKeyResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeTraceLicenseKeyResponse) SetBody(v *DescribeTraceLicenseKeyResponseBody) *DescribeTraceLicenseKeyResponse {
	s.Body = v
	return s
}

type DescribeWebhookContactsRequest struct {
	// The ID of the alert contact.
	ContactIds *string `json:"ContactIds,omitempty" xml:"ContactIds,omitempty"`
	// The number of the page to return.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of alert contacts displayed on each page.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The name of the webhook alert contact.
	WebhookName *string `json:"WebhookName,omitempty" xml:"WebhookName,omitempty"`
}

func (s DescribeWebhookContactsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebhookContactsRequest) GoString() string {
	return s.String()
}

func (s *DescribeWebhookContactsRequest) SetContactIds(v string) *DescribeWebhookContactsRequest {
	s.ContactIds = &v
	return s
}

func (s *DescribeWebhookContactsRequest) SetPage(v int64) *DescribeWebhookContactsRequest {
	s.Page = &v
	return s
}

func (s *DescribeWebhookContactsRequest) SetSize(v int64) *DescribeWebhookContactsRequest {
	s.Size = &v
	return s
}

func (s *DescribeWebhookContactsRequest) SetWebhookName(v string) *DescribeWebhookContactsRequest {
	s.WebhookName = &v
	return s
}

type DescribeWebhookContactsResponseBody struct {
	// The returned objects.
	PageBean *DescribeWebhookContactsResponseBodyPageBean `json:"PageBean,omitempty" xml:"PageBean,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeWebhookContactsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebhookContactsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeWebhookContactsResponseBody) SetPageBean(v *DescribeWebhookContactsResponseBodyPageBean) *DescribeWebhookContactsResponseBody {
	s.PageBean = v
	return s
}

func (s *DescribeWebhookContactsResponseBody) SetRequestId(v string) *DescribeWebhookContactsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeWebhookContactsResponseBodyPageBean struct {
	// The page number of the returned page.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of alert contacts displayed on each page.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The total number of alert contacts.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
	// The list of webhook alert contacts.
	WebhookContacts []*DescribeWebhookContactsResponseBodyPageBeanWebhookContacts `json:"WebhookContacts,omitempty" xml:"WebhookContacts,omitempty" type:"Repeated"`
}

func (s DescribeWebhookContactsResponseBodyPageBean) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebhookContactsResponseBodyPageBean) GoString() string {
	return s.String()
}

func (s *DescribeWebhookContactsResponseBodyPageBean) SetPage(v int64) *DescribeWebhookContactsResponseBodyPageBean {
	s.Page = &v
	return s
}

func (s *DescribeWebhookContactsResponseBodyPageBean) SetSize(v int64) *DescribeWebhookContactsResponseBodyPageBean {
	s.Size = &v
	return s
}

func (s *DescribeWebhookContactsResponseBodyPageBean) SetTotal(v int64) *DescribeWebhookContactsResponseBodyPageBean {
	s.Total = &v
	return s
}

func (s *DescribeWebhookContactsResponseBodyPageBean) SetWebhookContacts(v []*DescribeWebhookContactsResponseBodyPageBeanWebhookContacts) *DescribeWebhookContactsResponseBodyPageBean {
	s.WebhookContacts = v
	return s
}

type DescribeWebhookContactsResponseBodyPageBeanWebhookContacts struct {
	// The details of the webhook alert contact.
	Webhook *DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook `json:"Webhook,omitempty" xml:"Webhook,omitempty" type:"Struct"`
	// The ID of the webhook alert contact.
	WebhookId *float32 `json:"WebhookId,omitempty" xml:"WebhookId,omitempty"`
	// The name of the webhook alert contact.
	WebhookName *string `json:"WebhookName,omitempty" xml:"WebhookName,omitempty"`
}

func (s DescribeWebhookContactsResponseBodyPageBeanWebhookContacts) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebhookContactsResponseBodyPageBeanWebhookContacts) GoString() string {
	return s.String()
}

func (s *DescribeWebhookContactsResponseBodyPageBeanWebhookContacts) SetWebhook(v *DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook) *DescribeWebhookContactsResponseBodyPageBeanWebhookContacts {
	s.Webhook = v
	return s
}

func (s *DescribeWebhookContactsResponseBodyPageBeanWebhookContacts) SetWebhookId(v float32) *DescribeWebhookContactsResponseBodyPageBeanWebhookContacts {
	s.WebhookId = &v
	return s
}

func (s *DescribeWebhookContactsResponseBodyPageBeanWebhookContacts) SetWebhookName(v string) *DescribeWebhookContactsResponseBodyPageBeanWebhookContacts {
	s.WebhookName = &v
	return s
}

type DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook struct {
	// The header of the HTTP request.
	BizHeaders map[string]interface{} `json:"BizHeaders,omitempty" xml:"BizHeaders,omitempty"`
	// The parameters in the HTTP request.
	BizParams map[string]interface{} `json:"BizParams,omitempty" xml:"BizParams,omitempty"`
	// The alert notification template.
	Body *string `json:"Body,omitempty" xml:"Body,omitempty"`
	// The HTTP request method.
	//
	// *   Get
	// *   Post
	Method *string `json:"Method,omitempty" xml:"Method,omitempty"`
	// The notification template for clearing alerts.
	RecoverBody *string `json:"RecoverBody,omitempty" xml:"RecoverBody,omitempty"`
	// The URL of the request method.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook) GoString() string {
	return s.String()
}

func (s *DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook) SetBizHeaders(v map[string]interface{}) *DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook {
	s.BizHeaders = v
	return s
}

func (s *DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook) SetBizParams(v map[string]interface{}) *DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook {
	s.BizParams = v
	return s
}

func (s *DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook) SetBody(v string) *DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook {
	s.Body = &v
	return s
}

func (s *DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook) SetMethod(v string) *DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook {
	s.Method = &v
	return s
}

func (s *DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook) SetRecoverBody(v string) *DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook {
	s.RecoverBody = &v
	return s
}

func (s *DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook) SetUrl(v string) *DescribeWebhookContactsResponseBodyPageBeanWebhookContactsWebhook {
	s.Url = &v
	return s
}

type DescribeWebhookContactsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeWebhookContactsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeWebhookContactsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebhookContactsResponse) GoString() string {
	return s.String()
}

func (s *DescribeWebhookContactsResponse) SetHeaders(v map[string]*string) *DescribeWebhookContactsResponse {
	s.Headers = v
	return s
}

func (s *DescribeWebhookContactsResponse) SetStatusCode(v int32) *DescribeWebhookContactsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeWebhookContactsResponse) SetBody(v *DescribeWebhookContactsResponseBody) *DescribeWebhookContactsResponse {
	s.Body = v
	return s
}

type EnableMetricRequest struct {
	// The cluster ID.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// Enable metric name.
	DropMetric *string `json:"DropMetric,omitempty" xml:"DropMetric,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s EnableMetricRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableMetricRequest) GoString() string {
	return s.String()
}

func (s *EnableMetricRequest) SetClusterId(v string) *EnableMetricRequest {
	s.ClusterId = &v
	return s
}

func (s *EnableMetricRequest) SetDropMetric(v string) *EnableMetricRequest {
	s.DropMetric = &v
	return s
}

func (s *EnableMetricRequest) SetRegionId(v string) *EnableMetricRequest {
	s.RegionId = &v
	return s
}

type EnableMetricResponseBody struct {
	// The HTTP status code returned for the request. Valid values:
	//
	// *   2XX: The request is successful.
	// *   3XX: A redirection message is returned.
	// *   4XX: The request is invalid.
	// *   5XX: A server error occurs.
	Code *int64 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned struct.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   `true`: The call was successful.
	// *   `false`: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s EnableMetricResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableMetricResponseBody) GoString() string {
	return s.String()
}

func (s *EnableMetricResponseBody) SetCode(v int64) *EnableMetricResponseBody {
	s.Code = &v
	return s
}

func (s *EnableMetricResponseBody) SetData(v string) *EnableMetricResponseBody {
	s.Data = &v
	return s
}

func (s *EnableMetricResponseBody) SetMessage(v string) *EnableMetricResponseBody {
	s.Message = &v
	return s
}

func (s *EnableMetricResponseBody) SetRequestId(v string) *EnableMetricResponseBody {
	s.RequestId = &v
	return s
}

func (s *EnableMetricResponseBody) SetSuccess(v bool) *EnableMetricResponseBody {
	s.Success = &v
	return s
}

type EnableMetricResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EnableMetricResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EnableMetricResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableMetricResponse) GoString() string {
	return s.String()
}

func (s *EnableMetricResponse) SetHeaders(v map[string]*string) *EnableMetricResponse {
	s.Headers = v
	return s
}

func (s *EnableMetricResponse) SetStatusCode(v int32) *EnableMetricResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableMetricResponse) SetBody(v *EnableMetricResponseBody) *EnableMetricResponse {
	s.Body = v
	return s
}

type GetAgentDownloadUrlRequest struct {
	// The download URL of the ARMS agent.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetAgentDownloadUrlRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAgentDownloadUrlRequest) GoString() string {
	return s.String()
}

func (s *GetAgentDownloadUrlRequest) SetRegionId(v string) *GetAgentDownloadUrlRequest {
	s.RegionId = &v
	return s
}

type GetAgentDownloadUrlResponseBody struct {
	// The ID of the request.
	ArmsAgentDownloadUrl *string `json:"ArmsAgentDownloadUrl,omitempty" xml:"ArmsAgentDownloadUrl,omitempty"`
	// Obtains the download URL of the Application Real-Time Monitoring Service (ARMS) agent.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAgentDownloadUrlResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAgentDownloadUrlResponseBody) GoString() string {
	return s.String()
}

func (s *GetAgentDownloadUrlResponseBody) SetArmsAgentDownloadUrl(v string) *GetAgentDownloadUrlResponseBody {
	s.ArmsAgentDownloadUrl = &v
	return s
}

func (s *GetAgentDownloadUrlResponseBody) SetRequestId(v string) *GetAgentDownloadUrlResponseBody {
	s.RequestId = &v
	return s
}

type GetAgentDownloadUrlResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAgentDownloadUrlResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAgentDownloadUrlResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAgentDownloadUrlResponse) GoString() string {
	return s.String()
}

func (s *GetAgentDownloadUrlResponse) SetHeaders(v map[string]*string) *GetAgentDownloadUrlResponse {
	s.Headers = v
	return s
}

func (s *GetAgentDownloadUrlResponse) SetStatusCode(v int32) *GetAgentDownloadUrlResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAgentDownloadUrlResponse) SetBody(v *GetAgentDownloadUrlResponseBody) *GetAgentDownloadUrlResponse {
	s.Body = v
	return s
}

type GetAlertRulesRequest struct {
	// The unique IDs of alert rules.
	//
	// *   If you do not specify this parameter, the API operation does not filter alert rules based on their IDs.
	// *   If you specify this parameter, the API operation returns only the information of the specified alert rules. Other filter conditions also take effect.
	//
	// > When you call the GetAlertRules operation, you can specify other request parameters to obtain the AlertIds parameter from the response. Then, you can specify the AlertIds parameter to query the specified alert rules.
	AlertIds *string `json:"AlertIds,omitempty" xml:"AlertIds,omitempty"`
	// The names of alert rules. When you create alert rules of the new version, you cannot specify duplicate names. However, existing alert rules may have duplicate names. Therefore, the **AlertName** parameter does not uniquely identify an alert rule.
	//
	// *   If you do not specify this parameter, the API operation does not filter alert rules based on their names.
	// *   If you specify this parameter, the API operation returns only the information of the specified alert rules. Other filter conditions also take effect.
	AlertNames *string `json:"AlertNames,omitempty" xml:"AlertNames,omitempty"`
	// The status of the alert rule. Valid values:
	//
	// *   RUNNING
	// *   STOPPED
	// *   PAUSED
	//
	// > The **PAUSED** status indicates that the alert rule is abnormal and is actively paused by the system. The alert rule may be paused because that it is not unique or the associated cluster has been deleted.
	AlertStatus *string `json:"AlertStatus,omitempty" xml:"AlertStatus,omitempty"`
	// The type of the alert rule.
	//
	// *   APPLICATION_MONITORING_ALERT_RULE: alert rule for Application Monitoring
	// *   BROWSER_MONITORING_ALERT_RULE: an alert rule for Browser Monitoring.
	// *   PROMETHEUS_MONITORING_ALERT_RULE: alert rule for Managed Service for Prometheus.
	AlertType *string `json:"AlertType,omitempty" xml:"AlertType,omitempty"`
	// The ID of the monitored cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The number of the page to return.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// You do not need to configure this parameter.
	ProductCode *string `json:"ProductCode,omitempty" xml:"ProductCode,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The number of alert rules to return on each page.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The list of tags.
	Tags []*GetAlertRulesRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s GetAlertRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAlertRulesRequest) GoString() string {
	return s.String()
}

func (s *GetAlertRulesRequest) SetAlertIds(v string) *GetAlertRulesRequest {
	s.AlertIds = &v
	return s
}

func (s *GetAlertRulesRequest) SetAlertNames(v string) *GetAlertRulesRequest {
	s.AlertNames = &v
	return s
}

func (s *GetAlertRulesRequest) SetAlertStatus(v string) *GetAlertRulesRequest {
	s.AlertStatus = &v
	return s
}

func (s *GetAlertRulesRequest) SetAlertType(v string) *GetAlertRulesRequest {
	s.AlertType = &v
	return s
}

func (s *GetAlertRulesRequest) SetClusterId(v string) *GetAlertRulesRequest {
	s.ClusterId = &v
	return s
}

func (s *GetAlertRulesRequest) SetPage(v int64) *GetAlertRulesRequest {
	s.Page = &v
	return s
}

func (s *GetAlertRulesRequest) SetProductCode(v string) *GetAlertRulesRequest {
	s.ProductCode = &v
	return s
}

func (s *GetAlertRulesRequest) SetRegionId(v string) *GetAlertRulesRequest {
	s.RegionId = &v
	return s
}

func (s *GetAlertRulesRequest) SetSize(v int64) *GetAlertRulesRequest {
	s.Size = &v
	return s
}

func (s *GetAlertRulesRequest) SetTags(v []*GetAlertRulesRequestTags) *GetAlertRulesRequest {
	s.Tags = v
	return s
}

type GetAlertRulesRequestTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetAlertRulesRequestTags) String() string {
	return tea.Prettify(s)
}

func (s GetAlertRulesRequestTags) GoString() string {
	return s.String()
}

func (s *GetAlertRulesRequestTags) SetKey(v string) *GetAlertRulesRequestTags {
	s.Key = &v
	return s
}

func (s *GetAlertRulesRequestTags) SetValue(v string) *GetAlertRulesRequestTags {
	s.Value = &v
	return s
}

type GetAlertRulesResponseBody struct {
	// The pages returned.
	PageBean *GetAlertRulesResponseBodyPageBean `json:"PageBean,omitempty" xml:"PageBean,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAlertRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAlertRulesResponseBody) GoString() string {
	return s.String()
}

func (s *GetAlertRulesResponseBody) SetPageBean(v *GetAlertRulesResponseBodyPageBean) *GetAlertRulesResponseBody {
	s.PageBean = v
	return s
}

func (s *GetAlertRulesResponseBody) SetRequestId(v string) *GetAlertRulesResponseBody {
	s.RequestId = &v
	return s
}

type GetAlertRulesResponseBodyPageBean struct {
	// The list of alert rules.
	AlertRules []*GetAlertRulesResponseBodyPageBeanAlertRules `json:"AlertRules,omitempty" xml:"AlertRules,omitempty" type:"Repeated"`
	// The number of pages returned.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of alert rules returned per page.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The total number of queried alert rules.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s GetAlertRulesResponseBodyPageBean) String() string {
	return tea.Prettify(s)
}

func (s GetAlertRulesResponseBodyPageBean) GoString() string {
	return s.String()
}

func (s *GetAlertRulesResponseBodyPageBean) SetAlertRules(v []*GetAlertRulesResponseBodyPageBeanAlertRules) *GetAlertRulesResponseBodyPageBean {
	s.AlertRules = v
	return s
}

func (s *GetAlertRulesResponseBodyPageBean) SetPage(v int64) *GetAlertRulesResponseBodyPageBean {
	s.Page = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBean) SetSize(v int64) *GetAlertRulesResponseBodyPageBean {
	s.Size = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBean) SetTotal(v int64) *GetAlertRulesResponseBodyPageBean {
	s.Total = &v
	return s
}

type GetAlertRulesResponseBodyPageBeanAlertRules struct {
	// The alert check type of the Prometheus alert rule. Valid values:
	//
	// *   STATIC: static threshold value
	// *   CUSTOM: custom PromQL statement
	AlertCheckType *string `json:"AlertCheckType,omitempty" xml:"AlertCheckType,omitempty"`
	// The ID of the alert contact group to which the alert rule belongs. Valid values:
	//
	// *   \-1: custom PromQL
	// *   1: Kubernetes load
	// *   15: Kubernetes node
	AlertGroup *int64 `json:"AlertGroup,omitempty" xml:"AlertGroup,omitempty"`
	// The ID of the alert rule.
	AlertId *float32 `json:"AlertId,omitempty" xml:"AlertId,omitempty"`
	// The name of the alert rule.
	AlertName *string `json:"AlertName,omitempty" xml:"AlertName,omitempty"`
	// The content of the Application Monitoring or Browser Monitoring alert rule.
	AlertRuleContent *GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent `json:"AlertRuleContent,omitempty" xml:"AlertRuleContent,omitempty" type:"Struct"`
	// The status of the alert rule. Valid values:
	//
	// *   RUNNING
	// *   STOPPED
	// *   PAUSED
	//
	// > The **PAUSED** status indicates that the alert rule is abnormal and is actively paused by the system. The alert rule may be paused because that it is not unique or the associated cluster has been deleted.
	AlertStatus *string `json:"AlertStatus,omitempty" xml:"AlertStatus,omitempty"`
	// The type of the alert rule.
	//
	// *   APPLICATION_MONITORING_ALERT_RULE: alert rule for Application Monitoring
	// *   BROWSER_MONITORING_ALERT_RULE: alert rule for Browser Monitoring
	// *   PROMETHEUS_MONITORING_ALERT_RULE: alert rule for Managed Service for Prometheus
	AlertType *string `json:"AlertType,omitempty" xml:"AlertType,omitempty"`
	// The annotations of the Prometheus alert rule.
	Annotations []*GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations `json:"Annotations,omitempty" xml:"Annotations,omitempty" type:"Repeated"`
	// Indicates whether the alert rule was applied to new applications that were created in Application Monitoring or Browser Monitoring. Valid values:
	//
	// *   `true`
	// *   `false`
	AutoAddNewApplication *bool `json:"AutoAddNewApplication,omitempty" xml:"AutoAddNewApplication,omitempty"`
	// The cluster ID of the Prometheus alert rule.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The time when the alert rule was created. The value is a timestamp. Unit: milliseconds.
	CreatedTime *int64 `json:"CreatedTime,omitempty" xml:"CreatedTime,omitempty"`
	// The duration of the Prometheus alert rule.
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The extended fields.
	//
	// > For existing Application Monitoring alert rules, the fields contained information such as contacts, alert template, and notification content.
	Extend *string `json:"Extend,omitempty" xml:"Extend,omitempty"`
	// The filter conditions of the Application Monitoring or Browser Monitoring alert rule.
	Filters *GetAlertRulesResponseBodyPageBeanAlertRulesFilters `json:"Filters,omitempty" xml:"Filters,omitempty" type:"Struct"`
	// The tags of the Prometheus alert rule.
	Labels []*GetAlertRulesResponseBodyPageBeanAlertRulesLabels `json:"Labels,omitempty" xml:"Labels,omitempty" type:"Repeated"`
	// The severity level of the Prometheus alert rule.
	//
	// *   P1: Alert notifications are sent for major issues that affect the availability of core business, have a huge impact, and may lead to serious consequences.
	// *   P2: Alert notifications are sent for service errors that affect the system availability with relatively limited impact.
	// *   P3: Alert notifications are sent for issues that may cause service errors or negative effects, or alert notifications for services that are relatively less important.
	// *   P4: Alert notifications are sent for low-priority issues that do not affect your business.
	// *   Default: Alert notifications are sent regardless of alert levels.
	Level *string `json:"Level,omitempty" xml:"Level,omitempty"`
	// The alert message of the Prometheus alert rule.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The metric type of the Application Monitoring or Browser Monitoring alert rule.
	MetricsType *string `json:"MetricsType,omitempty" xml:"MetricsType,omitempty"`
	// The name of the notification policy.
	NotifyStrategy *string `json:"NotifyStrategy,omitempty" xml:"NotifyStrategy,omitempty"`
	// The process ID (PID) that was associated with the Application Monitoring or Browser Monitoring alert rule.
	Pids []*string `json:"Pids,omitempty" xml:"Pids,omitempty" type:"Repeated"`
	// The PromQL statement of the Prometheus alert rule.
	PromQL *string `json:"PromQL,omitempty" xml:"PromQL,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The list of tags.
	Tags []*GetAlertRulesResponseBodyPageBeanAlertRulesTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The time when the alert rule was updated. The value is a timestamp. Unit: milliseconds.
	UpdatedTime *int64 `json:"UpdatedTime,omitempty" xml:"UpdatedTime,omitempty"`
	// The ID of the Alibaba Cloud account to which the resource belongs.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s GetAlertRulesResponseBodyPageBeanAlertRules) String() string {
	return tea.Prettify(s)
}

func (s GetAlertRulesResponseBodyPageBeanAlertRules) GoString() string {
	return s.String()
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetAlertCheckType(v string) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.AlertCheckType = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetAlertGroup(v int64) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.AlertGroup = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetAlertId(v float32) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.AlertId = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetAlertName(v string) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.AlertName = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetAlertRuleContent(v *GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.AlertRuleContent = v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetAlertStatus(v string) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.AlertStatus = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetAlertType(v string) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.AlertType = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetAnnotations(v []*GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.Annotations = v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetAutoAddNewApplication(v bool) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.AutoAddNewApplication = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetClusterId(v string) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.ClusterId = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetCreatedTime(v int64) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.CreatedTime = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetDuration(v string) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.Duration = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetExtend(v string) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.Extend = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetFilters(v *GetAlertRulesResponseBodyPageBeanAlertRulesFilters) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.Filters = v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetLabels(v []*GetAlertRulesResponseBodyPageBeanAlertRulesLabels) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.Labels = v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetLevel(v string) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.Level = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetMessage(v string) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.Message = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetMetricsType(v string) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.MetricsType = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetNotifyStrategy(v string) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.NotifyStrategy = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetPids(v []*string) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.Pids = v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetPromQL(v string) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.PromQL = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetRegionId(v string) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.RegionId = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetTags(v []*GetAlertRulesResponseBodyPageBeanAlertRulesTags) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.Tags = v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetUpdatedTime(v int64) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.UpdatedTime = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRules) SetUserId(v string) *GetAlertRulesResponseBodyPageBeanAlertRules {
	s.UserId = &v
	return s
}

type GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent struct {
	// The trigger conditions of the Application Monitoring or Browser Monitoring alert rule.
	AlertRuleItems []*GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems `json:"AlertRuleItems,omitempty" xml:"AlertRuleItems,omitempty" type:"Repeated"`
	// The relationship between multiple alert conditions specified for the Application Monitoring or Browser Monitoring alert rule. Valid values:
	//
	// *   OR: meets any of the specified conditions.
	// *   AND: meets all the specified conditions.
	Condition *string `json:"Condition,omitempty" xml:"Condition,omitempty"`
}

func (s GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent) String() string {
	return tea.Prettify(s)
}

func (s GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent) GoString() string {
	return s.String()
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent) SetAlertRuleItems(v []*GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems) *GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent {
	s.AlertRuleItems = v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent) SetCondition(v string) *GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContent {
	s.Condition = &v
	return s
}

type GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems struct {
	// The aggregation method of the alert condition. Valid values:
	//
	// *   AVG: calculates the average value
	// *   SUM: calculates the total value
	// *   MAX: selects the maximum value
	// *   MIN: selects the minimum value
	Aggregate *string `json:"Aggregate,omitempty" xml:"Aggregate,omitempty"`
	// The metric of the alert condition.
	MetricKey *string `json:"MetricKey,omitempty" xml:"MetricKey,omitempty"`
	// Indicates the last N minutes.
	N *float32 `json:"N,omitempty" xml:"N,omitempty"`
	// The comparison operator that was used to compare the metric value with the threshold. Valid values:
	//
	// *   CURRENT_GTE: greater than or equal to
	// *   CURRENT_LTE: less than or equal to
	// *   PREVIOUS_UP: the increase percentage compared with the last period
	// *   PREVIOUS_DOWN: the decrease percentage compared with the last period
	// *   HOH_UP: the increase percentage compared with the last hour
	// *   HOH_DOWN: the decrease percentage compared with the last hour
	// *   DOD_UP: the increase percentage compared with the last day
	// *   DOD_DOWN: the decrease percentage compared with the last day
	Operator *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
	// The threshold of the alert condition.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems) String() string {
	return tea.Prettify(s)
}

func (s GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems) GoString() string {
	return s.String()
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems) SetAggregate(v string) *GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems {
	s.Aggregate = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems) SetMetricKey(v string) *GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems {
	s.MetricKey = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems) SetN(v float32) *GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems {
	s.N = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems) SetOperator(v string) *GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems {
	s.Operator = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems) SetValue(v string) *GetAlertRulesResponseBodyPageBeanAlertRulesAlertRuleContentAlertRuleItems {
	s.Value = &v
	return s
}

type GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations struct {
	// The key of the annotation.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The value of the annotation.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations) String() string {
	return tea.Prettify(s)
}

func (s GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations) GoString() string {
	return s.String()
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations) SetName(v string) *GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations {
	s.Name = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations) SetValue(v string) *GetAlertRulesResponseBodyPageBeanAlertRulesAnnotations {
	s.Value = &v
	return s
}

type GetAlertRulesResponseBodyPageBeanAlertRulesFilters struct {
	// The custom filter condition of the Browser Monitoring alert rule.
	CustomSLSFilters []*GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters `json:"CustomSLSFilters,omitempty" xml:"CustomSLSFilters,omitempty" type:"Repeated"`
	// The information of the aggregation dimension.
	CustomSLSGroupByDimensions []*string `json:"CustomSLSGroupByDimensions,omitempty" xml:"CustomSLSGroupByDimensions,omitempty" type:"Repeated"`
	// The details of the custom filter condition.
	CustomSLSWheres []*string `json:"CustomSLSWheres,omitempty" xml:"CustomSLSWheres,omitempty" type:"Repeated"`
	// The information about each filter condition of the Application Monitoring or Browser Monitoring alert rule.
	DimFilters []*GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters `json:"DimFilters,omitempty" xml:"DimFilters,omitempty" type:"Repeated"`
}

func (s GetAlertRulesResponseBodyPageBeanAlertRulesFilters) String() string {
	return tea.Prettify(s)
}

func (s GetAlertRulesResponseBodyPageBeanAlertRulesFilters) GoString() string {
	return s.String()
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesFilters) SetCustomSLSFilters(v []*GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters) *GetAlertRulesResponseBodyPageBeanAlertRulesFilters {
	s.CustomSLSFilters = v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesFilters) SetCustomSLSGroupByDimensions(v []*string) *GetAlertRulesResponseBodyPageBeanAlertRulesFilters {
	s.CustomSLSGroupByDimensions = v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesFilters) SetCustomSLSWheres(v []*string) *GetAlertRulesResponseBodyPageBeanAlertRulesFilters {
	s.CustomSLSWheres = v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesFilters) SetDimFilters(v []*GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters) *GetAlertRulesResponseBodyPageBeanAlertRulesFilters {
	s.DimFilters = v
	return s
}

type GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters struct {
	// The key of the filter condition.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The logical operator of the filter condition. Valid values:
	//
	// *   \=: equal to
	// *   not: not equal to
	Opt *string `json:"Opt,omitempty" xml:"Opt,omitempty"`
	// Indicates whether this filter condition was displayed on the frontend.
	Show *bool `json:"Show,omitempty" xml:"Show,omitempty"`
	// Indicates the log type of Browser Monitoring. This field was not included in other filter conditions.
	T *string `json:"T,omitempty" xml:"T,omitempty"`
	// The value of the filter condition.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters) String() string {
	return tea.Prettify(s)
}

func (s GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters) GoString() string {
	return s.String()
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters) SetKey(v string) *GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters {
	s.Key = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters) SetOpt(v string) *GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters {
	s.Opt = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters) SetShow(v bool) *GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters {
	s.Show = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters) SetT(v string) *GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters {
	s.T = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters) SetValue(v string) *GetAlertRulesResponseBodyPageBeanAlertRulesFiltersCustomSLSFilters {
	s.Value = &v
	return s
}

type GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters struct {
	// The key of the filter condition.
	FilterKey *string `json:"FilterKey,omitempty" xml:"FilterKey,omitempty"`
	// The logical operator of the filter condition.
	FilterOpt *string `json:"FilterOpt,omitempty" xml:"FilterOpt,omitempty"`
	// The details of the filter condition.
	FilterValues []*string `json:"FilterValues,omitempty" xml:"FilterValues,omitempty" type:"Repeated"`
}

func (s GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters) String() string {
	return tea.Prettify(s)
}

func (s GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters) GoString() string {
	return s.String()
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters) SetFilterKey(v string) *GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters {
	s.FilterKey = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters) SetFilterOpt(v string) *GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters {
	s.FilterOpt = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters) SetFilterValues(v []*string) *GetAlertRulesResponseBodyPageBeanAlertRulesFiltersDimFilters {
	s.FilterValues = v
	return s
}

type GetAlertRulesResponseBodyPageBeanAlertRulesLabels struct {
	// The tag key.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetAlertRulesResponseBodyPageBeanAlertRulesLabels) String() string {
	return tea.Prettify(s)
}

func (s GetAlertRulesResponseBodyPageBeanAlertRulesLabels) GoString() string {
	return s.String()
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesLabels) SetName(v string) *GetAlertRulesResponseBodyPageBeanAlertRulesLabels {
	s.Name = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesLabels) SetValue(v string) *GetAlertRulesResponseBodyPageBeanAlertRulesLabels {
	s.Value = &v
	return s
}

type GetAlertRulesResponseBodyPageBeanAlertRulesTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetAlertRulesResponseBodyPageBeanAlertRulesTags) String() string {
	return tea.Prettify(s)
}

func (s GetAlertRulesResponseBodyPageBeanAlertRulesTags) GoString() string {
	return s.String()
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesTags) SetKey(v string) *GetAlertRulesResponseBodyPageBeanAlertRulesTags {
	s.Key = &v
	return s
}

func (s *GetAlertRulesResponseBodyPageBeanAlertRulesTags) SetValue(v string) *GetAlertRulesResponseBodyPageBeanAlertRulesTags {
	s.Value = &v
	return s
}

type GetAlertRulesResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAlertRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAlertRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAlertRulesResponse) GoString() string {
	return s.String()
}

func (s *GetAlertRulesResponse) SetHeaders(v map[string]*string) *GetAlertRulesResponse {
	s.Headers = v
	return s
}

func (s *GetAlertRulesResponse) SetStatusCode(v int32) *GetAlertRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAlertRulesResponse) SetBody(v *GetAlertRulesResponseBody) *GetAlertRulesResponse {
	s.Body = v
	return s
}

type GetAppApiByPageRequest struct {
	// The page number of the returned page.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The end of the time range to query. Unit: milliseconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time interval between the data shards to be queried. Unit: milliseconds. Minimum value: 60000. Maximum value: 2147483647.
	IntervalMills *int32 `json:"IntervalMills,omitempty" xml:"IntervalMills,omitempty"`
	// The process identifier (PID) of the application. For information about how to obtain a PID, see [Obtain the PID of an application](https://www.alibabacloud.com/help/zh/doc-detail/186100.htm?spm=a2cdw.13409063.0.0.7a72281f0bkTfx#title-imy-7gj-qhr).
	PId *string `json:"PId,omitempty" xml:"PId,omitempty"`
	// The number of entries to return on each page. This parameter is no longer supported. The number of entries to return on each page. Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The beginning of the time range to query. Unit: milliseconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s GetAppApiByPageRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAppApiByPageRequest) GoString() string {
	return s.String()
}

func (s *GetAppApiByPageRequest) SetCurrentPage(v int32) *GetAppApiByPageRequest {
	s.CurrentPage = &v
	return s
}

func (s *GetAppApiByPageRequest) SetEndTime(v int64) *GetAppApiByPageRequest {
	s.EndTime = &v
	return s
}

func (s *GetAppApiByPageRequest) SetIntervalMills(v int32) *GetAppApiByPageRequest {
	s.IntervalMills = &v
	return s
}

func (s *GetAppApiByPageRequest) SetPId(v string) *GetAppApiByPageRequest {
	s.PId = &v
	return s
}

func (s *GetAppApiByPageRequest) SetPageSize(v int32) *GetAppApiByPageRequest {
	s.PageSize = &v
	return s
}

func (s *GetAppApiByPageRequest) SetRegionId(v string) *GetAppApiByPageRequest {
	s.RegionId = &v
	return s
}

func (s *GetAppApiByPageRequest) SetStartTime(v int64) *GetAppApiByPageRequest {
	s.StartTime = &v
	return s
}

type GetAppApiByPageResponseBody struct {
	// The HTTP status code returned for the request. Valid values:
	//
	// *   2XX: The request was successful.
	// *   3XX: A redirection message was returned.
	// *   4XX: The request was invalid.
	// *   5XX: A server error occurred.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The struct returned.
	Data *GetAppApiByPageResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   `true`: The call was successful.
	// *   `false`: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetAppApiByPageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAppApiByPageResponseBody) GoString() string {
	return s.String()
}

func (s *GetAppApiByPageResponseBody) SetCode(v int32) *GetAppApiByPageResponseBody {
	s.Code = &v
	return s
}

func (s *GetAppApiByPageResponseBody) SetData(v *GetAppApiByPageResponseBodyData) *GetAppApiByPageResponseBody {
	s.Data = v
	return s
}

func (s *GetAppApiByPageResponseBody) SetMessage(v string) *GetAppApiByPageResponseBody {
	s.Message = &v
	return s
}

func (s *GetAppApiByPageResponseBody) SetRequestId(v string) *GetAppApiByPageResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetAppApiByPageResponseBody) SetSuccess(v bool) *GetAppApiByPageResponseBody {
	s.Success = &v
	return s
}

type GetAppApiByPageResponseBodyData struct {
	// Is completed.
	Completed *bool `json:"Completed,omitempty" xml:"Completed,omitempty"`
	// The data entries.
	Items []map[string]interface{} `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
	// The page number of the returned page.
	Page *int32 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of returned entries.
	Total *string `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s GetAppApiByPageResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetAppApiByPageResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetAppApiByPageResponseBodyData) SetCompleted(v bool) *GetAppApiByPageResponseBodyData {
	s.Completed = &v
	return s
}

func (s *GetAppApiByPageResponseBodyData) SetItems(v []map[string]interface{}) *GetAppApiByPageResponseBodyData {
	s.Items = v
	return s
}

func (s *GetAppApiByPageResponseBodyData) SetPage(v int32) *GetAppApiByPageResponseBodyData {
	s.Page = &v
	return s
}

func (s *GetAppApiByPageResponseBodyData) SetPageSize(v int32) *GetAppApiByPageResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *GetAppApiByPageResponseBodyData) SetTotal(v string) *GetAppApiByPageResponseBodyData {
	s.Total = &v
	return s
}

type GetAppApiByPageResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAppApiByPageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAppApiByPageResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAppApiByPageResponse) GoString() string {
	return s.String()
}

func (s *GetAppApiByPageResponse) SetHeaders(v map[string]*string) *GetAppApiByPageResponse {
	s.Headers = v
	return s
}

func (s *GetAppApiByPageResponse) SetStatusCode(v int32) *GetAppApiByPageResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAppApiByPageResponse) SetBody(v *GetAppApiByPageResponseBody) *GetAppApiByPageResponse {
	s.Body = v
	return s
}

type GetAppJVMConfigRequest struct {
	// The end of the time range to query. Unit: milliseconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the application.
	//
	// Log on to the **ARMS console**. In the left-side navigation pane, choose **Application Monitoring** > **Applications**. On the **Applications** page, click the name of an application. The URL in the address bar contains the process ID (PID) of the application. The PID is indicated in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is eb4zdose6v%409781be0f44d\*\*\*\*, you must replace %40 with an at sign (@) to obtain eb4zdose6v@9781be0f44d\*\*\*\*.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The start time of the call method.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s GetAppJVMConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAppJVMConfigRequest) GoString() string {
	return s.String()
}

func (s *GetAppJVMConfigRequest) SetEndTime(v int64) *GetAppJVMConfigRequest {
	s.EndTime = &v
	return s
}

func (s *GetAppJVMConfigRequest) SetPid(v string) *GetAppJVMConfigRequest {
	s.Pid = &v
	return s
}

func (s *GetAppJVMConfigRequest) SetRegionId(v string) *GetAppJVMConfigRequest {
	s.RegionId = &v
	return s
}

func (s *GetAppJVMConfigRequest) SetStartTime(v int64) *GetAppJVMConfigRequest {
	s.StartTime = &v
	return s
}

type GetAppJVMConfigResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Java VM info list.
	JvmInfoList []*GetAppJVMConfigResponseBodyJvmInfoList `json:"JvmInfoList,omitempty" xml:"JvmInfoList,omitempty" type:"Repeated"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`
	// *   `false`
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetAppJVMConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAppJVMConfigResponseBody) GoString() string {
	return s.String()
}

func (s *GetAppJVMConfigResponseBody) SetCode(v int32) *GetAppJVMConfigResponseBody {
	s.Code = &v
	return s
}

func (s *GetAppJVMConfigResponseBody) SetJvmInfoList(v []*GetAppJVMConfigResponseBodyJvmInfoList) *GetAppJVMConfigResponseBody {
	s.JvmInfoList = v
	return s
}

func (s *GetAppJVMConfigResponseBody) SetMessage(v string) *GetAppJVMConfigResponseBody {
	s.Message = &v
	return s
}

func (s *GetAppJVMConfigResponseBody) SetRequestId(v string) *GetAppJVMConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetAppJVMConfigResponseBody) SetSuccess(v bool) *GetAppJVMConfigResponseBody {
	s.Success = &v
	return s
}

type GetAppJVMConfigResponseBodyJvmInfoList struct {
	// Agent version.
	AgentVersion *string `json:"AgentVersion,omitempty" xml:"AgentVersion,omitempty"`
	// The name of the elastic container instance.
	HostName *string `json:"HostName,omitempty" xml:"HostName,omitempty"`
	// Ip address.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The PID.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// Process Id.
	ProcId *string `json:"ProcId,omitempty" xml:"ProcId,omitempty"`
	// Java VM config.
	VmArgs *string `json:"VmArgs,omitempty" xml:"VmArgs,omitempty"`
}

func (s GetAppJVMConfigResponseBodyJvmInfoList) String() string {
	return tea.Prettify(s)
}

func (s GetAppJVMConfigResponseBodyJvmInfoList) GoString() string {
	return s.String()
}

func (s *GetAppJVMConfigResponseBodyJvmInfoList) SetAgentVersion(v string) *GetAppJVMConfigResponseBodyJvmInfoList {
	s.AgentVersion = &v
	return s
}

func (s *GetAppJVMConfigResponseBodyJvmInfoList) SetHostName(v string) *GetAppJVMConfigResponseBodyJvmInfoList {
	s.HostName = &v
	return s
}

func (s *GetAppJVMConfigResponseBodyJvmInfoList) SetIp(v string) *GetAppJVMConfigResponseBodyJvmInfoList {
	s.Ip = &v
	return s
}

func (s *GetAppJVMConfigResponseBodyJvmInfoList) SetPid(v string) *GetAppJVMConfigResponseBodyJvmInfoList {
	s.Pid = &v
	return s
}

func (s *GetAppJVMConfigResponseBodyJvmInfoList) SetProcId(v string) *GetAppJVMConfigResponseBodyJvmInfoList {
	s.ProcId = &v
	return s
}

func (s *GetAppJVMConfigResponseBodyJvmInfoList) SetVmArgs(v string) *GetAppJVMConfigResponseBodyJvmInfoList {
	s.VmArgs = &v
	return s
}

type GetAppJVMConfigResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAppJVMConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAppJVMConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAppJVMConfigResponse) GoString() string {
	return s.String()
}

func (s *GetAppJVMConfigResponse) SetHeaders(v map[string]*string) *GetAppJVMConfigResponse {
	s.Headers = v
	return s
}

func (s *GetAppJVMConfigResponse) SetStatusCode(v int32) *GetAppJVMConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAppJVMConfigResponse) SetBody(v *GetAppJVMConfigResponseBody) *GetAppJVMConfigResponse {
	s.Body = v
	return s
}

type GetAuthTokenRequest struct {
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetAuthTokenRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAuthTokenRequest) GoString() string {
	return s.String()
}

func (s *GetAuthTokenRequest) SetClusterId(v string) *GetAuthTokenRequest {
	s.ClusterId = &v
	return s
}

func (s *GetAuthTokenRequest) SetRegionId(v string) *GetAuthTokenRequest {
	s.RegionId = &v
	return s
}

type GetAuthTokenResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned authentication token.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`
	// *   `false`
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetAuthTokenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAuthTokenResponseBody) GoString() string {
	return s.String()
}

func (s *GetAuthTokenResponseBody) SetCode(v int32) *GetAuthTokenResponseBody {
	s.Code = &v
	return s
}

func (s *GetAuthTokenResponseBody) SetData(v string) *GetAuthTokenResponseBody {
	s.Data = &v
	return s
}

func (s *GetAuthTokenResponseBody) SetMessage(v string) *GetAuthTokenResponseBody {
	s.Message = &v
	return s
}

func (s *GetAuthTokenResponseBody) SetRequestId(v string) *GetAuthTokenResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetAuthTokenResponseBody) SetSuccess(v bool) *GetAuthTokenResponseBody {
	s.Success = &v
	return s
}

type GetAuthTokenResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAuthTokenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAuthTokenResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAuthTokenResponse) GoString() string {
	return s.String()
}

func (s *GetAuthTokenResponse) SetHeaders(v map[string]*string) *GetAuthTokenResponse {
	s.Headers = v
	return s
}

func (s *GetAuthTokenResponse) SetStatusCode(v int32) *GetAuthTokenResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAuthTokenResponse) SetBody(v *GetAuthTokenResponseBody) *GetAuthTokenResponse {
	s.Body = v
	return s
}

type GetCloudClusterAllUrlRequest struct {
	// The ID of the CloudMonitor instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetCloudClusterAllUrlRequest) String() string {
	return tea.Prettify(s)
}

func (s GetCloudClusterAllUrlRequest) GoString() string {
	return s.String()
}

func (s *GetCloudClusterAllUrlRequest) SetClusterId(v string) *GetCloudClusterAllUrlRequest {
	s.ClusterId = &v
	return s
}

func (s *GetCloudClusterAllUrlRequest) SetRegionId(v string) *GetCloudClusterAllUrlRequest {
	s.RegionId = &v
	return s
}

type GetCloudClusterAllUrlResponseBody struct {
	// 状态码。200为成功，其他状态码为异常。
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// An array object.
	Data []*GetCloudClusterAllUrlResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// 详细信息。
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// 操作是否成功：true：操作成功                                 false：操作失败
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetCloudClusterAllUrlResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetCloudClusterAllUrlResponseBody) GoString() string {
	return s.String()
}

func (s *GetCloudClusterAllUrlResponseBody) SetCode(v int32) *GetCloudClusterAllUrlResponseBody {
	s.Code = &v
	return s
}

func (s *GetCloudClusterAllUrlResponseBody) SetData(v []*GetCloudClusterAllUrlResponseBodyData) *GetCloudClusterAllUrlResponseBody {
	s.Data = v
	return s
}

func (s *GetCloudClusterAllUrlResponseBody) SetMessage(v string) *GetCloudClusterAllUrlResponseBody {
	s.Message = &v
	return s
}

func (s *GetCloudClusterAllUrlResponseBody) SetRequestId(v string) *GetCloudClusterAllUrlResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetCloudClusterAllUrlResponseBody) SetSuccess(v bool) *GetCloudClusterAllUrlResponseBody {
	s.Success = &v
	return s
}

type GetCloudClusterAllUrlResponseBodyData struct {
	// The identifier of the cloud service.
	ProductCode *string `json:"ProductCode,omitempty" xml:"ProductCode,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The URLs for remote read and write. The value is a JSON string.
	RemoteUrl *GetCloudClusterAllUrlResponseBodyDataRemoteUrl `json:"RemoteUrl,omitempty" xml:"RemoteUrl,omitempty" type:"Struct"`
}

func (s GetCloudClusterAllUrlResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetCloudClusterAllUrlResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetCloudClusterAllUrlResponseBodyData) SetProductCode(v string) *GetCloudClusterAllUrlResponseBodyData {
	s.ProductCode = &v
	return s
}

func (s *GetCloudClusterAllUrlResponseBodyData) SetRegion(v string) *GetCloudClusterAllUrlResponseBodyData {
	s.Region = &v
	return s
}

func (s *GetCloudClusterAllUrlResponseBodyData) SetRemoteUrl(v *GetCloudClusterAllUrlResponseBodyDataRemoteUrl) *GetCloudClusterAllUrlResponseBodyData {
	s.RemoteUrl = v
	return s
}

type GetCloudClusterAllUrlResponseBodyDataRemoteUrl struct {
	// Indicates whether authentication is enabled.
	AuthToken *bool `json:"AuthToken,omitempty" xml:"AuthToken,omitempty"`
	// The internal URL for Grafana.
	GrafanaUrl *string `json:"GrafanaUrl,omitempty" xml:"GrafanaUrl,omitempty"`
	// The public URL for Grafana.
	InternetGrafanaUrl *string `json:"InternetGrafanaUrl,omitempty" xml:"InternetGrafanaUrl,omitempty"`
	// The public URL for Pushgateway.
	InternetPushGatewayUrl *string `json:"InternetPushGatewayUrl,omitempty" xml:"InternetPushGatewayUrl,omitempty"`
	// The public URL for remote read.
	InternetRemoteReadUrl *string `json:"InternetRemoteReadUrl,omitempty" xml:"InternetRemoteReadUrl,omitempty"`
	// The public URL for remote write.
	InternetRemoteWriteUrl *string `json:"InternetRemoteWriteUrl,omitempty" xml:"InternetRemoteWriteUrl,omitempty"`
	// The internal URL for Pushgateway.
	PushGatewayUrl *string `json:"PushGatewayUrl,omitempty" xml:"PushGatewayUrl,omitempty"`
	// The internal URL for remote read.
	RemoteReadUrl *string `json:"RemoteReadUrl,omitempty" xml:"RemoteReadUrl,omitempty"`
	// The internal URL for remote write.
	RemoteWriteUrl *string `json:"RemoteWriteUrl,omitempty" xml:"RemoteWriteUrl,omitempty"`
	// The token value used for authentication.
	Token *string `json:"Token,omitempty" xml:"Token,omitempty"`
}

func (s GetCloudClusterAllUrlResponseBodyDataRemoteUrl) String() string {
	return tea.Prettify(s)
}

func (s GetCloudClusterAllUrlResponseBodyDataRemoteUrl) GoString() string {
	return s.String()
}

func (s *GetCloudClusterAllUrlResponseBodyDataRemoteUrl) SetAuthToken(v bool) *GetCloudClusterAllUrlResponseBodyDataRemoteUrl {
	s.AuthToken = &v
	return s
}

func (s *GetCloudClusterAllUrlResponseBodyDataRemoteUrl) SetGrafanaUrl(v string) *GetCloudClusterAllUrlResponseBodyDataRemoteUrl {
	s.GrafanaUrl = &v
	return s
}

func (s *GetCloudClusterAllUrlResponseBodyDataRemoteUrl) SetInternetGrafanaUrl(v string) *GetCloudClusterAllUrlResponseBodyDataRemoteUrl {
	s.InternetGrafanaUrl = &v
	return s
}

func (s *GetCloudClusterAllUrlResponseBodyDataRemoteUrl) SetInternetPushGatewayUrl(v string) *GetCloudClusterAllUrlResponseBodyDataRemoteUrl {
	s.InternetPushGatewayUrl = &v
	return s
}

func (s *GetCloudClusterAllUrlResponseBodyDataRemoteUrl) SetInternetRemoteReadUrl(v string) *GetCloudClusterAllUrlResponseBodyDataRemoteUrl {
	s.InternetRemoteReadUrl = &v
	return s
}

func (s *GetCloudClusterAllUrlResponseBodyDataRemoteUrl) SetInternetRemoteWriteUrl(v string) *GetCloudClusterAllUrlResponseBodyDataRemoteUrl {
	s.InternetRemoteWriteUrl = &v
	return s
}

func (s *GetCloudClusterAllUrlResponseBodyDataRemoteUrl) SetPushGatewayUrl(v string) *GetCloudClusterAllUrlResponseBodyDataRemoteUrl {
	s.PushGatewayUrl = &v
	return s
}

func (s *GetCloudClusterAllUrlResponseBodyDataRemoteUrl) SetRemoteReadUrl(v string) *GetCloudClusterAllUrlResponseBodyDataRemoteUrl {
	s.RemoteReadUrl = &v
	return s
}

func (s *GetCloudClusterAllUrlResponseBodyDataRemoteUrl) SetRemoteWriteUrl(v string) *GetCloudClusterAllUrlResponseBodyDataRemoteUrl {
	s.RemoteWriteUrl = &v
	return s
}

func (s *GetCloudClusterAllUrlResponseBodyDataRemoteUrl) SetToken(v string) *GetCloudClusterAllUrlResponseBodyDataRemoteUrl {
	s.Token = &v
	return s
}

type GetCloudClusterAllUrlResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetCloudClusterAllUrlResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetCloudClusterAllUrlResponse) String() string {
	return tea.Prettify(s)
}

func (s GetCloudClusterAllUrlResponse) GoString() string {
	return s.String()
}

func (s *GetCloudClusterAllUrlResponse) SetHeaders(v map[string]*string) *GetCloudClusterAllUrlResponse {
	s.Headers = v
	return s
}

func (s *GetCloudClusterAllUrlResponse) SetStatusCode(v int32) *GetCloudClusterAllUrlResponse {
	s.StatusCode = &v
	return s
}

func (s *GetCloudClusterAllUrlResponse) SetBody(v *GetCloudClusterAllUrlResponseBody) *GetCloudClusterAllUrlResponse {
	s.Body = v
	return s
}

type GetClusterAllUrlRequest struct {
	// The cluster ID.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The region ID. Default value: cn-hangzhou.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetClusterAllUrlRequest) String() string {
	return tea.Prettify(s)
}

func (s GetClusterAllUrlRequest) GoString() string {
	return s.String()
}

func (s *GetClusterAllUrlRequest) SetClusterId(v string) *GetClusterAllUrlRequest {
	s.ClusterId = &v
	return s
}

func (s *GetClusterAllUrlRequest) SetRegionId(v string) *GetClusterAllUrlRequest {
	s.RegionId = &v
	return s
}

type GetClusterAllUrlResponseBody struct {
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The response parameters in the JSON format.
	Data    *string `json:"Data,omitempty" xml:"Data,omitempty"`
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetClusterAllUrlResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetClusterAllUrlResponseBody) GoString() string {
	return s.String()
}

func (s *GetClusterAllUrlResponseBody) SetCode(v int32) *GetClusterAllUrlResponseBody {
	s.Code = &v
	return s
}

func (s *GetClusterAllUrlResponseBody) SetData(v string) *GetClusterAllUrlResponseBody {
	s.Data = &v
	return s
}

func (s *GetClusterAllUrlResponseBody) SetMessage(v string) *GetClusterAllUrlResponseBody {
	s.Message = &v
	return s
}

func (s *GetClusterAllUrlResponseBody) SetRequestId(v string) *GetClusterAllUrlResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetClusterAllUrlResponseBody) SetSuccess(v bool) *GetClusterAllUrlResponseBody {
	s.Success = &v
	return s
}

type GetClusterAllUrlResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetClusterAllUrlResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetClusterAllUrlResponse) String() string {
	return tea.Prettify(s)
}

func (s GetClusterAllUrlResponse) GoString() string {
	return s.String()
}

func (s *GetClusterAllUrlResponse) SetHeaders(v map[string]*string) *GetClusterAllUrlResponse {
	s.Headers = v
	return s
}

func (s *GetClusterAllUrlResponse) SetStatusCode(v int32) *GetClusterAllUrlResponse {
	s.StatusCode = &v
	return s
}

func (s *GetClusterAllUrlResponse) SetBody(v *GetClusterAllUrlResponseBody) *GetClusterAllUrlResponse {
	s.Body = v
	return s
}

type GetCommercialStatusRequest struct {
	CommodityCode *string `json:"CommodityCode,omitempty" xml:"CommodityCode,omitempty"`
	RegionId      *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetCommercialStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s GetCommercialStatusRequest) GoString() string {
	return s.String()
}

func (s *GetCommercialStatusRequest) SetCommodityCode(v string) *GetCommercialStatusRequest {
	s.CommodityCode = &v
	return s
}

func (s *GetCommercialStatusRequest) SetRegionId(v string) *GetCommercialStatusRequest {
	s.RegionId = &v
	return s
}

type GetCommercialStatusResponseBody struct {
	// Id of the request
	RequestId              *string                                                `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	UserAndCommodityStatus *GetCommercialStatusResponseBodyUserAndCommodityStatus `json:"UserAndCommodityStatus,omitempty" xml:"UserAndCommodityStatus,omitempty" type:"Struct"`
}

func (s GetCommercialStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetCommercialStatusResponseBody) GoString() string {
	return s.String()
}

func (s *GetCommercialStatusResponseBody) SetRequestId(v string) *GetCommercialStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetCommercialStatusResponseBody) SetUserAndCommodityStatus(v *GetCommercialStatusResponseBodyUserAndCommodityStatus) *GetCommercialStatusResponseBody {
	s.UserAndCommodityStatus = v
	return s
}

type GetCommercialStatusResponseBodyUserAndCommodityStatus struct {
	Basic      *bool                  `json:"Basic,omitempty" xml:"Basic,omitempty"`
	ChargeType *string                `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	Enable     *bool                  `json:"Enable,omitempty" xml:"Enable,omitempty"`
	ExtraInfo  map[string]interface{} `json:"ExtraInfo,omitempty" xml:"ExtraInfo,omitempty"`
	FreeDays   *int64                 `json:"FreeDays,omitempty" xml:"FreeDays,omitempty"`
	Lable      *string                `json:"Lable,omitempty" xml:"Lable,omitempty"`
	Status     *string                `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetCommercialStatusResponseBodyUserAndCommodityStatus) String() string {
	return tea.Prettify(s)
}

func (s GetCommercialStatusResponseBodyUserAndCommodityStatus) GoString() string {
	return s.String()
}

func (s *GetCommercialStatusResponseBodyUserAndCommodityStatus) SetBasic(v bool) *GetCommercialStatusResponseBodyUserAndCommodityStatus {
	s.Basic = &v
	return s
}

func (s *GetCommercialStatusResponseBodyUserAndCommodityStatus) SetChargeType(v string) *GetCommercialStatusResponseBodyUserAndCommodityStatus {
	s.ChargeType = &v
	return s
}

func (s *GetCommercialStatusResponseBodyUserAndCommodityStatus) SetEnable(v bool) *GetCommercialStatusResponseBodyUserAndCommodityStatus {
	s.Enable = &v
	return s
}

func (s *GetCommercialStatusResponseBodyUserAndCommodityStatus) SetExtraInfo(v map[string]interface{}) *GetCommercialStatusResponseBodyUserAndCommodityStatus {
	s.ExtraInfo = v
	return s
}

func (s *GetCommercialStatusResponseBodyUserAndCommodityStatus) SetFreeDays(v int64) *GetCommercialStatusResponseBodyUserAndCommodityStatus {
	s.FreeDays = &v
	return s
}

func (s *GetCommercialStatusResponseBodyUserAndCommodityStatus) SetLable(v string) *GetCommercialStatusResponseBodyUserAndCommodityStatus {
	s.Lable = &v
	return s
}

func (s *GetCommercialStatusResponseBodyUserAndCommodityStatus) SetStatus(v string) *GetCommercialStatusResponseBodyUserAndCommodityStatus {
	s.Status = &v
	return s
}

type GetCommercialStatusResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetCommercialStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetCommercialStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s GetCommercialStatusResponse) GoString() string {
	return s.String()
}

func (s *GetCommercialStatusResponse) SetHeaders(v map[string]*string) *GetCommercialStatusResponse {
	s.Headers = v
	return s
}

func (s *GetCommercialStatusResponse) SetStatusCode(v int32) *GetCommercialStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *GetCommercialStatusResponse) SetBody(v *GetCommercialStatusResponseBody) *GetCommercialStatusResponse {
	s.Body = v
	return s
}

type GetExploreUrlRequest struct {
	// The cluster ID.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The query statement that corresponds to the data source.
	Expression *string `json:"Expression,omitempty" xml:"Expression,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The type of the Grafana data source.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetExploreUrlRequest) String() string {
	return tea.Prettify(s)
}

func (s GetExploreUrlRequest) GoString() string {
	return s.String()
}

func (s *GetExploreUrlRequest) SetClusterId(v string) *GetExploreUrlRequest {
	s.ClusterId = &v
	return s
}

func (s *GetExploreUrlRequest) SetExpression(v string) *GetExploreUrlRequest {
	s.Expression = &v
	return s
}

func (s *GetExploreUrlRequest) SetRegionId(v string) *GetExploreUrlRequest {
	s.RegionId = &v
	return s
}

func (s *GetExploreUrlRequest) SetType(v string) *GetExploreUrlRequest {
	s.Type = &v
	return s
}

type GetExploreUrlResponseBody struct {
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Response parameters
	Data    *string `json:"Data,omitempty" xml:"Data,omitempty"`
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetExploreUrlResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetExploreUrlResponseBody) GoString() string {
	return s.String()
}

func (s *GetExploreUrlResponseBody) SetCode(v int32) *GetExploreUrlResponseBody {
	s.Code = &v
	return s
}

func (s *GetExploreUrlResponseBody) SetData(v string) *GetExploreUrlResponseBody {
	s.Data = &v
	return s
}

func (s *GetExploreUrlResponseBody) SetMessage(v string) *GetExploreUrlResponseBody {
	s.Message = &v
	return s
}

func (s *GetExploreUrlResponseBody) SetRequestId(v string) *GetExploreUrlResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetExploreUrlResponseBody) SetSuccess(v bool) *GetExploreUrlResponseBody {
	s.Success = &v
	return s
}

type GetExploreUrlResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetExploreUrlResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetExploreUrlResponse) String() string {
	return tea.Prettify(s)
}

func (s GetExploreUrlResponse) GoString() string {
	return s.String()
}

func (s *GetExploreUrlResponse) SetHeaders(v map[string]*string) *GetExploreUrlResponse {
	s.Headers = v
	return s
}

func (s *GetExploreUrlResponse) SetStatusCode(v int32) *GetExploreUrlResponse {
	s.StatusCode = &v
	return s
}

func (s *GetExploreUrlResponse) SetBody(v *GetExploreUrlResponseBody) *GetExploreUrlResponse {
	s.Body = v
	return s
}

type GetGrafanaWorkspaceRequest struct {
	AliyunLang         *string `json:"AliyunLang,omitempty" xml:"AliyunLang,omitempty"`
	GrafanaWorkspaceId *string `json:"GrafanaWorkspaceId,omitempty" xml:"GrafanaWorkspaceId,omitempty"`
	RegionId           *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetGrafanaWorkspaceRequest) String() string {
	return tea.Prettify(s)
}

func (s GetGrafanaWorkspaceRequest) GoString() string {
	return s.String()
}

func (s *GetGrafanaWorkspaceRequest) SetAliyunLang(v string) *GetGrafanaWorkspaceRequest {
	s.AliyunLang = &v
	return s
}

func (s *GetGrafanaWorkspaceRequest) SetGrafanaWorkspaceId(v string) *GetGrafanaWorkspaceRequest {
	s.GrafanaWorkspaceId = &v
	return s
}

func (s *GetGrafanaWorkspaceRequest) SetRegionId(v string) *GetGrafanaWorkspaceRequest {
	s.RegionId = &v
	return s
}

type GetGrafanaWorkspaceResponseBody struct {
	Code    *int32            `json:"Code,omitempty" xml:"Code,omitempty"`
	Data    *GrafanaWorkspace `json:"Data,omitempty" xml:"Data,omitempty"`
	Message *string           `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
	TraceId   *string `json:"TraceId,omitempty" xml:"TraceId,omitempty"`
}

func (s GetGrafanaWorkspaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetGrafanaWorkspaceResponseBody) GoString() string {
	return s.String()
}

func (s *GetGrafanaWorkspaceResponseBody) SetCode(v int32) *GetGrafanaWorkspaceResponseBody {
	s.Code = &v
	return s
}

func (s *GetGrafanaWorkspaceResponseBody) SetData(v *GrafanaWorkspace) *GetGrafanaWorkspaceResponseBody {
	s.Data = v
	return s
}

func (s *GetGrafanaWorkspaceResponseBody) SetMessage(v string) *GetGrafanaWorkspaceResponseBody {
	s.Message = &v
	return s
}

func (s *GetGrafanaWorkspaceResponseBody) SetRequestId(v string) *GetGrafanaWorkspaceResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetGrafanaWorkspaceResponseBody) SetSuccess(v bool) *GetGrafanaWorkspaceResponseBody {
	s.Success = &v
	return s
}

func (s *GetGrafanaWorkspaceResponseBody) SetTraceId(v string) *GetGrafanaWorkspaceResponseBody {
	s.TraceId = &v
	return s
}

type GetGrafanaWorkspaceResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetGrafanaWorkspaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetGrafanaWorkspaceResponse) String() string {
	return tea.Prettify(s)
}

func (s GetGrafanaWorkspaceResponse) GoString() string {
	return s.String()
}

func (s *GetGrafanaWorkspaceResponse) SetHeaders(v map[string]*string) *GetGrafanaWorkspaceResponse {
	s.Headers = v
	return s
}

func (s *GetGrafanaWorkspaceResponse) SetStatusCode(v int32) *GetGrafanaWorkspaceResponse {
	s.StatusCode = &v
	return s
}

func (s *GetGrafanaWorkspaceResponse) SetBody(v *GetGrafanaWorkspaceResponseBody) *GetGrafanaWorkspaceResponse {
	s.Body = v
	return s
}

type GetIntegrationStateRequest struct {
	ClusterId   *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	Integration *string `json:"Integration,omitempty" xml:"Integration,omitempty"`
	RegionId    *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetIntegrationStateRequest) String() string {
	return tea.Prettify(s)
}

func (s GetIntegrationStateRequest) GoString() string {
	return s.String()
}

func (s *GetIntegrationStateRequest) SetClusterId(v string) *GetIntegrationStateRequest {
	s.ClusterId = &v
	return s
}

func (s *GetIntegrationStateRequest) SetIntegration(v string) *GetIntegrationStateRequest {
	s.Integration = &v
	return s
}

func (s *GetIntegrationStateRequest) SetRegionId(v string) *GetIntegrationStateRequest {
	s.RegionId = &v
	return s
}

type GetIntegrationStateResponseBody struct {
	// 状态码。200为成功，其他状态码为异常。
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// 返回结果的提示信息。
	Message   *string `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	State     *bool   `json:"State,omitempty" xml:"State,omitempty"`
}

func (s GetIntegrationStateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetIntegrationStateResponseBody) GoString() string {
	return s.String()
}

func (s *GetIntegrationStateResponseBody) SetCode(v int32) *GetIntegrationStateResponseBody {
	s.Code = &v
	return s
}

func (s *GetIntegrationStateResponseBody) SetMessage(v string) *GetIntegrationStateResponseBody {
	s.Message = &v
	return s
}

func (s *GetIntegrationStateResponseBody) SetRequestId(v string) *GetIntegrationStateResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetIntegrationStateResponseBody) SetState(v bool) *GetIntegrationStateResponseBody {
	s.State = &v
	return s
}

type GetIntegrationStateResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetIntegrationStateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetIntegrationStateResponse) String() string {
	return tea.Prettify(s)
}

func (s GetIntegrationStateResponse) GoString() string {
	return s.String()
}

func (s *GetIntegrationStateResponse) SetHeaders(v map[string]*string) *GetIntegrationStateResponse {
	s.Headers = v
	return s
}

func (s *GetIntegrationStateResponse) SetStatusCode(v int32) *GetIntegrationStateResponse {
	s.StatusCode = &v
	return s
}

func (s *GetIntegrationStateResponse) SetBody(v *GetIntegrationStateResponseBody) *GetIntegrationStateResponse {
	s.Body = v
	return s
}

type GetManagedPrometheusStatusRequest struct {
	// The ID of the ASK cluster. This parameter is required if the ClusterType parameter is set to ask.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The type of the monitoring object. Valid values: ask , acs , one and ecs.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the Prometheus instance belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// This parameter is required if the ClusterType parameter is set to ecs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s GetManagedPrometheusStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s GetManagedPrometheusStatusRequest) GoString() string {
	return s.String()
}

func (s *GetManagedPrometheusStatusRequest) SetClusterId(v string) *GetManagedPrometheusStatusRequest {
	s.ClusterId = &v
	return s
}

func (s *GetManagedPrometheusStatusRequest) SetClusterType(v string) *GetManagedPrometheusStatusRequest {
	s.ClusterType = &v
	return s
}

func (s *GetManagedPrometheusStatusRequest) SetRegionId(v string) *GetManagedPrometheusStatusRequest {
	s.RegionId = &v
	return s
}

func (s *GetManagedPrometheusStatusRequest) SetResourceGroupId(v string) *GetManagedPrometheusStatusRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *GetManagedPrometheusStatusRequest) SetVpcId(v string) *GetManagedPrometheusStatusRequest {
	s.VpcId = &v
	return s
}

type GetManagedPrometheusStatusResponseBody struct {
	// The status code or error code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The status of the Prometheus instance.
	//
	// *   Installing: The Prometheus instance is created and the Prometheus agent has no registration information.
	// *   Succeed: The Prometheus instance is created and the Prometheus agent is registered.
	// *   Failure: The Prometheus instance failed to be created or the Prometheus agent failed to be registered.
	// *   Unknown: No status of the Prometheus instance is available.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`
	// *   `false`
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetManagedPrometheusStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetManagedPrometheusStatusResponseBody) GoString() string {
	return s.String()
}

func (s *GetManagedPrometheusStatusResponseBody) SetCode(v int32) *GetManagedPrometheusStatusResponseBody {
	s.Code = &v
	return s
}

func (s *GetManagedPrometheusStatusResponseBody) SetData(v string) *GetManagedPrometheusStatusResponseBody {
	s.Data = &v
	return s
}

func (s *GetManagedPrometheusStatusResponseBody) SetMessage(v string) *GetManagedPrometheusStatusResponseBody {
	s.Message = &v
	return s
}

func (s *GetManagedPrometheusStatusResponseBody) SetRequestId(v string) *GetManagedPrometheusStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetManagedPrometheusStatusResponseBody) SetSuccess(v bool) *GetManagedPrometheusStatusResponseBody {
	s.Success = &v
	return s
}

type GetManagedPrometheusStatusResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetManagedPrometheusStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetManagedPrometheusStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s GetManagedPrometheusStatusResponse) GoString() string {
	return s.String()
}

func (s *GetManagedPrometheusStatusResponse) SetHeaders(v map[string]*string) *GetManagedPrometheusStatusResponse {
	s.Headers = v
	return s
}

func (s *GetManagedPrometheusStatusResponse) SetStatusCode(v int32) *GetManagedPrometheusStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *GetManagedPrometheusStatusResponse) SetBody(v *GetManagedPrometheusStatusResponseBody) *GetManagedPrometheusStatusResponse {
	s.Body = v
	return s
}

type GetMultipleTraceRequest struct {
	EndTime   *int64    `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	RegionId  *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	StartTime *int64    `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	TraceIDs  []*string `json:"TraceIDs,omitempty" xml:"TraceIDs,omitempty" type:"Repeated"`
}

func (s GetMultipleTraceRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMultipleTraceRequest) GoString() string {
	return s.String()
}

func (s *GetMultipleTraceRequest) SetEndTime(v int64) *GetMultipleTraceRequest {
	s.EndTime = &v
	return s
}

func (s *GetMultipleTraceRequest) SetRegionId(v string) *GetMultipleTraceRequest {
	s.RegionId = &v
	return s
}

func (s *GetMultipleTraceRequest) SetStartTime(v int64) *GetMultipleTraceRequest {
	s.StartTime = &v
	return s
}

func (s *GetMultipleTraceRequest) SetTraceIDs(v []*string) *GetMultipleTraceRequest {
	s.TraceIDs = v
	return s
}

type GetMultipleTraceResponseBody struct {
	MultiCallChainInfos []*GetMultipleTraceResponseBodyMultiCallChainInfos `json:"MultiCallChainInfos,omitempty" xml:"MultiCallChainInfos,omitempty" type:"Repeated"`
	RequestId           *string                                            `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetMultipleTraceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMultipleTraceResponseBody) GoString() string {
	return s.String()
}

func (s *GetMultipleTraceResponseBody) SetMultiCallChainInfos(v []*GetMultipleTraceResponseBodyMultiCallChainInfos) *GetMultipleTraceResponseBody {
	s.MultiCallChainInfos = v
	return s
}

func (s *GetMultipleTraceResponseBody) SetRequestId(v string) *GetMultipleTraceResponseBody {
	s.RequestId = &v
	return s
}

type GetMultipleTraceResponseBodyMultiCallChainInfos struct {
	Spans   []*GetMultipleTraceResponseBodyMultiCallChainInfosSpans `json:"Spans,omitempty" xml:"Spans,omitempty" type:"Repeated"`
	TraceID *string                                                 `json:"TraceID,omitempty" xml:"TraceID,omitempty"`
}

func (s GetMultipleTraceResponseBodyMultiCallChainInfos) String() string {
	return tea.Prettify(s)
}

func (s GetMultipleTraceResponseBodyMultiCallChainInfos) GoString() string {
	return s.String()
}

func (s *GetMultipleTraceResponseBodyMultiCallChainInfos) SetSpans(v []*GetMultipleTraceResponseBodyMultiCallChainInfosSpans) *GetMultipleTraceResponseBodyMultiCallChainInfos {
	s.Spans = v
	return s
}

func (s *GetMultipleTraceResponseBodyMultiCallChainInfos) SetTraceID(v string) *GetMultipleTraceResponseBodyMultiCallChainInfos {
	s.TraceID = &v
	return s
}

type GetMultipleTraceResponseBodyMultiCallChainInfosSpans struct {
	Duration      *int64                                                              `json:"Duration,omitempty" xml:"Duration,omitempty"`
	HaveStack     *bool                                                               `json:"HaveStack,omitempty" xml:"HaveStack,omitempty"`
	LogEventList  []*GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList `json:"LogEventList,omitempty" xml:"LogEventList,omitempty" type:"Repeated"`
	OperationName *string                                                             `json:"OperationName,omitempty" xml:"OperationName,omitempty"`
	ParentSpanId  *string                                                             `json:"ParentSpanId,omitempty" xml:"ParentSpanId,omitempty"`
	ResultCode    *string                                                             `json:"ResultCode,omitempty" xml:"ResultCode,omitempty"`
	RpcId         *string                                                             `json:"RpcId,omitempty" xml:"RpcId,omitempty"`
	RpcType       *int32                                                              `json:"RpcType,omitempty" xml:"RpcType,omitempty"`
	ServiceIp     *string                                                             `json:"ServiceIp,omitempty" xml:"ServiceIp,omitempty"`
	ServiceName   *string                                                             `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	SpanId        *string                                                             `json:"SpanId,omitempty" xml:"SpanId,omitempty"`
	TagEntryList  []*GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList `json:"TagEntryList,omitempty" xml:"TagEntryList,omitempty" type:"Repeated"`
	Timestamp     *int64                                                              `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	TraceID       *string                                                             `json:"TraceID,omitempty" xml:"TraceID,omitempty"`
}

func (s GetMultipleTraceResponseBodyMultiCallChainInfosSpans) String() string {
	return tea.Prettify(s)
}

func (s GetMultipleTraceResponseBodyMultiCallChainInfosSpans) GoString() string {
	return s.String()
}

func (s *GetMultipleTraceResponseBodyMultiCallChainInfosSpans) SetDuration(v int64) *GetMultipleTraceResponseBodyMultiCallChainInfosSpans {
	s.Duration = &v
	return s
}

func (s *GetMultipleTraceResponseBodyMultiCallChainInfosSpans) SetHaveStack(v bool) *GetMultipleTraceResponseBodyMultiCallChainInfosSpans {
	s.HaveStack = &v
	return s
}

func (s *GetMultipleTraceResponseBodyMultiCallChainInfosSpans) SetLogEventList(v []*GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList) *GetMultipleTraceResponseBodyMultiCallChainInfosSpans {
	s.LogEventList = v
	return s
}

func (s *GetMultipleTraceResponseBodyMultiCallChainInfosSpans) SetOperationName(v string) *GetMultipleTraceResponseBodyMultiCallChainInfosSpans {
	s.OperationName = &v
	return s
}

func (s *GetMultipleTraceResponseBodyMultiCallChainInfosSpans) SetParentSpanId(v string) *GetMultipleTraceResponseBodyMultiCallChainInfosSpans {
	s.ParentSpanId = &v
	return s
}

func (s *GetMultipleTraceResponseBodyMultiCallChainInfosSpans) SetResultCode(v string) *GetMultipleTraceResponseBodyMultiCallChainInfosSpans {
	s.ResultCode = &v
	return s
}

func (s *GetMultipleTraceResponseBodyMultiCallChainInfosSpans) SetRpcId(v string) *GetMultipleTraceResponseBodyMultiCallChainInfosSpans {
	s.RpcId = &v
	return s
}

func (s *GetMultipleTraceResponseBodyMultiCallChainInfosSpans) SetRpcType(v int32) *GetMultipleTraceResponseBodyMultiCallChainInfosSpans {
	s.RpcType = &v
	return s
}

func (s *GetMultipleTraceResponseBodyMultiCallChainInfosSpans) SetServiceIp(v string) *GetMultipleTraceResponseBodyMultiCallChainInfosSpans {
	s.ServiceIp = &v
	return s
}

func (s *GetMultipleTraceResponseBodyMultiCallChainInfosSpans) SetServiceName(v string) *GetMultipleTraceResponseBodyMultiCallChainInfosSpans {
	s.ServiceName = &v
	return s
}

func (s *GetMultipleTraceResponseBodyMultiCallChainInfosSpans) SetSpanId(v string) *GetMultipleTraceResponseBodyMultiCallChainInfosSpans {
	s.SpanId = &v
	return s
}

func (s *GetMultipleTraceResponseBodyMultiCallChainInfosSpans) SetTagEntryList(v []*GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList) *GetMultipleTraceResponseBodyMultiCallChainInfosSpans {
	s.TagEntryList = v
	return s
}

func (s *GetMultipleTraceResponseBodyMultiCallChainInfosSpans) SetTimestamp(v int64) *GetMultipleTraceResponseBodyMultiCallChainInfosSpans {
	s.Timestamp = &v
	return s
}

func (s *GetMultipleTraceResponseBodyMultiCallChainInfosSpans) SetTraceID(v string) *GetMultipleTraceResponseBodyMultiCallChainInfosSpans {
	s.TraceID = &v
	return s
}

type GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList struct {
	TagEntryList []*GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList `json:"TagEntryList,omitempty" xml:"TagEntryList,omitempty" type:"Repeated"`
	Timestamp    *int64                                                                          `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
}

func (s GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList) String() string {
	return tea.Prettify(s)
}

func (s GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList) GoString() string {
	return s.String()
}

func (s *GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList) SetTagEntryList(v []*GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList) *GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList {
	s.TagEntryList = v
	return s
}

func (s *GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList) SetTimestamp(v int64) *GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventList {
	s.Timestamp = &v
	return s
}

type GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList) String() string {
	return tea.Prettify(s)
}

func (s GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList) GoString() string {
	return s.String()
}

func (s *GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList) SetKey(v string) *GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList {
	s.Key = &v
	return s
}

func (s *GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList) SetValue(v string) *GetMultipleTraceResponseBodyMultiCallChainInfosSpansLogEventListTagEntryList {
	s.Value = &v
	return s
}

type GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList) String() string {
	return tea.Prettify(s)
}

func (s GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList) GoString() string {
	return s.String()
}

func (s *GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList) SetKey(v string) *GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList {
	s.Key = &v
	return s
}

func (s *GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList) SetValue(v string) *GetMultipleTraceResponseBodyMultiCallChainInfosSpansTagEntryList {
	s.Value = &v
	return s
}

type GetMultipleTraceResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetMultipleTraceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetMultipleTraceResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMultipleTraceResponse) GoString() string {
	return s.String()
}

func (s *GetMultipleTraceResponse) SetHeaders(v map[string]*string) *GetMultipleTraceResponse {
	s.Headers = v
	return s
}

func (s *GetMultipleTraceResponse) SetStatusCode(v int32) *GetMultipleTraceResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMultipleTraceResponse) SetBody(v *GetMultipleTraceResponseBody) *GetMultipleTraceResponse {
	s.Body = v
	return s
}

type GetOnCallSchedulesDetailRequest struct {
	// The date on which the shift ends. Format: `yyyy-MM-dd`.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the scheduling policy.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The date from which the shift starts. Format: `yyyy-MM-dd`.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s GetOnCallSchedulesDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetOnCallSchedulesDetailRequest) GoString() string {
	return s.String()
}

func (s *GetOnCallSchedulesDetailRequest) SetEndTime(v string) *GetOnCallSchedulesDetailRequest {
	s.EndTime = &v
	return s
}

func (s *GetOnCallSchedulesDetailRequest) SetId(v int64) *GetOnCallSchedulesDetailRequest {
	s.Id = &v
	return s
}

func (s *GetOnCallSchedulesDetailRequest) SetStartTime(v string) *GetOnCallSchedulesDetailRequest {
	s.StartTime = &v
	return s
}

type GetOnCallSchedulesDetailResponseBody struct {
	// The information about the scheduling policy.
	Data *GetOnCallSchedulesDetailResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetOnCallSchedulesDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetOnCallSchedulesDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetOnCallSchedulesDetailResponseBody) SetData(v *GetOnCallSchedulesDetailResponseBodyData) *GetOnCallSchedulesDetailResponseBody {
	s.Data = v
	return s
}

func (s *GetOnCallSchedulesDetailResponseBody) SetRequestId(v string) *GetOnCallSchedulesDetailResponseBody {
	s.RequestId = &v
	return s
}

type GetOnCallSchedulesDetailResponseBodyData struct {
	// The URL of the DingTalk chatbot, which is used to receive notifications about shift changes.
	AlertRobotId *int64 `json:"AlertRobotId,omitempty" xml:"AlertRobotId,omitempty"`
	// The description of the scheduling policy.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the scheduling policy.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the scheduling policy.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The information about the final user on duty.
	RenderedFinnalEntries []*GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries `json:"RenderedFinnalEntries,omitempty" xml:"RenderedFinnalEntries,omitempty" type:"Repeated"`
	// The scheduled users on duty within a time range.
	RenderedLayerEntries [][]*GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries `json:"RenderedLayerEntries,omitempty" xml:"RenderedLayerEntries,omitempty" type:"Repeated"`
	// The information about the substitutes within a time range.
	RenderedSubstitudeEntries []*GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries `json:"RenderedSubstitudeEntries,omitempty" xml:"RenderedSubstitudeEntries,omitempty" type:"Repeated"`
	// The information about the shift.
	ScheduleLayers []*GetOnCallSchedulesDetailResponseBodyDataScheduleLayers `json:"ScheduleLayers,omitempty" xml:"ScheduleLayers,omitempty" type:"Repeated"`
}

func (s GetOnCallSchedulesDetailResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetOnCallSchedulesDetailResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetOnCallSchedulesDetailResponseBodyData) SetAlertRobotId(v int64) *GetOnCallSchedulesDetailResponseBodyData {
	s.AlertRobotId = &v
	return s
}

func (s *GetOnCallSchedulesDetailResponseBodyData) SetDescription(v string) *GetOnCallSchedulesDetailResponseBodyData {
	s.Description = &v
	return s
}

func (s *GetOnCallSchedulesDetailResponseBodyData) SetId(v int64) *GetOnCallSchedulesDetailResponseBodyData {
	s.Id = &v
	return s
}

func (s *GetOnCallSchedulesDetailResponseBodyData) SetName(v string) *GetOnCallSchedulesDetailResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetOnCallSchedulesDetailResponseBodyData) SetRenderedFinnalEntries(v []*GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries) *GetOnCallSchedulesDetailResponseBodyData {
	s.RenderedFinnalEntries = v
	return s
}

func (s *GetOnCallSchedulesDetailResponseBodyData) SetRenderedLayerEntries(v [][]*GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries) *GetOnCallSchedulesDetailResponseBodyData {
	s.RenderedLayerEntries = v
	return s
}

func (s *GetOnCallSchedulesDetailResponseBodyData) SetRenderedSubstitudeEntries(v []*GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries) *GetOnCallSchedulesDetailResponseBodyData {
	s.RenderedSubstitudeEntries = v
	return s
}

func (s *GetOnCallSchedulesDetailResponseBodyData) SetScheduleLayers(v []*GetOnCallSchedulesDetailResponseBodyDataScheduleLayers) *GetOnCallSchedulesDetailResponseBodyData {
	s.ScheduleLayers = v
	return s
}

type GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries struct {
	// The date on which the user completed shift work.
	End *string `json:"End,omitempty" xml:"End,omitempty"`
	// The information about the user on duty.
	SimpleContact *GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact `json:"SimpleContact,omitempty" xml:"SimpleContact,omitempty" type:"Struct"`
	// The date from which the user started shift work.
	Start *string `json:"Start,omitempty" xml:"Start,omitempty"`
}

func (s GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries) String() string {
	return tea.Prettify(s)
}

func (s GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries) GoString() string {
	return s.String()
}

func (s *GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries) SetEnd(v string) *GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries {
	s.End = &v
	return s
}

func (s *GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries) SetSimpleContact(v *GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact) *GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries {
	s.SimpleContact = v
	return s
}

func (s *GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries) SetStart(v string) *GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntries {
	s.Start = &v
	return s
}

type GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact struct {
	// The ID of the user on duty.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the user on duty.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact) String() string {
	return tea.Prettify(s)
}

func (s GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact) GoString() string {
	return s.String()
}

func (s *GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact) SetId(v int64) *GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact {
	s.Id = &v
	return s
}

func (s *GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact) SetName(v string) *GetOnCallSchedulesDetailResponseBodyDataRenderedFinnalEntriesSimpleContact {
	s.Name = &v
	return s
}

type GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries struct {
	// The date from which the scheduled user was supposed to start shift work.
	Start *string `json:"Start,omitempty" xml:"Start,omitempty"`
	// The date on which the scheduled user was supposed to complete shift work.
	End *string `json:"End,omitempty" xml:"End,omitempty"`
	// The information about the scheduled user.
	SimpleContact *GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact `json:"SimpleContact,omitempty" xml:"SimpleContact,omitempty" type:"Struct"`
}

func (s GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries) String() string {
	return tea.Prettify(s)
}

func (s GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries) GoString() string {
	return s.String()
}

func (s *GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries) SetStart(v string) *GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries {
	s.Start = &v
	return s
}

func (s *GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries) SetEnd(v string) *GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries {
	s.End = &v
	return s
}

func (s *GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries) SetSimpleContact(v *GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact) *GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntries {
	s.SimpleContact = v
	return s
}

type GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact struct {
	// The ID of the scheduled user.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the scheduled user.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact) String() string {
	return tea.Prettify(s)
}

func (s GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact) GoString() string {
	return s.String()
}

func (s *GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact) SetId(v int64) *GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact {
	s.Id = &v
	return s
}

func (s *GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact) SetName(v string) *GetOnCallSchedulesDetailResponseBodyDataRenderedLayerEntriesSimpleContact {
	s.Name = &v
	return s
}

type GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries struct {
	// The date on which the substitute was supposed to complete shift work.
	End *string `json:"End,omitempty" xml:"End,omitempty"`
	// The information about the substitute.
	SimpleContact *GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact `json:"SimpleContact,omitempty" xml:"SimpleContact,omitempty" type:"Struct"`
	// The date from which the substitute was supposed to start shift work.
	Start *string `json:"Start,omitempty" xml:"Start,omitempty"`
}

func (s GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries) String() string {
	return tea.Prettify(s)
}

func (s GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries) GoString() string {
	return s.String()
}

func (s *GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries) SetEnd(v string) *GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries {
	s.End = &v
	return s
}

func (s *GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries) SetSimpleContact(v *GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact) *GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries {
	s.SimpleContact = v
	return s
}

func (s *GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries) SetStart(v string) *GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntries {
	s.Start = &v
	return s
}

type GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact struct {
	// The ID of the substitute.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the substitute.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact) String() string {
	return tea.Prettify(s)
}

func (s GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact) GoString() string {
	return s.String()
}

func (s *GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact) SetId(v int64) *GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact {
	s.Id = &v
	return s
}

func (s *GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact) SetName(v string) *GetOnCallSchedulesDetailResponseBodyDataRenderedSubstitudeEntriesSimpleContact {
	s.Name = &v
	return s
}

type GetOnCallSchedulesDetailResponseBodyDataScheduleLayers struct {
	// The ID list of users on duty.
	ContactIds []*int64 `json:"ContactIds,omitempty" xml:"ContactIds,omitempty" type:"Repeated"`
	// The limit on the time of the shift.
	Restrictions []*GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions `json:"Restrictions,omitempty" xml:"Restrictions,omitempty" type:"Repeated"`
	// The type of the shift. Valid values:
	//
	// *   DAY
	// *   WEEK
	// *   CUSTOM
	RotationType *string `json:"RotationType,omitempty" xml:"RotationType,omitempty"`
	// The shift cycle. Unit: hours.
	ShiftLength *int64 `json:"ShiftLength,omitempty" xml:"ShiftLength,omitempty"`
	// The date on which the shift change took effect.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s GetOnCallSchedulesDetailResponseBodyDataScheduleLayers) String() string {
	return tea.Prettify(s)
}

func (s GetOnCallSchedulesDetailResponseBodyDataScheduleLayers) GoString() string {
	return s.String()
}

func (s *GetOnCallSchedulesDetailResponseBodyDataScheduleLayers) SetContactIds(v []*int64) *GetOnCallSchedulesDetailResponseBodyDataScheduleLayers {
	s.ContactIds = v
	return s
}

func (s *GetOnCallSchedulesDetailResponseBodyDataScheduleLayers) SetRestrictions(v []*GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions) *GetOnCallSchedulesDetailResponseBodyDataScheduleLayers {
	s.Restrictions = v
	return s
}

func (s *GetOnCallSchedulesDetailResponseBodyDataScheduleLayers) SetRotationType(v string) *GetOnCallSchedulesDetailResponseBodyDataScheduleLayers {
	s.RotationType = &v
	return s
}

func (s *GetOnCallSchedulesDetailResponseBodyDataScheduleLayers) SetShiftLength(v int64) *GetOnCallSchedulesDetailResponseBodyDataScheduleLayers {
	s.ShiftLength = &v
	return s
}

func (s *GetOnCallSchedulesDetailResponseBodyDataScheduleLayers) SetStartTime(v string) *GetOnCallSchedulesDetailResponseBodyDataScheduleLayers {
	s.StartTime = &v
	return s
}

type GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions struct {
	// The end time of the shift per day.
	EndTimeOfDay *string `json:"EndTimeOfDay,omitempty" xml:"EndTimeOfDay,omitempty"`
	// The type of the limit. Valid values:
	//
	// *   daily_restriction
	// *   weekly_restriction
	RestrictionType *string `json:"RestrictionType,omitempty" xml:"RestrictionType,omitempty"`
	// The start time of the shift per day.
	StartTimeOfDay *string `json:"StartTimeOfDay,omitempty" xml:"StartTimeOfDay,omitempty"`
}

func (s GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions) String() string {
	return tea.Prettify(s)
}

func (s GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions) GoString() string {
	return s.String()
}

func (s *GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions) SetEndTimeOfDay(v string) *GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions {
	s.EndTimeOfDay = &v
	return s
}

func (s *GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions) SetRestrictionType(v string) *GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions {
	s.RestrictionType = &v
	return s
}

func (s *GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions) SetStartTimeOfDay(v string) *GetOnCallSchedulesDetailResponseBodyDataScheduleLayersRestrictions {
	s.StartTimeOfDay = &v
	return s
}

type GetOnCallSchedulesDetailResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetOnCallSchedulesDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetOnCallSchedulesDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetOnCallSchedulesDetailResponse) GoString() string {
	return s.String()
}

func (s *GetOnCallSchedulesDetailResponse) SetHeaders(v map[string]*string) *GetOnCallSchedulesDetailResponse {
	s.Headers = v
	return s
}

func (s *GetOnCallSchedulesDetailResponse) SetStatusCode(v int32) *GetOnCallSchedulesDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetOnCallSchedulesDetailResponse) SetBody(v *GetOnCallSchedulesDetailResponseBody) *GetOnCallSchedulesDetailResponse {
	s.Body = v
	return s
}

type GetPrometheusApiTokenRequest struct {
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetPrometheusApiTokenRequest) String() string {
	return tea.Prettify(s)
}

func (s GetPrometheusApiTokenRequest) GoString() string {
	return s.String()
}

func (s *GetPrometheusApiTokenRequest) SetRegionId(v string) *GetPrometheusApiTokenRequest {
	s.RegionId = &v
	return s
}

type GetPrometheusApiTokenResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The token required for integrating Prometheus Service.
	Token *string `json:"Token,omitempty" xml:"Token,omitempty"`
}

func (s GetPrometheusApiTokenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetPrometheusApiTokenResponseBody) GoString() string {
	return s.String()
}

func (s *GetPrometheusApiTokenResponseBody) SetRequestId(v string) *GetPrometheusApiTokenResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetPrometheusApiTokenResponseBody) SetToken(v string) *GetPrometheusApiTokenResponseBody {
	s.Token = &v
	return s
}

type GetPrometheusApiTokenResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetPrometheusApiTokenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetPrometheusApiTokenResponse) String() string {
	return tea.Prettify(s)
}

func (s GetPrometheusApiTokenResponse) GoString() string {
	return s.String()
}

func (s *GetPrometheusApiTokenResponse) SetHeaders(v map[string]*string) *GetPrometheusApiTokenResponse {
	s.Headers = v
	return s
}

func (s *GetPrometheusApiTokenResponse) SetStatusCode(v int32) *GetPrometheusApiTokenResponse {
	s.StatusCode = &v
	return s
}

func (s *GetPrometheusApiTokenResponse) SetBody(v *GetPrometheusApiTokenResponseBody) *GetPrometheusApiTokenResponse {
	s.Body = v
	return s
}

type GetPrometheusGlobalViewRequest struct {
	// The ID of the global aggregation instance.
	GlobalViewClusterId *string `json:"GlobalViewClusterId,omitempty" xml:"GlobalViewClusterId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetPrometheusGlobalViewRequest) String() string {
	return tea.Prettify(s)
}

func (s GetPrometheusGlobalViewRequest) GoString() string {
	return s.String()
}

func (s *GetPrometheusGlobalViewRequest) SetGlobalViewClusterId(v string) *GetPrometheusGlobalViewRequest {
	s.GlobalViewClusterId = &v
	return s
}

func (s *GetPrometheusGlobalViewRequest) SetRegionId(v string) *GetPrometheusGlobalViewRequest {
	s.RegionId = &v
	return s
}

type GetPrometheusGlobalViewResponseBody struct {
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned struct.
	Data    *string `json:"Data,omitempty" xml:"Data,omitempty"`
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetPrometheusGlobalViewResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetPrometheusGlobalViewResponseBody) GoString() string {
	return s.String()
}

func (s *GetPrometheusGlobalViewResponseBody) SetCode(v int32) *GetPrometheusGlobalViewResponseBody {
	s.Code = &v
	return s
}

func (s *GetPrometheusGlobalViewResponseBody) SetData(v string) *GetPrometheusGlobalViewResponseBody {
	s.Data = &v
	return s
}

func (s *GetPrometheusGlobalViewResponseBody) SetMessage(v string) *GetPrometheusGlobalViewResponseBody {
	s.Message = &v
	return s
}

func (s *GetPrometheusGlobalViewResponseBody) SetRequestId(v string) *GetPrometheusGlobalViewResponseBody {
	s.RequestId = &v
	return s
}

type GetPrometheusGlobalViewResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetPrometheusGlobalViewResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetPrometheusGlobalViewResponse) String() string {
	return tea.Prettify(s)
}

func (s GetPrometheusGlobalViewResponse) GoString() string {
	return s.String()
}

func (s *GetPrometheusGlobalViewResponse) SetHeaders(v map[string]*string) *GetPrometheusGlobalViewResponse {
	s.Headers = v
	return s
}

func (s *GetPrometheusGlobalViewResponse) SetStatusCode(v int32) *GetPrometheusGlobalViewResponse {
	s.StatusCode = &v
	return s
}

func (s *GetPrometheusGlobalViewResponse) SetBody(v *GetPrometheusGlobalViewResponseBody) *GetPrometheusGlobalViewResponse {
	s.Body = v
	return s
}

type GetPrometheusInstanceRequest struct {
	// The ID of the Prometheus instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetPrometheusInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s GetPrometheusInstanceRequest) GoString() string {
	return s.String()
}

func (s *GetPrometheusInstanceRequest) SetClusterId(v string) *GetPrometheusInstanceRequest {
	s.ClusterId = &v
	return s
}

func (s *GetPrometheusInstanceRequest) SetRegionId(v string) *GetPrometheusInstanceRequest {
	s.RegionId = &v
	return s
}

type GetPrometheusInstanceResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned information.
	Data *GetPrometheusInstanceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetPrometheusInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetPrometheusInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *GetPrometheusInstanceResponseBody) SetCode(v int32) *GetPrometheusInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *GetPrometheusInstanceResponseBody) SetData(v *GetPrometheusInstanceResponseBodyData) *GetPrometheusInstanceResponseBody {
	s.Data = v
	return s
}

func (s *GetPrometheusInstanceResponseBody) SetMessage(v string) *GetPrometheusInstanceResponseBody {
	s.Message = &v
	return s
}

func (s *GetPrometheusInstanceResponseBody) SetRequestId(v string) *GetPrometheusInstanceResponseBody {
	s.RequestId = &v
	return s
}

type GetPrometheusInstanceResponseBodyData struct {
	// auth token string.
	AuthToken *string `json:"AuthToken,omitempty" xml:"AuthToken,omitempty"`
	// The ID of the Prometheus instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the monitoring object.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// *   remote-write: Prometheus instance for Remote Write
	// *   ecs: Prometheus instances for ECS
	// *   cloud-monitor: Prometheus instance for cloud services (Chinese mainland)
	// *   cloud-monitor: Prometheus instance for cloud services (regions outside the Chinese mainland)
	// *   global-view: Prometheus instance for GlobalView
	// *   aliyun-cs: Prometheus instance for Container Service
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The ID of the Grafana workspace.
	GrafanaInstanceId *string `json:"GrafanaInstanceId,omitempty" xml:"GrafanaInstanceId,omitempty"`
	// http api internet url.
	HttpApiInterUrl *string `json:"HttpApiInterUrl,omitempty" xml:"HttpApiInterUrl,omitempty"`
	// http api intranet url.
	HttpApiIntraUrl *string `json:"HttpApiIntraUrl,omitempty" xml:"HttpApiIntraUrl,omitempty"`
	// The billing method. Valid values:
	//
	// *   PREPAY: subscription
	// *   POSTPAY: pay-as-you-go
	PaymentType *string `json:"PaymentType,omitempty" xml:"PaymentType,omitempty"`
	// push gateway internet url.
	PushGatewayInterUrl *string `json:"PushGatewayInterUrl,omitempty" xml:"PushGatewayInterUrl,omitempty"`
	// push gateway intranet url.
	PushGatewayIntraUrl *string `json:"PushGatewayIntraUrl,omitempty" xml:"PushGatewayIntraUrl,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// remote read internet url.
	RemoteReadInterUrl *string `json:"RemoteReadInterUrl,omitempty" xml:"RemoteReadInterUrl,omitempty"`
	// remote read intranet url.
	RemoteReadIntraUrl *string `json:"RemoteReadIntraUrl,omitempty" xml:"RemoteReadIntraUrl,omitempty"`
	// remote write internet url.
	RemoteWriteInterUrl *string `json:"RemoteWriteInterUrl,omitempty" xml:"RemoteWriteInterUrl,omitempty"`
	// remote write intranet url.
	RemoteWriteIntraUrl *string `json:"RemoteWriteIntraUrl,omitempty" xml:"RemoteWriteIntraUrl,omitempty"`
	// The ID of the resource group to which the instance belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The type of the resource. Set the value to PROMETHEUS.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The ID of the security group.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// The child instances of the Prometheus instance for GlobalView. The value is a JSON string.
	SubClustersJson *string `json:"SubClustersJson,omitempty" xml:"SubClustersJson,omitempty"`
	// The tags of the instance.
	Tags []*GetPrometheusInstanceResponseBodyDataTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The user ID.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The ID of the vSwitch.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The virtual private cloud (VPC) where the monitoring object resides.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s GetPrometheusInstanceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetPrometheusInstanceResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetPrometheusInstanceResponseBodyData) SetAuthToken(v string) *GetPrometheusInstanceResponseBodyData {
	s.AuthToken = &v
	return s
}

func (s *GetPrometheusInstanceResponseBodyData) SetClusterId(v string) *GetPrometheusInstanceResponseBodyData {
	s.ClusterId = &v
	return s
}

func (s *GetPrometheusInstanceResponseBodyData) SetClusterName(v string) *GetPrometheusInstanceResponseBodyData {
	s.ClusterName = &v
	return s
}

func (s *GetPrometheusInstanceResponseBodyData) SetClusterType(v string) *GetPrometheusInstanceResponseBodyData {
	s.ClusterType = &v
	return s
}

func (s *GetPrometheusInstanceResponseBodyData) SetGrafanaInstanceId(v string) *GetPrometheusInstanceResponseBodyData {
	s.GrafanaInstanceId = &v
	return s
}

func (s *GetPrometheusInstanceResponseBodyData) SetHttpApiInterUrl(v string) *GetPrometheusInstanceResponseBodyData {
	s.HttpApiInterUrl = &v
	return s
}

func (s *GetPrometheusInstanceResponseBodyData) SetHttpApiIntraUrl(v string) *GetPrometheusInstanceResponseBodyData {
	s.HttpApiIntraUrl = &v
	return s
}

func (s *GetPrometheusInstanceResponseBodyData) SetPaymentType(v string) *GetPrometheusInstanceResponseBodyData {
	s.PaymentType = &v
	return s
}

func (s *GetPrometheusInstanceResponseBodyData) SetPushGatewayInterUrl(v string) *GetPrometheusInstanceResponseBodyData {
	s.PushGatewayInterUrl = &v
	return s
}

func (s *GetPrometheusInstanceResponseBodyData) SetPushGatewayIntraUrl(v string) *GetPrometheusInstanceResponseBodyData {
	s.PushGatewayIntraUrl = &v
	return s
}

func (s *GetPrometheusInstanceResponseBodyData) SetRegionId(v string) *GetPrometheusInstanceResponseBodyData {
	s.RegionId = &v
	return s
}

func (s *GetPrometheusInstanceResponseBodyData) SetRemoteReadInterUrl(v string) *GetPrometheusInstanceResponseBodyData {
	s.RemoteReadInterUrl = &v
	return s
}

func (s *GetPrometheusInstanceResponseBodyData) SetRemoteReadIntraUrl(v string) *GetPrometheusInstanceResponseBodyData {
	s.RemoteReadIntraUrl = &v
	return s
}

func (s *GetPrometheusInstanceResponseBodyData) SetRemoteWriteInterUrl(v string) *GetPrometheusInstanceResponseBodyData {
	s.RemoteWriteInterUrl = &v
	return s
}

func (s *GetPrometheusInstanceResponseBodyData) SetRemoteWriteIntraUrl(v string) *GetPrometheusInstanceResponseBodyData {
	s.RemoteWriteIntraUrl = &v
	return s
}

func (s *GetPrometheusInstanceResponseBodyData) SetResourceGroupId(v string) *GetPrometheusInstanceResponseBodyData {
	s.ResourceGroupId = &v
	return s
}

func (s *GetPrometheusInstanceResponseBodyData) SetResourceType(v string) *GetPrometheusInstanceResponseBodyData {
	s.ResourceType = &v
	return s
}

func (s *GetPrometheusInstanceResponseBodyData) SetSecurityGroupId(v string) *GetPrometheusInstanceResponseBodyData {
	s.SecurityGroupId = &v
	return s
}

func (s *GetPrometheusInstanceResponseBodyData) SetSubClustersJson(v string) *GetPrometheusInstanceResponseBodyData {
	s.SubClustersJson = &v
	return s
}

func (s *GetPrometheusInstanceResponseBodyData) SetTags(v []*GetPrometheusInstanceResponseBodyDataTags) *GetPrometheusInstanceResponseBodyData {
	s.Tags = v
	return s
}

func (s *GetPrometheusInstanceResponseBodyData) SetUserId(v string) *GetPrometheusInstanceResponseBodyData {
	s.UserId = &v
	return s
}

func (s *GetPrometheusInstanceResponseBodyData) SetVSwitchId(v string) *GetPrometheusInstanceResponseBodyData {
	s.VSwitchId = &v
	return s
}

func (s *GetPrometheusInstanceResponseBodyData) SetVpcId(v string) *GetPrometheusInstanceResponseBodyData {
	s.VpcId = &v
	return s
}

type GetPrometheusInstanceResponseBodyDataTags struct {
	// The tag key of the instance.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The tag value of the instance.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s GetPrometheusInstanceResponseBodyDataTags) String() string {
	return tea.Prettify(s)
}

func (s GetPrometheusInstanceResponseBodyDataTags) GoString() string {
	return s.String()
}

func (s *GetPrometheusInstanceResponseBodyDataTags) SetTagKey(v string) *GetPrometheusInstanceResponseBodyDataTags {
	s.TagKey = &v
	return s
}

func (s *GetPrometheusInstanceResponseBodyDataTags) SetTagValue(v string) *GetPrometheusInstanceResponseBodyDataTags {
	s.TagValue = &v
	return s
}

type GetPrometheusInstanceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetPrometheusInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetPrometheusInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s GetPrometheusInstanceResponse) GoString() string {
	return s.String()
}

func (s *GetPrometheusInstanceResponse) SetHeaders(v map[string]*string) *GetPrometheusInstanceResponse {
	s.Headers = v
	return s
}

func (s *GetPrometheusInstanceResponse) SetStatusCode(v int32) *GetPrometheusInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *GetPrometheusInstanceResponse) SetBody(v *GetPrometheusInstanceResponseBody) *GetPrometheusInstanceResponse {
	s.Body = v
	return s
}

type GetPrometheusIntegrationRequest struct {
	// The ID of the Prometheus instance. Only a Prometheus instance for Container Service or a Prometheus instance for ECS is supported.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The exporter ID.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of the integration.
	IntegrationType *string `json:"IntegrationType,omitempty" xml:"IntegrationType,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetPrometheusIntegrationRequest) String() string {
	return tea.Prettify(s)
}

func (s GetPrometheusIntegrationRequest) GoString() string {
	return s.String()
}

func (s *GetPrometheusIntegrationRequest) SetClusterId(v string) *GetPrometheusIntegrationRequest {
	s.ClusterId = &v
	return s
}

func (s *GetPrometheusIntegrationRequest) SetInstanceId(v int64) *GetPrometheusIntegrationRequest {
	s.InstanceId = &v
	return s
}

func (s *GetPrometheusIntegrationRequest) SetIntegrationType(v string) *GetPrometheusIntegrationRequest {
	s.IntegrationType = &v
	return s
}

func (s *GetPrometheusIntegrationRequest) SetRegionId(v string) *GetPrometheusIntegrationRequest {
	s.RegionId = &v
	return s
}

type GetPrometheusIntegrationResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The struct returned.
	Data *GetPrometheusIntegrationResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetPrometheusIntegrationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetPrometheusIntegrationResponseBody) GoString() string {
	return s.String()
}

func (s *GetPrometheusIntegrationResponseBody) SetCode(v int32) *GetPrometheusIntegrationResponseBody {
	s.Code = &v
	return s
}

func (s *GetPrometheusIntegrationResponseBody) SetData(v *GetPrometheusIntegrationResponseBodyData) *GetPrometheusIntegrationResponseBody {
	s.Data = v
	return s
}

func (s *GetPrometheusIntegrationResponseBody) SetMessage(v string) *GetPrometheusIntegrationResponseBody {
	s.Message = &v
	return s
}

func (s *GetPrometheusIntegrationResponseBody) SetRequestId(v string) *GetPrometheusIntegrationResponseBody {
	s.RequestId = &v
	return s
}

type GetPrometheusIntegrationResponseBodyData struct {
	// Indicates whether the exporter can be deleted.
	CanDelete *bool `json:"CanDelete,omitempty" xml:"CanDelete,omitempty"`
	// Indicates whether the exporter can be modified.
	CanEditor *bool `json:"CanEditor,omitempty" xml:"CanEditor,omitempty"`
	// The ID of the Prometheus instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The container name.
	ContainerName *string `json:"ContainerName,omitempty" xml:"ContainerName,omitempty"`
	// The description of the exporter.
	Describe *string `json:"Describe,omitempty" xml:"Describe,omitempty"`
	// The type of the exporter.
	ExporterType *string `json:"ExporterType,omitempty" xml:"ExporterType,omitempty"`
	// The exporter ID.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the exporter.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The type of the integration.
	IntegrationType *string `json:"IntegrationType,omitempty" xml:"IntegrationType,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// Indicates whether an upgrade is required.
	NeedUpgrade *bool `json:"NeedUpgrade,omitempty" xml:"NeedUpgrade,omitempty"`
	// The configurations of the exporter. The value is a JSON string.
	Param *string `json:"Param,omitempty" xml:"Param,omitempty"`
	// Indicates whether the description is displayed.
	ShowDescribe *bool `json:"ShowDescribe,omitempty" xml:"ShowDescribe,omitempty"`
	// Indicates whether the exporter logs are displayed.
	ShowLog *string `json:"ShowLog,omitempty" xml:"ShowLog,omitempty"`
	// The status of the exporter.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The monitored IP address.
	Target *string `json:"Target,omitempty" xml:"Target,omitempty"`
	// The version information.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s GetPrometheusIntegrationResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetPrometheusIntegrationResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetPrometheusIntegrationResponseBodyData) SetCanDelete(v bool) *GetPrometheusIntegrationResponseBodyData {
	s.CanDelete = &v
	return s
}

func (s *GetPrometheusIntegrationResponseBodyData) SetCanEditor(v bool) *GetPrometheusIntegrationResponseBodyData {
	s.CanEditor = &v
	return s
}

func (s *GetPrometheusIntegrationResponseBodyData) SetClusterId(v string) *GetPrometheusIntegrationResponseBodyData {
	s.ClusterId = &v
	return s
}

func (s *GetPrometheusIntegrationResponseBodyData) SetContainerName(v string) *GetPrometheusIntegrationResponseBodyData {
	s.ContainerName = &v
	return s
}

func (s *GetPrometheusIntegrationResponseBodyData) SetDescribe(v string) *GetPrometheusIntegrationResponseBodyData {
	s.Describe = &v
	return s
}

func (s *GetPrometheusIntegrationResponseBodyData) SetExporterType(v string) *GetPrometheusIntegrationResponseBodyData {
	s.ExporterType = &v
	return s
}

func (s *GetPrometheusIntegrationResponseBodyData) SetInstanceId(v int64) *GetPrometheusIntegrationResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *GetPrometheusIntegrationResponseBodyData) SetInstanceName(v string) *GetPrometheusIntegrationResponseBodyData {
	s.InstanceName = &v
	return s
}

func (s *GetPrometheusIntegrationResponseBodyData) SetIntegrationType(v string) *GetPrometheusIntegrationResponseBodyData {
	s.IntegrationType = &v
	return s
}

func (s *GetPrometheusIntegrationResponseBodyData) SetNamespace(v string) *GetPrometheusIntegrationResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *GetPrometheusIntegrationResponseBodyData) SetNeedUpgrade(v bool) *GetPrometheusIntegrationResponseBodyData {
	s.NeedUpgrade = &v
	return s
}

func (s *GetPrometheusIntegrationResponseBodyData) SetParam(v string) *GetPrometheusIntegrationResponseBodyData {
	s.Param = &v
	return s
}

func (s *GetPrometheusIntegrationResponseBodyData) SetShowDescribe(v bool) *GetPrometheusIntegrationResponseBodyData {
	s.ShowDescribe = &v
	return s
}

func (s *GetPrometheusIntegrationResponseBodyData) SetShowLog(v string) *GetPrometheusIntegrationResponseBodyData {
	s.ShowLog = &v
	return s
}

func (s *GetPrometheusIntegrationResponseBodyData) SetStatus(v string) *GetPrometheusIntegrationResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetPrometheusIntegrationResponseBodyData) SetTarget(v string) *GetPrometheusIntegrationResponseBodyData {
	s.Target = &v
	return s
}

func (s *GetPrometheusIntegrationResponseBodyData) SetVersion(v string) *GetPrometheusIntegrationResponseBodyData {
	s.Version = &v
	return s
}

type GetPrometheusIntegrationResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetPrometheusIntegrationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetPrometheusIntegrationResponse) String() string {
	return tea.Prettify(s)
}

func (s GetPrometheusIntegrationResponse) GoString() string {
	return s.String()
}

func (s *GetPrometheusIntegrationResponse) SetHeaders(v map[string]*string) *GetPrometheusIntegrationResponse {
	s.Headers = v
	return s
}

func (s *GetPrometheusIntegrationResponse) SetStatusCode(v int32) *GetPrometheusIntegrationResponse {
	s.StatusCode = &v
	return s
}

func (s *GetPrometheusIntegrationResponse) SetBody(v *GetPrometheusIntegrationResponseBody) *GetPrometheusIntegrationResponse {
	s.Body = v
	return s
}

type GetPrometheusMonitoringRequest struct {
	// The ID of the Prometheus instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the monitoring configuration.
	MonitoringName *string `json:"MonitoringName,omitempty" xml:"MonitoringName,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The type of the monitoring configuration.
	// Valid values for a Prometheus instance for Container Service: serviceMonitor, podMonitor, customJob, and probe.
	// Valid values for a Prometheus instance for ECS: customJob and probe.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetPrometheusMonitoringRequest) String() string {
	return tea.Prettify(s)
}

func (s GetPrometheusMonitoringRequest) GoString() string {
	return s.String()
}

func (s *GetPrometheusMonitoringRequest) SetClusterId(v string) *GetPrometheusMonitoringRequest {
	s.ClusterId = &v
	return s
}

func (s *GetPrometheusMonitoringRequest) SetMonitoringName(v string) *GetPrometheusMonitoringRequest {
	s.MonitoringName = &v
	return s
}

func (s *GetPrometheusMonitoringRequest) SetRegionId(v string) *GetPrometheusMonitoringRequest {
	s.RegionId = &v
	return s
}

func (s *GetPrometheusMonitoringRequest) SetType(v string) *GetPrometheusMonitoringRequest {
	s.Type = &v
	return s
}

type GetPrometheusMonitoringResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned struct.
	Data *GetPrometheusMonitoringResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetPrometheusMonitoringResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetPrometheusMonitoringResponseBody) GoString() string {
	return s.String()
}

func (s *GetPrometheusMonitoringResponseBody) SetCode(v int32) *GetPrometheusMonitoringResponseBody {
	s.Code = &v
	return s
}

func (s *GetPrometheusMonitoringResponseBody) SetData(v *GetPrometheusMonitoringResponseBodyData) *GetPrometheusMonitoringResponseBody {
	s.Data = v
	return s
}

func (s *GetPrometheusMonitoringResponseBody) SetMessage(v string) *GetPrometheusMonitoringResponseBody {
	s.Message = &v
	return s
}

func (s *GetPrometheusMonitoringResponseBody) SetRequestId(v string) *GetPrometheusMonitoringResponseBody {
	s.RequestId = &v
	return s
}

type GetPrometheusMonitoringResponseBodyData struct {
	// Prometheus Instance ID.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The monitoring configuration. The value is a YAML string.
	ConfigYaml *string `json:"ConfigYaml,omitempty" xml:"ConfigYaml,omitempty"`
	// The name of the monitoring configuration.
	MonitoringName *string `json:"MonitoringName,omitempty" xml:"MonitoringName,omitempty"`
	// The status of the monitoring configuration. Valid values: run and stop.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the monitoring configuration. Valid values: serviceMonitor, podMonitor, customJob, and probe.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetPrometheusMonitoringResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetPrometheusMonitoringResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetPrometheusMonitoringResponseBodyData) SetClusterId(v string) *GetPrometheusMonitoringResponseBodyData {
	s.ClusterId = &v
	return s
}

func (s *GetPrometheusMonitoringResponseBodyData) SetConfigYaml(v string) *GetPrometheusMonitoringResponseBodyData {
	s.ConfigYaml = &v
	return s
}

func (s *GetPrometheusMonitoringResponseBodyData) SetMonitoringName(v string) *GetPrometheusMonitoringResponseBodyData {
	s.MonitoringName = &v
	return s
}

func (s *GetPrometheusMonitoringResponseBodyData) SetStatus(v string) *GetPrometheusMonitoringResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetPrometheusMonitoringResponseBodyData) SetType(v string) *GetPrometheusMonitoringResponseBodyData {
	s.Type = &v
	return s
}

type GetPrometheusMonitoringResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetPrometheusMonitoringResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetPrometheusMonitoringResponse) String() string {
	return tea.Prettify(s)
}

func (s GetPrometheusMonitoringResponse) GoString() string {
	return s.String()
}

func (s *GetPrometheusMonitoringResponse) SetHeaders(v map[string]*string) *GetPrometheusMonitoringResponse {
	s.Headers = v
	return s
}

func (s *GetPrometheusMonitoringResponse) SetStatusCode(v int32) *GetPrometheusMonitoringResponse {
	s.StatusCode = &v
	return s
}

func (s *GetPrometheusMonitoringResponse) SetBody(v *GetPrometheusMonitoringResponseBody) *GetPrometheusMonitoringResponse {
	s.Body = v
	return s
}

type GetPrometheusRemoteWriteRequest struct {
	// The ID of the Prometheus instance. Only a Prometheus instance for Container Service or a Prometheus instance for ECS is supported.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The name of the remote write configuration item.
	RemoteWriteName *string `json:"RemoteWriteName,omitempty" xml:"RemoteWriteName,omitempty"`
}

func (s GetPrometheusRemoteWriteRequest) String() string {
	return tea.Prettify(s)
}

func (s GetPrometheusRemoteWriteRequest) GoString() string {
	return s.String()
}

func (s *GetPrometheusRemoteWriteRequest) SetClusterId(v string) *GetPrometheusRemoteWriteRequest {
	s.ClusterId = &v
	return s
}

func (s *GetPrometheusRemoteWriteRequest) SetRegionId(v string) *GetPrometheusRemoteWriteRequest {
	s.RegionId = &v
	return s
}

func (s *GetPrometheusRemoteWriteRequest) SetRemoteWriteName(v string) *GetPrometheusRemoteWriteRequest {
	s.RemoteWriteName = &v
	return s
}

type GetPrometheusRemoteWriteResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details of the remote write configuration item.
	Data *GetPrometheusRemoteWriteResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`
	// *   `false`
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetPrometheusRemoteWriteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetPrometheusRemoteWriteResponseBody) GoString() string {
	return s.String()
}

func (s *GetPrometheusRemoteWriteResponseBody) SetCode(v int32) *GetPrometheusRemoteWriteResponseBody {
	s.Code = &v
	return s
}

func (s *GetPrometheusRemoteWriteResponseBody) SetData(v *GetPrometheusRemoteWriteResponseBodyData) *GetPrometheusRemoteWriteResponseBody {
	s.Data = v
	return s
}

func (s *GetPrometheusRemoteWriteResponseBody) SetMessage(v string) *GetPrometheusRemoteWriteResponseBody {
	s.Message = &v
	return s
}

func (s *GetPrometheusRemoteWriteResponseBody) SetRequestId(v string) *GetPrometheusRemoteWriteResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetPrometheusRemoteWriteResponseBody) SetSuccess(v bool) *GetPrometheusRemoteWriteResponseBody {
	s.Success = &v
	return s
}

type GetPrometheusRemoteWriteResponseBodyData struct {
	// The ID of the Prometheus instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the remote write configuration item.
	RemoteWriteName *string `json:"RemoteWriteName,omitempty" xml:"RemoteWriteName,omitempty"`
	// The details of the remote write configuration item. The value is in the YAML format.
	RemoteWriteYaml *string `json:"RemoteWriteYaml,omitempty" xml:"RemoteWriteYaml,omitempty"`
}

func (s GetPrometheusRemoteWriteResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetPrometheusRemoteWriteResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetPrometheusRemoteWriteResponseBodyData) SetClusterId(v string) *GetPrometheusRemoteWriteResponseBodyData {
	s.ClusterId = &v
	return s
}

func (s *GetPrometheusRemoteWriteResponseBodyData) SetRemoteWriteName(v string) *GetPrometheusRemoteWriteResponseBodyData {
	s.RemoteWriteName = &v
	return s
}

func (s *GetPrometheusRemoteWriteResponseBodyData) SetRemoteWriteYaml(v string) *GetPrometheusRemoteWriteResponseBodyData {
	s.RemoteWriteYaml = &v
	return s
}

type GetPrometheusRemoteWriteResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetPrometheusRemoteWriteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetPrometheusRemoteWriteResponse) String() string {
	return tea.Prettify(s)
}

func (s GetPrometheusRemoteWriteResponse) GoString() string {
	return s.String()
}

func (s *GetPrometheusRemoteWriteResponse) SetHeaders(v map[string]*string) *GetPrometheusRemoteWriteResponse {
	s.Headers = v
	return s
}

func (s *GetPrometheusRemoteWriteResponse) SetStatusCode(v int32) *GetPrometheusRemoteWriteResponse {
	s.StatusCode = &v
	return s
}

func (s *GetPrometheusRemoteWriteResponse) SetBody(v *GetPrometheusRemoteWriteResponseBody) *GetPrometheusRemoteWriteResponse {
	s.Body = v
	return s
}

type GetRecordingRuleRequest struct {
	// The cluster ID.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetRecordingRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s GetRecordingRuleRequest) GoString() string {
	return s.String()
}

func (s *GetRecordingRuleRequest) SetClusterId(v string) *GetRecordingRuleRequest {
	s.ClusterId = &v
	return s
}

func (s *GetRecordingRuleRequest) SetRegionId(v string) *GetRecordingRuleRequest {
	s.RegionId = &v
	return s
}

type GetRecordingRuleResponseBody struct {
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The recording rule.
	Data    *string `json:"Data,omitempty" xml:"Data,omitempty"`
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetRecordingRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetRecordingRuleResponseBody) GoString() string {
	return s.String()
}

func (s *GetRecordingRuleResponseBody) SetCode(v int32) *GetRecordingRuleResponseBody {
	s.Code = &v
	return s
}

func (s *GetRecordingRuleResponseBody) SetData(v string) *GetRecordingRuleResponseBody {
	s.Data = &v
	return s
}

func (s *GetRecordingRuleResponseBody) SetMessage(v string) *GetRecordingRuleResponseBody {
	s.Message = &v
	return s
}

func (s *GetRecordingRuleResponseBody) SetRequestId(v string) *GetRecordingRuleResponseBody {
	s.RequestId = &v
	return s
}

type GetRecordingRuleResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetRecordingRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetRecordingRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s GetRecordingRuleResponse) GoString() string {
	return s.String()
}

func (s *GetRecordingRuleResponse) SetHeaders(v map[string]*string) *GetRecordingRuleResponse {
	s.Headers = v
	return s
}

func (s *GetRecordingRuleResponse) SetStatusCode(v int32) *GetRecordingRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *GetRecordingRuleResponse) SetBody(v *GetRecordingRuleResponseBody) *GetRecordingRuleResponse {
	s.Body = v
	return s
}

type GetRetcodeAppByPidRequest struct {
	// The PID of the application. To obtain the PID of the application, perform the following steps: Log on to the Application Real-Time Monitoring Service (ARMS) console. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of the application. The URL in the address bar contains the PID of the application. The PID is in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is xxx%4074xxx, you must replace %40 with the at sign (@) to obtain xxx@74xxx.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The list of tags.
	Tags []*GetRetcodeAppByPidRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s GetRetcodeAppByPidRequest) String() string {
	return tea.Prettify(s)
}

func (s GetRetcodeAppByPidRequest) GoString() string {
	return s.String()
}

func (s *GetRetcodeAppByPidRequest) SetPid(v string) *GetRetcodeAppByPidRequest {
	s.Pid = &v
	return s
}

func (s *GetRetcodeAppByPidRequest) SetRegionId(v string) *GetRetcodeAppByPidRequest {
	s.RegionId = &v
	return s
}

func (s *GetRetcodeAppByPidRequest) SetTags(v []*GetRetcodeAppByPidRequestTags) *GetRetcodeAppByPidRequest {
	s.Tags = v
	return s
}

type GetRetcodeAppByPidRequestTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetRetcodeAppByPidRequestTags) String() string {
	return tea.Prettify(s)
}

func (s GetRetcodeAppByPidRequestTags) GoString() string {
	return s.String()
}

func (s *GetRetcodeAppByPidRequestTags) SetKey(v string) *GetRetcodeAppByPidRequestTags {
	s.Key = &v
	return s
}

func (s *GetRetcodeAppByPidRequestTags) SetValue(v string) *GetRetcodeAppByPidRequestTags {
	s.Value = &v
	return s
}

type GetRetcodeAppByPidResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned application data.
	RetcodeApp *GetRetcodeAppByPidResponseBodyRetcodeApp `json:"RetcodeApp,omitempty" xml:"RetcodeApp,omitempty" type:"Struct"`
}

func (s GetRetcodeAppByPidResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetRetcodeAppByPidResponseBody) GoString() string {
	return s.String()
}

func (s *GetRetcodeAppByPidResponseBody) SetRequestId(v string) *GetRetcodeAppByPidResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetRetcodeAppByPidResponseBody) SetRetcodeApp(v *GetRetcodeAppByPidResponseBodyRetcodeApp) *GetRetcodeAppByPidResponseBody {
	s.RetcodeApp = v
	return s
}

type GetRetcodeAppByPidResponseBodyRetcodeApp struct {
	// The ID of the application. The parameter is an auto-increment parameter.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application that is monitored by Browser Monitoring.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The process identifier (PID) of the application.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The ID of the resource group. You can obtain the resource group ID in the **Resource Management** console.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The type of the application that is monitored by Browser Monitoring. Valid values:
	//
	// *   `web`: web application
	// *   `weex`: Weex mobile app
	// *   `mini_dd`: DingTalk mini program
	// *   `mini_alipay`: Alipay mini program
	// *   `mini_wx`: WeChat mini program
	// *   `mini_common`: mini program on other platforms
	RetcodeAppType *string `json:"RetcodeAppType,omitempty" xml:"RetcodeAppType,omitempty"`
	// The tags that are attached to the instance.
	Tags []*GetRetcodeAppByPidResponseBodyRetcodeAppTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s GetRetcodeAppByPidResponseBodyRetcodeApp) String() string {
	return tea.Prettify(s)
}

func (s GetRetcodeAppByPidResponseBodyRetcodeApp) GoString() string {
	return s.String()
}

func (s *GetRetcodeAppByPidResponseBodyRetcodeApp) SetAppId(v string) *GetRetcodeAppByPidResponseBodyRetcodeApp {
	s.AppId = &v
	return s
}

func (s *GetRetcodeAppByPidResponseBodyRetcodeApp) SetAppName(v string) *GetRetcodeAppByPidResponseBodyRetcodeApp {
	s.AppName = &v
	return s
}

func (s *GetRetcodeAppByPidResponseBodyRetcodeApp) SetPid(v string) *GetRetcodeAppByPidResponseBodyRetcodeApp {
	s.Pid = &v
	return s
}

func (s *GetRetcodeAppByPidResponseBodyRetcodeApp) SetResourceGroupId(v string) *GetRetcodeAppByPidResponseBodyRetcodeApp {
	s.ResourceGroupId = &v
	return s
}

func (s *GetRetcodeAppByPidResponseBodyRetcodeApp) SetRetcodeAppType(v string) *GetRetcodeAppByPidResponseBodyRetcodeApp {
	s.RetcodeAppType = &v
	return s
}

func (s *GetRetcodeAppByPidResponseBodyRetcodeApp) SetTags(v []*GetRetcodeAppByPidResponseBodyRetcodeAppTags) *GetRetcodeAppByPidResponseBodyRetcodeApp {
	s.Tags = v
	return s
}

type GetRetcodeAppByPidResponseBodyRetcodeAppTags struct {
	// The key of the tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetRetcodeAppByPidResponseBodyRetcodeAppTags) String() string {
	return tea.Prettify(s)
}

func (s GetRetcodeAppByPidResponseBodyRetcodeAppTags) GoString() string {
	return s.String()
}

func (s *GetRetcodeAppByPidResponseBodyRetcodeAppTags) SetKey(v string) *GetRetcodeAppByPidResponseBodyRetcodeAppTags {
	s.Key = &v
	return s
}

func (s *GetRetcodeAppByPidResponseBodyRetcodeAppTags) SetValue(v string) *GetRetcodeAppByPidResponseBodyRetcodeAppTags {
	s.Value = &v
	return s
}

type GetRetcodeAppByPidResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetRetcodeAppByPidResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetRetcodeAppByPidResponse) String() string {
	return tea.Prettify(s)
}

func (s GetRetcodeAppByPidResponse) GoString() string {
	return s.String()
}

func (s *GetRetcodeAppByPidResponse) SetHeaders(v map[string]*string) *GetRetcodeAppByPidResponse {
	s.Headers = v
	return s
}

func (s *GetRetcodeAppByPidResponse) SetStatusCode(v int32) *GetRetcodeAppByPidResponse {
	s.StatusCode = &v
	return s
}

func (s *GetRetcodeAppByPidResponse) SetBody(v *GetRetcodeAppByPidResponseBody) *GetRetcodeAppByPidResponse {
	s.Body = v
	return s
}

type GetRetcodeDataByQueryRequest struct {
	From     *int64  `json:"From,omitempty" xml:"From,omitempty"`
	Pid      *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	Query    *string `json:"Query,omitempty" xml:"Query,omitempty"`
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	To       *int64  `json:"To,omitempty" xml:"To,omitempty"`
}

func (s GetRetcodeDataByQueryRequest) String() string {
	return tea.Prettify(s)
}

func (s GetRetcodeDataByQueryRequest) GoString() string {
	return s.String()
}

func (s *GetRetcodeDataByQueryRequest) SetFrom(v int64) *GetRetcodeDataByQueryRequest {
	s.From = &v
	return s
}

func (s *GetRetcodeDataByQueryRequest) SetPid(v string) *GetRetcodeDataByQueryRequest {
	s.Pid = &v
	return s
}

func (s *GetRetcodeDataByQueryRequest) SetQuery(v string) *GetRetcodeDataByQueryRequest {
	s.Query = &v
	return s
}

func (s *GetRetcodeDataByQueryRequest) SetRegionId(v string) *GetRetcodeDataByQueryRequest {
	s.RegionId = &v
	return s
}

func (s *GetRetcodeDataByQueryRequest) SetTo(v int64) *GetRetcodeDataByQueryRequest {
	s.To = &v
	return s
}

type GetRetcodeDataByQueryResponseBody struct {
	Code      *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data      *string `json:"Data,omitempty" xml:"Data,omitempty"`
	Message   *string `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetRetcodeDataByQueryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetRetcodeDataByQueryResponseBody) GoString() string {
	return s.String()
}

func (s *GetRetcodeDataByQueryResponseBody) SetCode(v string) *GetRetcodeDataByQueryResponseBody {
	s.Code = &v
	return s
}

func (s *GetRetcodeDataByQueryResponseBody) SetData(v string) *GetRetcodeDataByQueryResponseBody {
	s.Data = &v
	return s
}

func (s *GetRetcodeDataByQueryResponseBody) SetMessage(v string) *GetRetcodeDataByQueryResponseBody {
	s.Message = &v
	return s
}

func (s *GetRetcodeDataByQueryResponseBody) SetRequestId(v string) *GetRetcodeDataByQueryResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetRetcodeDataByQueryResponseBody) SetSuccess(v bool) *GetRetcodeDataByQueryResponseBody {
	s.Success = &v
	return s
}

type GetRetcodeDataByQueryResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetRetcodeDataByQueryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetRetcodeDataByQueryResponse) String() string {
	return tea.Prettify(s)
}

func (s GetRetcodeDataByQueryResponse) GoString() string {
	return s.String()
}

func (s *GetRetcodeDataByQueryResponse) SetHeaders(v map[string]*string) *GetRetcodeDataByQueryResponse {
	s.Headers = v
	return s
}

func (s *GetRetcodeDataByQueryResponse) SetStatusCode(v int32) *GetRetcodeDataByQueryResponse {
	s.StatusCode = &v
	return s
}

func (s *GetRetcodeDataByQueryResponse) SetBody(v *GetRetcodeDataByQueryResponseBody) *GetRetcodeDataByQueryResponse {
	s.Body = v
	return s
}

type GetRetcodeLogstoreRequest struct {
	Pid      *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetRetcodeLogstoreRequest) String() string {
	return tea.Prettify(s)
}

func (s GetRetcodeLogstoreRequest) GoString() string {
	return s.String()
}

func (s *GetRetcodeLogstoreRequest) SetPid(v string) *GetRetcodeLogstoreRequest {
	s.Pid = &v
	return s
}

func (s *GetRetcodeLogstoreRequest) SetRegionId(v string) *GetRetcodeLogstoreRequest {
	s.RegionId = &v
	return s
}

type GetRetcodeLogstoreResponseBody struct {
	Data      *GetRetcodeLogstoreResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	RequestId *string                             `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetRetcodeLogstoreResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetRetcodeLogstoreResponseBody) GoString() string {
	return s.String()
}

func (s *GetRetcodeLogstoreResponseBody) SetData(v *GetRetcodeLogstoreResponseBodyData) *GetRetcodeLogstoreResponseBody {
	s.Data = v
	return s
}

func (s *GetRetcodeLogstoreResponseBody) SetRequestId(v string) *GetRetcodeLogstoreResponseBody {
	s.RequestId = &v
	return s
}

type GetRetcodeLogstoreResponseBodyData struct {
	Message          *string                                             `json:"Message,omitempty" xml:"Message,omitempty"`
	RetcodeSLSConfig *GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig `json:"RetcodeSLSConfig,omitempty" xml:"RetcodeSLSConfig,omitempty" type:"Struct"`
	Status           *string                                             `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetRetcodeLogstoreResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetRetcodeLogstoreResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetRetcodeLogstoreResponseBodyData) SetMessage(v string) *GetRetcodeLogstoreResponseBodyData {
	s.Message = &v
	return s
}

func (s *GetRetcodeLogstoreResponseBodyData) SetRetcodeSLSConfig(v *GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig) *GetRetcodeLogstoreResponseBodyData {
	s.RetcodeSLSConfig = v
	return s
}

func (s *GetRetcodeLogstoreResponseBodyData) SetStatus(v string) *GetRetcodeLogstoreResponseBodyData {
	s.Status = &v
	return s
}

type GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig struct {
	Logstore *string `json:"Logstore,omitempty" xml:"Logstore,omitempty"`
	Project  *string `json:"Project,omitempty" xml:"Project,omitempty"`
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig) String() string {
	return tea.Prettify(s)
}

func (s GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig) GoString() string {
	return s.String()
}

func (s *GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig) SetLogstore(v string) *GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig {
	s.Logstore = &v
	return s
}

func (s *GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig) SetProject(v string) *GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig {
	s.Project = &v
	return s
}

func (s *GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig) SetRegionId(v string) *GetRetcodeLogstoreResponseBodyDataRetcodeSLSConfig {
	s.RegionId = &v
	return s
}

type GetRetcodeLogstoreResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetRetcodeLogstoreResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetRetcodeLogstoreResponse) String() string {
	return tea.Prettify(s)
}

func (s GetRetcodeLogstoreResponse) GoString() string {
	return s.String()
}

func (s *GetRetcodeLogstoreResponse) SetHeaders(v map[string]*string) *GetRetcodeLogstoreResponse {
	s.Headers = v
	return s
}

func (s *GetRetcodeLogstoreResponse) SetStatusCode(v int32) *GetRetcodeLogstoreResponse {
	s.StatusCode = &v
	return s
}

func (s *GetRetcodeLogstoreResponse) SetBody(v *GetRetcodeLogstoreResponseBody) *GetRetcodeLogstoreResponse {
	s.Body = v
	return s
}

type GetRetcodeShareUrlRequest struct {
	// The logon-free URL of the application.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
}

func (s GetRetcodeShareUrlRequest) String() string {
	return tea.Prettify(s)
}

func (s GetRetcodeShareUrlRequest) GoString() string {
	return s.String()
}

func (s *GetRetcodeShareUrlRequest) SetPid(v string) *GetRetcodeShareUrlRequest {
	s.Pid = &v
	return s
}

type GetRetcodeShareUrlResponseBody struct {
	// Queries the logon-free URL of a Browser Monitoring application.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetRetcodeShareUrlResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetRetcodeShareUrlResponseBody) GoString() string {
	return s.String()
}

func (s *GetRetcodeShareUrlResponseBody) SetRequestId(v string) *GetRetcodeShareUrlResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetRetcodeShareUrlResponseBody) SetUrl(v string) *GetRetcodeShareUrlResponseBody {
	s.Url = &v
	return s
}

type GetRetcodeShareUrlResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetRetcodeShareUrlResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetRetcodeShareUrlResponse) String() string {
	return tea.Prettify(s)
}

func (s GetRetcodeShareUrlResponse) GoString() string {
	return s.String()
}

func (s *GetRetcodeShareUrlResponse) SetHeaders(v map[string]*string) *GetRetcodeShareUrlResponse {
	s.Headers = v
	return s
}

func (s *GetRetcodeShareUrlResponse) SetStatusCode(v int32) *GetRetcodeShareUrlResponse {
	s.StatusCode = &v
	return s
}

func (s *GetRetcodeShareUrlResponse) SetBody(v *GetRetcodeShareUrlResponseBody) *GetRetcodeShareUrlResponse {
	s.Body = v
	return s
}

type GetSourceMapInfoRequest struct {
	AscendingSequence *bool   `json:"AscendingSequence,omitempty" xml:"AscendingSequence,omitempty"`
	Edition           *string `json:"Edition,omitempty" xml:"Edition,omitempty"`
	ID                *string `json:"ID,omitempty" xml:"ID,omitempty"`
	Keyword           *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	OrderField        *string `json:"OrderField,omitempty" xml:"OrderField,omitempty"`
	RegionId          *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetSourceMapInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetSourceMapInfoRequest) GoString() string {
	return s.String()
}

func (s *GetSourceMapInfoRequest) SetAscendingSequence(v bool) *GetSourceMapInfoRequest {
	s.AscendingSequence = &v
	return s
}

func (s *GetSourceMapInfoRequest) SetEdition(v string) *GetSourceMapInfoRequest {
	s.Edition = &v
	return s
}

func (s *GetSourceMapInfoRequest) SetID(v string) *GetSourceMapInfoRequest {
	s.ID = &v
	return s
}

func (s *GetSourceMapInfoRequest) SetKeyword(v string) *GetSourceMapInfoRequest {
	s.Keyword = &v
	return s
}

func (s *GetSourceMapInfoRequest) SetOrderField(v string) *GetSourceMapInfoRequest {
	s.OrderField = &v
	return s
}

func (s *GetSourceMapInfoRequest) SetRegionId(v string) *GetSourceMapInfoRequest {
	s.RegionId = &v
	return s
}

type GetSourceMapInfoResponseBody struct {
	RequestId     *string                                      `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	SourceMapList []*GetSourceMapInfoResponseBodySourceMapList `json:"SourceMapList,omitempty" xml:"SourceMapList,omitempty" type:"Repeated"`
}

func (s GetSourceMapInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetSourceMapInfoResponseBody) GoString() string {
	return s.String()
}

func (s *GetSourceMapInfoResponseBody) SetRequestId(v string) *GetSourceMapInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetSourceMapInfoResponseBody) SetSourceMapList(v []*GetSourceMapInfoResponseBodySourceMapList) *GetSourceMapInfoResponseBody {
	s.SourceMapList = v
	return s
}

type GetSourceMapInfoResponseBodySourceMapList struct {
	Fid        *string `json:"Fid,omitempty" xml:"Fid,omitempty"`
	FileName   *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	Size       *string `json:"Size,omitempty" xml:"Size,omitempty"`
	UploadTime *string `json:"UploadTime,omitempty" xml:"UploadTime,omitempty"`
	Version    *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s GetSourceMapInfoResponseBodySourceMapList) String() string {
	return tea.Prettify(s)
}

func (s GetSourceMapInfoResponseBodySourceMapList) GoString() string {
	return s.String()
}

func (s *GetSourceMapInfoResponseBodySourceMapList) SetFid(v string) *GetSourceMapInfoResponseBodySourceMapList {
	s.Fid = &v
	return s
}

func (s *GetSourceMapInfoResponseBodySourceMapList) SetFileName(v string) *GetSourceMapInfoResponseBodySourceMapList {
	s.FileName = &v
	return s
}

func (s *GetSourceMapInfoResponseBodySourceMapList) SetSize(v string) *GetSourceMapInfoResponseBodySourceMapList {
	s.Size = &v
	return s
}

func (s *GetSourceMapInfoResponseBodySourceMapList) SetUploadTime(v string) *GetSourceMapInfoResponseBodySourceMapList {
	s.UploadTime = &v
	return s
}

func (s *GetSourceMapInfoResponseBodySourceMapList) SetVersion(v string) *GetSourceMapInfoResponseBodySourceMapList {
	s.Version = &v
	return s
}

type GetSourceMapInfoResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetSourceMapInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetSourceMapInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSourceMapInfoResponse) GoString() string {
	return s.String()
}

func (s *GetSourceMapInfoResponse) SetHeaders(v map[string]*string) *GetSourceMapInfoResponse {
	s.Headers = v
	return s
}

func (s *GetSourceMapInfoResponse) SetStatusCode(v int32) *GetSourceMapInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *GetSourceMapInfoResponse) SetBody(v *GetSourceMapInfoResponseBody) *GetSourceMapInfoResponse {
	s.Body = v
	return s
}

type GetStackRequest struct {
	// The end time of the call method.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The process identifier (PID) of the application. For more information about how to obtain the PID, see [Obtain the PID of an application](https://www.alibabacloud.com/help/zh/doc-detail/186100.htm?spm=a2cdw.13409063.0.0.7a72281f0bkTfx#title-imy-7gj-qhr).
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the remote procedure call (RPC) mode. You can obtain the ID by calling the **GetTrace** operation.
	RpcID *string `json:"RpcID,omitempty" xml:"RpcID,omitempty"`
	// The start time of the call method.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The trace ID. You can log on to the Application Real-Time Monitoring Service (ARMS) console and obtain the trace ID on the **Trace Query** page.
	TraceID *string `json:"TraceID,omitempty" xml:"TraceID,omitempty"`
}

func (s GetStackRequest) String() string {
	return tea.Prettify(s)
}

func (s GetStackRequest) GoString() string {
	return s.String()
}

func (s *GetStackRequest) SetEndTime(v int64) *GetStackRequest {
	s.EndTime = &v
	return s
}

func (s *GetStackRequest) SetPid(v string) *GetStackRequest {
	s.Pid = &v
	return s
}

func (s *GetStackRequest) SetRegionId(v string) *GetStackRequest {
	s.RegionId = &v
	return s
}

func (s *GetStackRequest) SetRpcID(v string) *GetStackRequest {
	s.RpcID = &v
	return s
}

func (s *GetStackRequest) SetStartTime(v int64) *GetStackRequest {
	s.StartTime = &v
	return s
}

func (s *GetStackRequest) SetTraceID(v string) *GetStackRequest {
	s.TraceID = &v
	return s
}

type GetStackResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information of the method stack.
	StackInfo []*GetStackResponseBodyStackInfo `json:"StackInfo,omitempty" xml:"StackInfo,omitempty" type:"Repeated"`
}

func (s GetStackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetStackResponseBody) GoString() string {
	return s.String()
}

func (s *GetStackResponseBody) SetRequestId(v string) *GetStackResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetStackResponseBody) SetStackInfo(v []*GetStackResponseBodyStackInfo) *GetStackResponseBody {
	s.StackInfo = v
	return s
}

type GetStackResponseBodyStackInfo struct {
	// The name of the operation.
	Api *string `json:"Api,omitempty" xml:"Api,omitempty"`
	// The duration. Unit: milliseconds.
	Duration *int64 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The error message.
	Exception *string `json:"Exception,omitempty" xml:"Exception,omitempty"`
	// The information about the array object.
	ExtInfo *GetStackResponseBodyStackInfoExtInfo `json:"ExtInfo,omitempty" xml:"ExtInfo,omitempty" type:"Struct"`
	// The number of rows in the method stack information.
	Line *string `json:"Line,omitempty" xml:"Line,omitempty"`
	// The ID of the RPC mode.
	RpcId *string `json:"RpcId,omitempty" xml:"RpcId,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The start time of the call method.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s GetStackResponseBodyStackInfo) String() string {
	return tea.Prettify(s)
}

func (s GetStackResponseBodyStackInfo) GoString() string {
	return s.String()
}

func (s *GetStackResponseBodyStackInfo) SetApi(v string) *GetStackResponseBodyStackInfo {
	s.Api = &v
	return s
}

func (s *GetStackResponseBodyStackInfo) SetDuration(v int64) *GetStackResponseBodyStackInfo {
	s.Duration = &v
	return s
}

func (s *GetStackResponseBodyStackInfo) SetException(v string) *GetStackResponseBodyStackInfo {
	s.Exception = &v
	return s
}

func (s *GetStackResponseBodyStackInfo) SetExtInfo(v *GetStackResponseBodyStackInfoExtInfo) *GetStackResponseBodyStackInfo {
	s.ExtInfo = v
	return s
}

func (s *GetStackResponseBodyStackInfo) SetLine(v string) *GetStackResponseBodyStackInfo {
	s.Line = &v
	return s
}

func (s *GetStackResponseBodyStackInfo) SetRpcId(v string) *GetStackResponseBodyStackInfo {
	s.RpcId = &v
	return s
}

func (s *GetStackResponseBodyStackInfo) SetServiceName(v string) *GetStackResponseBodyStackInfo {
	s.ServiceName = &v
	return s
}

func (s *GetStackResponseBodyStackInfo) SetStartTime(v int64) *GetStackResponseBodyStackInfo {
	s.StartTime = &v
	return s
}

type GetStackResponseBodyStackInfoExtInfo struct {
	// The content of the custom parameter.
	Info *string `json:"Info,omitempty" xml:"Info,omitempty"`
	// The type of the custom parameter.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetStackResponseBodyStackInfoExtInfo) String() string {
	return tea.Prettify(s)
}

func (s GetStackResponseBodyStackInfoExtInfo) GoString() string {
	return s.String()
}

func (s *GetStackResponseBodyStackInfoExtInfo) SetInfo(v string) *GetStackResponseBodyStackInfoExtInfo {
	s.Info = &v
	return s
}

func (s *GetStackResponseBodyStackInfoExtInfo) SetType(v string) *GetStackResponseBodyStackInfoExtInfo {
	s.Type = &v
	return s
}

type GetStackResponse struct {
	Headers    map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetStackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetStackResponse) String() string {
	return tea.Prettify(s)
}

func (s GetStackResponse) GoString() string {
	return s.String()
}

func (s *GetStackResponse) SetHeaders(v map[string]*string) *GetStackResponse {
	s.Headers = v
	return s
}

func (s *GetStackResponse) SetStatusCode(v int32) *GetStackResponse {
	s.StatusCode = &v
	return s
}

func (s *GetStackResponse) SetBody(v *GetStackResponseBody) *GetStackResponse {
	s.Body = v
	return s
}

type GetSyntheticMonitorsRequest struct {
	// The query conditions.
	Filter *GetSyntheticMonitorsRequestFilter `json:"Filter,omitempty" xml:"Filter,omitempty" type:"Struct"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetSyntheticMonitorsRequest) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticMonitorsRequest) GoString() string {
	return s.String()
}

func (s *GetSyntheticMonitorsRequest) SetFilter(v *GetSyntheticMonitorsRequestFilter) *GetSyntheticMonitorsRequest {
	s.Filter = v
	return s
}

func (s *GetSyntheticMonitorsRequest) SetRegionId(v string) *GetSyntheticMonitorsRequest {
	s.RegionId = &v
	return s
}

type GetSyntheticMonitorsRequestFilter struct {
	// The type of the monitoring point. Valid values: 1: PC. 2: mobile device.
	MonitorCategory *int32 `json:"MonitorCategory,omitempty" xml:"MonitorCategory,omitempty"`
	// The network type. Valid values: 1: private network. 2: Internet.
	Network *int32 `json:"Network,omitempty" xml:"Network,omitempty"`
	// The type of the monitoring task. Valid values:
	//
	// 1: ICMP. 2: TCP. 3: DNS. 4: HTTP. 5: website speed. 6: file download.
	TaskType *int32 `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s GetSyntheticMonitorsRequestFilter) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticMonitorsRequestFilter) GoString() string {
	return s.String()
}

func (s *GetSyntheticMonitorsRequestFilter) SetMonitorCategory(v int32) *GetSyntheticMonitorsRequestFilter {
	s.MonitorCategory = &v
	return s
}

func (s *GetSyntheticMonitorsRequestFilter) SetNetwork(v int32) *GetSyntheticMonitorsRequestFilter {
	s.Network = &v
	return s
}

func (s *GetSyntheticMonitorsRequestFilter) SetTaskType(v int32) *GetSyntheticMonitorsRequestFilter {
	s.TaskType = &v
	return s
}

type GetSyntheticMonitorsShrinkRequest struct {
	// The query conditions.
	FilterShrink *string `json:"Filter,omitempty" xml:"Filter,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetSyntheticMonitorsShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticMonitorsShrinkRequest) GoString() string {
	return s.String()
}

func (s *GetSyntheticMonitorsShrinkRequest) SetFilterShrink(v string) *GetSyntheticMonitorsShrinkRequest {
	s.FilterShrink = &v
	return s
}

func (s *GetSyntheticMonitorsShrinkRequest) SetRegionId(v string) *GetSyntheticMonitorsShrinkRequest {
	s.RegionId = &v
	return s
}

type GetSyntheticMonitorsResponseBody struct {
	// The HTTP status code. The status code 200 indicates that the request was successful.
	Code *int64 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The list of monitoring points.
	Data []*GetSyntheticMonitorsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetSyntheticMonitorsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticMonitorsResponseBody) GoString() string {
	return s.String()
}

func (s *GetSyntheticMonitorsResponseBody) SetCode(v int64) *GetSyntheticMonitorsResponseBody {
	s.Code = &v
	return s
}

func (s *GetSyntheticMonitorsResponseBody) SetData(v []*GetSyntheticMonitorsResponseBodyData) *GetSyntheticMonitorsResponseBody {
	s.Data = v
	return s
}

func (s *GetSyntheticMonitorsResponseBody) SetMessage(v string) *GetSyntheticMonitorsResponseBody {
	s.Message = &v
	return s
}

func (s *GetSyntheticMonitorsResponseBody) SetRequestId(v string) *GetSyntheticMonitorsResponseBody {
	s.RequestId = &v
	return s
}

type GetSyntheticMonitorsResponseBodyData struct {
	// Indicates whether the monitoring point is available. Valid values: true and false.
	Available *string `json:"Available,omitempty" xml:"Available,omitempty"`
	// Indicates whether the monitoring point is selected. Valid values: true and false.
	CanBeSelected *bool `json:"CanBeSelected,omitempty" xml:"CanBeSelected,omitempty"`
	// The city.
	City *string `json:"City,omitempty" xml:"City,omitempty"`
	// The city code.
	CityCode *string `json:"CityCode,omitempty" xml:"CityCode,omitempty"`
	// The client type of the monitoring point. Valid values: 1: data center. 2: Internet. 3: mobile device. 4: ECS instance.
	ClientType *int32 `json:"ClientType,omitempty" xml:"ClientType,omitempty"`
	// The country.
	Country *string `json:"Country,omitempty" xml:"Country,omitempty"`
	// Indicates whether IPv6 is supported. Valid values: 0: IPv6 is not supported. 1: IPv6 is supported.
	Ipv6 *int32 `json:"Ipv6,omitempty" xml:"Ipv6,omitempty"`
	// The carrier.
	Operator *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
	// The carrier code.
	OperatorCode *string `json:"OperatorCode,omitempty" xml:"OperatorCode,omitempty"`
	// The region.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
}

func (s GetSyntheticMonitorsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticMonitorsResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetSyntheticMonitorsResponseBodyData) SetAvailable(v string) *GetSyntheticMonitorsResponseBodyData {
	s.Available = &v
	return s
}

func (s *GetSyntheticMonitorsResponseBodyData) SetCanBeSelected(v bool) *GetSyntheticMonitorsResponseBodyData {
	s.CanBeSelected = &v
	return s
}

func (s *GetSyntheticMonitorsResponseBodyData) SetCity(v string) *GetSyntheticMonitorsResponseBodyData {
	s.City = &v
	return s
}

func (s *GetSyntheticMonitorsResponseBodyData) SetCityCode(v string) *GetSyntheticMonitorsResponseBodyData {
	s.CityCode = &v
	return s
}

func (s *GetSyntheticMonitorsResponseBodyData) SetClientType(v int32) *GetSyntheticMonitorsResponseBodyData {
	s.ClientType = &v
	return s
}

func (s *GetSyntheticMonitorsResponseBodyData) SetCountry(v string) *GetSyntheticMonitorsResponseBodyData {
	s.Country = &v
	return s
}

func (s *GetSyntheticMonitorsResponseBodyData) SetIpv6(v int32) *GetSyntheticMonitorsResponseBodyData {
	s.Ipv6 = &v
	return s
}

func (s *GetSyntheticMonitorsResponseBodyData) SetOperator(v string) *GetSyntheticMonitorsResponseBodyData {
	s.Operator = &v
	return s
}

func (s *GetSyntheticMonitorsResponseBodyData) SetOperatorCode(v string) *GetSyntheticMonitorsResponseBodyData {
	s.OperatorCode = &v
	return s
}

func (s *GetSyntheticMonitorsResponseBodyData) SetRegion(v string) *GetSyntheticMonitorsResponseBodyData {
	s.Region = &v
	return s
}

type GetSyntheticMonitorsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetSyntheticMonitorsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetSyntheticMonitorsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticMonitorsResponse) GoString() string {
	return s.String()
}

func (s *GetSyntheticMonitorsResponse) SetHeaders(v map[string]*string) *GetSyntheticMonitorsResponse {
	s.Headers = v
	return s
}

func (s *GetSyntheticMonitorsResponse) SetStatusCode(v int32) *GetSyntheticMonitorsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetSyntheticMonitorsResponse) SetBody(v *GetSyntheticMonitorsResponseBody) *GetSyntheticMonitorsResponse {
	s.Body = v
	return s
}

type GetSyntheticTaskDetailRequest struct {
	// 地域ID。默认为cn-hangzhou。
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// 云拨测任务ID。
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s GetSyntheticTaskDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskDetailRequest) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskDetailRequest) SetRegionId(v string) *GetSyntheticTaskDetailRequest {
	s.RegionId = &v
	return s
}

func (s *GetSyntheticTaskDetailRequest) SetTaskId(v string) *GetSyntheticTaskDetailRequest {
	s.TaskId = &v
	return s
}

type GetSyntheticTaskDetailResponseBody struct {
	// 请求ID。
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// 任务详情。
	TaskDetail *GetSyntheticTaskDetailResponseBodyTaskDetail `json:"TaskDetail,omitempty" xml:"TaskDetail,omitempty" type:"Struct"`
}

func (s GetSyntheticTaskDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskDetailResponseBody) SetRequestId(v string) *GetSyntheticTaskDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBody) SetTaskDetail(v *GetSyntheticTaskDetailResponseBodyTaskDetail) *GetSyntheticTaskDetailResponseBody {
	s.TaskDetail = v
	return s
}

type GetSyntheticTaskDetailResponseBodyTaskDetail struct {
	CommonParam *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam `json:"CommonParam,omitempty" xml:"CommonParam,omitempty" type:"Struct"`
	// 文件下载任务。
	Download *GetSyntheticTaskDetailResponseBodyTaskDetailDownload `json:"Download,omitempty" xml:"Download,omitempty" type:"Struct"`
	// 自定义扩展频率。
	ExtendInterval *GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval `json:"ExtendInterval,omitempty" xml:"ExtendInterval,omitempty" type:"Struct"`
	// 拨测频率，单位为分钟。可选频率如下：
	//
	// - 1
	// - 5
	// - 10
	// - 15
	// - 20
	// - 30
	// - 60
	// - 120
	// - 180
	// - 240
	// - 360
	// - 480
	// - 720
	// - 1440
	IntervalTime      *int64                                                     `json:"IntervalTime,omitempty" xml:"IntervalTime,omitempty"`
	IntervalType      *int64                                                     `json:"IntervalType,omitempty" xml:"IntervalType,omitempty"`
	IpType            *int64                                                     `json:"IpType,omitempty" xml:"IpType,omitempty"`
	MonitorList       []*GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList `json:"MonitorList,omitempty" xml:"MonitorList,omitempty" type:"Repeated"`
	MonitorListString *string                                                    `json:"MonitorListString,omitempty" xml:"MonitorListString,omitempty"`
	Nav               *GetSyntheticTaskDetailResponseBodyTaskDetailNav           `json:"Nav,omitempty" xml:"Nav,omitempty" type:"Struct"`
	Net               *GetSyntheticTaskDetailResponseBodyTaskDetailNet           `json:"Net,omitempty" xml:"Net,omitempty" type:"Struct"`
	Protocol          *GetSyntheticTaskDetailResponseBodyTaskDetailProtocol      `json:"Protocol,omitempty" xml:"Protocol,omitempty" type:"Struct"`
	// 云拨测任务ID。
	TaskId *int64 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// 任务名称。
	TaskName *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
	TaskType *int64  `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
	// 拨测地址。
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetail) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetail) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetail) SetCommonParam(v *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam) *GetSyntheticTaskDetailResponseBodyTaskDetail {
	s.CommonParam = v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetail) SetDownload(v *GetSyntheticTaskDetailResponseBodyTaskDetailDownload) *GetSyntheticTaskDetailResponseBodyTaskDetail {
	s.Download = v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetail) SetExtendInterval(v *GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval) *GetSyntheticTaskDetailResponseBodyTaskDetail {
	s.ExtendInterval = v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetail) SetIntervalTime(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetail {
	s.IntervalTime = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetail) SetIntervalType(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetail {
	s.IntervalType = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetail) SetIpType(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetail {
	s.IpType = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetail) SetMonitorList(v []*GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList) *GetSyntheticTaskDetailResponseBodyTaskDetail {
	s.MonitorList = v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetail) SetMonitorListString(v string) *GetSyntheticTaskDetailResponseBodyTaskDetail {
	s.MonitorListString = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetail) SetNav(v *GetSyntheticTaskDetailResponseBodyTaskDetailNav) *GetSyntheticTaskDetailResponseBodyTaskDetail {
	s.Nav = v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetail) SetNet(v *GetSyntheticTaskDetailResponseBodyTaskDetailNet) *GetSyntheticTaskDetailResponseBodyTaskDetail {
	s.Net = v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetail) SetProtocol(v *GetSyntheticTaskDetailResponseBodyTaskDetailProtocol) *GetSyntheticTaskDetailResponseBodyTaskDetail {
	s.Protocol = v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetail) SetTaskId(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetail {
	s.TaskId = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetail) SetTaskName(v string) *GetSyntheticTaskDetailResponseBodyTaskDetail {
	s.TaskName = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetail) SetTaskType(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetail {
	s.TaskType = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetail) SetUrl(v string) *GetSyntheticTaskDetailResponseBodyTaskDetail {
	s.Url = &v
	return s
}

type GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam struct {
	AlarmFlag          *int64                                                              `json:"AlarmFlag,omitempty" xml:"AlarmFlag,omitempty"`
	AlertList          []*GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList `json:"AlertList,omitempty" xml:"AlertList,omitempty" type:"Repeated"`
	AlertNotifierId    *string                                                             `json:"AlertNotifierId,omitempty" xml:"AlertNotifierId,omitempty"`
	AlertPolicyId      *string                                                             `json:"AlertPolicyId,omitempty" xml:"AlertPolicyId,omitempty"`
	MonitorSamples     *string                                                             `json:"MonitorSamples,omitempty" xml:"MonitorSamples,omitempty"`
	StartExecutionTime *string                                                             `json:"StartExecutionTime,omitempty" xml:"StartExecutionTime,omitempty"`
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam) SetAlarmFlag(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam {
	s.AlarmFlag = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam) SetAlertList(v []*GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList) *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam {
	s.AlertList = v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam) SetAlertNotifierId(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam {
	s.AlertNotifierId = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam) SetAlertPolicyId(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam {
	s.AlertPolicyId = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam) SetMonitorSamples(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam {
	s.MonitorSamples = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam) SetStartExecutionTime(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParam {
	s.StartExecutionTime = &v
	return s
}

type GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList struct {
	GeneralAlert *string `json:"GeneralAlert,omitempty" xml:"GeneralAlert,omitempty"`
	IsCritical   *string `json:"IsCritical,omitempty" xml:"IsCritical,omitempty"`
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	SeriousAlert *string `json:"SeriousAlert,omitempty" xml:"SeriousAlert,omitempty"`
	Symbols      *string `json:"Symbols,omitempty" xml:"Symbols,omitempty"`
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList) SetGeneralAlert(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList {
	s.GeneralAlert = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList) SetIsCritical(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList {
	s.IsCritical = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList) SetName(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList {
	s.Name = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList) SetSeriousAlert(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList {
	s.SeriousAlert = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList) SetSymbols(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailCommonParamAlertList {
	s.Symbols = &v
	return s
}

type GetSyntheticTaskDetailResponseBodyTaskDetailDownload struct {
	ConnectionTimeout           *int64  `json:"ConnectionTimeout,omitempty" xml:"ConnectionTimeout,omitempty"`
	DownloadCustomHeaderContent *string `json:"DownloadCustomHeaderContent,omitempty" xml:"DownloadCustomHeaderContent,omitempty"`
	DownloadCustomHost          *int64  `json:"DownloadCustomHost,omitempty" xml:"DownloadCustomHost,omitempty"`
	DownloadCustomHostIp        *string `json:"DownloadCustomHostIp,omitempty" xml:"DownloadCustomHostIp,omitempty"`
	DownloadKernel              *int64  `json:"DownloadKernel,omitempty" xml:"DownloadKernel,omitempty"`
	DownloadRedirect            *int64  `json:"DownloadRedirect,omitempty" xml:"DownloadRedirect,omitempty"`
	DownloadTransmissionSize    *int64  `json:"DownloadTransmissionSize,omitempty" xml:"DownloadTransmissionSize,omitempty"`
	MonitorTimeout              *int64  `json:"MonitorTimeout,omitempty" xml:"MonitorTimeout,omitempty"`
	QuickProtocol               *string `json:"QuickProtocol,omitempty" xml:"QuickProtocol,omitempty"`
	ValidateKeywords            *string `json:"ValidateKeywords,omitempty" xml:"ValidateKeywords,omitempty"`
	VerifyWay                   *int64  `json:"VerifyWay,omitempty" xml:"VerifyWay,omitempty"`
	WhiteList                   *string `json:"WhiteList,omitempty" xml:"WhiteList,omitempty"`
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailDownload) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailDownload) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailDownload) SetConnectionTimeout(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailDownload {
	s.ConnectionTimeout = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailDownload) SetDownloadCustomHeaderContent(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailDownload {
	s.DownloadCustomHeaderContent = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailDownload) SetDownloadCustomHost(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailDownload {
	s.DownloadCustomHost = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailDownload) SetDownloadCustomHostIp(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailDownload {
	s.DownloadCustomHostIp = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailDownload) SetDownloadKernel(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailDownload {
	s.DownloadKernel = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailDownload) SetDownloadRedirect(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailDownload {
	s.DownloadRedirect = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailDownload) SetDownloadTransmissionSize(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailDownload {
	s.DownloadTransmissionSize = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailDownload) SetMonitorTimeout(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailDownload {
	s.MonitorTimeout = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailDownload) SetQuickProtocol(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailDownload {
	s.QuickProtocol = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailDownload) SetValidateKeywords(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailDownload {
	s.ValidateKeywords = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailDownload) SetVerifyWay(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailDownload {
	s.VerifyWay = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailDownload) SetWhiteList(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailDownload {
	s.WhiteList = &v
	return s
}

type GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval struct {
	// 拨测执行周期。
	//
	// - -1：每天
	// - 0：周日
	// - 1：周一
	// - 2：周二
	// - 3：周三
	// - 4：周四
	// - 5：周五
	// - 6：周六
	Days []*int64 `json:"Days,omitempty" xml:"Days,omitempty" type:"Repeated"`
	// 当天结束分钟数。
	EndMinute *int64  `json:"EndMinute,omitempty" xml:"EndMinute,omitempty"`
	EndTime   *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// 当天结束小时数。
	Endhour *int64 `json:"Endhour,omitempty" xml:"Endhour,omitempty"`
	// 当天开始拨测时间的小时数。
	StartHour *int64 `json:"StartHour,omitempty" xml:"StartHour,omitempty"`
	// 当天开始拨测时间的分钟数。
	StartMinute *int64  `json:"StartMinute,omitempty" xml:"StartMinute,omitempty"`
	StartTime   *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval) SetDays(v []*int64) *GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval {
	s.Days = v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval) SetEndMinute(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval {
	s.EndMinute = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval) SetEndTime(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval {
	s.EndTime = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval) SetEndhour(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval {
	s.Endhour = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval) SetStartHour(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval {
	s.StartHour = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval) SetStartMinute(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval {
	s.StartMinute = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval) SetStartTime(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailExtendInterval {
	s.StartTime = &v
	return s
}

type GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList struct {
	// 城市编码。
	CityCode     *int64 `json:"CityCode,omitempty" xml:"CityCode,omitempty"`
	MonitorType  *int64 `json:"MonitorType,omitempty" xml:"MonitorType,omitempty"`
	NetServiceId *int64 `json:"NetServiceId,omitempty" xml:"NetServiceId,omitempty"`
	SendCount    *int64 `json:"SendCount,omitempty" xml:"SendCount,omitempty"`
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList) SetCityCode(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList {
	s.CityCode = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList) SetMonitorType(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList {
	s.MonitorType = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList) SetNetServiceId(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList {
	s.NetServiceId = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList) SetSendCount(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailMonitorList {
	s.SendCount = &v
	return s
}

type GetSyntheticTaskDetailResponseBodyTaskDetailNav struct {
	DnsHijackWhitelist        *string `json:"DnsHijackWhitelist,omitempty" xml:"DnsHijackWhitelist,omitempty"`
	ElementBlacklist          *string `json:"ElementBlacklist,omitempty" xml:"ElementBlacklist,omitempty"`
	ExecuteActiveX            *int64  `json:"ExecuteActiveX,omitempty" xml:"ExecuteActiveX,omitempty"`
	ExecuteApplet             *int64  `json:"ExecuteApplet,omitempty" xml:"ExecuteApplet,omitempty"`
	ExecuteScript             *int64  `json:"ExecuteScript,omitempty" xml:"ExecuteScript,omitempty"`
	FilterInvalidIP           *int64  `json:"FilterInvalidIP,omitempty" xml:"FilterInvalidIP,omitempty"`
	FlowHijackJumpTimes       *int64  `json:"FlowHijackJumpTimes,omitempty" xml:"FlowHijackJumpTimes,omitempty"`
	FlowHijackLogo            *string `json:"FlowHijackLogo,omitempty" xml:"FlowHijackLogo,omitempty"`
	MonitorTimeout            *int64  `json:"MonitorTimeout,omitempty" xml:"MonitorTimeout,omitempty"`
	NavAutomaticScrolling     *int64  `json:"NavAutomaticScrolling,omitempty" xml:"NavAutomaticScrolling,omitempty"`
	NavCustomHeader           *string `json:"NavCustomHeader,omitempty" xml:"NavCustomHeader,omitempty"`
	NavCustomHeaderContent    *string `json:"NavCustomHeaderContent,omitempty" xml:"NavCustomHeaderContent,omitempty"`
	NavCustomHost             *int64  `json:"NavCustomHost,omitempty" xml:"NavCustomHost,omitempty"`
	NavCustomHostIp           *string `json:"NavCustomHostIp,omitempty" xml:"NavCustomHostIp,omitempty"`
	NavDisableCache           *int64  `json:"NavDisableCache,omitempty" xml:"NavDisableCache,omitempty"`
	NavDisableCompression     *int64  `json:"NavDisableCompression,omitempty" xml:"NavDisableCompression,omitempty"`
	NavIgnoreCertificateError *int64  `json:"NavIgnoreCertificateError,omitempty" xml:"NavIgnoreCertificateError,omitempty"`
	NavRedirect               *int64  `json:"NavRedirect,omitempty" xml:"NavRedirect,omitempty"`
	NavReturnElement          *int64  `json:"NavReturnElement,omitempty" xml:"NavReturnElement,omitempty"`
	PageTampering             *string `json:"PageTampering,omitempty" xml:"PageTampering,omitempty"`
	ProcessName               *string `json:"ProcessName,omitempty" xml:"ProcessName,omitempty"`
	QuicDomain                *string `json:"QuicDomain,omitempty" xml:"QuicDomain,omitempty"`
	QuicVersion               *int64  `json:"QuicVersion,omitempty" xml:"QuicVersion,omitempty"`
	RequestHeader             *int64  `json:"RequestHeader,omitempty" xml:"RequestHeader,omitempty"`
	SlowElementThreshold      *int64  `json:"SlowElementThreshold,omitempty" xml:"SlowElementThreshold,omitempty"`
	VerifyStringBlacklist     *string `json:"VerifyStringBlacklist,omitempty" xml:"VerifyStringBlacklist,omitempty"`
	VerifyStringWhitelist     *string `json:"VerifyStringWhitelist,omitempty" xml:"VerifyStringWhitelist,omitempty"`
	WaitCompletionTime        *int64  `json:"WaitCompletionTime,omitempty" xml:"WaitCompletionTime,omitempty"`
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailNav) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailNav) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetDnsHijackWhitelist(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.DnsHijackWhitelist = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetElementBlacklist(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.ElementBlacklist = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetExecuteActiveX(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.ExecuteActiveX = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetExecuteApplet(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.ExecuteApplet = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetExecuteScript(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.ExecuteScript = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetFilterInvalidIP(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.FilterInvalidIP = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetFlowHijackJumpTimes(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.FlowHijackJumpTimes = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetFlowHijackLogo(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.FlowHijackLogo = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetMonitorTimeout(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.MonitorTimeout = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetNavAutomaticScrolling(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.NavAutomaticScrolling = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetNavCustomHeader(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.NavCustomHeader = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetNavCustomHeaderContent(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.NavCustomHeaderContent = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetNavCustomHost(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.NavCustomHost = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetNavCustomHostIp(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.NavCustomHostIp = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetNavDisableCache(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.NavDisableCache = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetNavDisableCompression(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.NavDisableCompression = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetNavIgnoreCertificateError(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.NavIgnoreCertificateError = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetNavRedirect(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.NavRedirect = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetNavReturnElement(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.NavReturnElement = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetPageTampering(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.PageTampering = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetProcessName(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.ProcessName = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetQuicDomain(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.QuicDomain = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetQuicVersion(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.QuicVersion = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetRequestHeader(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.RequestHeader = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetSlowElementThreshold(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.SlowElementThreshold = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetVerifyStringBlacklist(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.VerifyStringBlacklist = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetVerifyStringWhitelist(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.VerifyStringWhitelist = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNav) SetWaitCompletionTime(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNav {
	s.WaitCompletionTime = &v
	return s
}

type GetSyntheticTaskDetailResponseBodyTaskDetailNet struct {
	NetDigSwitch         *int64  `json:"NetDigSwitch,omitempty" xml:"NetDigSwitch,omitempty"`
	NetDnsNs             *string `json:"NetDnsNs,omitempty" xml:"NetDnsNs,omitempty"`
	NetDnsQueryMethod    *string `json:"NetDnsQueryMethod,omitempty" xml:"NetDnsQueryMethod,omitempty"`
	NetDnsServer         *int64  `json:"NetDnsServer,omitempty" xml:"NetDnsServer,omitempty"`
	NetDnsSwitch         *int64  `json:"NetDnsSwitch,omitempty" xml:"NetDnsSwitch,omitempty"`
	NetDnsTimeout        *string `json:"NetDnsTimeout,omitempty" xml:"NetDnsTimeout,omitempty"`
	NetIcmpActive        *int64  `json:"NetIcmpActive,omitempty" xml:"NetIcmpActive,omitempty"`
	NetIcmpDataCut       *int64  `json:"NetIcmpDataCut,omitempty" xml:"NetIcmpDataCut,omitempty"`
	NetIcmpInterval      *int64  `json:"NetIcmpInterval,omitempty" xml:"NetIcmpInterval,omitempty"`
	NetIcmpNum           *int64  `json:"NetIcmpNum,omitempty" xml:"NetIcmpNum,omitempty"`
	NetIcmpSize          *int64  `json:"NetIcmpSize,omitempty" xml:"NetIcmpSize,omitempty"`
	NetIcmpSwitch        *int64  `json:"NetIcmpSwitch,omitempty" xml:"NetIcmpSwitch,omitempty"`
	NetIcmpTimeout       *int64  `json:"NetIcmpTimeout,omitempty" xml:"NetIcmpTimeout,omitempty"`
	NetTraceRouteNum     *int64  `json:"NetTraceRouteNum,omitempty" xml:"NetTraceRouteNum,omitempty"`
	NetTraceRouteSwitch  *int64  `json:"NetTraceRouteSwitch,omitempty" xml:"NetTraceRouteSwitch,omitempty"`
	NetTraceRouteTimeout *int64  `json:"NetTraceRouteTimeout,omitempty" xml:"NetTraceRouteTimeout,omitempty"`
	WhiteList            *string `json:"WhiteList,omitempty" xml:"WhiteList,omitempty"`
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailNet) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailNet) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNet) SetNetDigSwitch(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNet {
	s.NetDigSwitch = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNet) SetNetDnsNs(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailNet {
	s.NetDnsNs = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNet) SetNetDnsQueryMethod(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailNet {
	s.NetDnsQueryMethod = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNet) SetNetDnsServer(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNet {
	s.NetDnsServer = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNet) SetNetDnsSwitch(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNet {
	s.NetDnsSwitch = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNet) SetNetDnsTimeout(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailNet {
	s.NetDnsTimeout = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNet) SetNetIcmpActive(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNet {
	s.NetIcmpActive = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNet) SetNetIcmpDataCut(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNet {
	s.NetIcmpDataCut = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNet) SetNetIcmpInterval(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNet {
	s.NetIcmpInterval = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNet) SetNetIcmpNum(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNet {
	s.NetIcmpNum = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNet) SetNetIcmpSize(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNet {
	s.NetIcmpSize = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNet) SetNetIcmpSwitch(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNet {
	s.NetIcmpSwitch = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNet) SetNetIcmpTimeout(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNet {
	s.NetIcmpTimeout = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNet) SetNetTraceRouteNum(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNet {
	s.NetTraceRouteNum = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNet) SetNetTraceRouteSwitch(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNet {
	s.NetTraceRouteSwitch = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNet) SetNetTraceRouteTimeout(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailNet {
	s.NetTraceRouteTimeout = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailNet) SetWhiteList(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailNet {
	s.WhiteList = &v
	return s
}

type GetSyntheticTaskDetailResponseBodyTaskDetailProtocol struct {
	CharacterEncoding         *int64                                                              `json:"CharacterEncoding,omitempty" xml:"CharacterEncoding,omitempty"`
	CustomHost                *int64                                                              `json:"CustomHost,omitempty" xml:"CustomHost,omitempty"`
	CustomHostIp              *string                                                             `json:"CustomHostIp,omitempty" xml:"CustomHostIp,omitempty"`
	ProtocolConnectionTimeout *int64                                                              `json:"ProtocolConnectionTimeout,omitempty" xml:"ProtocolConnectionTimeout,omitempty"`
	ProtocolMonitorTimeout    *int64                                                              `json:"ProtocolMonitorTimeout,omitempty" xml:"ProtocolMonitorTimeout,omitempty"`
	ReceivedDataSize          *int64                                                              `json:"ReceivedDataSize,omitempty" xml:"ReceivedDataSize,omitempty"`
	RequestContent            *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent `json:"RequestContent,omitempty" xml:"RequestContent,omitempty" type:"Struct"`
	VerifyContent             *string                                                             `json:"VerifyContent,omitempty" xml:"VerifyContent,omitempty"`
	VerifyWay                 *int64                                                              `json:"VerifyWay,omitempty" xml:"VerifyWay,omitempty"`
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailProtocol) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailProtocol) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailProtocol) SetCharacterEncoding(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailProtocol {
	s.CharacterEncoding = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailProtocol) SetCustomHost(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailProtocol {
	s.CustomHost = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailProtocol) SetCustomHostIp(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailProtocol {
	s.CustomHostIp = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailProtocol) SetProtocolConnectionTimeout(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailProtocol {
	s.ProtocolConnectionTimeout = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailProtocol) SetProtocolMonitorTimeout(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailProtocol {
	s.ProtocolMonitorTimeout = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailProtocol) SetReceivedDataSize(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailProtocol {
	s.ReceivedDataSize = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailProtocol) SetRequestContent(v *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent) *GetSyntheticTaskDetailResponseBodyTaskDetailProtocol {
	s.RequestContent = v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailProtocol) SetVerifyContent(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailProtocol {
	s.VerifyContent = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailProtocol) SetVerifyWay(v int64) *GetSyntheticTaskDetailResponseBodyTaskDetailProtocol {
	s.VerifyWay = &v
	return s
}

type GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent struct {
	Body   *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody     `json:"Body,omitempty" xml:"Body,omitempty" type:"Struct"`
	Header []*GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader `json:"Header,omitempty" xml:"Header,omitempty" type:"Repeated"`
	Method *string                                                                     `json:"Method,omitempty" xml:"Method,omitempty"`
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent) SetBody(v *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody) *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent {
	s.Body = v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent) SetHeader(v []*GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader) *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent {
	s.Header = v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent) SetMethod(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContent {
	s.Method = &v
	return s
}

type GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody struct {
	Formdata   *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata   `json:"Formdata,omitempty" xml:"Formdata,omitempty" type:"Struct"`
	Language   *string                                                                           `json:"Language,omitempty" xml:"Language,omitempty"`
	Mode       *string                                                                           `json:"Mode,omitempty" xml:"Mode,omitempty"`
	Raw        *string                                                                           `json:"Raw,omitempty" xml:"Raw,omitempty"`
	Urlencoded *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded `json:"Urlencoded,omitempty" xml:"Urlencoded,omitempty" type:"Struct"`
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody) SetFormdata(v *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata) *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody {
	s.Formdata = v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody) SetLanguage(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody {
	s.Language = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody) SetMode(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody {
	s.Mode = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody) SetRaw(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody {
	s.Raw = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody) SetUrlencoded(v *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded) *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBody {
	s.Urlencoded = v
	return s
}

type GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata) SetKey(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata {
	s.Key = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata) SetValue(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyFormdata {
	s.Value = &v
	return s
}

type GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded) SetKey(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded {
	s.Key = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded) SetValue(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentBodyUrlencoded {
	s.Value = &v
	return s
}

type GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader) SetKey(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader {
	s.Key = &v
	return s
}

func (s *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader) SetValue(v string) *GetSyntheticTaskDetailResponseBodyTaskDetailProtocolRequestContentHeader {
	s.Value = &v
	return s
}

type GetSyntheticTaskDetailResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetSyntheticTaskDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetSyntheticTaskDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskDetailResponse) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskDetailResponse) SetHeaders(v map[string]*string) *GetSyntheticTaskDetailResponse {
	s.Headers = v
	return s
}

func (s *GetSyntheticTaskDetailResponse) SetStatusCode(v int32) *GetSyntheticTaskDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetSyntheticTaskDetailResponse) SetBody(v *GetSyntheticTaskDetailResponseBody) *GetSyntheticTaskDetailResponse {
	s.Body = v
	return s
}

type GetSyntheticTaskListRequest struct {
	Direction  *string `json:"Direction,omitempty" xml:"Direction,omitempty"`
	Order      *string `json:"Order,omitempty" xml:"Order,omitempty"`
	PageNum    *int64  `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	PageSize   *int64  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RegionId   *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	TaskName   *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
	TaskStatus *string `json:"TaskStatus,omitempty" xml:"TaskStatus,omitempty"`
	TaskType   *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
	Url        *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetSyntheticTaskListRequest) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskListRequest) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskListRequest) SetDirection(v string) *GetSyntheticTaskListRequest {
	s.Direction = &v
	return s
}

func (s *GetSyntheticTaskListRequest) SetOrder(v string) *GetSyntheticTaskListRequest {
	s.Order = &v
	return s
}

func (s *GetSyntheticTaskListRequest) SetPageNum(v int64) *GetSyntheticTaskListRequest {
	s.PageNum = &v
	return s
}

func (s *GetSyntheticTaskListRequest) SetPageSize(v int64) *GetSyntheticTaskListRequest {
	s.PageSize = &v
	return s
}

func (s *GetSyntheticTaskListRequest) SetRegionId(v string) *GetSyntheticTaskListRequest {
	s.RegionId = &v
	return s
}

func (s *GetSyntheticTaskListRequest) SetTaskName(v string) *GetSyntheticTaskListRequest {
	s.TaskName = &v
	return s
}

func (s *GetSyntheticTaskListRequest) SetTaskStatus(v string) *GetSyntheticTaskListRequest {
	s.TaskStatus = &v
	return s
}

func (s *GetSyntheticTaskListRequest) SetTaskType(v string) *GetSyntheticTaskListRequest {
	s.TaskType = &v
	return s
}

func (s *GetSyntheticTaskListRequest) SetUrl(v string) *GetSyntheticTaskListRequest {
	s.Url = &v
	return s
}

type GetSyntheticTaskListResponseBody struct {
	PageInfo  *GetSyntheticTaskListResponseBodyPageInfo `json:"PageInfo,omitempty" xml:"PageInfo,omitempty" type:"Struct"`
	RequestId *string                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetSyntheticTaskListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskListResponseBody) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskListResponseBody) SetPageInfo(v *GetSyntheticTaskListResponseBodyPageInfo) *GetSyntheticTaskListResponseBody {
	s.PageInfo = v
	return s
}

func (s *GetSyntheticTaskListResponseBody) SetRequestId(v string) *GetSyntheticTaskListResponseBody {
	s.RequestId = &v
	return s
}

type GetSyntheticTaskListResponseBodyPageInfo struct {
	HasNextPage       *string                                         `json:"HasNextPage,omitempty" xml:"HasNextPage,omitempty"`
	HasPreviousPage   *bool                                           `json:"HasPreviousPage,omitempty" xml:"HasPreviousPage,omitempty"`
	IsFirstPage       *bool                                           `json:"IsFirstPage,omitempty" xml:"IsFirstPage,omitempty"`
	IsLastPage        *bool                                           `json:"IsLastPage,omitempty" xml:"IsLastPage,omitempty"`
	List              []*GetSyntheticTaskListResponseBodyPageInfoList `json:"List,omitempty" xml:"List,omitempty" type:"Repeated"`
	NavigateFirstPage *string                                         `json:"NavigateFirstPage,omitempty" xml:"NavigateFirstPage,omitempty"`
	NavigateLastPage  *string                                         `json:"NavigateLastPage,omitempty" xml:"NavigateLastPage,omitempty"`
	NavigatePageNums  *string                                         `json:"NavigatePageNums,omitempty" xml:"NavigatePageNums,omitempty"`
	NextPage          *string                                         `json:"NextPage,omitempty" xml:"NextPage,omitempty"`
	Pages             *string                                         `json:"Pages,omitempty" xml:"Pages,omitempty"`
	Prepage           *string                                         `json:"Prepage,omitempty" xml:"Prepage,omitempty"`
	Size              *int64                                          `json:"Size,omitempty" xml:"Size,omitempty"`
	Total             *int64                                          `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s GetSyntheticTaskListResponseBodyPageInfo) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskListResponseBodyPageInfo) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskListResponseBodyPageInfo) SetHasNextPage(v string) *GetSyntheticTaskListResponseBodyPageInfo {
	s.HasNextPage = &v
	return s
}

func (s *GetSyntheticTaskListResponseBodyPageInfo) SetHasPreviousPage(v bool) *GetSyntheticTaskListResponseBodyPageInfo {
	s.HasPreviousPage = &v
	return s
}

func (s *GetSyntheticTaskListResponseBodyPageInfo) SetIsFirstPage(v bool) *GetSyntheticTaskListResponseBodyPageInfo {
	s.IsFirstPage = &v
	return s
}

func (s *GetSyntheticTaskListResponseBodyPageInfo) SetIsLastPage(v bool) *GetSyntheticTaskListResponseBodyPageInfo {
	s.IsLastPage = &v
	return s
}

func (s *GetSyntheticTaskListResponseBodyPageInfo) SetList(v []*GetSyntheticTaskListResponseBodyPageInfoList) *GetSyntheticTaskListResponseBodyPageInfo {
	s.List = v
	return s
}

func (s *GetSyntheticTaskListResponseBodyPageInfo) SetNavigateFirstPage(v string) *GetSyntheticTaskListResponseBodyPageInfo {
	s.NavigateFirstPage = &v
	return s
}

func (s *GetSyntheticTaskListResponseBodyPageInfo) SetNavigateLastPage(v string) *GetSyntheticTaskListResponseBodyPageInfo {
	s.NavigateLastPage = &v
	return s
}

func (s *GetSyntheticTaskListResponseBodyPageInfo) SetNavigatePageNums(v string) *GetSyntheticTaskListResponseBodyPageInfo {
	s.NavigatePageNums = &v
	return s
}

func (s *GetSyntheticTaskListResponseBodyPageInfo) SetNextPage(v string) *GetSyntheticTaskListResponseBodyPageInfo {
	s.NextPage = &v
	return s
}

func (s *GetSyntheticTaskListResponseBodyPageInfo) SetPages(v string) *GetSyntheticTaskListResponseBodyPageInfo {
	s.Pages = &v
	return s
}

func (s *GetSyntheticTaskListResponseBodyPageInfo) SetPrepage(v string) *GetSyntheticTaskListResponseBodyPageInfo {
	s.Prepage = &v
	return s
}

func (s *GetSyntheticTaskListResponseBodyPageInfo) SetSize(v int64) *GetSyntheticTaskListResponseBodyPageInfo {
	s.Size = &v
	return s
}

func (s *GetSyntheticTaskListResponseBodyPageInfo) SetTotal(v int64) *GetSyntheticTaskListResponseBodyPageInfo {
	s.Total = &v
	return s
}

type GetSyntheticTaskListResponseBodyPageInfoList struct {
	CreateTime    *string  `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	MonitorNumber *int64   `json:"MonitorNumber,omitempty" xml:"MonitorNumber,omitempty"`
	TaskId        *string  `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	TaskName      *string  `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
	TaskStatus    *string  `json:"TaskStatus,omitempty" xml:"TaskStatus,omitempty"`
	TaskType      *int64   `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
	TaskTypeName  *string  `json:"TaskTypeName,omitempty" xml:"TaskTypeName,omitempty"`
	Url           *string  `json:"Url,omitempty" xml:"Url,omitempty"`
	Usable        *float32 `json:"Usable,omitempty" xml:"Usable,omitempty"`
}

func (s GetSyntheticTaskListResponseBodyPageInfoList) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskListResponseBodyPageInfoList) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskListResponseBodyPageInfoList) SetCreateTime(v string) *GetSyntheticTaskListResponseBodyPageInfoList {
	s.CreateTime = &v
	return s
}

func (s *GetSyntheticTaskListResponseBodyPageInfoList) SetMonitorNumber(v int64) *GetSyntheticTaskListResponseBodyPageInfoList {
	s.MonitorNumber = &v
	return s
}

func (s *GetSyntheticTaskListResponseBodyPageInfoList) SetTaskId(v string) *GetSyntheticTaskListResponseBodyPageInfoList {
	s.TaskId = &v
	return s
}

func (s *GetSyntheticTaskListResponseBodyPageInfoList) SetTaskName(v string) *GetSyntheticTaskListResponseBodyPageInfoList {
	s.TaskName = &v
	return s
}

func (s *GetSyntheticTaskListResponseBodyPageInfoList) SetTaskStatus(v string) *GetSyntheticTaskListResponseBodyPageInfoList {
	s.TaskStatus = &v
	return s
}

func (s *GetSyntheticTaskListResponseBodyPageInfoList) SetTaskType(v int64) *GetSyntheticTaskListResponseBodyPageInfoList {
	s.TaskType = &v
	return s
}

func (s *GetSyntheticTaskListResponseBodyPageInfoList) SetTaskTypeName(v string) *GetSyntheticTaskListResponseBodyPageInfoList {
	s.TaskTypeName = &v
	return s
}

func (s *GetSyntheticTaskListResponseBodyPageInfoList) SetUrl(v string) *GetSyntheticTaskListResponseBodyPageInfoList {
	s.Url = &v
	return s
}

func (s *GetSyntheticTaskListResponseBodyPageInfoList) SetUsable(v float32) *GetSyntheticTaskListResponseBodyPageInfoList {
	s.Usable = &v
	return s
}

type GetSyntheticTaskListResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetSyntheticTaskListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetSyntheticTaskListResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskListResponse) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskListResponse) SetHeaders(v map[string]*string) *GetSyntheticTaskListResponse {
	s.Headers = v
	return s
}

func (s *GetSyntheticTaskListResponse) SetStatusCode(v int32) *GetSyntheticTaskListResponse {
	s.StatusCode = &v
	return s
}

func (s *GetSyntheticTaskListResponse) SetBody(v *GetSyntheticTaskListResponseBody) *GetSyntheticTaskListResponse {
	s.Body = v
	return s
}

type GetSyntheticTaskMonitorsRequest struct {
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetSyntheticTaskMonitorsRequest) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskMonitorsRequest) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskMonitorsRequest) SetRegionId(v string) *GetSyntheticTaskMonitorsRequest {
	s.RegionId = &v
	return s
}

type GetSyntheticTaskMonitorsResponseBody struct {
	Code      *string                                     `json:"Code,omitempty" xml:"Code,omitempty"`
	Data      []*GetSyntheticTaskMonitorsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	Msg       *string                                     `json:"Msg,omitempty" xml:"Msg,omitempty"`
	RequestId *string                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetSyntheticTaskMonitorsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskMonitorsResponseBody) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskMonitorsResponseBody) SetCode(v string) *GetSyntheticTaskMonitorsResponseBody {
	s.Code = &v
	return s
}

func (s *GetSyntheticTaskMonitorsResponseBody) SetData(v []*GetSyntheticTaskMonitorsResponseBodyData) *GetSyntheticTaskMonitorsResponseBody {
	s.Data = v
	return s
}

func (s *GetSyntheticTaskMonitorsResponseBody) SetMsg(v string) *GetSyntheticTaskMonitorsResponseBody {
	s.Msg = &v
	return s
}

func (s *GetSyntheticTaskMonitorsResponseBody) SetRequestId(v string) *GetSyntheticTaskMonitorsResponseBody {
	s.RequestId = &v
	return s
}

type GetSyntheticTaskMonitorsResponseBodyData struct {
	Busy           *int64  `json:"Busy,omitempty" xml:"Busy,omitempty"`
	City           *string `json:"City,omitempty" xml:"City,omitempty"`
	CityCode       *int64  `json:"CityCode,omitempty" xml:"CityCode,omitempty"`
	ClientType     *int64  `json:"ClientType,omitempty" xml:"ClientType,omitempty"`
	District       *string `json:"District,omitempty" xml:"District,omitempty"`
	NetServiceId   *int64  `json:"NetServiceId,omitempty" xml:"NetServiceId,omitempty"`
	NetServiceName *string `json:"NetServiceName,omitempty" xml:"NetServiceName,omitempty"`
}

func (s GetSyntheticTaskMonitorsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskMonitorsResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskMonitorsResponseBodyData) SetBusy(v int64) *GetSyntheticTaskMonitorsResponseBodyData {
	s.Busy = &v
	return s
}

func (s *GetSyntheticTaskMonitorsResponseBodyData) SetCity(v string) *GetSyntheticTaskMonitorsResponseBodyData {
	s.City = &v
	return s
}

func (s *GetSyntheticTaskMonitorsResponseBodyData) SetCityCode(v int64) *GetSyntheticTaskMonitorsResponseBodyData {
	s.CityCode = &v
	return s
}

func (s *GetSyntheticTaskMonitorsResponseBodyData) SetClientType(v int64) *GetSyntheticTaskMonitorsResponseBodyData {
	s.ClientType = &v
	return s
}

func (s *GetSyntheticTaskMonitorsResponseBodyData) SetDistrict(v string) *GetSyntheticTaskMonitorsResponseBodyData {
	s.District = &v
	return s
}

func (s *GetSyntheticTaskMonitorsResponseBodyData) SetNetServiceId(v int64) *GetSyntheticTaskMonitorsResponseBodyData {
	s.NetServiceId = &v
	return s
}

func (s *GetSyntheticTaskMonitorsResponseBodyData) SetNetServiceName(v string) *GetSyntheticTaskMonitorsResponseBodyData {
	s.NetServiceName = &v
	return s
}

type GetSyntheticTaskMonitorsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetSyntheticTaskMonitorsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetSyntheticTaskMonitorsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSyntheticTaskMonitorsResponse) GoString() string {
	return s.String()
}

func (s *GetSyntheticTaskMonitorsResponse) SetHeaders(v map[string]*string) *GetSyntheticTaskMonitorsResponse {
	s.Headers = v
	return s
}

func (s *GetSyntheticTaskMonitorsResponse) SetStatusCode(v int32) *GetSyntheticTaskMonitorsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetSyntheticTaskMonitorsResponse) SetBody(v *GetSyntheticTaskMonitorsResponseBody) *GetSyntheticTaskMonitorsResponse {
	s.Body = v
	return s
}

type GetTimingSyntheticTaskRequest struct {
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the synthetic monitoring task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s GetTimingSyntheticTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s GetTimingSyntheticTaskRequest) GoString() string {
	return s.String()
}

func (s *GetTimingSyntheticTaskRequest) SetRegionId(v string) *GetTimingSyntheticTaskRequest {
	s.RegionId = &v
	return s
}

func (s *GetTimingSyntheticTaskRequest) SetTaskId(v string) *GetTimingSyntheticTaskRequest {
	s.TaskId = &v
	return s
}

type GetTimingSyntheticTaskResponseBody struct {
	// The status code returned. The status code 200 indicates that the request was successful.
	Code *int64 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The struct returned.
	Data *GetTimingSyntheticTaskResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetTimingSyntheticTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetTimingSyntheticTaskResponseBody) GoString() string {
	return s.String()
}

func (s *GetTimingSyntheticTaskResponseBody) SetCode(v int64) *GetTimingSyntheticTaskResponseBody {
	s.Code = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBody) SetData(v *GetTimingSyntheticTaskResponseBodyData) *GetTimingSyntheticTaskResponseBody {
	s.Data = v
	return s
}

func (s *GetTimingSyntheticTaskResponseBody) SetMessage(v string) *GetTimingSyntheticTaskResponseBody {
	s.Message = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBody) SetRequestId(v string) *GetTimingSyntheticTaskResponseBody {
	s.RequestId = &v
	return s
}

type GetTimingSyntheticTaskResponseBodyData struct {
	// The list of assertions.
	AvailableAssertions []*GetTimingSyntheticTaskResponseBodyDataAvailableAssertions `json:"AvailableAssertions,omitempty" xml:"AvailableAssertions,omitempty" type:"Repeated"`
	// The general settings.
	CommonSetting *GetTimingSyntheticTaskResponseBodyDataCommonSetting `json:"CommonSetting,omitempty" xml:"CommonSetting,omitempty" type:"Struct"`
	// The custom cycle.
	CustomPeriod *GetTimingSyntheticTaskResponseBodyDataCustomPeriod `json:"CustomPeriod,omitempty" xml:"CustomPeriod,omitempty" type:"Struct"`
	// The detection frequency. Valid values: 1m, 5m, 10m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, and 24h.
	Frequency *string `json:"Frequency,omitempty" xml:"Frequency,omitempty"`
	// The detection point type. 1: PC. 2: mobile device.
	MonitorCategory *int64 `json:"MonitorCategory,omitempty" xml:"MonitorCategory,omitempty"`
	// The monitoring configurations.
	MonitorConf *GetTimingSyntheticTaskResponseBodyDataMonitorConf `json:"MonitorConf,omitempty" xml:"MonitorConf,omitempty" type:"Struct"`
	// The list of monitoring points.
	Monitors []*GetTimingSyntheticTaskResponseBodyDataMonitors `json:"Monitors,omitempty" xml:"Monitors,omitempty" type:"Repeated"`
	// The name of the task.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// CREATING: The task is being created. RUNNING: The task is running. PARTIAL_RUNNING: The task is partially running. STOP: The task is stopped. LIMIT_STOP: The task is stopped due to quota insufficiency. EXCEPTION: The task is abnormal. DELETE: The task is deleted. DELETE_EXCEPTION: The task failed to be deleted.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tag.
	Tags []*GetTimingSyntheticTaskResponseBodyDataTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The ID of the synthetic monitoring task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The type of the task. Valid values:
	//
	// ICMP TCP DNS HTTP Website speed measurement File download
	TaskType *int32 `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s GetTimingSyntheticTaskResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetTimingSyntheticTaskResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetTimingSyntheticTaskResponseBodyData) SetAvailableAssertions(v []*GetTimingSyntheticTaskResponseBodyDataAvailableAssertions) *GetTimingSyntheticTaskResponseBodyData {
	s.AvailableAssertions = v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyData) SetCommonSetting(v *GetTimingSyntheticTaskResponseBodyDataCommonSetting) *GetTimingSyntheticTaskResponseBodyData {
	s.CommonSetting = v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyData) SetCustomPeriod(v *GetTimingSyntheticTaskResponseBodyDataCustomPeriod) *GetTimingSyntheticTaskResponseBodyData {
	s.CustomPeriod = v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyData) SetFrequency(v string) *GetTimingSyntheticTaskResponseBodyData {
	s.Frequency = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyData) SetMonitorCategory(v int64) *GetTimingSyntheticTaskResponseBodyData {
	s.MonitorCategory = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyData) SetMonitorConf(v *GetTimingSyntheticTaskResponseBodyDataMonitorConf) *GetTimingSyntheticTaskResponseBodyData {
	s.MonitorConf = v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyData) SetMonitors(v []*GetTimingSyntheticTaskResponseBodyDataMonitors) *GetTimingSyntheticTaskResponseBodyData {
	s.Monitors = v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyData) SetName(v string) *GetTimingSyntheticTaskResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyData) SetRegionId(v string) *GetTimingSyntheticTaskResponseBodyData {
	s.RegionId = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyData) SetResourceGroupId(v string) *GetTimingSyntheticTaskResponseBodyData {
	s.ResourceGroupId = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyData) SetStatus(v string) *GetTimingSyntheticTaskResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyData) SetTags(v []*GetTimingSyntheticTaskResponseBodyDataTags) *GetTimingSyntheticTaskResponseBodyData {
	s.Tags = v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyData) SetTaskId(v string) *GetTimingSyntheticTaskResponseBodyData {
	s.TaskId = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyData) SetTaskType(v int32) *GetTimingSyntheticTaskResponseBodyData {
	s.TaskType = &v
	return s
}

type GetTimingSyntheticTaskResponseBodyDataAvailableAssertions struct {
	// The expected value.
	Expect *string `json:"Expect,omitempty" xml:"Expect,omitempty"`
	// The condition. gt: greater than. gte: greater than or equal to. lt: less than. lte: less than or equal to. eq: equal to. neq: not equal to. ctn: contain. nctn: does not contain. exist: exist. n_exist: does not exist. belong: belong to. n_belong: does not belong to. reg_match: regular expression.
	Operator *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
	// The check target. If you set the type parameter to HttpResCode, HttpResBody, or HttpResponseTime, you do not need to set the target parameter. If you set the type parameter to HttpResHead, you must specify the key in the header. If you set the type parameter to HttpResBodyJson, use jsonPath.
	Target *string `json:"Target,omitempty" xml:"Target,omitempty"`
	// The assertion type. Valid values: HttpResCode, HttpResHead, HttpResBody, HttpResBodyJson, HttpResponseTime, IcmpPackLoss (packet loss rate), IcmpPackMaxLatency (maximum packet latency), IcmpPackAvgLatency (average packet latency), TraceRouteHops (number of hops), DnsARecord (A record), DnsCName (CNAME), websiteTTFB (time to first packet), websiteTTLB (time to last packet), websiteFST (first paint time), websiteFFST (first meaningful paint), websiteOnload (full loaded time). For more information, see the following description.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetTimingSyntheticTaskResponseBodyDataAvailableAssertions) String() string {
	return tea.Prettify(s)
}

func (s GetTimingSyntheticTaskResponseBodyDataAvailableAssertions) GoString() string {
	return s.String()
}

func (s *GetTimingSyntheticTaskResponseBodyDataAvailableAssertions) SetExpect(v string) *GetTimingSyntheticTaskResponseBodyDataAvailableAssertions {
	s.Expect = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataAvailableAssertions) SetOperator(v string) *GetTimingSyntheticTaskResponseBodyDataAvailableAssertions {
	s.Operator = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataAvailableAssertions) SetTarget(v string) *GetTimingSyntheticTaskResponseBodyDataAvailableAssertions {
	s.Target = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataAvailableAssertions) SetType(v string) *GetTimingSyntheticTaskResponseBodyDataAvailableAssertions {
	s.Type = &v
	return s
}

type GetTimingSyntheticTaskResponseBodyDataCommonSetting struct {
	// The custom host.
	CustomHost *GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHost `json:"CustomHost,omitempty" xml:"CustomHost,omitempty" type:"Struct"`
	// The IP version. Valid values:
	//
	// *   0: A version is automatically selected.
	// *   1: IPv4
	// *   2: IPv6
	IpType *int32 `json:"IpType,omitempty" xml:"IpType,omitempty"`
	// 是否开启链路追踪。
	IsOpenTrace *bool `json:"IsOpenTrace,omitempty" xml:"IsOpenTrace,omitempty"`
	// Specifies whether to evenly distribute monitoring samples. Valid values:
	//
	// *   0: No
	// *   1: Yes
	MonitorSamples *int32 `json:"MonitorSamples,omitempty" xml:"MonitorSamples,omitempty"`
	// 链路追踪客户端类型：
	//
	// - 0：ARMS Agent
	// - 1：OpenTelemetry
	// - 2：Jaeger
	TraceClientType *int32 `json:"TraceClientType,omitempty" xml:"TraceClientType,omitempty"`
	// 链路数据上报region。
	XtraceRegion *string `json:"XtraceRegion,omitempty" xml:"XtraceRegion,omitempty"`
}

func (s GetTimingSyntheticTaskResponseBodyDataCommonSetting) String() string {
	return tea.Prettify(s)
}

func (s GetTimingSyntheticTaskResponseBodyDataCommonSetting) GoString() string {
	return s.String()
}

func (s *GetTimingSyntheticTaskResponseBodyDataCommonSetting) SetCustomHost(v *GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHost) *GetTimingSyntheticTaskResponseBodyDataCommonSetting {
	s.CustomHost = v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataCommonSetting) SetIpType(v int32) *GetTimingSyntheticTaskResponseBodyDataCommonSetting {
	s.IpType = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataCommonSetting) SetIsOpenTrace(v bool) *GetTimingSyntheticTaskResponseBodyDataCommonSetting {
	s.IsOpenTrace = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataCommonSetting) SetMonitorSamples(v int32) *GetTimingSyntheticTaskResponseBodyDataCommonSetting {
	s.MonitorSamples = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataCommonSetting) SetTraceClientType(v int32) *GetTimingSyntheticTaskResponseBodyDataCommonSetting {
	s.TraceClientType = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataCommonSetting) SetXtraceRegion(v string) *GetTimingSyntheticTaskResponseBodyDataCommonSetting {
	s.XtraceRegion = &v
	return s
}

type GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHost struct {
	// The list of hosts.
	Hosts []*GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts `json:"Hosts,omitempty" xml:"Hosts,omitempty" type:"Repeated"`
	// The selection mode. 0: Random. 1: Polling.
	SelectType *int32 `json:"SelectType,omitempty" xml:"SelectType,omitempty"`
}

func (s GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHost) String() string {
	return tea.Prettify(s)
}

func (s GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHost) GoString() string {
	return s.String()
}

func (s *GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHost) SetHosts(v []*GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts) *GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHost {
	s.Hosts = v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHost) SetSelectType(v int32) *GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHost {
	s.SelectType = &v
	return s
}

type GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts struct {
	// The domain name.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The IP version. Valid values:
	//
	// *   0: A version is automatically selected.
	// *   1: IPv4
	// *   2: IPv6
	IpType *int32 `json:"IpType,omitempty" xml:"IpType,omitempty"`
	// The list of IP addresses.
	Ips []*string `json:"Ips,omitempty" xml:"Ips,omitempty" type:"Repeated"`
}

func (s GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts) String() string {
	return tea.Prettify(s)
}

func (s GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts) GoString() string {
	return s.String()
}

func (s *GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts) SetDomain(v string) *GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts {
	s.Domain = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts) SetIpType(v int32) *GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts {
	s.IpType = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts) SetIps(v []*string) *GetTimingSyntheticTaskResponseBodyDataCommonSettingCustomHostHosts {
	s.Ips = v
	return s
}

type GetTimingSyntheticTaskResponseBodyDataCustomPeriod struct {
	// The hour at which the test ends. Valid values: 0 to 24.
	EndHour *int64 `json:"EndHour,omitempty" xml:"EndHour,omitempty"`
	// The hour at which the test starts. Valid values: 0 to 24.
	StartHour *int64 `json:"StartHour,omitempty" xml:"StartHour,omitempty"`
}

func (s GetTimingSyntheticTaskResponseBodyDataCustomPeriod) String() string {
	return tea.Prettify(s)
}

func (s GetTimingSyntheticTaskResponseBodyDataCustomPeriod) GoString() string {
	return s.String()
}

func (s *GetTimingSyntheticTaskResponseBodyDataCustomPeriod) SetEndHour(v int64) *GetTimingSyntheticTaskResponseBodyDataCustomPeriod {
	s.EndHour = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataCustomPeriod) SetStartHour(v int64) *GetTimingSyntheticTaskResponseBodyDataCustomPeriod {
	s.StartHour = &v
	return s
}

type GetTimingSyntheticTaskResponseBodyDataMonitorConf struct {
	// The HTTP(S) synthetic test parameters.
	ApiHTTP *GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP `json:"ApiHTTP,omitempty" xml:"ApiHTTP,omitempty" type:"Struct"`
	// The file download parameters.
	FileDownload *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload `json:"FileDownload,omitempty" xml:"FileDownload,omitempty" type:"Struct"`
	// The DNS synthetic test parameters. This parameter is required if the TaskType parameter is set to 3.
	NetDNS *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS `json:"NetDNS,omitempty" xml:"NetDNS,omitempty" type:"Struct"`
	// The ICMP synthetic test parameters. This parameter is required if the TaskType parameter is set to 1.
	NetICMP *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP `json:"NetICMP,omitempty" xml:"NetICMP,omitempty" type:"Struct"`
	// The TCP synthetic tests parameters. This parameter is required if the TaskType parameter is set to 2.
	NetTCP *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP `json:"NetTCP,omitempty" xml:"NetTCP,omitempty" type:"Struct"`
	// 流媒体拨测配置。
	Stream *GetTimingSyntheticTaskResponseBodyDataMonitorConfStream `json:"Stream,omitempty" xml:"Stream,omitempty" type:"Struct"`
	// The website-speed measurement parameters.
	Website *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite `json:"Website,omitempty" xml:"Website,omitempty" type:"Struct"`
}

func (s GetTimingSyntheticTaskResponseBodyDataMonitorConf) String() string {
	return tea.Prettify(s)
}

func (s GetTimingSyntheticTaskResponseBodyDataMonitorConf) GoString() string {
	return s.String()
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConf) SetApiHTTP(v *GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP) *GetTimingSyntheticTaskResponseBodyDataMonitorConf {
	s.ApiHTTP = v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConf) SetFileDownload(v *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload) *GetTimingSyntheticTaskResponseBodyDataMonitorConf {
	s.FileDownload = v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConf) SetNetDNS(v *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS) *GetTimingSyntheticTaskResponseBodyDataMonitorConf {
	s.NetDNS = v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConf) SetNetICMP(v *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP) *GetTimingSyntheticTaskResponseBodyDataMonitorConf {
	s.NetICMP = v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConf) SetNetTCP(v *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP) *GetTimingSyntheticTaskResponseBodyDataMonitorConf {
	s.NetTCP = v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConf) SetStream(v *GetTimingSyntheticTaskResponseBodyDataMonitorConfStream) *GetTimingSyntheticTaskResponseBodyDataMonitorConf {
	s.Stream = v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConf) SetWebsite(v *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite) *GetTimingSyntheticTaskResponseBodyDataMonitorConf {
	s.Website = v
	return s
}

type GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP struct {
	// The connection timeout period. Unit: milliseconds. Default value: 5000. Minimum value: 1000. Maximum value: 300000.
	ConnectTimeout *int64 `json:"ConnectTimeout,omitempty" xml:"ConnectTimeout,omitempty"`
	// The request method.
	//
	// *   POST
	// *   GET
	Method *string `json:"Method,omitempty" xml:"Method,omitempty"`
	// The HTTP request body.
	RequestBody *GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTPRequestBody `json:"RequestBody,omitempty" xml:"RequestBody,omitempty" type:"Struct"`
	// The HTTP request header.
	RequestHeaders map[string]*string `json:"RequestHeaders,omitempty" xml:"RequestHeaders,omitempty"`
	// The URL for synthetic monitoring.
	TargetUrl *string `json:"TargetUrl,omitempty" xml:"TargetUrl,omitempty"`
	// The timeout period. Unit: milliseconds. Default value: 10000. Minimum value: 1000. Maximum value: 300000.
	Timeout *int64 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
}

func (s GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP) String() string {
	return tea.Prettify(s)
}

func (s GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP) GoString() string {
	return s.String()
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP) SetConnectTimeout(v int64) *GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP {
	s.ConnectTimeout = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP) SetMethod(v string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP {
	s.Method = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP) SetRequestBody(v *GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTPRequestBody) *GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP {
	s.RequestBody = v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP) SetRequestHeaders(v map[string]*string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP {
	s.RequestHeaders = v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP) SetTargetUrl(v string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP {
	s.TargetUrl = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP) SetTimeout(v int64) *GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTP {
	s.Timeout = &v
	return s
}

type GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTPRequestBody struct {
	// The content of the request body. Format: JSON string. The parameter is required if the type parameter is set to text/plain, application/json, application/xml, or text/html. Format: JSON string.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The type of the request body. Valid values: text/plain, application/json, application/x-www-form-urlencoded, multipart/form-data, application/xml, and text/html.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTPRequestBody) String() string {
	return tea.Prettify(s)
}

func (s GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTPRequestBody) GoString() string {
	return s.String()
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTPRequestBody) SetContent(v string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTPRequestBody {
	s.Content = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTPRequestBody) SetType(v string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfApiHTTPRequestBody {
	s.Type = &v
	return s
}

type GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload struct {
	// The connection timeout period. Unit: milliseconds. Minimum value: 1000. Maximum value: 120000. Default value: 5000.
	ConnectionTimeout *int64 `json:"ConnectionTimeout,omitempty" xml:"ConnectionTimeout,omitempty"`
	// The content of the custom request header.
	CustomHeaderContent map[string]*string `json:"CustomHeaderContent,omitempty" xml:"CustomHeaderContent,omitempty"`
	// The kernel type.
	//
	// *   1: curl
	// *   0: WinInet
	DownloadKernel *int64 `json:"DownloadKernel,omitempty" xml:"DownloadKernel,omitempty"`
	// Specifies whether to ignore CA certificate authentication errors. 0: No. 1: Yes. Default value: 1.
	IgnoreCertificateAuthError *int32 `json:"IgnoreCertificateAuthError,omitempty" xml:"IgnoreCertificateAuthError,omitempty"`
	// Specifies whether to ignore certificate revocation errors. 0: No. 1: Yes. Default value: 1.
	IgnoreCertificateCanceledError *int32 `json:"IgnoreCertificateCanceledError,omitempty" xml:"IgnoreCertificateCanceledError,omitempty"`
	// Specifies whether to ignore certificate invalidity. 0: No. 1: Yes. Default value: 1.
	IgnoreCertificateOutOfDateError *int32 `json:"IgnoreCertificateOutOfDateError,omitempty" xml:"IgnoreCertificateOutOfDateError,omitempty"`
	// Specifies whether to ignore certificate status errors. 0: No. 1: Yes. Default value: 1.
	IgnoreCertificateStatusError *int32 `json:"IgnoreCertificateStatusError,omitempty" xml:"IgnoreCertificateStatusError,omitempty"`
	// Specifies whether to ignore certificate incredibility. 0: No. 1: Yes. Default value: 1.
	IgnoreCertificateUntrustworthyError *int32 `json:"IgnoreCertificateUntrustworthyError,omitempty" xml:"IgnoreCertificateUntrustworthyError,omitempty"`
	// Specifies whether to ignore certificate usage errors. 0: No. 1: Yes. Default value: 1.
	IgnoreCertificateUsingError *int32 `json:"IgnoreCertificateUsingError,omitempty" xml:"IgnoreCertificateUsingError,omitempty"`
	// Specifies whether to ignore host invalidity. 0: No. 1: Yes. Default value: 1.
	IgnoreInvalidHostError *int32 `json:"IgnoreInvalidHostError,omitempty" xml:"IgnoreInvalidHostError,omitempty"`
	// The monitoring timeout period. Unit: milliseconds. Minimum value: 1000. Maximum value: 120000. Default value: 60000.
	MonitorTimeout *int64 `json:"MonitorTimeout,omitempty" xml:"MonitorTimeout,omitempty"`
	// The QUIC protocol type.
	//
	// *   1: http1
	// *   2: http2
	// *   3: http3
	QuickProtocol *int64 `json:"QuickProtocol,omitempty" xml:"QuickProtocol,omitempty"`
	// Specifies whether to support redirection. 0: No. 1: Yes. Default value: 1.
	Redirection *int32 `json:"Redirection,omitempty" xml:"Redirection,omitempty"`
	// The file download URL.
	TargetUrl *string `json:"TargetUrl,omitempty" xml:"TargetUrl,omitempty"`
	// The maximum file size of a single transfer. Unit: KB. Minimum value: 1. Maximum value: 20480. Valid values: 2048.
	TransmissionSize *int64 `json:"TransmissionSize,omitempty" xml:"TransmissionSize,omitempty"`
	// 验证关键词。
	ValidateKeywords *string `json:"ValidateKeywords,omitempty" xml:"ValidateKeywords,omitempty"`
	// 验证方式。
	//
	// - 0：不验证
	// - 1：验证字符串
	// - 2：MD5验证
	VerifyWay *int32 `json:"VerifyWay,omitempty" xml:"VerifyWay,omitempty"`
	// DNS劫持白名单。匹配规则支持IP、IP通配符、子网掩码和CNAME，可以填写多个匹配规则，多个匹配规则以竖线（|）隔开。例如：www.aliyun.com:203.0.3.55|203.3.44.67，表示www.aliyun.com域名下除203.0.3.55和203.3.44.67之外的其他IP都是被劫持的。
	WhiteList *string `json:"WhiteList,omitempty" xml:"WhiteList,omitempty"`
}

func (s GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload) String() string {
	return tea.Prettify(s)
}

func (s GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload) GoString() string {
	return s.String()
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload) SetConnectionTimeout(v int64) *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload {
	s.ConnectionTimeout = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload) SetCustomHeaderContent(v map[string]*string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload {
	s.CustomHeaderContent = v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload) SetDownloadKernel(v int64) *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload {
	s.DownloadKernel = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload) SetIgnoreCertificateAuthError(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload {
	s.IgnoreCertificateAuthError = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload) SetIgnoreCertificateCanceledError(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload {
	s.IgnoreCertificateCanceledError = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload) SetIgnoreCertificateOutOfDateError(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload {
	s.IgnoreCertificateOutOfDateError = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload) SetIgnoreCertificateStatusError(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload {
	s.IgnoreCertificateStatusError = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload) SetIgnoreCertificateUntrustworthyError(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload {
	s.IgnoreCertificateUntrustworthyError = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload) SetIgnoreCertificateUsingError(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload {
	s.IgnoreCertificateUsingError = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload) SetIgnoreInvalidHostError(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload {
	s.IgnoreInvalidHostError = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload) SetMonitorTimeout(v int64) *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload {
	s.MonitorTimeout = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload) SetQuickProtocol(v int64) *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload {
	s.QuickProtocol = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload) SetRedirection(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload {
	s.Redirection = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload) SetTargetUrl(v string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload {
	s.TargetUrl = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload) SetTransmissionSize(v int64) *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload {
	s.TransmissionSize = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload) SetValidateKeywords(v string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload {
	s.ValidateKeywords = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload) SetVerifyWay(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload {
	s.VerifyWay = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload) SetWhiteList(v string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfFileDownload {
	s.WhiteList = &v
	return s
}

type GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS struct {
	// The IP version of the DNS server. 0: IPv4. 1: IPv6. 2: A version is automatically selected. Default value: 0.
	DnsServerIpType *int32 `json:"DnsServerIpType,omitempty" xml:"DnsServerIpType,omitempty"`
	// The IP address of the DNS server. Default value: 114.114.114.114.
	NsServer *string `json:"NsServer,omitempty" xml:"NsServer,omitempty"`
	// The DNS query. 0: recursive, 1: iterative. Default value: 0.
	QueryMethod *int32 `json:"QueryMethod,omitempty" xml:"QueryMethod,omitempty"`
	// The destination domain name.
	TargetUrl *string `json:"TargetUrl,omitempty" xml:"TargetUrl,omitempty"`
	// The timeout period for the DNS synthetic test. Unit: milliseconds. The minimum value is 1000 and the maximum value is 45000. Default value: 5000.
	Timeout *int64 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
}

func (s GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS) String() string {
	return tea.Prettify(s)
}

func (s GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS) GoString() string {
	return s.String()
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS) SetDnsServerIpType(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS {
	s.DnsServerIpType = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS) SetNsServer(v string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS {
	s.NsServer = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS) SetQueryMethod(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS {
	s.QueryMethod = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS) SetTargetUrl(v string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS {
	s.TargetUrl = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS) SetTimeout(v int64) *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetDNS {
	s.Timeout = &v
	return s
}

type GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP struct {
	// The interval at which ICMP packets are sent. Unit: milliseconds. Minimum value: 200. Maximum value: 2000. Default value: 200.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The number of ICMP packets that are sent. Minimum value: 1. Maximum value: 50. Default value: 4.
	PackageNum *int32 `json:"PackageNum,omitempty" xml:"PackageNum,omitempty"`
	// The size of each ICMP packet. Unit: bytes. Valid values: 32, 64, 128, 256, 512, 1024.
	PackageSize *int32 `json:"PackageSize,omitempty" xml:"PackageSize,omitempty"`
	// Specifies whether to split ICMP packets. Default value: true.
	SplitPackage *bool `json:"SplitPackage,omitempty" xml:"SplitPackage,omitempty"`
	// The destination host IP address or domain name
	TargetUrl *string `json:"TargetUrl,omitempty" xml:"TargetUrl,omitempty"`
	// The timeout period for the TCP synthetic test. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 20000.
	Timeout *int64 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	// Specifies whether to enable the tracert command. Default value: true.
	TracertEnable *bool `json:"TracertEnable,omitempty" xml:"TracertEnable,omitempty"`
	// The maximum number of hops for tracert. Minimum value: 1. Maximum value: 128. Default value: 64.
	TracertNumMax *int32 `json:"TracertNumMax,omitempty" xml:"TracertNumMax,omitempty"`
	// The timeout period of tracert. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 60000.
	TracertTimeout *int64 `json:"TracertTimeout,omitempty" xml:"TracertTimeout,omitempty"`
}

func (s GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP) String() string {
	return tea.Prettify(s)
}

func (s GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP) GoString() string {
	return s.String()
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP) SetInterval(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP {
	s.Interval = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP) SetPackageNum(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP {
	s.PackageNum = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP) SetPackageSize(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP {
	s.PackageSize = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP) SetSplitPackage(v bool) *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP {
	s.SplitPackage = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP) SetTargetUrl(v string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP {
	s.TargetUrl = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP) SetTimeout(v int64) *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP {
	s.Timeout = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP) SetTracertEnable(v bool) *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP {
	s.TracertEnable = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP) SetTracertNumMax(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP {
	s.TracertNumMax = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP) SetTracertTimeout(v int64) *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetICMP {
	s.TracertTimeout = &v
	return s
}

type GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP struct {
	// The number of TCP connections that are established in a test. Minimum value: 1. Maximum value: 16. Default value: 4.
	ConnectTimes *int32 `json:"ConnectTimes,omitempty" xml:"ConnectTimes,omitempty"`
	// The interval at which TCP connections are established. Unit: milliseconds. Minimum value: 200. Maximum value: 10000. Default value: 200.
	Interval *int64 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The destination host IP address.
	TargetUrl *string `json:"TargetUrl,omitempty" xml:"TargetUrl,omitempty"`
	// The timeout period for the TCP synthetic test. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 20000.
	Timeout *int64 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	// Specifies whether to enable the tracert command. Default value: true.
	TracertEnable *bool `json:"TracertEnable,omitempty" xml:"TracertEnable,omitempty"`
	// The maximum number of hops for tracert. Minimum value: 1. Maximum value: 128. Default value: 20.
	TracertNumMax *int32 `json:"TracertNumMax,omitempty" xml:"TracertNumMax,omitempty"`
	// The timeout period of tracert. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 60000.
	TracertTimeout *int64 `json:"TracertTimeout,omitempty" xml:"TracertTimeout,omitempty"`
}

func (s GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP) String() string {
	return tea.Prettify(s)
}

func (s GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP) GoString() string {
	return s.String()
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP) SetConnectTimes(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP {
	s.ConnectTimes = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP) SetInterval(v int64) *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP {
	s.Interval = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP) SetTargetUrl(v string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP {
	s.TargetUrl = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP) SetTimeout(v int64) *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP {
	s.Timeout = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP) SetTracertEnable(v bool) *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP {
	s.TracertEnable = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP) SetTracertNumMax(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP {
	s.TracertNumMax = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP) SetTracertTimeout(v int64) *GetTimingSyntheticTaskResponseBodyDataMonitorConfNetTCP {
	s.TracertTimeout = &v
	return s
}

type GetTimingSyntheticTaskResponseBodyDataMonitorConfStream struct {
	// 自定义header，JSON Map格式。
	CustomHeaderContent map[string]*string `json:"CustomHeaderContent,omitempty" xml:"CustomHeaderContent,omitempty"`
	// 播放器，不传默认12。
	//
	// - 12：VLC
	// - 2：FlashPlayer
	PlayerType *int32 `json:"PlayerType,omitempty" xml:"PlayerType,omitempty"`
	// 资源地址类型：
	//
	// - 1：资源地址。
	// - 0：页面地址。不传默认0。
	StreamAddressType *int32 `json:"StreamAddressType,omitempty" xml:"StreamAddressType,omitempty"`
	// 监测时长，单位秒，最长支持60s，不传默认60。
	StreamMonitorTimeout *int32 `json:"StreamMonitorTimeout,omitempty" xml:"StreamMonitorTimeout,omitempty"`
	// 音视频标志：0-视频，1-音频。
	StreamType *int32 `json:"StreamType,omitempty" xml:"StreamType,omitempty"`
	// 流媒体资源地址。
	TargetUrl *string `json:"TargetUrl,omitempty" xml:"TargetUrl,omitempty"`
	// DNS劫持白名单。匹配规则支持IP、IP通配符、子网掩码和CNAME，可以填写多个匹配规则，多个匹配规则以竖线（|）隔开。例如：www.aliyun.com:203.0.3.55|203.3.44.67，表示www.aliyun.com域名下除203.0.3.55和203.3.44.67之外的其他IP都是被劫持的。
	WhiteList *string `json:"WhiteList,omitempty" xml:"WhiteList,omitempty"`
}

func (s GetTimingSyntheticTaskResponseBodyDataMonitorConfStream) String() string {
	return tea.Prettify(s)
}

func (s GetTimingSyntheticTaskResponseBodyDataMonitorConfStream) GoString() string {
	return s.String()
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfStream) SetCustomHeaderContent(v map[string]*string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfStream {
	s.CustomHeaderContent = v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfStream) SetPlayerType(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfStream {
	s.PlayerType = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfStream) SetStreamAddressType(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfStream {
	s.StreamAddressType = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfStream) SetStreamMonitorTimeout(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfStream {
	s.StreamMonitorTimeout = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfStream) SetStreamType(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfStream {
	s.StreamType = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfStream) SetTargetUrl(v string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfStream {
	s.TargetUrl = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfStream) SetWhiteList(v string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfStream {
	s.WhiteList = &v
	return s
}

type GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite struct {
	// Specifies whether to automatically scroll up and down the screen to load a page. 0: No. 1: Yes. Default value: 0.
	AutomaticScrolling *int32 `json:"AutomaticScrolling,omitempty" xml:"AutomaticScrolling,omitempty"`
	// Specifies whether to create a custom header. 0: No. 1: The first packet is modified. 2: All packets are modified. Default value: 0.
	CustomHeader *int32 `json:"CustomHeader,omitempty" xml:"CustomHeader,omitempty"`
	// The custom header. Format: JSON map.
	CustomHeaderContent map[string]*string `json:"CustomHeaderContent,omitempty" xml:"CustomHeaderContent,omitempty"`
	// 域名（例如www.aliyun.com）解析时，解析出的IP地址或者CNAME不在DNS劫持白名单内，用户就会访问失败或者返回一个非Aliyun的目标IP；若解析结果中的IP或者CNAME在DNS白名单内，则会被认定为没有发生DNS劫持。
	//
	// 填写格式：域名:匹配规则。匹配规则支持IP、IP通配符、子网掩码和CNAME，可以填写多个匹配规则，多个匹配规则以竖线（|）隔开。例如：www.aliyun.com:203.0.3.55|203.3.44.67，表示www.aliyun.com域名下除203.0.3.55和203.3.44.67之外的其他IP都是被劫持的。
	DNSHijackWhitelist *string `json:"DNSHijackWhitelist,omitempty" xml:"DNSHijackWhitelist,omitempty"`
	// Specifies whether to disable the cache. 0: No. 1: Yes. Default value: 1.
	DisableCache *int32 `json:"DisableCache,omitempty" xml:"DisableCache,omitempty"`
	// Specifies whether to accept compressed files based on the HTTP Accept-Encoding request header. 0: No. 1: Yes. Default value: 0.
	DisableCompression *int32 `json:"DisableCompression,omitempty" xml:"DisableCompression,omitempty"`
	// 在页面加载过程中如果出现元素黑名单中配置的元素，不会请求加载该元素 。
	ElementBlacklist *string `json:"ElementBlacklist,omitempty" xml:"ElementBlacklist,omitempty"`
	// Specifies whether to exclude invalid IP addresses.
	//
	// *   1: No
	// *   0: Yes
	FilterInvalidIP *int32 `json:"FilterInvalidIP,omitempty" xml:"FilterInvalidIP,omitempty"`
	// 识别元素：设置浏览页面元素总个数。
	FlowHijackJumpTimes *int32 `json:"FlowHijackJumpTimes,omitempty" xml:"FlowHijackJumpTimes,omitempty"`
	// 劫持标识：设置匹配的关键信息。填写劫持判断关键字或关键元素，允许带星号（*）。
	FlowHijackLogo *string `json:"FlowHijackLogo,omitempty" xml:"FlowHijackLogo,omitempty"`
	// Specifies whether to ignore SSL certificate errors during browsing. 0: No. 1: Yes. Default value: 1.
	IgnoreCertificateError *int32 `json:"IgnoreCertificateError,omitempty" xml:"IgnoreCertificateError,omitempty"`
	// The monitoring timeout period. Unit: milliseconds. Default value: 20000. Minimum value: 5000. Maximum value: 300000.
	MonitorTimeout *int32 `json:"MonitorTimeout,omitempty" xml:"MonitorTimeout,omitempty"`
	// 监测页面出现了域名设置之外的元素都属于页面被篡改。常见的表现形式为弹出广告、浮动广告、跳转等。
	//
	// 填写格式：域名:元素。元素支持填写通配符，可以填写多个元素，多个元素以竖线（|）隔开。例如：www.aliyun.com:|/cc/bb/a.gif|/vv/bb/cc.jpg，表示www.aliyun.com域名下除基础文档、/cc/bb/a.gif和/vv/bb/cc.jpg之外的其他元素都属于页面被篡改。
	PageTamper *string `json:"PageTamper,omitempty" xml:"PageTamper,omitempty"`
	// Specifies whether to continue browsing after redirection. 0: No, 1:Yes. Default value: 1.
	Redirection *int32 `json:"Redirection,omitempty" xml:"Redirection,omitempty"`
	// The time threshold that is used to define a slow element. Unit: milliseconds. Default value: 5000. Minimum value: 1. Maximum value: 300000.
	SlowElementThreshold *int64 `json:"SlowElementThreshold,omitempty" xml:"SlowElementThreshold,omitempty"`
	// The destination URL.
	TargetUrl *string `json:"TargetUrl,omitempty" xml:"TargetUrl,omitempty"`
	// 验证字符串即监测页面源代码中的某个任意字符串。若客户端返回的源码中包含任一黑名单中的字符串则报650验证字符串失败的错误。多个字符串以竖线（|）隔开。
	VerifyStringBlacklist *string `json:"VerifyStringBlacklist,omitempty" xml:"VerifyStringBlacklist,omitempty"`
	// 验证字符串即监测页面源代码中的某个任意字符串。客户端返回的源码必须包含所有白名单中的字符串，否则报650验证字符串失败的错误。多个字符串以竖线（|）隔开。
	VerifyStringWhitelist *string `json:"VerifyStringWhitelist,omitempty" xml:"VerifyStringWhitelist,omitempty"`
	// The maximum waiting time. Unit: milliseconds. Default value: 5000. Minimum value: 5000. Maximum value: 300000.
	WaitCompletionTime *int64 `json:"WaitCompletionTime,omitempty" xml:"WaitCompletionTime,omitempty"`
}

func (s GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite) String() string {
	return tea.Prettify(s)
}

func (s GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite) GoString() string {
	return s.String()
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite) SetAutomaticScrolling(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite {
	s.AutomaticScrolling = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite) SetCustomHeader(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite {
	s.CustomHeader = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite) SetCustomHeaderContent(v map[string]*string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite {
	s.CustomHeaderContent = v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite) SetDNSHijackWhitelist(v string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite {
	s.DNSHijackWhitelist = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite) SetDisableCache(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite {
	s.DisableCache = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite) SetDisableCompression(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite {
	s.DisableCompression = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite) SetElementBlacklist(v string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite {
	s.ElementBlacklist = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite) SetFilterInvalidIP(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite {
	s.FilterInvalidIP = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite) SetFlowHijackJumpTimes(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite {
	s.FlowHijackJumpTimes = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite) SetFlowHijackLogo(v string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite {
	s.FlowHijackLogo = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite) SetIgnoreCertificateError(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite {
	s.IgnoreCertificateError = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite) SetMonitorTimeout(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite {
	s.MonitorTimeout = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite) SetPageTamper(v string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite {
	s.PageTamper = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite) SetRedirection(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite {
	s.Redirection = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite) SetSlowElementThreshold(v int64) *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite {
	s.SlowElementThreshold = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite) SetTargetUrl(v string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite {
	s.TargetUrl = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite) SetVerifyStringBlacklist(v string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite {
	s.VerifyStringBlacklist = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite) SetVerifyStringWhitelist(v string) *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite {
	s.VerifyStringWhitelist = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite) SetWaitCompletionTime(v int64) *GetTimingSyntheticTaskResponseBodyDataMonitorConfWebsite {
	s.WaitCompletionTime = &v
	return s
}

type GetTimingSyntheticTaskResponseBodyDataMonitors struct {
	// The city code.
	CityCode *string `json:"CityCode,omitempty" xml:"CityCode,omitempty"`
	// The client type of the monitoring point. Valid values: 1: data center. 2: Internet. 3: mobile device. 4: ECS instance.
	ClientType *int32 `json:"ClientType,omitempty" xml:"ClientType,omitempty"`
	// The carrier code.
	OperatorCode *string `json:"OperatorCode,omitempty" xml:"OperatorCode,omitempty"`
}

func (s GetTimingSyntheticTaskResponseBodyDataMonitors) String() string {
	return tea.Prettify(s)
}

func (s GetTimingSyntheticTaskResponseBodyDataMonitors) GoString() string {
	return s.String()
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitors) SetCityCode(v string) *GetTimingSyntheticTaskResponseBodyDataMonitors {
	s.CityCode = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitors) SetClientType(v int32) *GetTimingSyntheticTaskResponseBodyDataMonitors {
	s.ClientType = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataMonitors) SetOperatorCode(v string) *GetTimingSyntheticTaskResponseBodyDataMonitors {
	s.OperatorCode = &v
	return s
}

type GetTimingSyntheticTaskResponseBodyDataTags struct {
	// The key of the tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetTimingSyntheticTaskResponseBodyDataTags) String() string {
	return tea.Prettify(s)
}

func (s GetTimingSyntheticTaskResponseBodyDataTags) GoString() string {
	return s.String()
}

func (s *GetTimingSyntheticTaskResponseBodyDataTags) SetKey(v string) *GetTimingSyntheticTaskResponseBodyDataTags {
	s.Key = &v
	return s
}

func (s *GetTimingSyntheticTaskResponseBodyDataTags) SetValue(v string) *GetTimingSyntheticTaskResponseBodyDataTags {
	s.Value = &v
	return s
}

type GetTimingSyntheticTaskResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetTimingSyntheticTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetTimingSyntheticTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s GetTimingSyntheticTaskResponse) GoString() string {
	return s.String()
}

func (s *GetTimingSyntheticTaskResponse) SetHeaders(v map[string]*string) *GetTimingSyntheticTaskResponse {
	s.Headers = v
	return s
}

func (s *GetTimingSyntheticTaskResponse) SetStatusCode(v int32) *GetTimingSyntheticTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *GetTimingSyntheticTaskResponse) SetBody(v *GetTimingSyntheticTaskResponseBody) *GetTimingSyntheticTaskResponse {
	s.Body = v
	return s
}

type GetTraceRequest struct {
	// The end of the time range to query. Unit: milliseconds.
	//
	// > If the ID of the trace is 30 characters in length, this parameter is optional. Otherwise, this parameter is required.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The beginning of the time range to query. Unit: milliseconds.
	//
	// > If the ID of the trace is 30 characters in length, this parameter is optional. Otherwise, this parameter is required.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The trace ID. You can log on to the ARMS console and obtain the trace ID on the **Trace Query** page or **Interface Snapshot** tab.
	TraceID *string `json:"TraceID,omitempty" xml:"TraceID,omitempty"`
}

func (s GetTraceRequest) String() string {
	return tea.Prettify(s)
}

func (s GetTraceRequest) GoString() string {
	return s.String()
}

func (s *GetTraceRequest) SetEndTime(v int64) *GetTraceRequest {
	s.EndTime = &v
	return s
}

func (s *GetTraceRequest) SetRegionId(v string) *GetTraceRequest {
	s.RegionId = &v
	return s
}

func (s *GetTraceRequest) SetStartTime(v int64) *GetTraceRequest {
	s.StartTime = &v
	return s
}

func (s *GetTraceRequest) SetTraceID(v string) *GetTraceRequest {
	s.TraceID = &v
	return s
}

type GetTraceResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details of the trace.
	Spans []*GetTraceResponseBodySpans `json:"Spans,omitempty" xml:"Spans,omitempty" type:"Repeated"`
}

func (s GetTraceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetTraceResponseBody) GoString() string {
	return s.String()
}

func (s *GetTraceResponseBody) SetRequestId(v string) *GetTraceResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetTraceResponseBody) SetSpans(v []*GetTraceResponseBodySpans) *GetTraceResponseBody {
	s.Spans = v
	return s
}

type GetTraceResponseBodySpans struct {
	// The child spans of the current span.
	Children []map[string]interface{} `json:"Children,omitempty" xml:"Children,omitempty" type:"Repeated"`
	// The amount of time consumed by the trace. Unit: milliseconds.
	Duration *int64 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// Indicates whether a method stack was provided.
	//
	// *   `true`: A method stack was provided.
	// *   `false`: No method stack was provided.
	HaveStack *bool `json:"HaveStack,omitempty" xml:"HaveStack,omitempty"`
	// The log events in the trace.
	LogEventList []*GetTraceResponseBodySpansLogEventList `json:"LogEventList,omitempty" xml:"LogEventList,omitempty" type:"Repeated"`
	// The name of the traced span.
	OperationName *string `json:"OperationName,omitempty" xml:"OperationName,omitempty"`
	// The ID of the parent span.
	ParentSpanId *string `json:"ParentSpanId,omitempty" xml:"ParentSpanId,omitempty"`
	// The status code.
	ResultCode *string `json:"ResultCode,omitempty" xml:"ResultCode,omitempty"`
	// The ID of the RPC mode.
	RpcId *string `json:"RpcId,omitempty" xml:"RpcId,omitempty"`
	// The type of the remote procedure call (RPC) mode.
	//
	// - 0 http
	// - 25 http_client
	// - 1 hsf_client
	// - 2 hsf
	// - 40 local
	// - 41 async
	// - 52 DB2
	// - 53 Informix
	// - 54 SequoiaDB
	// - 55 Gbase
	// - 56 GaussDB
	// - 57 KingBase
	// - 58 infuxdb
	// - 59 clickhouse
	// - 60 mysql
	// - 61 mysql
	// - 62 oracle
	// - 63 postgresql
	// - 64 mongodb
	// - 65 ppas
	// - 66 sqlserver
	// - 67 mariadb
	// - 68 dmdb
	// - 69 oceanbase
	// - 70 redis
	// - 71 memcached
	// - 72 elasticsearch
	// - 73 kudu
	// - 4 tddl
	// - 5 tair
	// - 13 mq_client
	// - 252 mq
	// - 23 kafka_client
	// - 256 kafka
	// - 3 notify_client
	// - 254 notify
	// - 7 dubbo_client
	// - 8 dubbo
	// - 11 dsf_client
	// - 12 dsf
	// - 9 grpc
	// - 10 grpc_client
	// - 16 thrift
	// - 17 thrift_client
	// - 18 sofa
	// - 19 sofa_client
	// - -1 unknown
	// - 98 user_method
	// - 100 root
	// - 101 client
	// - 102 server
	// - 103 producer
	// - 104 consumer
	// - 105 db
	// - 106 xtrace_other
	// - 1301 schedulerx
	// - 1302 XXL_Job
	// - 1303 Spring_Scheduled
	// - 1304 Quartz
	// - 1305 ElasticJob
	// - 1308 Jdk_Timer
	RpcType *int32 `json:"RpcType,omitempty" xml:"RpcType,omitempty"`
	// The IP address of the host where the application resides.
	ServiceIp *string `json:"ServiceIp,omitempty" xml:"ServiceIp,omitempty"`
	// The name of the application.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The span ID.
	SpanId *string `json:"SpanId,omitempty" xml:"SpanId,omitempty"`
	// The tags of the trace.
	TagEntryList []*GetTraceResponseBodySpansTagEntryList `json:"TagEntryList,omitempty" xml:"TagEntryList,omitempty" type:"Repeated"`
	// The timestamp generated when the span was generated.
	Timestamp *int64 `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The trace ID.
	TraceID *string `json:"TraceID,omitempty" xml:"TraceID,omitempty"`
}

func (s GetTraceResponseBodySpans) String() string {
	return tea.Prettify(s)
}

func (s GetTraceResponseBodySpans) GoString() string {
	return s.String()
}

func (s *GetTraceResponseBodySpans) SetChildren(v []map[string]interface{}) *GetTraceResponseBodySpans {
	s.Children = v
	return s
}

func (s *GetTraceResponseBodySpans) SetDuration(v int64) *GetTraceResponseBodySpans {
	s.Duration = &v
	return s
}

func (s *GetTraceResponseBodySpans) SetHaveStack(v bool) *GetTraceResponseBodySpans {
	s.HaveStack = &v
	return s
}

func (s *GetTraceResponseBodySpans) SetLogEventList(v []*GetTraceResponseBodySpansLogEventList) *GetTraceResponseBodySpans {
	s.LogEventList = v
	return s
}

func (s *GetTraceResponseBodySpans) SetOperationName(v string) *GetTraceResponseBodySpans {
	s.OperationName = &v
	return s
}

func (s *GetTraceResponseBodySpans) SetParentSpanId(v string) *GetTraceResponseBodySpans {
	s.ParentSpanId = &v
	return s
}

func (s *GetTraceResponseBodySpans) SetResultCode(v string) *GetTraceResponseBodySpans {
	s.ResultCode = &v
	return s
}

func (s *GetTraceResponseBodySpans) SetRpcId(v string) *GetTraceResponseBodySpans {
	s.RpcId = &v
	return s
}

func (s *GetTraceResponseBodySpans) SetRpcType(v int32) *GetTraceResponseBodySpans {
	s.RpcType = &v
	return s
}

func (s *GetTraceResponseBodySpans) SetServiceIp(v string) *GetTraceResponseBodySpans {
	s.ServiceIp = &v
	return s
}

func (s *GetTraceResponseBodySpans) SetServiceName(v string) *GetTraceResponseBodySpans {
	s.ServiceName = &v
	return s
}

func (s *GetTraceResponseBodySpans) SetSpanId(v string) *GetTraceResponseBodySpans {
	s.SpanId = &v
	return s
}

func (s *GetTraceResponseBodySpans) SetTagEntryList(v []*GetTraceResponseBodySpansTagEntryList) *GetTraceResponseBodySpans {
	s.TagEntryList = v
	return s
}

func (s *GetTraceResponseBodySpans) SetTimestamp(v int64) *GetTraceResponseBodySpans {
	s.Timestamp = &v
	return s
}

func (s *GetTraceResponseBodySpans) SetTraceID(v string) *GetTraceResponseBodySpans {
	s.TraceID = &v
	return s
}

type GetTraceResponseBodySpansLogEventList struct {
	// The tags of the trace.
	TagEntryList []*GetTraceResponseBodySpansLogEventListTagEntryList `json:"TagEntryList,omitempty" xml:"TagEntryList,omitempty" type:"Repeated"`
	// The timestamp when the log event was generated.
	Timestamp *int64 `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
}

func (s GetTraceResponseBodySpansLogEventList) String() string {
	return tea.Prettify(s)
}

func (s GetTraceResponseBodySpansLogEventList) GoString() string {
	return s.String()
}

func (s *GetTraceResponseBodySpansLogEventList) SetTagEntryList(v []*GetTraceResponseBodySpansLogEventListTagEntryList) *GetTraceResponseBodySpansLogEventList {
	s.TagEntryList = v
	return s
}

func (s *GetTraceResponseBodySpansLogEventList) SetTimestamp(v int64) *GetTraceResponseBodySpansLogEventList {
	s.Timestamp = &v
	return s
}

type GetTraceResponseBodySpansLogEventListTagEntryList struct {
	// The key of the tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetTraceResponseBodySpansLogEventListTagEntryList) String() string {
	return tea.Prettify(s)
}

func (s GetTraceResponseBodySpansLogEventListTagEntryList) GoString() string {
	return s.String()
}

func (s *GetTraceResponseBodySpansLogEventListTagEntryList) SetKey(v string) *GetTraceResponseBodySpansLogEventListTagEntryList {
	s.Key = &v
	return s
}

func (s *GetTraceResponseBodySpansLogEventListTagEntryList) SetValue(v string) *GetTraceResponseBodySpansLogEventListTagEntryList {
	s.Value = &v
	return s
}

type GetTraceResponseBodySpansTagEntryList struct {
	// The key of the tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetTraceResponseBodySpansTagEntryList) String() string {
	return tea.Prettify(s)
}

func (s GetTraceResponseBodySpansTagEntryList) GoString() string {
	return s.String()
}

func (s *GetTraceResponseBodySpansTagEntryList) SetKey(v string) *GetTraceResponseBodySpansTagEntryList {
	s.Key = &v
	return s
}

func (s *GetTraceResponseBodySpansTagEntryList) SetValue(v string) *GetTraceResponseBodySpansTagEntryList {
	s.Value = &v
	return s
}

type GetTraceResponse struct {
	Headers    map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetTraceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetTraceResponse) String() string {
	return tea.Prettify(s)
}

func (s GetTraceResponse) GoString() string {
	return s.String()
}

func (s *GetTraceResponse) SetHeaders(v map[string]*string) *GetTraceResponse {
	s.Headers = v
	return s
}

func (s *GetTraceResponse) SetStatusCode(v int32) *GetTraceResponse {
	s.StatusCode = &v
	return s
}

func (s *GetTraceResponse) SetBody(v *GetTraceResponseBody) *GetTraceResponse {
	s.Body = v
	return s
}

type GetTraceAppRequest struct {
	// The process identifier (PID) of the application. For more information about how to obtain the PID, see [Obtain the PID of an application](https://www.alibabacloud.com/help/zh/doc-detail/186100.htm?spm=a2cdw.13409063.0.0.7a72281f0bkTfx#title-imy-7gj-qhr).
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The list of tags.
	Tags []*GetTraceAppRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s GetTraceAppRequest) String() string {
	return tea.Prettify(s)
}

func (s GetTraceAppRequest) GoString() string {
	return s.String()
}

func (s *GetTraceAppRequest) SetPid(v string) *GetTraceAppRequest {
	s.Pid = &v
	return s
}

func (s *GetTraceAppRequest) SetRegionId(v string) *GetTraceAppRequest {
	s.RegionId = &v
	return s
}

func (s *GetTraceAppRequest) SetTags(v []*GetTraceAppRequestTags) *GetTraceAppRequest {
	s.Tags = v
	return s
}

type GetTraceAppRequestTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetTraceAppRequestTags) String() string {
	return tea.Prettify(s)
}

func (s GetTraceAppRequestTags) GoString() string {
	return s.String()
}

func (s *GetTraceAppRequestTags) SetKey(v string) *GetTraceAppRequestTags {
	s.Key = &v
	return s
}

func (s *GetTraceAppRequestTags) SetValue(v string) *GetTraceAppRequestTags {
	s.Value = &v
	return s
}

type GetTraceAppResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the array object.
	TraceApp *GetTraceAppResponseBodyTraceApp `json:"TraceApp,omitempty" xml:"TraceApp,omitempty" type:"Struct"`
}

func (s GetTraceAppResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetTraceAppResponseBody) GoString() string {
	return s.String()
}

func (s *GetTraceAppResponseBody) SetRequestId(v string) *GetTraceAppResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetTraceAppResponseBody) SetTraceApp(v *GetTraceAppResponseBodyTraceApp) *GetTraceAppResponseBody {
	s.TraceApp = v
	return s
}

type GetTraceAppResponseBodyTraceApp struct {
	// The application ID.
	AppId *int64 `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The timestamp generated when the task was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The aliases of the application.
	Labels []*string `json:"Labels,omitempty" xml:"Labels,omitempty" type:"Repeated"`
	// The process identifier (PID) of the application.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Indicates whether the application is displayed in the Application Real-Time Monitoring Service (ARMS) console. Valid values:
	//
	// *   `true`: yes
	// *   `false`: no
	Show *bool `json:"Show,omitempty" xml:"Show,omitempty"`
	// The source of the application.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// A list of key-value pairs.
	Tags []*GetTraceAppResponseBodyTraceAppTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The type of the monitoring task. Valid values:
	//
	// *   `TRACE`: Application Monitoring
	// *   `RETCODE`: Browser Monitoring
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The timestamp generated when the task information was updated.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The user ID.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s GetTraceAppResponseBodyTraceApp) String() string {
	return tea.Prettify(s)
}

func (s GetTraceAppResponseBodyTraceApp) GoString() string {
	return s.String()
}

func (s *GetTraceAppResponseBodyTraceApp) SetAppId(v int64) *GetTraceAppResponseBodyTraceApp {
	s.AppId = &v
	return s
}

func (s *GetTraceAppResponseBodyTraceApp) SetAppName(v string) *GetTraceAppResponseBodyTraceApp {
	s.AppName = &v
	return s
}

func (s *GetTraceAppResponseBodyTraceApp) SetCreateTime(v int64) *GetTraceAppResponseBodyTraceApp {
	s.CreateTime = &v
	return s
}

func (s *GetTraceAppResponseBodyTraceApp) SetLabels(v []*string) *GetTraceAppResponseBodyTraceApp {
	s.Labels = v
	return s
}

func (s *GetTraceAppResponseBodyTraceApp) SetPid(v string) *GetTraceAppResponseBodyTraceApp {
	s.Pid = &v
	return s
}

func (s *GetTraceAppResponseBodyTraceApp) SetRegionId(v string) *GetTraceAppResponseBodyTraceApp {
	s.RegionId = &v
	return s
}

func (s *GetTraceAppResponseBodyTraceApp) SetResourceGroupId(v string) *GetTraceAppResponseBodyTraceApp {
	s.ResourceGroupId = &v
	return s
}

func (s *GetTraceAppResponseBodyTraceApp) SetShow(v bool) *GetTraceAppResponseBodyTraceApp {
	s.Show = &v
	return s
}

func (s *GetTraceAppResponseBodyTraceApp) SetSource(v string) *GetTraceAppResponseBodyTraceApp {
	s.Source = &v
	return s
}

func (s *GetTraceAppResponseBodyTraceApp) SetTags(v []*GetTraceAppResponseBodyTraceAppTags) *GetTraceAppResponseBodyTraceApp {
	s.Tags = v
	return s
}

func (s *GetTraceAppResponseBodyTraceApp) SetType(v string) *GetTraceAppResponseBodyTraceApp {
	s.Type = &v
	return s
}

func (s *GetTraceAppResponseBodyTraceApp) SetUpdateTime(v int64) *GetTraceAppResponseBodyTraceApp {
	s.UpdateTime = &v
	return s
}

func (s *GetTraceAppResponseBodyTraceApp) SetUserId(v string) *GetTraceAppResponseBodyTraceApp {
	s.UserId = &v
	return s
}

type GetTraceAppResponseBodyTraceAppTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetTraceAppResponseBodyTraceAppTags) String() string {
	return tea.Prettify(s)
}

func (s GetTraceAppResponseBodyTraceAppTags) GoString() string {
	return s.String()
}

func (s *GetTraceAppResponseBodyTraceAppTags) SetKey(v string) *GetTraceAppResponseBodyTraceAppTags {
	s.Key = &v
	return s
}

func (s *GetTraceAppResponseBodyTraceAppTags) SetValue(v string) *GetTraceAppResponseBodyTraceAppTags {
	s.Value = &v
	return s
}

type GetTraceAppResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetTraceAppResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetTraceAppResponse) String() string {
	return tea.Prettify(s)
}

func (s GetTraceAppResponse) GoString() string {
	return s.String()
}

func (s *GetTraceAppResponse) SetHeaders(v map[string]*string) *GetTraceAppResponse {
	s.Headers = v
	return s
}

func (s *GetTraceAppResponse) SetStatusCode(v int32) *GetTraceAppResponse {
	s.StatusCode = &v
	return s
}

func (s *GetTraceAppResponse) SetBody(v *GetTraceAppResponseBody) *GetTraceAppResponse {
	s.Body = v
	return s
}

type ImportAppAlertRulesRequest struct {
	// The IDs of the alert contact groups. The value must be a JSON array.
	ContactGroupIds *string `json:"ContactGroupIds,omitempty" xml:"ContactGroupIds,omitempty"`
	// Specifies whether to enable the alert rule after it is created. Default value: `false`.
	//
	// *   `true`: enables the alert rule.
	// *   `false`: disables the alert rule.
	IsAutoStart *bool `json:"IsAutoStart,omitempty" xml:"IsAutoStart,omitempty"`
	// The process identifiers (PIDs) of the applications associated with the alert rule. The value must be a JSON array. For more information about how to obtain the PID, see [Obtain the PID of an application](~~186100#section-bkl-3j6-ezg~~).
	Pids *string `json:"Pids,omitempty" xml:"Pids,omitempty"`
	// The ID of the region where the associated applications reside.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The list of tags.
	Tags []*ImportAppAlertRulesRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The configurations of the alert template based on which you want to create an alert rule. The value must be a JSON string. You must set at least one of the **TemplateAlertId** and **TemplageAlertConfig** parameters. If you set both parameters, the **TemplateAlertId** parameter prevails. For more information about the TemplageAlertConfig parameter, see the following **additional information about the TemplageAlertConfig parameter**.
	TemplageAlertConfig *string `json:"TemplageAlertConfig,omitempty" xml:"TemplageAlertConfig,omitempty"`
	// The ID of the alert template. You must set at least one of the **TemplateAlertId** and **TemplageAlertConfig** parameters. If you set both parameters, the **TemplateAlertId** parameter prevails.
	TemplateAlertId *string `json:"TemplateAlertId,omitempty" xml:"TemplateAlertId,omitempty"`
}

func (s ImportAppAlertRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s ImportAppAlertRulesRequest) GoString() string {
	return s.String()
}

func (s *ImportAppAlertRulesRequest) SetContactGroupIds(v string) *ImportAppAlertRulesRequest {
	s.ContactGroupIds = &v
	return s
}

func (s *ImportAppAlertRulesRequest) SetIsAutoStart(v bool) *ImportAppAlertRulesRequest {
	s.IsAutoStart = &v
	return s
}

func (s *ImportAppAlertRulesRequest) SetPids(v string) *ImportAppAlertRulesRequest {
	s.Pids = &v
	return s
}

func (s *ImportAppAlertRulesRequest) SetRegionId(v string) *ImportAppAlertRulesRequest {
	s.RegionId = &v
	return s
}

func (s *ImportAppAlertRulesRequest) SetTags(v []*ImportAppAlertRulesRequestTags) *ImportAppAlertRulesRequest {
	s.Tags = v
	return s
}

func (s *ImportAppAlertRulesRequest) SetTemplageAlertConfig(v string) *ImportAppAlertRulesRequest {
	s.TemplageAlertConfig = &v
	return s
}

func (s *ImportAppAlertRulesRequest) SetTemplateAlertId(v string) *ImportAppAlertRulesRequest {
	s.TemplateAlertId = &v
	return s
}

type ImportAppAlertRulesRequestTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ImportAppAlertRulesRequestTags) String() string {
	return tea.Prettify(s)
}

func (s ImportAppAlertRulesRequestTags) GoString() string {
	return s.String()
}

func (s *ImportAppAlertRulesRequestTags) SetKey(v string) *ImportAppAlertRulesRequestTags {
	s.Key = &v
	return s
}

func (s *ImportAppAlertRulesRequestTags) SetValue(v string) *ImportAppAlertRulesRequestTags {
	s.Value = &v
	return s
}

type ImportAppAlertRulesResponseBody struct {
	// The ID of the alert rule.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ImportAppAlertRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ImportAppAlertRulesResponseBody) GoString() string {
	return s.String()
}

func (s *ImportAppAlertRulesResponseBody) SetData(v string) *ImportAppAlertRulesResponseBody {
	s.Data = &v
	return s
}

func (s *ImportAppAlertRulesResponseBody) SetRequestId(v string) *ImportAppAlertRulesResponseBody {
	s.RequestId = &v
	return s
}

type ImportAppAlertRulesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ImportAppAlertRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ImportAppAlertRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s ImportAppAlertRulesResponse) GoString() string {
	return s.String()
}

func (s *ImportAppAlertRulesResponse) SetHeaders(v map[string]*string) *ImportAppAlertRulesResponse {
	s.Headers = v
	return s
}

func (s *ImportAppAlertRulesResponse) SetStatusCode(v int32) *ImportAppAlertRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *ImportAppAlertRulesResponse) SetBody(v *ImportAppAlertRulesResponseBody) *ImportAppAlertRulesResponse {
	s.Body = v
	return s
}

type InitEnvironmentRequest struct {
	// The language. Valid values: zh and en. Default value: zh.
	AliyunLang *string `json:"AliyunLang,omitempty" xml:"AliyunLang,omitempty"`
	// The ID of the environment instance.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// type of managed:
	//
	// - none: not managed. default value of prometheus for ACK.
	// - agent: managed agent. default value of promehtues for ASK/ACS/AckOne.
	// - agent-exproter: maanged agent and exporter. default of prometheus for Cloud.
	ManagedType *string `json:"ManagedType,omitempty" xml:"ManagedType,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s InitEnvironmentRequest) String() string {
	return tea.Prettify(s)
}

func (s InitEnvironmentRequest) GoString() string {
	return s.String()
}

func (s *InitEnvironmentRequest) SetAliyunLang(v string) *InitEnvironmentRequest {
	s.AliyunLang = &v
	return s
}

func (s *InitEnvironmentRequest) SetEnvironmentId(v string) *InitEnvironmentRequest {
	s.EnvironmentId = &v
	return s
}

func (s *InitEnvironmentRequest) SetManagedType(v string) *InitEnvironmentRequest {
	s.ManagedType = &v
	return s
}

func (s *InitEnvironmentRequest) SetRegionId(v string) *InitEnvironmentRequest {
	s.RegionId = &v
	return s
}

type InitEnvironmentResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result of the operation.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s InitEnvironmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InitEnvironmentResponseBody) GoString() string {
	return s.String()
}

func (s *InitEnvironmentResponseBody) SetCode(v int32) *InitEnvironmentResponseBody {
	s.Code = &v
	return s
}

func (s *InitEnvironmentResponseBody) SetData(v string) *InitEnvironmentResponseBody {
	s.Data = &v
	return s
}

func (s *InitEnvironmentResponseBody) SetMessage(v string) *InitEnvironmentResponseBody {
	s.Message = &v
	return s
}

func (s *InitEnvironmentResponseBody) SetRequestId(v string) *InitEnvironmentResponseBody {
	s.RequestId = &v
	return s
}

type InitEnvironmentResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *InitEnvironmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s InitEnvironmentResponse) String() string {
	return tea.Prettify(s)
}

func (s InitEnvironmentResponse) GoString() string {
	return s.String()
}

func (s *InitEnvironmentResponse) SetHeaders(v map[string]*string) *InitEnvironmentResponse {
	s.Headers = v
	return s
}

func (s *InitEnvironmentResponse) SetStatusCode(v int32) *InitEnvironmentResponse {
	s.StatusCode = &v
	return s
}

func (s *InitEnvironmentResponse) SetBody(v *InitEnvironmentResponseBody) *InitEnvironmentResponse {
	s.Body = v
	return s
}

type InstallAddonRequest struct {
	// Version of Addon.
	AddonVersion *string `json:"AddonVersion,omitempty" xml:"AddonVersion,omitempty"`
	// Locale, the default is Chinese zh.
	AliyunLang *string `json:"AliyunLang,omitempty" xml:"AliyunLang,omitempty"`
	// Whether to test run. The default value is false.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// Environment ID.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// Name of Addon.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The release name after installation, if not specified, generates the default rule name.
	ReleaseName *string `json:"ReleaseName,omitempty" xml:"ReleaseName,omitempty"`
	// Config information.
	Values *string `json:"Values,omitempty" xml:"Values,omitempty"`
}

func (s InstallAddonRequest) String() string {
	return tea.Prettify(s)
}

func (s InstallAddonRequest) GoString() string {
	return s.String()
}

func (s *InstallAddonRequest) SetAddonVersion(v string) *InstallAddonRequest {
	s.AddonVersion = &v
	return s
}

func (s *InstallAddonRequest) SetAliyunLang(v string) *InstallAddonRequest {
	s.AliyunLang = &v
	return s
}

func (s *InstallAddonRequest) SetDryRun(v bool) *InstallAddonRequest {
	s.DryRun = &v
	return s
}

func (s *InstallAddonRequest) SetEnvironmentId(v string) *InstallAddonRequest {
	s.EnvironmentId = &v
	return s
}

func (s *InstallAddonRequest) SetName(v string) *InstallAddonRequest {
	s.Name = &v
	return s
}

func (s *InstallAddonRequest) SetRegionId(v string) *InstallAddonRequest {
	s.RegionId = &v
	return s
}

func (s *InstallAddonRequest) SetReleaseName(v string) *InstallAddonRequest {
	s.ReleaseName = &v
	return s
}

func (s *InstallAddonRequest) SetValues(v string) *InstallAddonRequest {
	s.Values = &v
	return s
}

type InstallAddonResponseBody struct {
	// Status code: 200 indicates success.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned struct.
	Data *InstallAddonResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   `true`: The call was successful.
	// *   `false`: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s InstallAddonResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InstallAddonResponseBody) GoString() string {
	return s.String()
}

func (s *InstallAddonResponseBody) SetCode(v int32) *InstallAddonResponseBody {
	s.Code = &v
	return s
}

func (s *InstallAddonResponseBody) SetData(v *InstallAddonResponseBodyData) *InstallAddonResponseBody {
	s.Data = v
	return s
}

func (s *InstallAddonResponseBody) SetMessage(v string) *InstallAddonResponseBody {
	s.Message = &v
	return s
}

func (s *InstallAddonResponseBody) SetRequestId(v string) *InstallAddonResponseBody {
	s.RequestId = &v
	return s
}

func (s *InstallAddonResponseBody) SetSuccess(v bool) *InstallAddonResponseBody {
	s.Success = &v
	return s
}

type InstallAddonResponseBodyData struct {
	// Addon name.
	AddonName *string `json:"AddonName,omitempty" xml:"AddonName,omitempty"`
	// Number of alarm groups.
	AlertRuleCount *int64 `json:"AlertRuleCount,omitempty" xml:"AlertRuleCount,omitempty"`
	// Condition list.
	Conditions []*InstallAddonResponseBodyDataConditions `json:"Conditions,omitempty" xml:"Conditions,omitempty" type:"Repeated"`
	// Created time.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// Number of dashboard.
	DashboardCount *int64 `json:"DashboardCount,omitempty" xml:"DashboardCount,omitempty"`
	// Environment ID.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// Number of Exporter.
	ExporterCount *int64 `json:"ExporterCount,omitempty" xml:"ExporterCount,omitempty"`
	// Whether there is configuration.
	HaveConfig *bool `json:"HaveConfig,omitempty" xml:"HaveConfig,omitempty"`
	// User ID of the installation.
	InstallUserId *string `json:"InstallUserId,omitempty" xml:"InstallUserId,omitempty"`
	// Language.
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Release ID.
	ReleaseId *string `json:"ReleaseId,omitempty" xml:"ReleaseId,omitempty"`
	// Name of Release.
	ReleaseName *string `json:"ReleaseName,omitempty" xml:"ReleaseName,omitempty"`
	// Scene.
	Scene *string `json:"Scene,omitempty" xml:"Scene,omitempty"`
	// Status of Release.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// Update time.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// User ID.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The version number.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s InstallAddonResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s InstallAddonResponseBodyData) GoString() string {
	return s.String()
}

func (s *InstallAddonResponseBodyData) SetAddonName(v string) *InstallAddonResponseBodyData {
	s.AddonName = &v
	return s
}

func (s *InstallAddonResponseBodyData) SetAlertRuleCount(v int64) *InstallAddonResponseBodyData {
	s.AlertRuleCount = &v
	return s
}

func (s *InstallAddonResponseBodyData) SetConditions(v []*InstallAddonResponseBodyDataConditions) *InstallAddonResponseBodyData {
	s.Conditions = v
	return s
}

func (s *InstallAddonResponseBodyData) SetCreateTime(v string) *InstallAddonResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *InstallAddonResponseBodyData) SetDashboardCount(v int64) *InstallAddonResponseBodyData {
	s.DashboardCount = &v
	return s
}

func (s *InstallAddonResponseBodyData) SetEnvironmentId(v string) *InstallAddonResponseBodyData {
	s.EnvironmentId = &v
	return s
}

func (s *InstallAddonResponseBodyData) SetExporterCount(v int64) *InstallAddonResponseBodyData {
	s.ExporterCount = &v
	return s
}

func (s *InstallAddonResponseBodyData) SetHaveConfig(v bool) *InstallAddonResponseBodyData {
	s.HaveConfig = &v
	return s
}

func (s *InstallAddonResponseBodyData) SetInstallUserId(v string) *InstallAddonResponseBodyData {
	s.InstallUserId = &v
	return s
}

func (s *InstallAddonResponseBodyData) SetLanguage(v string) *InstallAddonResponseBodyData {
	s.Language = &v
	return s
}

func (s *InstallAddonResponseBodyData) SetRegionId(v string) *InstallAddonResponseBodyData {
	s.RegionId = &v
	return s
}

func (s *InstallAddonResponseBodyData) SetReleaseId(v string) *InstallAddonResponseBodyData {
	s.ReleaseId = &v
	return s
}

func (s *InstallAddonResponseBodyData) SetReleaseName(v string) *InstallAddonResponseBodyData {
	s.ReleaseName = &v
	return s
}

func (s *InstallAddonResponseBodyData) SetScene(v string) *InstallAddonResponseBodyData {
	s.Scene = &v
	return s
}

func (s *InstallAddonResponseBodyData) SetStatus(v string) *InstallAddonResponseBodyData {
	s.Status = &v
	return s
}

func (s *InstallAddonResponseBodyData) SetUpdateTime(v string) *InstallAddonResponseBodyData {
	s.UpdateTime = &v
	return s
}

func (s *InstallAddonResponseBodyData) SetUserId(v string) *InstallAddonResponseBodyData {
	s.UserId = &v
	return s
}

func (s *InstallAddonResponseBodyData) SetVersion(v string) *InstallAddonResponseBodyData {
	s.Version = &v
	return s
}

type InstallAddonResponseBodyDataConditions struct {
	// First transition time.
	FirstTransitionTime *string `json:"FirstTransitionTime,omitempty" xml:"FirstTransitionTime,omitempty"`
	// Last transition time.
	LastTransitionTime *string `json:"LastTransitionTime,omitempty" xml:"LastTransitionTime,omitempty"`
	// Details.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Reason of failure.
	Reason *string `json:"Reason,omitempty" xml:"Reason,omitempty"`
	// Condition status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// Condition type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s InstallAddonResponseBodyDataConditions) String() string {
	return tea.Prettify(s)
}

func (s InstallAddonResponseBodyDataConditions) GoString() string {
	return s.String()
}

func (s *InstallAddonResponseBodyDataConditions) SetFirstTransitionTime(v string) *InstallAddonResponseBodyDataConditions {
	s.FirstTransitionTime = &v
	return s
}

func (s *InstallAddonResponseBodyDataConditions) SetLastTransitionTime(v string) *InstallAddonResponseBodyDataConditions {
	s.LastTransitionTime = &v
	return s
}

func (s *InstallAddonResponseBodyDataConditions) SetMessage(v string) *InstallAddonResponseBodyDataConditions {
	s.Message = &v
	return s
}

func (s *InstallAddonResponseBodyDataConditions) SetReason(v string) *InstallAddonResponseBodyDataConditions {
	s.Reason = &v
	return s
}

func (s *InstallAddonResponseBodyDataConditions) SetStatus(v string) *InstallAddonResponseBodyDataConditions {
	s.Status = &v
	return s
}

func (s *InstallAddonResponseBodyDataConditions) SetType(v string) *InstallAddonResponseBodyDataConditions {
	s.Type = &v
	return s
}

type InstallAddonResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *InstallAddonResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s InstallAddonResponse) String() string {
	return tea.Prettify(s)
}

func (s InstallAddonResponse) GoString() string {
	return s.String()
}

func (s *InstallAddonResponse) SetHeaders(v map[string]*string) *InstallAddonResponse {
	s.Headers = v
	return s
}

func (s *InstallAddonResponse) SetStatusCode(v int32) *InstallAddonResponse {
	s.StatusCode = &v
	return s
}

func (s *InstallAddonResponse) SetBody(v *InstallAddonResponseBody) *InstallAddonResponse {
	s.Body = v
	return s
}

type InstallCmsExporterRequest struct {
	ClusterId  *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	CmsArgs    *string `json:"CmsArgs,omitempty" xml:"CmsArgs,omitempty"`
	DirectArgs *string `json:"DirectArgs,omitempty" xml:"DirectArgs,omitempty"`
	EnableTag  *bool   `json:"EnableTag,omitempty" xml:"EnableTag,omitempty"`
	RegionId   *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s InstallCmsExporterRequest) String() string {
	return tea.Prettify(s)
}

func (s InstallCmsExporterRequest) GoString() string {
	return s.String()
}

func (s *InstallCmsExporterRequest) SetClusterId(v string) *InstallCmsExporterRequest {
	s.ClusterId = &v
	return s
}

func (s *InstallCmsExporterRequest) SetCmsArgs(v string) *InstallCmsExporterRequest {
	s.CmsArgs = &v
	return s
}

func (s *InstallCmsExporterRequest) SetDirectArgs(v string) *InstallCmsExporterRequest {
	s.DirectArgs = &v
	return s
}

func (s *InstallCmsExporterRequest) SetEnableTag(v bool) *InstallCmsExporterRequest {
	s.EnableTag = &v
	return s
}

func (s *InstallCmsExporterRequest) SetRegionId(v string) *InstallCmsExporterRequest {
	s.RegionId = &v
	return s
}

type InstallCmsExporterResponseBody struct {
	Data      *string `json:"Data,omitempty" xml:"Data,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s InstallCmsExporterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InstallCmsExporterResponseBody) GoString() string {
	return s.String()
}

func (s *InstallCmsExporterResponseBody) SetData(v string) *InstallCmsExporterResponseBody {
	s.Data = &v
	return s
}

func (s *InstallCmsExporterResponseBody) SetRequestId(v string) *InstallCmsExporterResponseBody {
	s.RequestId = &v
	return s
}

type InstallCmsExporterResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *InstallCmsExporterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s InstallCmsExporterResponse) String() string {
	return tea.Prettify(s)
}

func (s InstallCmsExporterResponse) GoString() string {
	return s.String()
}

func (s *InstallCmsExporterResponse) SetHeaders(v map[string]*string) *InstallCmsExporterResponse {
	s.Headers = v
	return s
}

func (s *InstallCmsExporterResponse) SetStatusCode(v int32) *InstallCmsExporterResponse {
	s.StatusCode = &v
	return s
}

func (s *InstallCmsExporterResponse) SetBody(v *InstallCmsExporterResponseBody) *InstallCmsExporterResponse {
	s.Body = v
	return s
}

type InstallEnvironmentFeatureRequest struct {
	// The language. Valid values: zh and en. Default value: zh.
	AliyunLang *string `json:"AliyunLang,omitempty" xml:"AliyunLang,omitempty"`
	// The metadata of the feature.
	Config *string `json:"Config,omitempty" xml:"Config,omitempty"`
	// The environment ID.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The name of the feature.
	//
	// Valid values:
	//
	// *   app-agent-pilot
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   metric-agent
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	FeatureName *string `json:"FeatureName,omitempty" xml:"FeatureName,omitempty"`
	// The version of the feature.
	FeatureVersion *string `json:"FeatureVersion,omitempty" xml:"FeatureVersion,omitempty"`
	// The region ID of the feature.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s InstallEnvironmentFeatureRequest) String() string {
	return tea.Prettify(s)
}

func (s InstallEnvironmentFeatureRequest) GoString() string {
	return s.String()
}

func (s *InstallEnvironmentFeatureRequest) SetAliyunLang(v string) *InstallEnvironmentFeatureRequest {
	s.AliyunLang = &v
	return s
}

func (s *InstallEnvironmentFeatureRequest) SetConfig(v string) *InstallEnvironmentFeatureRequest {
	s.Config = &v
	return s
}

func (s *InstallEnvironmentFeatureRequest) SetEnvironmentId(v string) *InstallEnvironmentFeatureRequest {
	s.EnvironmentId = &v
	return s
}

func (s *InstallEnvironmentFeatureRequest) SetFeatureName(v string) *InstallEnvironmentFeatureRequest {
	s.FeatureName = &v
	return s
}

func (s *InstallEnvironmentFeatureRequest) SetFeatureVersion(v string) *InstallEnvironmentFeatureRequest {
	s.FeatureVersion = &v
	return s
}

func (s *InstallEnvironmentFeatureRequest) SetRegion(v string) *InstallEnvironmentFeatureRequest {
	s.Region = &v
	return s
}

func (s *InstallEnvironmentFeatureRequest) SetRegionId(v string) *InstallEnvironmentFeatureRequest {
	s.RegionId = &v
	return s
}

type InstallEnvironmentFeatureResponseBody struct {
	// The HTTP status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The release ID.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true
	// *   false
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s InstallEnvironmentFeatureResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InstallEnvironmentFeatureResponseBody) GoString() string {
	return s.String()
}

func (s *InstallEnvironmentFeatureResponseBody) SetCode(v int32) *InstallEnvironmentFeatureResponseBody {
	s.Code = &v
	return s
}

func (s *InstallEnvironmentFeatureResponseBody) SetData(v string) *InstallEnvironmentFeatureResponseBody {
	s.Data = &v
	return s
}

func (s *InstallEnvironmentFeatureResponseBody) SetMessage(v string) *InstallEnvironmentFeatureResponseBody {
	s.Message = &v
	return s
}

func (s *InstallEnvironmentFeatureResponseBody) SetRequestId(v string) *InstallEnvironmentFeatureResponseBody {
	s.RequestId = &v
	return s
}

func (s *InstallEnvironmentFeatureResponseBody) SetSuccess(v bool) *InstallEnvironmentFeatureResponseBody {
	s.Success = &v
	return s
}

type InstallEnvironmentFeatureResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *InstallEnvironmentFeatureResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s InstallEnvironmentFeatureResponse) String() string {
	return tea.Prettify(s)
}

func (s InstallEnvironmentFeatureResponse) GoString() string {
	return s.String()
}

func (s *InstallEnvironmentFeatureResponse) SetHeaders(v map[string]*string) *InstallEnvironmentFeatureResponse {
	s.Headers = v
	return s
}

func (s *InstallEnvironmentFeatureResponse) SetStatusCode(v int32) *InstallEnvironmentFeatureResponse {
	s.StatusCode = &v
	return s
}

func (s *InstallEnvironmentFeatureResponse) SetBody(v *InstallEnvironmentFeatureResponseBody) *InstallEnvironmentFeatureResponse {
	s.Body = v
	return s
}

type InstallManagedPrometheusRequest struct {
	// The ID of the ACK cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the ECS instance. If you set the ClusterType parameter to ecs, you must configure this parameter.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The cluster type.
	//
	// Valid values:
	//
	// *   ecs
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   one
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   ask
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   pro
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The ID of the Grafana workspace used by the ASK cluster or ECS instance. If you set the value to free or leave the parameter empty, a shared Grafana workspace is used.
	GrafanaInstanceId *string `json:"GrafanaInstanceId,omitempty" xml:"GrafanaInstanceId,omitempty"`
	// This parameter is not supported.
	KubeConfig *string `json:"KubeConfig,omitempty" xml:"KubeConfig,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the Prometheus instance belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The security group of the ASK cluster or ECS instance.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// The vSwitch used by the ASK cluster or ECS instance.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The virtual private cloud (VPC) where the ASK cluster or ECS instance resides.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s InstallManagedPrometheusRequest) String() string {
	return tea.Prettify(s)
}

func (s InstallManagedPrometheusRequest) GoString() string {
	return s.String()
}

func (s *InstallManagedPrometheusRequest) SetClusterId(v string) *InstallManagedPrometheusRequest {
	s.ClusterId = &v
	return s
}

func (s *InstallManagedPrometheusRequest) SetClusterName(v string) *InstallManagedPrometheusRequest {
	s.ClusterName = &v
	return s
}

func (s *InstallManagedPrometheusRequest) SetClusterType(v string) *InstallManagedPrometheusRequest {
	s.ClusterType = &v
	return s
}

func (s *InstallManagedPrometheusRequest) SetGrafanaInstanceId(v string) *InstallManagedPrometheusRequest {
	s.GrafanaInstanceId = &v
	return s
}

func (s *InstallManagedPrometheusRequest) SetKubeConfig(v string) *InstallManagedPrometheusRequest {
	s.KubeConfig = &v
	return s
}

func (s *InstallManagedPrometheusRequest) SetRegionId(v string) *InstallManagedPrometheusRequest {
	s.RegionId = &v
	return s
}

func (s *InstallManagedPrometheusRequest) SetResourceGroupId(v string) *InstallManagedPrometheusRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *InstallManagedPrometheusRequest) SetSecurityGroupId(v string) *InstallManagedPrometheusRequest {
	s.SecurityGroupId = &v
	return s
}

func (s *InstallManagedPrometheusRequest) SetVSwitchId(v string) *InstallManagedPrometheusRequest {
	s.VSwitchId = &v
	return s
}

func (s *InstallManagedPrometheusRequest) SetVpcId(v string) *InstallManagedPrometheusRequest {
	s.VpcId = &v
	return s
}

type InstallManagedPrometheusResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The response content. The status of the Prometheus instance is returned.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error message returned if the Prometheus instance fails to be created.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the Prometheus instance was created.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s InstallManagedPrometheusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InstallManagedPrometheusResponseBody) GoString() string {
	return s.String()
}

func (s *InstallManagedPrometheusResponseBody) SetCode(v int32) *InstallManagedPrometheusResponseBody {
	s.Code = &v
	return s
}

func (s *InstallManagedPrometheusResponseBody) SetData(v string) *InstallManagedPrometheusResponseBody {
	s.Data = &v
	return s
}

func (s *InstallManagedPrometheusResponseBody) SetMessage(v string) *InstallManagedPrometheusResponseBody {
	s.Message = &v
	return s
}

func (s *InstallManagedPrometheusResponseBody) SetRequestId(v string) *InstallManagedPrometheusResponseBody {
	s.RequestId = &v
	return s
}

func (s *InstallManagedPrometheusResponseBody) SetSuccess(v bool) *InstallManagedPrometheusResponseBody {
	s.Success = &v
	return s
}

type InstallManagedPrometheusResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *InstallManagedPrometheusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s InstallManagedPrometheusResponse) String() string {
	return tea.Prettify(s)
}

func (s InstallManagedPrometheusResponse) GoString() string {
	return s.String()
}

func (s *InstallManagedPrometheusResponse) SetHeaders(v map[string]*string) *InstallManagedPrometheusResponse {
	s.Headers = v
	return s
}

func (s *InstallManagedPrometheusResponse) SetStatusCode(v int32) *InstallManagedPrometheusResponse {
	s.StatusCode = &v
	return s
}

func (s *InstallManagedPrometheusResponse) SetBody(v *InstallManagedPrometheusResponseBody) *InstallManagedPrometheusResponse {
	s.Body = v
	return s
}

type ListActivatedAlertsRequest struct {
	// The number of the page to return. Default value: `1`.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The filter condition in the `{"key":"value"}`format. You must specify the `key` and `value` of the filter condition.
	Filter *string `json:"Filter,omitempty" xml:"Filter,omitempty"`
	// The number of entries to return on each page. Default value: `10`.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListActivatedAlertsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListActivatedAlertsRequest) GoString() string {
	return s.String()
}

func (s *ListActivatedAlertsRequest) SetCurrentPage(v int32) *ListActivatedAlertsRequest {
	s.CurrentPage = &v
	return s
}

func (s *ListActivatedAlertsRequest) SetFilter(v string) *ListActivatedAlertsRequest {
	s.Filter = &v
	return s
}

func (s *ListActivatedAlertsRequest) SetPageSize(v int32) *ListActivatedAlertsRequest {
	s.PageSize = &v
	return s
}

func (s *ListActivatedAlertsRequest) SetRegionId(v string) *ListActivatedAlertsRequest {
	s.RegionId = &v
	return s
}

type ListActivatedAlertsResponseBody struct {
	// The struct returned.
	Page *ListActivatedAlertsResponseBodyPage `json:"Page,omitempty" xml:"Page,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListActivatedAlertsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListActivatedAlertsResponseBody) GoString() string {
	return s.String()
}

func (s *ListActivatedAlertsResponseBody) SetPage(v *ListActivatedAlertsResponseBodyPage) *ListActivatedAlertsResponseBody {
	s.Page = v
	return s
}

func (s *ListActivatedAlertsResponseBody) SetRequestId(v string) *ListActivatedAlertsResponseBody {
	s.RequestId = &v
	return s
}

type ListActivatedAlertsResponseBodyPage struct {
	// The alerts that have been triggered.
	Alerts []*ListActivatedAlertsResponseBodyPageAlerts `json:"Alerts,omitempty" xml:"Alerts,omitempty" type:"Repeated"`
	// The page number of the returned page.
	Page *int32 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListActivatedAlertsResponseBodyPage) String() string {
	return tea.Prettify(s)
}

func (s ListActivatedAlertsResponseBodyPage) GoString() string {
	return s.String()
}

func (s *ListActivatedAlertsResponseBodyPage) SetAlerts(v []*ListActivatedAlertsResponseBodyPageAlerts) *ListActivatedAlertsResponseBodyPage {
	s.Alerts = v
	return s
}

func (s *ListActivatedAlertsResponseBodyPage) SetPage(v int32) *ListActivatedAlertsResponseBodyPage {
	s.Page = &v
	return s
}

func (s *ListActivatedAlertsResponseBodyPage) SetPageSize(v int32) *ListActivatedAlertsResponseBodyPage {
	s.PageSize = &v
	return s
}

func (s *ListActivatedAlertsResponseBodyPage) SetTotal(v int32) *ListActivatedAlertsResponseBodyPage {
	s.Total = &v
	return s
}

type ListActivatedAlertsResponseBodyPageAlerts struct {
	// The ID of the alert rule.
	AlertId *string `json:"AlertId,omitempty" xml:"AlertId,omitempty"`
	// The name of the alert rule.
	AlertName *string `json:"AlertName,omitempty" xml:"AlertName,omitempty"`
	// The type of the alert.
	AlertType *string `json:"AlertType,omitempty" xml:"AlertType,omitempty"`
	// The number of times that the alert event was received.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The timestamp when the alert rule was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The notification policies.
	DispatchRules []*ListActivatedAlertsResponseBodyPageAlertsDispatchRules `json:"DispatchRules,omitempty" xml:"DispatchRules,omitempty" type:"Repeated"`
	// The timestamp when the alert was ended.
	EndsAt *int64 `json:"EndsAt,omitempty" xml:"EndsAt,omitempty"`
	// The extended fields that indicate the following tags:
	//
	// *   The tags that are carried in the metrics of the alert rule expression.
	// *   The tags that are created based on the alert rule.
	// *   The default tags of Application Real-Time Monitoring Service (ARMS).
	ExpandFields map[string]interface{} `json:"ExpandFields,omitempty" xml:"ExpandFields,omitempty"`
	// The name of the object that is associated with the alert.
	IntegrationName *string `json:"IntegrationName,omitempty" xml:"IntegrationName,omitempty"`
	// The type of the service integration that generated the alert.
	IntegrationType *string `json:"IntegrationType,omitempty" xml:"IntegrationType,omitempty"`
	// The type of the object that is associated with the alert.
	InvolvedObjectKind *string `json:"InvolvedObjectKind,omitempty" xml:"InvolvedObjectKind,omitempty"`
	// The name of the service integration that generated the alert.
	InvolvedObjectName *string `json:"InvolvedObjectName,omitempty" xml:"InvolvedObjectName,omitempty"`
	// The description of the alert.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The level of the alert. Valid values:
	//
	// *   `critical`
	// *   `error`
	// *   `warn`
	// *   `page`
	Severity *string `json:"Severity,omitempty" xml:"Severity,omitempty"`
	// The timestamp when the alert was generated.
	StartsAt *int64 `json:"StartsAt,omitempty" xml:"StartsAt,omitempty"`
	// The status of the alert. Valid values:
	//
	// *   `Active`
	// *   `Inhibited`
	// *   `Silenced`
	// *   `Resolved`
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListActivatedAlertsResponseBodyPageAlerts) String() string {
	return tea.Prettify(s)
}

func (s ListActivatedAlertsResponseBodyPageAlerts) GoString() string {
	return s.String()
}

func (s *ListActivatedAlertsResponseBodyPageAlerts) SetAlertId(v string) *ListActivatedAlertsResponseBodyPageAlerts {
	s.AlertId = &v
	return s
}

func (s *ListActivatedAlertsResponseBodyPageAlerts) SetAlertName(v string) *ListActivatedAlertsResponseBodyPageAlerts {
	s.AlertName = &v
	return s
}

func (s *ListActivatedAlertsResponseBodyPageAlerts) SetAlertType(v string) *ListActivatedAlertsResponseBodyPageAlerts {
	s.AlertType = &v
	return s
}

func (s *ListActivatedAlertsResponseBodyPageAlerts) SetCount(v int32) *ListActivatedAlertsResponseBodyPageAlerts {
	s.Count = &v
	return s
}

func (s *ListActivatedAlertsResponseBodyPageAlerts) SetCreateTime(v int64) *ListActivatedAlertsResponseBodyPageAlerts {
	s.CreateTime = &v
	return s
}

func (s *ListActivatedAlertsResponseBodyPageAlerts) SetDispatchRules(v []*ListActivatedAlertsResponseBodyPageAlertsDispatchRules) *ListActivatedAlertsResponseBodyPageAlerts {
	s.DispatchRules = v
	return s
}

func (s *ListActivatedAlertsResponseBodyPageAlerts) SetEndsAt(v int64) *ListActivatedAlertsResponseBodyPageAlerts {
	s.EndsAt = &v
	return s
}

func (s *ListActivatedAlertsResponseBodyPageAlerts) SetExpandFields(v map[string]interface{}) *ListActivatedAlertsResponseBodyPageAlerts {
	s.ExpandFields = v
	return s
}

func (s *ListActivatedAlertsResponseBodyPageAlerts) SetIntegrationName(v string) *ListActivatedAlertsResponseBodyPageAlerts {
	s.IntegrationName = &v
	return s
}

func (s *ListActivatedAlertsResponseBodyPageAlerts) SetIntegrationType(v string) *ListActivatedAlertsResponseBodyPageAlerts {
	s.IntegrationType = &v
	return s
}

func (s *ListActivatedAlertsResponseBodyPageAlerts) SetInvolvedObjectKind(v string) *ListActivatedAlertsResponseBodyPageAlerts {
	s.InvolvedObjectKind = &v
	return s
}

func (s *ListActivatedAlertsResponseBodyPageAlerts) SetInvolvedObjectName(v string) *ListActivatedAlertsResponseBodyPageAlerts {
	s.InvolvedObjectName = &v
	return s
}

func (s *ListActivatedAlertsResponseBodyPageAlerts) SetMessage(v string) *ListActivatedAlertsResponseBodyPageAlerts {
	s.Message = &v
	return s
}

func (s *ListActivatedAlertsResponseBodyPageAlerts) SetSeverity(v string) *ListActivatedAlertsResponseBodyPageAlerts {
	s.Severity = &v
	return s
}

func (s *ListActivatedAlertsResponseBodyPageAlerts) SetStartsAt(v int64) *ListActivatedAlertsResponseBodyPageAlerts {
	s.StartsAt = &v
	return s
}

func (s *ListActivatedAlertsResponseBodyPageAlerts) SetStatus(v string) *ListActivatedAlertsResponseBodyPageAlerts {
	s.Status = &v
	return s
}

type ListActivatedAlertsResponseBodyPageAlertsDispatchRules struct {
	// The ID of the notification policy.
	RuleId *int32 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The name of the notification policy.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
}

func (s ListActivatedAlertsResponseBodyPageAlertsDispatchRules) String() string {
	return tea.Prettify(s)
}

func (s ListActivatedAlertsResponseBodyPageAlertsDispatchRules) GoString() string {
	return s.String()
}

func (s *ListActivatedAlertsResponseBodyPageAlertsDispatchRules) SetRuleId(v int32) *ListActivatedAlertsResponseBodyPageAlertsDispatchRules {
	s.RuleId = &v
	return s
}

func (s *ListActivatedAlertsResponseBodyPageAlertsDispatchRules) SetRuleName(v string) *ListActivatedAlertsResponseBodyPageAlertsDispatchRules {
	s.RuleName = &v
	return s
}

type ListActivatedAlertsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListActivatedAlertsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListActivatedAlertsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListActivatedAlertsResponse) GoString() string {
	return s.String()
}

func (s *ListActivatedAlertsResponse) SetHeaders(v map[string]*string) *ListActivatedAlertsResponse {
	s.Headers = v
	return s
}

func (s *ListActivatedAlertsResponse) SetStatusCode(v int32) *ListActivatedAlertsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListActivatedAlertsResponse) SetBody(v *ListActivatedAlertsResponseBody) *ListActivatedAlertsResponse {
	s.Body = v
	return s
}

type ListAddonReleasesRequest struct {
	// Name of Addon.
	AddonName *string `json:"AddonName,omitempty" xml:"AddonName,omitempty"`
	// Environment instance ID.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListAddonReleasesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAddonReleasesRequest) GoString() string {
	return s.String()
}

func (s *ListAddonReleasesRequest) SetAddonName(v string) *ListAddonReleasesRequest {
	s.AddonName = &v
	return s
}

func (s *ListAddonReleasesRequest) SetEnvironmentId(v string) *ListAddonReleasesRequest {
	s.EnvironmentId = &v
	return s
}

func (s *ListAddonReleasesRequest) SetRegionId(v string) *ListAddonReleasesRequest {
	s.RegionId = &v
	return s
}

type ListAddonReleasesResponseBody struct {
	// Status code: 200 indicates success.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned struct.
	Data *ListAddonReleasesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListAddonReleasesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAddonReleasesResponseBody) GoString() string {
	return s.String()
}

func (s *ListAddonReleasesResponseBody) SetCode(v int32) *ListAddonReleasesResponseBody {
	s.Code = &v
	return s
}

func (s *ListAddonReleasesResponseBody) SetData(v *ListAddonReleasesResponseBodyData) *ListAddonReleasesResponseBody {
	s.Data = v
	return s
}

func (s *ListAddonReleasesResponseBody) SetMessage(v string) *ListAddonReleasesResponseBody {
	s.Message = &v
	return s
}

func (s *ListAddonReleasesResponseBody) SetRequestId(v string) *ListAddonReleasesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAddonReleasesResponseBody) SetSuccess(v bool) *ListAddonReleasesResponseBody {
	s.Success = &v
	return s
}

type ListAddonReleasesResponseBodyData struct {
	// Release list.
	Releases []*ListAddonReleasesResponseBodyDataReleases `json:"Releases,omitempty" xml:"Releases,omitempty" type:"Repeated"`
	// The total number of entries returned.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListAddonReleasesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListAddonReleasesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListAddonReleasesResponseBodyData) SetReleases(v []*ListAddonReleasesResponseBodyDataReleases) *ListAddonReleasesResponseBodyData {
	s.Releases = v
	return s
}

func (s *ListAddonReleasesResponseBodyData) SetTotal(v int64) *ListAddonReleasesResponseBodyData {
	s.Total = &v
	return s
}

type ListAddonReleasesResponseBodyDataReleases struct {
	// Name of Addon.
	AddonName *string `json:"AddonName,omitempty" xml:"AddonName,omitempty"`
	// Number of alarm groups.
	AlertRuleCount *int64 `json:"AlertRuleCount,omitempty" xml:"AlertRuleCount,omitempty"`
	// Condition list.
	Conditions []*ListAddonReleasesResponseBodyDataReleasesConditions `json:"Conditions,omitempty" xml:"Conditions,omitempty" type:"Repeated"`
	// Created time.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// Number of dashboard.
	DashboardCount *int64 `json:"DashboardCount,omitempty" xml:"DashboardCount,omitempty"`
	// Environment instance ID.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// Number of Exporter.
	ExporterCount *int64 `json:"ExporterCount,omitempty" xml:"ExporterCount,omitempty"`
	// Whether there is configuration.
	HaveConfig *bool `json:"HaveConfig,omitempty" xml:"HaveConfig,omitempty"`
	// User ID of the installation.
	InstallUserId *string `json:"InstallUserId,omitempty" xml:"InstallUserId,omitempty"`
	// Language.
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Release ID.
	ReleaseId *string `json:"ReleaseId,omitempty" xml:"ReleaseId,omitempty"`
	// Name of Release.
	ReleaseName *string `json:"ReleaseName,omitempty" xml:"ReleaseName,omitempty"`
	// Scene.
	Scene *string `json:"Scene,omitempty" xml:"Scene,omitempty"`
	// Status of Release.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// Update time.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// User ID.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// Version of Addon.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s ListAddonReleasesResponseBodyDataReleases) String() string {
	return tea.Prettify(s)
}

func (s ListAddonReleasesResponseBodyDataReleases) GoString() string {
	return s.String()
}

func (s *ListAddonReleasesResponseBodyDataReleases) SetAddonName(v string) *ListAddonReleasesResponseBodyDataReleases {
	s.AddonName = &v
	return s
}

func (s *ListAddonReleasesResponseBodyDataReleases) SetAlertRuleCount(v int64) *ListAddonReleasesResponseBodyDataReleases {
	s.AlertRuleCount = &v
	return s
}

func (s *ListAddonReleasesResponseBodyDataReleases) SetConditions(v []*ListAddonReleasesResponseBodyDataReleasesConditions) *ListAddonReleasesResponseBodyDataReleases {
	s.Conditions = v
	return s
}

func (s *ListAddonReleasesResponseBodyDataReleases) SetCreateTime(v string) *ListAddonReleasesResponseBodyDataReleases {
	s.CreateTime = &v
	return s
}

func (s *ListAddonReleasesResponseBodyDataReleases) SetDashboardCount(v int64) *ListAddonReleasesResponseBodyDataReleases {
	s.DashboardCount = &v
	return s
}

func (s *ListAddonReleasesResponseBodyDataReleases) SetEnvironmentId(v string) *ListAddonReleasesResponseBodyDataReleases {
	s.EnvironmentId = &v
	return s
}

func (s *ListAddonReleasesResponseBodyDataReleases) SetExporterCount(v int64) *ListAddonReleasesResponseBodyDataReleases {
	s.ExporterCount = &v
	return s
}

func (s *ListAddonReleasesResponseBodyDataReleases) SetHaveConfig(v bool) *ListAddonReleasesResponseBodyDataReleases {
	s.HaveConfig = &v
	return s
}

func (s *ListAddonReleasesResponseBodyDataReleases) SetInstallUserId(v string) *ListAddonReleasesResponseBodyDataReleases {
	s.InstallUserId = &v
	return s
}

func (s *ListAddonReleasesResponseBodyDataReleases) SetLanguage(v string) *ListAddonReleasesResponseBodyDataReleases {
	s.Language = &v
	return s
}

func (s *ListAddonReleasesResponseBodyDataReleases) SetRegionId(v string) *ListAddonReleasesResponseBodyDataReleases {
	s.RegionId = &v
	return s
}

func (s *ListAddonReleasesResponseBodyDataReleases) SetReleaseId(v string) *ListAddonReleasesResponseBodyDataReleases {
	s.ReleaseId = &v
	return s
}

func (s *ListAddonReleasesResponseBodyDataReleases) SetReleaseName(v string) *ListAddonReleasesResponseBodyDataReleases {
	s.ReleaseName = &v
	return s
}

func (s *ListAddonReleasesResponseBodyDataReleases) SetScene(v string) *ListAddonReleasesResponseBodyDataReleases {
	s.Scene = &v
	return s
}

func (s *ListAddonReleasesResponseBodyDataReleases) SetStatus(v string) *ListAddonReleasesResponseBodyDataReleases {
	s.Status = &v
	return s
}

func (s *ListAddonReleasesResponseBodyDataReleases) SetUpdateTime(v string) *ListAddonReleasesResponseBodyDataReleases {
	s.UpdateTime = &v
	return s
}

func (s *ListAddonReleasesResponseBodyDataReleases) SetUserId(v string) *ListAddonReleasesResponseBodyDataReleases {
	s.UserId = &v
	return s
}

func (s *ListAddonReleasesResponseBodyDataReleases) SetVersion(v string) *ListAddonReleasesResponseBodyDataReleases {
	s.Version = &v
	return s
}

type ListAddonReleasesResponseBodyDataReleasesConditions struct {
	// First transition time.
	FirstTransitionTime *string `json:"FirstTransitionTime,omitempty" xml:"FirstTransitionTime,omitempty"`
	// Last transition time.
	LastTransitionTime *string `json:"LastTransitionTime,omitempty" xml:"LastTransitionTime,omitempty"`
	// Details.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Reason of failure.
	Reason *string `json:"Reason,omitempty" xml:"Reason,omitempty"`
	// Condition status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// Condition type.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListAddonReleasesResponseBodyDataReleasesConditions) String() string {
	return tea.Prettify(s)
}

func (s ListAddonReleasesResponseBodyDataReleasesConditions) GoString() string {
	return s.String()
}

func (s *ListAddonReleasesResponseBodyDataReleasesConditions) SetFirstTransitionTime(v string) *ListAddonReleasesResponseBodyDataReleasesConditions {
	s.FirstTransitionTime = &v
	return s
}

func (s *ListAddonReleasesResponseBodyDataReleasesConditions) SetLastTransitionTime(v string) *ListAddonReleasesResponseBodyDataReleasesConditions {
	s.LastTransitionTime = &v
	return s
}

func (s *ListAddonReleasesResponseBodyDataReleasesConditions) SetMessage(v string) *ListAddonReleasesResponseBodyDataReleasesConditions {
	s.Message = &v
	return s
}

func (s *ListAddonReleasesResponseBodyDataReleasesConditions) SetReason(v string) *ListAddonReleasesResponseBodyDataReleasesConditions {
	s.Reason = &v
	return s
}

func (s *ListAddonReleasesResponseBodyDataReleasesConditions) SetStatus(v string) *ListAddonReleasesResponseBodyDataReleasesConditions {
	s.Status = &v
	return s
}

func (s *ListAddonReleasesResponseBodyDataReleasesConditions) SetType(v string) *ListAddonReleasesResponseBodyDataReleasesConditions {
	s.Type = &v
	return s
}

type ListAddonReleasesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAddonReleasesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAddonReleasesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAddonReleasesResponse) GoString() string {
	return s.String()
}

func (s *ListAddonReleasesResponse) SetHeaders(v map[string]*string) *ListAddonReleasesResponse {
	s.Headers = v
	return s
}

func (s *ListAddonReleasesResponse) SetStatusCode(v int32) *ListAddonReleasesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAddonReleasesResponse) SetBody(v *ListAddonReleasesResponseBody) *ListAddonReleasesResponse {
	s.Body = v
	return s
}

type ListAlertEventsRequest struct {
	// The name of the alert.
	AlertName *string `json:"AlertName,omitempty" xml:"AlertName,omitempty"`
	// The end time of the alert events that you want to query. Specify the time in the YYYY-MM-DD HH:mm:ss format.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The list of matching conditions.
	MatchingConditions *string `json:"MatchingConditions,omitempty" xml:"MatchingConditions,omitempty"`
	// The number of the page to return.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of entries to return on each page.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The start time of the alert events that you want to query. Specify the time in the YYYY-MM-DD HH:mm:ss format.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The status of the alert events. Valid values:
	//
	// *   Active
	// *   Silenced
	// *   Resolved
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListAlertEventsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAlertEventsRequest) GoString() string {
	return s.String()
}

func (s *ListAlertEventsRequest) SetAlertName(v string) *ListAlertEventsRequest {
	s.AlertName = &v
	return s
}

func (s *ListAlertEventsRequest) SetEndTime(v string) *ListAlertEventsRequest {
	s.EndTime = &v
	return s
}

func (s *ListAlertEventsRequest) SetMatchingConditions(v string) *ListAlertEventsRequest {
	s.MatchingConditions = &v
	return s
}

func (s *ListAlertEventsRequest) SetPage(v int64) *ListAlertEventsRequest {
	s.Page = &v
	return s
}

func (s *ListAlertEventsRequest) SetSize(v int64) *ListAlertEventsRequest {
	s.Size = &v
	return s
}

func (s *ListAlertEventsRequest) SetStartTime(v string) *ListAlertEventsRequest {
	s.StartTime = &v
	return s
}

func (s *ListAlertEventsRequest) SetStatus(v string) *ListAlertEventsRequest {
	s.Status = &v
	return s
}

type ListAlertEventsResponseBody struct {
	// The struct returned.
	PageBean *ListAlertEventsResponseBodyPageBean `json:"PageBean,omitempty" xml:"PageBean,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAlertEventsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAlertEventsResponseBody) GoString() string {
	return s.String()
}

func (s *ListAlertEventsResponseBody) SetPageBean(v *ListAlertEventsResponseBodyPageBean) *ListAlertEventsResponseBody {
	s.PageBean = v
	return s
}

func (s *ListAlertEventsResponseBody) SetRequestId(v string) *ListAlertEventsResponseBody {
	s.RequestId = &v
	return s
}

type ListAlertEventsResponseBodyPageBean struct {
	// The list of information about historical alert events.
	Events []*ListAlertEventsResponseBodyPageBeanEvents `json:"Events,omitempty" xml:"Events,omitempty" type:"Repeated"`
	// The number of the page returned.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of entries returned per page.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The total number of returned entries.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListAlertEventsResponseBodyPageBean) String() string {
	return tea.Prettify(s)
}

func (s ListAlertEventsResponseBodyPageBean) GoString() string {
	return s.String()
}

func (s *ListAlertEventsResponseBodyPageBean) SetEvents(v []*ListAlertEventsResponseBodyPageBeanEvents) *ListAlertEventsResponseBodyPageBean {
	s.Events = v
	return s
}

func (s *ListAlertEventsResponseBodyPageBean) SetPage(v int64) *ListAlertEventsResponseBodyPageBean {
	s.Page = &v
	return s
}

func (s *ListAlertEventsResponseBodyPageBean) SetSize(v int64) *ListAlertEventsResponseBodyPageBean {
	s.Size = &v
	return s
}

func (s *ListAlertEventsResponseBodyPageBean) SetTotal(v int64) *ListAlertEventsResponseBodyPageBean {
	s.Total = &v
	return s
}

type ListAlertEventsResponseBodyPageBeanEvents struct {
	// The list of associated alerts.
	Alarms []*ListAlertEventsResponseBodyPageBeanEventsAlarms `json:"Alarms,omitempty" xml:"Alarms,omitempty" type:"Repeated"`
	// The name of the alert.
	AlertName *string `json:"AlertName,omitempty" xml:"AlertName,omitempty"`
	// The list of annotations.
	Annotations *string `json:"Annotations,omitempty" xml:"Annotations,omitempty"`
	// The description of the alert event.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The end time of the alert event.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The URL of the alert event.
	GeneratorURL *string `json:"GeneratorURL,omitempty" xml:"GeneratorURL,omitempty"`
	// The user who handled the alert.
	HandlerName *string `json:"HandlerName,omitempty" xml:"HandlerName,omitempty"`
	// The name of the alert integration.
	IntegrationName *string `json:"IntegrationName,omitempty" xml:"IntegrationName,omitempty"`
	// The type of the alert integration.
	IntegrationType *string `json:"IntegrationType,omitempty" xml:"IntegrationType,omitempty"`
	// The list of tags.
	Labels *string `json:"Labels,omitempty" xml:"Labels,omitempty"`
	// The time when the alert event was received.
	ReceiveTime *string `json:"ReceiveTime,omitempty" xml:"ReceiveTime,omitempty"`
	// The severity level of the alert. Valid value:
	//
	// *   critical: P1
	// *   error: P2
	// *   warning: P3
	// *   page: P4
	// *   default: P6
	Severity *string `json:"Severity,omitempty" xml:"Severity,omitempty"`
	// The start time of the alert event.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The status of the alert event. Valid values:
	//
	// *   Active
	// *   Silenced
	// *   Resolved
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListAlertEventsResponseBodyPageBeanEvents) String() string {
	return tea.Prettify(s)
}

func (s ListAlertEventsResponseBodyPageBeanEvents) GoString() string {
	return s.String()
}

func (s *ListAlertEventsResponseBodyPageBeanEvents) SetAlarms(v []*ListAlertEventsResponseBodyPageBeanEventsAlarms) *ListAlertEventsResponseBodyPageBeanEvents {
	s.Alarms = v
	return s
}

func (s *ListAlertEventsResponseBodyPageBeanEvents) SetAlertName(v string) *ListAlertEventsResponseBodyPageBeanEvents {
	s.AlertName = &v
	return s
}

func (s *ListAlertEventsResponseBodyPageBeanEvents) SetAnnotations(v string) *ListAlertEventsResponseBodyPageBeanEvents {
	s.Annotations = &v
	return s
}

func (s *ListAlertEventsResponseBodyPageBeanEvents) SetDescription(v string) *ListAlertEventsResponseBodyPageBeanEvents {
	s.Description = &v
	return s
}

func (s *ListAlertEventsResponseBodyPageBeanEvents) SetEndTime(v string) *ListAlertEventsResponseBodyPageBeanEvents {
	s.EndTime = &v
	return s
}

func (s *ListAlertEventsResponseBodyPageBeanEvents) SetGeneratorURL(v string) *ListAlertEventsResponseBodyPageBeanEvents {
	s.GeneratorURL = &v
	return s
}

func (s *ListAlertEventsResponseBodyPageBeanEvents) SetHandlerName(v string) *ListAlertEventsResponseBodyPageBeanEvents {
	s.HandlerName = &v
	return s
}

func (s *ListAlertEventsResponseBodyPageBeanEvents) SetIntegrationName(v string) *ListAlertEventsResponseBodyPageBeanEvents {
	s.IntegrationName = &v
	return s
}

func (s *ListAlertEventsResponseBodyPageBeanEvents) SetIntegrationType(v string) *ListAlertEventsResponseBodyPageBeanEvents {
	s.IntegrationType = &v
	return s
}

func (s *ListAlertEventsResponseBodyPageBeanEvents) SetLabels(v string) *ListAlertEventsResponseBodyPageBeanEvents {
	s.Labels = &v
	return s
}

func (s *ListAlertEventsResponseBodyPageBeanEvents) SetReceiveTime(v string) *ListAlertEventsResponseBodyPageBeanEvents {
	s.ReceiveTime = &v
	return s
}

func (s *ListAlertEventsResponseBodyPageBeanEvents) SetSeverity(v string) *ListAlertEventsResponseBodyPageBeanEvents {
	s.Severity = &v
	return s
}

func (s *ListAlertEventsResponseBodyPageBeanEvents) SetStartTime(v string) *ListAlertEventsResponseBodyPageBeanEvents {
	s.StartTime = &v
	return s
}

func (s *ListAlertEventsResponseBodyPageBeanEvents) SetStatus(v string) *ListAlertEventsResponseBodyPageBeanEvents {
	s.Status = &v
	return s
}

type ListAlertEventsResponseBodyPageBeanEventsAlarms struct {
	// The ID of the alert.
	AlarmId *int64 `json:"AlarmId,omitempty" xml:"AlarmId,omitempty"`
	// The name of the alert.
	AlarmName *string `json:"AlarmName,omitempty" xml:"AlarmName,omitempty"`
	// The time when the alert was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The status of the alert. Valid values:
	//
	// *   0: The alert is pending.
	// *   1: The alert is being handled.
	// *   2: The alert is cleared.
	State *int32 `json:"State,omitempty" xml:"State,omitempty"`
}

func (s ListAlertEventsResponseBodyPageBeanEventsAlarms) String() string {
	return tea.Prettify(s)
}

func (s ListAlertEventsResponseBodyPageBeanEventsAlarms) GoString() string {
	return s.String()
}

func (s *ListAlertEventsResponseBodyPageBeanEventsAlarms) SetAlarmId(v int64) *ListAlertEventsResponseBodyPageBeanEventsAlarms {
	s.AlarmId = &v
	return s
}

func (s *ListAlertEventsResponseBodyPageBeanEventsAlarms) SetAlarmName(v string) *ListAlertEventsResponseBodyPageBeanEventsAlarms {
	s.AlarmName = &v
	return s
}

func (s *ListAlertEventsResponseBodyPageBeanEventsAlarms) SetCreateTime(v string) *ListAlertEventsResponseBodyPageBeanEventsAlarms {
	s.CreateTime = &v
	return s
}

func (s *ListAlertEventsResponseBodyPageBeanEventsAlarms) SetState(v int32) *ListAlertEventsResponseBodyPageBeanEventsAlarms {
	s.State = &v
	return s
}

type ListAlertEventsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAlertEventsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAlertEventsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAlertEventsResponse) GoString() string {
	return s.String()
}

func (s *ListAlertEventsResponse) SetHeaders(v map[string]*string) *ListAlertEventsResponse {
	s.Headers = v
	return s
}

func (s *ListAlertEventsResponse) SetStatusCode(v int32) *ListAlertEventsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAlertEventsResponse) SetBody(v *ListAlertEventsResponseBody) *ListAlertEventsResponse {
	s.Body = v
	return s
}

type ListAlertsRequest struct {
	// The name of the alert rule.
	AlertName *string `json:"AlertName,omitempty" xml:"AlertName,omitempty"`
	// The ID of the notification policy.
	DispatchRuleId *int64 `json:"DispatchRuleId,omitempty" xml:"DispatchRuleId,omitempty"`
	// The end time of the alert sending history that you want to query. Specify the time in the `YYYY-MM-DD HH:mm:ss` format.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The integration type.
	//
	// *   ARMS
	// *   CLOUD_MONITOR
	// *   MSE
	// *   ARMS_CLOUD_DIALTEST
	// *   PROMETHEUS
	// *   LOG_SERVICE
	// *   CUSTOM
	// *   ARMS_PROMETHEUS
	// *   ARMS_APP_MON
	// *   ARMS_FRONT_MON
	// *   ARMS_CUSTOM
	// *   XTRACE
	// *   GRAFANA
	// *   ZABBIX
	// *   SKYWALKING
	// *   EVENT_BRIDGE
	// *   NAGIOS
	// *   OPENFALCON
	// *   ARMS_INSIGHTS
	IntegrationType *string `json:"IntegrationType,omitempty" xml:"IntegrationType,omitempty"`
	// The number of the page to return.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The severity level of the alert. Valid values: P6, P5, P4, P3, P2, and P1. The preceding values are listed in ascending order of severity.
	Severity *string `json:"Severity,omitempty" xml:"Severity,omitempty"`
	// Specifies whether to query the activities that correspond to alerts. Valid values:
	//
	// *   `false` (default value): The activities are not queried.
	// *   `true`: The activities in the last three days are queried.
	ShowActivities *bool `json:"ShowActivities,omitempty" xml:"ShowActivities,omitempty"`
	// Specifies whether to query the events that correspond to alerts. Valid values:
	//
	// *   `false` (default value): The events are not queried.
	// *   `true`: The events are queried.
	ShowEvents *bool `json:"ShowEvents,omitempty" xml:"ShowEvents,omitempty"`
	// The number of alerts to return on each page.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The start time of the alert sending history that you want to query. Specify the time in the `YYYY-MM-DD HH:mm:ss` format.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The status of the alert. Valid values:
	//
	// *   0: The alert is pending.
	// *   1: The alert is being handled.
	// *   2: The alert is handled.
	State *int64 `json:"State,omitempty" xml:"State,omitempty"`
}

func (s ListAlertsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAlertsRequest) GoString() string {
	return s.String()
}

func (s *ListAlertsRequest) SetAlertName(v string) *ListAlertsRequest {
	s.AlertName = &v
	return s
}

func (s *ListAlertsRequest) SetDispatchRuleId(v int64) *ListAlertsRequest {
	s.DispatchRuleId = &v
	return s
}

func (s *ListAlertsRequest) SetEndTime(v string) *ListAlertsRequest {
	s.EndTime = &v
	return s
}

func (s *ListAlertsRequest) SetIntegrationType(v string) *ListAlertsRequest {
	s.IntegrationType = &v
	return s
}

func (s *ListAlertsRequest) SetPage(v int64) *ListAlertsRequest {
	s.Page = &v
	return s
}

func (s *ListAlertsRequest) SetRegionId(v string) *ListAlertsRequest {
	s.RegionId = &v
	return s
}

func (s *ListAlertsRequest) SetSeverity(v string) *ListAlertsRequest {
	s.Severity = &v
	return s
}

func (s *ListAlertsRequest) SetShowActivities(v bool) *ListAlertsRequest {
	s.ShowActivities = &v
	return s
}

func (s *ListAlertsRequest) SetShowEvents(v bool) *ListAlertsRequest {
	s.ShowEvents = &v
	return s
}

func (s *ListAlertsRequest) SetSize(v int64) *ListAlertsRequest {
	s.Size = &v
	return s
}

func (s *ListAlertsRequest) SetStartTime(v string) *ListAlertsRequest {
	s.StartTime = &v
	return s
}

func (s *ListAlertsRequest) SetState(v int64) *ListAlertsRequest {
	s.State = &v
	return s
}

type ListAlertsResponseBody struct {
	// The information about the array object.
	PageBean *ListAlertsResponseBodyPageBean `json:"PageBean,omitempty" xml:"PageBean,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAlertsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAlertsResponseBody) GoString() string {
	return s.String()
}

func (s *ListAlertsResponseBody) SetPageBean(v *ListAlertsResponseBodyPageBean) *ListAlertsResponseBody {
	s.PageBean = v
	return s
}

func (s *ListAlertsResponseBody) SetRequestId(v string) *ListAlertsResponseBody {
	s.RequestId = &v
	return s
}

type ListAlertsResponseBodyPageBean struct {
	// The alerts for which the alert sending history is queried.
	ListAlerts []*ListAlertsResponseBodyPageBeanListAlerts `json:"ListAlerts,omitempty" xml:"ListAlerts,omitempty" type:"Repeated"`
	// The page number of the returned page.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of alerts returned per page.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The total number of queried alerts.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListAlertsResponseBodyPageBean) String() string {
	return tea.Prettify(s)
}

func (s ListAlertsResponseBodyPageBean) GoString() string {
	return s.String()
}

func (s *ListAlertsResponseBodyPageBean) SetListAlerts(v []*ListAlertsResponseBodyPageBeanListAlerts) *ListAlertsResponseBodyPageBean {
	s.ListAlerts = v
	return s
}

func (s *ListAlertsResponseBodyPageBean) SetPage(v int64) *ListAlertsResponseBodyPageBean {
	s.Page = &v
	return s
}

func (s *ListAlertsResponseBodyPageBean) SetSize(v int64) *ListAlertsResponseBodyPageBean {
	s.Size = &v
	return s
}

func (s *ListAlertsResponseBodyPageBean) SetTotal(v int64) *ListAlertsResponseBodyPageBean {
	s.Total = &v
	return s
}

type ListAlertsResponseBodyPageBeanListAlerts struct {
	AcknowledgeTime *int64 `json:"AcknowledgeTime,omitempty" xml:"AcknowledgeTime,omitempty"`
	// The list of activities.
	Activities []*ListAlertsResponseBodyPageBeanListAlertsActivities `json:"Activities,omitempty" xml:"Activities,omitempty" type:"Repeated"`
	// The list of events.
	AlertEvents []*ListAlertsResponseBodyPageBeanListAlertsAlertEvents `json:"AlertEvents,omitempty" xml:"AlertEvents,omitempty" type:"Repeated"`
	// The alert ID.
	AlertId *int64 `json:"AlertId,omitempty" xml:"AlertId,omitempty"`
	// The name of the alert rule.
	AlertName *string `json:"AlertName,omitempty" xml:"AlertName,omitempty"`
	// The time when the alert was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	Describe   *string `json:"Describe,omitempty" xml:"Describe,omitempty"`
	// The ID of the notification policy.
	DispatchRuleId *float32 `json:"DispatchRuleId,omitempty" xml:"DispatchRuleId,omitempty"`
	// The name of the notification policy.
	DispatchRuleName *string `json:"DispatchRuleName,omitempty" xml:"DispatchRuleName,omitempty"`
	Handler          *string `json:"Handler,omitempty" xml:"Handler,omitempty"`
	NotifyRobots     *string `json:"NotifyRobots,omitempty" xml:"NotifyRobots,omitempty"`
	Owner            *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	RecoverTime      *int64  `json:"RecoverTime,omitempty" xml:"RecoverTime,omitempty"`
	// The severity level of the alert. Valid values: P6, P5, P4, P3, P2, and P1. The preceding values are listed in ascending order of severity.
	Severity *string `json:"Severity,omitempty" xml:"Severity,omitempty"`
	// The Alert solution.
	Solution *string `json:"Solution,omitempty" xml:"Solution,omitempty"`
	// The status of the alert. Valid values:
	//
	// *   0: The alert is pending.
	// *   1: The alert is being handled.
	// *   2: The alert is handled.
	State *int64 `json:"State,omitempty" xml:"State,omitempty"`
}

func (s ListAlertsResponseBodyPageBeanListAlerts) String() string {
	return tea.Prettify(s)
}

func (s ListAlertsResponseBodyPageBeanListAlerts) GoString() string {
	return s.String()
}

func (s *ListAlertsResponseBodyPageBeanListAlerts) SetAcknowledgeTime(v int64) *ListAlertsResponseBodyPageBeanListAlerts {
	s.AcknowledgeTime = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlerts) SetActivities(v []*ListAlertsResponseBodyPageBeanListAlertsActivities) *ListAlertsResponseBodyPageBeanListAlerts {
	s.Activities = v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlerts) SetAlertEvents(v []*ListAlertsResponseBodyPageBeanListAlertsAlertEvents) *ListAlertsResponseBodyPageBeanListAlerts {
	s.AlertEvents = v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlerts) SetAlertId(v int64) *ListAlertsResponseBodyPageBeanListAlerts {
	s.AlertId = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlerts) SetAlertName(v string) *ListAlertsResponseBodyPageBeanListAlerts {
	s.AlertName = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlerts) SetCreateTime(v string) *ListAlertsResponseBodyPageBeanListAlerts {
	s.CreateTime = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlerts) SetDescribe(v string) *ListAlertsResponseBodyPageBeanListAlerts {
	s.Describe = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlerts) SetDispatchRuleId(v float32) *ListAlertsResponseBodyPageBeanListAlerts {
	s.DispatchRuleId = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlerts) SetDispatchRuleName(v string) *ListAlertsResponseBodyPageBeanListAlerts {
	s.DispatchRuleName = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlerts) SetHandler(v string) *ListAlertsResponseBodyPageBeanListAlerts {
	s.Handler = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlerts) SetNotifyRobots(v string) *ListAlertsResponseBodyPageBeanListAlerts {
	s.NotifyRobots = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlerts) SetOwner(v string) *ListAlertsResponseBodyPageBeanListAlerts {
	s.Owner = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlerts) SetRecoverTime(v int64) *ListAlertsResponseBodyPageBeanListAlerts {
	s.RecoverTime = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlerts) SetSeverity(v string) *ListAlertsResponseBodyPageBeanListAlerts {
	s.Severity = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlerts) SetSolution(v string) *ListAlertsResponseBodyPageBeanListAlerts {
	s.Solution = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlerts) SetState(v int64) *ListAlertsResponseBodyPageBeanListAlerts {
	s.State = &v
	return s
}

type ListAlertsResponseBodyPageBeanListAlertsActivities struct {
	// The content of the alert notification.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The description of the activity.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the handler.
	HandlerName *string `json:"HandlerName,omitempty" xml:"HandlerName,omitempty"`
	// The operation time of the activity.
	Time *string `json:"Time,omitempty" xml:"Time,omitempty"`
	// The type of the activity. Valid values:
	//
	// *   1: The alert is claimed.
	// *   2: The alert is disclaimed.
	// *   3: A comment is added for the alert.
	// *   4: The alert is disabled.
	// *   5: An alert notification is sent.
	Type *int64 `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListAlertsResponseBodyPageBeanListAlertsActivities) String() string {
	return tea.Prettify(s)
}

func (s ListAlertsResponseBodyPageBeanListAlertsActivities) GoString() string {
	return s.String()
}

func (s *ListAlertsResponseBodyPageBeanListAlertsActivities) SetContent(v string) *ListAlertsResponseBodyPageBeanListAlertsActivities {
	s.Content = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlertsActivities) SetDescription(v string) *ListAlertsResponseBodyPageBeanListAlertsActivities {
	s.Description = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlertsActivities) SetHandlerName(v string) *ListAlertsResponseBodyPageBeanListAlertsActivities {
	s.HandlerName = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlertsActivities) SetTime(v string) *ListAlertsResponseBodyPageBeanListAlertsActivities {
	s.Time = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlertsActivities) SetType(v int64) *ListAlertsResponseBodyPageBeanListAlertsActivities {
	s.Type = &v
	return s
}

type ListAlertsResponseBodyPageBeanListAlertsAlertEvents struct {
	// The name of the event.
	AlertName *string `json:"AlertName,omitempty" xml:"AlertName,omitempty"`
	// The annotations.
	Annotations *string `json:"Annotations,omitempty" xml:"Annotations,omitempty"`
	// The description of the event.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The time when the event ended.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The URL of the event.
	GeneratorURL *string `json:"GeneratorURL,omitempty" xml:"GeneratorURL,omitempty"`
	// The name of the integration that corresponds to the alert event.
	IntegrationName *string `json:"IntegrationName,omitempty" xml:"IntegrationName,omitempty"`
	// The type of the integration that corresponds to the alert event. Valid values:
	//
	// *   ARMS
	// *   CLOUD_MONITOR
	// *   MSE
	// *   ARMS_CLOUD_DIALTEST
	// *   PROMETHEUS
	// *   LOG_SERVICE
	// *   CUSTOM
	// *   ARMS_PROMETHEUS
	// *   ARMS_APP_MON
	// *   ARMS_FRONT_MON
	// *   ARMS_CUSTOM
	// *   XTRACE
	// *   GRAFANA
	// *   ZABBIX
	// *   SKYWALKING
	// *   EVENT_BRIDGE
	// *   NAGIOS
	// *   OPENFALCON
	// *   ARMS_INSIGHTS
	IntegrationType *string `json:"IntegrationType,omitempty" xml:"IntegrationType,omitempty"`
	// The tags.
	Labels *string `json:"Labels,omitempty" xml:"Labels,omitempty"`
	// The time when the event was created.
	ReceiveTime *string `json:"ReceiveTime,omitempty" xml:"ReceiveTime,omitempty"`
	// The severity level of the event. Valid values:
	//
	// *   critical
	// *   error
	// *   warning
	// *   info
	Severity *string `json:"Severity,omitempty" xml:"Severity,omitempty"`
	// The time when the event started.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The status of the event. Valid values:
	//
	// *   Active: The event is not cleared.
	// *   Silenced: The event is silenced.
	// *   Resolved: The event is cleared.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s ListAlertsResponseBodyPageBeanListAlertsAlertEvents) String() string {
	return tea.Prettify(s)
}

func (s ListAlertsResponseBodyPageBeanListAlertsAlertEvents) GoString() string {
	return s.String()
}

func (s *ListAlertsResponseBodyPageBeanListAlertsAlertEvents) SetAlertName(v string) *ListAlertsResponseBodyPageBeanListAlertsAlertEvents {
	s.AlertName = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlertsAlertEvents) SetAnnotations(v string) *ListAlertsResponseBodyPageBeanListAlertsAlertEvents {
	s.Annotations = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlertsAlertEvents) SetDescription(v string) *ListAlertsResponseBodyPageBeanListAlertsAlertEvents {
	s.Description = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlertsAlertEvents) SetEndTime(v string) *ListAlertsResponseBodyPageBeanListAlertsAlertEvents {
	s.EndTime = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlertsAlertEvents) SetGeneratorURL(v string) *ListAlertsResponseBodyPageBeanListAlertsAlertEvents {
	s.GeneratorURL = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlertsAlertEvents) SetIntegrationName(v string) *ListAlertsResponseBodyPageBeanListAlertsAlertEvents {
	s.IntegrationName = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlertsAlertEvents) SetIntegrationType(v string) *ListAlertsResponseBodyPageBeanListAlertsAlertEvents {
	s.IntegrationType = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlertsAlertEvents) SetLabels(v string) *ListAlertsResponseBodyPageBeanListAlertsAlertEvents {
	s.Labels = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlertsAlertEvents) SetReceiveTime(v string) *ListAlertsResponseBodyPageBeanListAlertsAlertEvents {
	s.ReceiveTime = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlertsAlertEvents) SetSeverity(v string) *ListAlertsResponseBodyPageBeanListAlertsAlertEvents {
	s.Severity = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlertsAlertEvents) SetStartTime(v string) *ListAlertsResponseBodyPageBeanListAlertsAlertEvents {
	s.StartTime = &v
	return s
}

func (s *ListAlertsResponseBodyPageBeanListAlertsAlertEvents) SetState(v string) *ListAlertsResponseBodyPageBeanListAlertsAlertEvents {
	s.State = &v
	return s
}

type ListAlertsResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAlertsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAlertsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAlertsResponse) GoString() string {
	return s.String()
}

func (s *ListAlertsResponse) SetHeaders(v map[string]*string) *ListAlertsResponse {
	s.Headers = v
	return s
}

func (s *ListAlertsResponse) SetStatusCode(v int32) *ListAlertsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAlertsResponse) SetBody(v *ListAlertsResponseBody) *ListAlertsResponse {
	s.Body = v
	return s
}

type ListClusterFromGrafanaRequest struct {
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListClusterFromGrafanaRequest) String() string {
	return tea.Prettify(s)
}

func (s ListClusterFromGrafanaRequest) GoString() string {
	return s.String()
}

func (s *ListClusterFromGrafanaRequest) SetRegionId(v string) *ListClusterFromGrafanaRequest {
	s.RegionId = &v
	return s
}

type ListClusterFromGrafanaResponseBody struct {
	// The cluster information.
	PromClusterList []*ListClusterFromGrafanaResponseBodyPromClusterList `json:"PromClusterList,omitempty" xml:"PromClusterList,omitempty" type:"Repeated"`
	// The request ID. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListClusterFromGrafanaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListClusterFromGrafanaResponseBody) GoString() string {
	return s.String()
}

func (s *ListClusterFromGrafanaResponseBody) SetPromClusterList(v []*ListClusterFromGrafanaResponseBodyPromClusterList) *ListClusterFromGrafanaResponseBody {
	s.PromClusterList = v
	return s
}

func (s *ListClusterFromGrafanaResponseBody) SetRequestId(v string) *ListClusterFromGrafanaResponseBody {
	s.RequestId = &v
	return s
}

type ListClusterFromGrafanaResponseBodyPromClusterList struct {
	// The status of the Prometheus agent on the cluster. Valid values:
	//
	// *   INSTALL_FAILED: The Prometheus agent failed to be installed.
	// *   INSTALL_SUCCEED: The Prometheus agent was installed.
	// *   NOT_REGISTER: You have not registered an Alibaba Cloud account.
	AgentStatus *string `json:"AgentStatus,omitempty" xml:"AgentStatus,omitempty"`
	// The cluster ID.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the cluster.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The type of the cluster.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The controller ID.
	ControllerId *string `json:"ControllerId,omitempty" xml:"ControllerId,omitempty"`
	// The time when the dashboard was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The extended fields. This parameter is a JSON string.
	Extra *string `json:"Extra,omitempty" xml:"Extra,omitempty"`
	// The ID of a database in the cluster.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The timestamp when the Prometheus agent was installed.
	InstallTime *int64 `json:"InstallTime,omitempty" xml:"InstallTime,omitempty"`
	// Indicates whether the Prometheus agent was installed. Valid values:
	//
	// *   true: The Prometheus agent was installed.
	// *   false: The Prometheus agent was not installed.
	IsControllerInstalled *bool `json:"IsControllerInstalled,omitempty" xml:"IsControllerInstalled,omitempty"`
	// The time when the last heartbeat was reported.
	LastHeartBeatTime *int64 `json:"LastHeartBeatTime,omitempty" xml:"LastHeartBeatTime,omitempty"`
	// The number of nodes.
	NodeNum *int32 `json:"NodeNum,omitempty" xml:"NodeNum,omitempty"`
	// The custom parameter.
	Options *string `json:"Options,omitempty" xml:"Options,omitempty"`
	// The list of nodejsonar logs.
	PluginsJsonArray *string `json:"PluginsJsonArray,omitempty" xml:"PluginsJsonArray,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The information about applications deployed in the cluster.
	StateJson *string `json:"StateJson,omitempty" xml:"StateJson,omitempty"`
	// The time when the dashboard was updated.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The ID of the Alibaba Cloud account to which the cluster belongs.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s ListClusterFromGrafanaResponseBodyPromClusterList) String() string {
	return tea.Prettify(s)
}

func (s ListClusterFromGrafanaResponseBodyPromClusterList) GoString() string {
	return s.String()
}

func (s *ListClusterFromGrafanaResponseBodyPromClusterList) SetAgentStatus(v string) *ListClusterFromGrafanaResponseBodyPromClusterList {
	s.AgentStatus = &v
	return s
}

func (s *ListClusterFromGrafanaResponseBodyPromClusterList) SetClusterId(v string) *ListClusterFromGrafanaResponseBodyPromClusterList {
	s.ClusterId = &v
	return s
}

func (s *ListClusterFromGrafanaResponseBodyPromClusterList) SetClusterName(v string) *ListClusterFromGrafanaResponseBodyPromClusterList {
	s.ClusterName = &v
	return s
}

func (s *ListClusterFromGrafanaResponseBodyPromClusterList) SetClusterType(v string) *ListClusterFromGrafanaResponseBodyPromClusterList {
	s.ClusterType = &v
	return s
}

func (s *ListClusterFromGrafanaResponseBodyPromClusterList) SetControllerId(v string) *ListClusterFromGrafanaResponseBodyPromClusterList {
	s.ControllerId = &v
	return s
}

func (s *ListClusterFromGrafanaResponseBodyPromClusterList) SetCreateTime(v int64) *ListClusterFromGrafanaResponseBodyPromClusterList {
	s.CreateTime = &v
	return s
}

func (s *ListClusterFromGrafanaResponseBodyPromClusterList) SetExtra(v string) *ListClusterFromGrafanaResponseBodyPromClusterList {
	s.Extra = &v
	return s
}

func (s *ListClusterFromGrafanaResponseBodyPromClusterList) SetId(v int64) *ListClusterFromGrafanaResponseBodyPromClusterList {
	s.Id = &v
	return s
}

func (s *ListClusterFromGrafanaResponseBodyPromClusterList) SetInstallTime(v int64) *ListClusterFromGrafanaResponseBodyPromClusterList {
	s.InstallTime = &v
	return s
}

func (s *ListClusterFromGrafanaResponseBodyPromClusterList) SetIsControllerInstalled(v bool) *ListClusterFromGrafanaResponseBodyPromClusterList {
	s.IsControllerInstalled = &v
	return s
}

func (s *ListClusterFromGrafanaResponseBodyPromClusterList) SetLastHeartBeatTime(v int64) *ListClusterFromGrafanaResponseBodyPromClusterList {
	s.LastHeartBeatTime = &v
	return s
}

func (s *ListClusterFromGrafanaResponseBodyPromClusterList) SetNodeNum(v int32) *ListClusterFromGrafanaResponseBodyPromClusterList {
	s.NodeNum = &v
	return s
}

func (s *ListClusterFromGrafanaResponseBodyPromClusterList) SetOptions(v string) *ListClusterFromGrafanaResponseBodyPromClusterList {
	s.Options = &v
	return s
}

func (s *ListClusterFromGrafanaResponseBodyPromClusterList) SetPluginsJsonArray(v string) *ListClusterFromGrafanaResponseBodyPromClusterList {
	s.PluginsJsonArray = &v
	return s
}

func (s *ListClusterFromGrafanaResponseBodyPromClusterList) SetRegionId(v string) *ListClusterFromGrafanaResponseBodyPromClusterList {
	s.RegionId = &v
	return s
}

func (s *ListClusterFromGrafanaResponseBodyPromClusterList) SetStateJson(v string) *ListClusterFromGrafanaResponseBodyPromClusterList {
	s.StateJson = &v
	return s
}

func (s *ListClusterFromGrafanaResponseBodyPromClusterList) SetUpdateTime(v int64) *ListClusterFromGrafanaResponseBodyPromClusterList {
	s.UpdateTime = &v
	return s
}

func (s *ListClusterFromGrafanaResponseBodyPromClusterList) SetUserId(v string) *ListClusterFromGrafanaResponseBodyPromClusterList {
	s.UserId = &v
	return s
}

type ListClusterFromGrafanaResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListClusterFromGrafanaResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListClusterFromGrafanaResponse) String() string {
	return tea.Prettify(s)
}

func (s ListClusterFromGrafanaResponse) GoString() string {
	return s.String()
}

func (s *ListClusterFromGrafanaResponse) SetHeaders(v map[string]*string) *ListClusterFromGrafanaResponse {
	s.Headers = v
	return s
}

func (s *ListClusterFromGrafanaResponse) SetStatusCode(v int32) *ListClusterFromGrafanaResponse {
	s.StatusCode = &v
	return s
}

func (s *ListClusterFromGrafanaResponse) SetBody(v *ListClusterFromGrafanaResponseBody) *ListClusterFromGrafanaResponse {
	s.Body = v
	return s
}

type ListCmsInstancesRequest struct {
	ClusterId  *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	RegionId   *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	TypeFilter *string `json:"TypeFilter,omitempty" xml:"TypeFilter,omitempty"`
}

func (s ListCmsInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListCmsInstancesRequest) GoString() string {
	return s.String()
}

func (s *ListCmsInstancesRequest) SetClusterId(v string) *ListCmsInstancesRequest {
	s.ClusterId = &v
	return s
}

func (s *ListCmsInstancesRequest) SetRegionId(v string) *ListCmsInstancesRequest {
	s.RegionId = &v
	return s
}

func (s *ListCmsInstancesRequest) SetTypeFilter(v string) *ListCmsInstancesRequest {
	s.TypeFilter = &v
	return s
}

type ListCmsInstancesResponseBody struct {
	Data      *ListCmsInstancesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	RequestId *string                           `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListCmsInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListCmsInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *ListCmsInstancesResponseBody) SetData(v *ListCmsInstancesResponseBodyData) *ListCmsInstancesResponseBody {
	s.Data = v
	return s
}

func (s *ListCmsInstancesResponseBody) SetRequestId(v string) *ListCmsInstancesResponseBody {
	s.RequestId = &v
	return s
}

type ListCmsInstancesResponseBodyData struct {
	EnableTag *bool                                       `json:"EnableTag,omitempty" xml:"EnableTag,omitempty"`
	Products  []*ListCmsInstancesResponseBodyDataProducts `json:"Products,omitempty" xml:"Products,omitempty" type:"Repeated"`
}

func (s ListCmsInstancesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListCmsInstancesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListCmsInstancesResponseBodyData) SetEnableTag(v bool) *ListCmsInstancesResponseBodyData {
	s.EnableTag = &v
	return s
}

func (s *ListCmsInstancesResponseBodyData) SetProducts(v []*ListCmsInstancesResponseBodyDataProducts) *ListCmsInstancesResponseBodyData {
	s.Products = v
	return s
}

type ListCmsInstancesResponseBodyDataProducts struct {
	Descr    *string `json:"Descr,omitempty" xml:"Descr,omitempty"`
	Id       *string `json:"Id,omitempty" xml:"Id,omitempty"`
	Instance *string `json:"Instance,omitempty" xml:"Instance,omitempty"`
	Name     *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Prod     *string `json:"Prod,omitempty" xml:"Prod,omitempty"`
	Source   *string `json:"Source,omitempty" xml:"Source,omitempty"`
	State    *string `json:"State,omitempty" xml:"State,omitempty"`
	Time     *string `json:"Time,omitempty" xml:"Time,omitempty"`
	Type     *string `json:"Type,omitempty" xml:"Type,omitempty"`
	Url      *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s ListCmsInstancesResponseBodyDataProducts) String() string {
	return tea.Prettify(s)
}

func (s ListCmsInstancesResponseBodyDataProducts) GoString() string {
	return s.String()
}

func (s *ListCmsInstancesResponseBodyDataProducts) SetDescr(v string) *ListCmsInstancesResponseBodyDataProducts {
	s.Descr = &v
	return s
}

func (s *ListCmsInstancesResponseBodyDataProducts) SetId(v string) *ListCmsInstancesResponseBodyDataProducts {
	s.Id = &v
	return s
}

func (s *ListCmsInstancesResponseBodyDataProducts) SetInstance(v string) *ListCmsInstancesResponseBodyDataProducts {
	s.Instance = &v
	return s
}

func (s *ListCmsInstancesResponseBodyDataProducts) SetName(v string) *ListCmsInstancesResponseBodyDataProducts {
	s.Name = &v
	return s
}

func (s *ListCmsInstancesResponseBodyDataProducts) SetProd(v string) *ListCmsInstancesResponseBodyDataProducts {
	s.Prod = &v
	return s
}

func (s *ListCmsInstancesResponseBodyDataProducts) SetSource(v string) *ListCmsInstancesResponseBodyDataProducts {
	s.Source = &v
	return s
}

func (s *ListCmsInstancesResponseBodyDataProducts) SetState(v string) *ListCmsInstancesResponseBodyDataProducts {
	s.State = &v
	return s
}

func (s *ListCmsInstancesResponseBodyDataProducts) SetTime(v string) *ListCmsInstancesResponseBodyDataProducts {
	s.Time = &v
	return s
}

func (s *ListCmsInstancesResponseBodyDataProducts) SetType(v string) *ListCmsInstancesResponseBodyDataProducts {
	s.Type = &v
	return s
}

func (s *ListCmsInstancesResponseBodyDataProducts) SetUrl(v string) *ListCmsInstancesResponseBodyDataProducts {
	s.Url = &v
	return s
}

type ListCmsInstancesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListCmsInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListCmsInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListCmsInstancesResponse) GoString() string {
	return s.String()
}

func (s *ListCmsInstancesResponse) SetHeaders(v map[string]*string) *ListCmsInstancesResponse {
	s.Headers = v
	return s
}

func (s *ListCmsInstancesResponse) SetStatusCode(v int32) *ListCmsInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListCmsInstancesResponse) SetBody(v *ListCmsInstancesResponseBody) *ListCmsInstancesResponse {
	s.Body = v
	return s
}

type ListDashboardsRequest struct {
	// The ID of the ACK cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// Valid values: ACK, ASK, cloud-product-prometheus, and Node. You can query the dashboards of a virtual cluster by specifying the cluster type. For InfluxDB, set this parameter to `cloud-product-prometheus`.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The unique names of the dashboards. You can query dashboards by specifying their names. The **dashboard title** can be changed whereas the **dashboard name** cannot. You can specify multiple names and separate them with commas (,), for example, `k8s-event,k8s-overview`. A dashboard may have multiple versions. If you want to specify a version, you can add version information after the name, for example, `k8s-event:v1,k8s-overview:latest`.
	DashboardName *string `json:"DashboardName,omitempty" xml:"DashboardName,omitempty"`
	// The language of the Grafana dashboards. Valid values: en and zh. Default value: en.
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// The code of the cloud service. This parameter is required if you set the ClusterType parameter to `cloud-product-prometheus`. The following cloud services are available: Serverless App Engine, Microservices Engine, Message Queue for Apache RocketMQ, Lindorm, Message Queue for Apache Kafka, ApsaraDB for ClickHouse, Data Lake Analytics, Message Queue for RabbitMQ, ApsaraDB for MongoDB, Time Series Database (TSDB) for InfluxDB, MSE Cloud-native Gateway, Grafana Service, SchedulerX, Global Transaction Service, Enterprise Distributed Application Service, Machine Learning Platform for AI - Elastic Algorithm Service (EAS), Application High Availability Service, and Performance Testing.
	Product *string `json:"Product,omitempty" xml:"Product,omitempty"`
	// Specifies whether to create or query a virtual cluster. This parameter provides backward compatibility.
	RecreateSwitch *bool `json:"RecreateSwitch,omitempty" xml:"RecreateSwitch,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The dashboard title. The dashboard title can be changed. We recommend that you specify the **DashboardName** parameter.
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
}

func (s ListDashboardsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDashboardsRequest) GoString() string {
	return s.String()
}

func (s *ListDashboardsRequest) SetClusterId(v string) *ListDashboardsRequest {
	s.ClusterId = &v
	return s
}

func (s *ListDashboardsRequest) SetClusterType(v string) *ListDashboardsRequest {
	s.ClusterType = &v
	return s
}

func (s *ListDashboardsRequest) SetDashboardName(v string) *ListDashboardsRequest {
	s.DashboardName = &v
	return s
}

func (s *ListDashboardsRequest) SetLanguage(v string) *ListDashboardsRequest {
	s.Language = &v
	return s
}

func (s *ListDashboardsRequest) SetProduct(v string) *ListDashboardsRequest {
	s.Product = &v
	return s
}

func (s *ListDashboardsRequest) SetRecreateSwitch(v bool) *ListDashboardsRequest {
	s.RecreateSwitch = &v
	return s
}

func (s *ListDashboardsRequest) SetRegionId(v string) *ListDashboardsRequest {
	s.RegionId = &v
	return s
}

func (s *ListDashboardsRequest) SetTitle(v string) *ListDashboardsRequest {
	s.Title = &v
	return s
}

type ListDashboardsResponseBody struct {
	// The information about the Grafana dashboard.
	DashboardVos  []*ListDashboardsResponseBodyDashboardVos `json:"DashboardVos,omitempty" xml:"DashboardVos,omitempty" type:"Repeated"`
	EnvironmentId *string                                   `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The indicators of whether the Prometheus service has been activated.
	PrometheusServiceOpened *string `json:"PrometheusServiceOpened,omitempty" xml:"PrometheusServiceOpened,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListDashboardsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDashboardsResponseBody) GoString() string {
	return s.String()
}

func (s *ListDashboardsResponseBody) SetDashboardVos(v []*ListDashboardsResponseBodyDashboardVos) *ListDashboardsResponseBody {
	s.DashboardVos = v
	return s
}

func (s *ListDashboardsResponseBody) SetEnvironmentId(v string) *ListDashboardsResponseBody {
	s.EnvironmentId = &v
	return s
}

func (s *ListDashboardsResponseBody) SetPrometheusServiceOpened(v string) *ListDashboardsResponseBody {
	s.PrometheusServiceOpened = &v
	return s
}

func (s *ListDashboardsResponseBody) SetRequestId(v string) *ListDashboardsResponseBody {
	s.RequestId = &v
	return s
}

type ListDashboardsResponseBodyDashboardVos struct {
	// The type of the Grafana dashboard. This parameter has the same effect as the Exporter parameter whereas provides clearer implication.
	DashboardType *string `json:"DashboardType,omitempty" xml:"DashboardType,omitempty"`
	// The type of the exporter access source. Valid values:
	//
	// *   Prometheus
	// *   Node
	// *   GPU
	// *   Redis
	// *   MySQL
	// *   Kafka
	// *   NGINX V2
	// *   Nginx
	// *   ZooKeeper
	// *   MongoDB
	// *   RabbitMQ
	// *   PostgreSQL
	// *   Kubernetes
	// *   Client Library
	// *   Elasticsearch
	// *   RocketMQ
	Exporter *string `json:"Exporter,omitempty" xml:"Exporter,omitempty"`
	// The URL of the Grafana dashboard.
	HttpUrl *string `json:"HttpUrl,omitempty" xml:"HttpUrl,omitempty"`
	// The URL of the Grafana dashboard.
	HttpsUrl *string `json:"HttpsUrl,omitempty" xml:"HttpsUrl,omitempty"`
	// The information about the Grafana dashboard.
	I18nChild *ListDashboardsResponseBodyDashboardVosI18nChild `json:"I18nChild,omitempty" xml:"I18nChild,omitempty" type:"Struct"`
	// The ID of the Grafana dashboard. The value is unique only when you install the Grafana dashboard.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// Indicates whether the exporter was provided by ARMS. Valid values:
	//
	// *   `true`: The exporter is provided by ARMS.
	// *   `false`: The exporter is not provided by ARMS.
	IsArmsExporter *bool `json:"IsArmsExporter,omitempty" xml:"IsArmsExporter,omitempty"`
	// The type of the dashboard. Valid values: BASIC, THIRD, LIMIT, and CUSTOM. BASIC indicates a basic dashboard. THIRD indicates a third-party dashboard. LIMIT indicates a time-limited free dashboard. CUSTOM indicates a custom dashboard.
	Kind *string `json:"Kind,omitempty" xml:"Kind,omitempty"`
	// The language of the Grafana dashboard.
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// The name of the Grafana dashboard. This parameter is different from the **Title** parameter as this parameter cannot be changed.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Indicates whether the Grafana dashboard has a new version that was available for upgrade.
	NeedUpdate *bool `json:"NeedUpdate,omitempty" xml:"NeedUpdate,omitempty"`
	// The tags of the Grafana dashboard.
	Tags []*string `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The timestamp when the Grafana dashboard was created. Unit: seconds.
	Time *string `json:"Time,omitempty" xml:"Time,omitempty"`
	// The title of the Grafana dashboard.
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The type of the Grafana dashboard. Valid values:
	//
	// *   `dash-db`: a dashboard
	// *   `dash-folder`: a folder that can include a dashboard
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The unique identifier of a dashboard when multiple Grafana dashboards were installed. It is a unique business ID displayed on the page.
	Uid *string `json:"Uid,omitempty" xml:"Uid,omitempty"`
	// The complete URL of the Grafana dashboard.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
	// The version of the Grafana dashboard. The combination of version and name uniquely identifies a dashboard.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s ListDashboardsResponseBodyDashboardVos) String() string {
	return tea.Prettify(s)
}

func (s ListDashboardsResponseBodyDashboardVos) GoString() string {
	return s.String()
}

func (s *ListDashboardsResponseBodyDashboardVos) SetDashboardType(v string) *ListDashboardsResponseBodyDashboardVos {
	s.DashboardType = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVos) SetExporter(v string) *ListDashboardsResponseBodyDashboardVos {
	s.Exporter = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVos) SetHttpUrl(v string) *ListDashboardsResponseBodyDashboardVos {
	s.HttpUrl = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVos) SetHttpsUrl(v string) *ListDashboardsResponseBodyDashboardVos {
	s.HttpsUrl = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVos) SetI18nChild(v *ListDashboardsResponseBodyDashboardVosI18nChild) *ListDashboardsResponseBodyDashboardVos {
	s.I18nChild = v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVos) SetId(v string) *ListDashboardsResponseBodyDashboardVos {
	s.Id = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVos) SetIsArmsExporter(v bool) *ListDashboardsResponseBodyDashboardVos {
	s.IsArmsExporter = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVos) SetKind(v string) *ListDashboardsResponseBodyDashboardVos {
	s.Kind = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVos) SetLanguage(v string) *ListDashboardsResponseBodyDashboardVos {
	s.Language = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVos) SetName(v string) *ListDashboardsResponseBodyDashboardVos {
	s.Name = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVos) SetNeedUpdate(v bool) *ListDashboardsResponseBodyDashboardVos {
	s.NeedUpdate = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVos) SetTags(v []*string) *ListDashboardsResponseBodyDashboardVos {
	s.Tags = v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVos) SetTime(v string) *ListDashboardsResponseBodyDashboardVos {
	s.Time = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVos) SetTitle(v string) *ListDashboardsResponseBodyDashboardVos {
	s.Title = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVos) SetType(v string) *ListDashboardsResponseBodyDashboardVos {
	s.Type = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVos) SetUid(v string) *ListDashboardsResponseBodyDashboardVos {
	s.Uid = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVos) SetUrl(v string) *ListDashboardsResponseBodyDashboardVos {
	s.Url = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVos) SetVersion(v string) *ListDashboardsResponseBodyDashboardVos {
	s.Version = &v
	return s
}

type ListDashboardsResponseBodyDashboardVosI18nChild struct {
	// The type of the Grafana dashboard. This parameter has the same effect as the Exporter parameter whereas provides clearer implication.
	DashboardType *string `json:"DashboardType,omitempty" xml:"DashboardType,omitempty"`
	// The type of the exporter access source. Valid values:
	//
	// *   Prometheus
	// *   Node
	// *   GPU
	// *   Redis
	// *   MySQL
	// *   Kafka
	// *   NGINX V2
	// *   Nginx
	// *   ZooKeeper
	// *   MongoDB
	// *   RabbitMQ
	// *   PostgreSQL
	// *   Kubernetes
	// *   Client Library
	// *   Elasticsearch
	// *   RocketMQ
	Exporter *string `json:"Exporter,omitempty" xml:"Exporter,omitempty"`
	// The URL of the Grafana dashboard.
	HttpUrl *string `json:"HttpUrl,omitempty" xml:"HttpUrl,omitempty"`
	// The URL of the Grafana dashboard.
	HttpsUrl *string `json:"HttpsUrl,omitempty" xml:"HttpsUrl,omitempty"`
	// The ID of the Grafana dashboard. The value is unique only when you install the Grafana dashboard.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// Indicates whether the exporter was provided by ARMS. Valid values:
	//
	// *   `true`: The exporter is provided by ARMS.
	// *   `false`: The exporter is not provided by ARMS.
	IsArmsExporter *bool `json:"IsArmsExporter,omitempty" xml:"IsArmsExporter,omitempty"`
	// The category of the Grafana dashboard. Valid values: BASIC, THIRD, LIMIT, and CUSTOM.
	Kind *string `json:"Kind,omitempty" xml:"Kind,omitempty"`
	// The language of the Grafana dashboard.
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// The name of the Grafana dashboard. This parameter is different from the **Title** parameter as this parameter cannot be changed.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Indicates whether the Grafana dashboard has a new version that was available for upgrade.
	NeedUpdate *bool `json:"NeedUpdate,omitempty" xml:"NeedUpdate,omitempty"`
	// The tags of the Grafana dashboard.
	Tags []*string `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The timestamp when the Grafana dashboard was created.
	Time *string `json:"Time,omitempty" xml:"Time,omitempty"`
	// The title of the Grafana dashboard.
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The type of the Grafana dashboard. Valid values:
	//
	// *   `dash-db`: a dashboard
	// *   `dash-folder`: a folder that can include a dashboard
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The unique identifier of a dashboard when multiple Grafana dashboards were installed. It is a unique business ID displayed on the page.
	Uid *string `json:"Uid,omitempty" xml:"Uid,omitempty"`
	// The complete URL of the Grafana dashboard.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
	// The version of the Grafana dashboard. The combination of version and name uniquely identifies a dashboard.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s ListDashboardsResponseBodyDashboardVosI18nChild) String() string {
	return tea.Prettify(s)
}

func (s ListDashboardsResponseBodyDashboardVosI18nChild) GoString() string {
	return s.String()
}

func (s *ListDashboardsResponseBodyDashboardVosI18nChild) SetDashboardType(v string) *ListDashboardsResponseBodyDashboardVosI18nChild {
	s.DashboardType = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVosI18nChild) SetExporter(v string) *ListDashboardsResponseBodyDashboardVosI18nChild {
	s.Exporter = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVosI18nChild) SetHttpUrl(v string) *ListDashboardsResponseBodyDashboardVosI18nChild {
	s.HttpUrl = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVosI18nChild) SetHttpsUrl(v string) *ListDashboardsResponseBodyDashboardVosI18nChild {
	s.HttpsUrl = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVosI18nChild) SetId(v string) *ListDashboardsResponseBodyDashboardVosI18nChild {
	s.Id = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVosI18nChild) SetIsArmsExporter(v bool) *ListDashboardsResponseBodyDashboardVosI18nChild {
	s.IsArmsExporter = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVosI18nChild) SetKind(v string) *ListDashboardsResponseBodyDashboardVosI18nChild {
	s.Kind = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVosI18nChild) SetLanguage(v string) *ListDashboardsResponseBodyDashboardVosI18nChild {
	s.Language = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVosI18nChild) SetName(v string) *ListDashboardsResponseBodyDashboardVosI18nChild {
	s.Name = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVosI18nChild) SetNeedUpdate(v bool) *ListDashboardsResponseBodyDashboardVosI18nChild {
	s.NeedUpdate = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVosI18nChild) SetTags(v []*string) *ListDashboardsResponseBodyDashboardVosI18nChild {
	s.Tags = v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVosI18nChild) SetTime(v string) *ListDashboardsResponseBodyDashboardVosI18nChild {
	s.Time = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVosI18nChild) SetTitle(v string) *ListDashboardsResponseBodyDashboardVosI18nChild {
	s.Title = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVosI18nChild) SetType(v string) *ListDashboardsResponseBodyDashboardVosI18nChild {
	s.Type = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVosI18nChild) SetUid(v string) *ListDashboardsResponseBodyDashboardVosI18nChild {
	s.Uid = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVosI18nChild) SetUrl(v string) *ListDashboardsResponseBodyDashboardVosI18nChild {
	s.Url = &v
	return s
}

func (s *ListDashboardsResponseBodyDashboardVosI18nChild) SetVersion(v string) *ListDashboardsResponseBodyDashboardVosI18nChild {
	s.Version = &v
	return s
}

type ListDashboardsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDashboardsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDashboardsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDashboardsResponse) GoString() string {
	return s.String()
}

func (s *ListDashboardsResponse) SetHeaders(v map[string]*string) *ListDashboardsResponse {
	s.Headers = v
	return s
}

func (s *ListDashboardsResponse) SetStatusCode(v int32) *ListDashboardsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDashboardsResponse) SetBody(v *ListDashboardsResponseBody) *ListDashboardsResponse {
	s.Body = v
	return s
}

type ListDashboardsByNameRequest struct {
	ClusterId        *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	ClusterType      *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	DashBoardName    *string `json:"DashBoardName,omitempty" xml:"DashBoardName,omitempty"`
	DashBoardVersion *string `json:"DashBoardVersion,omitempty" xml:"DashBoardVersion,omitempty"`
	DataSourceType   *string `json:"DataSourceType,omitempty" xml:"DataSourceType,omitempty"`
	GroupName        *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	OnlyQuery        *bool   `json:"OnlyQuery,omitempty" xml:"OnlyQuery,omitempty"`
	ProductCode      *string `json:"ProductCode,omitempty" xml:"ProductCode,omitempty"`
	RegionId         *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListDashboardsByNameRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDashboardsByNameRequest) GoString() string {
	return s.String()
}

func (s *ListDashboardsByNameRequest) SetClusterId(v string) *ListDashboardsByNameRequest {
	s.ClusterId = &v
	return s
}

func (s *ListDashboardsByNameRequest) SetClusterType(v string) *ListDashboardsByNameRequest {
	s.ClusterType = &v
	return s
}

func (s *ListDashboardsByNameRequest) SetDashBoardName(v string) *ListDashboardsByNameRequest {
	s.DashBoardName = &v
	return s
}

func (s *ListDashboardsByNameRequest) SetDashBoardVersion(v string) *ListDashboardsByNameRequest {
	s.DashBoardVersion = &v
	return s
}

func (s *ListDashboardsByNameRequest) SetDataSourceType(v string) *ListDashboardsByNameRequest {
	s.DataSourceType = &v
	return s
}

func (s *ListDashboardsByNameRequest) SetGroupName(v string) *ListDashboardsByNameRequest {
	s.GroupName = &v
	return s
}

func (s *ListDashboardsByNameRequest) SetOnlyQuery(v bool) *ListDashboardsByNameRequest {
	s.OnlyQuery = &v
	return s
}

func (s *ListDashboardsByNameRequest) SetProductCode(v string) *ListDashboardsByNameRequest {
	s.ProductCode = &v
	return s
}

func (s *ListDashboardsByNameRequest) SetRegionId(v string) *ListDashboardsByNameRequest {
	s.RegionId = &v
	return s
}

type ListDashboardsByNameResponseBody struct {
	// 状态码。说明 200表示成功。
	Code *int32  `json:"Code,omitempty" xml:"Code,omitempty"`
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// 返回结果的提示信息。
	Message   *string `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListDashboardsByNameResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDashboardsByNameResponseBody) GoString() string {
	return s.String()
}

func (s *ListDashboardsByNameResponseBody) SetCode(v int32) *ListDashboardsByNameResponseBody {
	s.Code = &v
	return s
}

func (s *ListDashboardsByNameResponseBody) SetData(v string) *ListDashboardsByNameResponseBody {
	s.Data = &v
	return s
}

func (s *ListDashboardsByNameResponseBody) SetMessage(v string) *ListDashboardsByNameResponseBody {
	s.Message = &v
	return s
}

func (s *ListDashboardsByNameResponseBody) SetRequestId(v string) *ListDashboardsByNameResponseBody {
	s.RequestId = &v
	return s
}

type ListDashboardsByNameResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDashboardsByNameResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDashboardsByNameResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDashboardsByNameResponse) GoString() string {
	return s.String()
}

func (s *ListDashboardsByNameResponse) SetHeaders(v map[string]*string) *ListDashboardsByNameResponse {
	s.Headers = v
	return s
}

func (s *ListDashboardsByNameResponse) SetStatusCode(v int32) *ListDashboardsByNameResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDashboardsByNameResponse) SetBody(v *ListDashboardsByNameResponseBody) *ListDashboardsByNameResponse {
	s.Body = v
	return s
}

type ListDispatchRuleRequest struct {
	Name     *string `json:"Name,omitempty" xml:"Name,omitempty"`
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	System   *bool   `json:"System,omitempty" xml:"System,omitempty"`
}

func (s ListDispatchRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDispatchRuleRequest) GoString() string {
	return s.String()
}

func (s *ListDispatchRuleRequest) SetName(v string) *ListDispatchRuleRequest {
	s.Name = &v
	return s
}

func (s *ListDispatchRuleRequest) SetRegionId(v string) *ListDispatchRuleRequest {
	s.RegionId = &v
	return s
}

func (s *ListDispatchRuleRequest) SetSystem(v bool) *ListDispatchRuleRequest {
	s.System = &v
	return s
}

type ListDispatchRuleResponseBody struct {
	DispatchRules []*ListDispatchRuleResponseBodyDispatchRules `json:"DispatchRules,omitempty" xml:"DispatchRules,omitempty" type:"Repeated"`
	RequestId     *string                                      `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListDispatchRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDispatchRuleResponseBody) GoString() string {
	return s.String()
}

func (s *ListDispatchRuleResponseBody) SetDispatchRules(v []*ListDispatchRuleResponseBodyDispatchRules) *ListDispatchRuleResponseBody {
	s.DispatchRules = v
	return s
}

func (s *ListDispatchRuleResponseBody) SetRequestId(v string) *ListDispatchRuleResponseBody {
	s.RequestId = &v
	return s
}

type ListDispatchRuleResponseBodyDispatchRules struct {
	Name   *string `json:"Name,omitempty" xml:"Name,omitempty"`
	RuleId *int64  `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	State  *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s ListDispatchRuleResponseBodyDispatchRules) String() string {
	return tea.Prettify(s)
}

func (s ListDispatchRuleResponseBodyDispatchRules) GoString() string {
	return s.String()
}

func (s *ListDispatchRuleResponseBodyDispatchRules) SetName(v string) *ListDispatchRuleResponseBodyDispatchRules {
	s.Name = &v
	return s
}

func (s *ListDispatchRuleResponseBodyDispatchRules) SetRuleId(v int64) *ListDispatchRuleResponseBodyDispatchRules {
	s.RuleId = &v
	return s
}

func (s *ListDispatchRuleResponseBodyDispatchRules) SetState(v string) *ListDispatchRuleResponseBodyDispatchRules {
	s.State = &v
	return s
}

type ListDispatchRuleResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDispatchRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDispatchRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDispatchRuleResponse) GoString() string {
	return s.String()
}

func (s *ListDispatchRuleResponse) SetHeaders(v map[string]*string) *ListDispatchRuleResponse {
	s.Headers = v
	return s
}

func (s *ListDispatchRuleResponse) SetStatusCode(v int32) *ListDispatchRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDispatchRuleResponse) SetBody(v *ListDispatchRuleResponseBody) *ListDispatchRuleResponse {
	s.Body = v
	return s
}

type ListEnvCustomJobsRequest struct {
	// Specifies whether to return the encrypted YAML string.
	EncryptYaml *bool `json:"EncryptYaml,omitempty" xml:"EncryptYaml,omitempty"`
	// The ID of the environment instance.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListEnvCustomJobsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEnvCustomJobsRequest) GoString() string {
	return s.String()
}

func (s *ListEnvCustomJobsRequest) SetEncryptYaml(v bool) *ListEnvCustomJobsRequest {
	s.EncryptYaml = &v
	return s
}

func (s *ListEnvCustomJobsRequest) SetEnvironmentId(v string) *ListEnvCustomJobsRequest {
	s.EnvironmentId = &v
	return s
}

func (s *ListEnvCustomJobsRequest) SetRegionId(v string) *ListEnvCustomJobsRequest {
	s.RegionId = &v
	return s
}

type ListEnvCustomJobsResponseBody struct {
	// The HTTP status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned struct.
	Data []*ListEnvCustomJobsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListEnvCustomJobsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListEnvCustomJobsResponseBody) GoString() string {
	return s.String()
}

func (s *ListEnvCustomJobsResponseBody) SetCode(v int32) *ListEnvCustomJobsResponseBody {
	s.Code = &v
	return s
}

func (s *ListEnvCustomJobsResponseBody) SetData(v []*ListEnvCustomJobsResponseBodyData) *ListEnvCustomJobsResponseBody {
	s.Data = v
	return s
}

func (s *ListEnvCustomJobsResponseBody) SetMessage(v string) *ListEnvCustomJobsResponseBody {
	s.Message = &v
	return s
}

func (s *ListEnvCustomJobsResponseBody) SetRequestId(v string) *ListEnvCustomJobsResponseBody {
	s.RequestId = &v
	return s
}

type ListEnvCustomJobsResponseBodyData struct {
	// The name of the component to which the custom job belongs.
	AddonName *string `json:"AddonName,omitempty" xml:"AddonName,omitempty"`
	// The instance name of the component.
	AddonReleaseName *string `json:"AddonReleaseName,omitempty" xml:"AddonReleaseName,omitempty"`
	// The version of the component.
	AddonVersion *string `json:"AddonVersion,omitempty" xml:"AddonVersion,omitempty"`
	// If the request parameter EncryptYaml is set to true, a Base64-encoded YAML string is returned. Otherwise, a plaintext YAML string is returned.
	ConfigYaml *string `json:"ConfigYaml,omitempty" xml:"ConfigYaml,omitempty"`
	// The time when the custom job was created. The value of this parameter is a timestamp.
	CreationTimestamp *string `json:"CreationTimestamp,omitempty" xml:"CreationTimestamp,omitempty"`
	// The name of the custom job.
	CustomJobName *string `json:"CustomJobName,omitempty" xml:"CustomJobName,omitempty"`
	// The ID of the environment instance.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The capture configurations.
	ScrapeConfigs []*ListEnvCustomJobsResponseBodyDataScrapeConfigs `json:"ScrapeConfigs,omitempty" xml:"ScrapeConfigs,omitempty" type:"Repeated"`
	// The status of the custom job.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListEnvCustomJobsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListEnvCustomJobsResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListEnvCustomJobsResponseBodyData) SetAddonName(v string) *ListEnvCustomJobsResponseBodyData {
	s.AddonName = &v
	return s
}

func (s *ListEnvCustomJobsResponseBodyData) SetAddonReleaseName(v string) *ListEnvCustomJobsResponseBodyData {
	s.AddonReleaseName = &v
	return s
}

func (s *ListEnvCustomJobsResponseBodyData) SetAddonVersion(v string) *ListEnvCustomJobsResponseBodyData {
	s.AddonVersion = &v
	return s
}

func (s *ListEnvCustomJobsResponseBodyData) SetConfigYaml(v string) *ListEnvCustomJobsResponseBodyData {
	s.ConfigYaml = &v
	return s
}

func (s *ListEnvCustomJobsResponseBodyData) SetCreationTimestamp(v string) *ListEnvCustomJobsResponseBodyData {
	s.CreationTimestamp = &v
	return s
}

func (s *ListEnvCustomJobsResponseBodyData) SetCustomJobName(v string) *ListEnvCustomJobsResponseBodyData {
	s.CustomJobName = &v
	return s
}

func (s *ListEnvCustomJobsResponseBodyData) SetEnvironmentId(v string) *ListEnvCustomJobsResponseBodyData {
	s.EnvironmentId = &v
	return s
}

func (s *ListEnvCustomJobsResponseBodyData) SetRegionId(v string) *ListEnvCustomJobsResponseBodyData {
	s.RegionId = &v
	return s
}

func (s *ListEnvCustomJobsResponseBodyData) SetScrapeConfigs(v []*ListEnvCustomJobsResponseBodyDataScrapeConfigs) *ListEnvCustomJobsResponseBodyData {
	s.ScrapeConfigs = v
	return s
}

func (s *ListEnvCustomJobsResponseBodyData) SetStatus(v string) *ListEnvCustomJobsResponseBodyData {
	s.Status = &v
	return s
}

type ListEnvCustomJobsResponseBodyDataScrapeConfigs struct {
	// The name of the job.
	JobName *string `json:"JobName,omitempty" xml:"JobName,omitempty"`
	// The path of the metric.
	MetricsPath *string `json:"MetricsPath,omitempty" xml:"MetricsPath,omitempty"`
	// The service discovery methods.
	ScrapeDiscoverys []*string `json:"ScrapeDiscoverys,omitempty" xml:"ScrapeDiscoverys,omitempty" type:"Repeated"`
	// The capture interval.
	ScrapeInterval *string `json:"ScrapeInterval,omitempty" xml:"ScrapeInterval,omitempty"`
}

func (s ListEnvCustomJobsResponseBodyDataScrapeConfigs) String() string {
	return tea.Prettify(s)
}

func (s ListEnvCustomJobsResponseBodyDataScrapeConfigs) GoString() string {
	return s.String()
}

func (s *ListEnvCustomJobsResponseBodyDataScrapeConfigs) SetJobName(v string) *ListEnvCustomJobsResponseBodyDataScrapeConfigs {
	s.JobName = &v
	return s
}

func (s *ListEnvCustomJobsResponseBodyDataScrapeConfigs) SetMetricsPath(v string) *ListEnvCustomJobsResponseBodyDataScrapeConfigs {
	s.MetricsPath = &v
	return s
}

func (s *ListEnvCustomJobsResponseBodyDataScrapeConfigs) SetScrapeDiscoverys(v []*string) *ListEnvCustomJobsResponseBodyDataScrapeConfigs {
	s.ScrapeDiscoverys = v
	return s
}

func (s *ListEnvCustomJobsResponseBodyDataScrapeConfigs) SetScrapeInterval(v string) *ListEnvCustomJobsResponseBodyDataScrapeConfigs {
	s.ScrapeInterval = &v
	return s
}

type ListEnvCustomJobsResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListEnvCustomJobsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListEnvCustomJobsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListEnvCustomJobsResponse) GoString() string {
	return s.String()
}

func (s *ListEnvCustomJobsResponse) SetHeaders(v map[string]*string) *ListEnvCustomJobsResponse {
	s.Headers = v
	return s
}

func (s *ListEnvCustomJobsResponse) SetStatusCode(v int32) *ListEnvCustomJobsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListEnvCustomJobsResponse) SetBody(v *ListEnvCustomJobsResponseBody) *ListEnvCustomJobsResponse {
	s.Body = v
	return s
}

type ListEnvPodMonitorsRequest struct {
	// The environment ID.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListEnvPodMonitorsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEnvPodMonitorsRequest) GoString() string {
	return s.String()
}

func (s *ListEnvPodMonitorsRequest) SetEnvironmentId(v string) *ListEnvPodMonitorsRequest {
	s.EnvironmentId = &v
	return s
}

func (s *ListEnvPodMonitorsRequest) SetRegionId(v string) *ListEnvPodMonitorsRequest {
	s.RegionId = &v
	return s
}

type ListEnvPodMonitorsResponseBody struct {
	// The HTTP status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result of the operation.
	Data []*ListEnvPodMonitorsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListEnvPodMonitorsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListEnvPodMonitorsResponseBody) GoString() string {
	return s.String()
}

func (s *ListEnvPodMonitorsResponseBody) SetCode(v int32) *ListEnvPodMonitorsResponseBody {
	s.Code = &v
	return s
}

func (s *ListEnvPodMonitorsResponseBody) SetData(v []*ListEnvPodMonitorsResponseBodyData) *ListEnvPodMonitorsResponseBody {
	s.Data = v
	return s
}

func (s *ListEnvPodMonitorsResponseBody) SetMessage(v string) *ListEnvPodMonitorsResponseBody {
	s.Message = &v
	return s
}

func (s *ListEnvPodMonitorsResponseBody) SetRequestId(v string) *ListEnvPodMonitorsResponseBody {
	s.RequestId = &v
	return s
}

type ListEnvPodMonitorsResponseBodyData struct {
	// The name of the component to which the PodMonitor belongs.
	AddonName *string `json:"AddonName,omitempty" xml:"AddonName,omitempty"`
	// The instance name of the component.
	AddonReleaseName *string `json:"AddonReleaseName,omitempty" xml:"AddonReleaseName,omitempty"`
	// The version of the component.
	AddonVersion *string `json:"AddonVersion,omitempty" xml:"AddonVersion,omitempty"`
	// The YAML configuration string.
	ConfigYaml *string `json:"ConfigYaml,omitempty" xml:"ConfigYaml,omitempty"`
	// The time when the PodMonitor was created. The value of this parameter is a timestamp.
	CreationTimestamp *string `json:"CreationTimestamp,omitempty" xml:"CreationTimestamp,omitempty"`
	// The endpoints of the PodMonitor.
	Endpoints []*ListEnvPodMonitorsResponseBodyDataEndpoints `json:"Endpoints,omitempty" xml:"Endpoints,omitempty" type:"Repeated"`
	// The environment ID.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The name of the PodMonitor.
	PodMonitorName *string `json:"PodMonitorName,omitempty" xml:"PodMonitorName,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The status of the PodMonitor.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListEnvPodMonitorsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListEnvPodMonitorsResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListEnvPodMonitorsResponseBodyData) SetAddonName(v string) *ListEnvPodMonitorsResponseBodyData {
	s.AddonName = &v
	return s
}

func (s *ListEnvPodMonitorsResponseBodyData) SetAddonReleaseName(v string) *ListEnvPodMonitorsResponseBodyData {
	s.AddonReleaseName = &v
	return s
}

func (s *ListEnvPodMonitorsResponseBodyData) SetAddonVersion(v string) *ListEnvPodMonitorsResponseBodyData {
	s.AddonVersion = &v
	return s
}

func (s *ListEnvPodMonitorsResponseBodyData) SetConfigYaml(v string) *ListEnvPodMonitorsResponseBodyData {
	s.ConfigYaml = &v
	return s
}

func (s *ListEnvPodMonitorsResponseBodyData) SetCreationTimestamp(v string) *ListEnvPodMonitorsResponseBodyData {
	s.CreationTimestamp = &v
	return s
}

func (s *ListEnvPodMonitorsResponseBodyData) SetEndpoints(v []*ListEnvPodMonitorsResponseBodyDataEndpoints) *ListEnvPodMonitorsResponseBodyData {
	s.Endpoints = v
	return s
}

func (s *ListEnvPodMonitorsResponseBodyData) SetEnvironmentId(v string) *ListEnvPodMonitorsResponseBodyData {
	s.EnvironmentId = &v
	return s
}

func (s *ListEnvPodMonitorsResponseBodyData) SetNamespace(v string) *ListEnvPodMonitorsResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *ListEnvPodMonitorsResponseBodyData) SetPodMonitorName(v string) *ListEnvPodMonitorsResponseBodyData {
	s.PodMonitorName = &v
	return s
}

func (s *ListEnvPodMonitorsResponseBodyData) SetRegionId(v string) *ListEnvPodMonitorsResponseBodyData {
	s.RegionId = &v
	return s
}

func (s *ListEnvPodMonitorsResponseBodyData) SetStatus(v string) *ListEnvPodMonitorsResponseBodyData {
	s.Status = &v
	return s
}

type ListEnvPodMonitorsResponseBodyDataEndpoints struct {
	// The collection interval.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The number of pods that match the PodMonitor endpoint.
	MatchedTargetCount *int32 `json:"MatchedTargetCount,omitempty" xml:"MatchedTargetCount,omitempty"`
	// The collection path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The external port.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The destination port.
	TargetPort *int32 `json:"TargetPort,omitempty" xml:"TargetPort,omitempty"`
}

func (s ListEnvPodMonitorsResponseBodyDataEndpoints) String() string {
	return tea.Prettify(s)
}

func (s ListEnvPodMonitorsResponseBodyDataEndpoints) GoString() string {
	return s.String()
}

func (s *ListEnvPodMonitorsResponseBodyDataEndpoints) SetInterval(v string) *ListEnvPodMonitorsResponseBodyDataEndpoints {
	s.Interval = &v
	return s
}

func (s *ListEnvPodMonitorsResponseBodyDataEndpoints) SetMatchedTargetCount(v int32) *ListEnvPodMonitorsResponseBodyDataEndpoints {
	s.MatchedTargetCount = &v
	return s
}

func (s *ListEnvPodMonitorsResponseBodyDataEndpoints) SetPath(v string) *ListEnvPodMonitorsResponseBodyDataEndpoints {
	s.Path = &v
	return s
}

func (s *ListEnvPodMonitorsResponseBodyDataEndpoints) SetPort(v string) *ListEnvPodMonitorsResponseBodyDataEndpoints {
	s.Port = &v
	return s
}

func (s *ListEnvPodMonitorsResponseBodyDataEndpoints) SetTargetPort(v int32) *ListEnvPodMonitorsResponseBodyDataEndpoints {
	s.TargetPort = &v
	return s
}

type ListEnvPodMonitorsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListEnvPodMonitorsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListEnvPodMonitorsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListEnvPodMonitorsResponse) GoString() string {
	return s.String()
}

func (s *ListEnvPodMonitorsResponse) SetHeaders(v map[string]*string) *ListEnvPodMonitorsResponse {
	s.Headers = v
	return s
}

func (s *ListEnvPodMonitorsResponse) SetStatusCode(v int32) *ListEnvPodMonitorsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListEnvPodMonitorsResponse) SetBody(v *ListEnvPodMonitorsResponseBody) *ListEnvPodMonitorsResponse {
	s.Body = v
	return s
}

type ListEnvServiceMonitorsRequest struct {
	// The environment ID.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListEnvServiceMonitorsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEnvServiceMonitorsRequest) GoString() string {
	return s.String()
}

func (s *ListEnvServiceMonitorsRequest) SetEnvironmentId(v string) *ListEnvServiceMonitorsRequest {
	s.EnvironmentId = &v
	return s
}

func (s *ListEnvServiceMonitorsRequest) SetRegionId(v string) *ListEnvServiceMonitorsRequest {
	s.RegionId = &v
	return s
}

type ListEnvServiceMonitorsResponseBody struct {
	// The HTTP status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned struct.
	Data []*ListEnvServiceMonitorsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListEnvServiceMonitorsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListEnvServiceMonitorsResponseBody) GoString() string {
	return s.String()
}

func (s *ListEnvServiceMonitorsResponseBody) SetCode(v int32) *ListEnvServiceMonitorsResponseBody {
	s.Code = &v
	return s
}

func (s *ListEnvServiceMonitorsResponseBody) SetData(v []*ListEnvServiceMonitorsResponseBodyData) *ListEnvServiceMonitorsResponseBody {
	s.Data = v
	return s
}

func (s *ListEnvServiceMonitorsResponseBody) SetMessage(v string) *ListEnvServiceMonitorsResponseBody {
	s.Message = &v
	return s
}

func (s *ListEnvServiceMonitorsResponseBody) SetRequestId(v string) *ListEnvServiceMonitorsResponseBody {
	s.RequestId = &v
	return s
}

type ListEnvServiceMonitorsResponseBodyData struct {
	// The name of the component to which the ServiceMonitor belongs.
	AddonName *string `json:"AddonName,omitempty" xml:"AddonName,omitempty"`
	// The instance name of the component.
	AddonReleaseName *string `json:"AddonReleaseName,omitempty" xml:"AddonReleaseName,omitempty"`
	// The version of the component.
	AddonVersion *string `json:"AddonVersion,omitempty" xml:"AddonVersion,omitempty"`
	// The YAML configuration string.
	ConfigYaml *string `json:"ConfigYaml,omitempty" xml:"ConfigYaml,omitempty"`
	// The time when the ServiceMonitor was created. The value of this parameter is a timestamp.
	CreationTimestamp *string `json:"CreationTimestamp,omitempty" xml:"CreationTimestamp,omitempty"`
	// The endpoints of the ServiceMonitor.
	Endpoints []*ListEnvServiceMonitorsResponseBodyDataEndpoints `json:"Endpoints,omitempty" xml:"Endpoints,omitempty" type:"Repeated"`
	// The environment ID.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The number of matched services.
	MatchedServiceCount *int32 `json:"MatchedServiceCount,omitempty" xml:"MatchedServiceCount,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The name of the ServiceMonitor.
	ServiceMonitorName *string `json:"ServiceMonitorName,omitempty" xml:"ServiceMonitorName,omitempty"`
	// The status of the ServiceMonitor.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListEnvServiceMonitorsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListEnvServiceMonitorsResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListEnvServiceMonitorsResponseBodyData) SetAddonName(v string) *ListEnvServiceMonitorsResponseBodyData {
	s.AddonName = &v
	return s
}

func (s *ListEnvServiceMonitorsResponseBodyData) SetAddonReleaseName(v string) *ListEnvServiceMonitorsResponseBodyData {
	s.AddonReleaseName = &v
	return s
}

func (s *ListEnvServiceMonitorsResponseBodyData) SetAddonVersion(v string) *ListEnvServiceMonitorsResponseBodyData {
	s.AddonVersion = &v
	return s
}

func (s *ListEnvServiceMonitorsResponseBodyData) SetConfigYaml(v string) *ListEnvServiceMonitorsResponseBodyData {
	s.ConfigYaml = &v
	return s
}

func (s *ListEnvServiceMonitorsResponseBodyData) SetCreationTimestamp(v string) *ListEnvServiceMonitorsResponseBodyData {
	s.CreationTimestamp = &v
	return s
}

func (s *ListEnvServiceMonitorsResponseBodyData) SetEndpoints(v []*ListEnvServiceMonitorsResponseBodyDataEndpoints) *ListEnvServiceMonitorsResponseBodyData {
	s.Endpoints = v
	return s
}

func (s *ListEnvServiceMonitorsResponseBodyData) SetEnvironmentId(v string) *ListEnvServiceMonitorsResponseBodyData {
	s.EnvironmentId = &v
	return s
}

func (s *ListEnvServiceMonitorsResponseBodyData) SetMatchedServiceCount(v int32) *ListEnvServiceMonitorsResponseBodyData {
	s.MatchedServiceCount = &v
	return s
}

func (s *ListEnvServiceMonitorsResponseBodyData) SetNamespace(v string) *ListEnvServiceMonitorsResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *ListEnvServiceMonitorsResponseBodyData) SetRegionId(v string) *ListEnvServiceMonitorsResponseBodyData {
	s.RegionId = &v
	return s
}

func (s *ListEnvServiceMonitorsResponseBodyData) SetServiceMonitorName(v string) *ListEnvServiceMonitorsResponseBodyData {
	s.ServiceMonitorName = &v
	return s
}

func (s *ListEnvServiceMonitorsResponseBodyData) SetStatus(v string) *ListEnvServiceMonitorsResponseBodyData {
	s.Status = &v
	return s
}

type ListEnvServiceMonitorsResponseBodyDataEndpoints struct {
	// The collection interval.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The number of pods that match the ServiceMonitor endpoint.
	MatchedTargetCount *int32 `json:"MatchedTargetCount,omitempty" xml:"MatchedTargetCount,omitempty"`
	// The collection path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The external port.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The destination port.
	TargetPort *int32 `json:"TargetPort,omitempty" xml:"TargetPort,omitempty"`
}

func (s ListEnvServiceMonitorsResponseBodyDataEndpoints) String() string {
	return tea.Prettify(s)
}

func (s ListEnvServiceMonitorsResponseBodyDataEndpoints) GoString() string {
	return s.String()
}

func (s *ListEnvServiceMonitorsResponseBodyDataEndpoints) SetInterval(v string) *ListEnvServiceMonitorsResponseBodyDataEndpoints {
	s.Interval = &v
	return s
}

func (s *ListEnvServiceMonitorsResponseBodyDataEndpoints) SetMatchedTargetCount(v int32) *ListEnvServiceMonitorsResponseBodyDataEndpoints {
	s.MatchedTargetCount = &v
	return s
}

func (s *ListEnvServiceMonitorsResponseBodyDataEndpoints) SetPath(v string) *ListEnvServiceMonitorsResponseBodyDataEndpoints {
	s.Path = &v
	return s
}

func (s *ListEnvServiceMonitorsResponseBodyDataEndpoints) SetPort(v string) *ListEnvServiceMonitorsResponseBodyDataEndpoints {
	s.Port = &v
	return s
}

func (s *ListEnvServiceMonitorsResponseBodyDataEndpoints) SetTargetPort(v int32) *ListEnvServiceMonitorsResponseBodyDataEndpoints {
	s.TargetPort = &v
	return s
}

type ListEnvServiceMonitorsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListEnvServiceMonitorsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListEnvServiceMonitorsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListEnvServiceMonitorsResponse) GoString() string {
	return s.String()
}

func (s *ListEnvServiceMonitorsResponse) SetHeaders(v map[string]*string) *ListEnvServiceMonitorsResponse {
	s.Headers = v
	return s
}

func (s *ListEnvServiceMonitorsResponse) SetStatusCode(v int32) *ListEnvServiceMonitorsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListEnvServiceMonitorsResponse) SetBody(v *ListEnvServiceMonitorsResponseBody) *ListEnvServiceMonitorsResponse {
	s.Body = v
	return s
}

type ListEnvironmentFeaturesRequest struct {
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	RegionId      *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListEnvironmentFeaturesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEnvironmentFeaturesRequest) GoString() string {
	return s.String()
}

func (s *ListEnvironmentFeaturesRequest) SetEnvironmentId(v string) *ListEnvironmentFeaturesRequest {
	s.EnvironmentId = &v
	return s
}

func (s *ListEnvironmentFeaturesRequest) SetRegionId(v string) *ListEnvironmentFeaturesRequest {
	s.RegionId = &v
	return s
}

type ListEnvironmentFeaturesResponseBody struct {
	Code    *int32                                     `json:"Code,omitempty" xml:"Code,omitempty"`
	Data    []*ListEnvironmentFeaturesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	Message *string                                    `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListEnvironmentFeaturesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListEnvironmentFeaturesResponseBody) GoString() string {
	return s.String()
}

func (s *ListEnvironmentFeaturesResponseBody) SetCode(v int32) *ListEnvironmentFeaturesResponseBody {
	s.Code = &v
	return s
}

func (s *ListEnvironmentFeaturesResponseBody) SetData(v []*ListEnvironmentFeaturesResponseBodyData) *ListEnvironmentFeaturesResponseBody {
	s.Data = v
	return s
}

func (s *ListEnvironmentFeaturesResponseBody) SetMessage(v string) *ListEnvironmentFeaturesResponseBody {
	s.Message = &v
	return s
}

func (s *ListEnvironmentFeaturesResponseBody) SetRequestId(v string) *ListEnvironmentFeaturesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListEnvironmentFeaturesResponseBody) SetSuccess(v bool) *ListEnvironmentFeaturesResponseBody {
	s.Success = &v
	return s
}

type ListEnvironmentFeaturesResponseBodyData struct {
	Alias         *string            `json:"Alias,omitempty" xml:"Alias,omitempty"`
	Config        map[string]*string `json:"Config,omitempty" xml:"Config,omitempty"`
	Description   *string            `json:"Description,omitempty" xml:"Description,omitempty"`
	EnvironmentId *string            `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	Icon          *string            `json:"Icon,omitempty" xml:"Icon,omitempty"`
	Language      *string            `json:"Language,omitempty" xml:"Language,omitempty"`
	LatestVersion *string            `json:"LatestVersion,omitempty" xml:"LatestVersion,omitempty"`
	Name          *string            `json:"Name,omitempty" xml:"Name,omitempty"`
	Status        *string            `json:"Status,omitempty" xml:"Status,omitempty"`
	Version       *string            `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s ListEnvironmentFeaturesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListEnvironmentFeaturesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListEnvironmentFeaturesResponseBodyData) SetAlias(v string) *ListEnvironmentFeaturesResponseBodyData {
	s.Alias = &v
	return s
}

func (s *ListEnvironmentFeaturesResponseBodyData) SetConfig(v map[string]*string) *ListEnvironmentFeaturesResponseBodyData {
	s.Config = v
	return s
}

func (s *ListEnvironmentFeaturesResponseBodyData) SetDescription(v string) *ListEnvironmentFeaturesResponseBodyData {
	s.Description = &v
	return s
}

func (s *ListEnvironmentFeaturesResponseBodyData) SetEnvironmentId(v string) *ListEnvironmentFeaturesResponseBodyData {
	s.EnvironmentId = &v
	return s
}

func (s *ListEnvironmentFeaturesResponseBodyData) SetIcon(v string) *ListEnvironmentFeaturesResponseBodyData {
	s.Icon = &v
	return s
}

func (s *ListEnvironmentFeaturesResponseBodyData) SetLanguage(v string) *ListEnvironmentFeaturesResponseBodyData {
	s.Language = &v
	return s
}

func (s *ListEnvironmentFeaturesResponseBodyData) SetLatestVersion(v string) *ListEnvironmentFeaturesResponseBodyData {
	s.LatestVersion = &v
	return s
}

func (s *ListEnvironmentFeaturesResponseBodyData) SetName(v string) *ListEnvironmentFeaturesResponseBodyData {
	s.Name = &v
	return s
}

func (s *ListEnvironmentFeaturesResponseBodyData) SetStatus(v string) *ListEnvironmentFeaturesResponseBodyData {
	s.Status = &v
	return s
}

func (s *ListEnvironmentFeaturesResponseBodyData) SetVersion(v string) *ListEnvironmentFeaturesResponseBodyData {
	s.Version = &v
	return s
}

type ListEnvironmentFeaturesResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListEnvironmentFeaturesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListEnvironmentFeaturesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListEnvironmentFeaturesResponse) GoString() string {
	return s.String()
}

func (s *ListEnvironmentFeaturesResponse) SetHeaders(v map[string]*string) *ListEnvironmentFeaturesResponse {
	s.Headers = v
	return s
}

func (s *ListEnvironmentFeaturesResponse) SetStatusCode(v int32) *ListEnvironmentFeaturesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListEnvironmentFeaturesResponse) SetBody(v *ListEnvironmentFeaturesResponseBody) *ListEnvironmentFeaturesResponse {
	s.Body = v
	return s
}

type ListEnvironmentsRequest struct {
	// Name of Addon.
	AddonName *string `json:"AddonName,omitempty" xml:"AddonName,omitempty"`
	// Environment type, AddonName or EnvironmentType must be at least one.
	EnvironmentType *string `json:"EnvironmentType,omitempty" xml:"EnvironmentType,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Resource tag list.
	Tag []*ListEnvironmentsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s ListEnvironmentsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEnvironmentsRequest) GoString() string {
	return s.String()
}

func (s *ListEnvironmentsRequest) SetAddonName(v string) *ListEnvironmentsRequest {
	s.AddonName = &v
	return s
}

func (s *ListEnvironmentsRequest) SetEnvironmentType(v string) *ListEnvironmentsRequest {
	s.EnvironmentType = &v
	return s
}

func (s *ListEnvironmentsRequest) SetRegionId(v string) *ListEnvironmentsRequest {
	s.RegionId = &v
	return s
}

func (s *ListEnvironmentsRequest) SetResourceGroupId(v string) *ListEnvironmentsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListEnvironmentsRequest) SetTag(v []*ListEnvironmentsRequestTag) *ListEnvironmentsRequest {
	s.Tag = v
	return s
}

type ListEnvironmentsRequestTag struct {
	// Tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// Tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListEnvironmentsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListEnvironmentsRequestTag) GoString() string {
	return s.String()
}

func (s *ListEnvironmentsRequestTag) SetKey(v string) *ListEnvironmentsRequestTag {
	s.Key = &v
	return s
}

func (s *ListEnvironmentsRequestTag) SetValue(v string) *ListEnvironmentsRequestTag {
	s.Value = &v
	return s
}

type ListEnvironmentsShrinkRequest struct {
	// Name of Addon.
	AddonName *string `json:"AddonName,omitempty" xml:"AddonName,omitempty"`
	// Environment type, AddonName or EnvironmentType must be at least one.
	EnvironmentType *string `json:"EnvironmentType,omitempty" xml:"EnvironmentType,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Resource tag list.
	TagShrink *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s ListEnvironmentsShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEnvironmentsShrinkRequest) GoString() string {
	return s.String()
}

func (s *ListEnvironmentsShrinkRequest) SetAddonName(v string) *ListEnvironmentsShrinkRequest {
	s.AddonName = &v
	return s
}

func (s *ListEnvironmentsShrinkRequest) SetEnvironmentType(v string) *ListEnvironmentsShrinkRequest {
	s.EnvironmentType = &v
	return s
}

func (s *ListEnvironmentsShrinkRequest) SetRegionId(v string) *ListEnvironmentsShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *ListEnvironmentsShrinkRequest) SetResourceGroupId(v string) *ListEnvironmentsShrinkRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListEnvironmentsShrinkRequest) SetTagShrink(v string) *ListEnvironmentsShrinkRequest {
	s.TagShrink = &v
	return s
}

type ListEnvironmentsResponseBody struct {
	// Status code: 200 indicates success.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned message.
	Data *ListEnvironmentsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`
	// *   `false`
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListEnvironmentsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListEnvironmentsResponseBody) GoString() string {
	return s.String()
}

func (s *ListEnvironmentsResponseBody) SetCode(v int32) *ListEnvironmentsResponseBody {
	s.Code = &v
	return s
}

func (s *ListEnvironmentsResponseBody) SetData(v *ListEnvironmentsResponseBodyData) *ListEnvironmentsResponseBody {
	s.Data = v
	return s
}

func (s *ListEnvironmentsResponseBody) SetMessage(v string) *ListEnvironmentsResponseBody {
	s.Message = &v
	return s
}

func (s *ListEnvironmentsResponseBody) SetRequestId(v string) *ListEnvironmentsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListEnvironmentsResponseBody) SetSuccess(v bool) *ListEnvironmentsResponseBody {
	s.Success = &v
	return s
}

type ListEnvironmentsResponseBodyData struct {
	// Environment list.
	Environments []*ListEnvironmentsResponseBodyDataEnvironments `json:"Environments,omitempty" xml:"Environments,omitempty" type:"Repeated"`
	// The total number of entries returned.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListEnvironmentsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListEnvironmentsResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListEnvironmentsResponseBodyData) SetEnvironments(v []*ListEnvironmentsResponseBodyDataEnvironments) *ListEnvironmentsResponseBodyData {
	s.Environments = v
	return s
}

func (s *ListEnvironmentsResponseBodyData) SetTotal(v int64) *ListEnvironmentsResponseBodyData {
	s.Total = &v
	return s
}

type ListEnvironmentsResponseBodyDataEnvironments struct {
	// Addon list.
	Addons []*ListEnvironmentsResponseBodyDataEnvironmentsAddons `json:"Addons,omitempty" xml:"Addons,omitempty" type:"Repeated"`
	// Id of the resource to be bound.
	BindResourceId *string `json:"BindResourceId,omitempty" xml:"BindResourceId,omitempty"`
	// Profile of the resource to be bound.
	BindResourceProfile *string `json:"BindResourceProfile,omitempty" xml:"BindResourceProfile,omitempty"`
	// Type of the resource to be bound.
	BindResourceType *string `json:"BindResourceType,omitempty" xml:"BindResourceType,omitempty"`
	// Bound Vpc IP Cidr.
	BindVpcCidr *string `json:"BindVpcCidr,omitempty" xml:"BindVpcCidr,omitempty"`
	// Create time.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// Created User ID.
	CreatedUserId *string `json:"CreatedUserId,omitempty" xml:"CreatedUserId,omitempty"`
	// Environment ID.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// Environment name.
	EnvironmentName *string `json:"EnvironmentName,omitempty" xml:"EnvironmentName,omitempty"`
	// Environment type.
	EnvironmentType *string `json:"EnvironmentType,omitempty" xml:"EnvironmentType,omitempty"`
	// Featyre list.
	Features []*ListEnvironmentsResponseBodyDataEnvironmentsFeatures `json:"Features,omitempty" xml:"Features,omitempty" type:"Repeated"`
	// Grafana datasource UID.
	GrafanaDatasourceUid *string `json:"GrafanaDatasourceUid,omitempty" xml:"GrafanaDatasourceUid,omitempty"`
	// Grafana folder title.
	GrafanaFolderTitle *string `json:"GrafanaFolderTitle,omitempty" xml:"GrafanaFolderTitle,omitempty"`
	// Grafana folder UID.
	GrafanaFolderUid *string `json:"GrafanaFolderUid,omitempty" xml:"GrafanaFolderUid,omitempty"`
	// Latest Release create time.
	LatestReleaseCreateTime *string `json:"LatestReleaseCreateTime,omitempty" xml:"LatestReleaseCreateTime,omitempty"`
	// Prometheus ID.
	PrometheusId *int64 `json:"PrometheusId,omitempty" xml:"PrometheusId,omitempty"`
	// Prometheus instance ID.
	PrometheusInstanceId *string `json:"PrometheusInstanceId,omitempty" xml:"PrometheusInstanceId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Number of Release.
	ReleaseCount *int32 `json:"ReleaseCount,omitempty" xml:"ReleaseCount,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The tag value.
	Tags []*ListEnvironmentsResponseBodyDataEnvironmentsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// User ID.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s ListEnvironmentsResponseBodyDataEnvironments) String() string {
	return tea.Prettify(s)
}

func (s ListEnvironmentsResponseBodyDataEnvironments) GoString() string {
	return s.String()
}

func (s *ListEnvironmentsResponseBodyDataEnvironments) SetAddons(v []*ListEnvironmentsResponseBodyDataEnvironmentsAddons) *ListEnvironmentsResponseBodyDataEnvironments {
	s.Addons = v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironments) SetBindResourceId(v string) *ListEnvironmentsResponseBodyDataEnvironments {
	s.BindResourceId = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironments) SetBindResourceProfile(v string) *ListEnvironmentsResponseBodyDataEnvironments {
	s.BindResourceProfile = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironments) SetBindResourceType(v string) *ListEnvironmentsResponseBodyDataEnvironments {
	s.BindResourceType = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironments) SetBindVpcCidr(v string) *ListEnvironmentsResponseBodyDataEnvironments {
	s.BindVpcCidr = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironments) SetCreateTime(v string) *ListEnvironmentsResponseBodyDataEnvironments {
	s.CreateTime = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironments) SetCreatedUserId(v string) *ListEnvironmentsResponseBodyDataEnvironments {
	s.CreatedUserId = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironments) SetEnvironmentId(v string) *ListEnvironmentsResponseBodyDataEnvironments {
	s.EnvironmentId = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironments) SetEnvironmentName(v string) *ListEnvironmentsResponseBodyDataEnvironments {
	s.EnvironmentName = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironments) SetEnvironmentType(v string) *ListEnvironmentsResponseBodyDataEnvironments {
	s.EnvironmentType = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironments) SetFeatures(v []*ListEnvironmentsResponseBodyDataEnvironmentsFeatures) *ListEnvironmentsResponseBodyDataEnvironments {
	s.Features = v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironments) SetGrafanaDatasourceUid(v string) *ListEnvironmentsResponseBodyDataEnvironments {
	s.GrafanaDatasourceUid = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironments) SetGrafanaFolderTitle(v string) *ListEnvironmentsResponseBodyDataEnvironments {
	s.GrafanaFolderTitle = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironments) SetGrafanaFolderUid(v string) *ListEnvironmentsResponseBodyDataEnvironments {
	s.GrafanaFolderUid = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironments) SetLatestReleaseCreateTime(v string) *ListEnvironmentsResponseBodyDataEnvironments {
	s.LatestReleaseCreateTime = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironments) SetPrometheusId(v int64) *ListEnvironmentsResponseBodyDataEnvironments {
	s.PrometheusId = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironments) SetPrometheusInstanceId(v string) *ListEnvironmentsResponseBodyDataEnvironments {
	s.PrometheusInstanceId = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironments) SetRegionId(v string) *ListEnvironmentsResponseBodyDataEnvironments {
	s.RegionId = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironments) SetReleaseCount(v int32) *ListEnvironmentsResponseBodyDataEnvironments {
	s.ReleaseCount = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironments) SetResourceGroupId(v string) *ListEnvironmentsResponseBodyDataEnvironments {
	s.ResourceGroupId = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironments) SetTags(v []*ListEnvironmentsResponseBodyDataEnvironmentsTags) *ListEnvironmentsResponseBodyDataEnvironments {
	s.Tags = v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironments) SetUserId(v string) *ListEnvironmentsResponseBodyDataEnvironments {
	s.UserId = &v
	return s
}

type ListEnvironmentsResponseBodyDataEnvironmentsAddons struct {
	// Alias of Addon.
	Alias *string `json:"Alias,omitempty" xml:"Alias,omitempty"`
	// Description of Addon.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Icon of Addon.
	Icon *string `json:"Icon,omitempty" xml:"Icon,omitempty"`
	// Name of Addon.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s ListEnvironmentsResponseBodyDataEnvironmentsAddons) String() string {
	return tea.Prettify(s)
}

func (s ListEnvironmentsResponseBodyDataEnvironmentsAddons) GoString() string {
	return s.String()
}

func (s *ListEnvironmentsResponseBodyDataEnvironmentsAddons) SetAlias(v string) *ListEnvironmentsResponseBodyDataEnvironmentsAddons {
	s.Alias = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironmentsAddons) SetDescription(v string) *ListEnvironmentsResponseBodyDataEnvironmentsAddons {
	s.Description = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironmentsAddons) SetIcon(v string) *ListEnvironmentsResponseBodyDataEnvironmentsAddons {
	s.Icon = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironmentsAddons) SetName(v string) *ListEnvironmentsResponseBodyDataEnvironmentsAddons {
	s.Name = &v
	return s
}

type ListEnvironmentsResponseBodyDataEnvironmentsFeatures struct {
	// Alias of Feature.
	Alias *string `json:"Alias,omitempty" xml:"Alias,omitempty"`
	// Description of Feature.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Icon address.
	Icon *string `json:"Icon,omitempty" xml:"Icon,omitempty"`
	// Name of Feature.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s ListEnvironmentsResponseBodyDataEnvironmentsFeatures) String() string {
	return tea.Prettify(s)
}

func (s ListEnvironmentsResponseBodyDataEnvironmentsFeatures) GoString() string {
	return s.String()
}

func (s *ListEnvironmentsResponseBodyDataEnvironmentsFeatures) SetAlias(v string) *ListEnvironmentsResponseBodyDataEnvironmentsFeatures {
	s.Alias = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironmentsFeatures) SetDescription(v string) *ListEnvironmentsResponseBodyDataEnvironmentsFeatures {
	s.Description = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironmentsFeatures) SetIcon(v string) *ListEnvironmentsResponseBodyDataEnvironmentsFeatures {
	s.Icon = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironmentsFeatures) SetName(v string) *ListEnvironmentsResponseBodyDataEnvironmentsFeatures {
	s.Name = &v
	return s
}

type ListEnvironmentsResponseBodyDataEnvironmentsTags struct {
	// Tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// Tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListEnvironmentsResponseBodyDataEnvironmentsTags) String() string {
	return tea.Prettify(s)
}

func (s ListEnvironmentsResponseBodyDataEnvironmentsTags) GoString() string {
	return s.String()
}

func (s *ListEnvironmentsResponseBodyDataEnvironmentsTags) SetKey(v string) *ListEnvironmentsResponseBodyDataEnvironmentsTags {
	s.Key = &v
	return s
}

func (s *ListEnvironmentsResponseBodyDataEnvironmentsTags) SetValue(v string) *ListEnvironmentsResponseBodyDataEnvironmentsTags {
	s.Value = &v
	return s
}

type ListEnvironmentsResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListEnvironmentsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListEnvironmentsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListEnvironmentsResponse) GoString() string {
	return s.String()
}

func (s *ListEnvironmentsResponse) SetHeaders(v map[string]*string) *ListEnvironmentsResponse {
	s.Headers = v
	return s
}

func (s *ListEnvironmentsResponse) SetStatusCode(v int32) *ListEnvironmentsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListEnvironmentsResponse) SetBody(v *ListEnvironmentsResponseBody) *ListEnvironmentsResponse {
	s.Body = v
	return s
}

type ListEscalationPoliciesRequest struct {
	// The name of the escalation policy.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The number of the page to return.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of entries to return on each page.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
}

func (s ListEscalationPoliciesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEscalationPoliciesRequest) GoString() string {
	return s.String()
}

func (s *ListEscalationPoliciesRequest) SetName(v string) *ListEscalationPoliciesRequest {
	s.Name = &v
	return s
}

func (s *ListEscalationPoliciesRequest) SetPage(v int64) *ListEscalationPoliciesRequest {
	s.Page = &v
	return s
}

func (s *ListEscalationPoliciesRequest) SetSize(v int64) *ListEscalationPoliciesRequest {
	s.Size = &v
	return s
}

type ListEscalationPoliciesResponseBody struct {
	// The returned objects.
	PageBean *ListEscalationPoliciesResponseBodyPageBean `json:"PageBean,omitempty" xml:"PageBean,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListEscalationPoliciesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListEscalationPoliciesResponseBody) GoString() string {
	return s.String()
}

func (s *ListEscalationPoliciesResponseBody) SetPageBean(v *ListEscalationPoliciesResponseBodyPageBean) *ListEscalationPoliciesResponseBody {
	s.PageBean = v
	return s
}

func (s *ListEscalationPoliciesResponseBody) SetRequestId(v string) *ListEscalationPoliciesResponseBody {
	s.RequestId = &v
	return s
}

type ListEscalationPoliciesResponseBodyPageBean struct {
	// The list of escalation policies.
	EscalationPolicies []*ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies `json:"EscalationPolicies,omitempty" xml:"EscalationPolicies,omitempty" type:"Repeated"`
	// The page number of the returned page.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of entries returned per page.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The total number of returned entries.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListEscalationPoliciesResponseBodyPageBean) String() string {
	return tea.Prettify(s)
}

func (s ListEscalationPoliciesResponseBodyPageBean) GoString() string {
	return s.String()
}

func (s *ListEscalationPoliciesResponseBodyPageBean) SetEscalationPolicies(v []*ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies) *ListEscalationPoliciesResponseBodyPageBean {
	s.EscalationPolicies = v
	return s
}

func (s *ListEscalationPoliciesResponseBodyPageBean) SetPage(v int64) *ListEscalationPoliciesResponseBodyPageBean {
	s.Page = &v
	return s
}

func (s *ListEscalationPoliciesResponseBodyPageBean) SetSize(v int64) *ListEscalationPoliciesResponseBodyPageBean {
	s.Size = &v
	return s
}

func (s *ListEscalationPoliciesResponseBodyPageBean) SetTotal(v int64) *ListEscalationPoliciesResponseBodyPageBean {
	s.Total = &v
	return s
}

type ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies struct {
	// The ID of the escalation policy.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the escalation policy.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies) String() string {
	return tea.Prettify(s)
}

func (s ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies) GoString() string {
	return s.String()
}

func (s *ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies) SetId(v int64) *ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies {
	s.Id = &v
	return s
}

func (s *ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies) SetName(v string) *ListEscalationPoliciesResponseBodyPageBeanEscalationPolicies {
	s.Name = &v
	return s
}

type ListEscalationPoliciesResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListEscalationPoliciesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListEscalationPoliciesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListEscalationPoliciesResponse) GoString() string {
	return s.String()
}

func (s *ListEscalationPoliciesResponse) SetHeaders(v map[string]*string) *ListEscalationPoliciesResponse {
	s.Headers = v
	return s
}

func (s *ListEscalationPoliciesResponse) SetStatusCode(v int32) *ListEscalationPoliciesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListEscalationPoliciesResponse) SetBody(v *ListEscalationPoliciesResponseBody) *ListEscalationPoliciesResponse {
	s.Body = v
	return s
}

type ListEventBridgeIntegrationsRequest struct {
	// The name of the EventBridge integration.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The number of the page to return.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of entries to return on each page.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
}

func (s ListEventBridgeIntegrationsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEventBridgeIntegrationsRequest) GoString() string {
	return s.String()
}

func (s *ListEventBridgeIntegrationsRequest) SetName(v string) *ListEventBridgeIntegrationsRequest {
	s.Name = &v
	return s
}

func (s *ListEventBridgeIntegrationsRequest) SetPage(v int64) *ListEventBridgeIntegrationsRequest {
	s.Page = &v
	return s
}

func (s *ListEventBridgeIntegrationsRequest) SetSize(v int64) *ListEventBridgeIntegrationsRequest {
	s.Size = &v
	return s
}

type ListEventBridgeIntegrationsResponseBody struct {
	// The information about EventBridge integrations that is returned on each page.
	PageBean *ListEventBridgeIntegrationsResponseBodyPageBean `json:"PageBean,omitempty" xml:"PageBean,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListEventBridgeIntegrationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListEventBridgeIntegrationsResponseBody) GoString() string {
	return s.String()
}

func (s *ListEventBridgeIntegrationsResponseBody) SetPageBean(v *ListEventBridgeIntegrationsResponseBodyPageBean) *ListEventBridgeIntegrationsResponseBody {
	s.PageBean = v
	return s
}

func (s *ListEventBridgeIntegrationsResponseBody) SetRequestId(v string) *ListEventBridgeIntegrationsResponseBody {
	s.RequestId = &v
	return s
}

type ListEventBridgeIntegrationsResponseBodyPageBean struct {
	// The EventBridge integrations.
	EventBridgeIntegrations []*ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations `json:"EventBridgeIntegrations,omitempty" xml:"EventBridgeIntegrations,omitempty" type:"Repeated"`
	// The number of the returned page.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of entries returned per page.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The total number of EventBridge integrations that are returned.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListEventBridgeIntegrationsResponseBodyPageBean) String() string {
	return tea.Prettify(s)
}

func (s ListEventBridgeIntegrationsResponseBodyPageBean) GoString() string {
	return s.String()
}

func (s *ListEventBridgeIntegrationsResponseBodyPageBean) SetEventBridgeIntegrations(v []*ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations) *ListEventBridgeIntegrationsResponseBodyPageBean {
	s.EventBridgeIntegrations = v
	return s
}

func (s *ListEventBridgeIntegrationsResponseBodyPageBean) SetPage(v int64) *ListEventBridgeIntegrationsResponseBodyPageBean {
	s.Page = &v
	return s
}

func (s *ListEventBridgeIntegrationsResponseBodyPageBean) SetSize(v int64) *ListEventBridgeIntegrationsResponseBodyPageBean {
	s.Size = &v
	return s
}

func (s *ListEventBridgeIntegrationsResponseBodyPageBean) SetTotal(v int64) *ListEventBridgeIntegrationsResponseBodyPageBean {
	s.Total = &v
	return s
}

type ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations struct {
	// The description of the EventBridge integration.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the EventBridge integration.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the EventBridge integration.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations) String() string {
	return tea.Prettify(s)
}

func (s ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations) GoString() string {
	return s.String()
}

func (s *ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations) SetDescription(v string) *ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations {
	s.Description = &v
	return s
}

func (s *ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations) SetId(v int64) *ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations {
	s.Id = &v
	return s
}

func (s *ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations) SetName(v string) *ListEventBridgeIntegrationsResponseBodyPageBeanEventBridgeIntegrations {
	s.Name = &v
	return s
}

type ListEventBridgeIntegrationsResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListEventBridgeIntegrationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListEventBridgeIntegrationsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListEventBridgeIntegrationsResponse) GoString() string {
	return s.String()
}

func (s *ListEventBridgeIntegrationsResponse) SetHeaders(v map[string]*string) *ListEventBridgeIntegrationsResponse {
	s.Headers = v
	return s
}

func (s *ListEventBridgeIntegrationsResponse) SetStatusCode(v int32) *ListEventBridgeIntegrationsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListEventBridgeIntegrationsResponse) SetBody(v *ListEventBridgeIntegrationsResponseBody) *ListEventBridgeIntegrationsResponse {
	s.Body = v
	return s
}

type ListGrafanaWorkspaceRequest struct {
	AliyunLang      *string                            `json:"AliyunLang,omitempty" xml:"AliyunLang,omitempty"`
	RegionId        *string                            `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId *string                            `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	Tags            []*ListGrafanaWorkspaceRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s ListGrafanaWorkspaceRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGrafanaWorkspaceRequest) GoString() string {
	return s.String()
}

func (s *ListGrafanaWorkspaceRequest) SetAliyunLang(v string) *ListGrafanaWorkspaceRequest {
	s.AliyunLang = &v
	return s
}

func (s *ListGrafanaWorkspaceRequest) SetRegionId(v string) *ListGrafanaWorkspaceRequest {
	s.RegionId = &v
	return s
}

func (s *ListGrafanaWorkspaceRequest) SetResourceGroupId(v string) *ListGrafanaWorkspaceRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListGrafanaWorkspaceRequest) SetTags(v []*ListGrafanaWorkspaceRequestTags) *ListGrafanaWorkspaceRequest {
	s.Tags = v
	return s
}

type ListGrafanaWorkspaceRequestTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListGrafanaWorkspaceRequestTags) String() string {
	return tea.Prettify(s)
}

func (s ListGrafanaWorkspaceRequestTags) GoString() string {
	return s.String()
}

func (s *ListGrafanaWorkspaceRequestTags) SetKey(v string) *ListGrafanaWorkspaceRequestTags {
	s.Key = &v
	return s
}

func (s *ListGrafanaWorkspaceRequestTags) SetValue(v string) *ListGrafanaWorkspaceRequestTags {
	s.Value = &v
	return s
}

type ListGrafanaWorkspaceShrinkRequest struct {
	AliyunLang      *string `json:"AliyunLang,omitempty" xml:"AliyunLang,omitempty"`
	RegionId        *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	TagsShrink      *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s ListGrafanaWorkspaceShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGrafanaWorkspaceShrinkRequest) GoString() string {
	return s.String()
}

func (s *ListGrafanaWorkspaceShrinkRequest) SetAliyunLang(v string) *ListGrafanaWorkspaceShrinkRequest {
	s.AliyunLang = &v
	return s
}

func (s *ListGrafanaWorkspaceShrinkRequest) SetRegionId(v string) *ListGrafanaWorkspaceShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *ListGrafanaWorkspaceShrinkRequest) SetResourceGroupId(v string) *ListGrafanaWorkspaceShrinkRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListGrafanaWorkspaceShrinkRequest) SetTagsShrink(v string) *ListGrafanaWorkspaceShrinkRequest {
	s.TagsShrink = &v
	return s
}

type ListGrafanaWorkspaceResponseBody struct {
	Code      *int32              `json:"Code,omitempty" xml:"Code,omitempty"`
	Data      []*GrafanaWorkspace `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	Message   *string             `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId *string             `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool               `json:"Success,omitempty" xml:"Success,omitempty"`
	TraceId   *string             `json:"TraceId,omitempty" xml:"TraceId,omitempty"`
}

func (s ListGrafanaWorkspaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListGrafanaWorkspaceResponseBody) GoString() string {
	return s.String()
}

func (s *ListGrafanaWorkspaceResponseBody) SetCode(v int32) *ListGrafanaWorkspaceResponseBody {
	s.Code = &v
	return s
}

func (s *ListGrafanaWorkspaceResponseBody) SetData(v []*GrafanaWorkspace) *ListGrafanaWorkspaceResponseBody {
	s.Data = v
	return s
}

func (s *ListGrafanaWorkspaceResponseBody) SetMessage(v string) *ListGrafanaWorkspaceResponseBody {
	s.Message = &v
	return s
}

func (s *ListGrafanaWorkspaceResponseBody) SetRequestId(v string) *ListGrafanaWorkspaceResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListGrafanaWorkspaceResponseBody) SetSuccess(v bool) *ListGrafanaWorkspaceResponseBody {
	s.Success = &v
	return s
}

func (s *ListGrafanaWorkspaceResponseBody) SetTraceId(v string) *ListGrafanaWorkspaceResponseBody {
	s.TraceId = &v
	return s
}

type ListGrafanaWorkspaceResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListGrafanaWorkspaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListGrafanaWorkspaceResponse) String() string {
	return tea.Prettify(s)
}

func (s ListGrafanaWorkspaceResponse) GoString() string {
	return s.String()
}

func (s *ListGrafanaWorkspaceResponse) SetHeaders(v map[string]*string) *ListGrafanaWorkspaceResponse {
	s.Headers = v
	return s
}

func (s *ListGrafanaWorkspaceResponse) SetStatusCode(v int32) *ListGrafanaWorkspaceResponse {
	s.StatusCode = &v
	return s
}

func (s *ListGrafanaWorkspaceResponse) SetBody(v *ListGrafanaWorkspaceResponseBody) *ListGrafanaWorkspaceResponse {
	s.Body = v
	return s
}

type ListInsightsEventsRequest struct {
	// The details of the event.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// Average response-time spikes of application services.
	InsightsTypes *string `json:"InsightsTypes,omitempty" xml:"InsightsTypes,omitempty"`
	// The types of the events that you want to query. Separate multiple event types with commas (,). If you do not specify this parameter, all events are queried.
	//
	// *   errorIncrease: API error-rate spike events. Examples: HTTP API error-rate spike events and Dubbo API error-rate spike events.
	// *   topErrorIncrease: the top five API error-rate spike events with the highest traffic.
	// *   topRtIncrease: API response-time spike events. Examples: HTTP API response-time spike events and Dubbo API response-time spike events.
	// *   rtIncrease: the top five API response-time spike events with the highest traffic.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The end of the time range to query. The value is a timestamp.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the request.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s ListInsightsEventsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListInsightsEventsRequest) GoString() string {
	return s.String()
}

func (s *ListInsightsEventsRequest) SetEndTime(v string) *ListInsightsEventsRequest {
	s.EndTime = &v
	return s
}

func (s *ListInsightsEventsRequest) SetInsightsTypes(v string) *ListInsightsEventsRequest {
	s.InsightsTypes = &v
	return s
}

func (s *ListInsightsEventsRequest) SetPid(v string) *ListInsightsEventsRequest {
	s.Pid = &v
	return s
}

func (s *ListInsightsEventsRequest) SetRegionId(v string) *ListInsightsEventsRequest {
	s.RegionId = &v
	return s
}

func (s *ListInsightsEventsRequest) SetStartTime(v string) *ListInsightsEventsRequest {
	s.StartTime = &v
	return s
}

type ListInsightsEventsResponseBody struct {
	// The event details.
	InsightsEvents []*ListInsightsEventsResponseBodyInsightsEvents `json:"InsightsEvents,omitempty" xml:"InsightsEvents,omitempty" type:"Repeated"`
	// The title of the event.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListInsightsEventsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListInsightsEventsResponseBody) GoString() string {
	return s.String()
}

func (s *ListInsightsEventsResponseBody) SetInsightsEvents(v []*ListInsightsEventsResponseBodyInsightsEvents) *ListInsightsEventsResponseBody {
	s.InsightsEvents = v
	return s
}

func (s *ListInsightsEventsResponseBody) SetRequestId(v string) *ListInsightsEventsResponseBody {
	s.RequestId = &v
	return s
}

type ListInsightsEventsResponseBodyInsightsEvents struct {
	// The time when the event occurred. The value is a timestamp.
	Date *int64 `json:"Date,omitempty" xml:"Date,omitempty"`
	// The description of the event.
	Desc *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	// The severity of the event.
	Level *string `json:"Level,omitempty" xml:"Level,omitempty"`
	// The ID of the application associated with the event.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// Problem identification.
	ProblemId *string `json:"ProblemId,omitempty" xml:"ProblemId,omitempty"`
	// The title of the event.
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The type of the event.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListInsightsEventsResponseBodyInsightsEvents) String() string {
	return tea.Prettify(s)
}

func (s ListInsightsEventsResponseBodyInsightsEvents) GoString() string {
	return s.String()
}

func (s *ListInsightsEventsResponseBodyInsightsEvents) SetDate(v int64) *ListInsightsEventsResponseBodyInsightsEvents {
	s.Date = &v
	return s
}

func (s *ListInsightsEventsResponseBodyInsightsEvents) SetDesc(v string) *ListInsightsEventsResponseBodyInsightsEvents {
	s.Desc = &v
	return s
}

func (s *ListInsightsEventsResponseBodyInsightsEvents) SetLevel(v string) *ListInsightsEventsResponseBodyInsightsEvents {
	s.Level = &v
	return s
}

func (s *ListInsightsEventsResponseBodyInsightsEvents) SetPid(v string) *ListInsightsEventsResponseBodyInsightsEvents {
	s.Pid = &v
	return s
}

func (s *ListInsightsEventsResponseBodyInsightsEvents) SetProblemId(v string) *ListInsightsEventsResponseBodyInsightsEvents {
	s.ProblemId = &v
	return s
}

func (s *ListInsightsEventsResponseBodyInsightsEvents) SetTitle(v string) *ListInsightsEventsResponseBodyInsightsEvents {
	s.Title = &v
	return s
}

func (s *ListInsightsEventsResponseBodyInsightsEvents) SetType(v string) *ListInsightsEventsResponseBodyInsightsEvents {
	s.Type = &v
	return s
}

type ListInsightsEventsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListInsightsEventsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListInsightsEventsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListInsightsEventsResponse) GoString() string {
	return s.String()
}

func (s *ListInsightsEventsResponse) SetHeaders(v map[string]*string) *ListInsightsEventsResponse {
	s.Headers = v
	return s
}

func (s *ListInsightsEventsResponse) SetStatusCode(v int32) *ListInsightsEventsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListInsightsEventsResponse) SetBody(v *ListInsightsEventsResponseBody) *ListInsightsEventsResponse {
	s.Body = v
	return s
}

type ListIntegrationRequest struct {
	IntegrationName        *string `json:"IntegrationName,omitempty" xml:"IntegrationName,omitempty"`
	IntegrationProductType *string `json:"IntegrationProductType,omitempty" xml:"IntegrationProductType,omitempty"`
	IsDetail               *bool   `json:"IsDetail,omitempty" xml:"IsDetail,omitempty"`
	Page                   *int64  `json:"Page,omitempty" xml:"Page,omitempty"`
	Size                   *int64  `json:"Size,omitempty" xml:"Size,omitempty"`
}

func (s ListIntegrationRequest) String() string {
	return tea.Prettify(s)
}

func (s ListIntegrationRequest) GoString() string {
	return s.String()
}

func (s *ListIntegrationRequest) SetIntegrationName(v string) *ListIntegrationRequest {
	s.IntegrationName = &v
	return s
}

func (s *ListIntegrationRequest) SetIntegrationProductType(v string) *ListIntegrationRequest {
	s.IntegrationProductType = &v
	return s
}

func (s *ListIntegrationRequest) SetIsDetail(v bool) *ListIntegrationRequest {
	s.IsDetail = &v
	return s
}

func (s *ListIntegrationRequest) SetPage(v int64) *ListIntegrationRequest {
	s.Page = &v
	return s
}

func (s *ListIntegrationRequest) SetSize(v int64) *ListIntegrationRequest {
	s.Size = &v
	return s
}

type ListIntegrationResponseBody struct {
	PageInfo  *ListIntegrationResponseBodyPageInfo `json:"PageInfo,omitempty" xml:"PageInfo,omitempty" type:"Struct"`
	RequestId *string                              `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListIntegrationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListIntegrationResponseBody) GoString() string {
	return s.String()
}

func (s *ListIntegrationResponseBody) SetPageInfo(v *ListIntegrationResponseBodyPageInfo) *ListIntegrationResponseBody {
	s.PageInfo = v
	return s
}

func (s *ListIntegrationResponseBody) SetRequestId(v string) *ListIntegrationResponseBody {
	s.RequestId = &v
	return s
}

type ListIntegrationResponseBodyPageInfo struct {
	Integrations []*ListIntegrationResponseBodyPageInfoIntegrations `json:"Integrations,omitempty" xml:"Integrations,omitempty" type:"Repeated"`
	Page         *int64                                             `json:"Page,omitempty" xml:"Page,omitempty"`
	Size         *int64                                             `json:"Size,omitempty" xml:"Size,omitempty"`
	Total        *int64                                             `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListIntegrationResponseBodyPageInfo) String() string {
	return tea.Prettify(s)
}

func (s ListIntegrationResponseBodyPageInfo) GoString() string {
	return s.String()
}

func (s *ListIntegrationResponseBodyPageInfo) SetIntegrations(v []*ListIntegrationResponseBodyPageInfoIntegrations) *ListIntegrationResponseBodyPageInfo {
	s.Integrations = v
	return s
}

func (s *ListIntegrationResponseBodyPageInfo) SetPage(v int64) *ListIntegrationResponseBodyPageInfo {
	s.Page = &v
	return s
}

func (s *ListIntegrationResponseBodyPageInfo) SetSize(v int64) *ListIntegrationResponseBodyPageInfo {
	s.Size = &v
	return s
}

func (s *ListIntegrationResponseBodyPageInfo) SetTotal(v int64) *ListIntegrationResponseBodyPageInfo {
	s.Total = &v
	return s
}

type ListIntegrationResponseBodyPageInfoIntegrations struct {
	ApiEndpoint            *string                                                           `json:"ApiEndpoint,omitempty" xml:"ApiEndpoint,omitempty"`
	CreateTime             *string                                                           `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	IntegrationDetail      *ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail `json:"IntegrationDetail,omitempty" xml:"IntegrationDetail,omitempty" type:"Struct"`
	IntegrationId          *int64                                                            `json:"IntegrationId,omitempty" xml:"IntegrationId,omitempty"`
	IntegrationName        *string                                                           `json:"IntegrationName,omitempty" xml:"IntegrationName,omitempty"`
	IntegrationProductType *string                                                           `json:"IntegrationProductType,omitempty" xml:"IntegrationProductType,omitempty"`
	Liveness               *string                                                           `json:"Liveness,omitempty" xml:"Liveness,omitempty"`
	ShortToken             *string                                                           `json:"ShortToken,omitempty" xml:"ShortToken,omitempty"`
	State                  *bool                                                             `json:"State,omitempty" xml:"State,omitempty"`
}

func (s ListIntegrationResponseBodyPageInfoIntegrations) String() string {
	return tea.Prettify(s)
}

func (s ListIntegrationResponseBodyPageInfoIntegrations) GoString() string {
	return s.String()
}

func (s *ListIntegrationResponseBodyPageInfoIntegrations) SetApiEndpoint(v string) *ListIntegrationResponseBodyPageInfoIntegrations {
	s.ApiEndpoint = &v
	return s
}

func (s *ListIntegrationResponseBodyPageInfoIntegrations) SetCreateTime(v string) *ListIntegrationResponseBodyPageInfoIntegrations {
	s.CreateTime = &v
	return s
}

func (s *ListIntegrationResponseBodyPageInfoIntegrations) SetIntegrationDetail(v *ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail) *ListIntegrationResponseBodyPageInfoIntegrations {
	s.IntegrationDetail = v
	return s
}

func (s *ListIntegrationResponseBodyPageInfoIntegrations) SetIntegrationId(v int64) *ListIntegrationResponseBodyPageInfoIntegrations {
	s.IntegrationId = &v
	return s
}

func (s *ListIntegrationResponseBodyPageInfoIntegrations) SetIntegrationName(v string) *ListIntegrationResponseBodyPageInfoIntegrations {
	s.IntegrationName = &v
	return s
}

func (s *ListIntegrationResponseBodyPageInfoIntegrations) SetIntegrationProductType(v string) *ListIntegrationResponseBodyPageInfoIntegrations {
	s.IntegrationProductType = &v
	return s
}

func (s *ListIntegrationResponseBodyPageInfoIntegrations) SetLiveness(v string) *ListIntegrationResponseBodyPageInfoIntegrations {
	s.Liveness = &v
	return s
}

func (s *ListIntegrationResponseBodyPageInfoIntegrations) SetShortToken(v string) *ListIntegrationResponseBodyPageInfoIntegrations {
	s.ShortToken = &v
	return s
}

func (s *ListIntegrationResponseBodyPageInfoIntegrations) SetState(v bool) *ListIntegrationResponseBodyPageInfoIntegrations {
	s.State = &v
	return s
}

type ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail struct {
	AutoRecover                *bool                    `json:"AutoRecover,omitempty" xml:"AutoRecover,omitempty"`
	Description                *string                  `json:"Description,omitempty" xml:"Description,omitempty"`
	DuplicateKey               *string                  `json:"DuplicateKey,omitempty" xml:"DuplicateKey,omitempty"`
	ExtendedFieldRedefineRules []map[string]interface{} `json:"ExtendedFieldRedefineRules,omitempty" xml:"ExtendedFieldRedefineRules,omitempty" type:"Repeated"`
	FieldRedefineRules         []map[string]interface{} `json:"FieldRedefineRules,omitempty" xml:"FieldRedefineRules,omitempty" type:"Repeated"`
	InitiativeRecoverField     *string                  `json:"InitiativeRecoverField,omitempty" xml:"InitiativeRecoverField,omitempty"`
	InitiativeRecoverValue     *string                  `json:"InitiativeRecoverValue,omitempty" xml:"InitiativeRecoverValue,omitempty"`
	RecoverTime                *int64                   `json:"RecoverTime,omitempty" xml:"RecoverTime,omitempty"`
	Stat                       []*int64                 `json:"Stat,omitempty" xml:"Stat,omitempty" type:"Repeated"`
}

func (s ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail) String() string {
	return tea.Prettify(s)
}

func (s ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail) GoString() string {
	return s.String()
}

func (s *ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail) SetAutoRecover(v bool) *ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail {
	s.AutoRecover = &v
	return s
}

func (s *ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail) SetDescription(v string) *ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail {
	s.Description = &v
	return s
}

func (s *ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail) SetDuplicateKey(v string) *ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail {
	s.DuplicateKey = &v
	return s
}

func (s *ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail) SetExtendedFieldRedefineRules(v []map[string]interface{}) *ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail {
	s.ExtendedFieldRedefineRules = v
	return s
}

func (s *ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail) SetFieldRedefineRules(v []map[string]interface{}) *ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail {
	s.FieldRedefineRules = v
	return s
}

func (s *ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail) SetInitiativeRecoverField(v string) *ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail {
	s.InitiativeRecoverField = &v
	return s
}

func (s *ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail) SetInitiativeRecoverValue(v string) *ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail {
	s.InitiativeRecoverValue = &v
	return s
}

func (s *ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail) SetRecoverTime(v int64) *ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail {
	s.RecoverTime = &v
	return s
}

func (s *ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail) SetStat(v []*int64) *ListIntegrationResponseBodyPageInfoIntegrationsIntegrationDetail {
	s.Stat = v
	return s
}

type ListIntegrationResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListIntegrationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListIntegrationResponse) String() string {
	return tea.Prettify(s)
}

func (s ListIntegrationResponse) GoString() string {
	return s.String()
}

func (s *ListIntegrationResponse) SetHeaders(v map[string]*string) *ListIntegrationResponse {
	s.Headers = v
	return s
}

func (s *ListIntegrationResponse) SetStatusCode(v int32) *ListIntegrationResponse {
	s.StatusCode = &v
	return s
}

func (s *ListIntegrationResponse) SetBody(v *ListIntegrationResponseBody) *ListIntegrationResponse {
	s.Body = v
	return s
}

type ListNotificationPoliciesRequest struct {
	// Specifies whether to enable simple mode.
	DirectedMode *bool `json:"DirectedMode,omitempty" xml:"DirectedMode,omitempty"`
	// The ID of the notification policy.
	Ids *string `json:"Ids,omitempty" xml:"Ids,omitempty"`
	// Specifies whether to query the details about notification policies. Valid values:
	//
	// *   `true`: Details about notification policies are queried.
	// *   `false`: Details about notification policies are not queried.
	IsDetail *bool `json:"IsDetail,omitempty" xml:"IsDetail,omitempty"`
	// The name of the notification policy.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The number of the page to return.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The number of entries to return on each page.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
}

func (s ListNotificationPoliciesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListNotificationPoliciesRequest) GoString() string {
	return s.String()
}

func (s *ListNotificationPoliciesRequest) SetDirectedMode(v bool) *ListNotificationPoliciesRequest {
	s.DirectedMode = &v
	return s
}

func (s *ListNotificationPoliciesRequest) SetIds(v string) *ListNotificationPoliciesRequest {
	s.Ids = &v
	return s
}

func (s *ListNotificationPoliciesRequest) SetIsDetail(v bool) *ListNotificationPoliciesRequest {
	s.IsDetail = &v
	return s
}

func (s *ListNotificationPoliciesRequest) SetName(v string) *ListNotificationPoliciesRequest {
	s.Name = &v
	return s
}

func (s *ListNotificationPoliciesRequest) SetPage(v int64) *ListNotificationPoliciesRequest {
	s.Page = &v
	return s
}

func (s *ListNotificationPoliciesRequest) SetRegionId(v string) *ListNotificationPoliciesRequest {
	s.RegionId = &v
	return s
}

func (s *ListNotificationPoliciesRequest) SetSize(v int64) *ListNotificationPoliciesRequest {
	s.Size = &v
	return s
}

type ListNotificationPoliciesResponseBody struct {
	// The returned pages.
	PageBean *ListNotificationPoliciesResponseBodyPageBean `json:"PageBean,omitempty" xml:"PageBean,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListNotificationPoliciesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListNotificationPoliciesResponseBody) GoString() string {
	return s.String()
}

func (s *ListNotificationPoliciesResponseBody) SetPageBean(v *ListNotificationPoliciesResponseBodyPageBean) *ListNotificationPoliciesResponseBody {
	s.PageBean = v
	return s
}

func (s *ListNotificationPoliciesResponseBody) SetRequestId(v string) *ListNotificationPoliciesResponseBody {
	s.RequestId = &v
	return s
}

type ListNotificationPoliciesResponseBodyPageBean struct {
	// The queried notification policies.
	NotificationPolicies []*ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies `json:"NotificationPolicies,omitempty" xml:"NotificationPolicies,omitempty" type:"Repeated"`
	// The number of the page returned.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of entries that are returned on each page.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The number of notification policies that are returned.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListNotificationPoliciesResponseBodyPageBean) String() string {
	return tea.Prettify(s)
}

func (s ListNotificationPoliciesResponseBodyPageBean) GoString() string {
	return s.String()
}

func (s *ListNotificationPoliciesResponseBodyPageBean) SetNotificationPolicies(v []*ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies) *ListNotificationPoliciesResponseBodyPageBean {
	s.NotificationPolicies = v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBean) SetPage(v int64) *ListNotificationPoliciesResponseBodyPageBean {
	s.Page = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBean) SetSize(v int64) *ListNotificationPoliciesResponseBodyPageBean {
	s.Size = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBean) SetTotal(v int64) *ListNotificationPoliciesResponseBodyPageBean {
	s.Total = &v
	return s
}

type ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies struct {
	// Indicates whether simple mode is enabled.
	DirectedMode *bool `json:"DirectedMode,omitempty" xml:"DirectedMode,omitempty"`
	// The ID of the escalation policy.
	EscalationPolicyId *int64 `json:"EscalationPolicyId,omitempty" xml:"EscalationPolicyId,omitempty"`
	// The grouping rule for alert events.
	GroupRule *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule `json:"GroupRule,omitempty" xml:"GroupRule,omitempty" type:"Struct"`
	// The ID of the notification policy.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The integration ID of the ticket system to which alerts are pushed.
	IntegrationId *int64 `json:"IntegrationId,omitempty" xml:"IntegrationId,omitempty"`
	// The matching rules for alert events.
	MatchingRules []*ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules `json:"MatchingRules,omitempty" xml:"MatchingRules,omitempty" type:"Repeated"`
	// The name of the notification policy.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The notification rules.
	NotifyRule *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule `json:"NotifyRule,omitempty" xml:"NotifyRule,omitempty" type:"Struct"`
	// The notification templates.
	NotifyTemplate *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate `json:"NotifyTemplate,omitempty" xml:"NotifyTemplate,omitempty" type:"Struct"`
	// Indicates whether the system resends notifications for a long-lasting unresolved alert. Valid values:
	//
	// *   `true` (default): The system resends notifications for a long-lasting unresolved alert at a specified time interval.
	// *   `false`: The system resends notifications for a long-lasting unresolved alert based on an escalation policy.
	Repeat *bool `json:"Repeat,omitempty" xml:"Repeat,omitempty"`
	// The time interval at which notifications are resent for a long-lasting unresolved alert. Unit: seconds.
	RepeatInterval *int64 `json:"RepeatInterval,omitempty" xml:"RepeatInterval,omitempty"`
	// Indicates whether the status of an alert automatically changes to Resolved when all events related to the alert change to the Restored state. The system sends a notification to the alert contacts when the alert status changes to Resolved.
	//
	// *   `true` (default): The system sends a notification.
	// *   `false`: The system does not send a notification.
	SendRecoverMessage *bool `json:"SendRecoverMessage,omitempty" xml:"SendRecoverMessage,omitempty"`
}

func (s ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies) String() string {
	return tea.Prettify(s)
}

func (s ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies) GoString() string {
	return s.String()
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies) SetDirectedMode(v bool) *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies {
	s.DirectedMode = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies) SetEscalationPolicyId(v int64) *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies {
	s.EscalationPolicyId = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies) SetGroupRule(v *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule) *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies {
	s.GroupRule = v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies) SetId(v int64) *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies {
	s.Id = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies) SetIntegrationId(v int64) *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies {
	s.IntegrationId = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies) SetMatchingRules(v []*ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules) *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies {
	s.MatchingRules = v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies) SetName(v string) *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies {
	s.Name = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies) SetNotifyRule(v *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule) *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies {
	s.NotifyRule = v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies) SetNotifyTemplate(v *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate) *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies {
	s.NotifyTemplate = v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies) SetRepeat(v bool) *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies {
	s.Repeat = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies) SetRepeatInterval(v int64) *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies {
	s.RepeatInterval = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies) SetSendRecoverMessage(v bool) *ListNotificationPoliciesResponseBodyPageBeanNotificationPolicies {
	s.SendRecoverMessage = &v
	return s
}

type ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule struct {
	// The time interval of grouping. Unit: seconds. Default value: 30.
	GroupInterval *int64 `json:"GroupInterval,omitempty" xml:"GroupInterval,omitempty"`
	// The waiting time for grouping. Unit: seconds. Default value: 5.
	GroupWait *int64 `json:"GroupWait,omitempty" xml:"GroupWait,omitempty"`
	// The fields that are used to group events.
	//
	// *   If this parameter is not returned, all alert notifications are sent to the alert contacts that belong to the `alertname` group. By default, this parameter is not returned.
	// *   If this parameter is returned, alerts with the same fields are sent to the alert contacts in one notification.
	GroupingFields []*string `json:"GroupingFields,omitempty" xml:"GroupingFields,omitempty" type:"Repeated"`
}

func (s ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule) String() string {
	return tea.Prettify(s)
}

func (s ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule) GoString() string {
	return s.String()
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule) SetGroupInterval(v int64) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule {
	s.GroupInterval = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule) SetGroupWait(v int64) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule {
	s.GroupWait = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule) SetGroupingFields(v []*string) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesGroupRule {
	s.GroupingFields = v
	return s
}

type ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules struct {
	// The matching conditions.
	MatchingConditions []*ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions `json:"MatchingConditions,omitempty" xml:"MatchingConditions,omitempty" type:"Repeated"`
}

func (s ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules) String() string {
	return tea.Prettify(s)
}

func (s ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules) GoString() string {
	return s.String()
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules) SetMatchingConditions(v []*ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRules {
	s.MatchingConditions = v
	return s
}

type ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions struct {
	// The key of the matching condition.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The logical operator of the matching condition. Valid values:
	//
	// *   `eq`: equal to
	// *   `neq`: not equal to
	// *   `in`: contains
	// *   `nin`: does not contain
	// *   `re`: regular expression match
	// *   `nre`: regular expression mismatch
	Operator *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
	// The value of the matching condition.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions) String() string {
	return tea.Prettify(s)
}

func (s ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions) GoString() string {
	return s.String()
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions) SetKey(v string) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions {
	s.Key = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions) SetOperator(v string) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions {
	s.Operator = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions) SetValue(v string) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesMatchingRulesMatchingConditions {
	s.Value = &v
	return s
}

type ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule struct {
	// The notification methods.
	NotifyChannels []*string `json:"NotifyChannels,omitempty" xml:"NotifyChannels,omitempty" type:"Repeated"`
	// The end time of the notification window.
	NotifyEndTime *string `json:"NotifyEndTime,omitempty" xml:"NotifyEndTime,omitempty"`
	// The notification objects.
	NotifyObjects []*ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects `json:"NotifyObjects,omitempty" xml:"NotifyObjects,omitempty" type:"Repeated"`
	// The start time of the notification window.
	NotifyStartTime *string `json:"NotifyStartTime,omitempty" xml:"NotifyStartTime,omitempty"`
}

func (s ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule) String() string {
	return tea.Prettify(s)
}

func (s ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule) GoString() string {
	return s.String()
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule) SetNotifyChannels(v []*string) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule {
	s.NotifyChannels = v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule) SetNotifyEndTime(v string) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule {
	s.NotifyEndTime = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule) SetNotifyObjects(v []*ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule {
	s.NotifyObjects = v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule) SetNotifyStartTime(v string) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRule {
	s.NotifyStartTime = &v
	return s
}

type ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects struct {
	// The notification methods specified for a contact.
	NotifyChannels []*string `json:"NotifyChannels,omitempty" xml:"NotifyChannels,omitempty" type:"Repeated"`
	// The ID of the notification object.
	NotifyObjectId *int64 `json:"NotifyObjectId,omitempty" xml:"NotifyObjectId,omitempty"`
	// The name of the notification object.
	NotifyObjectName *string `json:"NotifyObjectName,omitempty" xml:"NotifyObjectName,omitempty"`
	// The type of the notification object. Valid values:
	//
	// *   CONTACT: an individual contact
	// *   CONTACT_GROUP: a contact group
	// *   DING_ROBOT: an instant messaging (IM) chatbot
	// *   CONTACT_SCHEDULE: a person on duty based on an established schedule
	NotifyObjectType *string `json:"NotifyObjectType,omitempty" xml:"NotifyObjectType,omitempty"`
}

func (s ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects) String() string {
	return tea.Prettify(s)
}

func (s ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects) GoString() string {
	return s.String()
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects) SetNotifyChannels(v []*string) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects {
	s.NotifyChannels = v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects) SetNotifyObjectId(v int64) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects {
	s.NotifyObjectId = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects) SetNotifyObjectName(v string) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects {
	s.NotifyObjectName = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects) SetNotifyObjectType(v string) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyRuleNotifyObjects {
	s.NotifyObjectType = &v
	return s
}

type ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate struct {
	// The content of the alert notification sent by email.
	EmailContent *string `json:"EmailContent,omitempty" xml:"EmailContent,omitempty"`
	// The content of the alert resolution notification sent by email.
	EmailRecoverContent *string `json:"EmailRecoverContent,omitempty" xml:"EmailRecoverContent,omitempty"`
	// The title of the alert resolution notification sent by email.
	EmailRecoverTitle *string `json:"EmailRecoverTitle,omitempty" xml:"EmailRecoverTitle,omitempty"`
	// The title of the alert notification sent by email.
	EmailTitle *string `json:"EmailTitle,omitempty" xml:"EmailTitle,omitempty"`
	// The content of the alert notification sent by an IM chatbot.
	RobotContent *string `json:"RobotContent,omitempty" xml:"RobotContent,omitempty"`
	// The content of the alert notification sent by text message.
	SmsContent *string `json:"SmsContent,omitempty" xml:"SmsContent,omitempty"`
	// The content of the alert resolution notification sent by text message.
	SmsRecoverContent *string `json:"SmsRecoverContent,omitempty" xml:"SmsRecoverContent,omitempty"`
	// The content of the alert notification sent by phone.
	TtsContent *string `json:"TtsContent,omitempty" xml:"TtsContent,omitempty"`
	// The content of the alert resolution notification sent by phone.
	TtsRecoverContent *string `json:"TtsRecoverContent,omitempty" xml:"TtsRecoverContent,omitempty"`
}

func (s ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate) String() string {
	return tea.Prettify(s)
}

func (s ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate) GoString() string {
	return s.String()
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate) SetEmailContent(v string) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate {
	s.EmailContent = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate) SetEmailRecoverContent(v string) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate {
	s.EmailRecoverContent = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate) SetEmailRecoverTitle(v string) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate {
	s.EmailRecoverTitle = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate) SetEmailTitle(v string) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate {
	s.EmailTitle = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate) SetRobotContent(v string) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate {
	s.RobotContent = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate) SetSmsContent(v string) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate {
	s.SmsContent = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate) SetSmsRecoverContent(v string) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate {
	s.SmsRecoverContent = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate) SetTtsContent(v string) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate {
	s.TtsContent = &v
	return s
}

func (s *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate) SetTtsRecoverContent(v string) *ListNotificationPoliciesResponseBodyPageBeanNotificationPoliciesNotifyTemplate {
	s.TtsRecoverContent = &v
	return s
}

type ListNotificationPoliciesResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListNotificationPoliciesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListNotificationPoliciesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListNotificationPoliciesResponse) GoString() string {
	return s.String()
}

func (s *ListNotificationPoliciesResponse) SetHeaders(v map[string]*string) *ListNotificationPoliciesResponse {
	s.Headers = v
	return s
}

func (s *ListNotificationPoliciesResponse) SetStatusCode(v int32) *ListNotificationPoliciesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListNotificationPoliciesResponse) SetBody(v *ListNotificationPoliciesResponseBody) *ListNotificationPoliciesResponse {
	s.Body = v
	return s
}

type ListOnCallSchedulesRequest struct {
	// The name of the scheduling policy.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The number of the page to return.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of entries to return on each page.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
}

func (s ListOnCallSchedulesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListOnCallSchedulesRequest) GoString() string {
	return s.String()
}

func (s *ListOnCallSchedulesRequest) SetName(v string) *ListOnCallSchedulesRequest {
	s.Name = &v
	return s
}

func (s *ListOnCallSchedulesRequest) SetPage(v int64) *ListOnCallSchedulesRequest {
	s.Page = &v
	return s
}

func (s *ListOnCallSchedulesRequest) SetSize(v int64) *ListOnCallSchedulesRequest {
	s.Size = &v
	return s
}

type ListOnCallSchedulesResponseBody struct {
	// The objects that were returned.
	PageBean *ListOnCallSchedulesResponseBodyPageBean `json:"PageBean,omitempty" xml:"PageBean,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListOnCallSchedulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListOnCallSchedulesResponseBody) GoString() string {
	return s.String()
}

func (s *ListOnCallSchedulesResponseBody) SetPageBean(v *ListOnCallSchedulesResponseBodyPageBean) *ListOnCallSchedulesResponseBody {
	s.PageBean = v
	return s
}

func (s *ListOnCallSchedulesResponseBody) SetRequestId(v string) *ListOnCallSchedulesResponseBody {
	s.RequestId = &v
	return s
}

type ListOnCallSchedulesResponseBodyPageBean struct {
	// The information about the scheduling policy.
	OnCallSchedules []*ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules `json:"OnCallSchedules,omitempty" xml:"OnCallSchedules,omitempty" type:"Repeated"`
	// The page number of the returned page.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of entries returned per page.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The total number of returned entries.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListOnCallSchedulesResponseBodyPageBean) String() string {
	return tea.Prettify(s)
}

func (s ListOnCallSchedulesResponseBodyPageBean) GoString() string {
	return s.String()
}

func (s *ListOnCallSchedulesResponseBodyPageBean) SetOnCallSchedules(v []*ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules) *ListOnCallSchedulesResponseBodyPageBean {
	s.OnCallSchedules = v
	return s
}

func (s *ListOnCallSchedulesResponseBodyPageBean) SetPage(v int64) *ListOnCallSchedulesResponseBodyPageBean {
	s.Page = &v
	return s
}

func (s *ListOnCallSchedulesResponseBodyPageBean) SetSize(v int64) *ListOnCallSchedulesResponseBodyPageBean {
	s.Size = &v
	return s
}

func (s *ListOnCallSchedulesResponseBodyPageBean) SetTotal(v int64) *ListOnCallSchedulesResponseBodyPageBean {
	s.Total = &v
	return s
}

type ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules struct {
	// The description of the scheduling policy.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the scheduling policy.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the scheduling policy.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules) String() string {
	return tea.Prettify(s)
}

func (s ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules) GoString() string {
	return s.String()
}

func (s *ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules) SetDescription(v string) *ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules {
	s.Description = &v
	return s
}

func (s *ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules) SetId(v int64) *ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules {
	s.Id = &v
	return s
}

func (s *ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules) SetName(v string) *ListOnCallSchedulesResponseBodyPageBeanOnCallSchedules {
	s.Name = &v
	return s
}

type ListOnCallSchedulesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListOnCallSchedulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListOnCallSchedulesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListOnCallSchedulesResponse) GoString() string {
	return s.String()
}

func (s *ListOnCallSchedulesResponse) SetHeaders(v map[string]*string) *ListOnCallSchedulesResponse {
	s.Headers = v
	return s
}

func (s *ListOnCallSchedulesResponse) SetStatusCode(v int32) *ListOnCallSchedulesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListOnCallSchedulesResponse) SetBody(v *ListOnCallSchedulesResponseBody) *ListOnCallSchedulesResponse {
	s.Body = v
	return s
}

type ListPrometheusAlertRulesRequest struct {
	ClusterId        *string                                `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	MatchExpressions *string                                `json:"MatchExpressions,omitempty" xml:"MatchExpressions,omitempty"`
	Name             *string                                `json:"Name,omitempty" xml:"Name,omitempty"`
	RegionId         *string                                `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	Status           *int32                                 `json:"Status,omitempty" xml:"Status,omitempty"`
	Tags             []*ListPrometheusAlertRulesRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	Type             *string                                `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListPrometheusAlertRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusAlertRulesRequest) GoString() string {
	return s.String()
}

func (s *ListPrometheusAlertRulesRequest) SetClusterId(v string) *ListPrometheusAlertRulesRequest {
	s.ClusterId = &v
	return s
}

func (s *ListPrometheusAlertRulesRequest) SetMatchExpressions(v string) *ListPrometheusAlertRulesRequest {
	s.MatchExpressions = &v
	return s
}

func (s *ListPrometheusAlertRulesRequest) SetName(v string) *ListPrometheusAlertRulesRequest {
	s.Name = &v
	return s
}

func (s *ListPrometheusAlertRulesRequest) SetRegionId(v string) *ListPrometheusAlertRulesRequest {
	s.RegionId = &v
	return s
}

func (s *ListPrometheusAlertRulesRequest) SetStatus(v int32) *ListPrometheusAlertRulesRequest {
	s.Status = &v
	return s
}

func (s *ListPrometheusAlertRulesRequest) SetTags(v []*ListPrometheusAlertRulesRequestTags) *ListPrometheusAlertRulesRequest {
	s.Tags = v
	return s
}

func (s *ListPrometheusAlertRulesRequest) SetType(v string) *ListPrometheusAlertRulesRequest {
	s.Type = &v
	return s
}

type ListPrometheusAlertRulesRequestTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListPrometheusAlertRulesRequestTags) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusAlertRulesRequestTags) GoString() string {
	return s.String()
}

func (s *ListPrometheusAlertRulesRequestTags) SetKey(v string) *ListPrometheusAlertRulesRequestTags {
	s.Key = &v
	return s
}

func (s *ListPrometheusAlertRulesRequestTags) SetValue(v string) *ListPrometheusAlertRulesRequestTags {
	s.Value = &v
	return s
}

type ListPrometheusAlertRulesResponseBody struct {
	Code                 *int64                                                      `json:"Code,omitempty" xml:"Code,omitempty"`
	Message              *string                                                     `json:"Message,omitempty" xml:"Message,omitempty"`
	PrometheusAlertRules []*ListPrometheusAlertRulesResponseBodyPrometheusAlertRules `json:"PrometheusAlertRules,omitempty" xml:"PrometheusAlertRules,omitempty" type:"Repeated"`
	RequestId            *string                                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success              *bool                                                       `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListPrometheusAlertRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusAlertRulesResponseBody) GoString() string {
	return s.String()
}

func (s *ListPrometheusAlertRulesResponseBody) SetCode(v int64) *ListPrometheusAlertRulesResponseBody {
	s.Code = &v
	return s
}

func (s *ListPrometheusAlertRulesResponseBody) SetMessage(v string) *ListPrometheusAlertRulesResponseBody {
	s.Message = &v
	return s
}

func (s *ListPrometheusAlertRulesResponseBody) SetPrometheusAlertRules(v []*ListPrometheusAlertRulesResponseBodyPrometheusAlertRules) *ListPrometheusAlertRulesResponseBody {
	s.PrometheusAlertRules = v
	return s
}

func (s *ListPrometheusAlertRulesResponseBody) SetRequestId(v string) *ListPrometheusAlertRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListPrometheusAlertRulesResponseBody) SetSuccess(v bool) *ListPrometheusAlertRulesResponseBody {
	s.Success = &v
	return s
}

type ListPrometheusAlertRulesResponseBodyPrometheusAlertRules struct {
	AlertId        *int64                                                                 `json:"AlertId,omitempty" xml:"AlertId,omitempty"`
	AlertName      *string                                                                `json:"AlertName,omitempty" xml:"AlertName,omitempty"`
	Annotations    []*ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations `json:"Annotations,omitempty" xml:"Annotations,omitempty" type:"Repeated"`
	ClusterId      *string                                                                `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	DispatchRuleId *int64                                                                 `json:"DispatchRuleId,omitempty" xml:"DispatchRuleId,omitempty"`
	Duration       *string                                                                `json:"Duration,omitempty" xml:"Duration,omitempty"`
	Expression     *string                                                                `json:"Expression,omitempty" xml:"Expression,omitempty"`
	Labels         []*ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels      `json:"Labels,omitempty" xml:"Labels,omitempty" type:"Repeated"`
	Message        *string                                                                `json:"Message,omitempty" xml:"Message,omitempty"`
	NotifyType     *string                                                                `json:"NotifyType,omitempty" xml:"NotifyType,omitempty"`
	Status         *int32                                                                 `json:"Status,omitempty" xml:"Status,omitempty"`
	Tags           []*ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags        `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	Type           *string                                                                `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListPrometheusAlertRulesResponseBodyPrometheusAlertRules) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusAlertRulesResponseBodyPrometheusAlertRules) GoString() string {
	return s.String()
}

func (s *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules) SetAlertId(v int64) *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules {
	s.AlertId = &v
	return s
}

func (s *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules) SetAlertName(v string) *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules {
	s.AlertName = &v
	return s
}

func (s *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules) SetAnnotations(v []*ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations) *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules {
	s.Annotations = v
	return s
}

func (s *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules) SetClusterId(v string) *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules {
	s.ClusterId = &v
	return s
}

func (s *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules) SetDispatchRuleId(v int64) *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules {
	s.DispatchRuleId = &v
	return s
}

func (s *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules) SetDuration(v string) *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules {
	s.Duration = &v
	return s
}

func (s *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules) SetExpression(v string) *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules {
	s.Expression = &v
	return s
}

func (s *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules) SetLabels(v []*ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels) *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules {
	s.Labels = v
	return s
}

func (s *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules) SetMessage(v string) *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules {
	s.Message = &v
	return s
}

func (s *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules) SetNotifyType(v string) *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules {
	s.NotifyType = &v
	return s
}

func (s *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules) SetStatus(v int32) *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules {
	s.Status = &v
	return s
}

func (s *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules) SetTags(v []*ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags) *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules {
	s.Tags = v
	return s
}

func (s *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules) SetType(v string) *ListPrometheusAlertRulesResponseBodyPrometheusAlertRules {
	s.Type = &v
	return s
}

type ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations struct {
	Name  *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations) GoString() string {
	return s.String()
}

func (s *ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations) SetName(v string) *ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations {
	s.Name = &v
	return s
}

func (s *ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations) SetValue(v string) *ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesAnnotations {
	s.Value = &v
	return s
}

type ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels struct {
	Name  *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels) GoString() string {
	return s.String()
}

func (s *ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels) SetName(v string) *ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels {
	s.Name = &v
	return s
}

func (s *ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels) SetValue(v string) *ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesLabels {
	s.Value = &v
	return s
}

type ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags) GoString() string {
	return s.String()
}

func (s *ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags) SetKey(v string) *ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags {
	s.Key = &v
	return s
}

func (s *ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags) SetValue(v string) *ListPrometheusAlertRulesResponseBodyPrometheusAlertRulesTags {
	s.Value = &v
	return s
}

type ListPrometheusAlertRulesResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListPrometheusAlertRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListPrometheusAlertRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusAlertRulesResponse) GoString() string {
	return s.String()
}

func (s *ListPrometheusAlertRulesResponse) SetHeaders(v map[string]*string) *ListPrometheusAlertRulesResponse {
	s.Headers = v
	return s
}

func (s *ListPrometheusAlertRulesResponse) SetStatusCode(v int32) *ListPrometheusAlertRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListPrometheusAlertRulesResponse) SetBody(v *ListPrometheusAlertRulesResponseBody) *ListPrometheusAlertRulesResponse {
	s.Body = v
	return s
}

type ListPrometheusAlertTemplatesRequest struct {
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	RegionId  *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListPrometheusAlertTemplatesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusAlertTemplatesRequest) GoString() string {
	return s.String()
}

func (s *ListPrometheusAlertTemplatesRequest) SetClusterId(v string) *ListPrometheusAlertTemplatesRequest {
	s.ClusterId = &v
	return s
}

func (s *ListPrometheusAlertTemplatesRequest) SetRegionId(v string) *ListPrometheusAlertTemplatesRequest {
	s.RegionId = &v
	return s
}

type ListPrometheusAlertTemplatesResponseBody struct {
	PrometheusAlertTemplates []*ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates `json:"PrometheusAlertTemplates,omitempty" xml:"PrometheusAlertTemplates,omitempty" type:"Repeated"`
	RequestId                *string                                                             `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListPrometheusAlertTemplatesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusAlertTemplatesResponseBody) GoString() string {
	return s.String()
}

func (s *ListPrometheusAlertTemplatesResponseBody) SetPrometheusAlertTemplates(v []*ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates) *ListPrometheusAlertTemplatesResponseBody {
	s.PrometheusAlertTemplates = v
	return s
}

func (s *ListPrometheusAlertTemplatesResponseBody) SetRequestId(v string) *ListPrometheusAlertTemplatesResponseBody {
	s.RequestId = &v
	return s
}

type ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates struct {
	AlertName   *string                                                                        `json:"AlertName,omitempty" xml:"AlertName,omitempty"`
	Annotations []*ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations `json:"Annotations,omitempty" xml:"Annotations,omitempty" type:"Repeated"`
	Description *string                                                                        `json:"Description,omitempty" xml:"Description,omitempty"`
	Duration    *string                                                                        `json:"Duration,omitempty" xml:"Duration,omitempty"`
	Expression  *string                                                                        `json:"Expression,omitempty" xml:"Expression,omitempty"`
	Labels      []*ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels      `json:"Labels,omitempty" xml:"Labels,omitempty" type:"Repeated"`
	Type        *string                                                                        `json:"Type,omitempty" xml:"Type,omitempty"`
	Version     *string                                                                        `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates) GoString() string {
	return s.String()
}

func (s *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates) SetAlertName(v string) *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates {
	s.AlertName = &v
	return s
}

func (s *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates) SetAnnotations(v []*ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations) *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates {
	s.Annotations = v
	return s
}

func (s *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates) SetDescription(v string) *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates {
	s.Description = &v
	return s
}

func (s *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates) SetDuration(v string) *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates {
	s.Duration = &v
	return s
}

func (s *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates) SetExpression(v string) *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates {
	s.Expression = &v
	return s
}

func (s *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates) SetLabels(v []*ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels) *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates {
	s.Labels = v
	return s
}

func (s *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates) SetType(v string) *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates {
	s.Type = &v
	return s
}

func (s *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates) SetVersion(v string) *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplates {
	s.Version = &v
	return s
}

type ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations struct {
	Name  *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations) GoString() string {
	return s.String()
}

func (s *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations) SetName(v string) *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations {
	s.Name = &v
	return s
}

func (s *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations) SetValue(v string) *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesAnnotations {
	s.Value = &v
	return s
}

type ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels struct {
	Name  *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels) GoString() string {
	return s.String()
}

func (s *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels) SetName(v string) *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels {
	s.Name = &v
	return s
}

func (s *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels) SetValue(v string) *ListPrometheusAlertTemplatesResponseBodyPrometheusAlertTemplatesLabels {
	s.Value = &v
	return s
}

type ListPrometheusAlertTemplatesResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListPrometheusAlertTemplatesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListPrometheusAlertTemplatesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusAlertTemplatesResponse) GoString() string {
	return s.String()
}

func (s *ListPrometheusAlertTemplatesResponse) SetHeaders(v map[string]*string) *ListPrometheusAlertTemplatesResponse {
	s.Headers = v
	return s
}

func (s *ListPrometheusAlertTemplatesResponse) SetStatusCode(v int32) *ListPrometheusAlertTemplatesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListPrometheusAlertTemplatesResponse) SetBody(v *ListPrometheusAlertTemplatesResponseBody) *ListPrometheusAlertTemplatesResponse {
	s.Body = v
	return s
}

type ListPrometheusGlobalViewRequest struct {
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListPrometheusGlobalViewRequest) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusGlobalViewRequest) GoString() string {
	return s.String()
}

func (s *ListPrometheusGlobalViewRequest) SetRegionId(v string) *ListPrometheusGlobalViewRequest {
	s.RegionId = &v
	return s
}

type ListPrometheusGlobalViewResponseBody struct {
	Code      *int32  `json:"Code,omitempty" xml:"Code,omitempty"`
	Data      *string `json:"Data,omitempty" xml:"Data,omitempty"`
	Message   *string `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListPrometheusGlobalViewResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusGlobalViewResponseBody) GoString() string {
	return s.String()
}

func (s *ListPrometheusGlobalViewResponseBody) SetCode(v int32) *ListPrometheusGlobalViewResponseBody {
	s.Code = &v
	return s
}

func (s *ListPrometheusGlobalViewResponseBody) SetData(v string) *ListPrometheusGlobalViewResponseBody {
	s.Data = &v
	return s
}

func (s *ListPrometheusGlobalViewResponseBody) SetMessage(v string) *ListPrometheusGlobalViewResponseBody {
	s.Message = &v
	return s
}

func (s *ListPrometheusGlobalViewResponseBody) SetRequestId(v string) *ListPrometheusGlobalViewResponseBody {
	s.RequestId = &v
	return s
}

type ListPrometheusGlobalViewResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListPrometheusGlobalViewResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListPrometheusGlobalViewResponse) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusGlobalViewResponse) GoString() string {
	return s.String()
}

func (s *ListPrometheusGlobalViewResponse) SetHeaders(v map[string]*string) *ListPrometheusGlobalViewResponse {
	s.Headers = v
	return s
}

func (s *ListPrometheusGlobalViewResponse) SetStatusCode(v int32) *ListPrometheusGlobalViewResponse {
	s.StatusCode = &v
	return s
}

func (s *ListPrometheusGlobalViewResponse) SetBody(v *ListPrometheusGlobalViewResponseBody) *ListPrometheusGlobalViewResponse {
	s.Body = v
	return s
}

type ListPrometheusInstanceByTagAndResourceGroupIdRequest struct {
	// The region ID of the Prometheus instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The tags.
	Tag []*ListPrometheusInstanceByTagAndResourceGroupIdRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s ListPrometheusInstanceByTagAndResourceGroupIdRequest) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusInstanceByTagAndResourceGroupIdRequest) GoString() string {
	return s.String()
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdRequest) SetRegionId(v string) *ListPrometheusInstanceByTagAndResourceGroupIdRequest {
	s.RegionId = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdRequest) SetResourceGroupId(v string) *ListPrometheusInstanceByTagAndResourceGroupIdRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdRequest) SetTag(v []*ListPrometheusInstanceByTagAndResourceGroupIdRequestTag) *ListPrometheusInstanceByTagAndResourceGroupIdRequest {
	s.Tag = v
	return s
}

type ListPrometheusInstanceByTagAndResourceGroupIdRequestTag struct {
	// The key of the tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListPrometheusInstanceByTagAndResourceGroupIdRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusInstanceByTagAndResourceGroupIdRequestTag) GoString() string {
	return s.String()
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdRequestTag) SetKey(v string) *ListPrometheusInstanceByTagAndResourceGroupIdRequestTag {
	s.Key = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdRequestTag) SetValue(v string) *ListPrometheusInstanceByTagAndResourceGroupIdRequestTag {
	s.Value = &v
	return s
}

type ListPrometheusInstanceByTagAndResourceGroupIdResponseBody struct {
	// The response code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The struct returned.
	Data *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListPrometheusInstanceByTagAndResourceGroupIdResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusInstanceByTagAndResourceGroupIdResponseBody) GoString() string {
	return s.String()
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBody) SetCode(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBody {
	s.Code = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBody) SetData(v *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBody {
	s.Data = v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBody) SetMessage(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBody {
	s.Message = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBody) SetRequestId(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBody {
	s.RequestId = &v
	return s
}

type ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData struct {
	// The queried Prometheus instances.
	PrometheusInstances []*ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances `json:"PrometheusInstances,omitempty" xml:"PrometheusInstances,omitempty" type:"Repeated"`
}

func (s ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData) SetPrometheusInstances(v []*ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyData {
	s.PrometheusInstances = v
	return s
}

type ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances struct {
	// Auth Token string.
	AuthToken *string `json:"AuthToken,omitempty" xml:"AuthToken,omitempty"`
	// The ID of the Prometheus instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the Prometheus instance.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The type of the cluster. Valid values: remote-write: Prometheus instance for remote write.
	//
	// *   ecs: Prometheus instances for ECS.
	// *   cloud-monitor: Prometheus instance for Alibaba Cloud services in the Chinese mainland.
	// *   cloud-product: Prometheus instance for Alibaba Cloud services outside China.
	// *   global-view: Prometheus instance for GlobalView.
	// *   aliyun-cs: Prometheus instance for Container Service.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The ID of the Grafana workspace.
	GrafanaInstanceId *string `json:"GrafanaInstanceId,omitempty" xml:"GrafanaInstanceId,omitempty"`
	// HTTP Api internet url.
	HttpApiInterUrl *string `json:"HttpApiInterUrl,omitempty" xml:"HttpApiInterUrl,omitempty"`
	// HTTP Api intranet url.
	HttpApiIntraUrl *string `json:"HttpApiIntraUrl,omitempty" xml:"HttpApiIntraUrl,omitempty"`
	// The billing method. Valid values:
	//
	// *   PREPAY: subscription.
	// *   POSTPAY: pay-as-you-go.
	PaymentType *string `json:"PaymentType,omitempty" xml:"PaymentType,omitempty"`
	// Push Gateway internet url.
	PushGatewayInterUrl *string `json:"PushGatewayInterUrl,omitempty" xml:"PushGatewayInterUrl,omitempty"`
	// Push Gateway intranet url.
	PushGatewayIntraUrl *string `json:"PushGatewayIntraUrl,omitempty" xml:"PushGatewayIntraUrl,omitempty"`
	// The region ID of the Prometheus instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Remote Read internet url.
	RemoteReadInterUrl *string `json:"RemoteReadInterUrl,omitempty" xml:"RemoteReadInterUrl,omitempty"`
	// Remote Read intranet url.
	RemoteReadIntraUrl *string `json:"RemoteReadIntraUrl,omitempty" xml:"RemoteReadIntraUrl,omitempty"`
	// Remote Write internet url.
	RemoteWriteInterUrl *string `json:"RemoteWriteInterUrl,omitempty" xml:"RemoteWriteInterUrl,omitempty"`
	// Remote Write intranet url.
	RemoteWriteIntraUrl *string `json:"RemoteWriteIntraUrl,omitempty" xml:"RemoteWriteIntraUrl,omitempty"`
	// The ID of the resource group to which the Prometheus instance belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Resource type.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The ID of the security group.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// The child instances of the Prometheus instance for GlobalView instance. The value is a JSON string.
	SubClustersJson *string `json:"SubClustersJson,omitempty" xml:"SubClustersJson,omitempty"`
	// The tags.
	Tags []*ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The ID of the vSwitch.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the virtual private cloud (VPC).
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) GoString() string {
	return s.String()
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) SetAuthToken(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances {
	s.AuthToken = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) SetClusterId(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances {
	s.ClusterId = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) SetClusterName(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances {
	s.ClusterName = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) SetClusterType(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances {
	s.ClusterType = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) SetGrafanaInstanceId(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances {
	s.GrafanaInstanceId = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) SetHttpApiInterUrl(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances {
	s.HttpApiInterUrl = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) SetHttpApiIntraUrl(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances {
	s.HttpApiIntraUrl = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) SetPaymentType(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances {
	s.PaymentType = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) SetPushGatewayInterUrl(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances {
	s.PushGatewayInterUrl = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) SetPushGatewayIntraUrl(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances {
	s.PushGatewayIntraUrl = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) SetRegionId(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances {
	s.RegionId = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) SetRemoteReadInterUrl(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances {
	s.RemoteReadInterUrl = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) SetRemoteReadIntraUrl(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances {
	s.RemoteReadIntraUrl = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) SetRemoteWriteInterUrl(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances {
	s.RemoteWriteInterUrl = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) SetRemoteWriteIntraUrl(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances {
	s.RemoteWriteIntraUrl = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) SetResourceGroupId(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances {
	s.ResourceGroupId = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) SetResourceType(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances {
	s.ResourceType = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) SetSecurityGroupId(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances {
	s.SecurityGroupId = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) SetSubClustersJson(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances {
	s.SubClustersJson = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) SetTags(v []*ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances {
	s.Tags = v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) SetUserId(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances {
	s.UserId = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) SetVSwitchId(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances {
	s.VSwitchId = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances) SetVpcId(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstances {
	s.VpcId = &v
	return s
}

type ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags struct {
	// The key of the tag.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The value of the tag.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags) GoString() string {
	return s.String()
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags) SetTagKey(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags {
	s.TagKey = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags) SetTagValue(v string) *ListPrometheusInstanceByTagAndResourceGroupIdResponseBodyDataPrometheusInstancesTags {
	s.TagValue = &v
	return s
}

type ListPrometheusInstanceByTagAndResourceGroupIdResponse struct {
	Headers    map[string]*string                                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListPrometheusInstanceByTagAndResourceGroupIdResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListPrometheusInstanceByTagAndResourceGroupIdResponse) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusInstanceByTagAndResourceGroupIdResponse) GoString() string {
	return s.String()
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponse) SetHeaders(v map[string]*string) *ListPrometheusInstanceByTagAndResourceGroupIdResponse {
	s.Headers = v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponse) SetStatusCode(v int32) *ListPrometheusInstanceByTagAndResourceGroupIdResponse {
	s.StatusCode = &v
	return s
}

func (s *ListPrometheusInstanceByTagAndResourceGroupIdResponse) SetBody(v *ListPrometheusInstanceByTagAndResourceGroupIdResponseBody) *ListPrometheusInstanceByTagAndResourceGroupIdResponse {
	s.Body = v
	return s
}

type ListPrometheusInstancesRequest struct {
	// Optional instance types (if left blank, all types of instances will be queried):
	// - cloud-product-prometheus
	// - ManagedKubernetes
	// - satellite
	// - Ask
	// - remote-write-prometheus
	// - cloud-monitor-cmee
	// - ExternalKubernetes
	// - vpc-prometheus
	// - cloud-monitor-direct
	// - Edge Kubernetes
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Specifies whether to query global aggregation instances. Valid values:
	//
	// *   true
	// *   false
	ShowGlobalView *bool `json:"ShowGlobalView,omitempty" xml:"ShowGlobalView,omitempty"`
}

func (s ListPrometheusInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusInstancesRequest) GoString() string {
	return s.String()
}

func (s *ListPrometheusInstancesRequest) SetClusterType(v string) *ListPrometheusInstancesRequest {
	s.ClusterType = &v
	return s
}

func (s *ListPrometheusInstancesRequest) SetRegionId(v string) *ListPrometheusInstancesRequest {
	s.RegionId = &v
	return s
}

func (s *ListPrometheusInstancesRequest) SetShowGlobalView(v bool) *ListPrometheusInstancesRequest {
	s.ShowGlobalView = &v
	return s
}

type ListPrometheusInstancesResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The Prometheus instances in the region in the JSON format.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListPrometheusInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *ListPrometheusInstancesResponseBody) SetCode(v int32) *ListPrometheusInstancesResponseBody {
	s.Code = &v
	return s
}

func (s *ListPrometheusInstancesResponseBody) SetData(v string) *ListPrometheusInstancesResponseBody {
	s.Data = &v
	return s
}

func (s *ListPrometheusInstancesResponseBody) SetMessage(v string) *ListPrometheusInstancesResponseBody {
	s.Message = &v
	return s
}

func (s *ListPrometheusInstancesResponseBody) SetRequestId(v string) *ListPrometheusInstancesResponseBody {
	s.RequestId = &v
	return s
}

type ListPrometheusInstancesResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListPrometheusInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListPrometheusInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusInstancesResponse) GoString() string {
	return s.String()
}

func (s *ListPrometheusInstancesResponse) SetHeaders(v map[string]*string) *ListPrometheusInstancesResponse {
	s.Headers = v
	return s
}

func (s *ListPrometheusInstancesResponse) SetStatusCode(v int32) *ListPrometheusInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListPrometheusInstancesResponse) SetBody(v *ListPrometheusInstancesResponseBody) *ListPrometheusInstancesResponse {
	s.Body = v
	return s
}

type ListPrometheusIntegrationRequest struct {
	// The ID of the Prometheus instance. Only aliyun-cs and ecs instances are supported.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The integration type.
	IntegrationType *string `json:"IntegrationType,omitempty" xml:"IntegrationType,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListPrometheusIntegrationRequest) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusIntegrationRequest) GoString() string {
	return s.String()
}

func (s *ListPrometheusIntegrationRequest) SetClusterId(v string) *ListPrometheusIntegrationRequest {
	s.ClusterId = &v
	return s
}

func (s *ListPrometheusIntegrationRequest) SetIntegrationType(v string) *ListPrometheusIntegrationRequest {
	s.IntegrationType = &v
	return s
}

func (s *ListPrometheusIntegrationRequest) SetRegionId(v string) *ListPrometheusIntegrationRequest {
	s.RegionId = &v
	return s
}

type ListPrometheusIntegrationResponseBody struct {
	// The response code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The queried exporters.
	Data []*ListPrometheusIntegrationResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListPrometheusIntegrationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusIntegrationResponseBody) GoString() string {
	return s.String()
}

func (s *ListPrometheusIntegrationResponseBody) SetCode(v int32) *ListPrometheusIntegrationResponseBody {
	s.Code = &v
	return s
}

func (s *ListPrometheusIntegrationResponseBody) SetData(v []*ListPrometheusIntegrationResponseBodyData) *ListPrometheusIntegrationResponseBody {
	s.Data = v
	return s
}

func (s *ListPrometheusIntegrationResponseBody) SetMessage(v string) *ListPrometheusIntegrationResponseBody {
	s.Message = &v
	return s
}

func (s *ListPrometheusIntegrationResponseBody) SetRequestId(v string) *ListPrometheusIntegrationResponseBody {
	s.RequestId = &v
	return s
}

type ListPrometheusIntegrationResponseBodyData struct {
	// Indicates whether the exporter can be deleted.
	CanDelete *bool `json:"CanDelete,omitempty" xml:"CanDelete,omitempty"`
	// Indicates whether the exporter can be edited.
	CanEditor *bool `json:"CanEditor,omitempty" xml:"CanEditor,omitempty"`
	// The ID of the Prometheus instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the container.
	ContainerName *string `json:"ContainerName,omitempty" xml:"ContainerName,omitempty"`
	// The description of the exporter.
	Describe *string `json:"Describe,omitempty" xml:"Describe,omitempty"`
	// The type of the exporter.
	ExporterType *string `json:"ExporterType,omitempty" xml:"ExporterType,omitempty"`
	// The exporter ID.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the exporter.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The integration type.
	IntegrationType *string `json:"IntegrationType,omitempty" xml:"IntegrationType,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// Indicates whether an upgrade is required.
	NeedUpgrade *bool `json:"NeedUpgrade,omitempty" xml:"NeedUpgrade,omitempty"`
	// The configurations of the exporter. The value is a JSON string.
	Param *string `json:"Param,omitempty" xml:"Param,omitempty"`
	// The pod name of the exporter.
	PodName *string `json:"PodName,omitempty" xml:"PodName,omitempty"`
	// Indicates whether the description is displayed.
	ShowDescribe *bool `json:"ShowDescribe,omitempty" xml:"ShowDescribe,omitempty"`
	// Indicates whether the exporter logs are displayed.
	ShowLog *bool `json:"ShowLog,omitempty" xml:"ShowLog,omitempty"`
	// The state of the exporter.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The monitored IP address.
	Target *string `json:"Target,omitempty" xml:"Target,omitempty"`
	// The version number.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s ListPrometheusIntegrationResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusIntegrationResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListPrometheusIntegrationResponseBodyData) SetCanDelete(v bool) *ListPrometheusIntegrationResponseBodyData {
	s.CanDelete = &v
	return s
}

func (s *ListPrometheusIntegrationResponseBodyData) SetCanEditor(v bool) *ListPrometheusIntegrationResponseBodyData {
	s.CanEditor = &v
	return s
}

func (s *ListPrometheusIntegrationResponseBodyData) SetClusterId(v string) *ListPrometheusIntegrationResponseBodyData {
	s.ClusterId = &v
	return s
}

func (s *ListPrometheusIntegrationResponseBodyData) SetContainerName(v string) *ListPrometheusIntegrationResponseBodyData {
	s.ContainerName = &v
	return s
}

func (s *ListPrometheusIntegrationResponseBodyData) SetDescribe(v string) *ListPrometheusIntegrationResponseBodyData {
	s.Describe = &v
	return s
}

func (s *ListPrometheusIntegrationResponseBodyData) SetExporterType(v string) *ListPrometheusIntegrationResponseBodyData {
	s.ExporterType = &v
	return s
}

func (s *ListPrometheusIntegrationResponseBodyData) SetInstanceId(v int64) *ListPrometheusIntegrationResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *ListPrometheusIntegrationResponseBodyData) SetInstanceName(v string) *ListPrometheusIntegrationResponseBodyData {
	s.InstanceName = &v
	return s
}

func (s *ListPrometheusIntegrationResponseBodyData) SetIntegrationType(v string) *ListPrometheusIntegrationResponseBodyData {
	s.IntegrationType = &v
	return s
}

func (s *ListPrometheusIntegrationResponseBodyData) SetNamespace(v string) *ListPrometheusIntegrationResponseBodyData {
	s.Namespace = &v
	return s
}

func (s *ListPrometheusIntegrationResponseBodyData) SetNeedUpgrade(v bool) *ListPrometheusIntegrationResponseBodyData {
	s.NeedUpgrade = &v
	return s
}

func (s *ListPrometheusIntegrationResponseBodyData) SetParam(v string) *ListPrometheusIntegrationResponseBodyData {
	s.Param = &v
	return s
}

func (s *ListPrometheusIntegrationResponseBodyData) SetPodName(v string) *ListPrometheusIntegrationResponseBodyData {
	s.PodName = &v
	return s
}

func (s *ListPrometheusIntegrationResponseBodyData) SetShowDescribe(v bool) *ListPrometheusIntegrationResponseBodyData {
	s.ShowDescribe = &v
	return s
}

func (s *ListPrometheusIntegrationResponseBodyData) SetShowLog(v bool) *ListPrometheusIntegrationResponseBodyData {
	s.ShowLog = &v
	return s
}

func (s *ListPrometheusIntegrationResponseBodyData) SetStatus(v string) *ListPrometheusIntegrationResponseBodyData {
	s.Status = &v
	return s
}

func (s *ListPrometheusIntegrationResponseBodyData) SetTarget(v string) *ListPrometheusIntegrationResponseBodyData {
	s.Target = &v
	return s
}

func (s *ListPrometheusIntegrationResponseBodyData) SetVersion(v string) *ListPrometheusIntegrationResponseBodyData {
	s.Version = &v
	return s
}

type ListPrometheusIntegrationResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListPrometheusIntegrationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListPrometheusIntegrationResponse) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusIntegrationResponse) GoString() string {
	return s.String()
}

func (s *ListPrometheusIntegrationResponse) SetHeaders(v map[string]*string) *ListPrometheusIntegrationResponse {
	s.Headers = v
	return s
}

func (s *ListPrometheusIntegrationResponse) SetStatusCode(v int32) *ListPrometheusIntegrationResponse {
	s.StatusCode = &v
	return s
}

func (s *ListPrometheusIntegrationResponse) SetBody(v *ListPrometheusIntegrationResponseBody) *ListPrometheusIntegrationResponse {
	s.Body = v
	return s
}

type ListPrometheusMonitoringRequest struct {
	// The ID of the Prometheus instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The region ID. Default value: `cn-hangzhou`.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The type of the monitoring configuration. Valid values for a Prometheus instance for Container Service: serviceMonitor, podMonitor, customJob, and probe. Valid values for a Prometheus instance for ECS: customJob and probe.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListPrometheusMonitoringRequest) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusMonitoringRequest) GoString() string {
	return s.String()
}

func (s *ListPrometheusMonitoringRequest) SetClusterId(v string) *ListPrometheusMonitoringRequest {
	s.ClusterId = &v
	return s
}

func (s *ListPrometheusMonitoringRequest) SetRegionId(v string) *ListPrometheusMonitoringRequest {
	s.RegionId = &v
	return s
}

func (s *ListPrometheusMonitoringRequest) SetType(v string) *ListPrometheusMonitoringRequest {
	s.Type = &v
	return s
}

type ListPrometheusMonitoringResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned struct.
	Data []*ListPrometheusMonitoringResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListPrometheusMonitoringResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusMonitoringResponseBody) GoString() string {
	return s.String()
}

func (s *ListPrometheusMonitoringResponseBody) SetCode(v int32) *ListPrometheusMonitoringResponseBody {
	s.Code = &v
	return s
}

func (s *ListPrometheusMonitoringResponseBody) SetData(v []*ListPrometheusMonitoringResponseBodyData) *ListPrometheusMonitoringResponseBody {
	s.Data = v
	return s
}

func (s *ListPrometheusMonitoringResponseBody) SetMessage(v string) *ListPrometheusMonitoringResponseBody {
	s.Message = &v
	return s
}

func (s *ListPrometheusMonitoringResponseBody) SetRequestId(v string) *ListPrometheusMonitoringResponseBody {
	s.RequestId = &v
	return s
}

type ListPrometheusMonitoringResponseBodyData struct {
	// Prometheus Instance ID.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The monitoring configuration. The value is a YAML string.
	ConfigYaml *string `json:"ConfigYaml,omitempty" xml:"ConfigYaml,omitempty"`
	// The name of the monitoring configuration.
	MonitoringName *string `json:"MonitoringName,omitempty" xml:"MonitoringName,omitempty"`
	// The status of the monitoring configuration.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the monitoring configuration.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListPrometheusMonitoringResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusMonitoringResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListPrometheusMonitoringResponseBodyData) SetClusterId(v string) *ListPrometheusMonitoringResponseBodyData {
	s.ClusterId = &v
	return s
}

func (s *ListPrometheusMonitoringResponseBodyData) SetConfigYaml(v string) *ListPrometheusMonitoringResponseBodyData {
	s.ConfigYaml = &v
	return s
}

func (s *ListPrometheusMonitoringResponseBodyData) SetMonitoringName(v string) *ListPrometheusMonitoringResponseBodyData {
	s.MonitoringName = &v
	return s
}

func (s *ListPrometheusMonitoringResponseBodyData) SetStatus(v string) *ListPrometheusMonitoringResponseBodyData {
	s.Status = &v
	return s
}

func (s *ListPrometheusMonitoringResponseBodyData) SetType(v string) *ListPrometheusMonitoringResponseBodyData {
	s.Type = &v
	return s
}

type ListPrometheusMonitoringResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListPrometheusMonitoringResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListPrometheusMonitoringResponse) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusMonitoringResponse) GoString() string {
	return s.String()
}

func (s *ListPrometheusMonitoringResponse) SetHeaders(v map[string]*string) *ListPrometheusMonitoringResponse {
	s.Headers = v
	return s
}

func (s *ListPrometheusMonitoringResponse) SetStatusCode(v int32) *ListPrometheusMonitoringResponse {
	s.StatusCode = &v
	return s
}

func (s *ListPrometheusMonitoringResponse) SetBody(v *ListPrometheusMonitoringResponseBody) *ListPrometheusMonitoringResponse {
	s.Body = v
	return s
}

type ListPrometheusRemoteWritesRequest struct {
	// The ID of the Prometheus instance. Only a Prometheus instance for Container Service or a Prometheus instance for ECS is supported.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListPrometheusRemoteWritesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusRemoteWritesRequest) GoString() string {
	return s.String()
}

func (s *ListPrometheusRemoteWritesRequest) SetClusterId(v string) *ListPrometheusRemoteWritesRequest {
	s.ClusterId = &v
	return s
}

func (s *ListPrometheusRemoteWritesRequest) SetRegionId(v string) *ListPrometheusRemoteWritesRequest {
	s.RegionId = &v
	return s
}

type ListPrometheusRemoteWritesResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The remote write configuration items returned.
	Data []*ListPrometheusRemoteWritesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values: true and false.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListPrometheusRemoteWritesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusRemoteWritesResponseBody) GoString() string {
	return s.String()
}

func (s *ListPrometheusRemoteWritesResponseBody) SetCode(v int32) *ListPrometheusRemoteWritesResponseBody {
	s.Code = &v
	return s
}

func (s *ListPrometheusRemoteWritesResponseBody) SetData(v []*ListPrometheusRemoteWritesResponseBodyData) *ListPrometheusRemoteWritesResponseBody {
	s.Data = v
	return s
}

func (s *ListPrometheusRemoteWritesResponseBody) SetMessage(v string) *ListPrometheusRemoteWritesResponseBody {
	s.Message = &v
	return s
}

func (s *ListPrometheusRemoteWritesResponseBody) SetRequestId(v string) *ListPrometheusRemoteWritesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListPrometheusRemoteWritesResponseBody) SetSuccess(v bool) *ListPrometheusRemoteWritesResponseBody {
	s.Success = &v
	return s
}

type ListPrometheusRemoteWritesResponseBodyData struct {
	// The ID of the Prometheus instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the remote write configuration item.
	RemoteWriteName *string `json:"RemoteWriteName,omitempty" xml:"RemoteWriteName,omitempty"`
	// The information about the queried remote write configuration item of the Prometheus instance. The information is displayed in the YAML format.
	RemoteWriteYaml *string `json:"RemoteWriteYaml,omitempty" xml:"RemoteWriteYaml,omitempty"`
}

func (s ListPrometheusRemoteWritesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusRemoteWritesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListPrometheusRemoteWritesResponseBodyData) SetClusterId(v string) *ListPrometheusRemoteWritesResponseBodyData {
	s.ClusterId = &v
	return s
}

func (s *ListPrometheusRemoteWritesResponseBodyData) SetRemoteWriteName(v string) *ListPrometheusRemoteWritesResponseBodyData {
	s.RemoteWriteName = &v
	return s
}

func (s *ListPrometheusRemoteWritesResponseBodyData) SetRemoteWriteYaml(v string) *ListPrometheusRemoteWritesResponseBodyData {
	s.RemoteWriteYaml = &v
	return s
}

type ListPrometheusRemoteWritesResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListPrometheusRemoteWritesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListPrometheusRemoteWritesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListPrometheusRemoteWritesResponse) GoString() string {
	return s.String()
}

func (s *ListPrometheusRemoteWritesResponse) SetHeaders(v map[string]*string) *ListPrometheusRemoteWritesResponse {
	s.Headers = v
	return s
}

func (s *ListPrometheusRemoteWritesResponse) SetStatusCode(v int32) *ListPrometheusRemoteWritesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListPrometheusRemoteWritesResponse) SetBody(v *ListPrometheusRemoteWritesResponseBody) *ListPrometheusRemoteWritesResponse {
	s.Body = v
	return s
}

type ListRetcodeAppsRequest struct {
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group. You can obtain the resource group ID in the **Resource Management** console.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The tags.
	Tags []*ListRetcodeAppsRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s ListRetcodeAppsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListRetcodeAppsRequest) GoString() string {
	return s.String()
}

func (s *ListRetcodeAppsRequest) SetRegionId(v string) *ListRetcodeAppsRequest {
	s.RegionId = &v
	return s
}

func (s *ListRetcodeAppsRequest) SetResourceGroupId(v string) *ListRetcodeAppsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListRetcodeAppsRequest) SetTags(v []*ListRetcodeAppsRequestTags) *ListRetcodeAppsRequest {
	s.Tags = v
	return s
}

type ListRetcodeAppsRequestTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListRetcodeAppsRequestTags) String() string {
	return tea.Prettify(s)
}

func (s ListRetcodeAppsRequestTags) GoString() string {
	return s.String()
}

func (s *ListRetcodeAppsRequestTags) SetKey(v string) *ListRetcodeAppsRequestTags {
	s.Key = &v
	return s
}

func (s *ListRetcodeAppsRequestTags) SetValue(v string) *ListRetcodeAppsRequestTags {
	s.Value = &v
	return s
}

type ListRetcodeAppsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of applications monitored by Browser Monitoring.
	RetcodeApps []*ListRetcodeAppsResponseBodyRetcodeApps `json:"RetcodeApps,omitempty" xml:"RetcodeApps,omitempty" type:"Repeated"`
}

func (s ListRetcodeAppsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListRetcodeAppsResponseBody) GoString() string {
	return s.String()
}

func (s *ListRetcodeAppsResponseBody) SetRequestId(v string) *ListRetcodeAppsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListRetcodeAppsResponseBody) SetRetcodeApps(v []*ListRetcodeAppsResponseBodyRetcodeApps) *ListRetcodeAppsResponseBody {
	s.RetcodeApps = v
	return s
}

type ListRetcodeAppsResponseBodyRetcodeApps struct {
	// The ID of the application. The parameter is an auto-increment parameter.
	AppId *int64 `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The alias of the application monitored by Browser Monitoring.
	NickName *string `json:"NickName,omitempty" xml:"NickName,omitempty"`
	// The PID of the application.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The type of the application. Valid values:
	//
	// *   `web`: web application
	// *   `weex`: Weex mobile app
	// *   `mini_dd`: DingTalk mini program
	// *   `mini_alipay`: Alipay mini program
	// *   `mini_wx`: WeChat mini program
	// *   `mini_common`: mini program on other platforms
	RetcodeAppType *string `json:"RetcodeAppType,omitempty" xml:"RetcodeAppType,omitempty"`
	// The tags.
	Tags []*ListRetcodeAppsResponseBodyRetcodeAppsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s ListRetcodeAppsResponseBodyRetcodeApps) String() string {
	return tea.Prettify(s)
}

func (s ListRetcodeAppsResponseBodyRetcodeApps) GoString() string {
	return s.String()
}

func (s *ListRetcodeAppsResponseBodyRetcodeApps) SetAppId(v int64) *ListRetcodeAppsResponseBodyRetcodeApps {
	s.AppId = &v
	return s
}

func (s *ListRetcodeAppsResponseBodyRetcodeApps) SetAppName(v string) *ListRetcodeAppsResponseBodyRetcodeApps {
	s.AppName = &v
	return s
}

func (s *ListRetcodeAppsResponseBodyRetcodeApps) SetNickName(v string) *ListRetcodeAppsResponseBodyRetcodeApps {
	s.NickName = &v
	return s
}

func (s *ListRetcodeAppsResponseBodyRetcodeApps) SetPid(v string) *ListRetcodeAppsResponseBodyRetcodeApps {
	s.Pid = &v
	return s
}

func (s *ListRetcodeAppsResponseBodyRetcodeApps) SetResourceGroupId(v string) *ListRetcodeAppsResponseBodyRetcodeApps {
	s.ResourceGroupId = &v
	return s
}

func (s *ListRetcodeAppsResponseBodyRetcodeApps) SetRetcodeAppType(v string) *ListRetcodeAppsResponseBodyRetcodeApps {
	s.RetcodeAppType = &v
	return s
}

func (s *ListRetcodeAppsResponseBodyRetcodeApps) SetTags(v []*ListRetcodeAppsResponseBodyRetcodeAppsTags) *ListRetcodeAppsResponseBodyRetcodeApps {
	s.Tags = v
	return s
}

type ListRetcodeAppsResponseBodyRetcodeAppsTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListRetcodeAppsResponseBodyRetcodeAppsTags) String() string {
	return tea.Prettify(s)
}

func (s ListRetcodeAppsResponseBodyRetcodeAppsTags) GoString() string {
	return s.String()
}

func (s *ListRetcodeAppsResponseBodyRetcodeAppsTags) SetKey(v string) *ListRetcodeAppsResponseBodyRetcodeAppsTags {
	s.Key = &v
	return s
}

func (s *ListRetcodeAppsResponseBodyRetcodeAppsTags) SetValue(v string) *ListRetcodeAppsResponseBodyRetcodeAppsTags {
	s.Value = &v
	return s
}

type ListRetcodeAppsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListRetcodeAppsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListRetcodeAppsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListRetcodeAppsResponse) GoString() string {
	return s.String()
}

func (s *ListRetcodeAppsResponse) SetHeaders(v map[string]*string) *ListRetcodeAppsResponse {
	s.Headers = v
	return s
}

func (s *ListRetcodeAppsResponse) SetStatusCode(v int32) *ListRetcodeAppsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListRetcodeAppsResponse) SetBody(v *ListRetcodeAppsResponseBody) *ListRetcodeAppsResponse {
	s.Body = v
	return s
}

type ListScenarioRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the business monitoring job.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The scenario where the business monitoring job is used. Valid values:
	//
	// *   `USER-DEFINED`: user-defined. This is the default value.
	// *   `EDAS-ROLLOUT`: application release in Enterprise Distributed Application Service (EDAS)
	// *   `OAM-ROLLOUT`: application release based on Open Application Model (OAM)
	// *   `MSC-CANARY`: canary release based on Microservice Engine (MSE)
	Scenario *string `json:"Scenario,omitempty" xml:"Scenario,omitempty"`
	// The code of the business monitoring job. Set this parameter when you know the code of the business monitoring job you want to query.
	Sign *string `json:"Sign,omitempty" xml:"Sign,omitempty"`
}

func (s ListScenarioRequest) String() string {
	return tea.Prettify(s)
}

func (s ListScenarioRequest) GoString() string {
	return s.String()
}

func (s *ListScenarioRequest) SetAppId(v string) *ListScenarioRequest {
	s.AppId = &v
	return s
}

func (s *ListScenarioRequest) SetName(v string) *ListScenarioRequest {
	s.Name = &v
	return s
}

func (s *ListScenarioRequest) SetRegionId(v string) *ListScenarioRequest {
	s.RegionId = &v
	return s
}

func (s *ListScenarioRequest) SetScenario(v string) *ListScenarioRequest {
	s.Scenario = &v
	return s
}

func (s *ListScenarioRequest) SetSign(v string) *ListScenarioRequest {
	s.Sign = &v
	return s
}

type ListScenarioResponseBody struct {
	// The detailed information of the business monitoring job.
	ArmsScenarios []*ListScenarioResponseBodyArmsScenarios `json:"ArmsScenarios,omitempty" xml:"ArmsScenarios,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListScenarioResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListScenarioResponseBody) GoString() string {
	return s.String()
}

func (s *ListScenarioResponseBody) SetArmsScenarios(v []*ListScenarioResponseBodyArmsScenarios) *ListScenarioResponseBody {
	s.ArmsScenarios = v
	return s
}

func (s *ListScenarioResponseBody) SetRequestId(v string) *ListScenarioResponseBody {
	s.RequestId = &v
	return s
}

type ListScenarioResponseBodyArmsScenarios struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The time when the business monitoring job was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The extended information. The value is a JSON string.
	Extensions *string `json:"Extensions,omitempty" xml:"Extensions,omitempty"`
	// The ID of the business monitoring job.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the business monitoring job.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The code of the business monitoring job.
	Sign *string `json:"Sign,omitempty" xml:"Sign,omitempty"`
	// The time when the business monitoring job was updated.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s ListScenarioResponseBodyArmsScenarios) String() string {
	return tea.Prettify(s)
}

func (s ListScenarioResponseBodyArmsScenarios) GoString() string {
	return s.String()
}

func (s *ListScenarioResponseBodyArmsScenarios) SetAppId(v string) *ListScenarioResponseBodyArmsScenarios {
	s.AppId = &v
	return s
}

func (s *ListScenarioResponseBodyArmsScenarios) SetCreateTime(v string) *ListScenarioResponseBodyArmsScenarios {
	s.CreateTime = &v
	return s
}

func (s *ListScenarioResponseBodyArmsScenarios) SetExtensions(v string) *ListScenarioResponseBodyArmsScenarios {
	s.Extensions = &v
	return s
}

func (s *ListScenarioResponseBodyArmsScenarios) SetId(v int64) *ListScenarioResponseBodyArmsScenarios {
	s.Id = &v
	return s
}

func (s *ListScenarioResponseBodyArmsScenarios) SetName(v string) *ListScenarioResponseBodyArmsScenarios {
	s.Name = &v
	return s
}

func (s *ListScenarioResponseBodyArmsScenarios) SetRegionId(v string) *ListScenarioResponseBodyArmsScenarios {
	s.RegionId = &v
	return s
}

func (s *ListScenarioResponseBodyArmsScenarios) SetSign(v string) *ListScenarioResponseBodyArmsScenarios {
	s.Sign = &v
	return s
}

func (s *ListScenarioResponseBodyArmsScenarios) SetUpdateTime(v string) *ListScenarioResponseBodyArmsScenarios {
	s.UpdateTime = &v
	return s
}

func (s *ListScenarioResponseBodyArmsScenarios) SetUserId(v string) *ListScenarioResponseBodyArmsScenarios {
	s.UserId = &v
	return s
}

type ListScenarioResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListScenarioResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListScenarioResponse) String() string {
	return tea.Prettify(s)
}

func (s ListScenarioResponse) GoString() string {
	return s.String()
}

func (s *ListScenarioResponse) SetHeaders(v map[string]*string) *ListScenarioResponse {
	s.Headers = v
	return s
}

func (s *ListScenarioResponse) SetStatusCode(v int32) *ListScenarioResponse {
	s.StatusCode = &v
	return s
}

func (s *ListScenarioResponse) SetBody(v *ListScenarioResponseBody) *ListScenarioResponse {
	s.Body = v
	return s
}

type ListSilencePoliciesRequest struct {
	// The operation that you want to perform. Set the value to **ListSilencePolicies**.
	IsDetail *bool `json:"IsDetail,omitempty" xml:"IsDetail,omitempty"`
	// An array of matching condition objects.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The number of entries to return on each page.
	Page     *int64  `json:"Page,omitempty" xml:"Page,omitempty"`
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the silence policy.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
}

func (s ListSilencePoliciesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSilencePoliciesRequest) GoString() string {
	return s.String()
}

func (s *ListSilencePoliciesRequest) SetIsDetail(v bool) *ListSilencePoliciesRequest {
	s.IsDetail = &v
	return s
}

func (s *ListSilencePoliciesRequest) SetName(v string) *ListSilencePoliciesRequest {
	s.Name = &v
	return s
}

func (s *ListSilencePoliciesRequest) SetPage(v int64) *ListSilencePoliciesRequest {
	s.Page = &v
	return s
}

func (s *ListSilencePoliciesRequest) SetRegionId(v string) *ListSilencePoliciesRequest {
	s.RegionId = &v
	return s
}

func (s *ListSilencePoliciesRequest) SetSize(v int64) *ListSilencePoliciesRequest {
	s.Size = &v
	return s
}

type ListSilencePoliciesResponseBody struct {
	// The value of the matching condition.
	PageBean *ListSilencePoliciesResponseBodyPageBean `json:"PageBean,omitempty" xml:"PageBean,omitempty" type:"Struct"`
	// The logical operator of the matching condition. Valid values:
	//
	// *   `eq`: equal to.
	// *   `neq`: not equal to.
	// *   `in`: contains.
	// *   `nin`: does not contain.
	// *   `re`: regular expression match.
	// *   `nre`: regular expression mismatch.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListSilencePoliciesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSilencePoliciesResponseBody) GoString() string {
	return s.String()
}

func (s *ListSilencePoliciesResponseBody) SetPageBean(v *ListSilencePoliciesResponseBodyPageBean) *ListSilencePoliciesResponseBody {
	s.PageBean = v
	return s
}

func (s *ListSilencePoliciesResponseBody) SetRequestId(v string) *ListSilencePoliciesResponseBody {
	s.RequestId = &v
	return s
}

type ListSilencePoliciesResponseBodyPageBean struct {
	// The name of the silence policy.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of silence policies that were returned.
	SilencePolicies []*ListSilencePoliciesResponseBodyPageBeanSilencePolicies `json:"SilencePolicies,omitempty" xml:"SilencePolicies,omitempty" type:"Repeated"`
	// The number of entries that were returned on each page.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// An array of matching rule objects.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListSilencePoliciesResponseBodyPageBean) String() string {
	return tea.Prettify(s)
}

func (s ListSilencePoliciesResponseBodyPageBean) GoString() string {
	return s.String()
}

func (s *ListSilencePoliciesResponseBodyPageBean) SetPage(v int64) *ListSilencePoliciesResponseBodyPageBean {
	s.Page = &v
	return s
}

func (s *ListSilencePoliciesResponseBodyPageBean) SetSilencePolicies(v []*ListSilencePoliciesResponseBodyPageBeanSilencePolicies) *ListSilencePoliciesResponseBodyPageBean {
	s.SilencePolicies = v
	return s
}

func (s *ListSilencePoliciesResponseBodyPageBean) SetSize(v int64) *ListSilencePoliciesResponseBodyPageBean {
	s.Size = &v
	return s
}

func (s *ListSilencePoliciesResponseBodyPageBean) SetTotal(v int64) *ListSilencePoliciesResponseBodyPageBean {
	s.Total = &v
	return s
}

type ListSilencePoliciesResponseBodyPageBeanSilencePolicies struct {
	// The name of the silence policy.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// Specifies whether to query the details of a silence policy. Valid values:
	//
	// *   `true`: Details of the silence policy are queried.
	// *   `false`: Details of the silence policy are not queried.
	MatchingRules []*ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules `json:"MatchingRules,omitempty" xml:"MatchingRules,omitempty" type:"Repeated"`
	// An array of returned objects.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s ListSilencePoliciesResponseBodyPageBeanSilencePolicies) String() string {
	return tea.Prettify(s)
}

func (s ListSilencePoliciesResponseBodyPageBeanSilencePolicies) GoString() string {
	return s.String()
}

func (s *ListSilencePoliciesResponseBodyPageBeanSilencePolicies) SetId(v int64) *ListSilencePoliciesResponseBodyPageBeanSilencePolicies {
	s.Id = &v
	return s
}

func (s *ListSilencePoliciesResponseBodyPageBeanSilencePolicies) SetMatchingRules(v []*ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules) *ListSilencePoliciesResponseBodyPageBeanSilencePolicies {
	s.MatchingRules = v
	return s
}

func (s *ListSilencePoliciesResponseBodyPageBeanSilencePolicies) SetName(v string) *ListSilencePoliciesResponseBodyPageBeanSilencePolicies {
	s.Name = &v
	return s
}

type ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules struct {
	// The ID of the request.
	MatchingConditions []*ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions `json:"MatchingConditions,omitempty" xml:"MatchingConditions,omitempty" type:"Repeated"`
}

func (s ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules) String() string {
	return tea.Prettify(s)
}

func (s ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules) GoString() string {
	return s.String()
}

func (s *ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules) SetMatchingConditions(v []*ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions) *ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRules {
	s.MatchingConditions = v
	return s
}

type ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions struct {
	Key      *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Operator *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
	Value    *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions) String() string {
	return tea.Prettify(s)
}

func (s ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions) GoString() string {
	return s.String()
}

func (s *ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions) SetKey(v string) *ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions {
	s.Key = &v
	return s
}

func (s *ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions) SetOperator(v string) *ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions {
	s.Operator = &v
	return s
}

func (s *ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions) SetValue(v string) *ListSilencePoliciesResponseBodyPageBeanSilencePoliciesMatchingRulesMatchingConditions {
	s.Value = &v
	return s
}

type ListSilencePoliciesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListSilencePoliciesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListSilencePoliciesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSilencePoliciesResponse) GoString() string {
	return s.String()
}

func (s *ListSilencePoliciesResponse) SetHeaders(v map[string]*string) *ListSilencePoliciesResponse {
	s.Headers = v
	return s
}

func (s *ListSilencePoliciesResponse) SetStatusCode(v int32) *ListSilencePoliciesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSilencePoliciesResponse) SetBody(v *ListSilencePoliciesResponseBody) *ListSilencePoliciesResponse {
	s.Body = v
	return s
}

type ListTimingSyntheticTasksRequest struct {
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The search keyword.
	Search *ListTimingSyntheticTasksRequestSearch `json:"Search,omitempty" xml:"Search,omitempty" type:"Struct"`
	// The tags.
	Tags []*ListTimingSyntheticTasksRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s ListTimingSyntheticTasksRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTimingSyntheticTasksRequest) GoString() string {
	return s.String()
}

func (s *ListTimingSyntheticTasksRequest) SetRegionId(v string) *ListTimingSyntheticTasksRequest {
	s.RegionId = &v
	return s
}

func (s *ListTimingSyntheticTasksRequest) SetResourceGroupId(v string) *ListTimingSyntheticTasksRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListTimingSyntheticTasksRequest) SetSearch(v *ListTimingSyntheticTasksRequestSearch) *ListTimingSyntheticTasksRequest {
	s.Search = v
	return s
}

func (s *ListTimingSyntheticTasksRequest) SetTags(v []*ListTimingSyntheticTasksRequestTags) *ListTimingSyntheticTasksRequest {
	s.Tags = v
	return s
}

type ListTimingSyntheticTasksRequestSearch struct {
	// The task name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The order by which tasks are sorted. 1: ascending order. -1: descending order.
	Order *int32 `json:"Order,omitempty" xml:"Order,omitempty"`
	// The condition by which tasks are sorted. You can sort tasks by gmtCreate, gmtModified, status, or monitorCount.
	OrderField *string `json:"OrderField,omitempty" xml:"OrderField,omitempty"`
	// The page number. This parameter is required.
	Page *int32 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of entries per page. This parameter is required.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The task status. CREATING: The task is being created. RUNNING: The task is running. PARTIAL_RUNNING: The task is partially running. STOP: The task is stopped. LIMIT_STOP: The task is stopped due to quota limit. EXCEPTION: The task is abnormal. DELETE: The task is deleted. DELETE_EXCEPTION: An exception occurs while deleting the task.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The task IDs.
	TaskIds []*string `json:"TaskIds,omitempty" xml:"TaskIds,omitempty" type:"Repeated"`
	// The task types.
	TaskTypes []*int32 `json:"TaskTypes,omitempty" xml:"TaskTypes,omitempty" type:"Repeated"`
}

func (s ListTimingSyntheticTasksRequestSearch) String() string {
	return tea.Prettify(s)
}

func (s ListTimingSyntheticTasksRequestSearch) GoString() string {
	return s.String()
}

func (s *ListTimingSyntheticTasksRequestSearch) SetName(v string) *ListTimingSyntheticTasksRequestSearch {
	s.Name = &v
	return s
}

func (s *ListTimingSyntheticTasksRequestSearch) SetOrder(v int32) *ListTimingSyntheticTasksRequestSearch {
	s.Order = &v
	return s
}

func (s *ListTimingSyntheticTasksRequestSearch) SetOrderField(v string) *ListTimingSyntheticTasksRequestSearch {
	s.OrderField = &v
	return s
}

func (s *ListTimingSyntheticTasksRequestSearch) SetPage(v int32) *ListTimingSyntheticTasksRequestSearch {
	s.Page = &v
	return s
}

func (s *ListTimingSyntheticTasksRequestSearch) SetPageSize(v int32) *ListTimingSyntheticTasksRequestSearch {
	s.PageSize = &v
	return s
}

func (s *ListTimingSyntheticTasksRequestSearch) SetStatus(v string) *ListTimingSyntheticTasksRequestSearch {
	s.Status = &v
	return s
}

func (s *ListTimingSyntheticTasksRequestSearch) SetTaskIds(v []*string) *ListTimingSyntheticTasksRequestSearch {
	s.TaskIds = v
	return s
}

func (s *ListTimingSyntheticTasksRequestSearch) SetTaskTypes(v []*int32) *ListTimingSyntheticTasksRequestSearch {
	s.TaskTypes = v
	return s
}

type ListTimingSyntheticTasksRequestTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTimingSyntheticTasksRequestTags) String() string {
	return tea.Prettify(s)
}

func (s ListTimingSyntheticTasksRequestTags) GoString() string {
	return s.String()
}

func (s *ListTimingSyntheticTasksRequestTags) SetKey(v string) *ListTimingSyntheticTasksRequestTags {
	s.Key = &v
	return s
}

func (s *ListTimingSyntheticTasksRequestTags) SetValue(v string) *ListTimingSyntheticTasksRequestTags {
	s.Value = &v
	return s
}

type ListTimingSyntheticTasksShrinkRequest struct {
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The search keyword.
	SearchShrink *string `json:"Search,omitempty" xml:"Search,omitempty"`
	// The tags.
	TagsShrink *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s ListTimingSyntheticTasksShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTimingSyntheticTasksShrinkRequest) GoString() string {
	return s.String()
}

func (s *ListTimingSyntheticTasksShrinkRequest) SetRegionId(v string) *ListTimingSyntheticTasksShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *ListTimingSyntheticTasksShrinkRequest) SetResourceGroupId(v string) *ListTimingSyntheticTasksShrinkRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListTimingSyntheticTasksShrinkRequest) SetSearchShrink(v string) *ListTimingSyntheticTasksShrinkRequest {
	s.SearchShrink = &v
	return s
}

func (s *ListTimingSyntheticTasksShrinkRequest) SetTagsShrink(v string) *ListTimingSyntheticTasksShrinkRequest {
	s.TagsShrink = &v
	return s
}

type ListTimingSyntheticTasksResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful.
	Code *int64 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned struct.
	Data *ListTimingSyntheticTasksResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListTimingSyntheticTasksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTimingSyntheticTasksResponseBody) GoString() string {
	return s.String()
}

func (s *ListTimingSyntheticTasksResponseBody) SetCode(v int64) *ListTimingSyntheticTasksResponseBody {
	s.Code = &v
	return s
}

func (s *ListTimingSyntheticTasksResponseBody) SetData(v *ListTimingSyntheticTasksResponseBodyData) *ListTimingSyntheticTasksResponseBody {
	s.Data = v
	return s
}

func (s *ListTimingSyntheticTasksResponseBody) SetMessage(v string) *ListTimingSyntheticTasksResponseBody {
	s.Message = &v
	return s
}

func (s *ListTimingSyntheticTasksResponseBody) SetRequestId(v string) *ListTimingSyntheticTasksResponseBody {
	s.RequestId = &v
	return s
}

type ListTimingSyntheticTasksResponseBodyData struct {
	// The queried tasks.
	Items []*ListTimingSyntheticTasksResponseBodyDataItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
	// The page number.
	Page *int32 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of tasks.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListTimingSyntheticTasksResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListTimingSyntheticTasksResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListTimingSyntheticTasksResponseBodyData) SetItems(v []*ListTimingSyntheticTasksResponseBodyDataItems) *ListTimingSyntheticTasksResponseBodyData {
	s.Items = v
	return s
}

func (s *ListTimingSyntheticTasksResponseBodyData) SetPage(v int32) *ListTimingSyntheticTasksResponseBodyData {
	s.Page = &v
	return s
}

func (s *ListTimingSyntheticTasksResponseBodyData) SetPageSize(v int32) *ListTimingSyntheticTasksResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListTimingSyntheticTasksResponseBodyData) SetTotal(v int32) *ListTimingSyntheticTasksResponseBodyData {
	s.Total = &v
	return s
}

type ListTimingSyntheticTasksResponseBodyDataItems struct {
	// The detection frequency. Valid values: 1m, 5m, 10m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, and 24h.
	Frequency *string `json:"Frequency,omitempty" xml:"Frequency,omitempty"`
	// The time when the task was created.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the task was modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The detection point type. 1: PC. 2: mobile device.
	MonitorCategory *int32 `json:"MonitorCategory,omitempty" xml:"MonitorCategory,omitempty"`
	// The number of detection points.
	MonitorNum *string `json:"MonitorNum,omitempty" xml:"MonitorNum,omitempty"`
	// The task name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The task status. CREATING: The task is being created. RUNNING: The task is running. PARTIAL_RUNNING: The task is partially running. STOP: The task is stopped. LIMIT_STOP: The task is stopped due to quota limit. EXCEPTION: The task is abnormal. DELETE: The task is deleted. DELETE_EXCEPTION: An exception occurs while deleting the task.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tags.
	Tags []*ListTimingSyntheticTasksResponseBodyDataItemsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The ID of the synthetic monitoring task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The type of the task. Valid values:
	//
	// 1: ICMP. 2: TCP. 3: DNS. 4: HTTP. 5: website speed. 6: file download.
	TaskType *int32 `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
	// The URL for synthetic monitoring.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s ListTimingSyntheticTasksResponseBodyDataItems) String() string {
	return tea.Prettify(s)
}

func (s ListTimingSyntheticTasksResponseBodyDataItems) GoString() string {
	return s.String()
}

func (s *ListTimingSyntheticTasksResponseBodyDataItems) SetFrequency(v string) *ListTimingSyntheticTasksResponseBodyDataItems {
	s.Frequency = &v
	return s
}

func (s *ListTimingSyntheticTasksResponseBodyDataItems) SetGmtCreate(v string) *ListTimingSyntheticTasksResponseBodyDataItems {
	s.GmtCreate = &v
	return s
}

func (s *ListTimingSyntheticTasksResponseBodyDataItems) SetGmtModified(v string) *ListTimingSyntheticTasksResponseBodyDataItems {
	s.GmtModified = &v
	return s
}

func (s *ListTimingSyntheticTasksResponseBodyDataItems) SetMonitorCategory(v int32) *ListTimingSyntheticTasksResponseBodyDataItems {
	s.MonitorCategory = &v
	return s
}

func (s *ListTimingSyntheticTasksResponseBodyDataItems) SetMonitorNum(v string) *ListTimingSyntheticTasksResponseBodyDataItems {
	s.MonitorNum = &v
	return s
}

func (s *ListTimingSyntheticTasksResponseBodyDataItems) SetName(v string) *ListTimingSyntheticTasksResponseBodyDataItems {
	s.Name = &v
	return s
}

func (s *ListTimingSyntheticTasksResponseBodyDataItems) SetRegionId(v string) *ListTimingSyntheticTasksResponseBodyDataItems {
	s.RegionId = &v
	return s
}

func (s *ListTimingSyntheticTasksResponseBodyDataItems) SetResourceGroupId(v string) *ListTimingSyntheticTasksResponseBodyDataItems {
	s.ResourceGroupId = &v
	return s
}

func (s *ListTimingSyntheticTasksResponseBodyDataItems) SetStatus(v string) *ListTimingSyntheticTasksResponseBodyDataItems {
	s.Status = &v
	return s
}

func (s *ListTimingSyntheticTasksResponseBodyDataItems) SetTags(v []*ListTimingSyntheticTasksResponseBodyDataItemsTags) *ListTimingSyntheticTasksResponseBodyDataItems {
	s.Tags = v
	return s
}

func (s *ListTimingSyntheticTasksResponseBodyDataItems) SetTaskId(v string) *ListTimingSyntheticTasksResponseBodyDataItems {
	s.TaskId = &v
	return s
}

func (s *ListTimingSyntheticTasksResponseBodyDataItems) SetTaskType(v int32) *ListTimingSyntheticTasksResponseBodyDataItems {
	s.TaskType = &v
	return s
}

func (s *ListTimingSyntheticTasksResponseBodyDataItems) SetUrl(v string) *ListTimingSyntheticTasksResponseBodyDataItems {
	s.Url = &v
	return s
}

type ListTimingSyntheticTasksResponseBodyDataItemsTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTimingSyntheticTasksResponseBodyDataItemsTags) String() string {
	return tea.Prettify(s)
}

func (s ListTimingSyntheticTasksResponseBodyDataItemsTags) GoString() string {
	return s.String()
}

func (s *ListTimingSyntheticTasksResponseBodyDataItemsTags) SetKey(v string) *ListTimingSyntheticTasksResponseBodyDataItemsTags {
	s.Key = &v
	return s
}

func (s *ListTimingSyntheticTasksResponseBodyDataItemsTags) SetValue(v string) *ListTimingSyntheticTasksResponseBodyDataItemsTags {
	s.Value = &v
	return s
}

type ListTimingSyntheticTasksResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTimingSyntheticTasksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTimingSyntheticTasksResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTimingSyntheticTasksResponse) GoString() string {
	return s.String()
}

func (s *ListTimingSyntheticTasksResponse) SetHeaders(v map[string]*string) *ListTimingSyntheticTasksResponse {
	s.Headers = v
	return s
}

func (s *ListTimingSyntheticTasksResponse) SetStatusCode(v int32) *ListTimingSyntheticTasksResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTimingSyntheticTasksResponse) SetBody(v *ListTimingSyntheticTasksResponseBody) *ListTimingSyntheticTasksResponse {
	s.Body = v
	return s
}

type ListTraceAppsRequest struct {
	// The type of the application that is associated with the alert rule. Valid values:
	//
	// *   `TRACE`: Application Monitoring
	// *   `EBPF`: Application Monitoring eBPF Edition
	AppType *string `json:"AppType,omitempty" xml:"AppType,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource group ID.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The tags.
	Tags []*ListTraceAppsRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s ListTraceAppsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTraceAppsRequest) GoString() string {
	return s.String()
}

func (s *ListTraceAppsRequest) SetAppType(v string) *ListTraceAppsRequest {
	s.AppType = &v
	return s
}

func (s *ListTraceAppsRequest) SetRegion(v string) *ListTraceAppsRequest {
	s.Region = &v
	return s
}

func (s *ListTraceAppsRequest) SetRegionId(v string) *ListTraceAppsRequest {
	s.RegionId = &v
	return s
}

func (s *ListTraceAppsRequest) SetResourceGroupId(v string) *ListTraceAppsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListTraceAppsRequest) SetTags(v []*ListTraceAppsRequestTags) *ListTraceAppsRequest {
	s.Tags = v
	return s
}

type ListTraceAppsRequestTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTraceAppsRequestTags) String() string {
	return tea.Prettify(s)
}

func (s ListTraceAppsRequestTags) GoString() string {
	return s.String()
}

func (s *ListTraceAppsRequestTags) SetKey(v string) *ListTraceAppsRequestTags {
	s.Key = &v
	return s
}

func (s *ListTraceAppsRequestTags) SetValue(v string) *ListTraceAppsRequestTags {
	s.Value = &v
	return s
}

type ListTraceAppsResponseBody struct {
	// The HTTP status code returned for the request. Valid values:
	//
	// *   `2XX`: The request is successful.
	// *   `3XX`: A redirection message is returned.
	// *   `4XX`: The request is invalid.
	// *   `5XX`: A server error occurs.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the request parameters are invalid.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   `true`: The call was successful.
	// *   `false`: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The queried application monitoring tasks.
	TraceApps []*ListTraceAppsResponseBodyTraceApps `json:"TraceApps,omitempty" xml:"TraceApps,omitempty" type:"Repeated"`
}

func (s ListTraceAppsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTraceAppsResponseBody) GoString() string {
	return s.String()
}

func (s *ListTraceAppsResponseBody) SetCode(v int32) *ListTraceAppsResponseBody {
	s.Code = &v
	return s
}

func (s *ListTraceAppsResponseBody) SetMessage(v string) *ListTraceAppsResponseBody {
	s.Message = &v
	return s
}

func (s *ListTraceAppsResponseBody) SetRequestId(v string) *ListTraceAppsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTraceAppsResponseBody) SetSuccess(v bool) *ListTraceAppsResponseBody {
	s.Success = &v
	return s
}

func (s *ListTraceAppsResponseBody) SetTraceApps(v []*ListTraceAppsResponseBodyTraceApps) *ListTraceAppsResponseBody {
	s.TraceApps = v
	return s
}

type ListTraceAppsResponseBodyTraceApps struct {
	// The application ID.
	AppId *int64 `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The cluster ID.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The time when the monitoring task was created. The value is a timestamp. Unit: milliseconds.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The tags of the application.
	Labels []*string `json:"Labels,omitempty" xml:"Labels,omitempty" type:"Repeated"`
	// The language.
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The process identifier (PID) of the application.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource group ID.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Indicates whether the application is displayed in the Application Real-Time Monitoring Service (ARMS) console. Valid values:
	//
	// *   `true`: yes
	// *   `false`: no
	Show *bool `json:"Show,omitempty" xml:"Show,omitempty"`
	// The source of the application.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The tags.
	Tags []*ListTraceAppsResponseBodyTraceAppsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The type of the monitoring task. Valid values:
	//
	// *   `TRACE`: Application Monitoring
	// *   `RETCODE`: Browser Monitoring
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The time when the monitoring task was updated. The value is a timestamp. Unit: milliseconds.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The user ID.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The type of the workload.
	WorkloadKind *string `json:"WorkloadKind,omitempty" xml:"WorkloadKind,omitempty"`
	// The name of the workload.
	WorkloadName *string `json:"WorkloadName,omitempty" xml:"WorkloadName,omitempty"`
}

func (s ListTraceAppsResponseBodyTraceApps) String() string {
	return tea.Prettify(s)
}

func (s ListTraceAppsResponseBodyTraceApps) GoString() string {
	return s.String()
}

func (s *ListTraceAppsResponseBodyTraceApps) SetAppId(v int64) *ListTraceAppsResponseBodyTraceApps {
	s.AppId = &v
	return s
}

func (s *ListTraceAppsResponseBodyTraceApps) SetAppName(v string) *ListTraceAppsResponseBodyTraceApps {
	s.AppName = &v
	return s
}

func (s *ListTraceAppsResponseBodyTraceApps) SetClusterId(v string) *ListTraceAppsResponseBodyTraceApps {
	s.ClusterId = &v
	return s
}

func (s *ListTraceAppsResponseBodyTraceApps) SetCreateTime(v int64) *ListTraceAppsResponseBodyTraceApps {
	s.CreateTime = &v
	return s
}

func (s *ListTraceAppsResponseBodyTraceApps) SetLabels(v []*string) *ListTraceAppsResponseBodyTraceApps {
	s.Labels = v
	return s
}

func (s *ListTraceAppsResponseBodyTraceApps) SetLanguage(v string) *ListTraceAppsResponseBodyTraceApps {
	s.Language = &v
	return s
}

func (s *ListTraceAppsResponseBodyTraceApps) SetNamespace(v string) *ListTraceAppsResponseBodyTraceApps {
	s.Namespace = &v
	return s
}

func (s *ListTraceAppsResponseBodyTraceApps) SetPid(v string) *ListTraceAppsResponseBodyTraceApps {
	s.Pid = &v
	return s
}

func (s *ListTraceAppsResponseBodyTraceApps) SetRegionId(v string) *ListTraceAppsResponseBodyTraceApps {
	s.RegionId = &v
	return s
}

func (s *ListTraceAppsResponseBodyTraceApps) SetResourceGroupId(v string) *ListTraceAppsResponseBodyTraceApps {
	s.ResourceGroupId = &v
	return s
}

func (s *ListTraceAppsResponseBodyTraceApps) SetShow(v bool) *ListTraceAppsResponseBodyTraceApps {
	s.Show = &v
	return s
}

func (s *ListTraceAppsResponseBodyTraceApps) SetSource(v string) *ListTraceAppsResponseBodyTraceApps {
	s.Source = &v
	return s
}

func (s *ListTraceAppsResponseBodyTraceApps) SetTags(v []*ListTraceAppsResponseBodyTraceAppsTags) *ListTraceAppsResponseBodyTraceApps {
	s.Tags = v
	return s
}

func (s *ListTraceAppsResponseBodyTraceApps) SetType(v string) *ListTraceAppsResponseBodyTraceApps {
	s.Type = &v
	return s
}

func (s *ListTraceAppsResponseBodyTraceApps) SetUpdateTime(v int64) *ListTraceAppsResponseBodyTraceApps {
	s.UpdateTime = &v
	return s
}

func (s *ListTraceAppsResponseBodyTraceApps) SetUserId(v string) *ListTraceAppsResponseBodyTraceApps {
	s.UserId = &v
	return s
}

func (s *ListTraceAppsResponseBodyTraceApps) SetWorkloadKind(v string) *ListTraceAppsResponseBodyTraceApps {
	s.WorkloadKind = &v
	return s
}

func (s *ListTraceAppsResponseBodyTraceApps) SetWorkloadName(v string) *ListTraceAppsResponseBodyTraceApps {
	s.WorkloadName = &v
	return s
}

type ListTraceAppsResponseBodyTraceAppsTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTraceAppsResponseBodyTraceAppsTags) String() string {
	return tea.Prettify(s)
}

func (s ListTraceAppsResponseBodyTraceAppsTags) GoString() string {
	return s.String()
}

func (s *ListTraceAppsResponseBodyTraceAppsTags) SetKey(v string) *ListTraceAppsResponseBodyTraceAppsTags {
	s.Key = &v
	return s
}

func (s *ListTraceAppsResponseBodyTraceAppsTags) SetValue(v string) *ListTraceAppsResponseBodyTraceAppsTags {
	s.Value = &v
	return s
}

type ListTraceAppsResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTraceAppsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTraceAppsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTraceAppsResponse) GoString() string {
	return s.String()
}

func (s *ListTraceAppsResponse) SetHeaders(v map[string]*string) *ListTraceAppsResponse {
	s.Headers = v
	return s
}

func (s *ListTraceAppsResponse) SetStatusCode(v int32) *ListTraceAppsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTraceAppsResponse) SetBody(v *ListTraceAppsResponseBody) *ListTraceAppsResponse {
	s.Body = v
	return s
}

type ManageGetRecordingRuleRequest struct {
	// The cluster ID.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The user ID.
	QueryUserId *string `json:"QueryUserId,omitempty" xml:"QueryUserId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ManageGetRecordingRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s ManageGetRecordingRuleRequest) GoString() string {
	return s.String()
}

func (s *ManageGetRecordingRuleRequest) SetClusterId(v string) *ManageGetRecordingRuleRequest {
	s.ClusterId = &v
	return s
}

func (s *ManageGetRecordingRuleRequest) SetQueryUserId(v string) *ManageGetRecordingRuleRequest {
	s.QueryUserId = &v
	return s
}

func (s *ManageGetRecordingRuleRequest) SetRegionId(v string) *ManageGetRecordingRuleRequest {
	s.RegionId = &v
	return s
}

type ManageGetRecordingRuleResponseBody struct {
	// The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned message.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ManageGetRecordingRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ManageGetRecordingRuleResponseBody) GoString() string {
	return s.String()
}

func (s *ManageGetRecordingRuleResponseBody) SetCode(v int32) *ManageGetRecordingRuleResponseBody {
	s.Code = &v
	return s
}

func (s *ManageGetRecordingRuleResponseBody) SetData(v string) *ManageGetRecordingRuleResponseBody {
	s.Data = &v
	return s
}

func (s *ManageGetRecordingRuleResponseBody) SetMessage(v string) *ManageGetRecordingRuleResponseBody {
	s.Message = &v
	return s
}

func (s *ManageGetRecordingRuleResponseBody) SetRequestId(v string) *ManageGetRecordingRuleResponseBody {
	s.RequestId = &v
	return s
}

type ManageGetRecordingRuleResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ManageGetRecordingRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ManageGetRecordingRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s ManageGetRecordingRuleResponse) GoString() string {
	return s.String()
}

func (s *ManageGetRecordingRuleResponse) SetHeaders(v map[string]*string) *ManageGetRecordingRuleResponse {
	s.Headers = v
	return s
}

func (s *ManageGetRecordingRuleResponse) SetStatusCode(v int32) *ManageGetRecordingRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *ManageGetRecordingRuleResponse) SetBody(v *ManageGetRecordingRuleResponseBody) *ManageGetRecordingRuleResponse {
	s.Body = v
	return s
}

type ManageRecordingRuleRequest struct {
	// The cluster ID.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The user ID.
	QueryUserId *string `json:"QueryUserId,omitempty" xml:"QueryUserId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The recording rule.
	RuleYaml *string `json:"RuleYaml,omitempty" xml:"RuleYaml,omitempty"`
}

func (s ManageRecordingRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s ManageRecordingRuleRequest) GoString() string {
	return s.String()
}

func (s *ManageRecordingRuleRequest) SetClusterId(v string) *ManageRecordingRuleRequest {
	s.ClusterId = &v
	return s
}

func (s *ManageRecordingRuleRequest) SetQueryUserId(v string) *ManageRecordingRuleRequest {
	s.QueryUserId = &v
	return s
}

func (s *ManageRecordingRuleRequest) SetRegionId(v string) *ManageRecordingRuleRequest {
	s.RegionId = &v
	return s
}

func (s *ManageRecordingRuleRequest) SetRuleYaml(v string) *ManageRecordingRuleRequest {
	s.RuleYaml = &v
	return s
}

type ManageRecordingRuleResponseBody struct {
	// The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result of the operation.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ManageRecordingRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ManageRecordingRuleResponseBody) GoString() string {
	return s.String()
}

func (s *ManageRecordingRuleResponseBody) SetCode(v int32) *ManageRecordingRuleResponseBody {
	s.Code = &v
	return s
}

func (s *ManageRecordingRuleResponseBody) SetData(v string) *ManageRecordingRuleResponseBody {
	s.Data = &v
	return s
}

func (s *ManageRecordingRuleResponseBody) SetMessage(v string) *ManageRecordingRuleResponseBody {
	s.Message = &v
	return s
}

func (s *ManageRecordingRuleResponseBody) SetRequestId(v string) *ManageRecordingRuleResponseBody {
	s.RequestId = &v
	return s
}

type ManageRecordingRuleResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ManageRecordingRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ManageRecordingRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s ManageRecordingRuleResponse) GoString() string {
	return s.String()
}

func (s *ManageRecordingRuleResponse) SetHeaders(v map[string]*string) *ManageRecordingRuleResponse {
	s.Headers = v
	return s
}

func (s *ManageRecordingRuleResponse) SetStatusCode(v int32) *ManageRecordingRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *ManageRecordingRuleResponse) SetBody(v *ManageRecordingRuleResponseBody) *ManageRecordingRuleResponse {
	s.Body = v
	return s
}

type OpenArmsDefaultSLRRequest struct {
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s OpenArmsDefaultSLRRequest) String() string {
	return tea.Prettify(s)
}

func (s OpenArmsDefaultSLRRequest) GoString() string {
	return s.String()
}

func (s *OpenArmsDefaultSLRRequest) SetRegionId(v string) *OpenArmsDefaultSLRRequest {
	s.RegionId = &v
	return s
}

type OpenArmsDefaultSLRResponseBody struct {
	// The returned result.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s OpenArmsDefaultSLRResponseBody) String() string {
	return tea.Prettify(s)
}

func (s OpenArmsDefaultSLRResponseBody) GoString() string {
	return s.String()
}

func (s *OpenArmsDefaultSLRResponseBody) SetData(v string) *OpenArmsDefaultSLRResponseBody {
	s.Data = &v
	return s
}

func (s *OpenArmsDefaultSLRResponseBody) SetRequestId(v string) *OpenArmsDefaultSLRResponseBody {
	s.RequestId = &v
	return s
}

type OpenArmsDefaultSLRResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *OpenArmsDefaultSLRResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s OpenArmsDefaultSLRResponse) String() string {
	return tea.Prettify(s)
}

func (s OpenArmsDefaultSLRResponse) GoString() string {
	return s.String()
}

func (s *OpenArmsDefaultSLRResponse) SetHeaders(v map[string]*string) *OpenArmsDefaultSLRResponse {
	s.Headers = v
	return s
}

func (s *OpenArmsDefaultSLRResponse) SetStatusCode(v int32) *OpenArmsDefaultSLRResponse {
	s.StatusCode = &v
	return s
}

func (s *OpenArmsDefaultSLRResponse) SetBody(v *OpenArmsDefaultSLRResponseBody) *OpenArmsDefaultSLRResponse {
	s.Body = v
	return s
}

type OpenArmsServiceSecondVersionRequest struct {
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The type of the service. Valid values:
	//
	// *   `arms`: ARMS
	// *   `arms_app`: Application Monitoring
	// *   `arms_web`: Browser Monitoring
	// *   `prometheus_monitor`: Managed Service for Prometheus
	// *   `synthetic_post`: Synthetic Monitoring
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s OpenArmsServiceSecondVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s OpenArmsServiceSecondVersionRequest) GoString() string {
	return s.String()
}

func (s *OpenArmsServiceSecondVersionRequest) SetRegionId(v string) *OpenArmsServiceSecondVersionRequest {
	s.RegionId = &v
	return s
}

func (s *OpenArmsServiceSecondVersionRequest) SetType(v string) *OpenArmsServiceSecondVersionRequest {
	s.Type = &v
	return s
}

type OpenArmsServiceSecondVersionResponseBody struct {
	// The service ID that is returned if the service is activated.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s OpenArmsServiceSecondVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s OpenArmsServiceSecondVersionResponseBody) GoString() string {
	return s.String()
}

func (s *OpenArmsServiceSecondVersionResponseBody) SetOrderId(v string) *OpenArmsServiceSecondVersionResponseBody {
	s.OrderId = &v
	return s
}

func (s *OpenArmsServiceSecondVersionResponseBody) SetRequestId(v string) *OpenArmsServiceSecondVersionResponseBody {
	s.RequestId = &v
	return s
}

type OpenArmsServiceSecondVersionResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *OpenArmsServiceSecondVersionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s OpenArmsServiceSecondVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s OpenArmsServiceSecondVersionResponse) GoString() string {
	return s.String()
}

func (s *OpenArmsServiceSecondVersionResponse) SetHeaders(v map[string]*string) *OpenArmsServiceSecondVersionResponse {
	s.Headers = v
	return s
}

func (s *OpenArmsServiceSecondVersionResponse) SetStatusCode(v int32) *OpenArmsServiceSecondVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *OpenArmsServiceSecondVersionResponse) SetBody(v *OpenArmsServiceSecondVersionResponseBody) *OpenArmsServiceSecondVersionResponse {
	s.Body = v
	return s
}

type OpenVClusterRequest struct {
	// The type of the cluster. For cloud services, set this parameter to `cloud-product-prometheus`.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The length of the cluster ID. Default value: 10.
	Length *int32 `json:"Length,omitempty" xml:"Length,omitempty"`
	// The name of the cloud service. This parameter is required if you set ClusterType to `cloud-product-prometheus`. Valid values: influxdb, mongodb, and DLA. You cannot specify multiple service names.
	Product *string `json:"Product,omitempty" xml:"Product,omitempty"`
	// Specifies whether to create or query a virtual cluster. This parameter provides backward compatibility.
	RecreateSwitch *bool `json:"RecreateSwitch,omitempty" xml:"RecreateSwitch,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s OpenVClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s OpenVClusterRequest) GoString() string {
	return s.String()
}

func (s *OpenVClusterRequest) SetClusterType(v string) *OpenVClusterRequest {
	s.ClusterType = &v
	return s
}

func (s *OpenVClusterRequest) SetLength(v int32) *OpenVClusterRequest {
	s.Length = &v
	return s
}

func (s *OpenVClusterRequest) SetProduct(v string) *OpenVClusterRequest {
	s.Product = &v
	return s
}

func (s *OpenVClusterRequest) SetRecreateSwitch(v bool) *OpenVClusterRequest {
	s.RecreateSwitch = &v
	return s
}

func (s *OpenVClusterRequest) SetRegionId(v string) *OpenVClusterRequest {
	s.RegionId = &v
	return s
}

type OpenVClusterResponseBody struct {
	// The cluster ID. The value is a string.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The request ID. You can use the ID to find logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s OpenVClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s OpenVClusterResponseBody) GoString() string {
	return s.String()
}

func (s *OpenVClusterResponseBody) SetData(v string) *OpenVClusterResponseBody {
	s.Data = &v
	return s
}

func (s *OpenVClusterResponseBody) SetRequestId(v string) *OpenVClusterResponseBody {
	s.RequestId = &v
	return s
}

type OpenVClusterResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *OpenVClusterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s OpenVClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s OpenVClusterResponse) GoString() string {
	return s.String()
}

func (s *OpenVClusterResponse) SetHeaders(v map[string]*string) *OpenVClusterResponse {
	s.Headers = v
	return s
}

func (s *OpenVClusterResponse) SetStatusCode(v int32) *OpenVClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *OpenVClusterResponse) SetBody(v *OpenVClusterResponseBody) *OpenVClusterResponse {
	s.Body = v
	return s
}

type OpenXtraceDefaultSLRRequest struct {
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`: The request was successful.
	// *   `false`: The request failed.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s OpenXtraceDefaultSLRRequest) String() string {
	return tea.Prettify(s)
}

func (s OpenXtraceDefaultSLRRequest) GoString() string {
	return s.String()
}

func (s *OpenXtraceDefaultSLRRequest) SetRegionId(v string) *OpenXtraceDefaultSLRRequest {
	s.RegionId = &v
	return s
}

type OpenXtraceDefaultSLRResponseBody struct {
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`
	// *   `false`
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s OpenXtraceDefaultSLRResponseBody) String() string {
	return tea.Prettify(s)
}

func (s OpenXtraceDefaultSLRResponseBody) GoString() string {
	return s.String()
}

func (s *OpenXtraceDefaultSLRResponseBody) SetData(v string) *OpenXtraceDefaultSLRResponseBody {
	s.Data = &v
	return s
}

func (s *OpenXtraceDefaultSLRResponseBody) SetRequestId(v string) *OpenXtraceDefaultSLRResponseBody {
	s.RequestId = &v
	return s
}

type OpenXtraceDefaultSLRResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *OpenXtraceDefaultSLRResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s OpenXtraceDefaultSLRResponse) String() string {
	return tea.Prettify(s)
}

func (s OpenXtraceDefaultSLRResponse) GoString() string {
	return s.String()
}

func (s *OpenXtraceDefaultSLRResponse) SetHeaders(v map[string]*string) *OpenXtraceDefaultSLRResponse {
	s.Headers = v
	return s
}

func (s *OpenXtraceDefaultSLRResponse) SetStatusCode(v int32) *OpenXtraceDefaultSLRResponse {
	s.StatusCode = &v
	return s
}

func (s *OpenXtraceDefaultSLRResponse) SetBody(v *OpenXtraceDefaultSLRResponseBody) *OpenXtraceDefaultSLRResponse {
	s.Body = v
	return s
}

type QueryAppMetadataRequest struct {
	// The array of meta Ids.
	MetaIds *string `json:"MetaIds,omitempty" xml:"MetaIds,omitempty"`
	// The mata type.
	MetaType *string `json:"MetaType,omitempty" xml:"MetaType,omitempty"`
	// The ID of the application.
	//
	// Log on to the **ARMS console**. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of an application. The URL in the address bar contains the process ID (PID) of the application. The PID is indicated in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is eb4zdose6v%409781be0f44d\*\*\*\*, you must replace %40 with an at sign (@) to obtain eb4zdose6v@9781be0f44d\*\*\*\*.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s QueryAppMetadataRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryAppMetadataRequest) GoString() string {
	return s.String()
}

func (s *QueryAppMetadataRequest) SetMetaIds(v string) *QueryAppMetadataRequest {
	s.MetaIds = &v
	return s
}

func (s *QueryAppMetadataRequest) SetMetaType(v string) *QueryAppMetadataRequest {
	s.MetaType = &v
	return s
}

func (s *QueryAppMetadataRequest) SetPid(v string) *QueryAppMetadataRequest {
	s.Pid = &v
	return s
}

func (s *QueryAppMetadataRequest) SetRegionId(v string) *QueryAppMetadataRequest {
	s.RegionId = &v
	return s
}

type QueryAppMetadataResponseBody struct {
	// The HTTP status code returned for the request. Valid values:
	//
	// *   2XX: The request is successful.
	// *   3XX: A redirection message is returned.
	// *   4XX: The request is invalid.
	// *   5XX: A server error occurs.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned struct.
	Data map[string]interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   `true`: The call was successful.
	// *   `false`: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryAppMetadataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryAppMetadataResponseBody) GoString() string {
	return s.String()
}

func (s *QueryAppMetadataResponseBody) SetCode(v int32) *QueryAppMetadataResponseBody {
	s.Code = &v
	return s
}

func (s *QueryAppMetadataResponseBody) SetData(v map[string]interface{}) *QueryAppMetadataResponseBody {
	s.Data = v
	return s
}

func (s *QueryAppMetadataResponseBody) SetHttpStatusCode(v int32) *QueryAppMetadataResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QueryAppMetadataResponseBody) SetRequestId(v string) *QueryAppMetadataResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryAppMetadataResponseBody) SetSuccess(v bool) *QueryAppMetadataResponseBody {
	s.Success = &v
	return s
}

type QueryAppMetadataResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryAppMetadataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryAppMetadataResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryAppMetadataResponse) GoString() string {
	return s.String()
}

func (s *QueryAppMetadataResponse) SetHeaders(v map[string]*string) *QueryAppMetadataResponse {
	s.Headers = v
	return s
}

func (s *QueryAppMetadataResponse) SetStatusCode(v int32) *QueryAppMetadataResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryAppMetadataResponse) SetBody(v *QueryAppMetadataResponseBody) *QueryAppMetadataResponse {
	s.Body = v
	return s
}

type QueryAppTopologyRequest struct {
	// The application type
	AppType *string `json:"AppType,omitempty" xml:"AppType,omitempty"`
	// The database domain name.
	Db *string `json:"Db,omitempty" xml:"Db,omitempty"`
	// The name of the database.
	DbName *string `json:"DbName,omitempty" xml:"DbName,omitempty"`
	// The end of the time range to query. Unit: milliseconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The filter conditions.
	Filters map[string]*string `json:"Filters,omitempty" xml:"Filters,omitempty"`
	// The ID of the application.
	//
	// Log on to the **ARMS console**. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of an application. The URL in the address bar contains the process ID (PID) of the application. The PID is indicated in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is eb4zdose6v%409781be0f44d\*\*\*\*, you must replace %40 with an at sign (@) to obtain eb4zdose6v@9781be0f44d\*\*\*\*.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// RPC interface name.
	Rpc *string `json:"Rpc,omitempty" xml:"Rpc,omitempty"`
	// The start of the time range to query. Unit: milliseconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The type kind of topology.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s QueryAppTopologyRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryAppTopologyRequest) GoString() string {
	return s.String()
}

func (s *QueryAppTopologyRequest) SetAppType(v string) *QueryAppTopologyRequest {
	s.AppType = &v
	return s
}

func (s *QueryAppTopologyRequest) SetDb(v string) *QueryAppTopologyRequest {
	s.Db = &v
	return s
}

func (s *QueryAppTopologyRequest) SetDbName(v string) *QueryAppTopologyRequest {
	s.DbName = &v
	return s
}

func (s *QueryAppTopologyRequest) SetEndTime(v int64) *QueryAppTopologyRequest {
	s.EndTime = &v
	return s
}

func (s *QueryAppTopologyRequest) SetFilters(v map[string]*string) *QueryAppTopologyRequest {
	s.Filters = v
	return s
}

func (s *QueryAppTopologyRequest) SetPid(v string) *QueryAppTopologyRequest {
	s.Pid = &v
	return s
}

func (s *QueryAppTopologyRequest) SetRegionId(v string) *QueryAppTopologyRequest {
	s.RegionId = &v
	return s
}

func (s *QueryAppTopologyRequest) SetRpc(v string) *QueryAppTopologyRequest {
	s.Rpc = &v
	return s
}

func (s *QueryAppTopologyRequest) SetStartTime(v int64) *QueryAppTopologyRequest {
	s.StartTime = &v
	return s
}

func (s *QueryAppTopologyRequest) SetType(v string) *QueryAppTopologyRequest {
	s.Type = &v
	return s
}

type QueryAppTopologyShrinkRequest struct {
	// The application type
	AppType *string `json:"AppType,omitempty" xml:"AppType,omitempty"`
	// The database domain name.
	Db *string `json:"Db,omitempty" xml:"Db,omitempty"`
	// The name of the database.
	DbName *string `json:"DbName,omitempty" xml:"DbName,omitempty"`
	// The end of the time range to query. Unit: milliseconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The filter conditions.
	FiltersShrink *string `json:"Filters,omitempty" xml:"Filters,omitempty"`
	// The ID of the application.
	//
	// Log on to the **ARMS console**. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of an application. The URL in the address bar contains the process ID (PID) of the application. The PID is indicated in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is eb4zdose6v%409781be0f44d\*\*\*\*, you must replace %40 with an at sign (@) to obtain eb4zdose6v@9781be0f44d\*\*\*\*.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// RPC interface name.
	Rpc *string `json:"Rpc,omitempty" xml:"Rpc,omitempty"`
	// The start of the time range to query. Unit: milliseconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The type kind of topology.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s QueryAppTopologyShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryAppTopologyShrinkRequest) GoString() string {
	return s.String()
}

func (s *QueryAppTopologyShrinkRequest) SetAppType(v string) *QueryAppTopologyShrinkRequest {
	s.AppType = &v
	return s
}

func (s *QueryAppTopologyShrinkRequest) SetDb(v string) *QueryAppTopologyShrinkRequest {
	s.Db = &v
	return s
}

func (s *QueryAppTopologyShrinkRequest) SetDbName(v string) *QueryAppTopologyShrinkRequest {
	s.DbName = &v
	return s
}

func (s *QueryAppTopologyShrinkRequest) SetEndTime(v int64) *QueryAppTopologyShrinkRequest {
	s.EndTime = &v
	return s
}

func (s *QueryAppTopologyShrinkRequest) SetFiltersShrink(v string) *QueryAppTopologyShrinkRequest {
	s.FiltersShrink = &v
	return s
}

func (s *QueryAppTopologyShrinkRequest) SetPid(v string) *QueryAppTopologyShrinkRequest {
	s.Pid = &v
	return s
}

func (s *QueryAppTopologyShrinkRequest) SetRegionId(v string) *QueryAppTopologyShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *QueryAppTopologyShrinkRequest) SetRpc(v string) *QueryAppTopologyShrinkRequest {
	s.Rpc = &v
	return s
}

func (s *QueryAppTopologyShrinkRequest) SetStartTime(v int64) *QueryAppTopologyShrinkRequest {
	s.StartTime = &v
	return s
}

func (s *QueryAppTopologyShrinkRequest) SetType(v string) *QueryAppTopologyShrinkRequest {
	s.Type = &v
	return s
}

type QueryAppTopologyResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
	Code *int64 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned struct.
	Data interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   true: The call was successful.
	// *   false: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryAppTopologyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryAppTopologyResponseBody) GoString() string {
	return s.String()
}

func (s *QueryAppTopologyResponseBody) SetCode(v int64) *QueryAppTopologyResponseBody {
	s.Code = &v
	return s
}

func (s *QueryAppTopologyResponseBody) SetData(v interface{}) *QueryAppTopologyResponseBody {
	s.Data = v
	return s
}

func (s *QueryAppTopologyResponseBody) SetMessage(v string) *QueryAppTopologyResponseBody {
	s.Message = &v
	return s
}

func (s *QueryAppTopologyResponseBody) SetRequestId(v string) *QueryAppTopologyResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryAppTopologyResponseBody) SetSuccess(v bool) *QueryAppTopologyResponseBody {
	s.Success = &v
	return s
}

type QueryAppTopologyResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryAppTopologyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryAppTopologyResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryAppTopologyResponse) GoString() string {
	return s.String()
}

func (s *QueryAppTopologyResponse) SetHeaders(v map[string]*string) *QueryAppTopologyResponse {
	s.Headers = v
	return s
}

func (s *QueryAppTopologyResponse) SetStatusCode(v int32) *QueryAppTopologyResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryAppTopologyResponse) SetBody(v *QueryAppTopologyResponseBody) *QueryAppTopologyResponse {
	s.Body = v
	return s
}

type QueryCommercialUsageRequest struct {
	AdvancedFilters []*QueryCommercialUsageRequestAdvancedFilters `json:"AdvancedFilters,omitempty" xml:"AdvancedFilters,omitempty" type:"Repeated"`
	Dimensions      []*string                                     `json:"Dimensions,omitempty" xml:"Dimensions,omitempty" type:"Repeated"`
	EndTime         *int64                                        `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	IntervalInSec   *int32                                        `json:"IntervalInSec,omitempty" xml:"IntervalInSec,omitempty"`
	Measures        []*string                                     `json:"Measures,omitempty" xml:"Measures,omitempty" type:"Repeated"`
	Metric          *string                                       `json:"Metric,omitempty" xml:"Metric,omitempty"`
	Order           *string                                       `json:"Order,omitempty" xml:"Order,omitempty"`
	OrderBy         *string                                       `json:"OrderBy,omitempty" xml:"OrderBy,omitempty"`
	QueryType       *string                                       `json:"QueryType,omitempty" xml:"QueryType,omitempty"`
	StartTime       *int64                                        `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s QueryCommercialUsageRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryCommercialUsageRequest) GoString() string {
	return s.String()
}

func (s *QueryCommercialUsageRequest) SetAdvancedFilters(v []*QueryCommercialUsageRequestAdvancedFilters) *QueryCommercialUsageRequest {
	s.AdvancedFilters = v
	return s
}

func (s *QueryCommercialUsageRequest) SetDimensions(v []*string) *QueryCommercialUsageRequest {
	s.Dimensions = v
	return s
}

func (s *QueryCommercialUsageRequest) SetEndTime(v int64) *QueryCommercialUsageRequest {
	s.EndTime = &v
	return s
}

func (s *QueryCommercialUsageRequest) SetIntervalInSec(v int32) *QueryCommercialUsageRequest {
	s.IntervalInSec = &v
	return s
}

func (s *QueryCommercialUsageRequest) SetMeasures(v []*string) *QueryCommercialUsageRequest {
	s.Measures = v
	return s
}

func (s *QueryCommercialUsageRequest) SetMetric(v string) *QueryCommercialUsageRequest {
	s.Metric = &v
	return s
}

func (s *QueryCommercialUsageRequest) SetOrder(v string) *QueryCommercialUsageRequest {
	s.Order = &v
	return s
}

func (s *QueryCommercialUsageRequest) SetOrderBy(v string) *QueryCommercialUsageRequest {
	s.OrderBy = &v
	return s
}

func (s *QueryCommercialUsageRequest) SetQueryType(v string) *QueryCommercialUsageRequest {
	s.QueryType = &v
	return s
}

func (s *QueryCommercialUsageRequest) SetStartTime(v int64) *QueryCommercialUsageRequest {
	s.StartTime = &v
	return s
}

type QueryCommercialUsageRequestAdvancedFilters struct {
	Key    *string `json:"Key,omitempty" xml:"Key,omitempty"`
	OpType *string `json:"OpType,omitempty" xml:"OpType,omitempty"`
	Value  *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s QueryCommercialUsageRequestAdvancedFilters) String() string {
	return tea.Prettify(s)
}

func (s QueryCommercialUsageRequestAdvancedFilters) GoString() string {
	return s.String()
}

func (s *QueryCommercialUsageRequestAdvancedFilters) SetKey(v string) *QueryCommercialUsageRequestAdvancedFilters {
	s.Key = &v
	return s
}

func (s *QueryCommercialUsageRequestAdvancedFilters) SetOpType(v string) *QueryCommercialUsageRequestAdvancedFilters {
	s.OpType = &v
	return s
}

func (s *QueryCommercialUsageRequestAdvancedFilters) SetValue(v string) *QueryCommercialUsageRequestAdvancedFilters {
	s.Value = &v
	return s
}

type QueryCommercialUsageResponseBody struct {
	Code      *string                               `json:"Code,omitempty" xml:"Code,omitempty"`
	Data      *QueryCommercialUsageResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	Message   *string                               `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId *string                               `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool                                 `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryCommercialUsageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryCommercialUsageResponseBody) GoString() string {
	return s.String()
}

func (s *QueryCommercialUsageResponseBody) SetCode(v string) *QueryCommercialUsageResponseBody {
	s.Code = &v
	return s
}

func (s *QueryCommercialUsageResponseBody) SetData(v *QueryCommercialUsageResponseBodyData) *QueryCommercialUsageResponseBody {
	s.Data = v
	return s
}

func (s *QueryCommercialUsageResponseBody) SetMessage(v string) *QueryCommercialUsageResponseBody {
	s.Message = &v
	return s
}

func (s *QueryCommercialUsageResponseBody) SetRequestId(v string) *QueryCommercialUsageResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryCommercialUsageResponseBody) SetSuccess(v bool) *QueryCommercialUsageResponseBody {
	s.Success = &v
	return s
}

type QueryCommercialUsageResponseBodyData struct {
	Complete *bool                    `json:"Complete,omitempty" xml:"Complete,omitempty"`
	Items    []map[string]interface{} `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
}

func (s QueryCommercialUsageResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryCommercialUsageResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryCommercialUsageResponseBodyData) SetComplete(v bool) *QueryCommercialUsageResponseBodyData {
	s.Complete = &v
	return s
}

func (s *QueryCommercialUsageResponseBodyData) SetItems(v []map[string]interface{}) *QueryCommercialUsageResponseBodyData {
	s.Items = v
	return s
}

type QueryCommercialUsageResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryCommercialUsageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryCommercialUsageResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryCommercialUsageResponse) GoString() string {
	return s.String()
}

func (s *QueryCommercialUsageResponse) SetHeaders(v map[string]*string) *QueryCommercialUsageResponse {
	s.Headers = v
	return s
}

func (s *QueryCommercialUsageResponse) SetStatusCode(v int32) *QueryCommercialUsageResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryCommercialUsageResponse) SetBody(v *QueryCommercialUsageResponseBody) *QueryCommercialUsageResponse {
	s.Body = v
	return s
}

type QueryMetricByPageRequest struct {
	// The number of the page to return. Default value: `1`.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// Custom filter conditions.
	CustomFilters []*string `json:"CustomFilters,omitempty" xml:"CustomFilters,omitempty" type:"Repeated"`
	// The dimensions of the metric that you want to query.
	Dimensions []*string `json:"Dimensions,omitempty" xml:"Dimensions,omitempty" type:"Repeated"`
	// The end of the time range to query. Unit: milliseconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The filter conditions.
	Filters []*QueryMetricByPageRequestFilters `json:"Filters,omitempty" xml:"Filters,omitempty" type:"Repeated"`
	// The time interval at which data entries are aggregated. Unit: milliseconds. Minimum value: 60000.
	IntervalInSec *int32 `json:"IntervalInSec,omitempty" xml:"IntervalInSec,omitempty"`
	// The measures of the metric that you want to query.
	Measures []*string `json:"Measures,omitempty" xml:"Measures,omitempty" type:"Repeated"`
	// The metric that you want to query. You cannot specify a custom metric. For more information, see the "Application monitoring metrics that can be queried" section.
	Metric *string `json:"Metric,omitempty" xml:"Metric,omitempty"`
	// The order in which measures are sorted. Valid values:
	//
	// *   `ASC`: ascending order
	// *   `DESC`: descending order
	//
	// > If you do not specify the parameter, data is not sorted.
	Order *string `json:"Order,omitempty" xml:"Order,omitempty"`
	// The dimension from which metrics are sorted. You can set this parameter to a supported dimension.
	OrderBy *string `json:"OrderBy,omitempty" xml:"OrderBy,omitempty"`
	// The number of entries to return on each page. This parameter is no longer supported. The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The start of the time range to query. Unit: milliseconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s QueryMetricByPageRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryMetricByPageRequest) GoString() string {
	return s.String()
}

func (s *QueryMetricByPageRequest) SetCurrentPage(v int32) *QueryMetricByPageRequest {
	s.CurrentPage = &v
	return s
}

func (s *QueryMetricByPageRequest) SetCustomFilters(v []*string) *QueryMetricByPageRequest {
	s.CustomFilters = v
	return s
}

func (s *QueryMetricByPageRequest) SetDimensions(v []*string) *QueryMetricByPageRequest {
	s.Dimensions = v
	return s
}

func (s *QueryMetricByPageRequest) SetEndTime(v int64) *QueryMetricByPageRequest {
	s.EndTime = &v
	return s
}

func (s *QueryMetricByPageRequest) SetFilters(v []*QueryMetricByPageRequestFilters) *QueryMetricByPageRequest {
	s.Filters = v
	return s
}

func (s *QueryMetricByPageRequest) SetIntervalInSec(v int32) *QueryMetricByPageRequest {
	s.IntervalInSec = &v
	return s
}

func (s *QueryMetricByPageRequest) SetMeasures(v []*string) *QueryMetricByPageRequest {
	s.Measures = v
	return s
}

func (s *QueryMetricByPageRequest) SetMetric(v string) *QueryMetricByPageRequest {
	s.Metric = &v
	return s
}

func (s *QueryMetricByPageRequest) SetOrder(v string) *QueryMetricByPageRequest {
	s.Order = &v
	return s
}

func (s *QueryMetricByPageRequest) SetOrderBy(v string) *QueryMetricByPageRequest {
	s.OrderBy = &v
	return s
}

func (s *QueryMetricByPageRequest) SetPageSize(v int32) *QueryMetricByPageRequest {
	s.PageSize = &v
	return s
}

func (s *QueryMetricByPageRequest) SetStartTime(v int64) *QueryMetricByPageRequest {
	s.StartTime = &v
	return s
}

type QueryMetricByPageRequestFilters struct {
	// The key of the filter condition. You must set the key to `pid` or `regionId`.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the filter condition. You must set the value of the `pid` or `regionId` condition. For information about how to obtain the `pid`, see the "Obtain the PID of an application" section.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s QueryMetricByPageRequestFilters) String() string {
	return tea.Prettify(s)
}

func (s QueryMetricByPageRequestFilters) GoString() string {
	return s.String()
}

func (s *QueryMetricByPageRequestFilters) SetKey(v string) *QueryMetricByPageRequestFilters {
	s.Key = &v
	return s
}

func (s *QueryMetricByPageRequestFilters) SetValue(v string) *QueryMetricByPageRequestFilters {
	s.Value = &v
	return s
}

type QueryMetricByPageResponseBody struct {
	// The HTTP status code returned for the request. Valid values:
	//
	// *   2XX: The request was successful.
	// *   3XX: A redirection message was returned.
	// *   4XX: The request was invalid.
	// *   5XX: A server error occurred.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about the array object.
	Data *QueryMetricByPageResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   `true`: The call was successful.
	// *   `false`: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryMetricByPageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryMetricByPageResponseBody) GoString() string {
	return s.String()
}

func (s *QueryMetricByPageResponseBody) SetCode(v string) *QueryMetricByPageResponseBody {
	s.Code = &v
	return s
}

func (s *QueryMetricByPageResponseBody) SetData(v *QueryMetricByPageResponseBodyData) *QueryMetricByPageResponseBody {
	s.Data = v
	return s
}

func (s *QueryMetricByPageResponseBody) SetMessage(v string) *QueryMetricByPageResponseBody {
	s.Message = &v
	return s
}

func (s *QueryMetricByPageResponseBody) SetRequestId(v string) *QueryMetricByPageResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryMetricByPageResponseBody) SetSuccess(v bool) *QueryMetricByPageResponseBody {
	s.Success = &v
	return s
}

type QueryMetricByPageResponseBodyData struct {
	// Whether the paging query ends.
	//
	// true: end.
	// false: Need to continue pagination (continue to query after CurrentPage+1).
	Completed *bool `json:"Completed,omitempty" xml:"Completed,omitempty"`
	// The data entries returned.
	Items []map[string]interface{} `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
	// The page number of the returned page.
	Page *int32 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryMetricByPageResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryMetricByPageResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryMetricByPageResponseBodyData) SetCompleted(v bool) *QueryMetricByPageResponseBodyData {
	s.Completed = &v
	return s
}

func (s *QueryMetricByPageResponseBodyData) SetItems(v []map[string]interface{}) *QueryMetricByPageResponseBodyData {
	s.Items = v
	return s
}

func (s *QueryMetricByPageResponseBodyData) SetPage(v int32) *QueryMetricByPageResponseBodyData {
	s.Page = &v
	return s
}

func (s *QueryMetricByPageResponseBodyData) SetPageSize(v int32) *QueryMetricByPageResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryMetricByPageResponseBodyData) SetTotal(v int32) *QueryMetricByPageResponseBodyData {
	s.Total = &v
	return s
}

type QueryMetricByPageResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryMetricByPageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryMetricByPageResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryMetricByPageResponse) GoString() string {
	return s.String()
}

func (s *QueryMetricByPageResponse) SetHeaders(v map[string]*string) *QueryMetricByPageResponse {
	s.Headers = v
	return s
}

func (s *QueryMetricByPageResponse) SetStatusCode(v int32) *QueryMetricByPageResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryMetricByPageResponse) SetBody(v *QueryMetricByPageResponseBody) *QueryMetricByPageResponse {
	s.Body = v
	return s
}

type QueryPromInstallStatusRequest struct {
	// The cluster ID.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s QueryPromInstallStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryPromInstallStatusRequest) GoString() string {
	return s.String()
}

func (s *QueryPromInstallStatusRequest) SetClusterId(v string) *QueryPromInstallStatusRequest {
	s.ClusterId = &v
	return s
}

func (s *QueryPromInstallStatusRequest) SetRegionId(v string) *QueryPromInstallStatusRequest {
	s.RegionId = &v
	return s
}

type QueryPromInstallStatusResponseBody struct {
	// The returned struct.
	Data *QueryPromInstallStatusResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s QueryPromInstallStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryPromInstallStatusResponseBody) GoString() string {
	return s.String()
}

func (s *QueryPromInstallStatusResponseBody) SetData(v *QueryPromInstallStatusResponseBodyData) *QueryPromInstallStatusResponseBody {
	s.Data = v
	return s
}

func (s *QueryPromInstallStatusResponseBody) SetRequestId(v string) *QueryPromInstallStatusResponseBody {
	s.RequestId = &v
	return s
}

type QueryPromInstallStatusResponseBodyData struct {
	// Indicates whether the call was successful. Valid values:
	//
	// true: The call was successful. false: The call fails.
	IsControllerInstalled *bool `json:"isControllerInstalled,omitempty" xml:"isControllerInstalled,omitempty"`
}

func (s QueryPromInstallStatusResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryPromInstallStatusResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryPromInstallStatusResponseBodyData) SetIsControllerInstalled(v bool) *QueryPromInstallStatusResponseBodyData {
	s.IsControllerInstalled = &v
	return s
}

type QueryPromInstallStatusResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryPromInstallStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryPromInstallStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryPromInstallStatusResponse) GoString() string {
	return s.String()
}

func (s *QueryPromInstallStatusResponse) SetHeaders(v map[string]*string) *QueryPromInstallStatusResponse {
	s.Headers = v
	return s
}

func (s *QueryPromInstallStatusResponse) SetStatusCode(v int32) *QueryPromInstallStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryPromInstallStatusResponse) SetBody(v *QueryPromInstallStatusResponseBody) *QueryPromInstallStatusResponse {
	s.Body = v
	return s
}

type QueryReleaseMetricRequest struct {
	ChangeOrderId    *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	CreateTime       *int64  `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	MetricType       *string `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
	Pid              *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	ProxyUserId      *string `json:"ProxyUserId,omitempty" xml:"ProxyUserId,omitempty"`
	ReleaseEndTime   *int64  `json:"ReleaseEndTime,omitempty" xml:"ReleaseEndTime,omitempty"`
	ReleaseStartTime *int64  `json:"ReleaseStartTime,omitempty" xml:"ReleaseStartTime,omitempty"`
	Service          *string `json:"Service,omitempty" xml:"Service,omitempty"`
}

func (s QueryReleaseMetricRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryReleaseMetricRequest) GoString() string {
	return s.String()
}

func (s *QueryReleaseMetricRequest) SetChangeOrderId(v string) *QueryReleaseMetricRequest {
	s.ChangeOrderId = &v
	return s
}

func (s *QueryReleaseMetricRequest) SetCreateTime(v int64) *QueryReleaseMetricRequest {
	s.CreateTime = &v
	return s
}

func (s *QueryReleaseMetricRequest) SetMetricType(v string) *QueryReleaseMetricRequest {
	s.MetricType = &v
	return s
}

func (s *QueryReleaseMetricRequest) SetPid(v string) *QueryReleaseMetricRequest {
	s.Pid = &v
	return s
}

func (s *QueryReleaseMetricRequest) SetProxyUserId(v string) *QueryReleaseMetricRequest {
	s.ProxyUserId = &v
	return s
}

func (s *QueryReleaseMetricRequest) SetReleaseEndTime(v int64) *QueryReleaseMetricRequest {
	s.ReleaseEndTime = &v
	return s
}

func (s *QueryReleaseMetricRequest) SetReleaseStartTime(v int64) *QueryReleaseMetricRequest {
	s.ReleaseStartTime = &v
	return s
}

func (s *QueryReleaseMetricRequest) SetService(v string) *QueryReleaseMetricRequest {
	s.Service = &v
	return s
}

type QueryReleaseMetricResponseBody struct {
	Data      *string `json:"Data,omitempty" xml:"Data,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s QueryReleaseMetricResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryReleaseMetricResponseBody) GoString() string {
	return s.String()
}

func (s *QueryReleaseMetricResponseBody) SetData(v string) *QueryReleaseMetricResponseBody {
	s.Data = &v
	return s
}

func (s *QueryReleaseMetricResponseBody) SetRequestId(v string) *QueryReleaseMetricResponseBody {
	s.RequestId = &v
	return s
}

type QueryReleaseMetricResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryReleaseMetricResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryReleaseMetricResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryReleaseMetricResponse) GoString() string {
	return s.String()
}

func (s *QueryReleaseMetricResponse) SetHeaders(v map[string]*string) *QueryReleaseMetricResponse {
	s.Headers = v
	return s
}

func (s *QueryReleaseMetricResponse) SetStatusCode(v int32) *QueryReleaseMetricResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryReleaseMetricResponse) SetBody(v *QueryReleaseMetricResponseBody) *QueryReleaseMetricResponse {
	s.Body = v
	return s
}

type RemoveAliClusterIdsFromPrometheusGlobalViewRequest struct {
	// The IDs of clusters. Separate multiple IDs with commas (,).
	ClusterIds *string `json:"ClusterIds,omitempty" xml:"ClusterIds,omitempty"`
	// The ID of the global aggregation instance.
	GlobalViewClusterId *string `json:"GlobalViewClusterId,omitempty" xml:"GlobalViewClusterId,omitempty"`
	// The name of the global aggregation instance.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s RemoveAliClusterIdsFromPrometheusGlobalViewRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveAliClusterIdsFromPrometheusGlobalViewRequest) GoString() string {
	return s.String()
}

func (s *RemoveAliClusterIdsFromPrometheusGlobalViewRequest) SetClusterIds(v string) *RemoveAliClusterIdsFromPrometheusGlobalViewRequest {
	s.ClusterIds = &v
	return s
}

func (s *RemoveAliClusterIdsFromPrometheusGlobalViewRequest) SetGlobalViewClusterId(v string) *RemoveAliClusterIdsFromPrometheusGlobalViewRequest {
	s.GlobalViewClusterId = &v
	return s
}

func (s *RemoveAliClusterIdsFromPrometheusGlobalViewRequest) SetGroupName(v string) *RemoveAliClusterIdsFromPrometheusGlobalViewRequest {
	s.GroupName = &v
	return s
}

func (s *RemoveAliClusterIdsFromPrometheusGlobalViewRequest) SetRegionId(v string) *RemoveAliClusterIdsFromPrometheusGlobalViewRequest {
	s.RegionId = &v
	return s
}

type RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody struct {
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned struct.
	Data    *RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	Message *string                                                      `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody) SetCode(v int32) *RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody {
	s.Code = &v
	return s
}

func (s *RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody) SetData(v *RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData) *RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody {
	s.Data = v
	return s
}

func (s *RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody) SetMessage(v string) *RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody {
	s.Message = &v
	return s
}

func (s *RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody) SetRequestId(v string) *RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody {
	s.RequestId = &v
	return s
}

type RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData struct {
	// The Info-level information.
	Info *string `json:"Info,omitempty" xml:"Info,omitempty"`
	// The additional information.
	Msg *string `json:"Msg,omitempty" xml:"Msg,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`
	// *   `false`
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData) GoString() string {
	return s.String()
}

func (s *RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData) SetInfo(v string) *RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData {
	s.Info = &v
	return s
}

func (s *RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData) SetMsg(v string) *RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData {
	s.Msg = &v
	return s
}

func (s *RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData) SetSuccess(v bool) *RemoveAliClusterIdsFromPrometheusGlobalViewResponseBodyData {
	s.Success = &v
	return s
}

type RemoveAliClusterIdsFromPrometheusGlobalViewResponse struct {
	Headers    map[string]*string                                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemoveAliClusterIdsFromPrometheusGlobalViewResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveAliClusterIdsFromPrometheusGlobalViewResponse) GoString() string {
	return s.String()
}

func (s *RemoveAliClusterIdsFromPrometheusGlobalViewResponse) SetHeaders(v map[string]*string) *RemoveAliClusterIdsFromPrometheusGlobalViewResponse {
	s.Headers = v
	return s
}

func (s *RemoveAliClusterIdsFromPrometheusGlobalViewResponse) SetStatusCode(v int32) *RemoveAliClusterIdsFromPrometheusGlobalViewResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveAliClusterIdsFromPrometheusGlobalViewResponse) SetBody(v *RemoveAliClusterIdsFromPrometheusGlobalViewResponseBody) *RemoveAliClusterIdsFromPrometheusGlobalViewResponse {
	s.Body = v
	return s
}

type RemoveSourcesFromPrometheusGlobalViewRequest struct {
	GlobalViewClusterId *string `json:"GlobalViewClusterId,omitempty" xml:"GlobalViewClusterId,omitempty"`
	GroupName           *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	RegionId            *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	SourceNames         *string `json:"SourceNames,omitempty" xml:"SourceNames,omitempty"`
}

func (s RemoveSourcesFromPrometheusGlobalViewRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveSourcesFromPrometheusGlobalViewRequest) GoString() string {
	return s.String()
}

func (s *RemoveSourcesFromPrometheusGlobalViewRequest) SetGlobalViewClusterId(v string) *RemoveSourcesFromPrometheusGlobalViewRequest {
	s.GlobalViewClusterId = &v
	return s
}

func (s *RemoveSourcesFromPrometheusGlobalViewRequest) SetGroupName(v string) *RemoveSourcesFromPrometheusGlobalViewRequest {
	s.GroupName = &v
	return s
}

func (s *RemoveSourcesFromPrometheusGlobalViewRequest) SetRegionId(v string) *RemoveSourcesFromPrometheusGlobalViewRequest {
	s.RegionId = &v
	return s
}

func (s *RemoveSourcesFromPrometheusGlobalViewRequest) SetSourceNames(v string) *RemoveSourcesFromPrometheusGlobalViewRequest {
	s.SourceNames = &v
	return s
}

type RemoveSourcesFromPrometheusGlobalViewResponseBody struct {
	Code      *int32                                                 `json:"Code,omitempty" xml:"Code,omitempty"`
	Data      *RemoveSourcesFromPrometheusGlobalViewResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	Message   *string                                                `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId *string                                                `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RemoveSourcesFromPrometheusGlobalViewResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveSourcesFromPrometheusGlobalViewResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveSourcesFromPrometheusGlobalViewResponseBody) SetCode(v int32) *RemoveSourcesFromPrometheusGlobalViewResponseBody {
	s.Code = &v
	return s
}

func (s *RemoveSourcesFromPrometheusGlobalViewResponseBody) SetData(v *RemoveSourcesFromPrometheusGlobalViewResponseBodyData) *RemoveSourcesFromPrometheusGlobalViewResponseBody {
	s.Data = v
	return s
}

func (s *RemoveSourcesFromPrometheusGlobalViewResponseBody) SetMessage(v string) *RemoveSourcesFromPrometheusGlobalViewResponseBody {
	s.Message = &v
	return s
}

func (s *RemoveSourcesFromPrometheusGlobalViewResponseBody) SetRequestId(v string) *RemoveSourcesFromPrometheusGlobalViewResponseBody {
	s.RequestId = &v
	return s
}

type RemoveSourcesFromPrometheusGlobalViewResponseBodyData struct {
	Info    *string `json:"Info,omitempty" xml:"Info,omitempty"`
	Msg     *string `json:"Msg,omitempty" xml:"Msg,omitempty"`
	Success *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RemoveSourcesFromPrometheusGlobalViewResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s RemoveSourcesFromPrometheusGlobalViewResponseBodyData) GoString() string {
	return s.String()
}

func (s *RemoveSourcesFromPrometheusGlobalViewResponseBodyData) SetInfo(v string) *RemoveSourcesFromPrometheusGlobalViewResponseBodyData {
	s.Info = &v
	return s
}

func (s *RemoveSourcesFromPrometheusGlobalViewResponseBodyData) SetMsg(v string) *RemoveSourcesFromPrometheusGlobalViewResponseBodyData {
	s.Msg = &v
	return s
}

func (s *RemoveSourcesFromPrometheusGlobalViewResponseBodyData) SetSuccess(v bool) *RemoveSourcesFromPrometheusGlobalViewResponseBodyData {
	s.Success = &v
	return s
}

type RemoveSourcesFromPrometheusGlobalViewResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemoveSourcesFromPrometheusGlobalViewResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemoveSourcesFromPrometheusGlobalViewResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveSourcesFromPrometheusGlobalViewResponse) GoString() string {
	return s.String()
}

func (s *RemoveSourcesFromPrometheusGlobalViewResponse) SetHeaders(v map[string]*string) *RemoveSourcesFromPrometheusGlobalViewResponse {
	s.Headers = v
	return s
}

func (s *RemoveSourcesFromPrometheusGlobalViewResponse) SetStatusCode(v int32) *RemoveSourcesFromPrometheusGlobalViewResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveSourcesFromPrometheusGlobalViewResponse) SetBody(v *RemoveSourcesFromPrometheusGlobalViewResponseBody) *RemoveSourcesFromPrometheusGlobalViewResponse {
	s.Body = v
	return s
}

type RestartEnvironmentFeatureRequest struct {
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	FeatureName   *string `json:"FeatureName,omitempty" xml:"FeatureName,omitempty"`
	RegionId      *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s RestartEnvironmentFeatureRequest) String() string {
	return tea.Prettify(s)
}

func (s RestartEnvironmentFeatureRequest) GoString() string {
	return s.String()
}

func (s *RestartEnvironmentFeatureRequest) SetEnvironmentId(v string) *RestartEnvironmentFeatureRequest {
	s.EnvironmentId = &v
	return s
}

func (s *RestartEnvironmentFeatureRequest) SetFeatureName(v string) *RestartEnvironmentFeatureRequest {
	s.FeatureName = &v
	return s
}

func (s *RestartEnvironmentFeatureRequest) SetRegionId(v string) *RestartEnvironmentFeatureRequest {
	s.RegionId = &v
	return s
}

type RestartEnvironmentFeatureResponseBody struct {
	Code    *int32  `json:"Code,omitempty" xml:"Code,omitempty"`
	Data    *string `json:"Data,omitempty" xml:"Data,omitempty"`
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RestartEnvironmentFeatureResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RestartEnvironmentFeatureResponseBody) GoString() string {
	return s.String()
}

func (s *RestartEnvironmentFeatureResponseBody) SetCode(v int32) *RestartEnvironmentFeatureResponseBody {
	s.Code = &v
	return s
}

func (s *RestartEnvironmentFeatureResponseBody) SetData(v string) *RestartEnvironmentFeatureResponseBody {
	s.Data = &v
	return s
}

func (s *RestartEnvironmentFeatureResponseBody) SetMessage(v string) *RestartEnvironmentFeatureResponseBody {
	s.Message = &v
	return s
}

func (s *RestartEnvironmentFeatureResponseBody) SetRequestId(v string) *RestartEnvironmentFeatureResponseBody {
	s.RequestId = &v
	return s
}

func (s *RestartEnvironmentFeatureResponseBody) SetSuccess(v bool) *RestartEnvironmentFeatureResponseBody {
	s.Success = &v
	return s
}

type RestartEnvironmentFeatureResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RestartEnvironmentFeatureResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RestartEnvironmentFeatureResponse) String() string {
	return tea.Prettify(s)
}

func (s RestartEnvironmentFeatureResponse) GoString() string {
	return s.String()
}

func (s *RestartEnvironmentFeatureResponse) SetHeaders(v map[string]*string) *RestartEnvironmentFeatureResponse {
	s.Headers = v
	return s
}

func (s *RestartEnvironmentFeatureResponse) SetStatusCode(v int32) *RestartEnvironmentFeatureResponse {
	s.StatusCode = &v
	return s
}

func (s *RestartEnvironmentFeatureResponse) SetBody(v *RestartEnvironmentFeatureResponseBody) *RestartEnvironmentFeatureResponse {
	s.Body = v
	return s
}

type SaveTraceAppConfigRequest struct {
	// The ID of the application.
	//
	// Log on to the **ARMS console**. In the left-side navigation pane, choose **Application Monitoring** > **Applications**. On the **Applications** page, click the name of an application. The URL in the address bar contains the process ID (PID) of the application. The PID is indicated in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is eb4zdose6v%409781be0f44d\*\*\*\*, you must replace %40 with an at sign (@) to obtain eb4zdose6v@9781be0f44d\*\*\*\*.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The settings of Application Monitoring.
	Settings []*SaveTraceAppConfigRequestSettings `json:"Settings,omitempty" xml:"Settings,omitempty" type:"Repeated"`
}

func (s SaveTraceAppConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s SaveTraceAppConfigRequest) GoString() string {
	return s.String()
}

func (s *SaveTraceAppConfigRequest) SetPid(v string) *SaveTraceAppConfigRequest {
	s.Pid = &v
	return s
}

func (s *SaveTraceAppConfigRequest) SetSettings(v []*SaveTraceAppConfigRequestSettings) *SaveTraceAppConfigRequest {
	s.Settings = v
	return s
}

type SaveTraceAppConfigRequestSettings struct {
	// The values of the settings that you want to modify. For information about the supported settings, see the following items:
	//
	// *   Trace sampling settings
	// *   Main switch settings
	// *   Threshold settings
	// *   Advanced settings
	// *   Thread settings
	// *   Memory snapshot settings
	// *   URL convergence settings
	// *   Business log association settings
	// *   Business monitoring settings
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The values of the settings that you want to modify. For information about the supported settings, see the following items:
	//
	// *   Trace sampling settings
	// *   Main switch settings
	// *   Threshold settings
	// *   Advanced settings
	// *   Thread settings
	// *   Memory snapshot settings
	// *   URL convergence settings
	// *   Business log association settings
	// *   Business monitoring settings
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s SaveTraceAppConfigRequestSettings) String() string {
	return tea.Prettify(s)
}

func (s SaveTraceAppConfigRequestSettings) GoString() string {
	return s.String()
}

func (s *SaveTraceAppConfigRequestSettings) SetKey(v string) *SaveTraceAppConfigRequestSettings {
	s.Key = &v
	return s
}

func (s *SaveTraceAppConfigRequestSettings) SetValue(v string) *SaveTraceAppConfigRequestSettings {
	s.Value = &v
	return s
}

type SaveTraceAppConfigResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
	Code *int64 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the call was successful.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`
	// *   `false`
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SaveTraceAppConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SaveTraceAppConfigResponseBody) GoString() string {
	return s.String()
}

func (s *SaveTraceAppConfigResponseBody) SetCode(v int64) *SaveTraceAppConfigResponseBody {
	s.Code = &v
	return s
}

func (s *SaveTraceAppConfigResponseBody) SetData(v string) *SaveTraceAppConfigResponseBody {
	s.Data = &v
	return s
}

func (s *SaveTraceAppConfigResponseBody) SetMessage(v string) *SaveTraceAppConfigResponseBody {
	s.Message = &v
	return s
}

func (s *SaveTraceAppConfigResponseBody) SetRequestId(v string) *SaveTraceAppConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *SaveTraceAppConfigResponseBody) SetSuccess(v bool) *SaveTraceAppConfigResponseBody {
	s.Success = &v
	return s
}

type SaveTraceAppConfigResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SaveTraceAppConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SaveTraceAppConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s SaveTraceAppConfigResponse) GoString() string {
	return s.String()
}

func (s *SaveTraceAppConfigResponse) SetHeaders(v map[string]*string) *SaveTraceAppConfigResponse {
	s.Headers = v
	return s
}

func (s *SaveTraceAppConfigResponse) SetStatusCode(v int32) *SaveTraceAppConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *SaveTraceAppConfigResponse) SetBody(v *SaveTraceAppConfigResponseBody) *SaveTraceAppConfigResponse {
	s.Body = v
	return s
}

type SearchAlertContactRequest struct {
	// The ID of the alert contact.
	ContactIds *string `json:"ContactIds,omitempty" xml:"ContactIds,omitempty"`
	// The name of the alert contact.
	ContactName *string `json:"ContactName,omitempty" xml:"ContactName,omitempty"`
	// The number of the page to return.
	CurrentPage *string `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The email address of the alert contact.
	Email *string `json:"Email,omitempty" xml:"Email,omitempty"`
	// The number of entries to return on each page.
	PageSize *string `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The mobile number of the alert contact.
	Phone *string `json:"Phone,omitempty" xml:"Phone,omitempty"`
	// The ID of the region. Set the value to `cn-hangzhou`.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s SearchAlertContactRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertContactRequest) GoString() string {
	return s.String()
}

func (s *SearchAlertContactRequest) SetContactIds(v string) *SearchAlertContactRequest {
	s.ContactIds = &v
	return s
}

func (s *SearchAlertContactRequest) SetContactName(v string) *SearchAlertContactRequest {
	s.ContactName = &v
	return s
}

func (s *SearchAlertContactRequest) SetCurrentPage(v string) *SearchAlertContactRequest {
	s.CurrentPage = &v
	return s
}

func (s *SearchAlertContactRequest) SetEmail(v string) *SearchAlertContactRequest {
	s.Email = &v
	return s
}

func (s *SearchAlertContactRequest) SetPageSize(v string) *SearchAlertContactRequest {
	s.PageSize = &v
	return s
}

func (s *SearchAlertContactRequest) SetPhone(v string) *SearchAlertContactRequest {
	s.Phone = &v
	return s
}

func (s *SearchAlertContactRequest) SetRegionId(v string) *SearchAlertContactRequest {
	s.RegionId = &v
	return s
}

type SearchAlertContactResponseBody struct {
	// The returned struct.
	PageBean *SearchAlertContactResponseBodyPageBean `json:"PageBean,omitempty" xml:"PageBean,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SearchAlertContactResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertContactResponseBody) GoString() string {
	return s.String()
}

func (s *SearchAlertContactResponseBody) SetPageBean(v *SearchAlertContactResponseBodyPageBean) *SearchAlertContactResponseBody {
	s.PageBean = v
	return s
}

func (s *SearchAlertContactResponseBody) SetRequestId(v string) *SearchAlertContactResponseBody {
	s.RequestId = &v
	return s
}

type SearchAlertContactResponseBodyPageBean struct {
	// The information about the alert contacts.
	Contacts []*SearchAlertContactResponseBodyPageBeanContacts `json:"Contacts,omitempty" xml:"Contacts,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of returned entries.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s SearchAlertContactResponseBodyPageBean) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertContactResponseBodyPageBean) GoString() string {
	return s.String()
}

func (s *SearchAlertContactResponseBodyPageBean) SetContacts(v []*SearchAlertContactResponseBodyPageBeanContacts) *SearchAlertContactResponseBodyPageBean {
	s.Contacts = v
	return s
}

func (s *SearchAlertContactResponseBodyPageBean) SetPageNumber(v int32) *SearchAlertContactResponseBodyPageBean {
	s.PageNumber = &v
	return s
}

func (s *SearchAlertContactResponseBodyPageBean) SetPageSize(v int32) *SearchAlertContactResponseBodyPageBean {
	s.PageSize = &v
	return s
}

func (s *SearchAlertContactResponseBodyPageBean) SetTotalCount(v int32) *SearchAlertContactResponseBodyPageBean {
	s.TotalCount = &v
	return s
}

type SearchAlertContactResponseBodyPageBeanContacts struct {
	// The ID of the alert contact.
	ContactId *int64 `json:"ContactId,omitempty" xml:"ContactId,omitempty"`
	// The name of the alert contact.
	ContactName *string `json:"ContactName,omitempty" xml:"ContactName,omitempty"`
	// The contact group to which the contact belongs. If your contacts are added to multiple contact groups, the contact groups are separated by vertical bars (|).
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The timestamp generated when the alert contact was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The webhook URL of the DingTalk chatbot.
	DingRobot *string `json:"DingRobot,omitempty" xml:"DingRobot,omitempty"`
	// The email address of the alert contact.
	Email *string `json:"Email,omitempty" xml:"Email,omitempty"`
	// The mobile number of the alert contact.
	Phone *string `json:"Phone,omitempty" xml:"Phone,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Indicates whether the alert contact receives system notifications. Valid values:
	//
	// *   `true`: The alert contact receives system notifications.
	// *   `false`: The alert contact does not receive system notifications.
	SystemNoc *bool `json:"SystemNoc,omitempty" xml:"SystemNoc,omitempty"`
	// The timestamp generated when the alert contact was updated.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The information about the webhook.
	Webhook *string `json:"Webhook,omitempty" xml:"Webhook,omitempty"`
}

func (s SearchAlertContactResponseBodyPageBeanContacts) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertContactResponseBodyPageBeanContacts) GoString() string {
	return s.String()
}

func (s *SearchAlertContactResponseBodyPageBeanContacts) SetContactId(v int64) *SearchAlertContactResponseBodyPageBeanContacts {
	s.ContactId = &v
	return s
}

func (s *SearchAlertContactResponseBodyPageBeanContacts) SetContactName(v string) *SearchAlertContactResponseBodyPageBeanContacts {
	s.ContactName = &v
	return s
}

func (s *SearchAlertContactResponseBodyPageBeanContacts) SetContent(v string) *SearchAlertContactResponseBodyPageBeanContacts {
	s.Content = &v
	return s
}

func (s *SearchAlertContactResponseBodyPageBeanContacts) SetCreateTime(v int64) *SearchAlertContactResponseBodyPageBeanContacts {
	s.CreateTime = &v
	return s
}

func (s *SearchAlertContactResponseBodyPageBeanContacts) SetDingRobot(v string) *SearchAlertContactResponseBodyPageBeanContacts {
	s.DingRobot = &v
	return s
}

func (s *SearchAlertContactResponseBodyPageBeanContacts) SetEmail(v string) *SearchAlertContactResponseBodyPageBeanContacts {
	s.Email = &v
	return s
}

func (s *SearchAlertContactResponseBodyPageBeanContacts) SetPhone(v string) *SearchAlertContactResponseBodyPageBeanContacts {
	s.Phone = &v
	return s
}

func (s *SearchAlertContactResponseBodyPageBeanContacts) SetResourceGroupId(v string) *SearchAlertContactResponseBodyPageBeanContacts {
	s.ResourceGroupId = &v
	return s
}

func (s *SearchAlertContactResponseBodyPageBeanContacts) SetSystemNoc(v bool) *SearchAlertContactResponseBodyPageBeanContacts {
	s.SystemNoc = &v
	return s
}

func (s *SearchAlertContactResponseBodyPageBeanContacts) SetUpdateTime(v int64) *SearchAlertContactResponseBodyPageBeanContacts {
	s.UpdateTime = &v
	return s
}

func (s *SearchAlertContactResponseBodyPageBeanContacts) SetUserId(v string) *SearchAlertContactResponseBodyPageBeanContacts {
	s.UserId = &v
	return s
}

func (s *SearchAlertContactResponseBodyPageBeanContacts) SetWebhook(v string) *SearchAlertContactResponseBodyPageBeanContacts {
	s.Webhook = &v
	return s
}

type SearchAlertContactResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SearchAlertContactResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchAlertContactResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertContactResponse) GoString() string {
	return s.String()
}

func (s *SearchAlertContactResponse) SetHeaders(v map[string]*string) *SearchAlertContactResponse {
	s.Headers = v
	return s
}

func (s *SearchAlertContactResponse) SetStatusCode(v int32) *SearchAlertContactResponse {
	s.StatusCode = &v
	return s
}

func (s *SearchAlertContactResponse) SetBody(v *SearchAlertContactResponseBody) *SearchAlertContactResponse {
	s.Body = v
	return s
}

type SearchAlertContactGroupRequest struct {
	// The ID of the alert contact group. You can query multiple alert contact groups at a time. Separate multiple group IDs with commas (,).
	ContactGroupIds *string `json:"ContactGroupIds,omitempty" xml:"ContactGroupIds,omitempty"`
	// The name of the alert contact group.
	ContactGroupName *string `json:"ContactGroupName,omitempty" xml:"ContactGroupName,omitempty"`
	// The ID of the alert contact. You can call the SearchAlertContact operation to query the contact IDs. For more information, see [SearchAlertContact](~~130703~~).
	ContactId *int64 `json:"ContactId,omitempty" xml:"ContactId,omitempty"`
	// The name of the alert contact.
	ContactName *string `json:"ContactName,omitempty" xml:"ContactName,omitempty"`
	// Specifies whether to return all alert contacts in the queried alert contact group. By default, not all alert contacts are returned.
	IsDetail *bool `json:"IsDetail,omitempty" xml:"IsDetail,omitempty"`
	// The ID of the region. Default value: `cn-hangzhou`.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s SearchAlertContactGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertContactGroupRequest) GoString() string {
	return s.String()
}

func (s *SearchAlertContactGroupRequest) SetContactGroupIds(v string) *SearchAlertContactGroupRequest {
	s.ContactGroupIds = &v
	return s
}

func (s *SearchAlertContactGroupRequest) SetContactGroupName(v string) *SearchAlertContactGroupRequest {
	s.ContactGroupName = &v
	return s
}

func (s *SearchAlertContactGroupRequest) SetContactId(v int64) *SearchAlertContactGroupRequest {
	s.ContactId = &v
	return s
}

func (s *SearchAlertContactGroupRequest) SetContactName(v string) *SearchAlertContactGroupRequest {
	s.ContactName = &v
	return s
}

func (s *SearchAlertContactGroupRequest) SetIsDetail(v bool) *SearchAlertContactGroupRequest {
	s.IsDetail = &v
	return s
}

func (s *SearchAlertContactGroupRequest) SetRegionId(v string) *SearchAlertContactGroupRequest {
	s.RegionId = &v
	return s
}

type SearchAlertContactGroupResponseBody struct {
	// The information about the alert contact groups.
	ContactGroups []*SearchAlertContactGroupResponseBodyContactGroups `json:"ContactGroups,omitempty" xml:"ContactGroups,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SearchAlertContactGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertContactGroupResponseBody) GoString() string {
	return s.String()
}

func (s *SearchAlertContactGroupResponseBody) SetContactGroups(v []*SearchAlertContactGroupResponseBodyContactGroups) *SearchAlertContactGroupResponseBody {
	s.ContactGroups = v
	return s
}

func (s *SearchAlertContactGroupResponseBody) SetRequestId(v string) *SearchAlertContactGroupResponseBody {
	s.RequestId = &v
	return s
}

type SearchAlertContactGroupResponseBodyContactGroups struct {
	// The ID of the alert contact group.
	ContactGroupId *int64 `json:"ContactGroupId,omitempty" xml:"ContactGroupId,omitempty"`
	// The name of the alert contact group.
	ContactGroupName *string `json:"ContactGroupName,omitempty" xml:"ContactGroupName,omitempty"`
	// The alert contact list.
	Contacts []*SearchAlertContactGroupResponseBodyContactGroupsContacts `json:"Contacts,omitempty" xml:"Contacts,omitempty" type:"Repeated"`
	// The time when the alert contact group list was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The time when the alert contact group was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s SearchAlertContactGroupResponseBodyContactGroups) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertContactGroupResponseBodyContactGroups) GoString() string {
	return s.String()
}

func (s *SearchAlertContactGroupResponseBodyContactGroups) SetContactGroupId(v int64) *SearchAlertContactGroupResponseBodyContactGroups {
	s.ContactGroupId = &v
	return s
}

func (s *SearchAlertContactGroupResponseBodyContactGroups) SetContactGroupName(v string) *SearchAlertContactGroupResponseBodyContactGroups {
	s.ContactGroupName = &v
	return s
}

func (s *SearchAlertContactGroupResponseBodyContactGroups) SetContacts(v []*SearchAlertContactGroupResponseBodyContactGroupsContacts) *SearchAlertContactGroupResponseBodyContactGroups {
	s.Contacts = v
	return s
}

func (s *SearchAlertContactGroupResponseBodyContactGroups) SetCreateTime(v int64) *SearchAlertContactGroupResponseBodyContactGroups {
	s.CreateTime = &v
	return s
}

func (s *SearchAlertContactGroupResponseBodyContactGroups) SetUpdateTime(v int64) *SearchAlertContactGroupResponseBodyContactGroups {
	s.UpdateTime = &v
	return s
}

func (s *SearchAlertContactGroupResponseBodyContactGroups) SetUserId(v string) *SearchAlertContactGroupResponseBodyContactGroups {
	s.UserId = &v
	return s
}

type SearchAlertContactGroupResponseBodyContactGroupsContacts struct {
	// The ID of the alert contact.
	ContactId *int64 `json:"ContactId,omitempty" xml:"ContactId,omitempty"`
	// The name of the alert contact.
	ContactName *string `json:"ContactName,omitempty" xml:"ContactName,omitempty"`
	// The time when the alert contact group list was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The webhook URL of the DingTalk chatbot.
	DingRobot *string `json:"DingRobot,omitempty" xml:"DingRobot,omitempty"`
	// The email address of the alert contact.
	Email *string `json:"Email,omitempty" xml:"Email,omitempty"`
	// The mobile number of the alert contact.
	Phone *string `json:"Phone,omitempty" xml:"Phone,omitempty"`
	// Indicates whether the alert contact receives system notifications. Valid values:
	//
	// *   true: receives system notifications.
	// *   false: does not receive system notifications.
	SystemNoc *bool `json:"SystemNoc,omitempty" xml:"SystemNoc,omitempty"`
	// The time when the alert contact group was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s SearchAlertContactGroupResponseBodyContactGroupsContacts) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertContactGroupResponseBodyContactGroupsContacts) GoString() string {
	return s.String()
}

func (s *SearchAlertContactGroupResponseBodyContactGroupsContacts) SetContactId(v int64) *SearchAlertContactGroupResponseBodyContactGroupsContacts {
	s.ContactId = &v
	return s
}

func (s *SearchAlertContactGroupResponseBodyContactGroupsContacts) SetContactName(v string) *SearchAlertContactGroupResponseBodyContactGroupsContacts {
	s.ContactName = &v
	return s
}

func (s *SearchAlertContactGroupResponseBodyContactGroupsContacts) SetCreateTime(v int64) *SearchAlertContactGroupResponseBodyContactGroupsContacts {
	s.CreateTime = &v
	return s
}

func (s *SearchAlertContactGroupResponseBodyContactGroupsContacts) SetDingRobot(v string) *SearchAlertContactGroupResponseBodyContactGroupsContacts {
	s.DingRobot = &v
	return s
}

func (s *SearchAlertContactGroupResponseBodyContactGroupsContacts) SetEmail(v string) *SearchAlertContactGroupResponseBodyContactGroupsContacts {
	s.Email = &v
	return s
}

func (s *SearchAlertContactGroupResponseBodyContactGroupsContacts) SetPhone(v string) *SearchAlertContactGroupResponseBodyContactGroupsContacts {
	s.Phone = &v
	return s
}

func (s *SearchAlertContactGroupResponseBodyContactGroupsContacts) SetSystemNoc(v bool) *SearchAlertContactGroupResponseBodyContactGroupsContacts {
	s.SystemNoc = &v
	return s
}

func (s *SearchAlertContactGroupResponseBodyContactGroupsContacts) SetUpdateTime(v int64) *SearchAlertContactGroupResponseBodyContactGroupsContacts {
	s.UpdateTime = &v
	return s
}

func (s *SearchAlertContactGroupResponseBodyContactGroupsContacts) SetUserId(v string) *SearchAlertContactGroupResponseBodyContactGroupsContacts {
	s.UserId = &v
	return s
}

type SearchAlertContactGroupResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SearchAlertContactGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchAlertContactGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertContactGroupResponse) GoString() string {
	return s.String()
}

func (s *SearchAlertContactGroupResponse) SetHeaders(v map[string]*string) *SearchAlertContactGroupResponse {
	s.Headers = v
	return s
}

func (s *SearchAlertContactGroupResponse) SetStatusCode(v int32) *SearchAlertContactGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *SearchAlertContactGroupResponse) SetBody(v *SearchAlertContactGroupResponseBody) *SearchAlertContactGroupResponse {
	s.Body = v
	return s
}

type SearchAlertHistoriesRequest struct {
	// The ID of the alert rule. You can call the SearchAlertRules operation and view the `Id` parameter in the response. For more information, see [SearchAlertRules](~~175825~~).
	AlertId *int64 `json:"AlertId,omitempty" xml:"AlertId,omitempty"`
	// The type of the alert rule. Valid values:
	//
	// *   `1`: a custom alert rule that is used to monitor drill-down data sets
	// *   `3`: a custom alert rule that is used to monitor tiled data sets
	// *   `4`: an alert rule that is used to monitor web pages, including the default alert rule for browser monitoring
	// *   `5`: an alert rule that is used to monitor applications, including the default alert rule for application monitoring
	// *   `6`: the default alert rule for browser monitoring
	// *   `7`: the default alert rule for application monitoring
	// *   `8`: a Tracing Analysis alert rule
	// *   `101`: a Prometheus alert rule
	AlertType *int32 `json:"AlertType,omitempty" xml:"AlertType,omitempty"`
	// The number of the page to return. Default value: `1`.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The end of the time range to query. The value is a UNIX timestamp of the LONG data type. Unit: milliseconds. The default value is the current time.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The number of entries to return on each page. Default value: `10`.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region. Default value: `cn-hangzhou`.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The beginning of the time range to query. The value is a UNIX timestamp of the LONG data type. Unit: milliseconds. The default value is 10 minutes before the current time.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s SearchAlertHistoriesRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertHistoriesRequest) GoString() string {
	return s.String()
}

func (s *SearchAlertHistoriesRequest) SetAlertId(v int64) *SearchAlertHistoriesRequest {
	s.AlertId = &v
	return s
}

func (s *SearchAlertHistoriesRequest) SetAlertType(v int32) *SearchAlertHistoriesRequest {
	s.AlertType = &v
	return s
}

func (s *SearchAlertHistoriesRequest) SetCurrentPage(v int32) *SearchAlertHistoriesRequest {
	s.CurrentPage = &v
	return s
}

func (s *SearchAlertHistoriesRequest) SetEndTime(v int64) *SearchAlertHistoriesRequest {
	s.EndTime = &v
	return s
}

func (s *SearchAlertHistoriesRequest) SetPageSize(v int32) *SearchAlertHistoriesRequest {
	s.PageSize = &v
	return s
}

func (s *SearchAlertHistoriesRequest) SetRegionId(v string) *SearchAlertHistoriesRequest {
	s.RegionId = &v
	return s
}

func (s *SearchAlertHistoriesRequest) SetStartTime(v int64) *SearchAlertHistoriesRequest {
	s.StartTime = &v
	return s
}

type SearchAlertHistoriesResponseBody struct {
	// The returned struct.
	PageBean *SearchAlertHistoriesResponseBodyPageBean `json:"PageBean,omitempty" xml:"PageBean,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SearchAlertHistoriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertHistoriesResponseBody) GoString() string {
	return s.String()
}

func (s *SearchAlertHistoriesResponseBody) SetPageBean(v *SearchAlertHistoriesResponseBodyPageBean) *SearchAlertHistoriesResponseBody {
	s.PageBean = v
	return s
}

func (s *SearchAlertHistoriesResponseBody) SetRequestId(v string) *SearchAlertHistoriesResponseBody {
	s.RequestId = &v
	return s
}

type SearchAlertHistoriesResponseBodyPageBean struct {
	// The information about alert records.
	AlarmHistories []*SearchAlertHistoriesResponseBodyPageBeanAlarmHistories `json:"AlarmHistories,omitempty" xml:"AlarmHistories,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of returned entries.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s SearchAlertHistoriesResponseBodyPageBean) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertHistoriesResponseBodyPageBean) GoString() string {
	return s.String()
}

func (s *SearchAlertHistoriesResponseBodyPageBean) SetAlarmHistories(v []*SearchAlertHistoriesResponseBodyPageBeanAlarmHistories) *SearchAlertHistoriesResponseBodyPageBean {
	s.AlarmHistories = v
	return s
}

func (s *SearchAlertHistoriesResponseBodyPageBean) SetPageNumber(v int32) *SearchAlertHistoriesResponseBodyPageBean {
	s.PageNumber = &v
	return s
}

func (s *SearchAlertHistoriesResponseBodyPageBean) SetPageSize(v int32) *SearchAlertHistoriesResponseBodyPageBean {
	s.PageSize = &v
	return s
}

func (s *SearchAlertHistoriesResponseBodyPageBean) SetTotalCount(v int32) *SearchAlertHistoriesResponseBodyPageBean {
	s.TotalCount = &v
	return s
}

type SearchAlertHistoriesResponseBodyPageBeanAlarmHistories struct {
	// The content of the alert notification.
	AlarmContent *string `json:"AlarmContent,omitempty" xml:"AlarmContent,omitempty"`
	// The response code returned after the alert notification was sent.
	AlarmResponseCode *int32 `json:"AlarmResponseCode,omitempty" xml:"AlarmResponseCode,omitempty"`
	// The webhook URL, such as the webhook URL of a DingTalk chatbot.
	AlarmSources *string `json:"AlarmSources,omitempty" xml:"AlarmSources,omitempty"`
	// The time when the alert notification was sent.
	AlarmTime *int64 `json:"AlarmTime,omitempty" xml:"AlarmTime,omitempty"`
	// The type of the alert rule. Default value: 4. Valid values:
	//
	// *   `1`: a custom alert rule that is used to monitor drill-down data sets
	// *   `3`: a custom alert rule that is used to monitor tiled data sets
	// *   `4`: an alert rule that is used to monitor web pages, including the default alert rule for browser monitoring
	// *   `5`: an alert rule that is used to monitor applications, including the default alert rule for application monitoring
	// *   `6`: the default alert rule for browser monitoring
	// *   `7`: the default alert rule for application monitoring
	// *   `8`: a Tracing Analysis alert rule
	// *   `101`: a Prometheus alert rule
	AlarmType *int32 `json:"AlarmType,omitempty" xml:"AlarmType,omitempty"`
	// The email address of the alert contact.
	Emails *string `json:"Emails,omitempty" xml:"Emails,omitempty"`
	// The ID of the alert notification.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The mobile phone number of the alert contact.
	Phones *string `json:"Phones,omitempty" xml:"Phones,omitempty"`
	// The internal fields.
	StrategyId *string `json:"StrategyId,omitempty" xml:"StrategyId,omitempty"`
	// The internal fields.
	Target *string `json:"Target,omitempty" xml:"Target,omitempty"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s SearchAlertHistoriesResponseBodyPageBeanAlarmHistories) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertHistoriesResponseBodyPageBeanAlarmHistories) GoString() string {
	return s.String()
}

func (s *SearchAlertHistoriesResponseBodyPageBeanAlarmHistories) SetAlarmContent(v string) *SearchAlertHistoriesResponseBodyPageBeanAlarmHistories {
	s.AlarmContent = &v
	return s
}

func (s *SearchAlertHistoriesResponseBodyPageBeanAlarmHistories) SetAlarmResponseCode(v int32) *SearchAlertHistoriesResponseBodyPageBeanAlarmHistories {
	s.AlarmResponseCode = &v
	return s
}

func (s *SearchAlertHistoriesResponseBodyPageBeanAlarmHistories) SetAlarmSources(v string) *SearchAlertHistoriesResponseBodyPageBeanAlarmHistories {
	s.AlarmSources = &v
	return s
}

func (s *SearchAlertHistoriesResponseBodyPageBeanAlarmHistories) SetAlarmTime(v int64) *SearchAlertHistoriesResponseBodyPageBeanAlarmHistories {
	s.AlarmTime = &v
	return s
}

func (s *SearchAlertHistoriesResponseBodyPageBeanAlarmHistories) SetAlarmType(v int32) *SearchAlertHistoriesResponseBodyPageBeanAlarmHistories {
	s.AlarmType = &v
	return s
}

func (s *SearchAlertHistoriesResponseBodyPageBeanAlarmHistories) SetEmails(v string) *SearchAlertHistoriesResponseBodyPageBeanAlarmHistories {
	s.Emails = &v
	return s
}

func (s *SearchAlertHistoriesResponseBodyPageBeanAlarmHistories) SetId(v int64) *SearchAlertHistoriesResponseBodyPageBeanAlarmHistories {
	s.Id = &v
	return s
}

func (s *SearchAlertHistoriesResponseBodyPageBeanAlarmHistories) SetPhones(v string) *SearchAlertHistoriesResponseBodyPageBeanAlarmHistories {
	s.Phones = &v
	return s
}

func (s *SearchAlertHistoriesResponseBodyPageBeanAlarmHistories) SetStrategyId(v string) *SearchAlertHistoriesResponseBodyPageBeanAlarmHistories {
	s.StrategyId = &v
	return s
}

func (s *SearchAlertHistoriesResponseBodyPageBeanAlarmHistories) SetTarget(v string) *SearchAlertHistoriesResponseBodyPageBeanAlarmHistories {
	s.Target = &v
	return s
}

func (s *SearchAlertHistoriesResponseBodyPageBeanAlarmHistories) SetUserId(v string) *SearchAlertHistoriesResponseBodyPageBeanAlarmHistories {
	s.UserId = &v
	return s
}

type SearchAlertHistoriesResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SearchAlertHistoriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchAlertHistoriesResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertHistoriesResponse) GoString() string {
	return s.String()
}

func (s *SearchAlertHistoriesResponse) SetHeaders(v map[string]*string) *SearchAlertHistoriesResponse {
	s.Headers = v
	return s
}

func (s *SearchAlertHistoriesResponse) SetStatusCode(v int32) *SearchAlertHistoriesResponse {
	s.StatusCode = &v
	return s
}

func (s *SearchAlertHistoriesResponse) SetBody(v *SearchAlertHistoriesResponseBody) *SearchAlertHistoriesResponse {
	s.Body = v
	return s
}

type SearchAlertRulesRequest struct {
	// The id of AlertRule.
	AlertRuleId *string `json:"AlertRuleId,omitempty" xml:"AlertRuleId,omitempty"`
	// The type of the application that is associated with the alert rule. Valid values:
	//
	// *   `TRACE`: application
	// *   `RETCODE`: browser
	AppType *string `json:"AppType,omitempty" xml:"AppType,omitempty"`
	// The page number of the page to return. Default value: `1`.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The number of entries to return per page. Default value: `10`.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The process identifier (PID) of the application that is associated with the alert rule. For more information about how to obtain the PID, see [Obtain the PID of an application](https://help.aliyun.com/document_detail/186100.html?spm=a2c4g.11186623.6.792.1b50654cqcDPyk#title-imy-7gj-qhr).
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The region ID of the alert data. For more information about the mappings between **RegionId** and **SystemRegionId**, see the detailed description below the table.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group. You can obtain the resource group ID in the **Resource Management** console.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The region ID of the alert rule. For more information about the mappings between **RegionId** and **SystemRegionId**, see the detailed description below the table.
	SystemRegionId *string `json:"SystemRegionId,omitempty" xml:"SystemRegionId,omitempty"`
	// The list of tags.
	Tags []*SearchAlertRulesRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The alert rule name.
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The alert rule type. Valid values:
	//
	// *   `1`: custom alert rules that are used to monitor drill-down data sets
	// *   `3`: custom alert rules that are used to monitor tiled data sets
	// *   `4`: alert rules that are used to monitor the browser, including the default frontend alert rules
	// *   `5`: alert rules that are used to monitor applications, including the default application alert rules
	// *   `6`: the default browser alert rules
	// *   `7`: the default application alert rules
	// *   `8`: Tracing Analysis alert rules
	// *   `101`: Prometheus alert rules
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s SearchAlertRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertRulesRequest) GoString() string {
	return s.String()
}

func (s *SearchAlertRulesRequest) SetAlertRuleId(v string) *SearchAlertRulesRequest {
	s.AlertRuleId = &v
	return s
}

func (s *SearchAlertRulesRequest) SetAppType(v string) *SearchAlertRulesRequest {
	s.AppType = &v
	return s
}

func (s *SearchAlertRulesRequest) SetCurrentPage(v int32) *SearchAlertRulesRequest {
	s.CurrentPage = &v
	return s
}

func (s *SearchAlertRulesRequest) SetPageSize(v int32) *SearchAlertRulesRequest {
	s.PageSize = &v
	return s
}

func (s *SearchAlertRulesRequest) SetPid(v string) *SearchAlertRulesRequest {
	s.Pid = &v
	return s
}

func (s *SearchAlertRulesRequest) SetRegionId(v string) *SearchAlertRulesRequest {
	s.RegionId = &v
	return s
}

func (s *SearchAlertRulesRequest) SetResourceGroupId(v string) *SearchAlertRulesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *SearchAlertRulesRequest) SetSystemRegionId(v string) *SearchAlertRulesRequest {
	s.SystemRegionId = &v
	return s
}

func (s *SearchAlertRulesRequest) SetTags(v []*SearchAlertRulesRequestTags) *SearchAlertRulesRequest {
	s.Tags = v
	return s
}

func (s *SearchAlertRulesRequest) SetTitle(v string) *SearchAlertRulesRequest {
	s.Title = &v
	return s
}

func (s *SearchAlertRulesRequest) SetType(v string) *SearchAlertRulesRequest {
	s.Type = &v
	return s
}

type SearchAlertRulesRequestTags struct {
	// The key of the tag. The following system preset fields are provided:
	//
	// *   traceId: the ID of the trace.
	// *   serverApp: the name of the server application.
	// *   clientApp: the name of the client application.
	// *   service: the name of the operation.
	// *   rpc: the type of the call.
	// *   msOfSpan: the duration exceeds a specific value.
	// *   clientIp: the IP address of the client.
	// *   serverIp: the IP address of the server.
	// *   isError: specifies whether the call is abnormal.
	// *   hasTprof: contains only thread profiling.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s SearchAlertRulesRequestTags) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertRulesRequestTags) GoString() string {
	return s.String()
}

func (s *SearchAlertRulesRequestTags) SetKey(v string) *SearchAlertRulesRequestTags {
	s.Key = &v
	return s
}

func (s *SearchAlertRulesRequestTags) SetValue(v string) *SearchAlertRulesRequestTags {
	s.Value = &v
	return s
}

type SearchAlertRulesResponseBody struct {
	// The returned struct.
	PageBean *SearchAlertRulesResponseBodyPageBean `json:"PageBean,omitempty" xml:"PageBean,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SearchAlertRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertRulesResponseBody) GoString() string {
	return s.String()
}

func (s *SearchAlertRulesResponseBody) SetPageBean(v *SearchAlertRulesResponseBodyPageBean) *SearchAlertRulesResponseBody {
	s.PageBean = v
	return s
}

func (s *SearchAlertRulesResponseBody) SetRequestId(v string) *SearchAlertRulesResponseBody {
	s.RequestId = &v
	return s
}

type SearchAlertRulesResponseBodyPageBean struct {
	// The details of the alert rules.
	AlertRules []*SearchAlertRulesResponseBodyPageBeanAlertRules `json:"AlertRules,omitempty" xml:"AlertRules,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of returned entries.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s SearchAlertRulesResponseBodyPageBean) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertRulesResponseBodyPageBean) GoString() string {
	return s.String()
}

func (s *SearchAlertRulesResponseBodyPageBean) SetAlertRules(v []*SearchAlertRulesResponseBodyPageBeanAlertRules) *SearchAlertRulesResponseBodyPageBean {
	s.AlertRules = v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBean) SetPageNumber(v int32) *SearchAlertRulesResponseBodyPageBean {
	s.PageNumber = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBean) SetPageSize(v int32) *SearchAlertRulesResponseBodyPageBean {
	s.PageSize = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBean) SetTotalCount(v int32) *SearchAlertRulesResponseBodyPageBean {
	s.TotalCount = &v
	return s
}

type SearchAlertRulesResponseBodyPageBeanAlertRules struct {
	// The format of the alert notification.
	AlarmContext *SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext `json:"AlarmContext,omitempty" xml:"AlarmContext,omitempty" type:"Struct"`
	// The severity of the alerts. Only the value `WARN` is supported.
	AlertLevel *string `json:"AlertLevel,omitempty" xml:"AlertLevel,omitempty"`
	// The conditions of the alert rule. Multiple conditions are separated by the AND or OR logical operators.
	AlertRule *SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule `json:"AlertRule,omitempty" xml:"AlertRule,omitempty" type:"Struct"`
	// The name of the alert rule.
	AlertTitle *string `json:"AlertTitle,omitempty" xml:"AlertTitle,omitempty"`
	// The type of the alert rule. Valid values:
	//
	// *   `1`: custom alert rules that are used to monitor drill-down data sets
	// *   `3`: custom alert rules that are used to monitor tiled data sets
	// *   `4`: alert rules that are used to monitor the browser, including the default frontend alert rules
	// *   `5`: alert rules that are used to monitor applications, including the default application alert rules
	// *   `6`: the default browser alert rules
	// *   `7`: the default application alert rules
	// *   `8`: Tracing Analysis alert rules
	// *   `101`: Prometheus alert rules
	AlertType *int32 `json:"AlertType,omitempty" xml:"AlertType,omitempty"`
	// The version of the alert rule. Default value: `1`.
	AlertVersion *int32 `json:"AlertVersion,omitempty" xml:"AlertVersion,omitempty"`
	// Sending method of alarm notification.
	AlertWays []*string `json:"AlertWays,omitempty" xml:"AlertWays,omitempty" type:"Repeated"`
	// The configuration items of the alert rule. The value is a JSON string.
	//
	// The configuration item **continuous** indicates whether alert notifications are continuously sent. Valid values:
	//
	// *   `true`: Alert notifications are sent every minute.
	// *   `false`: The alert silence feature is enabled.
	//
	// The configuration item **dataRevision** indicates the data revision policy that is used if no data is obtained or the data is null. Default value: 2. Valid values:
	//
	// *   `0`: overwrites the data by using the value 0
	// *   `1`: overwrites the data by using the value 1
	// *   `2`: overwrites the data by using the value null. This value indicates that no alert is triggered if no data exists
	Config *string `json:"Config,omitempty" xml:"Config,omitempty"`
	// The ID of the contact group. Multiple IDs are separated by commas (,).
	ContactGroupIdList *string `json:"ContactGroupIdList,omitempty" xml:"ContactGroupIdList,omitempty"`
	// The IDs of the alert contact groups. The value is a JSON array.
	ContactGroupIds *string `json:"ContactGroupIds,omitempty" xml:"ContactGroupIds,omitempty"`
	// The timestamp that shows when the alert rule was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// Indicates whether the alert is sent through the alert center. Valid values:
	//
	// *   `true`
	// *   `false`
	HostByAlertManager *bool `json:"HostByAlertManager,omitempty" xml:"HostByAlertManager,omitempty"`
	// The ID of the alert rule.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The information about the application that is associated with the alert rule.
	MetricParam *SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam `json:"MetricParam,omitempty" xml:"MetricParam,omitempty" type:"Struct"`
	// The time ranges when the alert rule takes effect and when alert notifications are sent.
	Notice *SearchAlertRulesResponseBodyPageBeanAlertRulesNotice `json:"Notice,omitempty" xml:"Notice,omitempty" type:"Struct"`
	// The ID of the region to which the alert rule belongs.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The status of the alert rule. `RUNNING`: The alert rule is enabled. `STOPPED`: The alert rule is disabled.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the Application Real-Time Monitoring Service (ARMS) task that is associated with the alert rule.
	TaskId *int64 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The status of the task. This parameter is hidden from users.
	TaskStatus *string `json:"TaskStatus,omitempty" xml:"TaskStatus,omitempty"`
	// The name of the alert.
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The timestamp that shows when the alert rule was updated.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The ID of the user to which the alert rule belongs.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s SearchAlertRulesResponseBodyPageBeanAlertRules) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertRulesResponseBodyPageBeanAlertRules) GoString() string {
	return s.String()
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRules) SetAlarmContext(v *SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext) *SearchAlertRulesResponseBodyPageBeanAlertRules {
	s.AlarmContext = v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRules) SetAlertLevel(v string) *SearchAlertRulesResponseBodyPageBeanAlertRules {
	s.AlertLevel = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRules) SetAlertRule(v *SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule) *SearchAlertRulesResponseBodyPageBeanAlertRules {
	s.AlertRule = v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRules) SetAlertTitle(v string) *SearchAlertRulesResponseBodyPageBeanAlertRules {
	s.AlertTitle = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRules) SetAlertType(v int32) *SearchAlertRulesResponseBodyPageBeanAlertRules {
	s.AlertType = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRules) SetAlertVersion(v int32) *SearchAlertRulesResponseBodyPageBeanAlertRules {
	s.AlertVersion = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRules) SetAlertWays(v []*string) *SearchAlertRulesResponseBodyPageBeanAlertRules {
	s.AlertWays = v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRules) SetConfig(v string) *SearchAlertRulesResponseBodyPageBeanAlertRules {
	s.Config = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRules) SetContactGroupIdList(v string) *SearchAlertRulesResponseBodyPageBeanAlertRules {
	s.ContactGroupIdList = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRules) SetContactGroupIds(v string) *SearchAlertRulesResponseBodyPageBeanAlertRules {
	s.ContactGroupIds = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRules) SetCreateTime(v int64) *SearchAlertRulesResponseBodyPageBeanAlertRules {
	s.CreateTime = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRules) SetHostByAlertManager(v bool) *SearchAlertRulesResponseBodyPageBeanAlertRules {
	s.HostByAlertManager = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRules) SetId(v int64) *SearchAlertRulesResponseBodyPageBeanAlertRules {
	s.Id = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRules) SetMetricParam(v *SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam) *SearchAlertRulesResponseBodyPageBeanAlertRules {
	s.MetricParam = v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRules) SetNotice(v *SearchAlertRulesResponseBodyPageBeanAlertRulesNotice) *SearchAlertRulesResponseBodyPageBeanAlertRules {
	s.Notice = v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRules) SetRegionId(v string) *SearchAlertRulesResponseBodyPageBeanAlertRules {
	s.RegionId = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRules) SetResourceGroupId(v string) *SearchAlertRulesResponseBodyPageBeanAlertRules {
	s.ResourceGroupId = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRules) SetStatus(v string) *SearchAlertRulesResponseBodyPageBeanAlertRules {
	s.Status = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRules) SetTaskId(v int64) *SearchAlertRulesResponseBodyPageBeanAlertRules {
	s.TaskId = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRules) SetTaskStatus(v string) *SearchAlertRulesResponseBodyPageBeanAlertRules {
	s.TaskStatus = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRules) SetTitle(v string) *SearchAlertRulesResponseBodyPageBeanAlertRules {
	s.Title = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRules) SetUpdateTime(v int64) *SearchAlertRulesResponseBodyPageBeanAlertRules {
	s.UpdateTime = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRules) SetUserId(v string) *SearchAlertRulesResponseBodyPageBeanAlertRules {
	s.UserId = &v
	return s
}

type SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext struct {
	// The sub-title of the alert notification content.
	AlarmContentSubTitle *string `json:"AlarmContentSubTitle,omitempty" xml:"AlarmContentSubTitle,omitempty"`
	// The template of the alert notification.
	AlarmContentTemplate *string `json:"AlarmContentTemplate,omitempty" xml:"AlarmContentTemplate,omitempty"`
	// The content of the alert notification.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The sub-title of the alert notification.
	SubTitle *string `json:"SubTitle,omitempty" xml:"SubTitle,omitempty"`
}

func (s SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext) GoString() string {
	return s.String()
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext) SetAlarmContentSubTitle(v string) *SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext {
	s.AlarmContentSubTitle = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext) SetAlarmContentTemplate(v string) *SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext {
	s.AlarmContentTemplate = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext) SetContent(v string) *SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext {
	s.Content = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext) SetSubTitle(v string) *SearchAlertRulesResponseBodyPageBeanAlertRulesAlarmContext {
	s.SubTitle = &v
	return s
}

type SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule struct {
	// The logical operator between conditions. Valid values: `&`: AND. `|`: OR.
	Operator *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
	// The condition of the alert rule.
	Rules []*SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules `json:"Rules,omitempty" xml:"Rules,omitempty" type:"Repeated"`
}

func (s SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule) GoString() string {
	return s.String()
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule) SetOperator(v string) *SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule {
	s.Operator = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule) SetRules(v []*SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules) *SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRule {
	s.Rules = v
	return s
}

type SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules struct {
	// The aggregation logic of the metric data of the alert rule. Valid values:
	//
	// *   `AVG`: calculates the average value for each minute
	// *   `SUM`: calculates the total value for each minute
	// *   `MAX`: calculates the maximum value for each minute
	// *   `MIN`: calculates the minimum value for each minute
	Aggregates *string `json:"Aggregates,omitempty" xml:"Aggregates,omitempty"`
	// The displayed description of the alert metric.
	Alias *string `json:"Alias,omitempty" xml:"Alias,omitempty"`
	// The metric based on which alerts are triggered. For more information, see the "[Alert metrics](https://help.aliyun.com/document_detail/175825.html#h2-url-4)" section in this topic.
	Measure *string `json:"Measure,omitempty" xml:"Measure,omitempty"`
	// The time range when data is requested. Unit: minutes. For example, a value of 5 indicates that the alert rule applies to the data in the last 5 minutes.
	NValue *int32 `json:"NValue,omitempty" xml:"NValue,omitempty"`
	// The operation logic of the condition. Valid values:
	//
	// *   CURRENT_GTE: greater than or equal to
	// *   CURRENT_LTE: less than or equal to
	// *   PREVIOUS_UP: the increase percentage compared with the last period
	// *   PREVIOUS_DOWN: the decrease percentage compared with the last period
	// *   HOH_UP: the increase percentage compared with the last hour
	// *   HOH_DOWN: the decrease percentage compared with the last hour
	// *   DOD_UP: the increase percentage compared with the last day
	// *   DOD_DOWN: the decrease percentage compared with the last day
	Operator *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
	// The threshold of the condition.
	Value *float32 `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules) GoString() string {
	return s.String()
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules) SetAggregates(v string) *SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules {
	s.Aggregates = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules) SetAlias(v string) *SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules {
	s.Alias = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules) SetMeasure(v string) *SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules {
	s.Measure = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules) SetNValue(v int32) *SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules {
	s.NValue = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules) SetOperator(v string) *SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules {
	s.Operator = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules) SetValue(v float32) *SearchAlertRulesResponseBodyPageBeanAlertRulesAlertRuleRules {
	s.Value = &v
	return s
}

type SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam struct {
	// The ID of the application group that is associated with the alert rule. This parameter is applicable to Enterprise Distributed Application Service (EDAS) applications.
	AppGroupId *string `json:"AppGroupId,omitempty" xml:"AppGroupId,omitempty"`
	// The auto-increment ID of the ARMS application. You can ignore this ID.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The dimensions in the condition.
	Dimensions []*SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions `json:"Dimensions,omitempty" xml:"Dimensions,omitempty" type:"Repeated"`
	// The PID of the application that is associated with the alert rule.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The type of the metric. Valid values:
	//
	// *   `txn`: the number of API calls during application monitoring
	// *   `txn_type`: the types of API calls during application monitoring
	// *   `db`: database metrics
	// *   `jvm`: Java virtual machine (JVM) metrics
	// *   `host`: host metrics
	// *   `exception`: API call errors
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam) GoString() string {
	return s.String()
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam) SetAppGroupId(v string) *SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam {
	s.AppGroupId = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam) SetAppId(v string) *SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam {
	s.AppId = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam) SetDimensions(v []*SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions) *SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam {
	s.Dimensions = v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam) SetPid(v string) *SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam {
	s.Pid = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam) SetType(v string) *SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParam {
	s.Type = &v
	return s
}

type SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions struct {
	// The key of the dimension. Valid values:
	//
	// *   `rpc`: the name of the API
	// *   `rpcType`: the type of the API call, such as HTTP or DUBBO
	// *   `endpoint`: the name of the database
	// *   `rootIp`: the IP address of the host
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The type of the dimension. Valid values:
	//
	// *   `STATIC`: checks only the value of this dimension. In this case, you must set the **dimensions.value** parameter.
	// *   `ALL`: checks the values of all dimensions. The metrics of all API calls are checked. If an API call triggers an alert, the name of the API is displayed in the alert notification. In this case, you do not need to set the **dimensions.value** parameter.
	// *   `DISABLE`: aggregates the values of all dimensions. In this case, you do not need to set the **dimensions.value** parameter.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value of the dimension.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions) GoString() string {
	return s.String()
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions) SetKey(v string) *SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions {
	s.Key = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions) SetType(v string) *SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions {
	s.Type = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions) SetValue(v string) *SearchAlertRulesResponseBodyPageBeanAlertRulesMetricParamDimensions {
	s.Value = &v
	return s
}

type SearchAlertRulesResponseBodyPageBeanAlertRulesNotice struct {
	// The end of the time range when the alert rule takes effect within 24 hours per day. This value is a UNIX timestamp. The year, month, and day that are indicated by the timestamp are not displayed in this value. Only the hour, minute, and second are displayed.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The end of the time range when alert notifications are sent based on the alert rule within 24 hours per day. This value is a UNIX timestamp. The year, month, and day that are indicated by the timestamp are not displayed in this value. Only the hour, minute, and second are displayed.
	NoticeEndTime *int64 `json:"NoticeEndTime,omitempty" xml:"NoticeEndTime,omitempty"`
	// The beginning of the time range when alert notifications are sent based on the alert rule within 24 hours per day. This value is a UNIX timestamp. The year, month, and day that are indicated by the timestamp are not displayed in this value. Only the hour, minute, and second are displayed.
	NoticeStartTime *int64 `json:"NoticeStartTime,omitempty" xml:"NoticeStartTime,omitempty"`
	// The beginning of the time range when the alert rule takes effect within 24 hours per day. This value is a UNIX timestamp. The year, month, and day that are indicated by the timestamp are not displayed in this value. Only the hour, minute, and second are displayed.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s SearchAlertRulesResponseBodyPageBeanAlertRulesNotice) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertRulesResponseBodyPageBeanAlertRulesNotice) GoString() string {
	return s.String()
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesNotice) SetEndTime(v int64) *SearchAlertRulesResponseBodyPageBeanAlertRulesNotice {
	s.EndTime = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesNotice) SetNoticeEndTime(v int64) *SearchAlertRulesResponseBodyPageBeanAlertRulesNotice {
	s.NoticeEndTime = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesNotice) SetNoticeStartTime(v int64) *SearchAlertRulesResponseBodyPageBeanAlertRulesNotice {
	s.NoticeStartTime = &v
	return s
}

func (s *SearchAlertRulesResponseBodyPageBeanAlertRulesNotice) SetStartTime(v int64) *SearchAlertRulesResponseBodyPageBeanAlertRulesNotice {
	s.StartTime = &v
	return s
}

type SearchAlertRulesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SearchAlertRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchAlertRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchAlertRulesResponse) GoString() string {
	return s.String()
}

func (s *SearchAlertRulesResponse) SetHeaders(v map[string]*string) *SearchAlertRulesResponse {
	s.Headers = v
	return s
}

func (s *SearchAlertRulesResponse) SetStatusCode(v int32) *SearchAlertRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *SearchAlertRulesResponse) SetBody(v *SearchAlertRulesResponseBody) *SearchAlertRulesResponse {
	s.Body = v
	return s
}

type SearchEventsRequest struct {
	// The ID of the alert rule. You can call the SearchAlertRules operation and view the `Id` parameter in the response. For more information, see [SearchAlertRules](~~175825~~).
	AlertId *int64 `json:"AlertId,omitempty" xml:"AlertId,omitempty"`
	// The type of the alert rule. Valid values:
	//
	// *   `1`: custom alert rules to monitor drill-down data sets
	// *   `3`: custom alert rules to monitor tiled data sets
	// *   `4`: alert rules to monitor the frontend, including the default frontend alert rules
	// *   `5`: alert rules to monitor applications, including the default application alert rules
	// *   `6`: the default frontend alert rules
	// *   `7`: the default application alert rules
	// *   `8`: Tracing Analysis alert rules
	// *   `101`: Prometheus alert rules
	AlertType *int32 `json:"AlertType,omitempty" xml:"AlertType,omitempty"`
	// The type of the application that is associated with the alert rule. Valid values:
	//
	// *   `TRACE`: application monitoring
	// *   `RETCODE`: frontend monitoring
	AppType *string `json:"AppType,omitempty" xml:"AppType,omitempty"`
	// The number of the page to return. Default value: `1`.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The end of the time range to query. Specify a UNIX timestamp of the LONG data type, in milliseconds. The default value is the current time.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// Specifies whether the alert event is triggered. If you do not set this parameter, all alert events are queried. Valid values:
	//
	// *   `1`: The event is triggered.
	// *   `0`: The event is not triggered.
	IsTrigger *int32 `json:"IsTrigger,omitempty" xml:"IsTrigger,omitempty"`
	// The number of entries to return on each page. Default value: `10`.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The process identifier (PID) of the application that is associated with the alert rule.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The beginning of the time range to query. Specify a UNIX timestamp of the LONG data type, in milliseconds. The default value is 10 minutes before the current time.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s SearchEventsRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchEventsRequest) GoString() string {
	return s.String()
}

func (s *SearchEventsRequest) SetAlertId(v int64) *SearchEventsRequest {
	s.AlertId = &v
	return s
}

func (s *SearchEventsRequest) SetAlertType(v int32) *SearchEventsRequest {
	s.AlertType = &v
	return s
}

func (s *SearchEventsRequest) SetAppType(v string) *SearchEventsRequest {
	s.AppType = &v
	return s
}

func (s *SearchEventsRequest) SetCurrentPage(v int32) *SearchEventsRequest {
	s.CurrentPage = &v
	return s
}

func (s *SearchEventsRequest) SetEndTime(v int64) *SearchEventsRequest {
	s.EndTime = &v
	return s
}

func (s *SearchEventsRequest) SetIsTrigger(v int32) *SearchEventsRequest {
	s.IsTrigger = &v
	return s
}

func (s *SearchEventsRequest) SetPageSize(v int32) *SearchEventsRequest {
	s.PageSize = &v
	return s
}

func (s *SearchEventsRequest) SetPid(v string) *SearchEventsRequest {
	s.Pid = &v
	return s
}

func (s *SearchEventsRequest) SetRegionId(v string) *SearchEventsRequest {
	s.RegionId = &v
	return s
}

func (s *SearchEventsRequest) SetStartTime(v int64) *SearchEventsRequest {
	s.StartTime = &v
	return s
}

type SearchEventsResponseBody struct {
	// Specifies whether the alert event is triggered. If you do not set this parameter, all alert events are queried. Valid values:
	//
	// *   `1`: The event is triggered.
	// *   `0`: The event is not triggered.
	IsTrigger *int32 `json:"IsTrigger,omitempty" xml:"IsTrigger,omitempty"`
	// The struct returned.
	PageBean *SearchEventsResponseBodyPageBean `json:"PageBean,omitempty" xml:"PageBean,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SearchEventsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SearchEventsResponseBody) GoString() string {
	return s.String()
}

func (s *SearchEventsResponseBody) SetIsTrigger(v int32) *SearchEventsResponseBody {
	s.IsTrigger = &v
	return s
}

func (s *SearchEventsResponseBody) SetPageBean(v *SearchEventsResponseBodyPageBean) *SearchEventsResponseBody {
	s.PageBean = v
	return s
}

func (s *SearchEventsResponseBody) SetRequestId(v string) *SearchEventsResponseBody {
	s.RequestId = &v
	return s
}

type SearchEventsResponseBodyPageBean struct {
	// The information about the alert events.
	Event []*SearchEventsResponseBodyPageBeanEvent `json:"Event,omitempty" xml:"Event,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s SearchEventsResponseBodyPageBean) String() string {
	return tea.Prettify(s)
}

func (s SearchEventsResponseBodyPageBean) GoString() string {
	return s.String()
}

func (s *SearchEventsResponseBodyPageBean) SetEvent(v []*SearchEventsResponseBodyPageBeanEvent) *SearchEventsResponseBodyPageBean {
	s.Event = v
	return s
}

func (s *SearchEventsResponseBodyPageBean) SetPageNumber(v int32) *SearchEventsResponseBodyPageBean {
	s.PageNumber = &v
	return s
}

func (s *SearchEventsResponseBodyPageBean) SetPageSize(v int32) *SearchEventsResponseBodyPageBean {
	s.PageSize = &v
	return s
}

func (s *SearchEventsResponseBodyPageBean) SetTotalCount(v int32) *SearchEventsResponseBodyPageBean {
	s.TotalCount = &v
	return s
}

type SearchEventsResponseBodyPageBeanEvent struct {
	// The ID of the alert rule that is associated with the event.
	AlertId *int64 `json:"AlertId,omitempty" xml:"AlertId,omitempty"`
	// The name of the alert rule that is associated with the event.
	AlertName *string `json:"AlertName,omitempty" xml:"AlertName,omitempty"`
	// The condition of the alert rule.
	AlertRule *string `json:"AlertRule,omitempty" xml:"AlertRule,omitempty"`
	// The type of the alert rule. This parameter is not returned. Valid values:
	//
	// *   `1`: custom alert rules to monitor drill-down data sets
	// *   `3`: custom alert rules to monitor tiled data sets
	// *   `4`: alert rules to monitor the frontend, including the default frontend alert rules
	// *   `5`: alert rules to monitor applications, including the default application alert rules
	// *   `6`: the default frontend alert rules
	// *   `7`: the default application alert rules
	// *   `8`: Tracing Analysis alert rules
	// *   `101`: Prometheus alert rules
	AlertType *int32 `json:"AlertType,omitempty" xml:"AlertType,omitempty"`
	// The severity of the event.
	EventLevel *string `json:"EventLevel,omitempty" xml:"EventLevel,omitempty"`
	// The timestamp when the event occurred.
	EventTime *int64 `json:"EventTime,omitempty" xml:"EventTime,omitempty"`
	// The ID of the event record.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The list of event URLs.
	Links []*string `json:"Links,omitempty" xml:"Links,omitempty" type:"Repeated"`
	// The event content. The parameter value is a JSON string. Each key indicates a dimension and each value indicates the alert content in the dimension.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
}

func (s SearchEventsResponseBodyPageBeanEvent) String() string {
	return tea.Prettify(s)
}

func (s SearchEventsResponseBodyPageBeanEvent) GoString() string {
	return s.String()
}

func (s *SearchEventsResponseBodyPageBeanEvent) SetAlertId(v int64) *SearchEventsResponseBodyPageBeanEvent {
	s.AlertId = &v
	return s
}

func (s *SearchEventsResponseBodyPageBeanEvent) SetAlertName(v string) *SearchEventsResponseBodyPageBeanEvent {
	s.AlertName = &v
	return s
}

func (s *SearchEventsResponseBodyPageBeanEvent) SetAlertRule(v string) *SearchEventsResponseBodyPageBeanEvent {
	s.AlertRule = &v
	return s
}

func (s *SearchEventsResponseBodyPageBeanEvent) SetAlertType(v int32) *SearchEventsResponseBodyPageBeanEvent {
	s.AlertType = &v
	return s
}

func (s *SearchEventsResponseBodyPageBeanEvent) SetEventLevel(v string) *SearchEventsResponseBodyPageBeanEvent {
	s.EventLevel = &v
	return s
}

func (s *SearchEventsResponseBodyPageBeanEvent) SetEventTime(v int64) *SearchEventsResponseBodyPageBeanEvent {
	s.EventTime = &v
	return s
}

func (s *SearchEventsResponseBodyPageBeanEvent) SetId(v int64) *SearchEventsResponseBodyPageBeanEvent {
	s.Id = &v
	return s
}

func (s *SearchEventsResponseBodyPageBeanEvent) SetLinks(v []*string) *SearchEventsResponseBodyPageBeanEvent {
	s.Links = v
	return s
}

func (s *SearchEventsResponseBodyPageBeanEvent) SetMessage(v string) *SearchEventsResponseBodyPageBeanEvent {
	s.Message = &v
	return s
}

type SearchEventsResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SearchEventsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchEventsResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchEventsResponse) GoString() string {
	return s.String()
}

func (s *SearchEventsResponse) SetHeaders(v map[string]*string) *SearchEventsResponse {
	s.Headers = v
	return s
}

func (s *SearchEventsResponse) SetStatusCode(v int32) *SearchEventsResponse {
	s.StatusCode = &v
	return s
}

func (s *SearchEventsResponse) SetBody(v *SearchEventsResponseBody) *SearchEventsResponse {
	s.Body = v
	return s
}

type SearchRetcodeAppByPageRequest struct {
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group. You can obtain the resource group ID in the **Resource Management** console.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of the application.
	//
	// Log on to the **ARMS console**. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of an application. The URL in the browser address bar contains the pid of this application in the format of `pid=xxx`. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is `xxx%4074xxx`, you must replace **%40** with the at sign (@). The actual PID is `xxx@74xxx`.
	RetcodeAppId *string `json:"RetcodeAppId,omitempty" xml:"RetcodeAppId,omitempty"`
	// The name of the application that is monitored by Browser Monitoring.
	RetcodeAppName *string `json:"RetcodeAppName,omitempty" xml:"RetcodeAppName,omitempty"`
	// The tags.
	Tags []*SearchRetcodeAppByPageRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s SearchRetcodeAppByPageRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchRetcodeAppByPageRequest) GoString() string {
	return s.String()
}

func (s *SearchRetcodeAppByPageRequest) SetPageNumber(v int32) *SearchRetcodeAppByPageRequest {
	s.PageNumber = &v
	return s
}

func (s *SearchRetcodeAppByPageRequest) SetPageSize(v int32) *SearchRetcodeAppByPageRequest {
	s.PageSize = &v
	return s
}

func (s *SearchRetcodeAppByPageRequest) SetRegionId(v string) *SearchRetcodeAppByPageRequest {
	s.RegionId = &v
	return s
}

func (s *SearchRetcodeAppByPageRequest) SetResourceGroupId(v string) *SearchRetcodeAppByPageRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *SearchRetcodeAppByPageRequest) SetRetcodeAppId(v string) *SearchRetcodeAppByPageRequest {
	s.RetcodeAppId = &v
	return s
}

func (s *SearchRetcodeAppByPageRequest) SetRetcodeAppName(v string) *SearchRetcodeAppByPageRequest {
	s.RetcodeAppName = &v
	return s
}

func (s *SearchRetcodeAppByPageRequest) SetTags(v []*SearchRetcodeAppByPageRequestTags) *SearchRetcodeAppByPageRequest {
	s.Tags = v
	return s
}

type SearchRetcodeAppByPageRequestTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s SearchRetcodeAppByPageRequestTags) String() string {
	return tea.Prettify(s)
}

func (s SearchRetcodeAppByPageRequestTags) GoString() string {
	return s.String()
}

func (s *SearchRetcodeAppByPageRequestTags) SetKey(v string) *SearchRetcodeAppByPageRequestTags {
	s.Key = &v
	return s
}

func (s *SearchRetcodeAppByPageRequestTags) SetValue(v string) *SearchRetcodeAppByPageRequestTags {
	s.Value = &v
	return s
}

type SearchRetcodeAppByPageResponseBody struct {
	// The returned page information.
	PageBean *SearchRetcodeAppByPageResponseBodyPageBean `json:"PageBean,omitempty" xml:"PageBean,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SearchRetcodeAppByPageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SearchRetcodeAppByPageResponseBody) GoString() string {
	return s.String()
}

func (s *SearchRetcodeAppByPageResponseBody) SetPageBean(v *SearchRetcodeAppByPageResponseBodyPageBean) *SearchRetcodeAppByPageResponseBody {
	s.PageBean = v
	return s
}

func (s *SearchRetcodeAppByPageResponseBody) SetRequestId(v string) *SearchRetcodeAppByPageResponseBody {
	s.RequestId = &v
	return s
}

type SearchRetcodeAppByPageResponseBodyPageBean struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The Browser Monitoring tasks that are returned.
	RetcodeApps []*SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps `json:"RetcodeApps,omitempty" xml:"RetcodeApps,omitempty" type:"Repeated"`
	// The total number of returned entries.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s SearchRetcodeAppByPageResponseBodyPageBean) String() string {
	return tea.Prettify(s)
}

func (s SearchRetcodeAppByPageResponseBodyPageBean) GoString() string {
	return s.String()
}

func (s *SearchRetcodeAppByPageResponseBodyPageBean) SetPageNumber(v int32) *SearchRetcodeAppByPageResponseBodyPageBean {
	s.PageNumber = &v
	return s
}

func (s *SearchRetcodeAppByPageResponseBodyPageBean) SetPageSize(v int32) *SearchRetcodeAppByPageResponseBodyPageBean {
	s.PageSize = &v
	return s
}

func (s *SearchRetcodeAppByPageResponseBodyPageBean) SetRetcodeApps(v []*SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps) *SearchRetcodeAppByPageResponseBodyPageBean {
	s.RetcodeApps = v
	return s
}

func (s *SearchRetcodeAppByPageResponseBodyPageBean) SetTotalCount(v int32) *SearchRetcodeAppByPageResponseBodyPageBean {
	s.TotalCount = &v
	return s
}

type SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps struct {
	// The ID of the application. The parameter is an auto-increment parameter.
	AppId *int64 `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The time when the task was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The alias of the application.
	NickName *string `json:"NickName,omitempty" xml:"NickName,omitempty"`
	// The PID of the application.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The type of the application. Valid values:
	//
	// *   `web`: web application
	// *   `weex`: Weex mobile app
	// *   `mini_dd`: DingTalk mini program
	// *   `mini_alipay`: Alipay mini program
	// *   `mini_wx`: WeChat mini program
	// *   `mini_common`: mini program on other platforms
	RetcodeAppType *string `json:"RetcodeAppType,omitempty" xml:"RetcodeAppType,omitempty"`
	// The tags.
	Tags []*SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The type of the monitoring task. Valid values:
	//
	// *   `TRACE`: Application Monitoring
	// *   `RETCODE`: Browser Monitoring
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The time when the task was updated.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps) String() string {
	return tea.Prettify(s)
}

func (s SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps) GoString() string {
	return s.String()
}

func (s *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps) SetAppId(v int64) *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps {
	s.AppId = &v
	return s
}

func (s *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps) SetAppName(v string) *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps {
	s.AppName = &v
	return s
}

func (s *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps) SetCreateTime(v int64) *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps {
	s.CreateTime = &v
	return s
}

func (s *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps) SetNickName(v string) *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps {
	s.NickName = &v
	return s
}

func (s *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps) SetPid(v string) *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps {
	s.Pid = &v
	return s
}

func (s *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps) SetRegionId(v string) *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps {
	s.RegionId = &v
	return s
}

func (s *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps) SetResourceGroupId(v string) *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps {
	s.ResourceGroupId = &v
	return s
}

func (s *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps) SetRetcodeAppType(v string) *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps {
	s.RetcodeAppType = &v
	return s
}

func (s *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps) SetTags(v []*SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags) *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps {
	s.Tags = v
	return s
}

func (s *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps) SetType(v string) *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps {
	s.Type = &v
	return s
}

func (s *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps) SetUpdateTime(v int64) *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps {
	s.UpdateTime = &v
	return s
}

func (s *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps) SetUserId(v string) *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeApps {
	s.UserId = &v
	return s
}

type SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags) String() string {
	return tea.Prettify(s)
}

func (s SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags) GoString() string {
	return s.String()
}

func (s *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags) SetKey(v string) *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags {
	s.Key = &v
	return s
}

func (s *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags) SetValue(v string) *SearchRetcodeAppByPageResponseBodyPageBeanRetcodeAppsTags {
	s.Value = &v
	return s
}

type SearchRetcodeAppByPageResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SearchRetcodeAppByPageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchRetcodeAppByPageResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchRetcodeAppByPageResponse) GoString() string {
	return s.String()
}

func (s *SearchRetcodeAppByPageResponse) SetHeaders(v map[string]*string) *SearchRetcodeAppByPageResponse {
	s.Headers = v
	return s
}

func (s *SearchRetcodeAppByPageResponse) SetStatusCode(v int32) *SearchRetcodeAppByPageResponse {
	s.StatusCode = &v
	return s
}

func (s *SearchRetcodeAppByPageResponse) SetBody(v *SearchRetcodeAppByPageResponseBody) *SearchRetcodeAppByPageResponse {
	s.Body = v
	return s
}

type SearchTraceAppByNameRequest struct {
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The list of tags.
	Tags []*SearchTraceAppByNameRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The name of the application.
	//
	// > If you do not specify this parameter, all application monitoring tasks in the specified region are queried.
	TraceAppName *string `json:"TraceAppName,omitempty" xml:"TraceAppName,omitempty"`
}

func (s SearchTraceAppByNameRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchTraceAppByNameRequest) GoString() string {
	return s.String()
}

func (s *SearchTraceAppByNameRequest) SetRegionId(v string) *SearchTraceAppByNameRequest {
	s.RegionId = &v
	return s
}

func (s *SearchTraceAppByNameRequest) SetTags(v []*SearchTraceAppByNameRequestTags) *SearchTraceAppByNameRequest {
	s.Tags = v
	return s
}

func (s *SearchTraceAppByNameRequest) SetTraceAppName(v string) *SearchTraceAppByNameRequest {
	s.TraceAppName = &v
	return s
}

type SearchTraceAppByNameRequestTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s SearchTraceAppByNameRequestTags) String() string {
	return tea.Prettify(s)
}

func (s SearchTraceAppByNameRequestTags) GoString() string {
	return s.String()
}

func (s *SearchTraceAppByNameRequestTags) SetKey(v string) *SearchTraceAppByNameRequestTags {
	s.Key = &v
	return s
}

func (s *SearchTraceAppByNameRequestTags) SetValue(v string) *SearchTraceAppByNameRequestTags {
	s.Value = &v
	return s
}

type SearchTraceAppByNameResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the monitoring task.
	TraceApps []*SearchTraceAppByNameResponseBodyTraceApps `json:"TraceApps,omitempty" xml:"TraceApps,omitempty" type:"Repeated"`
}

func (s SearchTraceAppByNameResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SearchTraceAppByNameResponseBody) GoString() string {
	return s.String()
}

func (s *SearchTraceAppByNameResponseBody) SetRequestId(v string) *SearchTraceAppByNameResponseBody {
	s.RequestId = &v
	return s
}

func (s *SearchTraceAppByNameResponseBody) SetTraceApps(v []*SearchTraceAppByNameResponseBodyTraceApps) *SearchTraceAppByNameResponseBody {
	s.TraceApps = v
	return s
}

type SearchTraceAppByNameResponseBodyTraceApps struct {
	// The application ID.
	AppId *int64 `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The timestamp generated when the task was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The aliases of the application.
	Labels []*string `json:"Labels,omitempty" xml:"Labels,omitempty" type:"Repeated"`
	// The process identifier (PID) of the application.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Indicates whether the application is displayed in the Application Real-Time Monitoring Service (ARMS) console. Valid values:
	//
	// *   `true`: yes
	// *   `false`: no
	Show *bool `json:"Show,omitempty" xml:"Show,omitempty"`
	// A list of tags.
	Tags []*SearchTraceAppByNameResponseBodyTraceAppsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The type of the monitoring task. Valid values:
	//
	// *   `TRACE`: Application Monitoring
	// *   `RETCODE`: Browser Monitoring
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The timestamp generated when the task information was updated.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The user ID.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s SearchTraceAppByNameResponseBodyTraceApps) String() string {
	return tea.Prettify(s)
}

func (s SearchTraceAppByNameResponseBodyTraceApps) GoString() string {
	return s.String()
}

func (s *SearchTraceAppByNameResponseBodyTraceApps) SetAppId(v int64) *SearchTraceAppByNameResponseBodyTraceApps {
	s.AppId = &v
	return s
}

func (s *SearchTraceAppByNameResponseBodyTraceApps) SetAppName(v string) *SearchTraceAppByNameResponseBodyTraceApps {
	s.AppName = &v
	return s
}

func (s *SearchTraceAppByNameResponseBodyTraceApps) SetCreateTime(v int64) *SearchTraceAppByNameResponseBodyTraceApps {
	s.CreateTime = &v
	return s
}

func (s *SearchTraceAppByNameResponseBodyTraceApps) SetLabels(v []*string) *SearchTraceAppByNameResponseBodyTraceApps {
	s.Labels = v
	return s
}

func (s *SearchTraceAppByNameResponseBodyTraceApps) SetPid(v string) *SearchTraceAppByNameResponseBodyTraceApps {
	s.Pid = &v
	return s
}

func (s *SearchTraceAppByNameResponseBodyTraceApps) SetRegionId(v string) *SearchTraceAppByNameResponseBodyTraceApps {
	s.RegionId = &v
	return s
}

func (s *SearchTraceAppByNameResponseBodyTraceApps) SetResourceGroupId(v string) *SearchTraceAppByNameResponseBodyTraceApps {
	s.ResourceGroupId = &v
	return s
}

func (s *SearchTraceAppByNameResponseBodyTraceApps) SetShow(v bool) *SearchTraceAppByNameResponseBodyTraceApps {
	s.Show = &v
	return s
}

func (s *SearchTraceAppByNameResponseBodyTraceApps) SetTags(v []*SearchTraceAppByNameResponseBodyTraceAppsTags) *SearchTraceAppByNameResponseBodyTraceApps {
	s.Tags = v
	return s
}

func (s *SearchTraceAppByNameResponseBodyTraceApps) SetType(v string) *SearchTraceAppByNameResponseBodyTraceApps {
	s.Type = &v
	return s
}

func (s *SearchTraceAppByNameResponseBodyTraceApps) SetUpdateTime(v int64) *SearchTraceAppByNameResponseBodyTraceApps {
	s.UpdateTime = &v
	return s
}

func (s *SearchTraceAppByNameResponseBodyTraceApps) SetUserId(v string) *SearchTraceAppByNameResponseBodyTraceApps {
	s.UserId = &v
	return s
}

type SearchTraceAppByNameResponseBodyTraceAppsTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s SearchTraceAppByNameResponseBodyTraceAppsTags) String() string {
	return tea.Prettify(s)
}

func (s SearchTraceAppByNameResponseBodyTraceAppsTags) GoString() string {
	return s.String()
}

func (s *SearchTraceAppByNameResponseBodyTraceAppsTags) SetKey(v string) *SearchTraceAppByNameResponseBodyTraceAppsTags {
	s.Key = &v
	return s
}

func (s *SearchTraceAppByNameResponseBodyTraceAppsTags) SetValue(v string) *SearchTraceAppByNameResponseBodyTraceAppsTags {
	s.Value = &v
	return s
}

type SearchTraceAppByNameResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SearchTraceAppByNameResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchTraceAppByNameResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchTraceAppByNameResponse) GoString() string {
	return s.String()
}

func (s *SearchTraceAppByNameResponse) SetHeaders(v map[string]*string) *SearchTraceAppByNameResponse {
	s.Headers = v
	return s
}

func (s *SearchTraceAppByNameResponse) SetStatusCode(v int32) *SearchTraceAppByNameResponse {
	s.StatusCode = &v
	return s
}

func (s *SearchTraceAppByNameResponse) SetBody(v *SearchTraceAppByNameResponseBody) *SearchTraceAppByNameResponse {
	s.Body = v
	return s
}

type SearchTraceAppByPageRequest struct {
	// The number of the page to return. Default value: `1`.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: `10`.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource group ID.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// A list of tags.
	Tags []*SearchTraceAppByPageRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The name of the application.
	TraceAppName *string `json:"TraceAppName,omitempty" xml:"TraceAppName,omitempty"`
}

func (s SearchTraceAppByPageRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchTraceAppByPageRequest) GoString() string {
	return s.String()
}

func (s *SearchTraceAppByPageRequest) SetPageNumber(v int32) *SearchTraceAppByPageRequest {
	s.PageNumber = &v
	return s
}

func (s *SearchTraceAppByPageRequest) SetPageSize(v int32) *SearchTraceAppByPageRequest {
	s.PageSize = &v
	return s
}

func (s *SearchTraceAppByPageRequest) SetRegionId(v string) *SearchTraceAppByPageRequest {
	s.RegionId = &v
	return s
}

func (s *SearchTraceAppByPageRequest) SetResourceGroupId(v string) *SearchTraceAppByPageRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *SearchTraceAppByPageRequest) SetTags(v []*SearchTraceAppByPageRequestTags) *SearchTraceAppByPageRequest {
	s.Tags = v
	return s
}

func (s *SearchTraceAppByPageRequest) SetTraceAppName(v string) *SearchTraceAppByPageRequest {
	s.TraceAppName = &v
	return s
}

type SearchTraceAppByPageRequestTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s SearchTraceAppByPageRequestTags) String() string {
	return tea.Prettify(s)
}

func (s SearchTraceAppByPageRequestTags) GoString() string {
	return s.String()
}

func (s *SearchTraceAppByPageRequestTags) SetKey(v string) *SearchTraceAppByPageRequestTags {
	s.Key = &v
	return s
}

func (s *SearchTraceAppByPageRequestTags) SetValue(v string) *SearchTraceAppByPageRequestTags {
	s.Value = &v
	return s
}

type SearchTraceAppByPageResponseBody struct {
	// The information about the array object.
	PageBean *SearchTraceAppByPageResponseBodyPageBean `json:"PageBean,omitempty" xml:"PageBean,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SearchTraceAppByPageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SearchTraceAppByPageResponseBody) GoString() string {
	return s.String()
}

func (s *SearchTraceAppByPageResponseBody) SetPageBean(v *SearchTraceAppByPageResponseBodyPageBean) *SearchTraceAppByPageResponseBody {
	s.PageBean = v
	return s
}

func (s *SearchTraceAppByPageResponseBody) SetRequestId(v string) *SearchTraceAppByPageResponseBody {
	s.RequestId = &v
	return s
}

type SearchTraceAppByPageResponseBodyPageBean struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The information about the monitoring task.
	TraceApps []*SearchTraceAppByPageResponseBodyPageBeanTraceApps `json:"TraceApps,omitempty" xml:"TraceApps,omitempty" type:"Repeated"`
}

func (s SearchTraceAppByPageResponseBodyPageBean) String() string {
	return tea.Prettify(s)
}

func (s SearchTraceAppByPageResponseBodyPageBean) GoString() string {
	return s.String()
}

func (s *SearchTraceAppByPageResponseBodyPageBean) SetPageNumber(v int32) *SearchTraceAppByPageResponseBodyPageBean {
	s.PageNumber = &v
	return s
}

func (s *SearchTraceAppByPageResponseBodyPageBean) SetPageSize(v int32) *SearchTraceAppByPageResponseBodyPageBean {
	s.PageSize = &v
	return s
}

func (s *SearchTraceAppByPageResponseBodyPageBean) SetTotalCount(v int32) *SearchTraceAppByPageResponseBodyPageBean {
	s.TotalCount = &v
	return s
}

func (s *SearchTraceAppByPageResponseBodyPageBean) SetTraceApps(v []*SearchTraceAppByPageResponseBodyPageBeanTraceApps) *SearchTraceAppByPageResponseBodyPageBean {
	s.TraceApps = v
	return s
}

type SearchTraceAppByPageResponseBodyPageBeanTraceApps struct {
	// The application ID.
	AppId *int64 `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The timestamp generated when the task was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The aliases of the application.
	Labels []*string `json:"Labels,omitempty" xml:"Labels,omitempty" type:"Repeated"`
	// The process identifier (PID) of the application.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource group ID.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Indicates whether the application is displayed in the Application Real-Time Monitoring Service (ARMS) console. Valid values:
	//
	// *   `true`: yes
	// *   `false`: no
	Show *bool `json:"Show,omitempty" xml:"Show,omitempty"`
	// A list of tags.
	Tags []*SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The type of the monitoring task. Valid values:
	//
	// *   `TRACE`: Application Monitoring
	// *   `RETCODE`: Browser Monitoring
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The timestamp generated when the task information was updated.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The user ID.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s SearchTraceAppByPageResponseBodyPageBeanTraceApps) String() string {
	return tea.Prettify(s)
}

func (s SearchTraceAppByPageResponseBodyPageBeanTraceApps) GoString() string {
	return s.String()
}

func (s *SearchTraceAppByPageResponseBodyPageBeanTraceApps) SetAppId(v int64) *SearchTraceAppByPageResponseBodyPageBeanTraceApps {
	s.AppId = &v
	return s
}

func (s *SearchTraceAppByPageResponseBodyPageBeanTraceApps) SetAppName(v string) *SearchTraceAppByPageResponseBodyPageBeanTraceApps {
	s.AppName = &v
	return s
}

func (s *SearchTraceAppByPageResponseBodyPageBeanTraceApps) SetCreateTime(v int64) *SearchTraceAppByPageResponseBodyPageBeanTraceApps {
	s.CreateTime = &v
	return s
}

func (s *SearchTraceAppByPageResponseBodyPageBeanTraceApps) SetLabels(v []*string) *SearchTraceAppByPageResponseBodyPageBeanTraceApps {
	s.Labels = v
	return s
}

func (s *SearchTraceAppByPageResponseBodyPageBeanTraceApps) SetPid(v string) *SearchTraceAppByPageResponseBodyPageBeanTraceApps {
	s.Pid = &v
	return s
}

func (s *SearchTraceAppByPageResponseBodyPageBeanTraceApps) SetRegionId(v string) *SearchTraceAppByPageResponseBodyPageBeanTraceApps {
	s.RegionId = &v
	return s
}

func (s *SearchTraceAppByPageResponseBodyPageBeanTraceApps) SetResourceGroupId(v string) *SearchTraceAppByPageResponseBodyPageBeanTraceApps {
	s.ResourceGroupId = &v
	return s
}

func (s *SearchTraceAppByPageResponseBodyPageBeanTraceApps) SetShow(v bool) *SearchTraceAppByPageResponseBodyPageBeanTraceApps {
	s.Show = &v
	return s
}

func (s *SearchTraceAppByPageResponseBodyPageBeanTraceApps) SetTags(v []*SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags) *SearchTraceAppByPageResponseBodyPageBeanTraceApps {
	s.Tags = v
	return s
}

func (s *SearchTraceAppByPageResponseBodyPageBeanTraceApps) SetType(v string) *SearchTraceAppByPageResponseBodyPageBeanTraceApps {
	s.Type = &v
	return s
}

func (s *SearchTraceAppByPageResponseBodyPageBeanTraceApps) SetUpdateTime(v int64) *SearchTraceAppByPageResponseBodyPageBeanTraceApps {
	s.UpdateTime = &v
	return s
}

func (s *SearchTraceAppByPageResponseBodyPageBeanTraceApps) SetUserId(v string) *SearchTraceAppByPageResponseBodyPageBeanTraceApps {
	s.UserId = &v
	return s
}

type SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags) String() string {
	return tea.Prettify(s)
}

func (s SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags) GoString() string {
	return s.String()
}

func (s *SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags) SetKey(v string) *SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags {
	s.Key = &v
	return s
}

func (s *SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags) SetValue(v string) *SearchTraceAppByPageResponseBodyPageBeanTraceAppsTags {
	s.Value = &v
	return s
}

type SearchTraceAppByPageResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SearchTraceAppByPageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchTraceAppByPageResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchTraceAppByPageResponse) GoString() string {
	return s.String()
}

func (s *SearchTraceAppByPageResponse) SetHeaders(v map[string]*string) *SearchTraceAppByPageResponse {
	s.Headers = v
	return s
}

func (s *SearchTraceAppByPageResponse) SetStatusCode(v int32) *SearchTraceAppByPageResponse {
	s.StatusCode = &v
	return s
}

func (s *SearchTraceAppByPageResponse) SetBody(v *SearchTraceAppByPageResponseBody) *SearchTraceAppByPageResponse {
	s.Body = v
	return s
}

type SearchTracesRequest struct {
	// The end of the time range to query. Unit: milliseconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The filter conditions.
	ExclusionFilters []*SearchTracesRequestExclusionFilters `json:"ExclusionFilters,omitempty" xml:"ExclusionFilters,omitempty" type:"Repeated"`
	// The minimum amount of time consumed by traces. Unit: milliseconds.
	MinDuration *int64 `json:"MinDuration,omitempty" xml:"MinDuration,omitempty"`
	// The name of the traced span.
	OperationName *string `json:"OperationName,omitempty" xml:"OperationName,omitempty"`
	// The application ID.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Specifies whether to sort the query results in chronological order or reverse chronological order. Default value: `false`.
	//
	// *   `true`: sorts the query results in reverse chronological order.
	// *   `false`: sorts the query results in chronological order.
	Reverse *bool `json:"Reverse,omitempty" xml:"Reverse,omitempty"`
	// The IP address of the host where the application resides.
	ServiceIp *string `json:"ServiceIp,omitempty" xml:"ServiceIp,omitempty"`
	// The name of the application.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The beginning of the time range to query. Unit: milliseconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The list of tags.
	Tag []*SearchTracesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s SearchTracesRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchTracesRequest) GoString() string {
	return s.String()
}

func (s *SearchTracesRequest) SetEndTime(v int64) *SearchTracesRequest {
	s.EndTime = &v
	return s
}

func (s *SearchTracesRequest) SetExclusionFilters(v []*SearchTracesRequestExclusionFilters) *SearchTracesRequest {
	s.ExclusionFilters = v
	return s
}

func (s *SearchTracesRequest) SetMinDuration(v int64) *SearchTracesRequest {
	s.MinDuration = &v
	return s
}

func (s *SearchTracesRequest) SetOperationName(v string) *SearchTracesRequest {
	s.OperationName = &v
	return s
}

func (s *SearchTracesRequest) SetPid(v string) *SearchTracesRequest {
	s.Pid = &v
	return s
}

func (s *SearchTracesRequest) SetRegionId(v string) *SearchTracesRequest {
	s.RegionId = &v
	return s
}

func (s *SearchTracesRequest) SetReverse(v bool) *SearchTracesRequest {
	s.Reverse = &v
	return s
}

func (s *SearchTracesRequest) SetServiceIp(v string) *SearchTracesRequest {
	s.ServiceIp = &v
	return s
}

func (s *SearchTracesRequest) SetServiceName(v string) *SearchTracesRequest {
	s.ServiceName = &v
	return s
}

func (s *SearchTracesRequest) SetStartTime(v int64) *SearchTracesRequest {
	s.StartTime = &v
	return s
}

func (s *SearchTracesRequest) SetTag(v []*SearchTracesRequestTag) *SearchTracesRequest {
	s.Tag = v
	return s
}

type SearchTracesRequestExclusionFilters struct {
	// The key that is used to filter the query results.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the key that is used to filter the query results.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s SearchTracesRequestExclusionFilters) String() string {
	return tea.Prettify(s)
}

func (s SearchTracesRequestExclusionFilters) GoString() string {
	return s.String()
}

func (s *SearchTracesRequestExclusionFilters) SetKey(v string) *SearchTracesRequestExclusionFilters {
	s.Key = &v
	return s
}

func (s *SearchTracesRequestExclusionFilters) SetValue(v string) *SearchTracesRequestExclusionFilters {
	s.Value = &v
	return s
}

type SearchTracesRequestTag struct {
	// The tag key. The following system preset fields are provided:
	//
	// *   serverApp: the name of the server application.
	// *   clientApp: the name of the client application.
	// *   service: the name of the operation.
	// *   rpc: the type of the call.
	// *   msOfSpan: the duration exceeds a specific value.
	// *   clientIp: the IP address of the client.
	// *   serverIp: the IP address of the server.
	// *   isError: specifies whether the call is abnormal.
	// *   hasTprof: contains only thread profiling.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s SearchTracesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s SearchTracesRequestTag) GoString() string {
	return s.String()
}

func (s *SearchTracesRequestTag) SetKey(v string) *SearchTracesRequestTag {
	s.Key = &v
	return s
}

func (s *SearchTracesRequestTag) SetValue(v string) *SearchTracesRequestTag {
	s.Value = &v
	return s
}

type SearchTracesResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details of the returned traces.
	TraceInfos []*SearchTracesResponseBodyTraceInfos `json:"TraceInfos,omitempty" xml:"TraceInfos,omitempty" type:"Repeated"`
}

func (s SearchTracesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SearchTracesResponseBody) GoString() string {
	return s.String()
}

func (s *SearchTracesResponseBody) SetRequestId(v string) *SearchTracesResponseBody {
	s.RequestId = &v
	return s
}

func (s *SearchTracesResponseBody) SetTraceInfos(v []*SearchTracesResponseBodyTraceInfos) *SearchTracesResponseBody {
	s.TraceInfos = v
	return s
}

type SearchTracesResponseBodyTraceInfos struct {
	// The amount of time consumed by the trace. Unit: milliseconds.
	Duration *int64 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The name of the traced span.
	OperationName *string `json:"OperationName,omitempty" xml:"OperationName,omitempty"`
	// The IP address of the host where the application resides.
	ServiceIp *string `json:"ServiceIp,omitempty" xml:"ServiceIp,omitempty"`
	// The name of the application.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The timestamp.
	Timestamp *int64 `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The trace ID.
	TraceID *string `json:"TraceID,omitempty" xml:"TraceID,omitempty"`
}

func (s SearchTracesResponseBodyTraceInfos) String() string {
	return tea.Prettify(s)
}

func (s SearchTracesResponseBodyTraceInfos) GoString() string {
	return s.String()
}

func (s *SearchTracesResponseBodyTraceInfos) SetDuration(v int64) *SearchTracesResponseBodyTraceInfos {
	s.Duration = &v
	return s
}

func (s *SearchTracesResponseBodyTraceInfos) SetOperationName(v string) *SearchTracesResponseBodyTraceInfos {
	s.OperationName = &v
	return s
}

func (s *SearchTracesResponseBodyTraceInfos) SetServiceIp(v string) *SearchTracesResponseBodyTraceInfos {
	s.ServiceIp = &v
	return s
}

func (s *SearchTracesResponseBodyTraceInfos) SetServiceName(v string) *SearchTracesResponseBodyTraceInfos {
	s.ServiceName = &v
	return s
}

func (s *SearchTracesResponseBodyTraceInfos) SetTimestamp(v int64) *SearchTracesResponseBodyTraceInfos {
	s.Timestamp = &v
	return s
}

func (s *SearchTracesResponseBodyTraceInfos) SetTraceID(v string) *SearchTracesResponseBodyTraceInfos {
	s.TraceID = &v
	return s
}

type SearchTracesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SearchTracesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchTracesResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchTracesResponse) GoString() string {
	return s.String()
}

func (s *SearchTracesResponse) SetHeaders(v map[string]*string) *SearchTracesResponse {
	s.Headers = v
	return s
}

func (s *SearchTracesResponse) SetStatusCode(v int32) *SearchTracesResponse {
	s.StatusCode = &v
	return s
}

func (s *SearchTracesResponse) SetBody(v *SearchTracesResponseBody) *SearchTracesResponse {
	s.Body = v
	return s
}

type SearchTracesByPageRequest struct {
	// The end of the time range to query. Unit: milliseconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The filter conditions.
	ExclusionFilters []*SearchTracesByPageRequestExclusionFilters `json:"ExclusionFilters,omitempty" xml:"ExclusionFilters,omitempty" type:"Repeated"`
	// Specifies whether to include the traces of abnormal calls.
	//
	// *   `true`: No
	// *   `false` (default): Yes
	IsError *bool `json:"IsError,omitempty" xml:"IsError,omitempty"`
	// The minimum amount of time consumed by traces. Unit: milliseconds.
	MinDuration *int64 `json:"MinDuration,omitempty" xml:"MinDuration,omitempty"`
	// The name of the traced span.
	OperationName *string `json:"OperationName,omitempty" xml:"OperationName,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The application ID.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Specifies whether to sort the query results in chronological order or reverse chronological order. Default value: `false`.
	//
	// *   `true`: sorts the query results in reverse chronological order.
	// *   `false`: sorts the query results in chronological order.
	Reverse *bool `json:"Reverse,omitempty" xml:"Reverse,omitempty"`
	// The IP address of the host where the application resides.
	ServiceIp *string `json:"ServiceIp,omitempty" xml:"ServiceIp,omitempty"`
	// The name of the application.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The beginning of the time range to query. Unit: milliseconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The tags.
	Tags []*SearchTracesByPageRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s SearchTracesByPageRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchTracesByPageRequest) GoString() string {
	return s.String()
}

func (s *SearchTracesByPageRequest) SetEndTime(v int64) *SearchTracesByPageRequest {
	s.EndTime = &v
	return s
}

func (s *SearchTracesByPageRequest) SetExclusionFilters(v []*SearchTracesByPageRequestExclusionFilters) *SearchTracesByPageRequest {
	s.ExclusionFilters = v
	return s
}

func (s *SearchTracesByPageRequest) SetIsError(v bool) *SearchTracesByPageRequest {
	s.IsError = &v
	return s
}

func (s *SearchTracesByPageRequest) SetMinDuration(v int64) *SearchTracesByPageRequest {
	s.MinDuration = &v
	return s
}

func (s *SearchTracesByPageRequest) SetOperationName(v string) *SearchTracesByPageRequest {
	s.OperationName = &v
	return s
}

func (s *SearchTracesByPageRequest) SetPageNumber(v int32) *SearchTracesByPageRequest {
	s.PageNumber = &v
	return s
}

func (s *SearchTracesByPageRequest) SetPageSize(v int32) *SearchTracesByPageRequest {
	s.PageSize = &v
	return s
}

func (s *SearchTracesByPageRequest) SetPid(v string) *SearchTracesByPageRequest {
	s.Pid = &v
	return s
}

func (s *SearchTracesByPageRequest) SetRegionId(v string) *SearchTracesByPageRequest {
	s.RegionId = &v
	return s
}

func (s *SearchTracesByPageRequest) SetReverse(v bool) *SearchTracesByPageRequest {
	s.Reverse = &v
	return s
}

func (s *SearchTracesByPageRequest) SetServiceIp(v string) *SearchTracesByPageRequest {
	s.ServiceIp = &v
	return s
}

func (s *SearchTracesByPageRequest) SetServiceName(v string) *SearchTracesByPageRequest {
	s.ServiceName = &v
	return s
}

func (s *SearchTracesByPageRequest) SetStartTime(v int64) *SearchTracesByPageRequest {
	s.StartTime = &v
	return s
}

func (s *SearchTracesByPageRequest) SetTags(v []*SearchTracesByPageRequestTags) *SearchTracesByPageRequest {
	s.Tags = v
	return s
}

type SearchTracesByPageRequestExclusionFilters struct {
	// The key that is used to filter the query results.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the key that is used to filter the query results.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s SearchTracesByPageRequestExclusionFilters) String() string {
	return tea.Prettify(s)
}

func (s SearchTracesByPageRequestExclusionFilters) GoString() string {
	return s.String()
}

func (s *SearchTracesByPageRequestExclusionFilters) SetKey(v string) *SearchTracesByPageRequestExclusionFilters {
	s.Key = &v
	return s
}

func (s *SearchTracesByPageRequestExclusionFilters) SetValue(v string) *SearchTracesByPageRequestExclusionFilters {
	s.Value = &v
	return s
}

type SearchTracesByPageRequestTags struct {
	// The key of the tag. The following system preset fields are provided:
	//
	// *   traceId: the ID of the trace.
	// *   serverApp: the name of the server application.
	// *   clientApp: the name of the client application.
	// *   service: the name of the API operation.
	// *   rpc: the type of the call.
	// *   msOfSpan: the duration exceeds a specific value.
	// *   clientIp: the IP address of the client.
	// *   serverIp: the IP address of the server.
	// *   isError: specifies whether the call is abnormal.
	// *   hasTprof: contains only thread profiling.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s SearchTracesByPageRequestTags) String() string {
	return tea.Prettify(s)
}

func (s SearchTracesByPageRequestTags) GoString() string {
	return s.String()
}

func (s *SearchTracesByPageRequestTags) SetKey(v string) *SearchTracesByPageRequestTags {
	s.Key = &v
	return s
}

func (s *SearchTracesByPageRequestTags) SetValue(v string) *SearchTracesByPageRequestTags {
	s.Value = &v
	return s
}

type SearchTracesByPageResponseBody struct {
	// The returned struct.
	PageBean *SearchTracesByPageResponseBodyPageBean `json:"PageBean,omitempty" xml:"PageBean,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SearchTracesByPageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SearchTracesByPageResponseBody) GoString() string {
	return s.String()
}

func (s *SearchTracesByPageResponseBody) SetPageBean(v *SearchTracesByPageResponseBodyPageBean) *SearchTracesByPageResponseBody {
	s.PageBean = v
	return s
}

func (s *SearchTracesByPageResponseBody) SetRequestId(v string) *SearchTracesByPageResponseBody {
	s.RequestId = &v
	return s
}

type SearchTracesByPageResponseBodyPageBean struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of returned entries.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
	// The details of the returned traces.
	TraceInfos []*SearchTracesByPageResponseBodyPageBeanTraceInfos `json:"TraceInfos,omitempty" xml:"TraceInfos,omitempty" type:"Repeated"`
}

func (s SearchTracesByPageResponseBodyPageBean) String() string {
	return tea.Prettify(s)
}

func (s SearchTracesByPageResponseBodyPageBean) GoString() string {
	return s.String()
}

func (s *SearchTracesByPageResponseBodyPageBean) SetPageNumber(v int32) *SearchTracesByPageResponseBodyPageBean {
	s.PageNumber = &v
	return s
}

func (s *SearchTracesByPageResponseBodyPageBean) SetPageSize(v int32) *SearchTracesByPageResponseBodyPageBean {
	s.PageSize = &v
	return s
}

func (s *SearchTracesByPageResponseBodyPageBean) SetTotal(v int32) *SearchTracesByPageResponseBodyPageBean {
	s.Total = &v
	return s
}

func (s *SearchTracesByPageResponseBodyPageBean) SetTraceInfos(v []*SearchTracesByPageResponseBodyPageBeanTraceInfos) *SearchTracesByPageResponseBodyPageBean {
	s.TraceInfos = v
	return s
}

type SearchTracesByPageResponseBodyPageBeanTraceInfos struct {
	// The amount of time consumed by the trace. Unit: milliseconds.
	Duration *int64 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The name of the traced span.
	OperationName *string `json:"OperationName,omitempty" xml:"OperationName,omitempty"`
	// The IP address of the host where the application resides.
	ServiceIp *string `json:"ServiceIp,omitempty" xml:"ServiceIp,omitempty"`
	// The name of the application.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The timestamp.
	Timestamp *int64 `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The trace ID.
	TraceID *string `json:"TraceID,omitempty" xml:"TraceID,omitempty"`
}

func (s SearchTracesByPageResponseBodyPageBeanTraceInfos) String() string {
	return tea.Prettify(s)
}

func (s SearchTracesByPageResponseBodyPageBeanTraceInfos) GoString() string {
	return s.String()
}

func (s *SearchTracesByPageResponseBodyPageBeanTraceInfos) SetDuration(v int64) *SearchTracesByPageResponseBodyPageBeanTraceInfos {
	s.Duration = &v
	return s
}

func (s *SearchTracesByPageResponseBodyPageBeanTraceInfos) SetOperationName(v string) *SearchTracesByPageResponseBodyPageBeanTraceInfos {
	s.OperationName = &v
	return s
}

func (s *SearchTracesByPageResponseBodyPageBeanTraceInfos) SetServiceIp(v string) *SearchTracesByPageResponseBodyPageBeanTraceInfos {
	s.ServiceIp = &v
	return s
}

func (s *SearchTracesByPageResponseBodyPageBeanTraceInfos) SetServiceName(v string) *SearchTracesByPageResponseBodyPageBeanTraceInfos {
	s.ServiceName = &v
	return s
}

func (s *SearchTracesByPageResponseBodyPageBeanTraceInfos) SetTimestamp(v int64) *SearchTracesByPageResponseBodyPageBeanTraceInfos {
	s.Timestamp = &v
	return s
}

func (s *SearchTracesByPageResponseBodyPageBeanTraceInfos) SetTraceID(v string) *SearchTracesByPageResponseBodyPageBeanTraceInfos {
	s.TraceID = &v
	return s
}

type SearchTracesByPageResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SearchTracesByPageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchTracesByPageResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchTracesByPageResponse) GoString() string {
	return s.String()
}

func (s *SearchTracesByPageResponse) SetHeaders(v map[string]*string) *SearchTracesByPageResponse {
	s.Headers = v
	return s
}

func (s *SearchTracesByPageResponse) SetStatusCode(v int32) *SearchTracesByPageResponse {
	s.StatusCode = &v
	return s
}

func (s *SearchTracesByPageResponse) SetBody(v *SearchTracesByPageResponseBody) *SearchTracesByPageResponse {
	s.Body = v
	return s
}

type SendTTSVerifyLinkRequest struct {
	// The ID of the alert contact.
	ContactId *int64 `json:"ContactId,omitempty" xml:"ContactId,omitempty"`
	// The mobile number of the alert contact.
	Phone *string `json:"Phone,omitempty" xml:"Phone,omitempty"`
}

func (s SendTTSVerifyLinkRequest) String() string {
	return tea.Prettify(s)
}

func (s SendTTSVerifyLinkRequest) GoString() string {
	return s.String()
}

func (s *SendTTSVerifyLinkRequest) SetContactId(v int64) *SendTTSVerifyLinkRequest {
	s.ContactId = &v
	return s
}

func (s *SendTTSVerifyLinkRequest) SetPhone(v string) *SendTTSVerifyLinkRequest {
	s.Phone = &v
	return s
}

type SendTTSVerifyLinkResponseBody struct {
	// Indicates whether the text message was sent.
	//
	// *   `true`
	// *   `false`
	IsSuccess *bool `json:"IsSuccess,omitempty" xml:"IsSuccess,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SendTTSVerifyLinkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SendTTSVerifyLinkResponseBody) GoString() string {
	return s.String()
}

func (s *SendTTSVerifyLinkResponseBody) SetIsSuccess(v bool) *SendTTSVerifyLinkResponseBody {
	s.IsSuccess = &v
	return s
}

func (s *SendTTSVerifyLinkResponseBody) SetRequestId(v string) *SendTTSVerifyLinkResponseBody {
	s.RequestId = &v
	return s
}

type SendTTSVerifyLinkResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SendTTSVerifyLinkResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SendTTSVerifyLinkResponse) String() string {
	return tea.Prettify(s)
}

func (s SendTTSVerifyLinkResponse) GoString() string {
	return s.String()
}

func (s *SendTTSVerifyLinkResponse) SetHeaders(v map[string]*string) *SendTTSVerifyLinkResponse {
	s.Headers = v
	return s
}

func (s *SendTTSVerifyLinkResponse) SetStatusCode(v int32) *SendTTSVerifyLinkResponse {
	s.StatusCode = &v
	return s
}

func (s *SendTTSVerifyLinkResponse) SetBody(v *SendTTSVerifyLinkResponseBody) *SendTTSVerifyLinkResponse {
	s.Body = v
	return s
}

type SetRetcodeShareStatusRequest struct {
	// Turns on or turns off logon-free sharing for an application monitored by Browser Monitoring.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// Indicates whether the call is successful. Valid values:
	//
	// *   `true`: The call is successful.
	// *   `false`: The call fails.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// SetRetcodeShareStatus
	Status *bool `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s SetRetcodeShareStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s SetRetcodeShareStatusRequest) GoString() string {
	return s.String()
}

func (s *SetRetcodeShareStatusRequest) SetAppName(v string) *SetRetcodeShareStatusRequest {
	s.AppName = &v
	return s
}

func (s *SetRetcodeShareStatusRequest) SetPid(v string) *SetRetcodeShareStatusRequest {
	s.Pid = &v
	return s
}

func (s *SetRetcodeShareStatusRequest) SetStatus(v bool) *SetRetcodeShareStatusRequest {
	s.Status = &v
	return s
}

type SetRetcodeShareStatusResponseBody struct {
	// The ID of the application. Log on to the ARMS console. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of an application. The URL in the address bar contains the process ID (PID) of the application. The PID is indicated in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is xxx%4074xxx, you must replace %40 with the at sign (@) to obtain xxx@74xxx.
	IsSuccess *bool `json:"IsSuccess,omitempty" xml:"IsSuccess,omitempty"`
	// Specifies whether to turn on logon-free sharing. Valid values:
	//
	// *   `true`: turns on logon-free sharing.
	// *   `false`: turns off logon-free sharing.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetRetcodeShareStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetRetcodeShareStatusResponseBody) GoString() string {
	return s.String()
}

func (s *SetRetcodeShareStatusResponseBody) SetIsSuccess(v bool) *SetRetcodeShareStatusResponseBody {
	s.IsSuccess = &v
	return s
}

func (s *SetRetcodeShareStatusResponseBody) SetRequestId(v string) *SetRetcodeShareStatusResponseBody {
	s.RequestId = &v
	return s
}

type SetRetcodeShareStatusResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetRetcodeShareStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetRetcodeShareStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s SetRetcodeShareStatusResponse) GoString() string {
	return s.String()
}

func (s *SetRetcodeShareStatusResponse) SetHeaders(v map[string]*string) *SetRetcodeShareStatusResponse {
	s.Headers = v
	return s
}

func (s *SetRetcodeShareStatusResponse) SetStatusCode(v int32) *SetRetcodeShareStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *SetRetcodeShareStatusResponse) SetBody(v *SetRetcodeShareStatusResponseBody) *SetRetcodeShareStatusResponse {
	s.Body = v
	return s
}

type StartAlertRequest struct {
	AlertId  *string `json:"AlertId,omitempty" xml:"AlertId,omitempty"`
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s StartAlertRequest) String() string {
	return tea.Prettify(s)
}

func (s StartAlertRequest) GoString() string {
	return s.String()
}

func (s *StartAlertRequest) SetAlertId(v string) *StartAlertRequest {
	s.AlertId = &v
	return s
}

func (s *StartAlertRequest) SetRegionId(v string) *StartAlertRequest {
	s.RegionId = &v
	return s
}

type StartAlertResponseBody struct {
	IsSuccess *bool   `json:"IsSuccess,omitempty" xml:"IsSuccess,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StartAlertResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StartAlertResponseBody) GoString() string {
	return s.String()
}

func (s *StartAlertResponseBody) SetIsSuccess(v bool) *StartAlertResponseBody {
	s.IsSuccess = &v
	return s
}

func (s *StartAlertResponseBody) SetRequestId(v string) *StartAlertResponseBody {
	s.RequestId = &v
	return s
}

type StartAlertResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StartAlertResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StartAlertResponse) String() string {
	return tea.Prettify(s)
}

func (s StartAlertResponse) GoString() string {
	return s.String()
}

func (s *StartAlertResponse) SetHeaders(v map[string]*string) *StartAlertResponse {
	s.Headers = v
	return s
}

func (s *StartAlertResponse) SetStatusCode(v int32) *StartAlertResponse {
	s.StatusCode = &v
	return s
}

func (s *StartAlertResponse) SetBody(v *StartAlertResponseBody) *StartAlertResponse {
	s.Body = v
	return s
}

type StartTimingSyntheticTaskRequest struct {
	RegionId *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	TaskIds  []*string `json:"TaskIds,omitempty" xml:"TaskIds,omitempty" type:"Repeated"`
}

func (s StartTimingSyntheticTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s StartTimingSyntheticTaskRequest) GoString() string {
	return s.String()
}

func (s *StartTimingSyntheticTaskRequest) SetRegionId(v string) *StartTimingSyntheticTaskRequest {
	s.RegionId = &v
	return s
}

func (s *StartTimingSyntheticTaskRequest) SetTaskIds(v []*string) *StartTimingSyntheticTaskRequest {
	s.TaskIds = v
	return s
}

type StartTimingSyntheticTaskShrinkRequest struct {
	RegionId      *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	TaskIdsShrink *string `json:"TaskIds,omitempty" xml:"TaskIds,omitempty"`
}

func (s StartTimingSyntheticTaskShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s StartTimingSyntheticTaskShrinkRequest) GoString() string {
	return s.String()
}

func (s *StartTimingSyntheticTaskShrinkRequest) SetRegionId(v string) *StartTimingSyntheticTaskShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *StartTimingSyntheticTaskShrinkRequest) SetTaskIdsShrink(v string) *StartTimingSyntheticTaskShrinkRequest {
	s.TaskIdsShrink = &v
	return s
}

type StartTimingSyntheticTaskResponseBody struct {
	Code      *int64  `json:"Code,omitempty" xml:"Code,omitempty"`
	Data      *bool   `json:"Data,omitempty" xml:"Data,omitempty"`
	Message   *string `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StartTimingSyntheticTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StartTimingSyntheticTaskResponseBody) GoString() string {
	return s.String()
}

func (s *StartTimingSyntheticTaskResponseBody) SetCode(v int64) *StartTimingSyntheticTaskResponseBody {
	s.Code = &v
	return s
}

func (s *StartTimingSyntheticTaskResponseBody) SetData(v bool) *StartTimingSyntheticTaskResponseBody {
	s.Data = &v
	return s
}

func (s *StartTimingSyntheticTaskResponseBody) SetMessage(v string) *StartTimingSyntheticTaskResponseBody {
	s.Message = &v
	return s
}

func (s *StartTimingSyntheticTaskResponseBody) SetRequestId(v string) *StartTimingSyntheticTaskResponseBody {
	s.RequestId = &v
	return s
}

type StartTimingSyntheticTaskResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StartTimingSyntheticTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StartTimingSyntheticTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s StartTimingSyntheticTaskResponse) GoString() string {
	return s.String()
}

func (s *StartTimingSyntheticTaskResponse) SetHeaders(v map[string]*string) *StartTimingSyntheticTaskResponse {
	s.Headers = v
	return s
}

func (s *StartTimingSyntheticTaskResponse) SetStatusCode(v int32) *StartTimingSyntheticTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *StartTimingSyntheticTaskResponse) SetBody(v *StartTimingSyntheticTaskResponseBody) *StartTimingSyntheticTaskResponse {
	s.Body = v
	return s
}

type StopAlertRequest struct {
	// The ID of the alert rule.
	AlertId *string `json:"AlertId,omitempty" xml:"AlertId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s StopAlertRequest) String() string {
	return tea.Prettify(s)
}

func (s StopAlertRequest) GoString() string {
	return s.String()
}

func (s *StopAlertRequest) SetAlertId(v string) *StopAlertRequest {
	s.AlertId = &v
	return s
}

func (s *StopAlertRequest) SetRegionId(v string) *StopAlertRequest {
	s.RegionId = &v
	return s
}

type StopAlertResponseBody struct {
	// Indicates whether the request is successful. Valid values:
	//
	// *   `true`: The request is successful.
	// *   `false`: The request fails.
	IsSuccess *bool `json:"IsSuccess,omitempty" xml:"IsSuccess,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StopAlertResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StopAlertResponseBody) GoString() string {
	return s.String()
}

func (s *StopAlertResponseBody) SetIsSuccess(v bool) *StopAlertResponseBody {
	s.IsSuccess = &v
	return s
}

func (s *StopAlertResponseBody) SetRequestId(v string) *StopAlertResponseBody {
	s.RequestId = &v
	return s
}

type StopAlertResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StopAlertResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StopAlertResponse) String() string {
	return tea.Prettify(s)
}

func (s StopAlertResponse) GoString() string {
	return s.String()
}

func (s *StopAlertResponse) SetHeaders(v map[string]*string) *StopAlertResponse {
	s.Headers = v
	return s
}

func (s *StopAlertResponse) SetStatusCode(v int32) *StopAlertResponse {
	s.StatusCode = &v
	return s
}

func (s *StopAlertResponse) SetBody(v *StopAlertResponseBody) *StopAlertResponse {
	s.Body = v
	return s
}

type StopTimingSyntheticTaskRequest struct {
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The task IDs.
	TaskIds []*string `json:"TaskIds,omitempty" xml:"TaskIds,omitempty" type:"Repeated"`
}

func (s StopTimingSyntheticTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s StopTimingSyntheticTaskRequest) GoString() string {
	return s.String()
}

func (s *StopTimingSyntheticTaskRequest) SetRegionId(v string) *StopTimingSyntheticTaskRequest {
	s.RegionId = &v
	return s
}

func (s *StopTimingSyntheticTaskRequest) SetTaskIds(v []*string) *StopTimingSyntheticTaskRequest {
	s.TaskIds = v
	return s
}

type StopTimingSyntheticTaskShrinkRequest struct {
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The task IDs.
	TaskIdsShrink *string `json:"TaskIds,omitempty" xml:"TaskIds,omitempty"`
}

func (s StopTimingSyntheticTaskShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s StopTimingSyntheticTaskShrinkRequest) GoString() string {
	return s.String()
}

func (s *StopTimingSyntheticTaskShrinkRequest) SetRegionId(v string) *StopTimingSyntheticTaskShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *StopTimingSyntheticTaskShrinkRequest) SetTaskIdsShrink(v string) *StopTimingSyntheticTaskShrinkRequest {
	s.TaskIdsShrink = &v
	return s
}

type StopTimingSyntheticTaskResponseBody struct {
	// The HTTP status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
	Code *int64 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the request was successful. Valid values: true and false.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StopTimingSyntheticTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StopTimingSyntheticTaskResponseBody) GoString() string {
	return s.String()
}

func (s *StopTimingSyntheticTaskResponseBody) SetCode(v int64) *StopTimingSyntheticTaskResponseBody {
	s.Code = &v
	return s
}

func (s *StopTimingSyntheticTaskResponseBody) SetData(v bool) *StopTimingSyntheticTaskResponseBody {
	s.Data = &v
	return s
}

func (s *StopTimingSyntheticTaskResponseBody) SetMessage(v string) *StopTimingSyntheticTaskResponseBody {
	s.Message = &v
	return s
}

func (s *StopTimingSyntheticTaskResponseBody) SetRequestId(v string) *StopTimingSyntheticTaskResponseBody {
	s.RequestId = &v
	return s
}

type StopTimingSyntheticTaskResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StopTimingSyntheticTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StopTimingSyntheticTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s StopTimingSyntheticTaskResponse) GoString() string {
	return s.String()
}

func (s *StopTimingSyntheticTaskResponse) SetHeaders(v map[string]*string) *StopTimingSyntheticTaskResponse {
	s.Headers = v
	return s
}

func (s *StopTimingSyntheticTaskResponse) SetStatusCode(v int32) *StopTimingSyntheticTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *StopTimingSyntheticTaskResponse) SetBody(v *StopTimingSyntheticTaskResponseBody) *StopTimingSyntheticTaskResponse {
	s.Body = v
	return s
}

type SwitchSyntheticTaskStatusRequest struct {
	SwitchStatus *int64   `json:"SwitchStatus,omitempty" xml:"SwitchStatus,omitempty"`
	TaskIds      []*int64 `json:"TaskIds,omitempty" xml:"TaskIds,omitempty" type:"Repeated"`
}

func (s SwitchSyntheticTaskStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s SwitchSyntheticTaskStatusRequest) GoString() string {
	return s.String()
}

func (s *SwitchSyntheticTaskStatusRequest) SetSwitchStatus(v int64) *SwitchSyntheticTaskStatusRequest {
	s.SwitchStatus = &v
	return s
}

func (s *SwitchSyntheticTaskStatusRequest) SetTaskIds(v []*int64) *SwitchSyntheticTaskStatusRequest {
	s.TaskIds = v
	return s
}

type SwitchSyntheticTaskStatusResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *string `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s SwitchSyntheticTaskStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SwitchSyntheticTaskStatusResponseBody) GoString() string {
	return s.String()
}

func (s *SwitchSyntheticTaskStatusResponseBody) SetRequestId(v string) *SwitchSyntheticTaskStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *SwitchSyntheticTaskStatusResponseBody) SetResult(v string) *SwitchSyntheticTaskStatusResponseBody {
	s.Result = &v
	return s
}

type SwitchSyntheticTaskStatusResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SwitchSyntheticTaskStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SwitchSyntheticTaskStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s SwitchSyntheticTaskStatusResponse) GoString() string {
	return s.String()
}

func (s *SwitchSyntheticTaskStatusResponse) SetHeaders(v map[string]*string) *SwitchSyntheticTaskStatusResponse {
	s.Headers = v
	return s
}

func (s *SwitchSyntheticTaskStatusResponse) SetStatusCode(v int32) *SwitchSyntheticTaskStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *SwitchSyntheticTaskStatusResponse) SetBody(v *SwitchSyntheticTaskStatusResponseBody) *SwitchSyntheticTaskStatusResponse {
	s.Body = v
	return s
}

type SyncRecordingRulesRequest struct {
	// The ID of the cluster whose aggregation rule you want to synchronize.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the region. The destination region can be the same as the source region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The IDs of clusters to which you want to synchronize the aggregation rule.
	TargetClusters *string `json:"TargetClusters,omitempty" xml:"TargetClusters,omitempty"`
}

func (s SyncRecordingRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s SyncRecordingRulesRequest) GoString() string {
	return s.String()
}

func (s *SyncRecordingRulesRequest) SetClusterId(v string) *SyncRecordingRulesRequest {
	s.ClusterId = &v
	return s
}

func (s *SyncRecordingRulesRequest) SetRegionId(v string) *SyncRecordingRulesRequest {
	s.RegionId = &v
	return s
}

func (s *SyncRecordingRulesRequest) SetTargetClusters(v string) *SyncRecordingRulesRequest {
	s.TargetClusters = &v
	return s
}

type SyncRecordingRulesResponseBody struct {
	// 状态码。200表示成功。
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The struct returned.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// 返回结果的提示信息。
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SyncRecordingRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SyncRecordingRulesResponseBody) GoString() string {
	return s.String()
}

func (s *SyncRecordingRulesResponseBody) SetCode(v int32) *SyncRecordingRulesResponseBody {
	s.Code = &v
	return s
}

func (s *SyncRecordingRulesResponseBody) SetData(v string) *SyncRecordingRulesResponseBody {
	s.Data = &v
	return s
}

func (s *SyncRecordingRulesResponseBody) SetMessage(v string) *SyncRecordingRulesResponseBody {
	s.Message = &v
	return s
}

func (s *SyncRecordingRulesResponseBody) SetRequestId(v string) *SyncRecordingRulesResponseBody {
	s.RequestId = &v
	return s
}

type SyncRecordingRulesResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SyncRecordingRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SyncRecordingRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s SyncRecordingRulesResponse) GoString() string {
	return s.String()
}

func (s *SyncRecordingRulesResponse) SetHeaders(v map[string]*string) *SyncRecordingRulesResponse {
	s.Headers = v
	return s
}

func (s *SyncRecordingRulesResponse) SetStatusCode(v int32) *SyncRecordingRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *SyncRecordingRulesResponse) SetBody(v *SyncRecordingRulesResponseBody) *SyncRecordingRulesResponse {
	s.Body = v
	return s
}

type TagResourcesRequest struct {
	// The resource IDs. You can specify a maximum of 50 resource IDs.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The type of the ARMS resources for which you want to modify tags. Valid values: WEB: Browser Monitoring APPLICATION: Application Monitoring PROMETHEUS: Managed Service for Prometheus SYNTHETICTASK: Synthetic Monitoring ALERTRULE: Application Monitoring alert rules PROMETHEUSALERTRULE: Prometheus alert rules
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tags to add to the resource. You can specify a maximum of 20 tags.
	Tag []*TagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s TagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequest) GoString() string {
	return s.String()
}

func (s *TagResourcesRequest) SetResourceId(v []*string) *TagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *TagResourcesRequest) SetResourceType(v string) *TagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *TagResourcesRequest) SetTag(v []*TagResourcesRequestTag) *TagResourcesRequest {
	s.Tag = v
	return s
}

type TagResourcesRequestTag struct {
	// The key of the tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s TagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *TagResourcesRequestTag) SetKey(v string) *TagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *TagResourcesRequestTag) SetValue(v string) *TagResourcesRequestTag {
	s.Value = &v
	return s
}

type TagResourcesResponseBody struct {
	// The returned message.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *TagResourcesResponseBody) SetData(v string) *TagResourcesResponseBody {
	s.Data = &v
	return s
}

func (s *TagResourcesResponseBody) SetRequestId(v string) *TagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type TagResourcesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponse) GoString() string {
	return s.String()
}

func (s *TagResourcesResponse) SetHeaders(v map[string]*string) *TagResourcesResponse {
	s.Headers = v
	return s
}

func (s *TagResourcesResponse) SetStatusCode(v int32) *TagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *TagResourcesResponse) SetBody(v *TagResourcesResponseBody) *TagResourcesResponse {
	s.Body = v
	return s
}

type UninstallManagedPrometheusRequest struct {
	// The ID of the ASK cluster. This parameter is required if the ClusterType parameter is set to ask.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The type of the monitoring object. Valid values: ask and ecs.
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the Prometheus instance belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The virtual private cloud (VPC) where the ASK cluster or ECS instance resides.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s UninstallManagedPrometheusRequest) String() string {
	return tea.Prettify(s)
}

func (s UninstallManagedPrometheusRequest) GoString() string {
	return s.String()
}

func (s *UninstallManagedPrometheusRequest) SetClusterId(v string) *UninstallManagedPrometheusRequest {
	s.ClusterId = &v
	return s
}

func (s *UninstallManagedPrometheusRequest) SetClusterType(v string) *UninstallManagedPrometheusRequest {
	s.ClusterType = &v
	return s
}

func (s *UninstallManagedPrometheusRequest) SetRegionId(v string) *UninstallManagedPrometheusRequest {
	s.RegionId = &v
	return s
}

func (s *UninstallManagedPrometheusRequest) SetResourceGroupId(v string) *UninstallManagedPrometheusRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *UninstallManagedPrometheusRequest) SetVpcId(v string) *UninstallManagedPrometheusRequest {
	s.VpcId = &v
	return s
}

type UninstallManagedPrometheusResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful. If another status code is returned, the request failed.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The response content. The status of the Prometheus instance is returned.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error message that is returned if the request fails.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the Prometheus instance was removed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UninstallManagedPrometheusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UninstallManagedPrometheusResponseBody) GoString() string {
	return s.String()
}

func (s *UninstallManagedPrometheusResponseBody) SetCode(v int32) *UninstallManagedPrometheusResponseBody {
	s.Code = &v
	return s
}

func (s *UninstallManagedPrometheusResponseBody) SetData(v string) *UninstallManagedPrometheusResponseBody {
	s.Data = &v
	return s
}

func (s *UninstallManagedPrometheusResponseBody) SetMessage(v string) *UninstallManagedPrometheusResponseBody {
	s.Message = &v
	return s
}

func (s *UninstallManagedPrometheusResponseBody) SetRequestId(v string) *UninstallManagedPrometheusResponseBody {
	s.RequestId = &v
	return s
}

func (s *UninstallManagedPrometheusResponseBody) SetSuccess(v bool) *UninstallManagedPrometheusResponseBody {
	s.Success = &v
	return s
}

type UninstallManagedPrometheusResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UninstallManagedPrometheusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UninstallManagedPrometheusResponse) String() string {
	return tea.Prettify(s)
}

func (s UninstallManagedPrometheusResponse) GoString() string {
	return s.String()
}

func (s *UninstallManagedPrometheusResponse) SetHeaders(v map[string]*string) *UninstallManagedPrometheusResponse {
	s.Headers = v
	return s
}

func (s *UninstallManagedPrometheusResponse) SetStatusCode(v int32) *UninstallManagedPrometheusResponse {
	s.StatusCode = &v
	return s
}

func (s *UninstallManagedPrometheusResponse) SetBody(v *UninstallManagedPrometheusResponseBody) *UninstallManagedPrometheusResponse {
	s.Body = v
	return s
}

type UninstallPromClusterRequest struct {
	// Language environment(If left blank, defaults to zh):
	// - zh
	// - en
	AliyunLang *string `json:"AliyunLang,omitempty" xml:"AliyunLang,omitempty"`
	// The cluster ID.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The region ID. Default value: cn-hangzhou.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UninstallPromClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s UninstallPromClusterRequest) GoString() string {
	return s.String()
}

func (s *UninstallPromClusterRequest) SetAliyunLang(v string) *UninstallPromClusterRequest {
	s.AliyunLang = &v
	return s
}

func (s *UninstallPromClusterRequest) SetClusterId(v string) *UninstallPromClusterRequest {
	s.ClusterId = &v
	return s
}

func (s *UninstallPromClusterRequest) SetRegionId(v string) *UninstallPromClusterRequest {
	s.RegionId = &v
	return s
}

type UninstallPromClusterResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the request was successful.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID. You can use the ID to find logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UninstallPromClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UninstallPromClusterResponseBody) GoString() string {
	return s.String()
}

func (s *UninstallPromClusterResponseBody) SetCode(v int32) *UninstallPromClusterResponseBody {
	s.Code = &v
	return s
}

func (s *UninstallPromClusterResponseBody) SetData(v string) *UninstallPromClusterResponseBody {
	s.Data = &v
	return s
}

func (s *UninstallPromClusterResponseBody) SetMessage(v string) *UninstallPromClusterResponseBody {
	s.Message = &v
	return s
}

func (s *UninstallPromClusterResponseBody) SetRequestId(v string) *UninstallPromClusterResponseBody {
	s.RequestId = &v
	return s
}

type UninstallPromClusterResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UninstallPromClusterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UninstallPromClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s UninstallPromClusterResponse) GoString() string {
	return s.String()
}

func (s *UninstallPromClusterResponse) SetHeaders(v map[string]*string) *UninstallPromClusterResponse {
	s.Headers = v
	return s
}

func (s *UninstallPromClusterResponse) SetStatusCode(v int32) *UninstallPromClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *UninstallPromClusterResponse) SetBody(v *UninstallPromClusterResponseBody) *UninstallPromClusterResponse {
	s.Body = v
	return s
}

type UntagResourcesRequest struct {
	// Specifies whether to delete all tags. This parameter takes effect only when the TagKey.N parameter is not specified. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	All *bool `json:"All,omitempty" xml:"All,omitempty"`
	// The resource IDs. You can specify a maximum of 50 resource IDs.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The type of the ARMS resources for which you want to modify tags.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tag keys. You can specify a maximum of 20 tag keys.
	TagKey []*string `json:"TagKey,omitempty" xml:"TagKey,omitempty" type:"Repeated"`
	// The list of tags.
	Tags []*UntagResourcesRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s UntagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesRequest) GoString() string {
	return s.String()
}

func (s *UntagResourcesRequest) SetAll(v bool) *UntagResourcesRequest {
	s.All = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceId(v []*string) *UntagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *UntagResourcesRequest) SetResourceType(v string) *UntagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *UntagResourcesRequest) SetTagKey(v []*string) *UntagResourcesRequest {
	s.TagKey = v
	return s
}

func (s *UntagResourcesRequest) SetTags(v []*UntagResourcesRequestTags) *UntagResourcesRequest {
	s.Tags = v
	return s
}

type UntagResourcesRequestTags struct {
	// The key of the tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s UntagResourcesRequestTags) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesRequestTags) GoString() string {
	return s.String()
}

func (s *UntagResourcesRequestTags) SetKey(v string) *UntagResourcesRequestTags {
	s.Key = &v
	return s
}

func (s *UntagResourcesRequestTags) SetValue(v string) *UntagResourcesRequestTags {
	s.Value = &v
	return s
}

type UntagResourcesResponseBody struct {
	// The returned struct.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UntagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponseBody) SetData(v string) *UntagResourcesResponseBody {
	s.Data = &v
	return s
}

func (s *UntagResourcesResponseBody) SetRequestId(v string) *UntagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type UntagResourcesResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UntagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UntagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponse) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponse) SetHeaders(v map[string]*string) *UntagResourcesResponse {
	s.Headers = v
	return s
}

func (s *UntagResourcesResponse) SetStatusCode(v int32) *UntagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *UntagResourcesResponse) SetBody(v *UntagResourcesResponseBody) *UntagResourcesResponse {
	s.Body = v
	return s
}

type UpdateAlertContactRequest struct {
	// The ID of the alert contact to be updated. You can call the SearchAlertContact operation to query the contact ID. For more information, see [SearchAlertContact](~~130703~~).
	ContactId *int64 `json:"ContactId,omitempty" xml:"ContactId,omitempty"`
	// The new name of the alert contact.
	ContactName *string `json:"ContactName,omitempty" xml:"ContactName,omitempty"`
	// The new webhook URL of the DingTalk chatbot. For more information, see [Configure a DingTalk chatbot to send alert notifications](~~106247~~). You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.
	//
	// >  If you do not specify this parameter, the original parameter value is deleted. If you specify this parameter, the original parameter value is updated.
	DingRobotWebhookUrl *string `json:"DingRobotWebhookUrl,omitempty" xml:"DingRobotWebhookUrl,omitempty"`
	// The new email address of the alert contact. You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.
	//
	// >  If you do not specify this parameter, the original parameter value is deleted. If you specify this parameter, the original parameter value is updated.
	Email *string `json:"Email,omitempty" xml:"Email,omitempty"`
	// The new mobile phone number of the alert contact. You must specify at least one of the following parameters: PhoneNum, Email, and DingRobotWebhookUrl.
	//
	// >  If you do not specify this parameter, the original parameter value is deleted. If you specify this parameter, the original parameter value is updated.
	PhoneNum *string `json:"PhoneNum,omitempty" xml:"PhoneNum,omitempty"`
	// The ID of the region. Set the value to `cn-hangzhou`.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Specifies whether the alert contact receives system notifications. Valid values:
	//
	// *   `true`: The alert contact receives system notifications.
	// *   `false`: The alert contact does not receive system notifications.
	SystemNoc *bool `json:"SystemNoc,omitempty" xml:"SystemNoc,omitempty"`
}

func (s UpdateAlertContactRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAlertContactRequest) GoString() string {
	return s.String()
}

func (s *UpdateAlertContactRequest) SetContactId(v int64) *UpdateAlertContactRequest {
	s.ContactId = &v
	return s
}

func (s *UpdateAlertContactRequest) SetContactName(v string) *UpdateAlertContactRequest {
	s.ContactName = &v
	return s
}

func (s *UpdateAlertContactRequest) SetDingRobotWebhookUrl(v string) *UpdateAlertContactRequest {
	s.DingRobotWebhookUrl = &v
	return s
}

func (s *UpdateAlertContactRequest) SetEmail(v string) *UpdateAlertContactRequest {
	s.Email = &v
	return s
}

func (s *UpdateAlertContactRequest) SetPhoneNum(v string) *UpdateAlertContactRequest {
	s.PhoneNum = &v
	return s
}

func (s *UpdateAlertContactRequest) SetRegionId(v string) *UpdateAlertContactRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateAlertContactRequest) SetSystemNoc(v bool) *UpdateAlertContactRequest {
	s.SystemNoc = &v
	return s
}

type UpdateAlertContactResponseBody struct {
	// Indicates whether the alert contact was updated. Valid values:
	//
	// *   true: The alert contact was updated.
	// *   false: The alert contact failed to be updated.
	IsSuccess *bool `json:"IsSuccess,omitempty" xml:"IsSuccess,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateAlertContactResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAlertContactResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAlertContactResponseBody) SetIsSuccess(v bool) *UpdateAlertContactResponseBody {
	s.IsSuccess = &v
	return s
}

func (s *UpdateAlertContactResponseBody) SetRequestId(v string) *UpdateAlertContactResponseBody {
	s.RequestId = &v
	return s
}

type UpdateAlertContactResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateAlertContactResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateAlertContactResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAlertContactResponse) GoString() string {
	return s.String()
}

func (s *UpdateAlertContactResponse) SetHeaders(v map[string]*string) *UpdateAlertContactResponse {
	s.Headers = v
	return s
}

func (s *UpdateAlertContactResponse) SetStatusCode(v int32) *UpdateAlertContactResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAlertContactResponse) SetBody(v *UpdateAlertContactResponseBody) *UpdateAlertContactResponse {
	s.Body = v
	return s
}

type UpdateAlertContactGroupRequest struct {
	// The ID of the alert contact group.
	ContactGroupId *int64 `json:"ContactGroupId,omitempty" xml:"ContactGroupId,omitempty"`
	// The name of the alert contact group.
	ContactGroupName *string `json:"ContactGroupName,omitempty" xml:"ContactGroupName,omitempty"`
	// The ID of the alert contact.
	ContactIds *string `json:"ContactIds,omitempty" xml:"ContactIds,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateAlertContactGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAlertContactGroupRequest) GoString() string {
	return s.String()
}

func (s *UpdateAlertContactGroupRequest) SetContactGroupId(v int64) *UpdateAlertContactGroupRequest {
	s.ContactGroupId = &v
	return s
}

func (s *UpdateAlertContactGroupRequest) SetContactGroupName(v string) *UpdateAlertContactGroupRequest {
	s.ContactGroupName = &v
	return s
}

func (s *UpdateAlertContactGroupRequest) SetContactIds(v string) *UpdateAlertContactGroupRequest {
	s.ContactIds = &v
	return s
}

func (s *UpdateAlertContactGroupRequest) SetRegionId(v string) *UpdateAlertContactGroupRequest {
	s.RegionId = &v
	return s
}

type UpdateAlertContactGroupResponseBody struct {
	// Indicates whether the call was successful.
	//
	// *   `true`: The call was successful.
	// *   `false`: The call failed.
	IsSuccess *bool `json:"IsSuccess,omitempty" xml:"IsSuccess,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateAlertContactGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAlertContactGroupResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAlertContactGroupResponseBody) SetIsSuccess(v bool) *UpdateAlertContactGroupResponseBody {
	s.IsSuccess = &v
	return s
}

func (s *UpdateAlertContactGroupResponseBody) SetRequestId(v string) *UpdateAlertContactGroupResponseBody {
	s.RequestId = &v
	return s
}

type UpdateAlertContactGroupResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateAlertContactGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateAlertContactGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAlertContactGroupResponse) GoString() string {
	return s.String()
}

func (s *UpdateAlertContactGroupResponse) SetHeaders(v map[string]*string) *UpdateAlertContactGroupResponse {
	s.Headers = v
	return s
}

func (s *UpdateAlertContactGroupResponse) SetStatusCode(v int32) *UpdateAlertContactGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAlertContactGroupResponse) SetBody(v *UpdateAlertContactGroupResponseBody) *UpdateAlertContactGroupResponse {
	s.Body = v
	return s
}

type UpdateAlertRuleRequest struct {
	// The ID of the alert rule.
	AlertId *int64 `json:"AlertId,omitempty" xml:"AlertId,omitempty"`
	// The IDs of the alert contact groups. The value must be a JSON array.
	ContactGroupIds *string `json:"ContactGroupIds,omitempty" xml:"ContactGroupIds,omitempty"`
	// Specifies whether to enable the alert rule after it is created. Default value: `false`.
	//
	// *   `true`: enables the alert rule.
	// *   `false`: disables the alert rule.
	IsAutoStart *bool `json:"IsAutoStart,omitempty" xml:"IsAutoStart,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The configurations of the alert template based on which you want to create an alert rule. The value must be a JSON string. You must set at least one of the **TemplateAlertId** and **TemplageAlertConfig** parameters. If you set both parameters, the **TemplateAlertId** parameter prevails. For more information about the TemplageAlertConfig parameter, see the following **additional information about the TemplageAlertConfig parameter**.
	TemplageAlertConfig *string `json:"TemplageAlertConfig,omitempty" xml:"TemplageAlertConfig,omitempty"`
}

func (s UpdateAlertRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAlertRuleRequest) GoString() string {
	return s.String()
}

func (s *UpdateAlertRuleRequest) SetAlertId(v int64) *UpdateAlertRuleRequest {
	s.AlertId = &v
	return s
}

func (s *UpdateAlertRuleRequest) SetContactGroupIds(v string) *UpdateAlertRuleRequest {
	s.ContactGroupIds = &v
	return s
}

func (s *UpdateAlertRuleRequest) SetIsAutoStart(v bool) *UpdateAlertRuleRequest {
	s.IsAutoStart = &v
	return s
}

func (s *UpdateAlertRuleRequest) SetRegionId(v string) *UpdateAlertRuleRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateAlertRuleRequest) SetTemplageAlertConfig(v string) *UpdateAlertRuleRequest {
	s.TemplageAlertConfig = &v
	return s
}

type UpdateAlertRuleResponseBody struct {
	// The ID of the alert rule.
	AlertId *int64 `json:"AlertId,omitempty" xml:"AlertId,omitempty"`
	// The struct returned.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateAlertRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAlertRuleResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAlertRuleResponseBody) SetAlertId(v int64) *UpdateAlertRuleResponseBody {
	s.AlertId = &v
	return s
}

func (s *UpdateAlertRuleResponseBody) SetData(v string) *UpdateAlertRuleResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateAlertRuleResponseBody) SetRequestId(v string) *UpdateAlertRuleResponseBody {
	s.RequestId = &v
	return s
}

type UpdateAlertRuleResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateAlertRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateAlertRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAlertRuleResponse) GoString() string {
	return s.String()
}

func (s *UpdateAlertRuleResponse) SetHeaders(v map[string]*string) *UpdateAlertRuleResponse {
	s.Headers = v
	return s
}

func (s *UpdateAlertRuleResponse) SetStatusCode(v int32) *UpdateAlertRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAlertRuleResponse) SetBody(v *UpdateAlertRuleResponseBody) *UpdateAlertRuleResponse {
	s.Body = v
	return s
}

type UpdateDispatchRuleRequest struct {
	// ## Additional information about the **DispatchRule** parameter
	//
	// **JSON string example and description**
	//
	// ```
	//
	// {
	//   "id": 123,           // The ID of the dispatch policy.
	//   "system": false,        // Specifies whether the dispatch rule is editable. Valid values: true: not editable. false: editable.
	//   "ruleid": 10282,           // The ID of the dispatch rule.
	//   "name": "Prometheus Alert",   // The name of the dispatch policy.
	//   "labelMatchExpressionGrid": {
	//     "labelMatchExpressionGroups": [     // Sets the dispatch rule.
	//       {
	//         "labelMatchExpressions": [
	//           {
	//             "key": "_aliyun_arms_involvedObject_kind",   // The key of the tag of the dispatch rule. For more information, see the next section.
	//             "value": "app",                              // The value of the tag.
	//             "operator": "eq"                             // The operator used in the dispatch rule. Valid values: eq: equals to. re: matches a regular expression.
	//           }
	//         ]
	//       }
	//     ]
	//   },
	//   "dispatchType": "CREATE_ALERT/DISCARD_ALERT",    // The alert handling method. Valid values: CREATE_ALERT: generates an alert. DISCARD_ALERT: discards the alert event and generates no alert.
	//   "isRecover": true,               // Specifies whether to send the restored alert. Valid values: true: sends the alert. false: does not send the alert.
	//   "groupRules": [                  // Sets the event group.
	//     {
	//       "groupId": 1,               // The ID of the group.
	//       "groupingFields": [         // The fields that are used to group events. Events with the same field content are assigned to a group. Alerts with the same specified grouping field are sent to the handler in separate notifications.
	//         "alertname"
	//       ],
	//       "groupWait": 10,                 // The duration for which the system waits after the first alert is sent. After the duration, all alerts are sent in a single notification to the handler.
	//       "groupInterval": 15,             // The grouping interval. During the silence period of repeated alerts, if new alerts are generated, they will be sent after the group waiting time.
	//       "repeatInterval": 20             // The silence period of repeated alerts. All alerts are repeatedly sent at specified intervals until the alerts are cleared.
	//     }
	//   ],
	//   "notifyRules": [            // Sets the notification rule.
	//     {
	//       "notifyObjects": [
	//         {
	//           "notifyType": "ARMS_CONTACT",     // The type of the alert contact. Valid values: ARMS_CONTACT: contact. ARMS_CONTACT_GROUP: contact group.
	//           "name": "JohnDoe",                // The name of the contact or contact group.
	//           "notifyObjectId": 1               // The ID of the contact or contact group.
	//         },
	//         {
	//           "notifyType": "ARMS_CONTACT_GROUP",
	//           "name": "JohnDoe_group",
	//           "notifyObjectId": 2
	//         }
	//       ],
	//       "notifyChannels":["dingTalk","wechat","webhook","email"]     // The notification method. Valid values: dingTalk, sms, webhook, email, and wechat.
	//     },
	//   ],
	// }
	// ```
	//
	// **Enumerated keys of the tag of the dispatch rule**
	//
	// *   `_aliyun_arms_userid`: user ID
	// *   `_aliyun_arms_involvedObject_kind`: type of the associated object
	// *   `_aliyun_arms_involvedObject_id`: ID of the associated object
	// *   `_aliyun_arms_involvedObject_name`: name of the associated object
	// *   `_aliyun_arms_alert_name`: alert name
	// *   `_aliyun_arms_alert_rule_id`: alert rule ID
	// *   `_aliyun_arms_alert_type`: alert type
	// *   `_aliyun_arms_alert_level`: alert severity
	DispatchRule *string `json:"DispatchRule,omitempty" xml:"DispatchRule,omitempty"`
	RegionId     *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateDispatchRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDispatchRuleRequest) GoString() string {
	return s.String()
}

func (s *UpdateDispatchRuleRequest) SetDispatchRule(v string) *UpdateDispatchRuleRequest {
	s.DispatchRule = &v
	return s
}

func (s *UpdateDispatchRuleRequest) SetRegionId(v string) *UpdateDispatchRuleRequest {
	s.RegionId = &v
	return s
}

type UpdateDispatchRuleResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateDispatchRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDispatchRuleResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDispatchRuleResponseBody) SetRequestId(v string) *UpdateDispatchRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateDispatchRuleResponseBody) SetSuccess(v bool) *UpdateDispatchRuleResponseBody {
	s.Success = &v
	return s
}

type UpdateDispatchRuleResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDispatchRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDispatchRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDispatchRuleResponse) GoString() string {
	return s.String()
}

func (s *UpdateDispatchRuleResponse) SetHeaders(v map[string]*string) *UpdateDispatchRuleResponse {
	s.Headers = v
	return s
}

func (s *UpdateDispatchRuleResponse) SetStatusCode(v int32) *UpdateDispatchRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDispatchRuleResponse) SetBody(v *UpdateDispatchRuleResponseBody) *UpdateDispatchRuleResponse {
	s.Body = v
	return s
}

type UpdateEnvCustomJobRequest struct {
	// The language. Valid values: zh and en. Default value: zh.
	AliyunLang *string `json:"AliyunLang,omitempty" xml:"AliyunLang,omitempty"`
	// The YAML configuration string.
	ConfigYaml *string `json:"ConfigYaml,omitempty" xml:"ConfigYaml,omitempty"`
	// The name of the custom job.
	CustomJobName *string `json:"CustomJobName,omitempty" xml:"CustomJobName,omitempty"`
	// The environment ID.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The status of the custom job. Valid values: run and stop.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s UpdateEnvCustomJobRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateEnvCustomJobRequest) GoString() string {
	return s.String()
}

func (s *UpdateEnvCustomJobRequest) SetAliyunLang(v string) *UpdateEnvCustomJobRequest {
	s.AliyunLang = &v
	return s
}

func (s *UpdateEnvCustomJobRequest) SetConfigYaml(v string) *UpdateEnvCustomJobRequest {
	s.ConfigYaml = &v
	return s
}

func (s *UpdateEnvCustomJobRequest) SetCustomJobName(v string) *UpdateEnvCustomJobRequest {
	s.CustomJobName = &v
	return s
}

func (s *UpdateEnvCustomJobRequest) SetEnvironmentId(v string) *UpdateEnvCustomJobRequest {
	s.EnvironmentId = &v
	return s
}

func (s *UpdateEnvCustomJobRequest) SetRegionId(v string) *UpdateEnvCustomJobRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateEnvCustomJobRequest) SetStatus(v string) *UpdateEnvCustomJobRequest {
	s.Status = &v
	return s
}

type UpdateEnvCustomJobResponseBody struct {
	// The status code or error code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result of the operation.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateEnvCustomJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateEnvCustomJobResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateEnvCustomJobResponseBody) SetCode(v int32) *UpdateEnvCustomJobResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateEnvCustomJobResponseBody) SetData(v string) *UpdateEnvCustomJobResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateEnvCustomJobResponseBody) SetMessage(v string) *UpdateEnvCustomJobResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateEnvCustomJobResponseBody) SetRequestId(v string) *UpdateEnvCustomJobResponseBody {
	s.RequestId = &v
	return s
}

type UpdateEnvCustomJobResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateEnvCustomJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateEnvCustomJobResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateEnvCustomJobResponse) GoString() string {
	return s.String()
}

func (s *UpdateEnvCustomJobResponse) SetHeaders(v map[string]*string) *UpdateEnvCustomJobResponse {
	s.Headers = v
	return s
}

func (s *UpdateEnvCustomJobResponse) SetStatusCode(v int32) *UpdateEnvCustomJobResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateEnvCustomJobResponse) SetBody(v *UpdateEnvCustomJobResponseBody) *UpdateEnvCustomJobResponse {
	s.Body = v
	return s
}

type UpdateEnvPodMonitorRequest struct {
	// The language. Valid values: zh and en. Default value: zh.
	AliyunLang *string `json:"AliyunLang,omitempty" xml:"AliyunLang,omitempty"`
	// The YAML configuration string.
	ConfigYaml *string `json:"ConfigYaml,omitempty" xml:"ConfigYaml,omitempty"`
	// Specifies whether to perform only a dry run, without performing the actual request.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The environment ID.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The namespace where the PodMonitor is located.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The name of the PodMonitor.
	PodMonitorName *string `json:"PodMonitorName,omitempty" xml:"PodMonitorName,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateEnvPodMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateEnvPodMonitorRequest) GoString() string {
	return s.String()
}

func (s *UpdateEnvPodMonitorRequest) SetAliyunLang(v string) *UpdateEnvPodMonitorRequest {
	s.AliyunLang = &v
	return s
}

func (s *UpdateEnvPodMonitorRequest) SetConfigYaml(v string) *UpdateEnvPodMonitorRequest {
	s.ConfigYaml = &v
	return s
}

func (s *UpdateEnvPodMonitorRequest) SetDryRun(v bool) *UpdateEnvPodMonitorRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateEnvPodMonitorRequest) SetEnvironmentId(v string) *UpdateEnvPodMonitorRequest {
	s.EnvironmentId = &v
	return s
}

func (s *UpdateEnvPodMonitorRequest) SetNamespace(v string) *UpdateEnvPodMonitorRequest {
	s.Namespace = &v
	return s
}

func (s *UpdateEnvPodMonitorRequest) SetPodMonitorName(v string) *UpdateEnvPodMonitorRequest {
	s.PodMonitorName = &v
	return s
}

func (s *UpdateEnvPodMonitorRequest) SetRegionId(v string) *UpdateEnvPodMonitorRequest {
	s.RegionId = &v
	return s
}

type UpdateEnvPodMonitorResponseBody struct {
	// The HTTP status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned struct.
	Data *UpdateEnvPodMonitorResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateEnvPodMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateEnvPodMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateEnvPodMonitorResponseBody) SetCode(v int32) *UpdateEnvPodMonitorResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateEnvPodMonitorResponseBody) SetData(v *UpdateEnvPodMonitorResponseBodyData) *UpdateEnvPodMonitorResponseBody {
	s.Data = v
	return s
}

func (s *UpdateEnvPodMonitorResponseBody) SetMessage(v string) *UpdateEnvPodMonitorResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateEnvPodMonitorResponseBody) SetRequestId(v string) *UpdateEnvPodMonitorResponseBody {
	s.RequestId = &v
	return s
}

type UpdateEnvPodMonitorResponseBodyData struct {
	// Indicates whether targets are matched.
	MatchedMsg *string `json:"MatchedMsg,omitempty" xml:"MatchedMsg,omitempty"`
	// The number of matched targets.
	MatchedTargetCount *string `json:"MatchedTargetCount,omitempty" xml:"MatchedTargetCount,omitempty"`
}

func (s UpdateEnvPodMonitorResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s UpdateEnvPodMonitorResponseBodyData) GoString() string {
	return s.String()
}

func (s *UpdateEnvPodMonitorResponseBodyData) SetMatchedMsg(v string) *UpdateEnvPodMonitorResponseBodyData {
	s.MatchedMsg = &v
	return s
}

func (s *UpdateEnvPodMonitorResponseBodyData) SetMatchedTargetCount(v string) *UpdateEnvPodMonitorResponseBodyData {
	s.MatchedTargetCount = &v
	return s
}

type UpdateEnvPodMonitorResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateEnvPodMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateEnvPodMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateEnvPodMonitorResponse) GoString() string {
	return s.String()
}

func (s *UpdateEnvPodMonitorResponse) SetHeaders(v map[string]*string) *UpdateEnvPodMonitorResponse {
	s.Headers = v
	return s
}

func (s *UpdateEnvPodMonitorResponse) SetStatusCode(v int32) *UpdateEnvPodMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateEnvPodMonitorResponse) SetBody(v *UpdateEnvPodMonitorResponseBody) *UpdateEnvPodMonitorResponse {
	s.Body = v
	return s
}

type UpdateEnvServiceMonitorRequest struct {
	// The language. Valid values: zh and en. Default value: zh.
	AliyunLang *string `json:"AliyunLang,omitempty" xml:"AliyunLang,omitempty"`
	// The YAML configuration string.
	ConfigYaml *string `json:"ConfigYaml,omitempty" xml:"ConfigYaml,omitempty"`
	// Specifies whether to perform only a dry run, without performing the actual request.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The environment ID.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The namespace where the ServiceMonitor is located.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The name of the ServiceMonitor.
	ServiceMonitorName *string `json:"ServiceMonitorName,omitempty" xml:"ServiceMonitorName,omitempty"`
}

func (s UpdateEnvServiceMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateEnvServiceMonitorRequest) GoString() string {
	return s.String()
}

func (s *UpdateEnvServiceMonitorRequest) SetAliyunLang(v string) *UpdateEnvServiceMonitorRequest {
	s.AliyunLang = &v
	return s
}

func (s *UpdateEnvServiceMonitorRequest) SetConfigYaml(v string) *UpdateEnvServiceMonitorRequest {
	s.ConfigYaml = &v
	return s
}

func (s *UpdateEnvServiceMonitorRequest) SetDryRun(v bool) *UpdateEnvServiceMonitorRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateEnvServiceMonitorRequest) SetEnvironmentId(v string) *UpdateEnvServiceMonitorRequest {
	s.EnvironmentId = &v
	return s
}

func (s *UpdateEnvServiceMonitorRequest) SetNamespace(v string) *UpdateEnvServiceMonitorRequest {
	s.Namespace = &v
	return s
}

func (s *UpdateEnvServiceMonitorRequest) SetRegionId(v string) *UpdateEnvServiceMonitorRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateEnvServiceMonitorRequest) SetServiceMonitorName(v string) *UpdateEnvServiceMonitorRequest {
	s.ServiceMonitorName = &v
	return s
}

type UpdateEnvServiceMonitorResponseBody struct {
	// The HTTP status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned struct.
	Data *UpdateEnvServiceMonitorResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateEnvServiceMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateEnvServiceMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateEnvServiceMonitorResponseBody) SetCode(v int32) *UpdateEnvServiceMonitorResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateEnvServiceMonitorResponseBody) SetData(v *UpdateEnvServiceMonitorResponseBodyData) *UpdateEnvServiceMonitorResponseBody {
	s.Data = v
	return s
}

func (s *UpdateEnvServiceMonitorResponseBody) SetMessage(v string) *UpdateEnvServiceMonitorResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateEnvServiceMonitorResponseBody) SetRequestId(v string) *UpdateEnvServiceMonitorResponseBody {
	s.RequestId = &v
	return s
}

type UpdateEnvServiceMonitorResponseBodyData struct {
	// Indicates whether targets are matched.
	MatchedMsg *string `json:"MatchedMsg,omitempty" xml:"MatchedMsg,omitempty"`
	// The number of matched targets.
	MatchedTargetCount *string `json:"MatchedTargetCount,omitempty" xml:"MatchedTargetCount,omitempty"`
}

func (s UpdateEnvServiceMonitorResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s UpdateEnvServiceMonitorResponseBodyData) GoString() string {
	return s.String()
}

func (s *UpdateEnvServiceMonitorResponseBodyData) SetMatchedMsg(v string) *UpdateEnvServiceMonitorResponseBodyData {
	s.MatchedMsg = &v
	return s
}

func (s *UpdateEnvServiceMonitorResponseBodyData) SetMatchedTargetCount(v string) *UpdateEnvServiceMonitorResponseBodyData {
	s.MatchedTargetCount = &v
	return s
}

type UpdateEnvServiceMonitorResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateEnvServiceMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateEnvServiceMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateEnvServiceMonitorResponse) GoString() string {
	return s.String()
}

func (s *UpdateEnvServiceMonitorResponse) SetHeaders(v map[string]*string) *UpdateEnvServiceMonitorResponse {
	s.Headers = v
	return s
}

func (s *UpdateEnvServiceMonitorResponse) SetStatusCode(v int32) *UpdateEnvServiceMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateEnvServiceMonitorResponse) SetBody(v *UpdateEnvServiceMonitorResponseBody) *UpdateEnvServiceMonitorResponse {
	s.Body = v
	return s
}

type UpdateEnvironmentRequest struct {
	// Locale, the default is Chinese zh | en.
	AliyunLang *string `json:"AliyunLang,omitempty" xml:"AliyunLang,omitempty"`
	// Environment ID.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// Environment name.
	EnvironmentName *string `json:"EnvironmentName,omitempty" xml:"EnvironmentName,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateEnvironmentRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateEnvironmentRequest) GoString() string {
	return s.String()
}

func (s *UpdateEnvironmentRequest) SetAliyunLang(v string) *UpdateEnvironmentRequest {
	s.AliyunLang = &v
	return s
}

func (s *UpdateEnvironmentRequest) SetEnvironmentId(v string) *UpdateEnvironmentRequest {
	s.EnvironmentId = &v
	return s
}

func (s *UpdateEnvironmentRequest) SetEnvironmentName(v string) *UpdateEnvironmentRequest {
	s.EnvironmentName = &v
	return s
}

func (s *UpdateEnvironmentRequest) SetRegionId(v string) *UpdateEnvironmentRequest {
	s.RegionId = &v
	return s
}

type UpdateEnvironmentResponseBody struct {
	// The status code or error code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateEnvironmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateEnvironmentResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateEnvironmentResponseBody) SetCode(v int32) *UpdateEnvironmentResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateEnvironmentResponseBody) SetData(v string) *UpdateEnvironmentResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateEnvironmentResponseBody) SetMessage(v string) *UpdateEnvironmentResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateEnvironmentResponseBody) SetRequestId(v string) *UpdateEnvironmentResponseBody {
	s.RequestId = &v
	return s
}

type UpdateEnvironmentResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateEnvironmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateEnvironmentResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateEnvironmentResponse) GoString() string {
	return s.String()
}

func (s *UpdateEnvironmentResponse) SetHeaders(v map[string]*string) *UpdateEnvironmentResponse {
	s.Headers = v
	return s
}

func (s *UpdateEnvironmentResponse) SetStatusCode(v int32) *UpdateEnvironmentResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateEnvironmentResponse) SetBody(v *UpdateEnvironmentResponseBody) *UpdateEnvironmentResponse {
	s.Body = v
	return s
}

type UpdateGrafanaWorkspaceRequest struct {
	AliyunLang           *string `json:"AliyunLang,omitempty" xml:"AliyunLang,omitempty"`
	Description          *string `json:"Description,omitempty" xml:"Description,omitempty"`
	GrafanaWorkspaceId   *string `json:"GrafanaWorkspaceId,omitempty" xml:"GrafanaWorkspaceId,omitempty"`
	GrafanaWorkspaceName *string `json:"GrafanaWorkspaceName,omitempty" xml:"GrafanaWorkspaceName,omitempty"`
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateGrafanaWorkspaceRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGrafanaWorkspaceRequest) GoString() string {
	return s.String()
}

func (s *UpdateGrafanaWorkspaceRequest) SetAliyunLang(v string) *UpdateGrafanaWorkspaceRequest {
	s.AliyunLang = &v
	return s
}

func (s *UpdateGrafanaWorkspaceRequest) SetDescription(v string) *UpdateGrafanaWorkspaceRequest {
	s.Description = &v
	return s
}

func (s *UpdateGrafanaWorkspaceRequest) SetGrafanaWorkspaceId(v string) *UpdateGrafanaWorkspaceRequest {
	s.GrafanaWorkspaceId = &v
	return s
}

func (s *UpdateGrafanaWorkspaceRequest) SetGrafanaWorkspaceName(v string) *UpdateGrafanaWorkspaceRequest {
	s.GrafanaWorkspaceName = &v
	return s
}

func (s *UpdateGrafanaWorkspaceRequest) SetRegionId(v string) *UpdateGrafanaWorkspaceRequest {
	s.RegionId = &v
	return s
}

type UpdateGrafanaWorkspaceResponseBody struct {
	Code    *int32  `json:"Code,omitempty" xml:"Code,omitempty"`
	Data    *bool   `json:"Data,omitempty" xml:"Data,omitempty"`
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
	TraceId   *string `json:"TraceId,omitempty" xml:"TraceId,omitempty"`
}

func (s UpdateGrafanaWorkspaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGrafanaWorkspaceResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGrafanaWorkspaceResponseBody) SetCode(v int32) *UpdateGrafanaWorkspaceResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGrafanaWorkspaceResponseBody) SetData(v bool) *UpdateGrafanaWorkspaceResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGrafanaWorkspaceResponseBody) SetMessage(v string) *UpdateGrafanaWorkspaceResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGrafanaWorkspaceResponseBody) SetRequestId(v string) *UpdateGrafanaWorkspaceResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGrafanaWorkspaceResponseBody) SetSuccess(v bool) *UpdateGrafanaWorkspaceResponseBody {
	s.Success = &v
	return s
}

func (s *UpdateGrafanaWorkspaceResponseBody) SetTraceId(v string) *UpdateGrafanaWorkspaceResponseBody {
	s.TraceId = &v
	return s
}

type UpdateGrafanaWorkspaceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGrafanaWorkspaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGrafanaWorkspaceResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGrafanaWorkspaceResponse) GoString() string {
	return s.String()
}

func (s *UpdateGrafanaWorkspaceResponse) SetHeaders(v map[string]*string) *UpdateGrafanaWorkspaceResponse {
	s.Headers = v
	return s
}

func (s *UpdateGrafanaWorkspaceResponse) SetStatusCode(v int32) *UpdateGrafanaWorkspaceResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGrafanaWorkspaceResponse) SetBody(v *UpdateGrafanaWorkspaceResponseBody) *UpdateGrafanaWorkspaceResponse {
	s.Body = v
	return s
}

type UpdateGrafanaWorkspaceVersionRequest struct {
	AliyunLang         *string `json:"AliyunLang,omitempty" xml:"AliyunLang,omitempty"`
	GrafanaVersion     *string `json:"GrafanaVersion,omitempty" xml:"GrafanaVersion,omitempty"`
	GrafanaWorkspaceId *string `json:"GrafanaWorkspaceId,omitempty" xml:"GrafanaWorkspaceId,omitempty"`
	RegionId           *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateGrafanaWorkspaceVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGrafanaWorkspaceVersionRequest) GoString() string {
	return s.String()
}

func (s *UpdateGrafanaWorkspaceVersionRequest) SetAliyunLang(v string) *UpdateGrafanaWorkspaceVersionRequest {
	s.AliyunLang = &v
	return s
}

func (s *UpdateGrafanaWorkspaceVersionRequest) SetGrafanaVersion(v string) *UpdateGrafanaWorkspaceVersionRequest {
	s.GrafanaVersion = &v
	return s
}

func (s *UpdateGrafanaWorkspaceVersionRequest) SetGrafanaWorkspaceId(v string) *UpdateGrafanaWorkspaceVersionRequest {
	s.GrafanaWorkspaceId = &v
	return s
}

func (s *UpdateGrafanaWorkspaceVersionRequest) SetRegionId(v string) *UpdateGrafanaWorkspaceVersionRequest {
	s.RegionId = &v
	return s
}

type UpdateGrafanaWorkspaceVersionResponseBody struct {
	Code    *int32  `json:"Code,omitempty" xml:"Code,omitempty"`
	Data    *bool   `json:"Data,omitempty" xml:"Data,omitempty"`
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
	TraceId   *string `json:"TraceId,omitempty" xml:"TraceId,omitempty"`
}

func (s UpdateGrafanaWorkspaceVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGrafanaWorkspaceVersionResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGrafanaWorkspaceVersionResponseBody) SetCode(v int32) *UpdateGrafanaWorkspaceVersionResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateGrafanaWorkspaceVersionResponseBody) SetData(v bool) *UpdateGrafanaWorkspaceVersionResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateGrafanaWorkspaceVersionResponseBody) SetMessage(v string) *UpdateGrafanaWorkspaceVersionResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateGrafanaWorkspaceVersionResponseBody) SetRequestId(v string) *UpdateGrafanaWorkspaceVersionResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateGrafanaWorkspaceVersionResponseBody) SetSuccess(v bool) *UpdateGrafanaWorkspaceVersionResponseBody {
	s.Success = &v
	return s
}

func (s *UpdateGrafanaWorkspaceVersionResponseBody) SetTraceId(v string) *UpdateGrafanaWorkspaceVersionResponseBody {
	s.TraceId = &v
	return s
}

type UpdateGrafanaWorkspaceVersionResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGrafanaWorkspaceVersionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGrafanaWorkspaceVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGrafanaWorkspaceVersionResponse) GoString() string {
	return s.String()
}

func (s *UpdateGrafanaWorkspaceVersionResponse) SetHeaders(v map[string]*string) *UpdateGrafanaWorkspaceVersionResponse {
	s.Headers = v
	return s
}

func (s *UpdateGrafanaWorkspaceVersionResponse) SetStatusCode(v int32) *UpdateGrafanaWorkspaceVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGrafanaWorkspaceVersionResponse) SetBody(v *UpdateGrafanaWorkspaceVersionResponseBody) *UpdateGrafanaWorkspaceVersionResponse {
	s.Body = v
	return s
}

type UpdateIntegrationRequest struct {
	// Specifies whether to automatically clear alert events. Valid values:
	//
	// *   true (default)
	// *   false
	AutoRecover *bool `json:"AutoRecover,omitempty" xml:"AutoRecover,omitempty"`
	// The description of the alert integration.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The fields whose values are deduplicated.
	DuplicateKey *string `json:"DuplicateKey,omitempty" xml:"DuplicateKey,omitempty"`
	// The extended mapped fields are mapped to the fields of ARMS alerts. For more information, see the description of the ExtendedFieldRedefineRules parameter.
	ExtendedFieldRedefineRules *string `json:"ExtendedFieldRedefineRules,omitempty" xml:"ExtendedFieldRedefineRules,omitempty"`
	// The predefined mapped fields are mapped to the fields of ARMS alerts. The predefined mapped fields were generated when the alert integration was created. For more information, see the description of the FieldRedefineRules parameter.
	FieldRedefineRules *string `json:"FieldRedefineRules,omitempty" xml:"FieldRedefineRules,omitempty"`
	// The field for clearing alert events. The system queries alert events based on the field of alert clearing events and clears the alert events.
	//
	// > Only the Log Service alert integration supports the parameter.
	InitiativeRecoverField *string `json:"InitiativeRecoverField,omitempty" xml:"InitiativeRecoverField,omitempty"`
	// The value of the field for clearing alert events. The system queries alert events based on the field of alert clearing events and clears the alert events.
	//
	// > Only the Log Service alert integration supports the parameter.
	InitiativeRecoverValue *string `json:"InitiativeRecoverValue,omitempty" xml:"InitiativeRecoverValue,omitempty"`
	// The ID of the alert integration.
	IntegrationId *int64 `json:"IntegrationId,omitempty" xml:"IntegrationId,omitempty"`
	// The name of the alert integration.
	IntegrationName *string `json:"IntegrationName,omitempty" xml:"IntegrationName,omitempty"`
	// The service of the alert integration. Valid values:
	//
	// *   CLOUD_MONITOR: CloudMonitor
	// *   LOG_SERVICE: Log Service
	IntegrationProductType *string `json:"IntegrationProductType,omitempty" xml:"IntegrationProductType,omitempty"`
	// The activity of the alert integration
	Liveness *string `json:"Liveness,omitempty" xml:"Liveness,omitempty"`
	// The period of time within which alert events are automatically cleared. Unit: seconds. Default value: 300.
	RecoverTime *int64 `json:"RecoverTime,omitempty" xml:"RecoverTime,omitempty"`
	// The total number of alert events and the number of abnormal alert events in the last hour.
	Stat *string `json:"Stat,omitempty" xml:"Stat,omitempty"`
	// Indicates whether the alert integration was enabled. Valid values:
	//
	// *   true
	// *   false
	State *bool `json:"State,omitempty" xml:"State,omitempty"`
}

func (s UpdateIntegrationRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateIntegrationRequest) GoString() string {
	return s.String()
}

func (s *UpdateIntegrationRequest) SetAutoRecover(v bool) *UpdateIntegrationRequest {
	s.AutoRecover = &v
	return s
}

func (s *UpdateIntegrationRequest) SetDescription(v string) *UpdateIntegrationRequest {
	s.Description = &v
	return s
}

func (s *UpdateIntegrationRequest) SetDuplicateKey(v string) *UpdateIntegrationRequest {
	s.DuplicateKey = &v
	return s
}

func (s *UpdateIntegrationRequest) SetExtendedFieldRedefineRules(v string) *UpdateIntegrationRequest {
	s.ExtendedFieldRedefineRules = &v
	return s
}

func (s *UpdateIntegrationRequest) SetFieldRedefineRules(v string) *UpdateIntegrationRequest {
	s.FieldRedefineRules = &v
	return s
}

func (s *UpdateIntegrationRequest) SetInitiativeRecoverField(v string) *UpdateIntegrationRequest {
	s.InitiativeRecoverField = &v
	return s
}

func (s *UpdateIntegrationRequest) SetInitiativeRecoverValue(v string) *UpdateIntegrationRequest {
	s.InitiativeRecoverValue = &v
	return s
}

func (s *UpdateIntegrationRequest) SetIntegrationId(v int64) *UpdateIntegrationRequest {
	s.IntegrationId = &v
	return s
}

func (s *UpdateIntegrationRequest) SetIntegrationName(v string) *UpdateIntegrationRequest {
	s.IntegrationName = &v
	return s
}

func (s *UpdateIntegrationRequest) SetIntegrationProductType(v string) *UpdateIntegrationRequest {
	s.IntegrationProductType = &v
	return s
}

func (s *UpdateIntegrationRequest) SetLiveness(v string) *UpdateIntegrationRequest {
	s.Liveness = &v
	return s
}

func (s *UpdateIntegrationRequest) SetRecoverTime(v int64) *UpdateIntegrationRequest {
	s.RecoverTime = &v
	return s
}

func (s *UpdateIntegrationRequest) SetStat(v string) *UpdateIntegrationRequest {
	s.Stat = &v
	return s
}

func (s *UpdateIntegrationRequest) SetState(v bool) *UpdateIntegrationRequest {
	s.State = &v
	return s
}

type UpdateIntegrationResponseBody struct {
	// The Information about the alert integration.
	Integration *UpdateIntegrationResponseBodyIntegration `json:"Integration,omitempty" xml:"Integration,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateIntegrationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateIntegrationResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateIntegrationResponseBody) SetIntegration(v *UpdateIntegrationResponseBodyIntegration) *UpdateIntegrationResponseBody {
	s.Integration = v
	return s
}

func (s *UpdateIntegrationResponseBody) SetRequestId(v string) *UpdateIntegrationResponseBody {
	s.RequestId = &v
	return s
}

type UpdateIntegrationResponseBodyIntegration struct {
	// The endpoint of the alert integration.
	ApiEndpoint *string `json:"ApiEndpoint,omitempty" xml:"ApiEndpoint,omitempty"`
	// Indicates whether alert events are automatically cleared. Valid values:
	//
	// *   true (default)
	// *   false
	AutoRecover *bool `json:"AutoRecover,omitempty" xml:"AutoRecover,omitempty"`
	// The description of the alert integration.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The fields whose values are deduplicated.
	DuplicateKey *string `json:"DuplicateKey,omitempty" xml:"DuplicateKey,omitempty"`
	// The extended mapped fields of the alert source.
	ExtendedFieldRedefineRules []map[string]interface{} `json:"ExtendedFieldRedefineRules,omitempty" xml:"ExtendedFieldRedefineRules,omitempty" type:"Repeated"`
	// The predefined mapped fields of the alert source.
	FieldRedefineRules []map[string]interface{} `json:"FieldRedefineRules,omitempty" xml:"FieldRedefineRules,omitempty" type:"Repeated"`
	// The field for clearing alert events. The system queries alert events based on the field of alert clearing events and clears the alert events.
	//
	// > Only Log Service supports this parameter.
	InitiativeRecoverField *string `json:"InitiativeRecoverField,omitempty" xml:"InitiativeRecoverField,omitempty"`
	// The value of the field for clearing alert events. The system queries alert events based on the field of alert clearing events and clears the alert events.
	//
	// > Only Log Service supports this parameter.
	InitiativeRecoverValue *string `json:"InitiativeRecoverValue,omitempty" xml:"InitiativeRecoverValue,omitempty"`
	// The ID of the alert integration.
	IntegrationId *int64 `json:"IntegrationId,omitempty" xml:"IntegrationId,omitempty"`
	// The name of the alert integration.
	IntegrationName *string `json:"IntegrationName,omitempty" xml:"IntegrationName,omitempty"`
	// The service of the alert integration. Valid values:
	//
	// *   CLOUD_MONITOR: CloudMonitor
	// *   LOG_SERVICE: Log Service
	IntegrationProductType *string `json:"IntegrationProductType,omitempty" xml:"IntegrationProductType,omitempty"`
	// The activity of the alert integration
	Liveness *string `json:"Liveness,omitempty" xml:"Liveness,omitempty"`
	// The time when alert events are automatically cleared. Unit: seconds. Default value: 300.
	RecoverTime *int64 `json:"RecoverTime,omitempty" xml:"RecoverTime,omitempty"`
	// The authentication token of the alert integration.
	ShortToken *string `json:"ShortToken,omitempty" xml:"ShortToken,omitempty"`
	// The total number of alert events and the number of abnormal alert events in the last hour.
	Stat []*int64 `json:"Stat,omitempty" xml:"Stat,omitempty" type:"Repeated"`
	// Indicates whether the alert integration is enabled. Valid values:
	//
	// *   true
	// *   false
	State *bool `json:"State,omitempty" xml:"State,omitempty"`
}

func (s UpdateIntegrationResponseBodyIntegration) String() string {
	return tea.Prettify(s)
}

func (s UpdateIntegrationResponseBodyIntegration) GoString() string {
	return s.String()
}

func (s *UpdateIntegrationResponseBodyIntegration) SetApiEndpoint(v string) *UpdateIntegrationResponseBodyIntegration {
	s.ApiEndpoint = &v
	return s
}

func (s *UpdateIntegrationResponseBodyIntegration) SetAutoRecover(v bool) *UpdateIntegrationResponseBodyIntegration {
	s.AutoRecover = &v
	return s
}

func (s *UpdateIntegrationResponseBodyIntegration) SetDescription(v string) *UpdateIntegrationResponseBodyIntegration {
	s.Description = &v
	return s
}

func (s *UpdateIntegrationResponseBodyIntegration) SetDuplicateKey(v string) *UpdateIntegrationResponseBodyIntegration {
	s.DuplicateKey = &v
	return s
}

func (s *UpdateIntegrationResponseBodyIntegration) SetExtendedFieldRedefineRules(v []map[string]interface{}) *UpdateIntegrationResponseBodyIntegration {
	s.ExtendedFieldRedefineRules = v
	return s
}

func (s *UpdateIntegrationResponseBodyIntegration) SetFieldRedefineRules(v []map[string]interface{}) *UpdateIntegrationResponseBodyIntegration {
	s.FieldRedefineRules = v
	return s
}

func (s *UpdateIntegrationResponseBodyIntegration) SetInitiativeRecoverField(v string) *UpdateIntegrationResponseBodyIntegration {
	s.InitiativeRecoverField = &v
	return s
}

func (s *UpdateIntegrationResponseBodyIntegration) SetInitiativeRecoverValue(v string) *UpdateIntegrationResponseBodyIntegration {
	s.InitiativeRecoverValue = &v
	return s
}

func (s *UpdateIntegrationResponseBodyIntegration) SetIntegrationId(v int64) *UpdateIntegrationResponseBodyIntegration {
	s.IntegrationId = &v
	return s
}

func (s *UpdateIntegrationResponseBodyIntegration) SetIntegrationName(v string) *UpdateIntegrationResponseBodyIntegration {
	s.IntegrationName = &v
	return s
}

func (s *UpdateIntegrationResponseBodyIntegration) SetIntegrationProductType(v string) *UpdateIntegrationResponseBodyIntegration {
	s.IntegrationProductType = &v
	return s
}

func (s *UpdateIntegrationResponseBodyIntegration) SetLiveness(v string) *UpdateIntegrationResponseBodyIntegration {
	s.Liveness = &v
	return s
}

func (s *UpdateIntegrationResponseBodyIntegration) SetRecoverTime(v int64) *UpdateIntegrationResponseBodyIntegration {
	s.RecoverTime = &v
	return s
}

func (s *UpdateIntegrationResponseBodyIntegration) SetShortToken(v string) *UpdateIntegrationResponseBodyIntegration {
	s.ShortToken = &v
	return s
}

func (s *UpdateIntegrationResponseBodyIntegration) SetStat(v []*int64) *UpdateIntegrationResponseBodyIntegration {
	s.Stat = v
	return s
}

func (s *UpdateIntegrationResponseBodyIntegration) SetState(v bool) *UpdateIntegrationResponseBodyIntegration {
	s.State = &v
	return s
}

type UpdateIntegrationResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateIntegrationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateIntegrationResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateIntegrationResponse) GoString() string {
	return s.String()
}

func (s *UpdateIntegrationResponse) SetHeaders(v map[string]*string) *UpdateIntegrationResponse {
	s.Headers = v
	return s
}

func (s *UpdateIntegrationResponse) SetStatusCode(v int32) *UpdateIntegrationResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateIntegrationResponse) SetBody(v *UpdateIntegrationResponseBody) *UpdateIntegrationResponse {
	s.Body = v
	return s
}

type UpdateMetricDropRequest struct {
	ClusterId  *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	MetricDrop *string `json:"MetricDrop,omitempty" xml:"MetricDrop,omitempty"`
	RegionId   *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdateMetricDropRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateMetricDropRequest) GoString() string {
	return s.String()
}

func (s *UpdateMetricDropRequest) SetClusterId(v string) *UpdateMetricDropRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdateMetricDropRequest) SetMetricDrop(v string) *UpdateMetricDropRequest {
	s.MetricDrop = &v
	return s
}

func (s *UpdateMetricDropRequest) SetRegionId(v string) *UpdateMetricDropRequest {
	s.RegionId = &v
	return s
}

type UpdateMetricDropResponseBody struct {
	Code    *int64  `json:"Code,omitempty" xml:"Code,omitempty"`
	Data    *string `json:"Data,omitempty" xml:"Data,omitempty"`
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateMetricDropResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateMetricDropResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateMetricDropResponseBody) SetCode(v int64) *UpdateMetricDropResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateMetricDropResponseBody) SetData(v string) *UpdateMetricDropResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateMetricDropResponseBody) SetMessage(v string) *UpdateMetricDropResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateMetricDropResponseBody) SetRequestId(v string) *UpdateMetricDropResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateMetricDropResponseBody) SetSuccess(v bool) *UpdateMetricDropResponseBody {
	s.Success = &v
	return s
}

type UpdateMetricDropResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateMetricDropResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateMetricDropResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateMetricDropResponse) GoString() string {
	return s.String()
}

func (s *UpdateMetricDropResponse) SetHeaders(v map[string]*string) *UpdateMetricDropResponse {
	s.Headers = v
	return s
}

func (s *UpdateMetricDropResponse) SetStatusCode(v int32) *UpdateMetricDropResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateMetricDropResponse) SetBody(v *UpdateMetricDropResponseBody) *UpdateMetricDropResponse {
	s.Body = v
	return s
}

type UpdatePrometheusAlertRuleRequest struct {
	AlertId        *int64                                  `json:"AlertId,omitempty" xml:"AlertId,omitempty"`
	AlertName      *string                                 `json:"AlertName,omitempty" xml:"AlertName,omitempty"`
	Annotations    *string                                 `json:"Annotations,omitempty" xml:"Annotations,omitempty"`
	ClusterId      *string                                 `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	DispatchRuleId *int64                                  `json:"DispatchRuleId,omitempty" xml:"DispatchRuleId,omitempty"`
	Duration       *string                                 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	Expression     *string                                 `json:"Expression,omitempty" xml:"Expression,omitempty"`
	Labels         *string                                 `json:"Labels,omitempty" xml:"Labels,omitempty"`
	Message        *string                                 `json:"Message,omitempty" xml:"Message,omitempty"`
	NotifyType     *string                                 `json:"NotifyType,omitempty" xml:"NotifyType,omitempty"`
	RegionId       *string                                 `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	Tags           []*UpdatePrometheusAlertRuleRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	Type           *string                                 `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdatePrometheusAlertRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusAlertRuleRequest) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusAlertRuleRequest) SetAlertId(v int64) *UpdatePrometheusAlertRuleRequest {
	s.AlertId = &v
	return s
}

func (s *UpdatePrometheusAlertRuleRequest) SetAlertName(v string) *UpdatePrometheusAlertRuleRequest {
	s.AlertName = &v
	return s
}

func (s *UpdatePrometheusAlertRuleRequest) SetAnnotations(v string) *UpdatePrometheusAlertRuleRequest {
	s.Annotations = &v
	return s
}

func (s *UpdatePrometheusAlertRuleRequest) SetClusterId(v string) *UpdatePrometheusAlertRuleRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdatePrometheusAlertRuleRequest) SetDispatchRuleId(v int64) *UpdatePrometheusAlertRuleRequest {
	s.DispatchRuleId = &v
	return s
}

func (s *UpdatePrometheusAlertRuleRequest) SetDuration(v string) *UpdatePrometheusAlertRuleRequest {
	s.Duration = &v
	return s
}

func (s *UpdatePrometheusAlertRuleRequest) SetExpression(v string) *UpdatePrometheusAlertRuleRequest {
	s.Expression = &v
	return s
}

func (s *UpdatePrometheusAlertRuleRequest) SetLabels(v string) *UpdatePrometheusAlertRuleRequest {
	s.Labels = &v
	return s
}

func (s *UpdatePrometheusAlertRuleRequest) SetMessage(v string) *UpdatePrometheusAlertRuleRequest {
	s.Message = &v
	return s
}

func (s *UpdatePrometheusAlertRuleRequest) SetNotifyType(v string) *UpdatePrometheusAlertRuleRequest {
	s.NotifyType = &v
	return s
}

func (s *UpdatePrometheusAlertRuleRequest) SetRegionId(v string) *UpdatePrometheusAlertRuleRequest {
	s.RegionId = &v
	return s
}

func (s *UpdatePrometheusAlertRuleRequest) SetTags(v []*UpdatePrometheusAlertRuleRequestTags) *UpdatePrometheusAlertRuleRequest {
	s.Tags = v
	return s
}

func (s *UpdatePrometheusAlertRuleRequest) SetType(v string) *UpdatePrometheusAlertRuleRequest {
	s.Type = &v
	return s
}

type UpdatePrometheusAlertRuleRequestTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s UpdatePrometheusAlertRuleRequestTags) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusAlertRuleRequestTags) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusAlertRuleRequestTags) SetKey(v string) *UpdatePrometheusAlertRuleRequestTags {
	s.Key = &v
	return s
}

func (s *UpdatePrometheusAlertRuleRequestTags) SetValue(v string) *UpdatePrometheusAlertRuleRequestTags {
	s.Value = &v
	return s
}

type UpdatePrometheusAlertRuleResponseBody struct {
	Code                *int64                                                    `json:"Code,omitempty" xml:"Code,omitempty"`
	Message             *string                                                   `json:"Message,omitempty" xml:"Message,omitempty"`
	PrometheusAlertRule *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule `json:"PrometheusAlertRule,omitempty" xml:"PrometheusAlertRule,omitempty" type:"Struct"`
	RequestId           *string                                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success             *bool                                                     `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdatePrometheusAlertRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusAlertRuleResponseBody) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusAlertRuleResponseBody) SetCode(v int64) *UpdatePrometheusAlertRuleResponseBody {
	s.Code = &v
	return s
}

func (s *UpdatePrometheusAlertRuleResponseBody) SetMessage(v string) *UpdatePrometheusAlertRuleResponseBody {
	s.Message = &v
	return s
}

func (s *UpdatePrometheusAlertRuleResponseBody) SetPrometheusAlertRule(v *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule) *UpdatePrometheusAlertRuleResponseBody {
	s.PrometheusAlertRule = v
	return s
}

func (s *UpdatePrometheusAlertRuleResponseBody) SetRequestId(v string) *UpdatePrometheusAlertRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdatePrometheusAlertRuleResponseBody) SetSuccess(v bool) *UpdatePrometheusAlertRuleResponseBody {
	s.Success = &v
	return s
}

type UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule struct {
	AlertId        *int64                                                                 `json:"AlertId,omitempty" xml:"AlertId,omitempty"`
	AlertName      *string                                                                `json:"AlertName,omitempty" xml:"AlertName,omitempty"`
	Annotations    []*UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations `json:"Annotations,omitempty" xml:"Annotations,omitempty" type:"Repeated"`
	ClusterId      *string                                                                `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	DispatchRuleId *int64                                                                 `json:"DispatchRuleId,omitempty" xml:"DispatchRuleId,omitempty"`
	Duration       *string                                                                `json:"Duration,omitempty" xml:"Duration,omitempty"`
	Expression     *string                                                                `json:"Expression,omitempty" xml:"Expression,omitempty"`
	Labels         []*UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels      `json:"Labels,omitempty" xml:"Labels,omitempty" type:"Repeated"`
	Message        *string                                                                `json:"Message,omitempty" xml:"Message,omitempty"`
	NotifyType     *string                                                                `json:"NotifyType,omitempty" xml:"NotifyType,omitempty"`
	Status         *int32                                                                 `json:"Status,omitempty" xml:"Status,omitempty"`
	Type           *string                                                                `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetAlertId(v int64) *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.AlertId = &v
	return s
}

func (s *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetAlertName(v string) *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.AlertName = &v
	return s
}

func (s *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetAnnotations(v []*UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations) *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.Annotations = v
	return s
}

func (s *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetClusterId(v string) *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.ClusterId = &v
	return s
}

func (s *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetDispatchRuleId(v int64) *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.DispatchRuleId = &v
	return s
}

func (s *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetDuration(v string) *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.Duration = &v
	return s
}

func (s *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetExpression(v string) *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.Expression = &v
	return s
}

func (s *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetLabels(v []*UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels) *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.Labels = v
	return s
}

func (s *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetMessage(v string) *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.Message = &v
	return s
}

func (s *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetNotifyType(v string) *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.NotifyType = &v
	return s
}

func (s *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetStatus(v int32) *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.Status = &v
	return s
}

func (s *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule) SetType(v string) *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRule {
	s.Type = &v
	return s
}

type UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations struct {
	Name  *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations) SetName(v string) *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations {
	s.Name = &v
	return s
}

func (s *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations) SetValue(v string) *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleAnnotations {
	s.Value = &v
	return s
}

type UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels struct {
	Name  *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels) SetName(v string) *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels {
	s.Name = &v
	return s
}

func (s *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels) SetValue(v string) *UpdatePrometheusAlertRuleResponseBodyPrometheusAlertRuleLabels {
	s.Value = &v
	return s
}

type UpdatePrometheusAlertRuleResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdatePrometheusAlertRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdatePrometheusAlertRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusAlertRuleResponse) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusAlertRuleResponse) SetHeaders(v map[string]*string) *UpdatePrometheusAlertRuleResponse {
	s.Headers = v
	return s
}

func (s *UpdatePrometheusAlertRuleResponse) SetStatusCode(v int32) *UpdatePrometheusAlertRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdatePrometheusAlertRuleResponse) SetBody(v *UpdatePrometheusAlertRuleResponseBody) *UpdatePrometheusAlertRuleResponse {
	s.Body = v
	return s
}

type UpdatePrometheusGlobalViewRequest struct {
	// To edit a GlobalView aggregated instance, do you require all passed child instances to be verified successfully before creating a GlobalView instance (optional, default to false):
	// - true
	// - false
	AllSubClustersSuccess *bool `json:"AllSubClustersSuccess,omitempty" xml:"AllSubClustersSuccess,omitempty"`
	// The ID of the Prometheus instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the global aggregation instance.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The region ID of the global aggregation instance.
	MostRegionId *string `json:"MostRegionId,omitempty" xml:"MostRegionId,omitempty"`
	// The ID of the region in which the Prometheus instance resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the Prometheus instance belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The data sources of the Prometheus instance for GlobalView.
	SubClustersJson *string `json:"SubClustersJson,omitempty" xml:"SubClustersJson,omitempty"`
}

func (s UpdatePrometheusGlobalViewRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusGlobalViewRequest) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusGlobalViewRequest) SetAllSubClustersSuccess(v bool) *UpdatePrometheusGlobalViewRequest {
	s.AllSubClustersSuccess = &v
	return s
}

func (s *UpdatePrometheusGlobalViewRequest) SetClusterId(v string) *UpdatePrometheusGlobalViewRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdatePrometheusGlobalViewRequest) SetGroupName(v string) *UpdatePrometheusGlobalViewRequest {
	s.GroupName = &v
	return s
}

func (s *UpdatePrometheusGlobalViewRequest) SetMostRegionId(v string) *UpdatePrometheusGlobalViewRequest {
	s.MostRegionId = &v
	return s
}

func (s *UpdatePrometheusGlobalViewRequest) SetRegionId(v string) *UpdatePrometheusGlobalViewRequest {
	s.RegionId = &v
	return s
}

func (s *UpdatePrometheusGlobalViewRequest) SetResourceGroupId(v string) *UpdatePrometheusGlobalViewRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *UpdatePrometheusGlobalViewRequest) SetSubClustersJson(v string) *UpdatePrometheusGlobalViewRequest {
	s.SubClustersJson = &v
	return s
}

type UpdatePrometheusGlobalViewResponseBody struct {
	// The response code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned struct.
	Data *UpdatePrometheusGlobalViewResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message that is returned if the request failed.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdatePrometheusGlobalViewResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusGlobalViewResponseBody) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusGlobalViewResponseBody) SetCode(v int32) *UpdatePrometheusGlobalViewResponseBody {
	s.Code = &v
	return s
}

func (s *UpdatePrometheusGlobalViewResponseBody) SetData(v *UpdatePrometheusGlobalViewResponseBodyData) *UpdatePrometheusGlobalViewResponseBody {
	s.Data = v
	return s
}

func (s *UpdatePrometheusGlobalViewResponseBody) SetMessage(v string) *UpdatePrometheusGlobalViewResponseBody {
	s.Message = &v
	return s
}

func (s *UpdatePrometheusGlobalViewResponseBody) SetRequestId(v string) *UpdatePrometheusGlobalViewResponseBody {
	s.RequestId = &v
	return s
}

type UpdatePrometheusGlobalViewResponseBodyData struct {
	// The data sources that failed to be updated.
	FailedInstances []*UpdatePrometheusGlobalViewResponseBodyDataFailedInstances `json:"FailedInstances,omitempty" xml:"FailedInstances,omitempty" type:"Repeated"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`
	// *   `false`
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdatePrometheusGlobalViewResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusGlobalViewResponseBodyData) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusGlobalViewResponseBodyData) SetFailedInstances(v []*UpdatePrometheusGlobalViewResponseBodyDataFailedInstances) *UpdatePrometheusGlobalViewResponseBodyData {
	s.FailedInstances = v
	return s
}

func (s *UpdatePrometheusGlobalViewResponseBodyData) SetSuccess(v bool) *UpdatePrometheusGlobalViewResponseBodyData {
	s.Success = &v
	return s
}

type UpdatePrometheusGlobalViewResponseBodyDataFailedInstances struct {
	// The ID of the Prometheus instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the data source.
	SourceName *string `json:"SourceName,omitempty" xml:"SourceName,omitempty"`
	// The type of the data source. AlibabaPrometheus MetricStore CustomPrometheus
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The user ID.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s UpdatePrometheusGlobalViewResponseBodyDataFailedInstances) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusGlobalViewResponseBodyDataFailedInstances) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusGlobalViewResponseBodyDataFailedInstances) SetClusterId(v string) *UpdatePrometheusGlobalViewResponseBodyDataFailedInstances {
	s.ClusterId = &v
	return s
}

func (s *UpdatePrometheusGlobalViewResponseBodyDataFailedInstances) SetSourceName(v string) *UpdatePrometheusGlobalViewResponseBodyDataFailedInstances {
	s.SourceName = &v
	return s
}

func (s *UpdatePrometheusGlobalViewResponseBodyDataFailedInstances) SetSourceType(v string) *UpdatePrometheusGlobalViewResponseBodyDataFailedInstances {
	s.SourceType = &v
	return s
}

func (s *UpdatePrometheusGlobalViewResponseBodyDataFailedInstances) SetUserId(v string) *UpdatePrometheusGlobalViewResponseBodyDataFailedInstances {
	s.UserId = &v
	return s
}

type UpdatePrometheusGlobalViewResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdatePrometheusGlobalViewResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdatePrometheusGlobalViewResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusGlobalViewResponse) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusGlobalViewResponse) SetHeaders(v map[string]*string) *UpdatePrometheusGlobalViewResponse {
	s.Headers = v
	return s
}

func (s *UpdatePrometheusGlobalViewResponse) SetStatusCode(v int32) *UpdatePrometheusGlobalViewResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdatePrometheusGlobalViewResponse) SetBody(v *UpdatePrometheusGlobalViewResponseBody) *UpdatePrometheusGlobalViewResponse {
	s.Body = v
	return s
}

type UpdatePrometheusIntegrationRequest struct {
	// The ID of the Prometheus instance. Only a Prometheus instance for Container Service or a Prometheus instance for ECS is supported.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The exporter ID.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of the integration.
	IntegrationType *string `json:"IntegrationType,omitempty" xml:"IntegrationType,omitempty"`
	// The configurations of the exporter. The value is a JSON string.
	Param *string `json:"Param,omitempty" xml:"Param,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UpdatePrometheusIntegrationRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusIntegrationRequest) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusIntegrationRequest) SetClusterId(v string) *UpdatePrometheusIntegrationRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdatePrometheusIntegrationRequest) SetInstanceId(v int64) *UpdatePrometheusIntegrationRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdatePrometheusIntegrationRequest) SetIntegrationType(v string) *UpdatePrometheusIntegrationRequest {
	s.IntegrationType = &v
	return s
}

func (s *UpdatePrometheusIntegrationRequest) SetParam(v string) *UpdatePrometheusIntegrationRequest {
	s.Param = &v
	return s
}

func (s *UpdatePrometheusIntegrationRequest) SetRegionId(v string) *UpdatePrometheusIntegrationRequest {
	s.RegionId = &v
	return s
}

type UpdatePrometheusIntegrationResponseBody struct {
	// The status code or error code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The struct returned.
	Data *UpdatePrometheusIntegrationResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdatePrometheusIntegrationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusIntegrationResponseBody) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusIntegrationResponseBody) SetCode(v int32) *UpdatePrometheusIntegrationResponseBody {
	s.Code = &v
	return s
}

func (s *UpdatePrometheusIntegrationResponseBody) SetData(v *UpdatePrometheusIntegrationResponseBodyData) *UpdatePrometheusIntegrationResponseBody {
	s.Data = v
	return s
}

func (s *UpdatePrometheusIntegrationResponseBody) SetMessage(v string) *UpdatePrometheusIntegrationResponseBody {
	s.Message = &v
	return s
}

func (s *UpdatePrometheusIntegrationResponseBody) SetRequestId(v string) *UpdatePrometheusIntegrationResponseBody {
	s.RequestId = &v
	return s
}

type UpdatePrometheusIntegrationResponseBodyData struct {
	// The exporter ID.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The exporter name.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
}

func (s UpdatePrometheusIntegrationResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusIntegrationResponseBodyData) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusIntegrationResponseBodyData) SetInstanceId(v int64) *UpdatePrometheusIntegrationResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *UpdatePrometheusIntegrationResponseBodyData) SetInstanceName(v string) *UpdatePrometheusIntegrationResponseBodyData {
	s.InstanceName = &v
	return s
}

type UpdatePrometheusIntegrationResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdatePrometheusIntegrationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdatePrometheusIntegrationResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusIntegrationResponse) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusIntegrationResponse) SetHeaders(v map[string]*string) *UpdatePrometheusIntegrationResponse {
	s.Headers = v
	return s
}

func (s *UpdatePrometheusIntegrationResponse) SetStatusCode(v int32) *UpdatePrometheusIntegrationResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdatePrometheusIntegrationResponse) SetBody(v *UpdatePrometheusIntegrationResponseBody) *UpdatePrometheusIntegrationResponse {
	s.Body = v
	return s
}

type UpdatePrometheusMonitoringRequest struct {
	// The ID of the Prometheus instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The monitoring configuration. Specify a YAML string.
	ConfigYaml *string `json:"ConfigYaml,omitempty" xml:"ConfigYaml,omitempty"`
	// The name of the monitoring configuration.
	MonitoringName *string `json:"MonitoringName,omitempty" xml:"MonitoringName,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The type of the monitoring configuration.
	// Valid values for a Prometheus instance for Container Service: serviceMonitor, podMonitor, customJob, and probe.
	// Valid values for a Prometheus instance for ECS: customJob and probe.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdatePrometheusMonitoringRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusMonitoringRequest) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusMonitoringRequest) SetClusterId(v string) *UpdatePrometheusMonitoringRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdatePrometheusMonitoringRequest) SetConfigYaml(v string) *UpdatePrometheusMonitoringRequest {
	s.ConfigYaml = &v
	return s
}

func (s *UpdatePrometheusMonitoringRequest) SetMonitoringName(v string) *UpdatePrometheusMonitoringRequest {
	s.MonitoringName = &v
	return s
}

func (s *UpdatePrometheusMonitoringRequest) SetRegionId(v string) *UpdatePrometheusMonitoringRequest {
	s.RegionId = &v
	return s
}

func (s *UpdatePrometheusMonitoringRequest) SetType(v string) *UpdatePrometheusMonitoringRequest {
	s.Type = &v
	return s
}

type UpdatePrometheusMonitoringResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result of the operation.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdatePrometheusMonitoringResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusMonitoringResponseBody) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusMonitoringResponseBody) SetCode(v int32) *UpdatePrometheusMonitoringResponseBody {
	s.Code = &v
	return s
}

func (s *UpdatePrometheusMonitoringResponseBody) SetData(v string) *UpdatePrometheusMonitoringResponseBody {
	s.Data = &v
	return s
}

func (s *UpdatePrometheusMonitoringResponseBody) SetMessage(v string) *UpdatePrometheusMonitoringResponseBody {
	s.Message = &v
	return s
}

func (s *UpdatePrometheusMonitoringResponseBody) SetRequestId(v string) *UpdatePrometheusMonitoringResponseBody {
	s.RequestId = &v
	return s
}

type UpdatePrometheusMonitoringResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdatePrometheusMonitoringResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdatePrometheusMonitoringResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusMonitoringResponse) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusMonitoringResponse) SetHeaders(v map[string]*string) *UpdatePrometheusMonitoringResponse {
	s.Headers = v
	return s
}

func (s *UpdatePrometheusMonitoringResponse) SetStatusCode(v int32) *UpdatePrometheusMonitoringResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdatePrometheusMonitoringResponse) SetBody(v *UpdatePrometheusMonitoringResponseBody) *UpdatePrometheusMonitoringResponse {
	s.Body = v
	return s
}

type UpdatePrometheusMonitoringStatusRequest struct {
	// The ID of the Prometheus instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the monitoring configuration.
	MonitoringName *string `json:"MonitoringName,omitempty" xml:"MonitoringName,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The status of the monitoring configuration. Valid values: run and stop.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the monitoring configuration.
	// Valid values for a Prometheus instance for Container Service: serviceMonitor, podMonitor, and customJob.
	// Valid value for a Prometheus instance for ECS: customJob.
	// The status of probe cannot be modified.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdatePrometheusMonitoringStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusMonitoringStatusRequest) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusMonitoringStatusRequest) SetClusterId(v string) *UpdatePrometheusMonitoringStatusRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdatePrometheusMonitoringStatusRequest) SetMonitoringName(v string) *UpdatePrometheusMonitoringStatusRequest {
	s.MonitoringName = &v
	return s
}

func (s *UpdatePrometheusMonitoringStatusRequest) SetRegionId(v string) *UpdatePrometheusMonitoringStatusRequest {
	s.RegionId = &v
	return s
}

func (s *UpdatePrometheusMonitoringStatusRequest) SetStatus(v string) *UpdatePrometheusMonitoringStatusRequest {
	s.Status = &v
	return s
}

func (s *UpdatePrometheusMonitoringStatusRequest) SetType(v string) *UpdatePrometheusMonitoringStatusRequest {
	s.Type = &v
	return s
}

type UpdatePrometheusMonitoringStatusResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result of the operation.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdatePrometheusMonitoringStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusMonitoringStatusResponseBody) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusMonitoringStatusResponseBody) SetCode(v int32) *UpdatePrometheusMonitoringStatusResponseBody {
	s.Code = &v
	return s
}

func (s *UpdatePrometheusMonitoringStatusResponseBody) SetData(v string) *UpdatePrometheusMonitoringStatusResponseBody {
	s.Data = &v
	return s
}

func (s *UpdatePrometheusMonitoringStatusResponseBody) SetMessage(v string) *UpdatePrometheusMonitoringStatusResponseBody {
	s.Message = &v
	return s
}

func (s *UpdatePrometheusMonitoringStatusResponseBody) SetRequestId(v string) *UpdatePrometheusMonitoringStatusResponseBody {
	s.RequestId = &v
	return s
}

type UpdatePrometheusMonitoringStatusResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdatePrometheusMonitoringStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdatePrometheusMonitoringStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusMonitoringStatusResponse) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusMonitoringStatusResponse) SetHeaders(v map[string]*string) *UpdatePrometheusMonitoringStatusResponse {
	s.Headers = v
	return s
}

func (s *UpdatePrometheusMonitoringStatusResponse) SetStatusCode(v int32) *UpdatePrometheusMonitoringStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdatePrometheusMonitoringStatusResponse) SetBody(v *UpdatePrometheusMonitoringStatusResponseBody) *UpdatePrometheusMonitoringStatusResponse {
	s.Body = v
	return s
}

type UpdatePrometheusRemoteWriteRequest struct {
	// The ID of the Prometheus instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The name of the remote write configuration item.
	RemoteWriteName *string `json:"RemoteWriteName,omitempty" xml:"RemoteWriteName,omitempty"`
	// The remote write configuration. Specify the value in the YAML format.
	RemoteWriteYaml *string `json:"RemoteWriteYaml,omitempty" xml:"RemoteWriteYaml,omitempty"`
}

func (s UpdatePrometheusRemoteWriteRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusRemoteWriteRequest) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusRemoteWriteRequest) SetClusterId(v string) *UpdatePrometheusRemoteWriteRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdatePrometheusRemoteWriteRequest) SetRegionId(v string) *UpdatePrometheusRemoteWriteRequest {
	s.RegionId = &v
	return s
}

func (s *UpdatePrometheusRemoteWriteRequest) SetRemoteWriteName(v string) *UpdatePrometheusRemoteWriteRequest {
	s.RemoteWriteName = &v
	return s
}

func (s *UpdatePrometheusRemoteWriteRequest) SetRemoteWriteYaml(v string) *UpdatePrometheusRemoteWriteRequest {
	s.RemoteWriteYaml = &v
	return s
}

type UpdatePrometheusRemoteWriteResponseBody struct {
	// The status code. A value of 200 indicates that the request is successful.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The name of the remote write configuration that was modified, or the exception information.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   `true`
	// *   `false`
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdatePrometheusRemoteWriteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusRemoteWriteResponseBody) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusRemoteWriteResponseBody) SetCode(v int32) *UpdatePrometheusRemoteWriteResponseBody {
	s.Code = &v
	return s
}

func (s *UpdatePrometheusRemoteWriteResponseBody) SetData(v string) *UpdatePrometheusRemoteWriteResponseBody {
	s.Data = &v
	return s
}

func (s *UpdatePrometheusRemoteWriteResponseBody) SetMessage(v string) *UpdatePrometheusRemoteWriteResponseBody {
	s.Message = &v
	return s
}

func (s *UpdatePrometheusRemoteWriteResponseBody) SetRequestId(v string) *UpdatePrometheusRemoteWriteResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdatePrometheusRemoteWriteResponseBody) SetSuccess(v bool) *UpdatePrometheusRemoteWriteResponseBody {
	s.Success = &v
	return s
}

type UpdatePrometheusRemoteWriteResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdatePrometheusRemoteWriteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdatePrometheusRemoteWriteResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdatePrometheusRemoteWriteResponse) GoString() string {
	return s.String()
}

func (s *UpdatePrometheusRemoteWriteResponse) SetHeaders(v map[string]*string) *UpdatePrometheusRemoteWriteResponse {
	s.Headers = v
	return s
}

func (s *UpdatePrometheusRemoteWriteResponse) SetStatusCode(v int32) *UpdatePrometheusRemoteWriteResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdatePrometheusRemoteWriteResponse) SetBody(v *UpdatePrometheusRemoteWriteResponseBody) *UpdatePrometheusRemoteWriteResponse {
	s.Body = v
	return s
}

type UpdateTimingSyntheticTaskRequest struct {
	// The list of assertions.
	AvailableAssertions []*UpdateTimingSyntheticTaskRequestAvailableAssertions `json:"AvailableAssertions,omitempty" xml:"AvailableAssertions,omitempty" type:"Repeated"`
	// The general settings.
	CommonSetting *UpdateTimingSyntheticTaskRequestCommonSetting `json:"CommonSetting,omitempty" xml:"CommonSetting,omitempty" type:"Struct"`
	// The custom cycle.
	CustomPeriod *UpdateTimingSyntheticTaskRequestCustomPeriod `json:"CustomPeriod,omitempty" xml:"CustomPeriod,omitempty" type:"Struct"`
	// The detection frequency. Valid values: 1m, 5m, 10m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, and 24h.
	Frequency *string `json:"Frequency,omitempty" xml:"Frequency,omitempty"`
	// The monitoring configurations.
	MonitorConf *UpdateTimingSyntheticTaskRequestMonitorConf `json:"MonitorConf,omitempty" xml:"MonitorConf,omitempty" type:"Struct"`
	// The list of monitoring points.
	Monitors []*UpdateTimingSyntheticTaskRequestMonitors `json:"Monitors,omitempty" xml:"Monitors,omitempty" type:"Repeated"`
	// The name of the task.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource group ID.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The list of tags.
	Tags []*UpdateTimingSyntheticTaskRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The ID of the synthetic monitoring task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s UpdateTimingSyntheticTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTimingSyntheticTaskRequest) GoString() string {
	return s.String()
}

func (s *UpdateTimingSyntheticTaskRequest) SetAvailableAssertions(v []*UpdateTimingSyntheticTaskRequestAvailableAssertions) *UpdateTimingSyntheticTaskRequest {
	s.AvailableAssertions = v
	return s
}

func (s *UpdateTimingSyntheticTaskRequest) SetCommonSetting(v *UpdateTimingSyntheticTaskRequestCommonSetting) *UpdateTimingSyntheticTaskRequest {
	s.CommonSetting = v
	return s
}

func (s *UpdateTimingSyntheticTaskRequest) SetCustomPeriod(v *UpdateTimingSyntheticTaskRequestCustomPeriod) *UpdateTimingSyntheticTaskRequest {
	s.CustomPeriod = v
	return s
}

func (s *UpdateTimingSyntheticTaskRequest) SetFrequency(v string) *UpdateTimingSyntheticTaskRequest {
	s.Frequency = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequest) SetMonitorConf(v *UpdateTimingSyntheticTaskRequestMonitorConf) *UpdateTimingSyntheticTaskRequest {
	s.MonitorConf = v
	return s
}

func (s *UpdateTimingSyntheticTaskRequest) SetMonitors(v []*UpdateTimingSyntheticTaskRequestMonitors) *UpdateTimingSyntheticTaskRequest {
	s.Monitors = v
	return s
}

func (s *UpdateTimingSyntheticTaskRequest) SetName(v string) *UpdateTimingSyntheticTaskRequest {
	s.Name = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequest) SetRegionId(v string) *UpdateTimingSyntheticTaskRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequest) SetResourceGroupId(v string) *UpdateTimingSyntheticTaskRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequest) SetTags(v []*UpdateTimingSyntheticTaskRequestTags) *UpdateTimingSyntheticTaskRequest {
	s.Tags = v
	return s
}

func (s *UpdateTimingSyntheticTaskRequest) SetTaskId(v string) *UpdateTimingSyntheticTaskRequest {
	s.TaskId = &v
	return s
}

type UpdateTimingSyntheticTaskRequestAvailableAssertions struct {
	// The expected value.
	Expect *string `json:"Expect,omitempty" xml:"Expect,omitempty"`
	// The condition. gt: greater than. gte: greater than or equal to. lt: less than. lte: less than or equal to. eq: equal to. neq: not equal to. ctn: contain. nctn: does not contain. exist: exist. n_exist: does not exist. belong: belong to. n_belong: does not belong to. reg_match: regular expression.
	Operator *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
	// The check target. If you set the type parameter to HttpResCode, HttpResBody, or HttpResponseTime, you do not need to set the target parameter. If you set the type parameter to HttpResHead, you must specify the key in the header. If you set the type parameter to HttpResBodyJson, use jsonPath.
	Target *string `json:"Target,omitempty" xml:"Target,omitempty"`
	// The assertion type. Valid values: HttpResCode, HttpResHead, HttpResBody, HttpResBodyJson, HttpResponseTime, IcmpPackLoss (packet loss rate), IcmpPackMaxLatency (maximum packet latency), IcmpPackAvgLatency (average packet latency), TraceRouteHops (number of hops), DnsARecord (A record), DnsCName (CNAME), websiteTTFB (time to first packet), websiteTTLB (time to last packet), websiteFST (first paint time), websiteFFST (first meaningful paint), websiteOnload (full loaded time). For more information, see the following description.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateTimingSyntheticTaskRequestAvailableAssertions) String() string {
	return tea.Prettify(s)
}

func (s UpdateTimingSyntheticTaskRequestAvailableAssertions) GoString() string {
	return s.String()
}

func (s *UpdateTimingSyntheticTaskRequestAvailableAssertions) SetExpect(v string) *UpdateTimingSyntheticTaskRequestAvailableAssertions {
	s.Expect = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestAvailableAssertions) SetOperator(v string) *UpdateTimingSyntheticTaskRequestAvailableAssertions {
	s.Operator = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestAvailableAssertions) SetTarget(v string) *UpdateTimingSyntheticTaskRequestAvailableAssertions {
	s.Target = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestAvailableAssertions) SetType(v string) *UpdateTimingSyntheticTaskRequestAvailableAssertions {
	s.Type = &v
	return s
}

type UpdateTimingSyntheticTaskRequestCommonSetting struct {
	// The custom host.
	CustomHost *UpdateTimingSyntheticTaskRequestCommonSettingCustomHost `json:"CustomHost,omitempty" xml:"CustomHost,omitempty" type:"Struct"`
	// The IP version. Valid values:
	//
	// *   0: A version is automatically selected.
	// *   1: IPv4
	// *   2: IPv6
	IpType *int32 `json:"IpType,omitempty" xml:"IpType,omitempty"`
	// 是否开启链路追踪。
	IsOpenTrace *bool `json:"IsOpenTrace,omitempty" xml:"IsOpenTrace,omitempty"`
	// Specifies whether to evenly distribute monitoring samples. Valid values:
	//
	// *   0: No
	// *   1: Yes
	MonitorSamples *int32 `json:"MonitorSamples,omitempty" xml:"MonitorSamples,omitempty"`
	// 链路追踪客户端类型：
	//
	// - 0：ARMS Agent
	// - 1：OpenTelemetry
	// - 2：Jaeger
	TraceClientType *int32 `json:"TraceClientType,omitempty" xml:"TraceClientType,omitempty"`
	// 链路数据上报region。
	XtraceRegion *string `json:"XtraceRegion,omitempty" xml:"XtraceRegion,omitempty"`
}

func (s UpdateTimingSyntheticTaskRequestCommonSetting) String() string {
	return tea.Prettify(s)
}

func (s UpdateTimingSyntheticTaskRequestCommonSetting) GoString() string {
	return s.String()
}

func (s *UpdateTimingSyntheticTaskRequestCommonSetting) SetCustomHost(v *UpdateTimingSyntheticTaskRequestCommonSettingCustomHost) *UpdateTimingSyntheticTaskRequestCommonSetting {
	s.CustomHost = v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestCommonSetting) SetIpType(v int32) *UpdateTimingSyntheticTaskRequestCommonSetting {
	s.IpType = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestCommonSetting) SetIsOpenTrace(v bool) *UpdateTimingSyntheticTaskRequestCommonSetting {
	s.IsOpenTrace = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestCommonSetting) SetMonitorSamples(v int32) *UpdateTimingSyntheticTaskRequestCommonSetting {
	s.MonitorSamples = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestCommonSetting) SetTraceClientType(v int32) *UpdateTimingSyntheticTaskRequestCommonSetting {
	s.TraceClientType = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestCommonSetting) SetXtraceRegion(v string) *UpdateTimingSyntheticTaskRequestCommonSetting {
	s.XtraceRegion = &v
	return s
}

type UpdateTimingSyntheticTaskRequestCommonSettingCustomHost struct {
	// The list of hosts.
	Hosts []*UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts `json:"Hosts,omitempty" xml:"Hosts,omitempty" type:"Repeated"`
	// The selection mode. 0: Random. 1: Polling.
	SelectType *int32 `json:"SelectType,omitempty" xml:"SelectType,omitempty"`
}

func (s UpdateTimingSyntheticTaskRequestCommonSettingCustomHost) String() string {
	return tea.Prettify(s)
}

func (s UpdateTimingSyntheticTaskRequestCommonSettingCustomHost) GoString() string {
	return s.String()
}

func (s *UpdateTimingSyntheticTaskRequestCommonSettingCustomHost) SetHosts(v []*UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts) *UpdateTimingSyntheticTaskRequestCommonSettingCustomHost {
	s.Hosts = v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestCommonSettingCustomHost) SetSelectType(v int32) *UpdateTimingSyntheticTaskRequestCommonSettingCustomHost {
	s.SelectType = &v
	return s
}

type UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts struct {
	// The domain name.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The IP version. Valid values:
	//
	// *   0: A version is automatically selected.
	// *   1: IPv4
	// *   2: IPv6
	IpType *int32 `json:"IpType,omitempty" xml:"IpType,omitempty"`
	// The list of IP addresses.
	Ips []*string `json:"Ips,omitempty" xml:"Ips,omitempty" type:"Repeated"`
}

func (s UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts) String() string {
	return tea.Prettify(s)
}

func (s UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts) GoString() string {
	return s.String()
}

func (s *UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts) SetDomain(v string) *UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts {
	s.Domain = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts) SetIpType(v int32) *UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts {
	s.IpType = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts) SetIps(v []*string) *UpdateTimingSyntheticTaskRequestCommonSettingCustomHostHosts {
	s.Ips = v
	return s
}

type UpdateTimingSyntheticTaskRequestCustomPeriod struct {
	// The hour at which the test ends. Valid values: 0 to 24.
	EndHour *int32 `json:"EndHour,omitempty" xml:"EndHour,omitempty"`
	// The hour at which the test starts. Valid values: 0 to 24.
	StartHour *int32 `json:"StartHour,omitempty" xml:"StartHour,omitempty"`
}

func (s UpdateTimingSyntheticTaskRequestCustomPeriod) String() string {
	return tea.Prettify(s)
}

func (s UpdateTimingSyntheticTaskRequestCustomPeriod) GoString() string {
	return s.String()
}

func (s *UpdateTimingSyntheticTaskRequestCustomPeriod) SetEndHour(v int32) *UpdateTimingSyntheticTaskRequestCustomPeriod {
	s.EndHour = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestCustomPeriod) SetStartHour(v int32) *UpdateTimingSyntheticTaskRequestCustomPeriod {
	s.StartHour = &v
	return s
}

type UpdateTimingSyntheticTaskRequestMonitorConf struct {
	// The HTTP(S) synthetic test parameters.
	ApiHTTP *UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP `json:"ApiHTTP,omitempty" xml:"ApiHTTP,omitempty" type:"Struct"`
	// The file download parameters.
	FileDownload *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload `json:"FileDownload,omitempty" xml:"FileDownload,omitempty" type:"Struct"`
	// The DNS synthetic test parameters.
	NetDNS *UpdateTimingSyntheticTaskRequestMonitorConfNetDNS `json:"NetDNS,omitempty" xml:"NetDNS,omitempty" type:"Struct"`
	// The ICMP synthetic test parameters.
	NetICMP *UpdateTimingSyntheticTaskRequestMonitorConfNetICMP `json:"NetICMP,omitempty" xml:"NetICMP,omitempty" type:"Struct"`
	// The TCP synthetic tests parameters. This parameter is required if the TaskType parameter is set to 2.
	NetTCP *UpdateTimingSyntheticTaskRequestMonitorConfNetTCP `json:"NetTCP,omitempty" xml:"NetTCP,omitempty" type:"Struct"`
	// 流媒体拨测配置。
	Stream *UpdateTimingSyntheticTaskRequestMonitorConfStream `json:"Stream,omitempty" xml:"Stream,omitempty" type:"Struct"`
	// The website-speed measurement parameters.
	Website *UpdateTimingSyntheticTaskRequestMonitorConfWebsite `json:"Website,omitempty" xml:"Website,omitempty" type:"Struct"`
}

func (s UpdateTimingSyntheticTaskRequestMonitorConf) String() string {
	return tea.Prettify(s)
}

func (s UpdateTimingSyntheticTaskRequestMonitorConf) GoString() string {
	return s.String()
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConf) SetApiHTTP(v *UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP) *UpdateTimingSyntheticTaskRequestMonitorConf {
	s.ApiHTTP = v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConf) SetFileDownload(v *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload) *UpdateTimingSyntheticTaskRequestMonitorConf {
	s.FileDownload = v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConf) SetNetDNS(v *UpdateTimingSyntheticTaskRequestMonitorConfNetDNS) *UpdateTimingSyntheticTaskRequestMonitorConf {
	s.NetDNS = v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConf) SetNetICMP(v *UpdateTimingSyntheticTaskRequestMonitorConfNetICMP) *UpdateTimingSyntheticTaskRequestMonitorConf {
	s.NetICMP = v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConf) SetNetTCP(v *UpdateTimingSyntheticTaskRequestMonitorConfNetTCP) *UpdateTimingSyntheticTaskRequestMonitorConf {
	s.NetTCP = v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConf) SetStream(v *UpdateTimingSyntheticTaskRequestMonitorConfStream) *UpdateTimingSyntheticTaskRequestMonitorConf {
	s.Stream = v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConf) SetWebsite(v *UpdateTimingSyntheticTaskRequestMonitorConfWebsite) *UpdateTimingSyntheticTaskRequestMonitorConf {
	s.Website = v
	return s
}

type UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP struct {
	// The connection timeout period. Unit: milliseconds. Default value: 5000. Minimum value: 1000. Maximum value: 300000.
	ConnectTimeout *int64 `json:"ConnectTimeout,omitempty" xml:"ConnectTimeout,omitempty"`
	// The request method.
	//
	// *   POST
	// *   GET
	Method *string `json:"Method,omitempty" xml:"Method,omitempty"`
	// The HTTP request body.
	RequestBody *UpdateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody `json:"RequestBody,omitempty" xml:"RequestBody,omitempty" type:"Struct"`
	// The custom header field.
	RequestHeaders map[string]*string `json:"RequestHeaders,omitempty" xml:"RequestHeaders,omitempty"`
	// The URL or request path for synthetic monitoring.
	TargetUrl *string `json:"TargetUrl,omitempty" xml:"TargetUrl,omitempty"`
	// The timeout period. Unit: milliseconds. Default value: 10000. Minimum value: 1000. Maximum value: 300000.
	Timeout *int64 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
}

func (s UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP) String() string {
	return tea.Prettify(s)
}

func (s UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP) GoString() string {
	return s.String()
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP) SetConnectTimeout(v int64) *UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP {
	s.ConnectTimeout = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP) SetMethod(v string) *UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP {
	s.Method = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP) SetRequestBody(v *UpdateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody) *UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP {
	s.RequestBody = v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP) SetRequestHeaders(v map[string]*string) *UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP {
	s.RequestHeaders = v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP) SetTargetUrl(v string) *UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP {
	s.TargetUrl = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP) SetTimeout(v int64) *UpdateTimingSyntheticTaskRequestMonitorConfApiHTTP {
	s.Timeout = &v
	return s
}

type UpdateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody struct {
	// The content of the request body. Format: JSON string. The parameter is required if the type parameter is set to text/plain, application/json, application/xml, or text/html. Format: JSON string.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The type of the request body. Valid values: text/plain, application/json, application/x-www-form-urlencoded, multipart/form-data, application/xml, and text/html.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody) GoString() string {
	return s.String()
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody) SetContent(v string) *UpdateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody {
	s.Content = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody) SetType(v string) *UpdateTimingSyntheticTaskRequestMonitorConfApiHTTPRequestBody {
	s.Type = &v
	return s
}

type UpdateTimingSyntheticTaskRequestMonitorConfFileDownload struct {
	// The connection timeout period. Unit: milliseconds. Minimum value: 1000. Maximum value: 120000. Default value: 5000.
	ConnectionTimeout *int64 `json:"ConnectionTimeout,omitempty" xml:"ConnectionTimeout,omitempty"`
	// The content of the custom request header.
	CustomHeaderContent map[string]*string `json:"CustomHeaderContent,omitempty" xml:"CustomHeaderContent,omitempty"`
	// The kernel type.
	//
	// *   1: curl
	// *   0: WinInet
	DownloadKernel *int32 `json:"DownloadKernel,omitempty" xml:"DownloadKernel,omitempty"`
	// Specifies whether to ignore CA certificate authentication errors. 0: No. 1: Yes. Default value: 1.
	IgnoreCertificateAuthError *int32 `json:"IgnoreCertificateAuthError,omitempty" xml:"IgnoreCertificateAuthError,omitempty"`
	// Specifies whether to ignore certificate revocation errors. 0: No. 1: Yes. Default value: 1.
	IgnoreCertificateCanceledError *int32 `json:"IgnoreCertificateCanceledError,omitempty" xml:"IgnoreCertificateCanceledError,omitempty"`
	// Specifies whether to ignore certificate invalidity. 0: No. 1: Yes. Default value: 1.
	IgnoreCertificateOutOfDateError *int32 `json:"IgnoreCertificateOutOfDateError,omitempty" xml:"IgnoreCertificateOutOfDateError,omitempty"`
	// Specifies whether to ignore certificate status errors. 0: No. 1: Yes. Default value: 1.
	IgnoreCertificateStatusError *int32 `json:"IgnoreCertificateStatusError,omitempty" xml:"IgnoreCertificateStatusError,omitempty"`
	// Specifies whether to ignore certificate incredibility. 0: No. 1: Yes. Default value: 1.
	IgnoreCertificateUntrustworthyError *int32 `json:"IgnoreCertificateUntrustworthyError,omitempty" xml:"IgnoreCertificateUntrustworthyError,omitempty"`
	// Specifies whether to ignore certificate usage errors. 0: No. 1: Yes. Default value: 1.
	IgnoreCertificateUsingError *int32 `json:"IgnoreCertificateUsingError,omitempty" xml:"IgnoreCertificateUsingError,omitempty"`
	// Specifies whether to ignore host invalidity. 0: No. 1: Yes. Default value: 1.
	IgnoreInvalidHostError *int32 `json:"IgnoreInvalidHostError,omitempty" xml:"IgnoreInvalidHostError,omitempty"`
	// The monitoring timeout period. Unit: milliseconds. Minimum value: 1000. Maximum value: 120000. Default value: 60000.
	MonitorTimeout *int64 `json:"MonitorTimeout,omitempty" xml:"MonitorTimeout,omitempty"`
	// The QUIC protocol type.
	//
	// *   1: http1
	// *   2: http2
	// *   3: http3
	QuickProtocol *int32 `json:"QuickProtocol,omitempty" xml:"QuickProtocol,omitempty"`
	// Specifies whether to support redirection. 0: No. 1: Yes. Default value: 1.
	Redirection *int32 `json:"Redirection,omitempty" xml:"Redirection,omitempty"`
	// The file download URL.
	TargetUrl *string `json:"TargetUrl,omitempty" xml:"TargetUrl,omitempty"`
	// The maximum file size of a single transfer. Unit: KB. Minimum value: 1. Maximum value: 20480. Valid values: 2048.
	TransmissionSize *int64 `json:"TransmissionSize,omitempty" xml:"TransmissionSize,omitempty"`
	// 验证关键词。
	ValidateKeywords *string `json:"ValidateKeywords,omitempty" xml:"ValidateKeywords,omitempty"`
	// 验证方式。
	//
	// - 0：不验证
	// - 1：验证字符串
	// - 2：MD5验证
	VerifyWay *int32 `json:"VerifyWay,omitempty" xml:"VerifyWay,omitempty"`
	// DNS劫持白名单。匹配规则支持IP、IP通配符、子网掩码和CNAME，可以填写多个匹配规则，多个匹配规则以竖线（|）隔开。例如：www.aliyun.com:203.0.3.55|203.3.44.67，表示www.aliyun.com域名下除203.0.3.55和203.3.44.67之外的其他IP都是被劫持的。
	WhiteList *string `json:"WhiteList,omitempty" xml:"WhiteList,omitempty"`
}

func (s UpdateTimingSyntheticTaskRequestMonitorConfFileDownload) String() string {
	return tea.Prettify(s)
}

func (s UpdateTimingSyntheticTaskRequestMonitorConfFileDownload) GoString() string {
	return s.String()
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload) SetConnectionTimeout(v int64) *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.ConnectionTimeout = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload) SetCustomHeaderContent(v map[string]*string) *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.CustomHeaderContent = v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload) SetDownloadKernel(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.DownloadKernel = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload) SetIgnoreCertificateAuthError(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.IgnoreCertificateAuthError = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload) SetIgnoreCertificateCanceledError(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.IgnoreCertificateCanceledError = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload) SetIgnoreCertificateOutOfDateError(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.IgnoreCertificateOutOfDateError = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload) SetIgnoreCertificateStatusError(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.IgnoreCertificateStatusError = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload) SetIgnoreCertificateUntrustworthyError(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.IgnoreCertificateUntrustworthyError = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload) SetIgnoreCertificateUsingError(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.IgnoreCertificateUsingError = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload) SetIgnoreInvalidHostError(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.IgnoreInvalidHostError = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload) SetMonitorTimeout(v int64) *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.MonitorTimeout = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload) SetQuickProtocol(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.QuickProtocol = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload) SetRedirection(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.Redirection = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload) SetTargetUrl(v string) *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.TargetUrl = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload) SetTransmissionSize(v int64) *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.TransmissionSize = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload) SetValidateKeywords(v string) *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.ValidateKeywords = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload) SetVerifyWay(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.VerifyWay = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload) SetWhiteList(v string) *UpdateTimingSyntheticTaskRequestMonitorConfFileDownload {
	s.WhiteList = &v
	return s
}

type UpdateTimingSyntheticTaskRequestMonitorConfNetDNS struct {
	// Specifies whether to use dig to display the data. 0: No. 1: Yes.
	Dig *int32 `json:"Dig,omitempty" xml:"Dig,omitempty"`
	// The IP version of the DNS server. 0: IPv4. 1: IPv6. 2: A version is automatically selected. Default value: 0.
	DnsServerIpType *int32 `json:"DnsServerIpType,omitempty" xml:"DnsServerIpType,omitempty"`
	// The IP address of the DNS server. Default value: 114.114.114.114.
	NsServer *string `json:"NsServer,omitempty" xml:"NsServer,omitempty"`
	// The DNS query. 0: recursive, 1: iterative. Default value: 0.
	QueryMethod *int32 `json:"QueryMethod,omitempty" xml:"QueryMethod,omitempty"`
	// The destination domain name.
	TargetUrl *string `json:"TargetUrl,omitempty" xml:"TargetUrl,omitempty"`
	// The timeout period for the DNS synthetic test. Unit: milliseconds. The minimum value is 1000 and the maximum value is 45000. Default value: 5000.
	Timeout *int64 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
}

func (s UpdateTimingSyntheticTaskRequestMonitorConfNetDNS) String() string {
	return tea.Prettify(s)
}

func (s UpdateTimingSyntheticTaskRequestMonitorConfNetDNS) GoString() string {
	return s.String()
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfNetDNS) SetDig(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfNetDNS {
	s.Dig = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfNetDNS) SetDnsServerIpType(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfNetDNS {
	s.DnsServerIpType = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfNetDNS) SetNsServer(v string) *UpdateTimingSyntheticTaskRequestMonitorConfNetDNS {
	s.NsServer = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfNetDNS) SetQueryMethod(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfNetDNS {
	s.QueryMethod = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfNetDNS) SetTargetUrl(v string) *UpdateTimingSyntheticTaskRequestMonitorConfNetDNS {
	s.TargetUrl = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfNetDNS) SetTimeout(v int64) *UpdateTimingSyntheticTaskRequestMonitorConfNetDNS {
	s.Timeout = &v
	return s
}

type UpdateTimingSyntheticTaskRequestMonitorConfNetICMP struct {
	// The interval at which ICMP packets are sent. Unit: milliseconds. Minimum value: 200. Maximum value: 10000.
	Interval *int64 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The number of ICMP packets that are sent. Minimum value: 1. Maximum value: 50. Default value: 4.
	PackageNum *int32 `json:"PackageNum,omitempty" xml:"PackageNum,omitempty"`
	// The size of each ICMP packet. Unit: bytes. Valid values: 32, 64, 128, 256, 512, 1024.
	PackageSize *int32 `json:"PackageSize,omitempty" xml:"PackageSize,omitempty"`
	// Specifies whether to split ICMP packets. Default value: true.
	SplitPackage *bool `json:"SplitPackage,omitempty" xml:"SplitPackage,omitempty"`
	// The destination host IP address or domain name. Port numbers, protocol headers, or request paths are not supported.
	TargetUrl *string `json:"TargetUrl,omitempty" xml:"TargetUrl,omitempty"`
	// The timeout period for the TCP synthetic test. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 20000.
	Timeout *int64 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	// Specifies whether to enable the tracert command. Default value: true.
	TracertEnable *bool `json:"TracertEnable,omitempty" xml:"TracertEnable,omitempty"`
	// The maximum number of hops for tracert. Minimum value: 1. Maximum value: 128. Default value: 64.
	TracertNumMax *int32 `json:"TracertNumMax,omitempty" xml:"TracertNumMax,omitempty"`
	// The timeout period of tracert. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 60000.
	TracertTimeout *int64 `json:"TracertTimeout,omitempty" xml:"TracertTimeout,omitempty"`
}

func (s UpdateTimingSyntheticTaskRequestMonitorConfNetICMP) String() string {
	return tea.Prettify(s)
}

func (s UpdateTimingSyntheticTaskRequestMonitorConfNetICMP) GoString() string {
	return s.String()
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfNetICMP) SetInterval(v int64) *UpdateTimingSyntheticTaskRequestMonitorConfNetICMP {
	s.Interval = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfNetICMP) SetPackageNum(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfNetICMP {
	s.PackageNum = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfNetICMP) SetPackageSize(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfNetICMP {
	s.PackageSize = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfNetICMP) SetSplitPackage(v bool) *UpdateTimingSyntheticTaskRequestMonitorConfNetICMP {
	s.SplitPackage = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfNetICMP) SetTargetUrl(v string) *UpdateTimingSyntheticTaskRequestMonitorConfNetICMP {
	s.TargetUrl = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfNetICMP) SetTimeout(v int64) *UpdateTimingSyntheticTaskRequestMonitorConfNetICMP {
	s.Timeout = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfNetICMP) SetTracertEnable(v bool) *UpdateTimingSyntheticTaskRequestMonitorConfNetICMP {
	s.TracertEnable = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfNetICMP) SetTracertNumMax(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfNetICMP {
	s.TracertNumMax = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfNetICMP) SetTracertTimeout(v int64) *UpdateTimingSyntheticTaskRequestMonitorConfNetICMP {
	s.TracertTimeout = &v
	return s
}

type UpdateTimingSyntheticTaskRequestMonitorConfNetTCP struct {
	// The number of TCP connections that are established in a test. Minimum value: 1. Maximum value: 16. Default value: 4.
	ConnectTimes *int32 `json:"ConnectTimes,omitempty" xml:"ConnectTimes,omitempty"`
	// The interval at which TCP connections are established. Unit: milliseconds. Minimum value: 200. Maximum value: 10000. Default value: 200.
	Interval *int64 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The destination host IP address.
	TargetUrl *string `json:"TargetUrl,omitempty" xml:"TargetUrl,omitempty"`
	// The timeout period for the TCP synthetic test. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 20000.
	Timeout *int64 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	// Specifies whether to enable the tracert command. Default value: true.
	TracertEnable *bool `json:"TracertEnable,omitempty" xml:"TracertEnable,omitempty"`
	// The maximum number of hops for tracert. Minimum value: 1. Maximum value: 128. Default value: 20.
	TracertNumMax *int32 `json:"TracertNumMax,omitempty" xml:"TracertNumMax,omitempty"`
	// The timeout period of tracert. Unit: milliseconds. Minimum value: 1000. Maximum value: 300000. Default value: 60000.
	TracertTimeout *int64 `json:"TracertTimeout,omitempty" xml:"TracertTimeout,omitempty"`
}

func (s UpdateTimingSyntheticTaskRequestMonitorConfNetTCP) String() string {
	return tea.Prettify(s)
}

func (s UpdateTimingSyntheticTaskRequestMonitorConfNetTCP) GoString() string {
	return s.String()
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfNetTCP) SetConnectTimes(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfNetTCP {
	s.ConnectTimes = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfNetTCP) SetInterval(v int64) *UpdateTimingSyntheticTaskRequestMonitorConfNetTCP {
	s.Interval = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfNetTCP) SetTargetUrl(v string) *UpdateTimingSyntheticTaskRequestMonitorConfNetTCP {
	s.TargetUrl = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfNetTCP) SetTimeout(v int64) *UpdateTimingSyntheticTaskRequestMonitorConfNetTCP {
	s.Timeout = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfNetTCP) SetTracertEnable(v bool) *UpdateTimingSyntheticTaskRequestMonitorConfNetTCP {
	s.TracertEnable = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfNetTCP) SetTracertNumMax(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfNetTCP {
	s.TracertNumMax = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfNetTCP) SetTracertTimeout(v int64) *UpdateTimingSyntheticTaskRequestMonitorConfNetTCP {
	s.TracertTimeout = &v
	return s
}

type UpdateTimingSyntheticTaskRequestMonitorConfStream struct {
	// 自定义header，JSON Map格式。
	CustomHeaderContent map[string]*string `json:"CustomHeaderContent,omitempty" xml:"CustomHeaderContent,omitempty"`
	// 播放器，不传默认12。
	//
	// - 12：VLC
	// - 2：FlashPlayer
	PlayerType *int32 `json:"PlayerType,omitempty" xml:"PlayerType,omitempty"`
	// 资源地址类型：
	//
	// - 1：资源地址。
	// - 0：页面地址。不传默认0。
	StreamAddressType *int32 `json:"StreamAddressType,omitempty" xml:"StreamAddressType,omitempty"`
	// 监测时长，单位秒，最长支持60s，不传默认60。
	StreamMonitorTimeout *int32 `json:"StreamMonitorTimeout,omitempty" xml:"StreamMonitorTimeout,omitempty"`
	// 音视频标志：0-视频，1-音频。
	StreamType *int32 `json:"StreamType,omitempty" xml:"StreamType,omitempty"`
	// 流媒体地址。
	TargetUrl *string `json:"TargetUrl,omitempty" xml:"TargetUrl,omitempty"`
	// DNS劫持白名单。匹配规则支持IP、IP通配符、子网掩码和CNAME，可以填写多个匹配规则，多个匹配规则以竖线（|）隔开。例如：www.aliyun.com:203.0.3.55|203.3.44.67，表示www.aliyun.com域名下除203.0.3.55和203.3.44.67之外的其他IP都是被劫持的。
	WhiteList *string `json:"WhiteList,omitempty" xml:"WhiteList,omitempty"`
}

func (s UpdateTimingSyntheticTaskRequestMonitorConfStream) String() string {
	return tea.Prettify(s)
}

func (s UpdateTimingSyntheticTaskRequestMonitorConfStream) GoString() string {
	return s.String()
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfStream) SetCustomHeaderContent(v map[string]*string) *UpdateTimingSyntheticTaskRequestMonitorConfStream {
	s.CustomHeaderContent = v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfStream) SetPlayerType(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfStream {
	s.PlayerType = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfStream) SetStreamAddressType(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfStream {
	s.StreamAddressType = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfStream) SetStreamMonitorTimeout(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfStream {
	s.StreamMonitorTimeout = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfStream) SetStreamType(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfStream {
	s.StreamType = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfStream) SetTargetUrl(v string) *UpdateTimingSyntheticTaskRequestMonitorConfStream {
	s.TargetUrl = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfStream) SetWhiteList(v string) *UpdateTimingSyntheticTaskRequestMonitorConfStream {
	s.WhiteList = &v
	return s
}

type UpdateTimingSyntheticTaskRequestMonitorConfWebsite struct {
	// Specifies whether to automatically scroll up and down the screen to load a page. 0: No. 1: Yes. Default value: 0.
	AutomaticScrolling *int32 `json:"AutomaticScrolling,omitempty" xml:"AutomaticScrolling,omitempty"`
	// Specifies whether to create a custom header. 0: No. 1: The first packet is modified. 2: All packets are modified. Default value: 0.
	CustomHeader *int32 `json:"CustomHeader,omitempty" xml:"CustomHeader,omitempty"`
	// The custom header. Format: JSON map.
	CustomHeaderContent map[string]*string `json:"CustomHeaderContent,omitempty" xml:"CustomHeaderContent,omitempty"`
	// 域名（例如www.aliyun.com）解析时，解析出的IP地址或者CNAME不在DNS劫持白名单内，用户就会访问失败或者返回一个非Aliyun的目标IP；若解析结果中的IP或者CNAME在DNS白名单内，则会被认定为没有发生DNS劫持。
	//
	// 填写格式：域名:匹配规则。匹配规则支持IP、IP通配符、子网掩码和CNAME，可以填写多个匹配规则，多个匹配规则以竖线（|）隔开。例如：www.aliyun.com:203.0.3.55|203.3.44.67，表示www.aliyun.com域名下除203.0.3.55和203.3.44.67之外的其他IP都是被劫持的。
	DNSHijackWhitelist *string `json:"DNSHijackWhitelist,omitempty" xml:"DNSHijackWhitelist,omitempty"`
	// Specifies whether to disable the cache. 0: No. 1: Yes. Default value: 1.
	DisableCache *int32 `json:"DisableCache,omitempty" xml:"DisableCache,omitempty"`
	// Specifies whether to accept compressed files based on the HTTP Accept-Encoding request header. 0: No. 1: Yes. Default value: 0.
	DisableCompression *int32 `json:"DisableCompression,omitempty" xml:"DisableCompression,omitempty"`
	// 在页面加载过程中如果出现元素黑名单中配置的元素，不会请求加载该元素 。
	ElementBlacklist *string `json:"ElementBlacklist,omitempty" xml:"ElementBlacklist,omitempty"`
	// Specifies whether to filter invalid IP addresses.
	//
	// *   1: No
	// *   0: Yes
	FilterInvalidIP *int32 `json:"FilterInvalidIP,omitempty" xml:"FilterInvalidIP,omitempty"`
	// 识别元素：设置浏览页面元素总个数。
	FlowHijackJumpTimes *int32 `json:"FlowHijackJumpTimes,omitempty" xml:"FlowHijackJumpTimes,omitempty"`
	// 劫持标识：设置匹配的关键信息。填写劫持判断关键字或关键元素，允许带星号（*）。
	FlowHijackLogo *string `json:"FlowHijackLogo,omitempty" xml:"FlowHijackLogo,omitempty"`
	// Specifies whether to ignore SSL certificate errors during browsing. 0: No. 1: Yes. Default value: 1.
	IgnoreCertificateError *int32 `json:"IgnoreCertificateError,omitempty" xml:"IgnoreCertificateError,omitempty"`
	// The monitoring timeout period. Unit: milliseconds. Minimum value: 5000. Maximum value: 300000. Default value: 40000.
	MonitorTimeout *int64 `json:"MonitorTimeout,omitempty" xml:"MonitorTimeout,omitempty"`
	// 监测页面出现了域名设置之外的元素都属于页面被篡改。常见的表现形式为弹出广告、浮动广告、跳转等。
	PageTamper *string `json:"PageTamper,omitempty" xml:"PageTamper,omitempty"`
	// Specifies whether to continue browsing after redirection. 0: No, 1:Yes. Default value: 1.
	Redirection *int32 `json:"Redirection,omitempty" xml:"Redirection,omitempty"`
	// The time threshold that is used to define a slow element. Unit: milliseconds. Default value: 5000. Minimum value: 1. Maximum value: 300000.
	SlowElementThreshold *int64 `json:"SlowElementThreshold,omitempty" xml:"SlowElementThreshold,omitempty"`
	// The destination URL.
	TargetUrl *string `json:"TargetUrl,omitempty" xml:"TargetUrl,omitempty"`
	// 验证字符串即监测页面源代码中的某个任意字符串。若客户端返回的源码中包含任一黑名单中的字符串则报650验证字符串失败的错误。多个字符串以竖线（|）隔开。
	VerifyStringBlacklist *string `json:"VerifyStringBlacklist,omitempty" xml:"VerifyStringBlacklist,omitempty"`
	// 验证字符串即监测页面源代码中的某个任意字符串。客户端返回的源码必须包含所有白名单中的字符串，否则报650验证字符串失败的错误。多个字符串以竖线（|）隔开。
	VerifyStringWhitelist *string `json:"VerifyStringWhitelist,omitempty" xml:"VerifyStringWhitelist,omitempty"`
	// The maximum waiting time. Unit: milliseconds. Default value: 5000. Minimum value: 5000. Maximum value: 300000.
	WaitCompletionTime *int64 `json:"WaitCompletionTime,omitempty" xml:"WaitCompletionTime,omitempty"`
}

func (s UpdateTimingSyntheticTaskRequestMonitorConfWebsite) String() string {
	return tea.Prettify(s)
}

func (s UpdateTimingSyntheticTaskRequestMonitorConfWebsite) GoString() string {
	return s.String()
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfWebsite) SetAutomaticScrolling(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.AutomaticScrolling = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfWebsite) SetCustomHeader(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.CustomHeader = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfWebsite) SetCustomHeaderContent(v map[string]*string) *UpdateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.CustomHeaderContent = v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfWebsite) SetDNSHijackWhitelist(v string) *UpdateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.DNSHijackWhitelist = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfWebsite) SetDisableCache(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.DisableCache = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfWebsite) SetDisableCompression(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.DisableCompression = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfWebsite) SetElementBlacklist(v string) *UpdateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.ElementBlacklist = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfWebsite) SetFilterInvalidIP(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.FilterInvalidIP = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfWebsite) SetFlowHijackJumpTimes(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.FlowHijackJumpTimes = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfWebsite) SetFlowHijackLogo(v string) *UpdateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.FlowHijackLogo = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfWebsite) SetIgnoreCertificateError(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.IgnoreCertificateError = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfWebsite) SetMonitorTimeout(v int64) *UpdateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.MonitorTimeout = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfWebsite) SetPageTamper(v string) *UpdateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.PageTamper = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfWebsite) SetRedirection(v int32) *UpdateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.Redirection = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfWebsite) SetSlowElementThreshold(v int64) *UpdateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.SlowElementThreshold = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfWebsite) SetTargetUrl(v string) *UpdateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.TargetUrl = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfWebsite) SetVerifyStringBlacklist(v string) *UpdateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.VerifyStringBlacklist = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfWebsite) SetVerifyStringWhitelist(v string) *UpdateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.VerifyStringWhitelist = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitorConfWebsite) SetWaitCompletionTime(v int64) *UpdateTimingSyntheticTaskRequestMonitorConfWebsite {
	s.WaitCompletionTime = &v
	return s
}

type UpdateTimingSyntheticTaskRequestMonitors struct {
	// The city code.
	CityCode *string `json:"CityCode,omitempty" xml:"CityCode,omitempty"`
	// The client type of the monitoring point. Valid values: 1: data center. 2: Internet. 3: mobile device. 4: ECS instance.
	ClientType *int32 `json:"ClientType,omitempty" xml:"ClientType,omitempty"`
	// The carrier code.
	OperatorCode *string `json:"OperatorCode,omitempty" xml:"OperatorCode,omitempty"`
}

func (s UpdateTimingSyntheticTaskRequestMonitors) String() string {
	return tea.Prettify(s)
}

func (s UpdateTimingSyntheticTaskRequestMonitors) GoString() string {
	return s.String()
}

func (s *UpdateTimingSyntheticTaskRequestMonitors) SetCityCode(v string) *UpdateTimingSyntheticTaskRequestMonitors {
	s.CityCode = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitors) SetClientType(v int32) *UpdateTimingSyntheticTaskRequestMonitors {
	s.ClientType = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestMonitors) SetOperatorCode(v string) *UpdateTimingSyntheticTaskRequestMonitors {
	s.OperatorCode = &v
	return s
}

type UpdateTimingSyntheticTaskRequestTags struct {
	// The key of the tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s UpdateTimingSyntheticTaskRequestTags) String() string {
	return tea.Prettify(s)
}

func (s UpdateTimingSyntheticTaskRequestTags) GoString() string {
	return s.String()
}

func (s *UpdateTimingSyntheticTaskRequestTags) SetKey(v string) *UpdateTimingSyntheticTaskRequestTags {
	s.Key = &v
	return s
}

func (s *UpdateTimingSyntheticTaskRequestTags) SetValue(v string) *UpdateTimingSyntheticTaskRequestTags {
	s.Value = &v
	return s
}

type UpdateTimingSyntheticTaskShrinkRequest struct {
	// The list of assertions.
	AvailableAssertionsShrink *string `json:"AvailableAssertions,omitempty" xml:"AvailableAssertions,omitempty"`
	// The general settings.
	CommonSettingShrink *string `json:"CommonSetting,omitempty" xml:"CommonSetting,omitempty"`
	// The custom cycle.
	CustomPeriodShrink *string `json:"CustomPeriod,omitempty" xml:"CustomPeriod,omitempty"`
	// The detection frequency. Valid values: 1m, 5m, 10m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, and 24h.
	Frequency *string `json:"Frequency,omitempty" xml:"Frequency,omitempty"`
	// The monitoring configurations.
	MonitorConfShrink *string `json:"MonitorConf,omitempty" xml:"MonitorConf,omitempty"`
	// The list of monitoring points.
	MonitorsShrink *string `json:"Monitors,omitempty" xml:"Monitors,omitempty"`
	// The name of the task.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource group ID.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The list of tags.
	TagsShrink *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The ID of the synthetic monitoring task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s UpdateTimingSyntheticTaskShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTimingSyntheticTaskShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateTimingSyntheticTaskShrinkRequest) SetAvailableAssertionsShrink(v string) *UpdateTimingSyntheticTaskShrinkRequest {
	s.AvailableAssertionsShrink = &v
	return s
}

func (s *UpdateTimingSyntheticTaskShrinkRequest) SetCommonSettingShrink(v string) *UpdateTimingSyntheticTaskShrinkRequest {
	s.CommonSettingShrink = &v
	return s
}

func (s *UpdateTimingSyntheticTaskShrinkRequest) SetCustomPeriodShrink(v string) *UpdateTimingSyntheticTaskShrinkRequest {
	s.CustomPeriodShrink = &v
	return s
}

func (s *UpdateTimingSyntheticTaskShrinkRequest) SetFrequency(v string) *UpdateTimingSyntheticTaskShrinkRequest {
	s.Frequency = &v
	return s
}

func (s *UpdateTimingSyntheticTaskShrinkRequest) SetMonitorConfShrink(v string) *UpdateTimingSyntheticTaskShrinkRequest {
	s.MonitorConfShrink = &v
	return s
}

func (s *UpdateTimingSyntheticTaskShrinkRequest) SetMonitorsShrink(v string) *UpdateTimingSyntheticTaskShrinkRequest {
	s.MonitorsShrink = &v
	return s
}

func (s *UpdateTimingSyntheticTaskShrinkRequest) SetName(v string) *UpdateTimingSyntheticTaskShrinkRequest {
	s.Name = &v
	return s
}

func (s *UpdateTimingSyntheticTaskShrinkRequest) SetRegionId(v string) *UpdateTimingSyntheticTaskShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateTimingSyntheticTaskShrinkRequest) SetResourceGroupId(v string) *UpdateTimingSyntheticTaskShrinkRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *UpdateTimingSyntheticTaskShrinkRequest) SetTagsShrink(v string) *UpdateTimingSyntheticTaskShrinkRequest {
	s.TagsShrink = &v
	return s
}

func (s *UpdateTimingSyntheticTaskShrinkRequest) SetTaskId(v string) *UpdateTimingSyntheticTaskShrinkRequest {
	s.TaskId = &v
	return s
}

type UpdateTimingSyntheticTaskResponseBody struct {
	// The status code. The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
	Code *int64 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The struct returned.
	Data *UpdateTimingSyntheticTaskResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   `true`
	// *   `false`
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateTimingSyntheticTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTimingSyntheticTaskResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTimingSyntheticTaskResponseBody) SetCode(v int64) *UpdateTimingSyntheticTaskResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateTimingSyntheticTaskResponseBody) SetData(v *UpdateTimingSyntheticTaskResponseBodyData) *UpdateTimingSyntheticTaskResponseBody {
	s.Data = v
	return s
}

func (s *UpdateTimingSyntheticTaskResponseBody) SetMessage(v string) *UpdateTimingSyntheticTaskResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateTimingSyntheticTaskResponseBody) SetRequestId(v string) *UpdateTimingSyntheticTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTimingSyntheticTaskResponseBody) SetSuccess(v bool) *UpdateTimingSyntheticTaskResponseBody {
	s.Success = &v
	return s
}

type UpdateTimingSyntheticTaskResponseBodyData struct {
	// The task ID.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s UpdateTimingSyntheticTaskResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s UpdateTimingSyntheticTaskResponseBodyData) GoString() string {
	return s.String()
}

func (s *UpdateTimingSyntheticTaskResponseBodyData) SetTaskId(v string) *UpdateTimingSyntheticTaskResponseBodyData {
	s.TaskId = &v
	return s
}

type UpdateTimingSyntheticTaskResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTimingSyntheticTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTimingSyntheticTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTimingSyntheticTaskResponse) GoString() string {
	return s.String()
}

func (s *UpdateTimingSyntheticTaskResponse) SetHeaders(v map[string]*string) *UpdateTimingSyntheticTaskResponse {
	s.Headers = v
	return s
}

func (s *UpdateTimingSyntheticTaskResponse) SetStatusCode(v int32) *UpdateTimingSyntheticTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTimingSyntheticTaskResponse) SetBody(v *UpdateTimingSyntheticTaskResponseBody) *UpdateTimingSyntheticTaskResponse {
	s.Body = v
	return s
}

type UpdateWebhookRequest struct {
	// The notification template that is sent when an alert is triggered. This parameter is required if the **Method** parameter is set to **Post**. You can use the $content placeholder to specify the notification content. The content cannot exceed 500 characters in length.
	Body *string `json:"Body,omitempty" xml:"Body,omitempty"`
	// The ID of the webhook alert contact. You can call the **SearchAlertContact** operation to obtain the ID.
	ContactId *int64 `json:"ContactId,omitempty" xml:"ContactId,omitempty"`
	// The name of the webhook alert contact.
	ContactName *string `json:"ContactName,omitempty" xml:"ContactName,omitempty"`
	// The HTTP request headers.
	HttpHeaders *string `json:"HttpHeaders,omitempty" xml:"HttpHeaders,omitempty"`
	// The parameters in the HTTP request.
	HttpParams *string `json:"HttpParams,omitempty" xml:"HttpParams,omitempty"`
	// The HTTP request method. Valid values:
	//
	// *   `Get`
	// *   `Post`
	Method *string `json:"Method,omitempty" xml:"Method,omitempty"`
	// The notification template that is sent when an alert is resolved. This parameter is required if the **Method** parameter is set to **Post**. You can use the $content placeholder to specify the notification content. The content cannot exceed 500 characters in length.
	RecoverBody *string `json:"RecoverBody,omitempty" xml:"RecoverBody,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The URL of the HTTP request method.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s UpdateWebhookRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateWebhookRequest) GoString() string {
	return s.String()
}

func (s *UpdateWebhookRequest) SetBody(v string) *UpdateWebhookRequest {
	s.Body = &v
	return s
}

func (s *UpdateWebhookRequest) SetContactId(v int64) *UpdateWebhookRequest {
	s.ContactId = &v
	return s
}

func (s *UpdateWebhookRequest) SetContactName(v string) *UpdateWebhookRequest {
	s.ContactName = &v
	return s
}

func (s *UpdateWebhookRequest) SetHttpHeaders(v string) *UpdateWebhookRequest {
	s.HttpHeaders = &v
	return s
}

func (s *UpdateWebhookRequest) SetHttpParams(v string) *UpdateWebhookRequest {
	s.HttpParams = &v
	return s
}

func (s *UpdateWebhookRequest) SetMethod(v string) *UpdateWebhookRequest {
	s.Method = &v
	return s
}

func (s *UpdateWebhookRequest) SetRecoverBody(v string) *UpdateWebhookRequest {
	s.RecoverBody = &v
	return s
}

func (s *UpdateWebhookRequest) SetRegionId(v string) *UpdateWebhookRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateWebhookRequest) SetUrl(v string) *UpdateWebhookRequest {
	s.Url = &v
	return s
}

type UpdateWebhookResponseBody struct {
	// The result returned. Valid values:
	//
	// *   `true`: The modification is successful.
	// *   `false`: The modification fails.
	IsSuccess *bool `json:"IsSuccess,omitempty" xml:"IsSuccess,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateWebhookResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateWebhookResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateWebhookResponseBody) SetIsSuccess(v bool) *UpdateWebhookResponseBody {
	s.IsSuccess = &v
	return s
}

func (s *UpdateWebhookResponseBody) SetRequestId(v string) *UpdateWebhookResponseBody {
	s.RequestId = &v
	return s
}

type UpdateWebhookResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateWebhookResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateWebhookResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateWebhookResponse) GoString() string {
	return s.String()
}

func (s *UpdateWebhookResponse) SetHeaders(v map[string]*string) *UpdateWebhookResponse {
	s.Headers = v
	return s
}

func (s *UpdateWebhookResponse) SetStatusCode(v int32) *UpdateWebhookResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateWebhookResponse) SetBody(v *UpdateWebhookResponseBody) *UpdateWebhookResponse {
	s.Body = v
	return s
}

type UpgradeAddonReleaseRequest struct {
	// Version of Addon.
	AddonVersion *string `json:"AddonVersion,omitempty" xml:"AddonVersion,omitempty"`
	// Whether to pre-check this request.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// Environment ID.
	EnvironmentId *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The name of Release.
	ReleaseName *string `json:"ReleaseName,omitempty" xml:"ReleaseName,omitempty"`
	// Metadata information.
	Values *string `json:"Values,omitempty" xml:"Values,omitempty"`
}

func (s UpgradeAddonReleaseRequest) String() string {
	return tea.Prettify(s)
}

func (s UpgradeAddonReleaseRequest) GoString() string {
	return s.String()
}

func (s *UpgradeAddonReleaseRequest) SetAddonVersion(v string) *UpgradeAddonReleaseRequest {
	s.AddonVersion = &v
	return s
}

func (s *UpgradeAddonReleaseRequest) SetDryRun(v bool) *UpgradeAddonReleaseRequest {
	s.DryRun = &v
	return s
}

func (s *UpgradeAddonReleaseRequest) SetEnvironmentId(v string) *UpgradeAddonReleaseRequest {
	s.EnvironmentId = &v
	return s
}

func (s *UpgradeAddonReleaseRequest) SetRegionId(v string) *UpgradeAddonReleaseRequest {
	s.RegionId = &v
	return s
}

func (s *UpgradeAddonReleaseRequest) SetReleaseName(v string) *UpgradeAddonReleaseRequest {
	s.ReleaseName = &v
	return s
}

func (s *UpgradeAddonReleaseRequest) SetValues(v string) *UpgradeAddonReleaseRequest {
	s.Values = &v
	return s
}

type UpgradeAddonReleaseResponseBody struct {
	// The status code. 200 indicates success.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Return a message.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The information returned when the request parameter is incorrect.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Whether the call was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpgradeAddonReleaseResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpgradeAddonReleaseResponseBody) GoString() string {
	return s.String()
}

func (s *UpgradeAddonReleaseResponseBody) SetCode(v int32) *UpgradeAddonReleaseResponseBody {
	s.Code = &v
	return s
}

func (s *UpgradeAddonReleaseResponseBody) SetData(v string) *UpgradeAddonReleaseResponseBody {
	s.Data = &v
	return s
}

func (s *UpgradeAddonReleaseResponseBody) SetMessage(v string) *UpgradeAddonReleaseResponseBody {
	s.Message = &v
	return s
}

func (s *UpgradeAddonReleaseResponseBody) SetRequestId(v string) *UpgradeAddonReleaseResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpgradeAddonReleaseResponseBody) SetSuccess(v bool) *UpgradeAddonReleaseResponseBody {
	s.Success = &v
	return s
}

type UpgradeAddonReleaseResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpgradeAddonReleaseResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpgradeAddonReleaseResponse) String() string {
	return tea.Prettify(s)
}

func (s UpgradeAddonReleaseResponse) GoString() string {
	return s.String()
}

func (s *UpgradeAddonReleaseResponse) SetHeaders(v map[string]*string) *UpgradeAddonReleaseResponse {
	s.Headers = v
	return s
}

func (s *UpgradeAddonReleaseResponse) SetStatusCode(v int32) *UpgradeAddonReleaseResponse {
	s.StatusCode = &v
	return s
}

func (s *UpgradeAddonReleaseResponse) SetBody(v *UpgradeAddonReleaseResponseBody) *UpgradeAddonReleaseResponse {
	s.Body = v
	return s
}

type UpgradeEnvironmentFeatureRequest struct {
	AliyunLang     *string `json:"AliyunLang,omitempty" xml:"AliyunLang,omitempty"`
	EnvironmentId  *string `json:"EnvironmentId,omitempty" xml:"EnvironmentId,omitempty"`
	FeatureName    *string `json:"FeatureName,omitempty" xml:"FeatureName,omitempty"`
	FeatureVersion *string `json:"FeatureVersion,omitempty" xml:"FeatureVersion,omitempty"`
	RegionId       *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	Values         *string `json:"Values,omitempty" xml:"Values,omitempty"`
}

func (s UpgradeEnvironmentFeatureRequest) String() string {
	return tea.Prettify(s)
}

func (s UpgradeEnvironmentFeatureRequest) GoString() string {
	return s.String()
}

func (s *UpgradeEnvironmentFeatureRequest) SetAliyunLang(v string) *UpgradeEnvironmentFeatureRequest {
	s.AliyunLang = &v
	return s
}

func (s *UpgradeEnvironmentFeatureRequest) SetEnvironmentId(v string) *UpgradeEnvironmentFeatureRequest {
	s.EnvironmentId = &v
	return s
}

func (s *UpgradeEnvironmentFeatureRequest) SetFeatureName(v string) *UpgradeEnvironmentFeatureRequest {
	s.FeatureName = &v
	return s
}

func (s *UpgradeEnvironmentFeatureRequest) SetFeatureVersion(v string) *UpgradeEnvironmentFeatureRequest {
	s.FeatureVersion = &v
	return s
}

func (s *UpgradeEnvironmentFeatureRequest) SetRegionId(v string) *UpgradeEnvironmentFeatureRequest {
	s.RegionId = &v
	return s
}

func (s *UpgradeEnvironmentFeatureRequest) SetValues(v string) *UpgradeEnvironmentFeatureRequest {
	s.Values = &v
	return s
}

type UpgradeEnvironmentFeatureResponseBody struct {
	Code    *int32             `json:"Code,omitempty" xml:"Code,omitempty"`
	Data    map[string]*string `json:"Data,omitempty" xml:"Data,omitempty"`
	Message *string            `json:"Message,omitempty" xml:"Message,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpgradeEnvironmentFeatureResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpgradeEnvironmentFeatureResponseBody) GoString() string {
	return s.String()
}

func (s *UpgradeEnvironmentFeatureResponseBody) SetCode(v int32) *UpgradeEnvironmentFeatureResponseBody {
	s.Code = &v
	return s
}

func (s *UpgradeEnvironmentFeatureResponseBody) SetData(v map[string]*string) *UpgradeEnvironmentFeatureResponseBody {
	s.Data = v
	return s
}

func (s *UpgradeEnvironmentFeatureResponseBody) SetMessage(v string) *UpgradeEnvironmentFeatureResponseBody {
	s.Message = &v
	return s
}

func (s *UpgradeEnvironmentFeatureResponseBody) SetRequestId(v string) *UpgradeEnvironmentFeatureResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpgradeEnvironmentFeatureResponseBody) SetSuccess(v bool) *UpgradeEnvironmentFeatureResponseBody {
	s.Success = &v
	return s
}

type UpgradeEnvironmentFeatureResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpgradeEnvironmentFeatureResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpgradeEnvironmentFeatureResponse) String() string {
	return tea.Prettify(s)
}

func (s UpgradeEnvironmentFeatureResponse) GoString() string {
	return s.String()
}

func (s *UpgradeEnvironmentFeatureResponse) SetHeaders(v map[string]*string) *UpgradeEnvironmentFeatureResponse {
	s.Headers = v
	return s
}

func (s *UpgradeEnvironmentFeatureResponse) SetStatusCode(v int32) *UpgradeEnvironmentFeatureResponse {
	s.StatusCode = &v
	return s
}

func (s *UpgradeEnvironmentFeatureResponse) SetBody(v *UpgradeEnvironmentFeatureResponseBody) *UpgradeEnvironmentFeatureResponse {
	s.Body = v
	return s
}

type UploadRequest struct {
	// The version of the SourceMap file.
	Edition *string `json:"Edition,omitempty" xml:"Edition,omitempty"`
	// The content of the SourceMap file.
	File *string `json:"File,omitempty" xml:"File,omitempty"`
	// The name of the SourceMap file.
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The application ID.
	//
	// Log on to the **ARMS console**. In the left-side navigation pane, choose **Browser Monitoring** > **Browser Monitoring**. On the Browser Monitoring page, click the name of an application. The URL in the address bar contains the process ID (PID) of the application. The PID is indicated in the pid=xxx format. The PID is usually percent encoded as xxx%40xxx. You must modify this value to remove the percent encoding. For example, if the PID in the URL is eb4zdose6v%409781be0f44d\*\*\*\*, you must replace %40 with @ to obtain eb4zdose6v@9781be0f44d\*\*\*\*.
	Pid *string `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The ID of the region to which the SourceMap file is uploaded.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// We recommend that you do not specify this parameter.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s UploadRequest) String() string {
	return tea.Prettify(s)
}

func (s UploadRequest) GoString() string {
	return s.String()
}

func (s *UploadRequest) SetEdition(v string) *UploadRequest {
	s.Edition = &v
	return s
}

func (s *UploadRequest) SetFile(v string) *UploadRequest {
	s.File = &v
	return s
}

func (s *UploadRequest) SetFileName(v string) *UploadRequest {
	s.FileName = &v
	return s
}

func (s *UploadRequest) SetPid(v string) *UploadRequest {
	s.Pid = &v
	return s
}

func (s *UploadRequest) SetRegionId(v string) *UploadRequest {
	s.RegionId = &v
	return s
}

func (s *UploadRequest) SetVersion(v string) *UploadRequest {
	s.Version = &v
	return s
}

type UploadResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned data.
	UploadResult *UploadResponseBodyUploadResult `json:"UploadResult,omitempty" xml:"UploadResult,omitempty" type:"Struct"`
}

func (s UploadResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UploadResponseBody) GoString() string {
	return s.String()
}

func (s *UploadResponseBody) SetRequestId(v string) *UploadResponseBody {
	s.RequestId = &v
	return s
}

func (s *UploadResponseBody) SetUploadResult(v *UploadResponseBodyUploadResult) *UploadResponseBody {
	s.UploadResult = v
	return s
}

type UploadResponseBodyUploadResult struct {
	// The ID of the SourceMap file.
	Fid *string `json:"Fid,omitempty" xml:"Fid,omitempty"`
	// The name of the SourceMap file.
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The time when the file was uploaded.
	UploadTime *string `json:"UploadTime,omitempty" xml:"UploadTime,omitempty"`
}

func (s UploadResponseBodyUploadResult) String() string {
	return tea.Prettify(s)
}

func (s UploadResponseBodyUploadResult) GoString() string {
	return s.String()
}

func (s *UploadResponseBodyUploadResult) SetFid(v string) *UploadResponseBodyUploadResult {
	s.Fid = &v
	return s
}

func (s *UploadResponseBodyUploadResult) SetFileName(v string) *UploadResponseBodyUploadResult {
	s.FileName = &v
	return s
}

func (s *UploadResponseBodyUploadResult) SetUploadTime(v string) *UploadResponseBodyUploadResult {
	s.UploadTime = &v
	return s
}

type UploadResponse struct {
	Headers    map[string]*string  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UploadResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UploadResponse) String() string {
	return tea.Prettify(s)
}

func (s UploadResponse) GoString() string {
	return s.String()
}

func (s *UploadResponse) SetHeaders(v map[string]*string) *UploadResponse {
	s.Headers = v
	return s
}

func (s *UploadResponse) SetStatusCode(v int32) *UploadResponse {
	s.StatusCode = &v
	return s
}

func (s *UploadResponse) SetBody(v *UploadResponseBody) *UploadResponse {
	s.Body = v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.SignatureAlgorithm = tea.String("v2")
	client.EndpointRule = tea.String("regional")
	client.EndpointMap = map[string]*string{
		"ap-northeast-2-pop":          tea.String("arms.aliyuncs.com"),
		"cn-beijing-finance-1":        tea.String("arms.aliyuncs.com"),
		"cn-beijing-finance-pop":      tea.String("arms.aliyuncs.com"),
		"cn-beijing-gov-1":            tea.String("arms.aliyuncs.com"),
		"cn-beijing-nu16-b01":         tea.String("arms.aliyuncs.com"),
		"cn-edge-1":                   tea.String("arms.aliyuncs.com"),
		"cn-fujian":                   tea.String("arms.aliyuncs.com"),
		"cn-haidian-cm12-c01":         tea.String("arms.aliyuncs.com"),
		"cn-hangzhou-bj-b01":          tea.String("arms.aliyuncs.com"),
		"cn-hangzhou-internal-prod-1": tea.String("arms.aliyuncs.com"),
		"cn-hangzhou-internal-test-1": tea.String("arms.aliyuncs.com"),
		"cn-hangzhou-internal-test-2": tea.String("arms.aliyuncs.com"),
		"cn-hangzhou-internal-test-3": tea.String("arms.aliyuncs.com"),
		"cn-hangzhou-test-306":        tea.String("arms.aliyuncs.com"),
		"cn-hongkong-finance-pop":     tea.String("arms.aliyuncs.com"),
		"cn-huhehaote-nebula-1":       tea.String("arms.aliyuncs.com"),
		"cn-qingdao-nebula":           tea.String("arms.aliyuncs.com"),
		"cn-shanghai-et15-b01":        tea.String("arms.aliyuncs.com"),
		"cn-shanghai-et2-b01":         tea.String("arms.aliyuncs.com"),
		"cn-shanghai-inner":           tea.String("arms.aliyuncs.com"),
		"cn-shanghai-internal-test-1": tea.String("arms.aliyuncs.com"),
		"cn-shenzhen-inner":           tea.String("arms.aliyuncs.com"),
		"cn-shenzhen-st4-d01":         tea.String("arms.aliyuncs.com"),
		"cn-shenzhen-su18-b01":        tea.String("arms.aliyuncs.com"),
		"cn-wuhan":                    tea.String("arms.aliyuncs.com"),
		"cn-yushanfang":               tea.String("arms.aliyuncs.com"),
		"cn-zhangbei":                 tea.String("arms.aliyuncs.com"),
		"cn-zhangbei-na61-b01":        tea.String("arms.aliyuncs.com"),
		"cn-zhangjiakou-na62-a01":     tea.String("arms.aliyuncs.com"),
		"cn-zhengzhou-nebula-1":       tea.String("arms.aliyuncs.com"),
		"eu-west-1-oxs":               tea.String("arms.aliyuncs.com"),
		"me-east-1":                   tea.String("arms.aliyuncs.com"),
		"rus-west-1-pop":              tea.String("arms.aliyuncs.com"),
	}
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(tea.String("arms"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !tea.BoolValue(util.Empty(endpoint)) {
		_result = endpoint
		return _result, _err
	}

	if !tea.BoolValue(util.IsUnset(endpointMap)) && !tea.BoolValue(util.Empty(endpointMap[tea.StringValue(regionId)])) {
		_result = endpointMap[tea.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := endpointutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddAliClusterIdsToPrometheusGlobalViewWithOptions(request *AddAliClusterIdsToPrometheusGlobalViewRequest, runtime *util.RuntimeOptions) (_result *AddAliClusterIdsToPrometheusGlobalViewResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterIds)) {
		query["ClusterIds"] = request.ClusterIds
	}

	if !tea.BoolValue(util.IsUnset(request.GlobalViewClusterId)) {
		query["GlobalViewClusterId"] = request.GlobalViewClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddAliClusterIdsToPrometheusGlobalView"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddAliClusterIdsToPrometheusGlobalViewResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddAliClusterIdsToPrometheusGlobalView(request *AddAliClusterIdsToPrometheusGlobalViewRequest) (_result *AddAliClusterIdsToPrometheusGlobalViewResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddAliClusterIdsToPrometheusGlobalViewResponse{}
	_body, _err := client.AddAliClusterIdsToPrometheusGlobalViewWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddGrafanaWithOptions(request *AddGrafanaRequest, runtime *util.RuntimeOptions) (_result *AddGrafanaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Integration)) {
		query["Integration"] = request.Integration
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddGrafana"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddGrafanaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddGrafana(request *AddGrafanaRequest) (_result *AddGrafanaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddGrafanaResponse{}
	_body, _err := client.AddGrafanaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddIntegrationWithOptions(request *AddIntegrationRequest, runtime *util.RuntimeOptions) (_result *AddIntegrationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Integration)) {
		query["Integration"] = request.Integration
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddIntegration"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddIntegrationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddIntegration(request *AddIntegrationRequest) (_result *AddIntegrationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddIntegrationResponse{}
	_body, _err := client.AddIntegrationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddPrometheusGlobalViewWithOptions(request *AddPrometheusGlobalViewRequest, runtime *util.RuntimeOptions) (_result *AddPrometheusGlobalViewResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Clusters)) {
		query["Clusters"] = request.Clusters
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddPrometheusGlobalView"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddPrometheusGlobalViewResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddPrometheusGlobalView(request *AddPrometheusGlobalViewRequest) (_result *AddPrometheusGlobalViewResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddPrometheusGlobalViewResponse{}
	_body, _err := client.AddPrometheusGlobalViewWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddPrometheusGlobalViewByAliClusterIdsWithOptions(request *AddPrometheusGlobalViewByAliClusterIdsRequest, runtime *util.RuntimeOptions) (_result *AddPrometheusGlobalViewByAliClusterIdsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterIds)) {
		query["ClusterIds"] = request.ClusterIds
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.ProductCode)) {
		query["ProductCode"] = request.ProductCode
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddPrometheusGlobalViewByAliClusterIds"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddPrometheusGlobalViewByAliClusterIdsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddPrometheusGlobalViewByAliClusterIds(request *AddPrometheusGlobalViewByAliClusterIdsRequest) (_result *AddPrometheusGlobalViewByAliClusterIdsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddPrometheusGlobalViewByAliClusterIdsResponse{}
	_body, _err := client.AddPrometheusGlobalViewByAliClusterIdsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddPrometheusInstanceWithOptions(request *AddPrometheusInstanceRequest, runtime *util.RuntimeOptions) (_result *AddPrometheusInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddPrometheusInstance"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddPrometheusInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddPrometheusInstance(request *AddPrometheusInstanceRequest) (_result *AddPrometheusInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddPrometheusInstanceResponse{}
	_body, _err := client.AddPrometheusInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddPrometheusIntegrationWithOptions(request *AddPrometheusIntegrationRequest, runtime *util.RuntimeOptions) (_result *AddPrometheusIntegrationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.IntegrationType)) {
		query["IntegrationType"] = request.IntegrationType
	}

	if !tea.BoolValue(util.IsUnset(request.Param)) {
		query["Param"] = request.Param
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddPrometheusIntegration"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddPrometheusIntegrationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddPrometheusIntegration(request *AddPrometheusIntegrationRequest) (_result *AddPrometheusIntegrationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddPrometheusIntegrationResponse{}
	_body, _err := client.AddPrometheusIntegrationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddPrometheusRemoteWriteWithOptions(request *AddPrometheusRemoteWriteRequest, runtime *util.RuntimeOptions) (_result *AddPrometheusRemoteWriteResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RemoteWriteYaml)) {
		body["RemoteWriteYaml"] = request.RemoteWriteYaml
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("AddPrometheusRemoteWrite"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddPrometheusRemoteWriteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddPrometheusRemoteWrite(request *AddPrometheusRemoteWriteRequest) (_result *AddPrometheusRemoteWriteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddPrometheusRemoteWriteResponse{}
	_body, _err := client.AddPrometheusRemoteWriteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddRecordingRuleWithOptions(request *AddRecordingRuleRequest, runtime *util.RuntimeOptions) (_result *AddRecordingRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleYaml)) {
		query["RuleYaml"] = request.RuleYaml
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddRecordingRule"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddRecordingRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddRecordingRule(request *AddRecordingRuleRequest) (_result *AddRecordingRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddRecordingRuleResponse{}
	_body, _err := client.AddRecordingRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddTagToFlinkClusterWithOptions(request *AddTagToFlinkClusterRequest, runtime *util.RuntimeOptions) (_result *AddTagToFlinkClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.FlinkWorkSpaceId)) {
		query["FlinkWorkSpaceId"] = request.FlinkWorkSpaceId
	}

	if !tea.BoolValue(util.IsUnset(request.FlinkWorkSpaceName)) {
		query["FlinkWorkSpaceName"] = request.FlinkWorkSpaceName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetUserId)) {
		query["TargetUserId"] = request.TargetUserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddTagToFlinkCluster"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddTagToFlinkClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddTagToFlinkCluster(request *AddTagToFlinkClusterRequest) (_result *AddTagToFlinkClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddTagToFlinkClusterResponse{}
	_body, _err := client.AddTagToFlinkClusterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AppendInstancesToPrometheusGlobalViewWithOptions(request *AppendInstancesToPrometheusGlobalViewRequest, runtime *util.RuntimeOptions) (_result *AppendInstancesToPrometheusGlobalViewResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Clusters)) {
		query["Clusters"] = request.Clusters
	}

	if !tea.BoolValue(util.IsUnset(request.GlobalViewClusterId)) {
		query["GlobalViewClusterId"] = request.GlobalViewClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AppendInstancesToPrometheusGlobalView"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AppendInstancesToPrometheusGlobalViewResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AppendInstancesToPrometheusGlobalView(request *AppendInstancesToPrometheusGlobalViewRequest) (_result *AppendInstancesToPrometheusGlobalViewResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AppendInstancesToPrometheusGlobalViewResponse{}
	_body, _err := client.AppendInstancesToPrometheusGlobalViewWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ApplyScenarioWithOptions(tmpReq *ApplyScenarioRequest, runtime *util.RuntimeOptions) (_result *ApplyScenarioResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ApplyScenarioShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Config)) {
		request.ConfigShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Config, tea.String("Config"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigShrink)) {
		query["Config"] = request.ConfigShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Scenario)) {
		query["Scenario"] = request.Scenario
	}

	if !tea.BoolValue(util.IsUnset(request.Sign)) {
		query["Sign"] = request.Sign
	}

	if !tea.BoolValue(util.IsUnset(request.SnDump)) {
		query["SnDump"] = request.SnDump
	}

	if !tea.BoolValue(util.IsUnset(request.SnForce)) {
		query["SnForce"] = request.SnForce
	}

	if !tea.BoolValue(util.IsUnset(request.SnStat)) {
		query["SnStat"] = request.SnStat
	}

	if !tea.BoolValue(util.IsUnset(request.SnTransfer)) {
		query["SnTransfer"] = request.SnTransfer
	}

	if !tea.BoolValue(util.IsUnset(request.UpdateOption)) {
		query["UpdateOption"] = request.UpdateOption
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ApplyScenario"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ApplyScenarioResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ApplyScenario(request *ApplyScenarioRequest) (_result *ApplyScenarioResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ApplyScenarioResponse{}
	_body, _err := client.ApplyScenarioWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BindPrometheusGrafanaInstanceWithOptions(request *BindPrometheusGrafanaInstanceRequest, runtime *util.RuntimeOptions) (_result *BindPrometheusGrafanaInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.GrafanaInstanceId)) {
		query["GrafanaInstanceId"] = request.GrafanaInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BindPrometheusGrafanaInstance"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BindPrometheusGrafanaInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BindPrometheusGrafanaInstance(request *BindPrometheusGrafanaInstanceRequest) (_result *BindPrometheusGrafanaInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BindPrometheusGrafanaInstanceResponse{}
	_body, _err := client.BindPrometheusGrafanaInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BlockAlarmNotificationWithOptions(request *BlockAlarmNotificationRequest, runtime *util.RuntimeOptions) (_result *BlockAlarmNotificationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlarmId)) {
		query["AlarmId"] = request.AlarmId
	}

	if !tea.BoolValue(util.IsUnset(request.HandlerId)) {
		query["HandlerId"] = request.HandlerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Timeout)) {
		query["Timeout"] = request.Timeout
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BlockAlarmNotification"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BlockAlarmNotificationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BlockAlarmNotification(request *BlockAlarmNotificationRequest) (_result *BlockAlarmNotificationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BlockAlarmNotificationResponse{}
	_body, _err := client.BlockAlarmNotificationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ChangeAlarmSeverityWithOptions(request *ChangeAlarmSeverityRequest, runtime *util.RuntimeOptions) (_result *ChangeAlarmSeverityResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlarmId)) {
		query["AlarmId"] = request.AlarmId
	}

	if !tea.BoolValue(util.IsUnset(request.HandlerId)) {
		query["HandlerId"] = request.HandlerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Severity)) {
		query["Severity"] = request.Severity
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ChangeAlarmSeverity"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ChangeAlarmSeverityResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ChangeAlarmSeverity(request *ChangeAlarmSeverityRequest) (_result *ChangeAlarmSeverityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ChangeAlarmSeverityResponse{}
	_body, _err := client.ChangeAlarmSeverityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ChangeResourceGroupWithOptions(request *ChangeResourceGroupRequest, runtime *util.RuntimeOptions) (_result *ChangeResourceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NewResourceGroupId)) {
		query["NewResourceGroupId"] = request.NewResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ChangeResourceGroup"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ChangeResourceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ChangeResourceGroup(request *ChangeResourceGroupRequest) (_result *ChangeResourceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ChangeResourceGroupResponse{}
	_body, _err := client.ChangeResourceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to check whether ARMS is available for commercial use in a region.
 *
 * @param request CheckCommercialStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckCommercialStatusResponse
 */
func (client *Client) CheckCommercialStatusWithOptions(request *CheckCommercialStatusRequest, runtime *util.RuntimeOptions) (_result *CheckCommercialStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CheckCommercialStatus"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CheckCommercialStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to check whether ARMS is available for commercial use in a region.
 *
 * @param request CheckCommercialStatusRequest
 * @return CheckCommercialStatusResponse
 */
func (client *Client) CheckCommercialStatus(request *CheckCommercialStatusRequest) (_result *CheckCommercialStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CheckCommercialStatusResponse{}
	_body, _err := client.CheckCommercialStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CheckServiceStatusWithOptions(request *CheckServiceStatusRequest, runtime *util.RuntimeOptions) (_result *CheckServiceStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SvcCode)) {
		query["SvcCode"] = request.SvcCode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CheckServiceStatus"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CheckServiceStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CheckServiceStatus(request *CheckServiceStatusRequest) (_result *CheckServiceStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CheckServiceStatusResponse{}
	_body, _err := client.CheckServiceStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ClaimAlarmWithOptions(request *ClaimAlarmRequest, runtime *util.RuntimeOptions) (_result *ClaimAlarmResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlarmId)) {
		query["AlarmId"] = request.AlarmId
	}

	if !tea.BoolValue(util.IsUnset(request.HandlerId)) {
		query["HandlerId"] = request.HandlerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ClaimAlarm"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ClaimAlarmResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ClaimAlarm(request *ClaimAlarmRequest) (_result *ClaimAlarmResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ClaimAlarmResponse{}
	_body, _err := client.ClaimAlarmWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CloseAlarmWithOptions(request *CloseAlarmRequest, runtime *util.RuntimeOptions) (_result *CloseAlarmResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlarmId)) {
		query["AlarmId"] = request.AlarmId
	}

	if !tea.BoolValue(util.IsUnset(request.HandlerId)) {
		query["HandlerId"] = request.HandlerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Solution)) {
		query["Solution"] = request.Solution
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CloseAlarm"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CloseAlarmResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CloseAlarm(request *CloseAlarmRequest) (_result *CloseAlarmResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CloseAlarmResponse{}
	_body, _err := client.CloseAlarmWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ****
 *
 * @param request ConfigAppRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfigAppResponse
 */
func (client *Client) ConfigAppWithOptions(request *ConfigAppRequest, runtime *util.RuntimeOptions) (_result *ConfigAppResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppIds)) {
		query["AppIds"] = request.AppIds
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ConfigApp"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ConfigAppResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ****
 *
 * @param request ConfigAppRequest
 * @return ConfigAppResponse
 */
func (client *Client) ConfigApp(request *ConfigAppRequest) (_result *ConfigAppResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ConfigAppResponse{}
	_body, _err := client.ConfigAppWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is no longer maintained. To create or modify an alert contact, call the CreateOrUpdateContact operation provided by the new version of the Alert Management module.
 *
 * @param request CreateAlertContactRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAlertContactResponse
 */
func (client *Client) CreateAlertContactWithOptions(request *CreateAlertContactRequest, runtime *util.RuntimeOptions) (_result *CreateAlertContactResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ContactName)) {
		query["ContactName"] = request.ContactName
	}

	if !tea.BoolValue(util.IsUnset(request.DingRobotWebhookUrl)) {
		query["DingRobotWebhookUrl"] = request.DingRobotWebhookUrl
	}

	if !tea.BoolValue(util.IsUnset(request.Email)) {
		query["Email"] = request.Email
	}

	if !tea.BoolValue(util.IsUnset(request.PhoneNum)) {
		query["PhoneNum"] = request.PhoneNum
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SystemNoc)) {
		query["SystemNoc"] = request.SystemNoc
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAlertContact"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateAlertContactResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is no longer maintained. To create or modify an alert contact, call the CreateOrUpdateContact operation provided by the new version of the Alert Management module.
 *
 * @param request CreateAlertContactRequest
 * @return CreateAlertContactResponse
 */
func (client *Client) CreateAlertContact(request *CreateAlertContactRequest) (_result *CreateAlertContactResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateAlertContactResponse{}
	_body, _err := client.CreateAlertContactWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateAlertContactGroupWithOptions(request *CreateAlertContactGroupRequest, runtime *util.RuntimeOptions) (_result *CreateAlertContactGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ContactGroupName)) {
		query["ContactGroupName"] = request.ContactGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.ContactIds)) {
		query["ContactIds"] = request.ContactIds
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAlertContactGroup"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateAlertContactGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateAlertContactGroup(request *CreateAlertContactGroupRequest) (_result *CreateAlertContactGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateAlertContactGroupResponse{}
	_body, _err := client.CreateAlertContactGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateDispatchRuleWithOptions(request *CreateDispatchRuleRequest, runtime *util.RuntimeOptions) (_result *CreateDispatchRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DispatchRule)) {
		query["DispatchRule"] = request.DispatchRule
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDispatchRule"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDispatchRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateDispatchRule(request *CreateDispatchRuleRequest) (_result *CreateDispatchRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDispatchRuleResponse{}
	_body, _err := client.CreateDispatchRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateEnvCustomJobWithOptions(request *CreateEnvCustomJobRequest, runtime *util.RuntimeOptions) (_result *CreateEnvCustomJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliyunLang)) {
		query["AliyunLang"] = request.AliyunLang
	}

	if !tea.BoolValue(util.IsUnset(request.CustomJobName)) {
		query["CustomJobName"] = request.CustomJobName
	}

	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigYaml)) {
		body["ConfigYaml"] = request.ConfigYaml
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateEnvCustomJob"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateEnvCustomJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateEnvCustomJob(request *CreateEnvCustomJobRequest) (_result *CreateEnvCustomJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateEnvCustomJobResponse{}
	_body, _err := client.CreateEnvCustomJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateEnvPodMonitorWithOptions(request *CreateEnvPodMonitorRequest, runtime *util.RuntimeOptions) (_result *CreateEnvPodMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliyunLang)) {
		query["AliyunLang"] = request.AliyunLang
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigYaml)) {
		body["ConfigYaml"] = request.ConfigYaml
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateEnvPodMonitor"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateEnvPodMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateEnvPodMonitor(request *CreateEnvPodMonitorRequest) (_result *CreateEnvPodMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateEnvPodMonitorResponse{}
	_body, _err := client.CreateEnvPodMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateEnvServiceMonitorWithOptions(request *CreateEnvServiceMonitorRequest, runtime *util.RuntimeOptions) (_result *CreateEnvServiceMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliyunLang)) {
		query["AliyunLang"] = request.AliyunLang
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigYaml)) {
		body["ConfigYaml"] = request.ConfigYaml
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateEnvServiceMonitor"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateEnvServiceMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateEnvServiceMonitor(request *CreateEnvServiceMonitorRequest) (_result *CreateEnvServiceMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateEnvServiceMonitorResponse{}
	_body, _err := client.CreateEnvServiceMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateEnvironmentWithOptions(request *CreateEnvironmentRequest, runtime *util.RuntimeOptions) (_result *CreateEnvironmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliyunLang)) {
		query["AliyunLang"] = request.AliyunLang
	}

	if !tea.BoolValue(util.IsUnset(request.BindResourceId)) {
		query["BindResourceId"] = request.BindResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.EnvironmentName)) {
		query["EnvironmentName"] = request.EnvironmentName
	}

	if !tea.BoolValue(util.IsUnset(request.EnvironmentSubType)) {
		query["EnvironmentSubType"] = request.EnvironmentSubType
	}

	if !tea.BoolValue(util.IsUnset(request.EnvironmentType)) {
		query["EnvironmentType"] = request.EnvironmentType
	}

	if !tea.BoolValue(util.IsUnset(request.ManagedType)) {
		query["ManagedType"] = request.ManagedType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateEnvironment"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateEnvironmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateEnvironment(request *CreateEnvironmentRequest) (_result *CreateEnvironmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateEnvironmentResponse{}
	_body, _err := client.CreateEnvironmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateGrafanaWorkspaceWithOptions(tmpReq *CreateGrafanaWorkspaceRequest, runtime *util.RuntimeOptions) (_result *CreateGrafanaWorkspaceResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateGrafanaWorkspaceShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Tags)) {
		request.TagsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Tags, tea.String("Tags"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliyunLang)) {
		query["AliyunLang"] = request.AliyunLang
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.GrafanaVersion)) {
		query["GrafanaVersion"] = request.GrafanaVersion
	}

	if !tea.BoolValue(util.IsUnset(request.GrafanaWorkspaceEdition)) {
		query["GrafanaWorkspaceEdition"] = request.GrafanaWorkspaceEdition
	}

	if !tea.BoolValue(util.IsUnset(request.GrafanaWorkspaceName)) {
		query["GrafanaWorkspaceName"] = request.GrafanaWorkspaceName
	}

	if !tea.BoolValue(util.IsUnset(request.Password)) {
		query["Password"] = request.Password
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.TagsShrink)) {
		query["Tags"] = request.TagsShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateGrafanaWorkspace"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateGrafanaWorkspaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateGrafanaWorkspace(request *CreateGrafanaWorkspaceRequest) (_result *CreateGrafanaWorkspaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateGrafanaWorkspaceResponse{}
	_body, _err := client.CreateGrafanaWorkspaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateIntegrationWithOptions(request *CreateIntegrationRequest, runtime *util.RuntimeOptions) (_result *CreateIntegrationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoRecover)) {
		body["AutoRecover"] = request.AutoRecover
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.IntegrationName)) {
		body["IntegrationName"] = request.IntegrationName
	}

	if !tea.BoolValue(util.IsUnset(request.IntegrationProductType)) {
		body["IntegrationProductType"] = request.IntegrationProductType
	}

	if !tea.BoolValue(util.IsUnset(request.RecoverTime)) {
		body["RecoverTime"] = request.RecoverTime
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateIntegration"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateIntegrationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateIntegration(request *CreateIntegrationRequest) (_result *CreateIntegrationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateIntegrationResponse{}
	_body, _err := client.CreateIntegrationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateOrUpdateAlertRuleWithOptions(request *CreateOrUpdateAlertRuleRequest, runtime *util.RuntimeOptions) (_result *CreateOrUpdateAlertRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertCheckType)) {
		body["AlertCheckType"] = request.AlertCheckType
	}

	if !tea.BoolValue(util.IsUnset(request.AlertGroup)) {
		body["AlertGroup"] = request.AlertGroup
	}

	if !tea.BoolValue(util.IsUnset(request.AlertId)) {
		body["AlertId"] = request.AlertId
	}

	if !tea.BoolValue(util.IsUnset(request.AlertName)) {
		body["AlertName"] = request.AlertName
	}

	if !tea.BoolValue(util.IsUnset(request.AlertPiplines)) {
		body["AlertPiplines"] = request.AlertPiplines
	}

	if !tea.BoolValue(util.IsUnset(request.AlertRuleContent)) {
		body["AlertRuleContent"] = request.AlertRuleContent
	}

	if !tea.BoolValue(util.IsUnset(request.AlertStatus)) {
		body["AlertStatus"] = request.AlertStatus
	}

	if !tea.BoolValue(util.IsUnset(request.AlertType)) {
		body["AlertType"] = request.AlertType
	}

	if !tea.BoolValue(util.IsUnset(request.Annotations)) {
		body["Annotations"] = request.Annotations
	}

	if !tea.BoolValue(util.IsUnset(request.AutoAddNewApplication)) {
		body["AutoAddNewApplication"] = request.AutoAddNewApplication
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		body["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.DataConfig)) {
		body["DataConfig"] = request.DataConfig
	}

	if !tea.BoolValue(util.IsUnset(request.Duration)) {
		body["Duration"] = request.Duration
	}

	if !tea.BoolValue(util.IsUnset(request.Filters)) {
		body["Filters"] = request.Filters
	}

	if !tea.BoolValue(util.IsUnset(request.Labels)) {
		body["Labels"] = request.Labels
	}

	if !tea.BoolValue(util.IsUnset(request.Level)) {
		body["Level"] = request.Level
	}

	if !tea.BoolValue(util.IsUnset(request.MarkTags)) {
		body["MarkTags"] = request.MarkTags
	}

	if !tea.BoolValue(util.IsUnset(request.Message)) {
		body["Message"] = request.Message
	}

	if !tea.BoolValue(util.IsUnset(request.MetricsKey)) {
		body["MetricsKey"] = request.MetricsKey
	}

	if !tea.BoolValue(util.IsUnset(request.MetricsType)) {
		body["MetricsType"] = request.MetricsType
	}

	if !tea.BoolValue(util.IsUnset(request.Notice)) {
		body["Notice"] = request.Notice
	}

	if !tea.BoolValue(util.IsUnset(request.NotifyMode)) {
		body["NotifyMode"] = request.NotifyMode
	}

	if !tea.BoolValue(util.IsUnset(request.NotifyStrategy)) {
		body["NotifyStrategy"] = request.NotifyStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.Pids)) {
		body["Pids"] = request.Pids
	}

	if !tea.BoolValue(util.IsUnset(request.PromQL)) {
		body["PromQL"] = request.PromQL
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		body["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		body["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOrUpdateAlertRule"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateOrUpdateAlertRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateOrUpdateAlertRule(request *CreateOrUpdateAlertRuleRequest) (_result *CreateOrUpdateAlertRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateOrUpdateAlertRuleResponse{}
	_body, _err := client.CreateOrUpdateAlertRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateOrUpdateContactWithOptions(request *CreateOrUpdateContactRequest, runtime *util.RuntimeOptions) (_result *CreateOrUpdateContactResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DingRobotUrl)) {
		query["DingRobotUrl"] = request.DingRobotUrl
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ContactId)) {
		body["ContactId"] = request.ContactId
	}

	if !tea.BoolValue(util.IsUnset(request.ContactName)) {
		body["ContactName"] = request.ContactName
	}

	if !tea.BoolValue(util.IsUnset(request.Email)) {
		body["Email"] = request.Email
	}

	if !tea.BoolValue(util.IsUnset(request.IsEmailVerify)) {
		body["IsEmailVerify"] = request.IsEmailVerify
	}

	if !tea.BoolValue(util.IsUnset(request.Phone)) {
		body["Phone"] = request.Phone
	}

	if !tea.BoolValue(util.IsUnset(request.ReissueSendNotice)) {
		body["ReissueSendNotice"] = request.ReissueSendNotice
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOrUpdateContact"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateOrUpdateContactResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateOrUpdateContact(request *CreateOrUpdateContactRequest) (_result *CreateOrUpdateContactResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateOrUpdateContactResponse{}
	_body, _err := client.CreateOrUpdateContactWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateOrUpdateContactGroupWithOptions(request *CreateOrUpdateContactGroupRequest, runtime *util.RuntimeOptions) (_result *CreateOrUpdateContactGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ContactGroupId)) {
		body["ContactGroupId"] = request.ContactGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ContactGroupName)) {
		body["ContactGroupName"] = request.ContactGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.ContactIds)) {
		body["ContactIds"] = request.ContactIds
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOrUpdateContactGroup"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateOrUpdateContactGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateOrUpdateContactGroup(request *CreateOrUpdateContactGroupRequest) (_result *CreateOrUpdateContactGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateOrUpdateContactGroupResponse{}
	_body, _err := client.CreateOrUpdateContactGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateOrUpdateEventBridgeIntegrationWithOptions(request *CreateOrUpdateEventBridgeIntegrationRequest, runtime *util.RuntimeOptions) (_result *CreateOrUpdateEventBridgeIntegrationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccessKey)) {
		body["AccessKey"] = request.AccessKey
	}

	if !tea.BoolValue(util.IsUnset(request.AccessSecret)) {
		body["AccessSecret"] = request.AccessSecret
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Endpoint)) {
		body["Endpoint"] = request.Endpoint
	}

	if !tea.BoolValue(util.IsUnset(request.EventBusName)) {
		body["EventBusName"] = request.EventBusName
	}

	if !tea.BoolValue(util.IsUnset(request.EventBusRegionId)) {
		body["EventBusRegionId"] = request.EventBusRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		body["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		body["Source"] = request.Source
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOrUpdateEventBridgeIntegration"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateOrUpdateEventBridgeIntegrationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateOrUpdateEventBridgeIntegration(request *CreateOrUpdateEventBridgeIntegrationRequest) (_result *CreateOrUpdateEventBridgeIntegrationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateOrUpdateEventBridgeIntegrationResponse{}
	_body, _err := client.CreateOrUpdateEventBridgeIntegrationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateOrUpdateIMRobotWithOptions(request *CreateOrUpdateIMRobotRequest, runtime *util.RuntimeOptions) (_result *CreateOrUpdateIMRobotResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CardTemplate)) {
		body["CardTemplate"] = request.CardTemplate
	}

	if !tea.BoolValue(util.IsUnset(request.DailyNoc)) {
		body["DailyNoc"] = request.DailyNoc
	}

	if !tea.BoolValue(util.IsUnset(request.DailyNocTime)) {
		body["DailyNocTime"] = request.DailyNocTime
	}

	if !tea.BoolValue(util.IsUnset(request.DingSignKey)) {
		body["DingSignKey"] = request.DingSignKey
	}

	if !tea.BoolValue(util.IsUnset(request.EnableOutgoing)) {
		body["EnableOutgoing"] = request.EnableOutgoing
	}

	if !tea.BoolValue(util.IsUnset(request.RobotAddress)) {
		body["RobotAddress"] = request.RobotAddress
	}

	if !tea.BoolValue(util.IsUnset(request.RobotId)) {
		body["RobotId"] = request.RobotId
	}

	if !tea.BoolValue(util.IsUnset(request.RobotName)) {
		body["RobotName"] = request.RobotName
	}

	if !tea.BoolValue(util.IsUnset(request.Token)) {
		body["Token"] = request.Token
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		body["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOrUpdateIMRobot"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateOrUpdateIMRobotResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateOrUpdateIMRobot(request *CreateOrUpdateIMRobotRequest) (_result *CreateOrUpdateIMRobotResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateOrUpdateIMRobotResponse{}
	_body, _err := client.CreateOrUpdateIMRobotWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateOrUpdateNotificationPolicyWithOptions(request *CreateOrUpdateNotificationPolicyRequest, runtime *util.RuntimeOptions) (_result *CreateOrUpdateNotificationPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DirectedMode)) {
		body["DirectedMode"] = request.DirectedMode
	}

	if !tea.BoolValue(util.IsUnset(request.EscalationPolicyId)) {
		body["EscalationPolicyId"] = request.EscalationPolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupRule)) {
		body["GroupRule"] = request.GroupRule
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		body["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.IntegrationId)) {
		body["IntegrationId"] = request.IntegrationId
	}

	if !tea.BoolValue(util.IsUnset(request.MatchingRules)) {
		body["MatchingRules"] = request.MatchingRules
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.NotifyRule)) {
		body["NotifyRule"] = request.NotifyRule
	}

	if !tea.BoolValue(util.IsUnset(request.NotifyTemplate)) {
		body["NotifyTemplate"] = request.NotifyTemplate
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		body["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Repeat)) {
		body["Repeat"] = request.Repeat
	}

	if !tea.BoolValue(util.IsUnset(request.RepeatInterval)) {
		body["RepeatInterval"] = request.RepeatInterval
	}

	if !tea.BoolValue(util.IsUnset(request.SendRecoverMessage)) {
		body["SendRecoverMessage"] = request.SendRecoverMessage
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOrUpdateNotificationPolicy"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateOrUpdateNotificationPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateOrUpdateNotificationPolicy(request *CreateOrUpdateNotificationPolicyRequest) (_result *CreateOrUpdateNotificationPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateOrUpdateNotificationPolicyResponse{}
	_body, _err := client.CreateOrUpdateNotificationPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateOrUpdateSilencePolicyWithOptions(request *CreateOrUpdateSilencePolicyRequest, runtime *util.RuntimeOptions) (_result *CreateOrUpdateSilencePolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Id)) {
		body["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.MatchingRules)) {
		body["MatchingRules"] = request.MatchingRules
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		body["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOrUpdateSilencePolicy"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateOrUpdateSilencePolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateOrUpdateSilencePolicy(request *CreateOrUpdateSilencePolicyRequest) (_result *CreateOrUpdateSilencePolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateOrUpdateSilencePolicyResponse{}
	_body, _err := client.CreateOrUpdateSilencePolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateOrUpdateWebhookContactWithOptions(request *CreateOrUpdateWebhookContactRequest, runtime *util.RuntimeOptions) (_result *CreateOrUpdateWebhookContactResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BizHeaders)) {
		body["BizHeaders"] = request.BizHeaders
	}

	if !tea.BoolValue(util.IsUnset(request.BizParams)) {
		body["BizParams"] = request.BizParams
	}

	if !tea.BoolValue(util.IsUnset(request.Body)) {
		body["Body"] = request.Body
	}

	if !tea.BoolValue(util.IsUnset(request.Method)) {
		body["Method"] = request.Method
	}

	if !tea.BoolValue(util.IsUnset(request.RecoverBody)) {
		body["RecoverBody"] = request.RecoverBody
	}

	if !tea.BoolValue(util.IsUnset(request.Url)) {
		body["Url"] = request.Url
	}

	if !tea.BoolValue(util.IsUnset(request.WebhookId)) {
		body["WebhookId"] = request.WebhookId
	}

	if !tea.BoolValue(util.IsUnset(request.WebhookName)) {
		body["WebhookName"] = request.WebhookName
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOrUpdateWebhookContact"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateOrUpdateWebhookContactResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateOrUpdateWebhookContact(request *CreateOrUpdateWebhookContactRequest) (_result *CreateOrUpdateWebhookContactResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateOrUpdateWebhookContactResponse{}
	_body, _err := client.CreateOrUpdateWebhookContactWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreatePrometheusAlertRuleWithOptions(request *CreatePrometheusAlertRuleRequest, runtime *util.RuntimeOptions) (_result *CreatePrometheusAlertRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertName)) {
		query["AlertName"] = request.AlertName
	}

	if !tea.BoolValue(util.IsUnset(request.Annotations)) {
		query["Annotations"] = request.Annotations
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.DispatchRuleId)) {
		query["DispatchRuleId"] = request.DispatchRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.Duration)) {
		query["Duration"] = request.Duration
	}

	if !tea.BoolValue(util.IsUnset(request.Expression)) {
		query["Expression"] = request.Expression
	}

	if !tea.BoolValue(util.IsUnset(request.Labels)) {
		query["Labels"] = request.Labels
	}

	if !tea.BoolValue(util.IsUnset(request.Message)) {
		query["Message"] = request.Message
	}

	if !tea.BoolValue(util.IsUnset(request.NotifyType)) {
		query["NotifyType"] = request.NotifyType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreatePrometheusAlertRule"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreatePrometheusAlertRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreatePrometheusAlertRule(request *CreatePrometheusAlertRuleRequest) (_result *CreatePrometheusAlertRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreatePrometheusAlertRuleResponse{}
	_body, _err := client.CreatePrometheusAlertRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreatePrometheusInstanceWithOptions(request *CreatePrometheusInstanceRequest, runtime *util.RuntimeOptions) (_result *CreatePrometheusInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AllSubClustersSuccess)) {
		query["AllSubClustersSuccess"] = request.AllSubClustersSuccess
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterName)) {
		query["ClusterName"] = request.ClusterName
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterType)) {
		query["ClusterType"] = request.ClusterType
	}

	if !tea.BoolValue(util.IsUnset(request.GrafanaInstanceId)) {
		query["GrafanaInstanceId"] = request.GrafanaInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityGroupId)) {
		query["SecurityGroupId"] = request.SecurityGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SubClustersJson)) {
		query["SubClustersJson"] = request.SubClustersJson
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreatePrometheusInstance"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreatePrometheusInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreatePrometheusInstance(request *CreatePrometheusInstanceRequest) (_result *CreatePrometheusInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreatePrometheusInstanceResponse{}
	_body, _err := client.CreatePrometheusInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreatePrometheusMonitoringWithOptions(request *CreatePrometheusMonitoringRequest, runtime *util.RuntimeOptions) (_result *CreatePrometheusMonitoringResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigYaml)) {
		body["ConfigYaml"] = request.ConfigYaml
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreatePrometheusMonitoring"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreatePrometheusMonitoringResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreatePrometheusMonitoring(request *CreatePrometheusMonitoringRequest) (_result *CreatePrometheusMonitoringResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreatePrometheusMonitoringResponse{}
	_body, _err := client.CreatePrometheusMonitoringWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateRetcodeAppWithOptions(request *CreateRetcodeAppRequest, runtime *util.RuntimeOptions) (_result *CreateRetcodeAppResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RetcodeAppName)) {
		query["RetcodeAppName"] = request.RetcodeAppName
	}

	if !tea.BoolValue(util.IsUnset(request.RetcodeAppType)) {
		query["RetcodeAppType"] = request.RetcodeAppType
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateRetcodeApp"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateRetcodeAppResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateRetcodeApp(request *CreateRetcodeAppRequest) (_result *CreateRetcodeAppResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateRetcodeAppResponse{}
	_body, _err := client.CreateRetcodeAppWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateSyntheticTaskWithOptions(tmpReq *CreateSyntheticTaskRequest, runtime *util.RuntimeOptions) (_result *CreateSyntheticTaskResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateSyntheticTaskShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.CommonParam)) {
		request.CommonParamShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.CommonParam, tea.String("CommonParam"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.Download)) {
		request.DownloadShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Download, tea.String("Download"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.ExtendInterval)) {
		request.ExtendIntervalShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ExtendInterval, tea.String("ExtendInterval"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.MonitorList)) {
		request.MonitorListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.MonitorList, tea.String("MonitorList"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.Navigation)) {
		request.NavigationShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Navigation, tea.String("Navigation"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.Net)) {
		request.NetShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Net, tea.String("Net"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.Protocol)) {
		request.ProtocolShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Protocol, tea.String("Protocol"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CommonParamShrink)) {
		query["CommonParam"] = request.CommonParamShrink
	}

	if !tea.BoolValue(util.IsUnset(request.DownloadShrink)) {
		query["Download"] = request.DownloadShrink
	}

	if !tea.BoolValue(util.IsUnset(request.ExtendIntervalShrink)) {
		query["ExtendInterval"] = request.ExtendIntervalShrink
	}

	if !tea.BoolValue(util.IsUnset(request.IntervalTime)) {
		query["IntervalTime"] = request.IntervalTime
	}

	if !tea.BoolValue(util.IsUnset(request.IntervalType)) {
		query["IntervalType"] = request.IntervalType
	}

	if !tea.BoolValue(util.IsUnset(request.IpType)) {
		query["IpType"] = request.IpType
	}

	if !tea.BoolValue(util.IsUnset(request.MonitorListShrink)) {
		query["MonitorList"] = request.MonitorListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.NavigationShrink)) {
		query["Navigation"] = request.NavigationShrink
	}

	if !tea.BoolValue(util.IsUnset(request.NetShrink)) {
		query["Net"] = request.NetShrink
	}

	if !tea.BoolValue(util.IsUnset(request.ProtocolShrink)) {
		query["Protocol"] = request.ProtocolShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskName)) {
		query["TaskName"] = request.TaskName
	}

	if !tea.BoolValue(util.IsUnset(request.TaskType)) {
		query["TaskType"] = request.TaskType
	}

	if !tea.BoolValue(util.IsUnset(request.UpdateTask)) {
		query["UpdateTask"] = request.UpdateTask
	}

	if !tea.BoolValue(util.IsUnset(request.Url)) {
		query["Url"] = request.Url
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSyntheticTask"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateSyntheticTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateSyntheticTask(request *CreateSyntheticTaskRequest) (_result *CreateSyntheticTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateSyntheticTaskResponse{}
	_body, _err := client.CreateSyntheticTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateTimingSyntheticTaskWithOptions(tmpReq *CreateTimingSyntheticTaskRequest, runtime *util.RuntimeOptions) (_result *CreateTimingSyntheticTaskResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateTimingSyntheticTaskShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.AvailableAssertions)) {
		request.AvailableAssertionsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.AvailableAssertions, tea.String("AvailableAssertions"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.CommonSetting)) {
		request.CommonSettingShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.CommonSetting, tea.String("CommonSetting"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.CustomPeriod)) {
		request.CustomPeriodShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.CustomPeriod, tea.String("CustomPeriod"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.MonitorConf)) {
		request.MonitorConfShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.MonitorConf, tea.String("MonitorConf"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.Monitors)) {
		request.MonitorsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Monitors, tea.String("Monitors"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.Tags)) {
		request.TagsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Tags, tea.String("Tags"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AvailableAssertionsShrink)) {
		query["AvailableAssertions"] = request.AvailableAssertionsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.CommonSettingShrink)) {
		query["CommonSetting"] = request.CommonSettingShrink
	}

	if !tea.BoolValue(util.IsUnset(request.CustomPeriodShrink)) {
		query["CustomPeriod"] = request.CustomPeriodShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Frequency)) {
		query["Frequency"] = request.Frequency
	}

	if !tea.BoolValue(util.IsUnset(request.MonitorCategory)) {
		query["MonitorCategory"] = request.MonitorCategory
	}

	if !tea.BoolValue(util.IsUnset(request.MonitorConfShrink)) {
		query["MonitorConf"] = request.MonitorConfShrink
	}

	if !tea.BoolValue(util.IsUnset(request.MonitorsShrink)) {
		query["Monitors"] = request.MonitorsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.TagsShrink)) {
		query["Tags"] = request.TagsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.TaskType)) {
		query["TaskType"] = request.TaskType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTimingSyntheticTask"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTimingSyntheticTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateTimingSyntheticTask(request *CreateTimingSyntheticTaskRequest) (_result *CreateTimingSyntheticTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTimingSyntheticTaskResponse{}
	_body, _err := client.CreateTimingSyntheticTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateWebhookWithOptions(request *CreateWebhookRequest, runtime *util.RuntimeOptions) (_result *CreateWebhookResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Body)) {
		query["Body"] = request.Body
	}

	if !tea.BoolValue(util.IsUnset(request.ContactName)) {
		query["ContactName"] = request.ContactName
	}

	if !tea.BoolValue(util.IsUnset(request.HttpHeaders)) {
		query["HttpHeaders"] = request.HttpHeaders
	}

	if !tea.BoolValue(util.IsUnset(request.HttpParams)) {
		query["HttpParams"] = request.HttpParams
	}

	if !tea.BoolValue(util.IsUnset(request.Method)) {
		query["Method"] = request.Method
	}

	if !tea.BoolValue(util.IsUnset(request.RecoverBody)) {
		query["RecoverBody"] = request.RecoverBody
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Url)) {
		query["Url"] = request.Url
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateWebhook"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateWebhookResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateWebhook(request *CreateWebhookRequest) (_result *CreateWebhookResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateWebhookResponse{}
	_body, _err := client.CreateWebhookWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DelAuthTokenWithOptions(request *DelAuthTokenRequest, runtime *util.RuntimeOptions) (_result *DelAuthTokenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DelAuthToken"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DelAuthTokenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DelAuthToken(request *DelAuthTokenRequest) (_result *DelAuthTokenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DelAuthTokenResponse{}
	_body, _err := client.DelAuthTokenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteAddonReleaseWithOptions(request *DeleteAddonReleaseRequest, runtime *util.RuntimeOptions) (_result *DeleteAddonReleaseResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.Force)) {
		query["Force"] = request.Force
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ReleaseName)) {
		query["ReleaseName"] = request.ReleaseName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAddonRelease"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAddonReleaseResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteAddonRelease(request *DeleteAddonReleaseRequest) (_result *DeleteAddonReleaseResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAddonReleaseResponse{}
	_body, _err := client.DeleteAddonReleaseWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ********
 *
 * @param request DeleteAlertContactRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAlertContactResponse
 */
func (client *Client) DeleteAlertContactWithOptions(request *DeleteAlertContactRequest, runtime *util.RuntimeOptions) (_result *DeleteAlertContactResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ContactId)) {
		query["ContactId"] = request.ContactId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAlertContact"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAlertContactResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ********
 *
 * @param request DeleteAlertContactRequest
 * @return DeleteAlertContactResponse
 */
func (client *Client) DeleteAlertContact(request *DeleteAlertContactRequest) (_result *DeleteAlertContactResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAlertContactResponse{}
	_body, _err := client.DeleteAlertContactWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteAlertContactGroupWithOptions(request *DeleteAlertContactGroupRequest, runtime *util.RuntimeOptions) (_result *DeleteAlertContactGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ContactGroupId)) {
		query["ContactGroupId"] = request.ContactGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAlertContactGroup"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAlertContactGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteAlertContactGroup(request *DeleteAlertContactGroupRequest) (_result *DeleteAlertContactGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAlertContactGroupResponse{}
	_body, _err := client.DeleteAlertContactGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteAlertRuleWithOptions(request *DeleteAlertRuleRequest, runtime *util.RuntimeOptions) (_result *DeleteAlertRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertId)) {
		query["AlertId"] = request.AlertId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAlertRule"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAlertRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteAlertRule(request *DeleteAlertRuleRequest) (_result *DeleteAlertRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAlertRuleResponse{}
	_body, _err := client.DeleteAlertRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteAlertRulesWithOptions(request *DeleteAlertRulesRequest, runtime *util.RuntimeOptions) (_result *DeleteAlertRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertIds)) {
		query["AlertIds"] = request.AlertIds
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAlertRules"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAlertRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteAlertRules(request *DeleteAlertRulesRequest) (_result *DeleteAlertRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAlertRulesResponse{}
	_body, _err := client.DeleteAlertRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteAppListWithOptions(request *DeleteAppListRequest, runtime *util.RuntimeOptions) (_result *DeleteAppListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Pids)) {
		query["Pids"] = request.Pids
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAppList"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAppListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteAppList(request *DeleteAppListRequest) (_result *DeleteAppListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAppListResponse{}
	_body, _err := client.DeleteAppListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteCmsExporterWithOptions(request *DeleteCmsExporterRequest, runtime *util.RuntimeOptions) (_result *DeleteCmsExporterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCmsExporter"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCmsExporterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteCmsExporter(request *DeleteCmsExporterRequest) (_result *DeleteCmsExporterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCmsExporterResponse{}
	_body, _err := client.DeleteCmsExporterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteContactWithOptions(request *DeleteContactRequest, runtime *util.RuntimeOptions) (_result *DeleteContactResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ContactId)) {
		query["ContactId"] = request.ContactId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteContact"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteContactResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteContact(request *DeleteContactRequest) (_result *DeleteContactResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteContactResponse{}
	_body, _err := client.DeleteContactWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteContactGroupWithOptions(request *DeleteContactGroupRequest, runtime *util.RuntimeOptions) (_result *DeleteContactGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ContactGroupId)) {
		query["ContactGroupId"] = request.ContactGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteContactGroup"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteContactGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteContactGroup(request *DeleteContactGroupRequest) (_result *DeleteContactGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteContactGroupResponse{}
	_body, _err := client.DeleteContactGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDispatchRuleWithOptions(request *DeleteDispatchRuleRequest, runtime *util.RuntimeOptions) (_result *DeleteDispatchRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDispatchRule"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDispatchRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDispatchRule(request *DeleteDispatchRuleRequest) (_result *DeleteDispatchRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDispatchRuleResponse{}
	_body, _err := client.DeleteDispatchRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteEnvCustomJobWithOptions(request *DeleteEnvCustomJobRequest, runtime *util.RuntimeOptions) (_result *DeleteEnvCustomJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CustomJobName)) {
		query["CustomJobName"] = request.CustomJobName
	}

	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteEnvCustomJob"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteEnvCustomJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteEnvCustomJob(request *DeleteEnvCustomJobRequest) (_result *DeleteEnvCustomJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteEnvCustomJobResponse{}
	_body, _err := client.DeleteEnvCustomJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteEnvPodMonitorWithOptions(request *DeleteEnvPodMonitorRequest, runtime *util.RuntimeOptions) (_result *DeleteEnvPodMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.PodMonitorName)) {
		query["PodMonitorName"] = request.PodMonitorName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteEnvPodMonitor"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteEnvPodMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteEnvPodMonitor(request *DeleteEnvPodMonitorRequest) (_result *DeleteEnvPodMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteEnvPodMonitorResponse{}
	_body, _err := client.DeleteEnvPodMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteEnvServiceMonitorWithOptions(request *DeleteEnvServiceMonitorRequest, runtime *util.RuntimeOptions) (_result *DeleteEnvServiceMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceMonitorName)) {
		query["ServiceMonitorName"] = request.ServiceMonitorName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteEnvServiceMonitor"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteEnvServiceMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteEnvServiceMonitor(request *DeleteEnvServiceMonitorRequest) (_result *DeleteEnvServiceMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteEnvServiceMonitorResponse{}
	_body, _err := client.DeleteEnvServiceMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteEnvironmentWithOptions(request *DeleteEnvironmentRequest, runtime *util.RuntimeOptions) (_result *DeleteEnvironmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeletePromInstance)) {
		query["DeletePromInstance"] = request.DeletePromInstance
	}

	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteEnvironment"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteEnvironmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteEnvironment(request *DeleteEnvironmentRequest) (_result *DeleteEnvironmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteEnvironmentResponse{}
	_body, _err := client.DeleteEnvironmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteEnvironmentFeatureWithOptions(request *DeleteEnvironmentFeatureRequest, runtime *util.RuntimeOptions) (_result *DeleteEnvironmentFeatureResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.FeatureName)) {
		query["FeatureName"] = request.FeatureName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteEnvironmentFeature"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteEnvironmentFeatureResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteEnvironmentFeature(request *DeleteEnvironmentFeatureRequest) (_result *DeleteEnvironmentFeatureResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteEnvironmentFeatureResponse{}
	_body, _err := client.DeleteEnvironmentFeatureWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteEventBridgeIntegrationWithOptions(request *DeleteEventBridgeIntegrationRequest, runtime *util.RuntimeOptions) (_result *DeleteEventBridgeIntegrationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Id)) {
		body["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteEventBridgeIntegration"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteEventBridgeIntegrationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteEventBridgeIntegration(request *DeleteEventBridgeIntegrationRequest) (_result *DeleteEventBridgeIntegrationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteEventBridgeIntegrationResponse{}
	_body, _err := client.DeleteEventBridgeIntegrationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteGrafanaResourceWithOptions(request *DeleteGrafanaResourceRequest, runtime *util.RuntimeOptions) (_result *DeleteGrafanaResourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		body["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterName)) {
		body["ClusterName"] = request.ClusterName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteGrafanaResource"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteGrafanaResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteGrafanaResource(request *DeleteGrafanaResourceRequest) (_result *DeleteGrafanaResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteGrafanaResourceResponse{}
	_body, _err := client.DeleteGrafanaResourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteGrafanaWorkspaceWithOptions(request *DeleteGrafanaWorkspaceRequest, runtime *util.RuntimeOptions) (_result *DeleteGrafanaWorkspaceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GrafanaWorkspaceId)) {
		query["GrafanaWorkspaceId"] = request.GrafanaWorkspaceId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteGrafanaWorkspace"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteGrafanaWorkspaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteGrafanaWorkspace(request *DeleteGrafanaWorkspaceRequest) (_result *DeleteGrafanaWorkspaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteGrafanaWorkspaceResponse{}
	_body, _err := client.DeleteGrafanaWorkspaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteIMRobotWithOptions(request *DeleteIMRobotRequest, runtime *util.RuntimeOptions) (_result *DeleteIMRobotResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RobotId)) {
		query["RobotId"] = request.RobotId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteIMRobot"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteIMRobotResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteIMRobot(request *DeleteIMRobotRequest) (_result *DeleteIMRobotResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteIMRobotResponse{}
	_body, _err := client.DeleteIMRobotWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteIntegrationWithOptions(request *DeleteIntegrationRequest, runtime *util.RuntimeOptions) (_result *DeleteIntegrationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Integration)) {
		query["Integration"] = request.Integration
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteIntegration"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteIntegrationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteIntegration(request *DeleteIntegrationRequest) (_result *DeleteIntegrationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteIntegrationResponse{}
	_body, _err := client.DeleteIntegrationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteIntegrationsWithOptions(request *DeleteIntegrationsRequest, runtime *util.RuntimeOptions) (_result *DeleteIntegrationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteIntegrations"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteIntegrationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteIntegrations(request *DeleteIntegrationsRequest) (_result *DeleteIntegrationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteIntegrationsResponse{}
	_body, _err := client.DeleteIntegrationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteNotificationPolicyWithOptions(request *DeleteNotificationPolicyRequest, runtime *util.RuntimeOptions) (_result *DeleteNotificationPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteNotificationPolicy"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteNotificationPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteNotificationPolicy(request *DeleteNotificationPolicyRequest) (_result *DeleteNotificationPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteNotificationPolicyResponse{}
	_body, _err := client.DeleteNotificationPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeletePrometheusAlertRuleWithOptions(request *DeletePrometheusAlertRuleRequest, runtime *util.RuntimeOptions) (_result *DeletePrometheusAlertRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertId)) {
		query["AlertId"] = request.AlertId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeletePrometheusAlertRule"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeletePrometheusAlertRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeletePrometheusAlertRule(request *DeletePrometheusAlertRuleRequest) (_result *DeletePrometheusAlertRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeletePrometheusAlertRuleResponse{}
	_body, _err := client.DeletePrometheusAlertRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeletePrometheusGlobalViewWithOptions(request *DeletePrometheusGlobalViewRequest, runtime *util.RuntimeOptions) (_result *DeletePrometheusGlobalViewResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GlobalViewClusterId)) {
		query["GlobalViewClusterId"] = request.GlobalViewClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeletePrometheusGlobalView"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeletePrometheusGlobalViewResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeletePrometheusGlobalView(request *DeletePrometheusGlobalViewRequest) (_result *DeletePrometheusGlobalViewResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeletePrometheusGlobalViewResponse{}
	_body, _err := client.DeletePrometheusGlobalViewWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeletePrometheusIntegrationWithOptions(request *DeletePrometheusIntegrationRequest, runtime *util.RuntimeOptions) (_result *DeletePrometheusIntegrationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IntegrationType)) {
		query["IntegrationType"] = request.IntegrationType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeletePrometheusIntegration"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeletePrometheusIntegrationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeletePrometheusIntegration(request *DeletePrometheusIntegrationRequest) (_result *DeletePrometheusIntegrationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeletePrometheusIntegrationResponse{}
	_body, _err := client.DeletePrometheusIntegrationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeletePrometheusMonitoringWithOptions(request *DeletePrometheusMonitoringRequest, runtime *util.RuntimeOptions) (_result *DeletePrometheusMonitoringResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.MonitoringName)) {
		query["MonitoringName"] = request.MonitoringName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeletePrometheusMonitoring"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeletePrometheusMonitoringResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeletePrometheusMonitoring(request *DeletePrometheusMonitoringRequest) (_result *DeletePrometheusMonitoringResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeletePrometheusMonitoringResponse{}
	_body, _err := client.DeletePrometheusMonitoringWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeletePrometheusRemoteWriteWithOptions(request *DeletePrometheusRemoteWriteRequest, runtime *util.RuntimeOptions) (_result *DeletePrometheusRemoteWriteResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RemoteWriteNames)) {
		query["RemoteWriteNames"] = request.RemoteWriteNames
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeletePrometheusRemoteWrite"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeletePrometheusRemoteWriteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeletePrometheusRemoteWrite(request *DeletePrometheusRemoteWriteRequest) (_result *DeletePrometheusRemoteWriteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeletePrometheusRemoteWriteResponse{}
	_body, _err := client.DeletePrometheusRemoteWriteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteRetcodeAppWithOptions(request *DeleteRetcodeAppRequest, runtime *util.RuntimeOptions) (_result *DeleteRetcodeAppResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Pid)) {
		query["Pid"] = request.Pid
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteRetcodeApp"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteRetcodeAppResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteRetcodeApp(request *DeleteRetcodeAppRequest) (_result *DeleteRetcodeAppResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteRetcodeAppResponse{}
	_body, _err := client.DeleteRetcodeAppWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteScenarioWithOptions(request *DeleteScenarioRequest, runtime *util.RuntimeOptions) (_result *DeleteScenarioResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ScenarioId)) {
		query["ScenarioId"] = request.ScenarioId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteScenario"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteScenarioResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteScenario(request *DeleteScenarioRequest) (_result *DeleteScenarioResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteScenarioResponse{}
	_body, _err := client.DeleteScenarioWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteSilencePolicyWithOptions(request *DeleteSilencePolicyRequest, runtime *util.RuntimeOptions) (_result *DeleteSilencePolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSilencePolicy"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSilencePolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteSilencePolicy(request *DeleteSilencePolicyRequest) (_result *DeleteSilencePolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSilencePolicyResponse{}
	_body, _err := client.DeleteSilencePolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteSourceMapWithOptions(tmpReq *DeleteSourceMapRequest, runtime *util.RuntimeOptions) (_result *DeleteSourceMapResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &DeleteSourceMapShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.FidList)) {
		request.FidListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.FidList, tea.String("FidList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FidListShrink)) {
		query["FidList"] = request.FidListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Pid)) {
		query["Pid"] = request.Pid
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSourceMap"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSourceMapResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteSourceMap(request *DeleteSourceMapRequest) (_result *DeleteSourceMapResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSourceMapResponse{}
	_body, _err := client.DeleteSourceMapWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteSyntheticTaskWithOptions(request *DeleteSyntheticTaskRequest, runtime *util.RuntimeOptions) (_result *DeleteSyntheticTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskIds)) {
		query["TaskIds"] = request.TaskIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSyntheticTask"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSyntheticTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteSyntheticTask(request *DeleteSyntheticTaskRequest) (_result *DeleteSyntheticTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSyntheticTaskResponse{}
	_body, _err := client.DeleteSyntheticTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteTimingSyntheticTaskWithOptions(request *DeleteTimingSyntheticTaskRequest, runtime *util.RuntimeOptions) (_result *DeleteTimingSyntheticTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTimingSyntheticTask"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTimingSyntheticTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteTimingSyntheticTask(request *DeleteTimingSyntheticTaskRequest) (_result *DeleteTimingSyntheticTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTimingSyntheticTaskResponse{}
	_body, _err := client.DeleteTimingSyntheticTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteTraceAppWithOptions(tmpReq *DeleteTraceAppRequest, runtime *util.RuntimeOptions) (_result *DeleteTraceAppResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &DeleteTraceAppShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.DeleteReason)) {
		request.DeleteReasonShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.DeleteReason, tea.String("DeleteReason"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.DeleteReasonShrink)) {
		query["DeleteReason"] = request.DeleteReasonShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Pid)) {
		query["Pid"] = request.Pid
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTraceApp"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTraceAppResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteTraceApp(request *DeleteTraceAppRequest) (_result *DeleteTraceAppResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTraceAppResponse{}
	_body, _err := client.DeleteTraceAppWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteWebhookContactWithOptions(request *DeleteWebhookContactRequest, runtime *util.RuntimeOptions) (_result *DeleteWebhookContactResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.WebhookId)) {
		query["WebhookId"] = request.WebhookId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteWebhookContact"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteWebhookContactResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteWebhookContact(request *DeleteWebhookContactRequest) (_result *DeleteWebhookContactResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteWebhookContactResponse{}
	_body, _err := client.DeleteWebhookContactWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeAddonReleaseWithOptions(request *DescribeAddonReleaseRequest, runtime *util.RuntimeOptions) (_result *DescribeAddonReleaseResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ReleaseName)) {
		query["ReleaseName"] = request.ReleaseName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAddonRelease"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAddonReleaseResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeAddonRelease(request *DescribeAddonReleaseRequest) (_result *DescribeAddonReleaseResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAddonReleaseResponse{}
	_body, _err := client.DescribeAddonReleaseWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeContactGroupsWithOptions(request *DescribeContactGroupsRequest, runtime *util.RuntimeOptions) (_result *DescribeContactGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ContactGroupName)) {
		query["ContactGroupName"] = request.ContactGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.GroupIds)) {
		query["GroupIds"] = request.GroupIds
	}

	if !tea.BoolValue(util.IsUnset(request.IsDetail)) {
		query["IsDetail"] = request.IsDetail
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["Page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["Size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeContactGroups"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeContactGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeContactGroups(request *DescribeContactGroupsRequest) (_result *DescribeContactGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeContactGroupsResponse{}
	_body, _err := client.DescribeContactGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeContactsWithOptions(request *DescribeContactsRequest, runtime *util.RuntimeOptions) (_result *DescribeContactsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ContactIds)) {
		query["ContactIds"] = request.ContactIds
	}

	if !tea.BoolValue(util.IsUnset(request.ContactName)) {
		query["ContactName"] = request.ContactName
	}

	if !tea.BoolValue(util.IsUnset(request.Email)) {
		query["Email"] = request.Email
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["Page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.Phone)) {
		query["Phone"] = request.Phone
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["Size"] = request.Size
	}

	if !tea.BoolValue(util.IsUnset(request.Verbose)) {
		query["Verbose"] = request.Verbose
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeContacts"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeContactsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeContacts(request *DescribeContactsRequest) (_result *DescribeContactsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeContactsResponse{}
	_body, _err := client.DescribeContactsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDispatchRuleWithOptions(request *DescribeDispatchRuleRequest, runtime *util.RuntimeOptions) (_result *DescribeDispatchRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDispatchRule"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDispatchRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDispatchRule(request *DescribeDispatchRuleRequest) (_result *DescribeDispatchRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDispatchRuleResponse{}
	_body, _err := client.DescribeDispatchRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeEnvCustomJobWithOptions(request *DescribeEnvCustomJobRequest, runtime *util.RuntimeOptions) (_result *DescribeEnvCustomJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CustomJobName)) {
		query["CustomJobName"] = request.CustomJobName
	}

	if !tea.BoolValue(util.IsUnset(request.EncryptYaml)) {
		query["EncryptYaml"] = request.EncryptYaml
	}

	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeEnvCustomJob"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeEnvCustomJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeEnvCustomJob(request *DescribeEnvCustomJobRequest) (_result *DescribeEnvCustomJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeEnvCustomJobResponse{}
	_body, _err := client.DescribeEnvCustomJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeEnvPodMonitorWithOptions(request *DescribeEnvPodMonitorRequest, runtime *util.RuntimeOptions) (_result *DescribeEnvPodMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.PodMonitorName)) {
		query["PodMonitorName"] = request.PodMonitorName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeEnvPodMonitor"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeEnvPodMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeEnvPodMonitor(request *DescribeEnvPodMonitorRequest) (_result *DescribeEnvPodMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeEnvPodMonitorResponse{}
	_body, _err := client.DescribeEnvPodMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeEnvServiceMonitorWithOptions(request *DescribeEnvServiceMonitorRequest, runtime *util.RuntimeOptions) (_result *DescribeEnvServiceMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceMonitorName)) {
		query["ServiceMonitorName"] = request.ServiceMonitorName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeEnvServiceMonitor"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeEnvServiceMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeEnvServiceMonitor(request *DescribeEnvServiceMonitorRequest) (_result *DescribeEnvServiceMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeEnvServiceMonitorResponse{}
	_body, _err := client.DescribeEnvServiceMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeEnvironmentWithOptions(request *DescribeEnvironmentRequest, runtime *util.RuntimeOptions) (_result *DescribeEnvironmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeEnvironment"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeEnvironmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeEnvironment(request *DescribeEnvironmentRequest) (_result *DescribeEnvironmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeEnvironmentResponse{}
	_body, _err := client.DescribeEnvironmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeEnvironmentFeatureWithOptions(request *DescribeEnvironmentFeatureRequest, runtime *util.RuntimeOptions) (_result *DescribeEnvironmentFeatureResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.FeatureName)) {
		query["FeatureName"] = request.FeatureName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeEnvironmentFeature"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeEnvironmentFeatureResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeEnvironmentFeature(request *DescribeEnvironmentFeatureRequest) (_result *DescribeEnvironmentFeatureResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeEnvironmentFeatureResponse{}
	_body, _err := client.DescribeEnvironmentFeatureWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeIMRobotsWithOptions(request *DescribeIMRobotsRequest, runtime *util.RuntimeOptions) (_result *DescribeIMRobotsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["Page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.RobotIds)) {
		query["RobotIds"] = request.RobotIds
	}

	if !tea.BoolValue(util.IsUnset(request.RobotName)) {
		query["RobotName"] = request.RobotName
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["Size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeIMRobots"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeIMRobotsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeIMRobots(request *DescribeIMRobotsRequest) (_result *DescribeIMRobotsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeIMRobotsResponse{}
	_body, _err := client.DescribeIMRobotsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePrometheusAlertRuleWithOptions(request *DescribePrometheusAlertRuleRequest, runtime *util.RuntimeOptions) (_result *DescribePrometheusAlertRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertId)) {
		query["AlertId"] = request.AlertId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePrometheusAlertRule"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePrometheusAlertRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePrometheusAlertRule(request *DescribePrometheusAlertRuleRequest) (_result *DescribePrometheusAlertRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePrometheusAlertRuleResponse{}
	_body, _err := client.DescribePrometheusAlertRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeTraceLicenseKeyWithOptions(request *DescribeTraceLicenseKeyRequest, runtime *util.RuntimeOptions) (_result *DescribeTraceLicenseKeyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeTraceLicenseKey"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeTraceLicenseKeyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeTraceLicenseKey(request *DescribeTraceLicenseKeyRequest) (_result *DescribeTraceLicenseKeyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeTraceLicenseKeyResponse{}
	_body, _err := client.DescribeTraceLicenseKeyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeWebhookContactsWithOptions(request *DescribeWebhookContactsRequest, runtime *util.RuntimeOptions) (_result *DescribeWebhookContactsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeWebhookContacts"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeWebhookContactsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeWebhookContacts(request *DescribeWebhookContactsRequest) (_result *DescribeWebhookContactsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeWebhookContactsResponse{}
	_body, _err := client.DescribeWebhookContactsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EnableMetricWithOptions(request *EnableMetricRequest, runtime *util.RuntimeOptions) (_result *EnableMetricResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.DropMetric)) {
		query["DropMetric"] = request.DropMetric
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableMetric"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableMetricResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EnableMetric(request *EnableMetricRequest) (_result *EnableMetricResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnableMetricResponse{}
	_body, _err := client.EnableMetricWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetAgentDownloadUrlWithOptions(request *GetAgentDownloadUrlRequest, runtime *util.RuntimeOptions) (_result *GetAgentDownloadUrlResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAgentDownloadUrl"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAgentDownloadUrlResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetAgentDownloadUrl(request *GetAgentDownloadUrlRequest) (_result *GetAgentDownloadUrlResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAgentDownloadUrlResponse{}
	_body, _err := client.GetAgentDownloadUrlWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetAlertRulesWithOptions(request *GetAlertRulesRequest, runtime *util.RuntimeOptions) (_result *GetAlertRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertIds)) {
		query["AlertIds"] = request.AlertIds
	}

	if !tea.BoolValue(util.IsUnset(request.AlertNames)) {
		query["AlertNames"] = request.AlertNames
	}

	if !tea.BoolValue(util.IsUnset(request.AlertStatus)) {
		query["AlertStatus"] = request.AlertStatus
	}

	if !tea.BoolValue(util.IsUnset(request.AlertType)) {
		query["AlertType"] = request.AlertType
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["Page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.ProductCode)) {
		query["ProductCode"] = request.ProductCode
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["Size"] = request.Size
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAlertRules"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAlertRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetAlertRules(request *GetAlertRulesRequest) (_result *GetAlertRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAlertRulesResponse{}
	_body, _err := client.GetAlertRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetAppApiByPageWithOptions(request *GetAppApiByPageRequest, runtime *util.RuntimeOptions) (_result *GetAppApiByPageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.IntervalMills)) {
		query["IntervalMills"] = request.IntervalMills
	}

	if !tea.BoolValue(util.IsUnset(request.PId)) {
		query["PId"] = request.PId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAppApiByPage"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAppApiByPageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetAppApiByPage(request *GetAppApiByPageRequest) (_result *GetAppApiByPageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAppApiByPageResponse{}
	_body, _err := client.GetAppApiByPageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetAppJVMConfigWithOptions(request *GetAppJVMConfigRequest, runtime *util.RuntimeOptions) (_result *GetAppJVMConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAppJVMConfig"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAppJVMConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetAppJVMConfig(request *GetAppJVMConfigRequest) (_result *GetAppJVMConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAppJVMConfigResponse{}
	_body, _err := client.GetAppJVMConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetAuthTokenWithOptions(request *GetAuthTokenRequest, runtime *util.RuntimeOptions) (_result *GetAuthTokenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAuthToken"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAuthTokenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetAuthToken(request *GetAuthTokenRequest) (_result *GetAuthTokenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAuthTokenResponse{}
	_body, _err := client.GetAuthTokenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetCloudClusterAllUrlWithOptions(request *GetCloudClusterAllUrlRequest, runtime *util.RuntimeOptions) (_result *GetCloudClusterAllUrlResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetCloudClusterAllUrl"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetCloudClusterAllUrlResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetCloudClusterAllUrl(request *GetCloudClusterAllUrlRequest) (_result *GetCloudClusterAllUrlResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetCloudClusterAllUrlResponse{}
	_body, _err := client.GetCloudClusterAllUrlWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetClusterAllUrlWithOptions(request *GetClusterAllUrlRequest, runtime *util.RuntimeOptions) (_result *GetClusterAllUrlResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetClusterAllUrl"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetClusterAllUrlResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetClusterAllUrl(request *GetClusterAllUrlRequest) (_result *GetClusterAllUrlResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetClusterAllUrlResponse{}
	_body, _err := client.GetClusterAllUrlWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetCommercialStatusWithOptions(request *GetCommercialStatusRequest, runtime *util.RuntimeOptions) (_result *GetCommercialStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CommodityCode)) {
		query["CommodityCode"] = request.CommodityCode
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetCommercialStatus"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetCommercialStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetCommercialStatus(request *GetCommercialStatusRequest) (_result *GetCommercialStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetCommercialStatusResponse{}
	_body, _err := client.GetCommercialStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetExploreUrlWithOptions(request *GetExploreUrlRequest, runtime *util.RuntimeOptions) (_result *GetExploreUrlResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Expression)) {
		query["Expression"] = request.Expression
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetExploreUrl"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetExploreUrlResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetExploreUrl(request *GetExploreUrlRequest) (_result *GetExploreUrlResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetExploreUrlResponse{}
	_body, _err := client.GetExploreUrlWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetGrafanaWorkspaceWithOptions(request *GetGrafanaWorkspaceRequest, runtime *util.RuntimeOptions) (_result *GetGrafanaWorkspaceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliyunLang)) {
		query["AliyunLang"] = request.AliyunLang
	}

	if !tea.BoolValue(util.IsUnset(request.GrafanaWorkspaceId)) {
		query["GrafanaWorkspaceId"] = request.GrafanaWorkspaceId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetGrafanaWorkspace"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetGrafanaWorkspaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetGrafanaWorkspace(request *GetGrafanaWorkspaceRequest) (_result *GetGrafanaWorkspaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetGrafanaWorkspaceResponse{}
	_body, _err := client.GetGrafanaWorkspaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetIntegrationStateWithOptions(request *GetIntegrationStateRequest, runtime *util.RuntimeOptions) (_result *GetIntegrationStateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Integration)) {
		query["Integration"] = request.Integration
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetIntegrationState"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetIntegrationStateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetIntegrationState(request *GetIntegrationStateRequest) (_result *GetIntegrationStateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetIntegrationStateResponse{}
	_body, _err := client.GetIntegrationStateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetManagedPrometheusStatusWithOptions(request *GetManagedPrometheusStatusRequest, runtime *util.RuntimeOptions) (_result *GetManagedPrometheusStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterType)) {
		query["ClusterType"] = request.ClusterType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetManagedPrometheusStatus"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetManagedPrometheusStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetManagedPrometheusStatus(request *GetManagedPrometheusStatusRequest) (_result *GetManagedPrometheusStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetManagedPrometheusStatusResponse{}
	_body, _err := client.GetManagedPrometheusStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetMultipleTraceWithOptions(request *GetMultipleTraceRequest, runtime *util.RuntimeOptions) (_result *GetMultipleTraceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.TraceIDs)) {
		query["TraceIDs"] = request.TraceIDs
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMultipleTrace"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMultipleTraceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetMultipleTrace(request *GetMultipleTraceRequest) (_result *GetMultipleTraceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMultipleTraceResponse{}
	_body, _err := client.GetMultipleTraceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetOnCallSchedulesDetailWithOptions(request *GetOnCallSchedulesDetailRequest, runtime *util.RuntimeOptions) (_result *GetOnCallSchedulesDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetOnCallSchedulesDetail"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetOnCallSchedulesDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetOnCallSchedulesDetail(request *GetOnCallSchedulesDetailRequest) (_result *GetOnCallSchedulesDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetOnCallSchedulesDetailResponse{}
	_body, _err := client.GetOnCallSchedulesDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * None.
 *
 * @param request GetPrometheusApiTokenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPrometheusApiTokenResponse
 */
func (client *Client) GetPrometheusApiTokenWithOptions(request *GetPrometheusApiTokenRequest, runtime *util.RuntimeOptions) (_result *GetPrometheusApiTokenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetPrometheusApiToken"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetPrometheusApiTokenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * None.
 *
 * @param request GetPrometheusApiTokenRequest
 * @return GetPrometheusApiTokenResponse
 */
func (client *Client) GetPrometheusApiToken(request *GetPrometheusApiTokenRequest) (_result *GetPrometheusApiTokenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetPrometheusApiTokenResponse{}
	_body, _err := client.GetPrometheusApiTokenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetPrometheusGlobalViewWithOptions(request *GetPrometheusGlobalViewRequest, runtime *util.RuntimeOptions) (_result *GetPrometheusGlobalViewResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GlobalViewClusterId)) {
		query["GlobalViewClusterId"] = request.GlobalViewClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetPrometheusGlobalView"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetPrometheusGlobalViewResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetPrometheusGlobalView(request *GetPrometheusGlobalViewRequest) (_result *GetPrometheusGlobalViewResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetPrometheusGlobalViewResponse{}
	_body, _err := client.GetPrometheusGlobalViewWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetPrometheusInstanceWithOptions(request *GetPrometheusInstanceRequest, runtime *util.RuntimeOptions) (_result *GetPrometheusInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetPrometheusInstance"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetPrometheusInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetPrometheusInstance(request *GetPrometheusInstanceRequest) (_result *GetPrometheusInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetPrometheusInstanceResponse{}
	_body, _err := client.GetPrometheusInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetPrometheusIntegrationWithOptions(request *GetPrometheusIntegrationRequest, runtime *util.RuntimeOptions) (_result *GetPrometheusIntegrationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IntegrationType)) {
		query["IntegrationType"] = request.IntegrationType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetPrometheusIntegration"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetPrometheusIntegrationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetPrometheusIntegration(request *GetPrometheusIntegrationRequest) (_result *GetPrometheusIntegrationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetPrometheusIntegrationResponse{}
	_body, _err := client.GetPrometheusIntegrationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetPrometheusMonitoringWithOptions(request *GetPrometheusMonitoringRequest, runtime *util.RuntimeOptions) (_result *GetPrometheusMonitoringResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.MonitoringName)) {
		query["MonitoringName"] = request.MonitoringName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetPrometheusMonitoring"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetPrometheusMonitoringResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetPrometheusMonitoring(request *GetPrometheusMonitoringRequest) (_result *GetPrometheusMonitoringResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetPrometheusMonitoringResponse{}
	_body, _err := client.GetPrometheusMonitoringWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetPrometheusRemoteWriteWithOptions(request *GetPrometheusRemoteWriteRequest, runtime *util.RuntimeOptions) (_result *GetPrometheusRemoteWriteResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RemoteWriteName)) {
		query["RemoteWriteName"] = request.RemoteWriteName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetPrometheusRemoteWrite"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetPrometheusRemoteWriteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetPrometheusRemoteWrite(request *GetPrometheusRemoteWriteRequest) (_result *GetPrometheusRemoteWriteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetPrometheusRemoteWriteResponse{}
	_body, _err := client.GetPrometheusRemoteWriteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetRecordingRuleWithOptions(request *GetRecordingRuleRequest, runtime *util.RuntimeOptions) (_result *GetRecordingRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetRecordingRule"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetRecordingRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetRecordingRule(request *GetRecordingRuleRequest) (_result *GetRecordingRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetRecordingRuleResponse{}
	_body, _err := client.GetRecordingRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetRetcodeAppByPidWithOptions(request *GetRetcodeAppByPidRequest, runtime *util.RuntimeOptions) (_result *GetRetcodeAppByPidResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetRetcodeAppByPid"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetRetcodeAppByPidResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetRetcodeAppByPid(request *GetRetcodeAppByPidRequest) (_result *GetRetcodeAppByPidResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetRetcodeAppByPidResponse{}
	_body, _err := client.GetRetcodeAppByPidWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetRetcodeDataByQueryWithOptions(request *GetRetcodeDataByQueryRequest, runtime *util.RuntimeOptions) (_result *GetRetcodeDataByQueryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.From)) {
		query["From"] = request.From
	}

	if !tea.BoolValue(util.IsUnset(request.Pid)) {
		query["Pid"] = request.Pid
	}

	if !tea.BoolValue(util.IsUnset(request.Query)) {
		query["Query"] = request.Query
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.To)) {
		query["To"] = request.To
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetRetcodeDataByQuery"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetRetcodeDataByQueryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetRetcodeDataByQuery(request *GetRetcodeDataByQueryRequest) (_result *GetRetcodeDataByQueryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetRetcodeDataByQueryResponse{}
	_body, _err := client.GetRetcodeDataByQueryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetRetcodeLogstoreWithOptions(request *GetRetcodeLogstoreRequest, runtime *util.RuntimeOptions) (_result *GetRetcodeLogstoreResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Pid)) {
		query["Pid"] = request.Pid
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetRetcodeLogstore"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetRetcodeLogstoreResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetRetcodeLogstore(request *GetRetcodeLogstoreRequest) (_result *GetRetcodeLogstoreResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetRetcodeLogstoreResponse{}
	_body, _err := client.GetRetcodeLogstoreWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetRetcodeShareUrlWithOptions(request *GetRetcodeShareUrlRequest, runtime *util.RuntimeOptions) (_result *GetRetcodeShareUrlResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Pid)) {
		query["Pid"] = request.Pid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetRetcodeShareUrl"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetRetcodeShareUrlResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetRetcodeShareUrl(request *GetRetcodeShareUrlRequest) (_result *GetRetcodeShareUrlResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetRetcodeShareUrlResponse{}
	_body, _err := client.GetRetcodeShareUrlWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetSourceMapInfoWithOptions(request *GetSourceMapInfoRequest, runtime *util.RuntimeOptions) (_result *GetSourceMapInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AscendingSequence)) {
		query["AscendingSequence"] = request.AscendingSequence
	}

	if !tea.BoolValue(util.IsUnset(request.Edition)) {
		query["Edition"] = request.Edition
	}

	if !tea.BoolValue(util.IsUnset(request.ID)) {
		query["ID"] = request.ID
	}

	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.OrderField)) {
		query["OrderField"] = request.OrderField
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetSourceMapInfo"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetSourceMapInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetSourceMapInfo(request *GetSourceMapInfoRequest) (_result *GetSourceMapInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetSourceMapInfoResponse{}
	_body, _err := client.GetSourceMapInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetStackWithOptions(request *GetStackRequest, runtime *util.RuntimeOptions) (_result *GetStackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Pid)) {
		query["Pid"] = request.Pid
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RpcID)) {
		query["RpcID"] = request.RpcID
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.TraceID)) {
		query["TraceID"] = request.TraceID
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetStack"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetStackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetStack(request *GetStackRequest) (_result *GetStackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetStackResponse{}
	_body, _err := client.GetStackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetSyntheticMonitorsWithOptions(tmpReq *GetSyntheticMonitorsRequest, runtime *util.RuntimeOptions) (_result *GetSyntheticMonitorsResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &GetSyntheticMonitorsShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Filter)) {
		request.FilterShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Filter, tea.String("Filter"), tea.String("json"))
	}

	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetSyntheticMonitors"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetSyntheticMonitorsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetSyntheticMonitors(request *GetSyntheticMonitorsRequest) (_result *GetSyntheticMonitorsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetSyntheticMonitorsResponse{}
	_body, _err := client.GetSyntheticMonitorsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetSyntheticTaskDetailWithOptions(request *GetSyntheticTaskDetailRequest, runtime *util.RuntimeOptions) (_result *GetSyntheticTaskDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetSyntheticTaskDetail"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetSyntheticTaskDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetSyntheticTaskDetail(request *GetSyntheticTaskDetailRequest) (_result *GetSyntheticTaskDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetSyntheticTaskDetailResponse{}
	_body, _err := client.GetSyntheticTaskDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetSyntheticTaskListWithOptions(request *GetSyntheticTaskListRequest, runtime *util.RuntimeOptions) (_result *GetSyntheticTaskListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Direction)) {
		query["Direction"] = request.Direction
	}

	if !tea.BoolValue(util.IsUnset(request.Order)) {
		query["Order"] = request.Order
	}

	if !tea.BoolValue(util.IsUnset(request.PageNum)) {
		query["PageNum"] = request.PageNum
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskName)) {
		query["TaskName"] = request.TaskName
	}

	if !tea.BoolValue(util.IsUnset(request.TaskStatus)) {
		query["TaskStatus"] = request.TaskStatus
	}

	if !tea.BoolValue(util.IsUnset(request.TaskType)) {
		query["TaskType"] = request.TaskType
	}

	if !tea.BoolValue(util.IsUnset(request.Url)) {
		query["Url"] = request.Url
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetSyntheticTaskList"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetSyntheticTaskListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetSyntheticTaskList(request *GetSyntheticTaskListRequest) (_result *GetSyntheticTaskListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetSyntheticTaskListResponse{}
	_body, _err := client.GetSyntheticTaskListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetSyntheticTaskMonitorsWithOptions(request *GetSyntheticTaskMonitorsRequest, runtime *util.RuntimeOptions) (_result *GetSyntheticTaskMonitorsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetSyntheticTaskMonitors"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetSyntheticTaskMonitorsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetSyntheticTaskMonitors(request *GetSyntheticTaskMonitorsRequest) (_result *GetSyntheticTaskMonitorsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetSyntheticTaskMonitorsResponse{}
	_body, _err := client.GetSyntheticTaskMonitorsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetTimingSyntheticTaskWithOptions(request *GetTimingSyntheticTaskRequest, runtime *util.RuntimeOptions) (_result *GetTimingSyntheticTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetTimingSyntheticTask"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetTimingSyntheticTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetTimingSyntheticTask(request *GetTimingSyntheticTaskRequest) (_result *GetTimingSyntheticTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetTimingSyntheticTaskResponse{}
	_body, _err := client.GetTimingSyntheticTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You must use Application Real-Time Monitoring Service (ARMS) SDK for Java V2.7.24.
 *
 * @param request GetTraceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTraceResponse
 */
func (client *Client) GetTraceWithOptions(request *GetTraceRequest, runtime *util.RuntimeOptions) (_result *GetTraceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.TraceID)) {
		query["TraceID"] = request.TraceID
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetTrace"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetTraceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You must use Application Real-Time Monitoring Service (ARMS) SDK for Java V2.7.24.
 *
 * @param request GetTraceRequest
 * @return GetTraceResponse
 */
func (client *Client) GetTrace(request *GetTraceRequest) (_result *GetTraceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetTraceResponse{}
	_body, _err := client.GetTraceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetTraceAppWithOptions(request *GetTraceAppRequest, runtime *util.RuntimeOptions) (_result *GetTraceAppResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Pid)) {
		query["Pid"] = request.Pid
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetTraceApp"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetTraceAppResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetTraceApp(request *GetTraceAppRequest) (_result *GetTraceAppResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetTraceAppResponse{}
	_body, _err := client.GetTraceAppWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  You can call the **ImportAppAlertRules** operation to import only the alert rules that are generated by Application Real-Time Monitoring Service (ARMS) for application monitoring and browser monitoring. This operation cannot be used to import custom alert rules, alert rules for Prometheus monitoring, or default emergency alert rules.
 *
 * @param request ImportAppAlertRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImportAppAlertRulesResponse
 */
func (client *Client) ImportAppAlertRulesWithOptions(request *ImportAppAlertRulesRequest, runtime *util.RuntimeOptions) (_result *ImportAppAlertRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ContactGroupIds)) {
		query["ContactGroupIds"] = request.ContactGroupIds
	}

	if !tea.BoolValue(util.IsUnset(request.IsAutoStart)) {
		query["IsAutoStart"] = request.IsAutoStart
	}

	if !tea.BoolValue(util.IsUnset(request.Pids)) {
		query["Pids"] = request.Pids
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.TemplageAlertConfig)) {
		query["TemplageAlertConfig"] = request.TemplageAlertConfig
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateAlertId)) {
		query["TemplateAlertId"] = request.TemplateAlertId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ImportAppAlertRules"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ImportAppAlertRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  You can call the **ImportAppAlertRules** operation to import only the alert rules that are generated by Application Real-Time Monitoring Service (ARMS) for application monitoring and browser monitoring. This operation cannot be used to import custom alert rules, alert rules for Prometheus monitoring, or default emergency alert rules.
 *
 * @param request ImportAppAlertRulesRequest
 * @return ImportAppAlertRulesResponse
 */
func (client *Client) ImportAppAlertRules(request *ImportAppAlertRulesRequest) (_result *ImportAppAlertRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ImportAppAlertRulesResponse{}
	_body, _err := client.ImportAppAlertRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) InitEnvironmentWithOptions(request *InitEnvironmentRequest, runtime *util.RuntimeOptions) (_result *InitEnvironmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliyunLang)) {
		query["AliyunLang"] = request.AliyunLang
	}

	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.ManagedType)) {
		query["ManagedType"] = request.ManagedType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("InitEnvironment"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &InitEnvironmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) InitEnvironment(request *InitEnvironmentRequest) (_result *InitEnvironmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &InitEnvironmentResponse{}
	_body, _err := client.InitEnvironmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) InstallAddonWithOptions(request *InstallAddonRequest, runtime *util.RuntimeOptions) (_result *InstallAddonResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AddonVersion)) {
		query["AddonVersion"] = request.AddonVersion
	}

	if !tea.BoolValue(util.IsUnset(request.AliyunLang)) {
		query["AliyunLang"] = request.AliyunLang
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ReleaseName)) {
		query["ReleaseName"] = request.ReleaseName
	}

	if !tea.BoolValue(util.IsUnset(request.Values)) {
		query["Values"] = request.Values
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("InstallAddon"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &InstallAddonResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) InstallAddon(request *InstallAddonRequest) (_result *InstallAddonResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &InstallAddonResponse{}
	_body, _err := client.InstallAddonWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) InstallCmsExporterWithOptions(request *InstallCmsExporterRequest, runtime *util.RuntimeOptions) (_result *InstallCmsExporterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.CmsArgs)) {
		query["CmsArgs"] = request.CmsArgs
	}

	if !tea.BoolValue(util.IsUnset(request.DirectArgs)) {
		query["DirectArgs"] = request.DirectArgs
	}

	if !tea.BoolValue(util.IsUnset(request.EnableTag)) {
		query["EnableTag"] = request.EnableTag
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("InstallCmsExporter"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &InstallCmsExporterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) InstallCmsExporter(request *InstallCmsExporterRequest) (_result *InstallCmsExporterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &InstallCmsExporterResponse{}
	_body, _err := client.InstallCmsExporterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) InstallEnvironmentFeatureWithOptions(request *InstallEnvironmentFeatureRequest, runtime *util.RuntimeOptions) (_result *InstallEnvironmentFeatureResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliyunLang)) {
		query["AliyunLang"] = request.AliyunLang
	}

	if !tea.BoolValue(util.IsUnset(request.Config)) {
		query["Config"] = request.Config
	}

	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.FeatureName)) {
		query["FeatureName"] = request.FeatureName
	}

	if !tea.BoolValue(util.IsUnset(request.FeatureVersion)) {
		query["FeatureVersion"] = request.FeatureVersion
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("InstallEnvironmentFeature"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &InstallEnvironmentFeatureResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) InstallEnvironmentFeature(request *InstallEnvironmentFeatureRequest) (_result *InstallEnvironmentFeatureResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &InstallEnvironmentFeatureResponse{}
	_body, _err := client.InstallEnvironmentFeatureWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If you call the operation to monitor an ASK cluster or an ECS instance, a Prometheus agent is installed in the ASK cluster or ECS instance. Make sure that the ASK cluster or ECS instance has no Prometheus agent installed in advance.
 *
 * @param request InstallManagedPrometheusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstallManagedPrometheusResponse
 */
func (client *Client) InstallManagedPrometheusWithOptions(request *InstallManagedPrometheusRequest, runtime *util.RuntimeOptions) (_result *InstallManagedPrometheusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterName)) {
		query["ClusterName"] = request.ClusterName
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterType)) {
		query["ClusterType"] = request.ClusterType
	}

	if !tea.BoolValue(util.IsUnset(request.GrafanaInstanceId)) {
		query["GrafanaInstanceId"] = request.GrafanaInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.KubeConfig)) {
		query["KubeConfig"] = request.KubeConfig
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityGroupId)) {
		query["SecurityGroupId"] = request.SecurityGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("InstallManagedPrometheus"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &InstallManagedPrometheusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If you call the operation to monitor an ASK cluster or an ECS instance, a Prometheus agent is installed in the ASK cluster or ECS instance. Make sure that the ASK cluster or ECS instance has no Prometheus agent installed in advance.
 *
 * @param request InstallManagedPrometheusRequest
 * @return InstallManagedPrometheusResponse
 */
func (client *Client) InstallManagedPrometheus(request *InstallManagedPrometheusRequest) (_result *InstallManagedPrometheusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &InstallManagedPrometheusResponse{}
	_body, _err := client.InstallManagedPrometheusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListActivatedAlertsWithOptions(request *ListActivatedAlertsRequest, runtime *util.RuntimeOptions) (_result *ListActivatedAlertsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.Filter)) {
		query["Filter"] = request.Filter
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListActivatedAlerts"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListActivatedAlertsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListActivatedAlerts(request *ListActivatedAlertsRequest) (_result *ListActivatedAlertsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListActivatedAlertsResponse{}
	_body, _err := client.ListActivatedAlertsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListAddonReleasesWithOptions(request *ListAddonReleasesRequest, runtime *util.RuntimeOptions) (_result *ListAddonReleasesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AddonName)) {
		query["AddonName"] = request.AddonName
	}

	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAddonReleases"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAddonReleasesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListAddonReleases(request *ListAddonReleasesRequest) (_result *ListAddonReleasesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAddonReleasesResponse{}
	_body, _err := client.ListAddonReleasesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListAlertEventsWithOptions(request *ListAlertEventsRequest, runtime *util.RuntimeOptions) (_result *ListAlertEventsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertName)) {
		query["AlertName"] = request.AlertName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.MatchingConditions)) {
		query["MatchingConditions"] = request.MatchingConditions
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["Page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["Size"] = request.Size
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAlertEvents"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAlertEventsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListAlertEvents(request *ListAlertEventsRequest) (_result *ListAlertEventsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAlertEventsResponse{}
	_body, _err := client.ListAlertEventsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListAlertsWithOptions(request *ListAlertsRequest, runtime *util.RuntimeOptions) (_result *ListAlertsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertName)) {
		query["AlertName"] = request.AlertName
	}

	if !tea.BoolValue(util.IsUnset(request.DispatchRuleId)) {
		query["DispatchRuleId"] = request.DispatchRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.IntegrationType)) {
		query["IntegrationType"] = request.IntegrationType
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["Page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Severity)) {
		query["Severity"] = request.Severity
	}

	if !tea.BoolValue(util.IsUnset(request.ShowActivities)) {
		query["ShowActivities"] = request.ShowActivities
	}

	if !tea.BoolValue(util.IsUnset(request.ShowEvents)) {
		query["ShowEvents"] = request.ShowEvents
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["Size"] = request.Size
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.State)) {
		query["State"] = request.State
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAlerts"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAlertsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListAlerts(request *ListAlertsRequest) (_result *ListAlertsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAlertsResponse{}
	_body, _err := client.ListAlertsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListClusterFromGrafanaWithOptions(request *ListClusterFromGrafanaRequest, runtime *util.RuntimeOptions) (_result *ListClusterFromGrafanaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListClusterFromGrafana"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListClusterFromGrafanaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListClusterFromGrafana(request *ListClusterFromGrafanaRequest) (_result *ListClusterFromGrafanaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListClusterFromGrafanaResponse{}
	_body, _err := client.ListClusterFromGrafanaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListCmsInstancesWithOptions(request *ListCmsInstancesRequest, runtime *util.RuntimeOptions) (_result *ListCmsInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.TypeFilter)) {
		query["TypeFilter"] = request.TypeFilter
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListCmsInstances"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListCmsInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListCmsInstances(request *ListCmsInstancesRequest) (_result *ListCmsInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListCmsInstancesResponse{}
	_body, _err := client.ListCmsInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * None.
 *
 * @param request ListDashboardsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDashboardsResponse
 */
func (client *Client) ListDashboardsWithOptions(request *ListDashboardsRequest, runtime *util.RuntimeOptions) (_result *ListDashboardsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterType)) {
		query["ClusterType"] = request.ClusterType
	}

	if !tea.BoolValue(util.IsUnset(request.DashboardName)) {
		query["DashboardName"] = request.DashboardName
	}

	if !tea.BoolValue(util.IsUnset(request.Language)) {
		query["Language"] = request.Language
	}

	if !tea.BoolValue(util.IsUnset(request.Product)) {
		query["Product"] = request.Product
	}

	if !tea.BoolValue(util.IsUnset(request.RecreateSwitch)) {
		query["RecreateSwitch"] = request.RecreateSwitch
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Title)) {
		query["Title"] = request.Title
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDashboards"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDashboardsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * None.
 *
 * @param request ListDashboardsRequest
 * @return ListDashboardsResponse
 */
func (client *Client) ListDashboards(request *ListDashboardsRequest) (_result *ListDashboardsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDashboardsResponse{}
	_body, _err := client.ListDashboardsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDashboardsByNameWithOptions(request *ListDashboardsByNameRequest, runtime *util.RuntimeOptions) (_result *ListDashboardsByNameResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterType)) {
		query["ClusterType"] = request.ClusterType
	}

	if !tea.BoolValue(util.IsUnset(request.DashBoardName)) {
		query["DashBoardName"] = request.DashBoardName
	}

	if !tea.BoolValue(util.IsUnset(request.DashBoardVersion)) {
		query["DashBoardVersion"] = request.DashBoardVersion
	}

	if !tea.BoolValue(util.IsUnset(request.DataSourceType)) {
		query["DataSourceType"] = request.DataSourceType
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.OnlyQuery)) {
		query["OnlyQuery"] = request.OnlyQuery
	}

	if !tea.BoolValue(util.IsUnset(request.ProductCode)) {
		query["ProductCode"] = request.ProductCode
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDashboardsByName"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDashboardsByNameResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDashboardsByName(request *ListDashboardsByNameRequest) (_result *ListDashboardsByNameResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDashboardsByNameResponse{}
	_body, _err := client.ListDashboardsByNameWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDispatchRuleWithOptions(request *ListDispatchRuleRequest, runtime *util.RuntimeOptions) (_result *ListDispatchRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.System)) {
		query["System"] = request.System
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDispatchRule"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDispatchRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDispatchRule(request *ListDispatchRuleRequest) (_result *ListDispatchRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDispatchRuleResponse{}
	_body, _err := client.ListDispatchRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListEnvCustomJobsWithOptions(request *ListEnvCustomJobsRequest, runtime *util.RuntimeOptions) (_result *ListEnvCustomJobsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EncryptYaml)) {
		query["EncryptYaml"] = request.EncryptYaml
	}

	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListEnvCustomJobs"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListEnvCustomJobsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListEnvCustomJobs(request *ListEnvCustomJobsRequest) (_result *ListEnvCustomJobsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListEnvCustomJobsResponse{}
	_body, _err := client.ListEnvCustomJobsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListEnvPodMonitorsWithOptions(request *ListEnvPodMonitorsRequest, runtime *util.RuntimeOptions) (_result *ListEnvPodMonitorsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListEnvPodMonitors"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListEnvPodMonitorsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListEnvPodMonitors(request *ListEnvPodMonitorsRequest) (_result *ListEnvPodMonitorsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListEnvPodMonitorsResponse{}
	_body, _err := client.ListEnvPodMonitorsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListEnvServiceMonitorsWithOptions(request *ListEnvServiceMonitorsRequest, runtime *util.RuntimeOptions) (_result *ListEnvServiceMonitorsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListEnvServiceMonitors"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListEnvServiceMonitorsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListEnvServiceMonitors(request *ListEnvServiceMonitorsRequest) (_result *ListEnvServiceMonitorsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListEnvServiceMonitorsResponse{}
	_body, _err := client.ListEnvServiceMonitorsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListEnvironmentFeaturesWithOptions(request *ListEnvironmentFeaturesRequest, runtime *util.RuntimeOptions) (_result *ListEnvironmentFeaturesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListEnvironmentFeatures"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListEnvironmentFeaturesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListEnvironmentFeatures(request *ListEnvironmentFeaturesRequest) (_result *ListEnvironmentFeaturesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListEnvironmentFeaturesResponse{}
	_body, _err := client.ListEnvironmentFeaturesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListEnvironmentsWithOptions(tmpReq *ListEnvironmentsRequest, runtime *util.RuntimeOptions) (_result *ListEnvironmentsResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ListEnvironmentsShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Tag)) {
		request.TagShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Tag, tea.String("Tag"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AddonName)) {
		query["AddonName"] = request.AddonName
	}

	if !tea.BoolValue(util.IsUnset(request.EnvironmentType)) {
		query["EnvironmentType"] = request.EnvironmentType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.TagShrink)) {
		query["Tag"] = request.TagShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListEnvironments"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListEnvironmentsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListEnvironments(request *ListEnvironmentsRequest) (_result *ListEnvironmentsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListEnvironmentsResponse{}
	_body, _err := client.ListEnvironmentsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListEscalationPoliciesWithOptions(request *ListEscalationPoliciesRequest, runtime *util.RuntimeOptions) (_result *ListEscalationPoliciesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListEscalationPolicies"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListEscalationPoliciesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListEscalationPolicies(request *ListEscalationPoliciesRequest) (_result *ListEscalationPoliciesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListEscalationPoliciesResponse{}
	_body, _err := client.ListEscalationPoliciesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListEventBridgeIntegrationsWithOptions(request *ListEventBridgeIntegrationsRequest, runtime *util.RuntimeOptions) (_result *ListEventBridgeIntegrationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListEventBridgeIntegrations"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListEventBridgeIntegrationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListEventBridgeIntegrations(request *ListEventBridgeIntegrationsRequest) (_result *ListEventBridgeIntegrationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListEventBridgeIntegrationsResponse{}
	_body, _err := client.ListEventBridgeIntegrationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListGrafanaWorkspaceWithOptions(tmpReq *ListGrafanaWorkspaceRequest, runtime *util.RuntimeOptions) (_result *ListGrafanaWorkspaceResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ListGrafanaWorkspaceShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Tags)) {
		request.TagsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Tags, tea.String("Tags"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliyunLang)) {
		query["AliyunLang"] = request.AliyunLang
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.TagsShrink)) {
		query["Tags"] = request.TagsShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListGrafanaWorkspace"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListGrafanaWorkspaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListGrafanaWorkspace(request *ListGrafanaWorkspaceRequest) (_result *ListGrafanaWorkspaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListGrafanaWorkspaceResponse{}
	_body, _err := client.ListGrafanaWorkspaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListInsightsEventsWithOptions(request *ListInsightsEventsRequest, runtime *util.RuntimeOptions) (_result *ListInsightsEventsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.InsightsTypes)) {
		query["InsightsTypes"] = request.InsightsTypes
	}

	if !tea.BoolValue(util.IsUnset(request.Pid)) {
		query["Pid"] = request.Pid
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListInsightsEvents"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListInsightsEventsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListInsightsEvents(request *ListInsightsEventsRequest) (_result *ListInsightsEventsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListInsightsEventsResponse{}
	_body, _err := client.ListInsightsEventsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListIntegrationWithOptions(request *ListIntegrationRequest, runtime *util.RuntimeOptions) (_result *ListIntegrationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListIntegration"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListIntegrationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListIntegration(request *ListIntegrationRequest) (_result *ListIntegrationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListIntegrationResponse{}
	_body, _err := client.ListIntegrationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListNotificationPoliciesWithOptions(request *ListNotificationPoliciesRequest, runtime *util.RuntimeOptions) (_result *ListNotificationPoliciesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DirectedMode)) {
		query["DirectedMode"] = request.DirectedMode
	}

	if !tea.BoolValue(util.IsUnset(request.Ids)) {
		query["Ids"] = request.Ids
	}

	if !tea.BoolValue(util.IsUnset(request.IsDetail)) {
		query["IsDetail"] = request.IsDetail
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["Page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["Size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListNotificationPolicies"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListNotificationPoliciesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListNotificationPolicies(request *ListNotificationPoliciesRequest) (_result *ListNotificationPoliciesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListNotificationPoliciesResponse{}
	_body, _err := client.ListNotificationPoliciesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListOnCallSchedulesWithOptions(request *ListOnCallSchedulesRequest, runtime *util.RuntimeOptions) (_result *ListOnCallSchedulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListOnCallSchedules"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListOnCallSchedulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListOnCallSchedules(request *ListOnCallSchedulesRequest) (_result *ListOnCallSchedulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListOnCallSchedulesResponse{}
	_body, _err := client.ListOnCallSchedulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListPrometheusAlertRulesWithOptions(request *ListPrometheusAlertRulesRequest, runtime *util.RuntimeOptions) (_result *ListPrometheusAlertRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.MatchExpressions)) {
		query["MatchExpressions"] = request.MatchExpressions
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListPrometheusAlertRules"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListPrometheusAlertRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListPrometheusAlertRules(request *ListPrometheusAlertRulesRequest) (_result *ListPrometheusAlertRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListPrometheusAlertRulesResponse{}
	_body, _err := client.ListPrometheusAlertRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListPrometheusAlertTemplatesWithOptions(request *ListPrometheusAlertTemplatesRequest, runtime *util.RuntimeOptions) (_result *ListPrometheusAlertTemplatesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListPrometheusAlertTemplates"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListPrometheusAlertTemplatesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListPrometheusAlertTemplates(request *ListPrometheusAlertTemplatesRequest) (_result *ListPrometheusAlertTemplatesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListPrometheusAlertTemplatesResponse{}
	_body, _err := client.ListPrometheusAlertTemplatesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListPrometheusGlobalViewWithOptions(request *ListPrometheusGlobalViewRequest, runtime *util.RuntimeOptions) (_result *ListPrometheusGlobalViewResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListPrometheusGlobalView"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListPrometheusGlobalViewResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListPrometheusGlobalView(request *ListPrometheusGlobalViewRequest) (_result *ListPrometheusGlobalViewResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListPrometheusGlobalViewResponse{}
	_body, _err := client.ListPrometheusGlobalViewWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListPrometheusInstanceByTagAndResourceGroupIdWithOptions(request *ListPrometheusInstanceByTagAndResourceGroupIdRequest, runtime *util.RuntimeOptions) (_result *ListPrometheusInstanceByTagAndResourceGroupIdResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListPrometheusInstanceByTagAndResourceGroupId"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListPrometheusInstanceByTagAndResourceGroupIdResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListPrometheusInstanceByTagAndResourceGroupId(request *ListPrometheusInstanceByTagAndResourceGroupIdRequest) (_result *ListPrometheusInstanceByTagAndResourceGroupIdResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListPrometheusInstanceByTagAndResourceGroupIdResponse{}
	_body, _err := client.ListPrometheusInstanceByTagAndResourceGroupIdWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListPrometheusInstancesWithOptions(request *ListPrometheusInstancesRequest, runtime *util.RuntimeOptions) (_result *ListPrometheusInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterType)) {
		query["ClusterType"] = request.ClusterType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ShowGlobalView)) {
		query["ShowGlobalView"] = request.ShowGlobalView
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListPrometheusInstances"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListPrometheusInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListPrometheusInstances(request *ListPrometheusInstancesRequest) (_result *ListPrometheusInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListPrometheusInstancesResponse{}
	_body, _err := client.ListPrometheusInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListPrometheusIntegrationWithOptions(request *ListPrometheusIntegrationRequest, runtime *util.RuntimeOptions) (_result *ListPrometheusIntegrationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.IntegrationType)) {
		query["IntegrationType"] = request.IntegrationType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListPrometheusIntegration"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListPrometheusIntegrationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListPrometheusIntegration(request *ListPrometheusIntegrationRequest) (_result *ListPrometheusIntegrationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListPrometheusIntegrationResponse{}
	_body, _err := client.ListPrometheusIntegrationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListPrometheusMonitoringWithOptions(request *ListPrometheusMonitoringRequest, runtime *util.RuntimeOptions) (_result *ListPrometheusMonitoringResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListPrometheusMonitoring"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListPrometheusMonitoringResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListPrometheusMonitoring(request *ListPrometheusMonitoringRequest) (_result *ListPrometheusMonitoringResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListPrometheusMonitoringResponse{}
	_body, _err := client.ListPrometheusMonitoringWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListPrometheusRemoteWritesWithOptions(request *ListPrometheusRemoteWritesRequest, runtime *util.RuntimeOptions) (_result *ListPrometheusRemoteWritesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListPrometheusRemoteWrites"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListPrometheusRemoteWritesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListPrometheusRemoteWrites(request *ListPrometheusRemoteWritesRequest) (_result *ListPrometheusRemoteWritesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListPrometheusRemoteWritesResponse{}
	_body, _err := client.ListPrometheusRemoteWritesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ****
 *
 * @param request ListRetcodeAppsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRetcodeAppsResponse
 */
func (client *Client) ListRetcodeAppsWithOptions(request *ListRetcodeAppsRequest, runtime *util.RuntimeOptions) (_result *ListRetcodeAppsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListRetcodeApps"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListRetcodeAppsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ****
 *
 * @param request ListRetcodeAppsRequest
 * @return ListRetcodeAppsResponse
 */
func (client *Client) ListRetcodeApps(request *ListRetcodeAppsRequest) (_result *ListRetcodeAppsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListRetcodeAppsResponse{}
	_body, _err := client.ListRetcodeAppsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListScenarioWithOptions(request *ListScenarioRequest, runtime *util.RuntimeOptions) (_result *ListScenarioResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Scenario)) {
		query["Scenario"] = request.Scenario
	}

	if !tea.BoolValue(util.IsUnset(request.Sign)) {
		query["Sign"] = request.Sign
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListScenario"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListScenarioResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListScenario(request *ListScenarioRequest) (_result *ListScenarioResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListScenarioResponse{}
	_body, _err := client.ListScenarioWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListSilencePoliciesWithOptions(request *ListSilencePoliciesRequest, runtime *util.RuntimeOptions) (_result *ListSilencePoliciesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IsDetail)) {
		query["IsDetail"] = request.IsDetail
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["Page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["Size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSilencePolicies"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSilencePoliciesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListSilencePolicies(request *ListSilencePoliciesRequest) (_result *ListSilencePoliciesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListSilencePoliciesResponse{}
	_body, _err := client.ListSilencePoliciesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTimingSyntheticTasksWithOptions(tmpReq *ListTimingSyntheticTasksRequest, runtime *util.RuntimeOptions) (_result *ListTimingSyntheticTasksResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ListTimingSyntheticTasksShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Search)) {
		request.SearchShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Search, tea.String("Search"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.Tags)) {
		request.TagsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Tags, tea.String("Tags"), tea.String("json"))
	}

	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTimingSyntheticTasks"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTimingSyntheticTasksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTimingSyntheticTasks(request *ListTimingSyntheticTasksRequest) (_result *ListTimingSyntheticTasksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTimingSyntheticTasksResponse{}
	_body, _err := client.ListTimingSyntheticTasksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTraceAppsWithOptions(request *ListTraceAppsRequest, runtime *util.RuntimeOptions) (_result *ListTraceAppsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppType)) {
		query["AppType"] = request.AppType
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTraceApps"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTraceAppsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTraceApps(request *ListTraceAppsRequest) (_result *ListTraceAppsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTraceAppsResponse{}
	_body, _err := client.ListTraceAppsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ManageGetRecordingRuleWithOptions(request *ManageGetRecordingRuleRequest, runtime *util.RuntimeOptions) (_result *ManageGetRecordingRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.QueryUserId)) {
		query["QueryUserId"] = request.QueryUserId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ManageGetRecordingRule"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ManageGetRecordingRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ManageGetRecordingRule(request *ManageGetRecordingRuleRequest) (_result *ManageGetRecordingRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ManageGetRecordingRuleResponse{}
	_body, _err := client.ManageGetRecordingRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ManageRecordingRuleWithOptions(request *ManageRecordingRuleRequest, runtime *util.RuntimeOptions) (_result *ManageRecordingRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.QueryUserId)) {
		query["QueryUserId"] = request.QueryUserId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleYaml)) {
		query["RuleYaml"] = request.RuleYaml
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ManageRecordingRule"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ManageRecordingRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ManageRecordingRule(request *ManageRecordingRuleRequest) (_result *ManageRecordingRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ManageRecordingRuleResponse{}
	_body, _err := client.ManageRecordingRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) OpenArmsDefaultSLRWithOptions(request *OpenArmsDefaultSLRRequest, runtime *util.RuntimeOptions) (_result *OpenArmsDefaultSLRResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("OpenArmsDefaultSLR"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &OpenArmsDefaultSLRResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) OpenArmsDefaultSLR(request *OpenArmsDefaultSLRRequest) (_result *OpenArmsDefaultSLRResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &OpenArmsDefaultSLRResponse{}
	_body, _err := client.OpenArmsDefaultSLRWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The **OpenArmsServiceSecondVersion** operation supports the following sub-service editions:
 * *   Application Monitoring: Basic Edition
 * *   Browser Monitoring: Basic Edition
 * *   Synthetic Monitoring: Pro Edition (pay-as-you-go)
 * *   Prometheus Service: Pro Edition
 *
 * @param request OpenArmsServiceSecondVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenArmsServiceSecondVersionResponse
 */
func (client *Client) OpenArmsServiceSecondVersionWithOptions(request *OpenArmsServiceSecondVersionRequest, runtime *util.RuntimeOptions) (_result *OpenArmsServiceSecondVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("OpenArmsServiceSecondVersion"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &OpenArmsServiceSecondVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The **OpenArmsServiceSecondVersion** operation supports the following sub-service editions:
 * *   Application Monitoring: Basic Edition
 * *   Browser Monitoring: Basic Edition
 * *   Synthetic Monitoring: Pro Edition (pay-as-you-go)
 * *   Prometheus Service: Pro Edition
 *
 * @param request OpenArmsServiceSecondVersionRequest
 * @return OpenArmsServiceSecondVersionResponse
 */
func (client *Client) OpenArmsServiceSecondVersion(request *OpenArmsServiceSecondVersionRequest) (_result *OpenArmsServiceSecondVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &OpenArmsServiceSecondVersionResponse{}
	_body, _err := client.OpenArmsServiceSecondVersionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) OpenVClusterWithOptions(request *OpenVClusterRequest, runtime *util.RuntimeOptions) (_result *OpenVClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterType)) {
		query["ClusterType"] = request.ClusterType
	}

	if !tea.BoolValue(util.IsUnset(request.Length)) {
		query["Length"] = request.Length
	}

	if !tea.BoolValue(util.IsUnset(request.Product)) {
		query["Product"] = request.Product
	}

	if !tea.BoolValue(util.IsUnset(request.RecreateSwitch)) {
		query["RecreateSwitch"] = request.RecreateSwitch
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("OpenVCluster"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &OpenVClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) OpenVCluster(request *OpenVClusterRequest) (_result *OpenVClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &OpenVClusterResponse{}
	_body, _err := client.OpenVClusterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) OpenXtraceDefaultSLRWithOptions(request *OpenXtraceDefaultSLRRequest, runtime *util.RuntimeOptions) (_result *OpenXtraceDefaultSLRResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("OpenXtraceDefaultSLR"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &OpenXtraceDefaultSLRResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) OpenXtraceDefaultSLR(request *OpenXtraceDefaultSLRRequest) (_result *OpenXtraceDefaultSLRResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &OpenXtraceDefaultSLRResponse{}
	_body, _err := client.OpenXtraceDefaultSLRWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryAppMetadataWithOptions(request *QueryAppMetadataRequest, runtime *util.RuntimeOptions) (_result *QueryAppMetadataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryAppMetadata"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryAppMetadataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryAppMetadata(request *QueryAppMetadataRequest) (_result *QueryAppMetadataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryAppMetadataResponse{}
	_body, _err := client.QueryAppMetadataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryAppTopologyWithOptions(tmpReq *QueryAppTopologyRequest, runtime *util.RuntimeOptions) (_result *QueryAppTopologyResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &QueryAppTopologyShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Filters)) {
		request.FiltersShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Filters, tea.String("Filters"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppType)) {
		query["AppType"] = request.AppType
	}

	if !tea.BoolValue(util.IsUnset(request.Db)) {
		query["Db"] = request.Db
	}

	if !tea.BoolValue(util.IsUnset(request.DbName)) {
		query["DbName"] = request.DbName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.FiltersShrink)) {
		query["Filters"] = request.FiltersShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Pid)) {
		query["Pid"] = request.Pid
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Rpc)) {
		query["Rpc"] = request.Rpc
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryAppTopology"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryAppTopologyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryAppTopology(request *QueryAppTopologyRequest) (_result *QueryAppTopologyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryAppTopologyResponse{}
	_body, _err := client.QueryAppTopologyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryCommercialUsageWithOptions(request *QueryCommercialUsageRequest, runtime *util.RuntimeOptions) (_result *QueryCommercialUsageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AdvancedFilters)) {
		query["AdvancedFilters"] = request.AdvancedFilters
	}

	if !tea.BoolValue(util.IsUnset(request.Dimensions)) {
		query["Dimensions"] = request.Dimensions
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.IntervalInSec)) {
		query["IntervalInSec"] = request.IntervalInSec
	}

	if !tea.BoolValue(util.IsUnset(request.Measures)) {
		query["Measures"] = request.Measures
	}

	if !tea.BoolValue(util.IsUnset(request.Metric)) {
		query["Metric"] = request.Metric
	}

	if !tea.BoolValue(util.IsUnset(request.Order)) {
		query["Order"] = request.Order
	}

	if !tea.BoolValue(util.IsUnset(request.OrderBy)) {
		query["OrderBy"] = request.OrderBy
	}

	if !tea.BoolValue(util.IsUnset(request.QueryType)) {
		query["QueryType"] = request.QueryType
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryCommercialUsage"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryCommercialUsageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryCommercialUsage(request *QueryCommercialUsageRequest) (_result *QueryCommercialUsageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryCommercialUsageResponse{}
	_body, _err := client.QueryCommercialUsageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryMetricByPageWithOptions(request *QueryMetricByPageRequest, runtime *util.RuntimeOptions) (_result *QueryMetricByPageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.CustomFilters)) {
		query["CustomFilters"] = request.CustomFilters
	}

	if !tea.BoolValue(util.IsUnset(request.Dimensions)) {
		query["Dimensions"] = request.Dimensions
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Filters)) {
		query["Filters"] = request.Filters
	}

	if !tea.BoolValue(util.IsUnset(request.IntervalInSec)) {
		query["IntervalInSec"] = request.IntervalInSec
	}

	if !tea.BoolValue(util.IsUnset(request.Measures)) {
		query["Measures"] = request.Measures
	}

	if !tea.BoolValue(util.IsUnset(request.Metric)) {
		query["Metric"] = request.Metric
	}

	if !tea.BoolValue(util.IsUnset(request.Order)) {
		query["Order"] = request.Order
	}

	if !tea.BoolValue(util.IsUnset(request.OrderBy)) {
		query["OrderBy"] = request.OrderBy
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryMetricByPage"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryMetricByPageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryMetricByPage(request *QueryMetricByPageRequest) (_result *QueryMetricByPageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryMetricByPageResponse{}
	_body, _err := client.QueryMetricByPageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryPromInstallStatusWithOptions(request *QueryPromInstallStatusRequest, runtime *util.RuntimeOptions) (_result *QueryPromInstallStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryPromInstallStatus"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryPromInstallStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryPromInstallStatus(request *QueryPromInstallStatusRequest) (_result *QueryPromInstallStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryPromInstallStatusResponse{}
	_body, _err := client.QueryPromInstallStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryReleaseMetricWithOptions(request *QueryReleaseMetricRequest, runtime *util.RuntimeOptions) (_result *QueryReleaseMetricResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ChangeOrderId)) {
		query["ChangeOrderId"] = request.ChangeOrderId
	}

	if !tea.BoolValue(util.IsUnset(request.CreateTime)) {
		query["CreateTime"] = request.CreateTime
	}

	if !tea.BoolValue(util.IsUnset(request.MetricType)) {
		query["MetricType"] = request.MetricType
	}

	if !tea.BoolValue(util.IsUnset(request.Pid)) {
		query["Pid"] = request.Pid
	}

	if !tea.BoolValue(util.IsUnset(request.ProxyUserId)) {
		query["ProxyUserId"] = request.ProxyUserId
	}

	if !tea.BoolValue(util.IsUnset(request.ReleaseEndTime)) {
		query["ReleaseEndTime"] = request.ReleaseEndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ReleaseStartTime)) {
		query["ReleaseStartTime"] = request.ReleaseStartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Service)) {
		query["Service"] = request.Service
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryReleaseMetric"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryReleaseMetricResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryReleaseMetric(request *QueryReleaseMetricRequest) (_result *QueryReleaseMetricResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryReleaseMetricResponse{}
	_body, _err := client.QueryReleaseMetricWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RemoveAliClusterIdsFromPrometheusGlobalViewWithOptions(request *RemoveAliClusterIdsFromPrometheusGlobalViewRequest, runtime *util.RuntimeOptions) (_result *RemoveAliClusterIdsFromPrometheusGlobalViewResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterIds)) {
		query["ClusterIds"] = request.ClusterIds
	}

	if !tea.BoolValue(util.IsUnset(request.GlobalViewClusterId)) {
		query["GlobalViewClusterId"] = request.GlobalViewClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveAliClusterIdsFromPrometheusGlobalView"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveAliClusterIdsFromPrometheusGlobalViewResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RemoveAliClusterIdsFromPrometheusGlobalView(request *RemoveAliClusterIdsFromPrometheusGlobalViewRequest) (_result *RemoveAliClusterIdsFromPrometheusGlobalViewResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveAliClusterIdsFromPrometheusGlobalViewResponse{}
	_body, _err := client.RemoveAliClusterIdsFromPrometheusGlobalViewWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RemoveSourcesFromPrometheusGlobalViewWithOptions(request *RemoveSourcesFromPrometheusGlobalViewRequest, runtime *util.RuntimeOptions) (_result *RemoveSourcesFromPrometheusGlobalViewResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GlobalViewClusterId)) {
		query["GlobalViewClusterId"] = request.GlobalViewClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceNames)) {
		query["SourceNames"] = request.SourceNames
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveSourcesFromPrometheusGlobalView"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveSourcesFromPrometheusGlobalViewResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RemoveSourcesFromPrometheusGlobalView(request *RemoveSourcesFromPrometheusGlobalViewRequest) (_result *RemoveSourcesFromPrometheusGlobalViewResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveSourcesFromPrometheusGlobalViewResponse{}
	_body, _err := client.RemoveSourcesFromPrometheusGlobalViewWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RestartEnvironmentFeatureWithOptions(request *RestartEnvironmentFeatureRequest, runtime *util.RuntimeOptions) (_result *RestartEnvironmentFeatureResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.FeatureName)) {
		query["FeatureName"] = request.FeatureName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RestartEnvironmentFeature"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RestartEnvironmentFeatureResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RestartEnvironmentFeature(request *RestartEnvironmentFeatureRequest) (_result *RestartEnvironmentFeatureResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RestartEnvironmentFeatureResponse{}
	_body, _err := client.RestartEnvironmentFeatureWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SaveTraceAppConfigWithOptions(request *SaveTraceAppConfigRequest, runtime *util.RuntimeOptions) (_result *SaveTraceAppConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Pid)) {
		query["Pid"] = request.Pid
	}

	if !tea.BoolValue(util.IsUnset(request.Settings)) {
		query["Settings"] = request.Settings
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SaveTraceAppConfig"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SaveTraceAppConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SaveTraceAppConfig(request *SaveTraceAppConfigRequest) (_result *SaveTraceAppConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SaveTraceAppConfigResponse{}
	_body, _err := client.SaveTraceAppConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is no longer maintained. To query alert contacts, call the DescribeContacts operation provided by the new version of Alert Management.
 *
 * @param request SearchAlertContactRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchAlertContactResponse
 */
func (client *Client) SearchAlertContactWithOptions(request *SearchAlertContactRequest, runtime *util.RuntimeOptions) (_result *SearchAlertContactResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ContactIds)) {
		query["ContactIds"] = request.ContactIds
	}

	if !tea.BoolValue(util.IsUnset(request.ContactName)) {
		query["ContactName"] = request.ContactName
	}

	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.Email)) {
		query["Email"] = request.Email
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Phone)) {
		query["Phone"] = request.Phone
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SearchAlertContact"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SearchAlertContactResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is no longer maintained. To query alert contacts, call the DescribeContacts operation provided by the new version of Alert Management.
 *
 * @param request SearchAlertContactRequest
 * @return SearchAlertContactResponse
 */
func (client *Client) SearchAlertContact(request *SearchAlertContactRequest) (_result *SearchAlertContactResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SearchAlertContactResponse{}
	_body, _err := client.SearchAlertContactWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The operation is no longer maintained. Call the DescribeContactGroups operation in the alert management module to query alert contact groups.
 *
 * @param request SearchAlertContactGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchAlertContactGroupResponse
 */
func (client *Client) SearchAlertContactGroupWithOptions(request *SearchAlertContactGroupRequest, runtime *util.RuntimeOptions) (_result *SearchAlertContactGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ContactGroupIds)) {
		query["ContactGroupIds"] = request.ContactGroupIds
	}

	if !tea.BoolValue(util.IsUnset(request.ContactGroupName)) {
		query["ContactGroupName"] = request.ContactGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.ContactId)) {
		query["ContactId"] = request.ContactId
	}

	if !tea.BoolValue(util.IsUnset(request.ContactName)) {
		query["ContactName"] = request.ContactName
	}

	if !tea.BoolValue(util.IsUnset(request.IsDetail)) {
		query["IsDetail"] = request.IsDetail
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SearchAlertContactGroup"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SearchAlertContactGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The operation is no longer maintained. Call the DescribeContactGroups operation in the alert management module to query alert contact groups.
 *
 * @param request SearchAlertContactGroupRequest
 * @return SearchAlertContactGroupResponse
 */
func (client *Client) SearchAlertContactGroup(request *SearchAlertContactGroupRequest) (_result *SearchAlertContactGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SearchAlertContactGroupResponse{}
	_body, _err := client.SearchAlertContactGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is no longer maintained. To query alert records, call the ListAlerts operation provided by the new version of Alert Management.
 *
 * @param request SearchAlertHistoriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchAlertHistoriesResponse
 */
func (client *Client) SearchAlertHistoriesWithOptions(request *SearchAlertHistoriesRequest, runtime *util.RuntimeOptions) (_result *SearchAlertHistoriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertId)) {
		query["AlertId"] = request.AlertId
	}

	if !tea.BoolValue(util.IsUnset(request.AlertType)) {
		query["AlertType"] = request.AlertType
	}

	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SearchAlertHistories"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SearchAlertHistoriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is no longer maintained. To query alert records, call the ListAlerts operation provided by the new version of Alert Management.
 *
 * @param request SearchAlertHistoriesRequest
 * @return SearchAlertHistoriesResponse
 */
func (client *Client) SearchAlertHistories(request *SearchAlertHistoriesRequest) (_result *SearchAlertHistoriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SearchAlertHistoriesResponse{}
	_body, _err := client.SearchAlertHistoriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The current operation is no longer maintained. You can call the GetAlertRules operation of Alert Management (New) to query existing alert rules.
 *
 * @param request SearchAlertRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchAlertRulesResponse
 */
func (client *Client) SearchAlertRulesWithOptions(request *SearchAlertRulesRequest, runtime *util.RuntimeOptions) (_result *SearchAlertRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertRuleId)) {
		query["AlertRuleId"] = request.AlertRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.AppType)) {
		query["AppType"] = request.AppType
	}

	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Pid)) {
		query["Pid"] = request.Pid
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SystemRegionId)) {
		query["SystemRegionId"] = request.SystemRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.Title)) {
		query["Title"] = request.Title
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SearchAlertRules"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SearchAlertRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The current operation is no longer maintained. You can call the GetAlertRules operation of Alert Management (New) to query existing alert rules.
 *
 * @param request SearchAlertRulesRequest
 * @return SearchAlertRulesResponse
 */
func (client *Client) SearchAlertRules(request *SearchAlertRulesRequest) (_result *SearchAlertRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SearchAlertRulesResponse{}
	_body, _err := client.SearchAlertRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Alert event records are different from alert notification records. Alert events are recorded every minute after an alert rule filters data. Alert events can be classified based on whether they are triggered or not. If a triggered event is not in the silence period, an alert notification is sent.
 *
 * @param request SearchEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchEventsResponse
 */
func (client *Client) SearchEventsWithOptions(request *SearchEventsRequest, runtime *util.RuntimeOptions) (_result *SearchEventsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertId)) {
		query["AlertId"] = request.AlertId
	}

	if !tea.BoolValue(util.IsUnset(request.AlertType)) {
		query["AlertType"] = request.AlertType
	}

	if !tea.BoolValue(util.IsUnset(request.AppType)) {
		query["AppType"] = request.AppType
	}

	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.IsTrigger)) {
		query["IsTrigger"] = request.IsTrigger
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Pid)) {
		query["Pid"] = request.Pid
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SearchEvents"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SearchEventsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Alert event records are different from alert notification records. Alert events are recorded every minute after an alert rule filters data. Alert events can be classified based on whether they are triggered or not. If a triggered event is not in the silence period, an alert notification is sent.
 *
 * @param request SearchEventsRequest
 * @return SearchEventsResponse
 */
func (client *Client) SearchEvents(request *SearchEventsRequest) (_result *SearchEventsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SearchEventsResponse{}
	_body, _err := client.SearchEventsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SearchRetcodeAppByPageWithOptions(request *SearchRetcodeAppByPageRequest, runtime *util.RuntimeOptions) (_result *SearchRetcodeAppByPageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RetcodeAppId)) {
		query["RetcodeAppId"] = request.RetcodeAppId
	}

	if !tea.BoolValue(util.IsUnset(request.RetcodeAppName)) {
		query["RetcodeAppName"] = request.RetcodeAppName
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SearchRetcodeAppByPage"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SearchRetcodeAppByPageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SearchRetcodeAppByPage(request *SearchRetcodeAppByPageRequest) (_result *SearchRetcodeAppByPageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SearchRetcodeAppByPageResponse{}
	_body, _err := client.SearchRetcodeAppByPageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SearchTraceAppByNameWithOptions(request *SearchTraceAppByNameRequest, runtime *util.RuntimeOptions) (_result *SearchTraceAppByNameResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.TraceAppName)) {
		query["TraceAppName"] = request.TraceAppName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SearchTraceAppByName"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SearchTraceAppByNameResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SearchTraceAppByName(request *SearchTraceAppByNameRequest) (_result *SearchTraceAppByNameResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SearchTraceAppByNameResponse{}
	_body, _err := client.SearchTraceAppByNameWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SearchTraceAppByPageWithOptions(request *SearchTraceAppByPageRequest, runtime *util.RuntimeOptions) (_result *SearchTraceAppByPageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.TraceAppName)) {
		query["TraceAppName"] = request.TraceAppName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SearchTraceAppByPage"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SearchTraceAppByPageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SearchTraceAppByPage(request *SearchTraceAppByPageRequest) (_result *SearchTraceAppByPageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SearchTraceAppByPageResponse{}
	_body, _err := client.SearchTraceAppByPageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > A maximum of 100 data entries can be returned each time this operation is called. If you want to query all existing traces, we recommend that you call the SearchTracesByPage operation. For more information, see [SearchTracesByPage](~~175866~~).
 *
 * @param request SearchTracesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchTracesResponse
 */
func (client *Client) SearchTracesWithOptions(request *SearchTracesRequest, runtime *util.RuntimeOptions) (_result *SearchTracesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ExclusionFilters)) {
		query["ExclusionFilters"] = request.ExclusionFilters
	}

	if !tea.BoolValue(util.IsUnset(request.MinDuration)) {
		query["MinDuration"] = request.MinDuration
	}

	if !tea.BoolValue(util.IsUnset(request.OperationName)) {
		query["OperationName"] = request.OperationName
	}

	if !tea.BoolValue(util.IsUnset(request.Pid)) {
		query["Pid"] = request.Pid
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Reverse)) {
		query["Reverse"] = request.Reverse
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceIp)) {
		query["ServiceIp"] = request.ServiceIp
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SearchTraces"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SearchTracesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > A maximum of 100 data entries can be returned each time this operation is called. If you want to query all existing traces, we recommend that you call the SearchTracesByPage operation. For more information, see [SearchTracesByPage](~~175866~~).
 *
 * @param request SearchTracesRequest
 * @return SearchTracesResponse
 */
func (client *Client) SearchTraces(request *SearchTracesRequest) (_result *SearchTracesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SearchTracesResponse{}
	_body, _err := client.SearchTracesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SearchTracesByPageWithOptions(request *SearchTracesByPageRequest, runtime *util.RuntimeOptions) (_result *SearchTracesByPageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ExclusionFilters)) {
		query["ExclusionFilters"] = request.ExclusionFilters
	}

	if !tea.BoolValue(util.IsUnset(request.IsError)) {
		query["IsError"] = request.IsError
	}

	if !tea.BoolValue(util.IsUnset(request.MinDuration)) {
		query["MinDuration"] = request.MinDuration
	}

	if !tea.BoolValue(util.IsUnset(request.OperationName)) {
		query["OperationName"] = request.OperationName
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Pid)) {
		query["Pid"] = request.Pid
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Reverse)) {
		query["Reverse"] = request.Reverse
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceIp)) {
		query["ServiceIp"] = request.ServiceIp
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SearchTracesByPage"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SearchTracesByPageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SearchTracesByPage(request *SearchTracesByPageRequest) (_result *SearchTracesByPageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SearchTracesByPageResponse{}
	_body, _err := client.SearchTracesByPageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After you receive the text message, verify the mobile number as prompted. Before you can specify a mobile phone number in a notification policy, you must verify the mobile phone number.
 *
 * @param request SendTTSVerifyLinkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SendTTSVerifyLinkResponse
 */
func (client *Client) SendTTSVerifyLinkWithOptions(request *SendTTSVerifyLinkRequest, runtime *util.RuntimeOptions) (_result *SendTTSVerifyLinkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ContactId)) {
		body["ContactId"] = request.ContactId
	}

	if !tea.BoolValue(util.IsUnset(request.Phone)) {
		body["Phone"] = request.Phone
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("SendTTSVerifyLink"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SendTTSVerifyLinkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After you receive the text message, verify the mobile number as prompted. Before you can specify a mobile phone number in a notification policy, you must verify the mobile phone number.
 *
 * @param request SendTTSVerifyLinkRequest
 * @return SendTTSVerifyLinkResponse
 */
func (client *Client) SendTTSVerifyLink(request *SendTTSVerifyLinkRequest) (_result *SendTTSVerifyLinkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SendTTSVerifyLinkResponse{}
	_body, _err := client.SendTTSVerifyLinkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetRetcodeShareStatusWithOptions(request *SetRetcodeShareStatusRequest, runtime *util.RuntimeOptions) (_result *SetRetcodeShareStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Pid)) {
		query["Pid"] = request.Pid
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetRetcodeShareStatus"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetRetcodeShareStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetRetcodeShareStatus(request *SetRetcodeShareStatusRequest) (_result *SetRetcodeShareStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetRetcodeShareStatusResponse{}
	_body, _err := client.SetRetcodeShareStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) StartAlertWithOptions(request *StartAlertRequest, runtime *util.RuntimeOptions) (_result *StartAlertResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertId)) {
		query["AlertId"] = request.AlertId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StartAlert"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StartAlertResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) StartAlert(request *StartAlertRequest) (_result *StartAlertResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StartAlertResponse{}
	_body, _err := client.StartAlertWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) StartTimingSyntheticTaskWithOptions(tmpReq *StartTimingSyntheticTaskRequest, runtime *util.RuntimeOptions) (_result *StartTimingSyntheticTaskResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &StartTimingSyntheticTaskShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.TaskIds)) {
		request.TaskIdsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.TaskIds, tea.String("TaskIds"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskIdsShrink)) {
		query["TaskIds"] = request.TaskIdsShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StartTimingSyntheticTask"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StartTimingSyntheticTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) StartTimingSyntheticTask(request *StartTimingSyntheticTaskRequest) (_result *StartTimingSyntheticTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StartTimingSyntheticTaskResponse{}
	_body, _err := client.StartTimingSyntheticTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) StopAlertWithOptions(request *StopAlertRequest, runtime *util.RuntimeOptions) (_result *StopAlertResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertId)) {
		query["AlertId"] = request.AlertId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StopAlert"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StopAlertResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) StopAlert(request *StopAlertRequest) (_result *StopAlertResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StopAlertResponse{}
	_body, _err := client.StopAlertWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) StopTimingSyntheticTaskWithOptions(tmpReq *StopTimingSyntheticTaskRequest, runtime *util.RuntimeOptions) (_result *StopTimingSyntheticTaskResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &StopTimingSyntheticTaskShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.TaskIds)) {
		request.TaskIdsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.TaskIds, tea.String("TaskIds"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskIdsShrink)) {
		query["TaskIds"] = request.TaskIdsShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StopTimingSyntheticTask"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StopTimingSyntheticTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) StopTimingSyntheticTask(request *StopTimingSyntheticTaskRequest) (_result *StopTimingSyntheticTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StopTimingSyntheticTaskResponse{}
	_body, _err := client.StopTimingSyntheticTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SwitchSyntheticTaskStatusWithOptions(request *SwitchSyntheticTaskStatusRequest, runtime *util.RuntimeOptions) (_result *SwitchSyntheticTaskStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.SwitchStatus)) {
		query["SwitchStatus"] = request.SwitchStatus
	}

	if !tea.BoolValue(util.IsUnset(request.TaskIds)) {
		query["TaskIds"] = request.TaskIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SwitchSyntheticTaskStatus"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SwitchSyntheticTaskStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SwitchSyntheticTaskStatus(request *SwitchSyntheticTaskStatusRequest) (_result *SwitchSyntheticTaskStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SwitchSyntheticTaskStatusResponse{}
	_body, _err := client.SwitchSyntheticTaskStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SyncRecordingRulesWithOptions(request *SyncRecordingRulesRequest, runtime *util.RuntimeOptions) (_result *SyncRecordingRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetClusters)) {
		query["TargetClusters"] = request.TargetClusters
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SyncRecordingRules"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SyncRecordingRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SyncRecordingRules(request *SyncRecordingRulesRequest) (_result *SyncRecordingRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SyncRecordingRulesResponse{}
	_body, _err := client.SyncRecordingRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) TagResourcesWithOptions(request *TagResourcesRequest, runtime *util.RuntimeOptions) (_result *TagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TagResources"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) TagResources(request *TagResourcesRequest) (_result *TagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TagResourcesResponse{}
	_body, _err := client.TagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Make sure that the ASK cluster or ECS instance is monitored in Managed Service for Prometheus.
 *
 * @param request UninstallManagedPrometheusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UninstallManagedPrometheusResponse
 */
func (client *Client) UninstallManagedPrometheusWithOptions(request *UninstallManagedPrometheusRequest, runtime *util.RuntimeOptions) (_result *UninstallManagedPrometheusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterType)) {
		query["ClusterType"] = request.ClusterType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UninstallManagedPrometheus"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UninstallManagedPrometheusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Make sure that the ASK cluster or ECS instance is monitored in Managed Service for Prometheus.
 *
 * @param request UninstallManagedPrometheusRequest
 * @return UninstallManagedPrometheusResponse
 */
func (client *Client) UninstallManagedPrometheus(request *UninstallManagedPrometheusRequest) (_result *UninstallManagedPrometheusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UninstallManagedPrometheusResponse{}
	_body, _err := client.UninstallManagedPrometheusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UninstallPromClusterWithOptions(request *UninstallPromClusterRequest, runtime *util.RuntimeOptions) (_result *UninstallPromClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliyunLang)) {
		query["AliyunLang"] = request.AliyunLang
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UninstallPromCluster"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UninstallPromClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UninstallPromCluster(request *UninstallPromClusterRequest) (_result *UninstallPromClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UninstallPromClusterResponse{}
	_body, _err := client.UninstallPromClusterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UntagResourcesWithOptions(request *UntagResourcesRequest, runtime *util.RuntimeOptions) (_result *UntagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.All)) {
		query["All"] = request.All
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TagKey)) {
		query["TagKey"] = request.TagKey
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UntagResources"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UntagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UntagResources(request *UntagResourcesRequest) (_result *UntagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UntagResourcesResponse{}
	_body, _err := client.UntagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is no longer maintained. To create or modify an alert contact, call the CreateOrUpdateContact operation provided by the new version of Alert Management.
 *
 * @param request UpdateAlertContactRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAlertContactResponse
 */
func (client *Client) UpdateAlertContactWithOptions(request *UpdateAlertContactRequest, runtime *util.RuntimeOptions) (_result *UpdateAlertContactResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ContactId)) {
		query["ContactId"] = request.ContactId
	}

	if !tea.BoolValue(util.IsUnset(request.ContactName)) {
		query["ContactName"] = request.ContactName
	}

	if !tea.BoolValue(util.IsUnset(request.DingRobotWebhookUrl)) {
		query["DingRobotWebhookUrl"] = request.DingRobotWebhookUrl
	}

	if !tea.BoolValue(util.IsUnset(request.Email)) {
		query["Email"] = request.Email
	}

	if !tea.BoolValue(util.IsUnset(request.PhoneNum)) {
		query["PhoneNum"] = request.PhoneNum
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SystemNoc)) {
		query["SystemNoc"] = request.SystemNoc
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAlertContact"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAlertContactResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is no longer maintained. To create or modify an alert contact, call the CreateOrUpdateContact operation provided by the new version of Alert Management.
 *
 * @param request UpdateAlertContactRequest
 * @return UpdateAlertContactResponse
 */
func (client *Client) UpdateAlertContact(request *UpdateAlertContactRequest) (_result *UpdateAlertContactResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAlertContactResponse{}
	_body, _err := client.UpdateAlertContactWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateAlertContactGroupWithOptions(request *UpdateAlertContactGroupRequest, runtime *util.RuntimeOptions) (_result *UpdateAlertContactGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ContactGroupId)) {
		query["ContactGroupId"] = request.ContactGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ContactGroupName)) {
		query["ContactGroupName"] = request.ContactGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.ContactIds)) {
		query["ContactIds"] = request.ContactIds
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAlertContactGroup"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAlertContactGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateAlertContactGroup(request *UpdateAlertContactGroupRequest) (_result *UpdateAlertContactGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAlertContactGroupResponse{}
	_body, _err := client.UpdateAlertContactGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateAlertRuleWithOptions(request *UpdateAlertRuleRequest, runtime *util.RuntimeOptions) (_result *UpdateAlertRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertId)) {
		query["AlertId"] = request.AlertId
	}

	if !tea.BoolValue(util.IsUnset(request.ContactGroupIds)) {
		query["ContactGroupIds"] = request.ContactGroupIds
	}

	if !tea.BoolValue(util.IsUnset(request.IsAutoStart)) {
		query["IsAutoStart"] = request.IsAutoStart
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.TemplageAlertConfig)) {
		query["TemplageAlertConfig"] = request.TemplageAlertConfig
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAlertRule"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAlertRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateAlertRule(request *UpdateAlertRuleRequest) (_result *UpdateAlertRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAlertRuleResponse{}
	_body, _err := client.UpdateAlertRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateDispatchRuleWithOptions(request *UpdateDispatchRuleRequest, runtime *util.RuntimeOptions) (_result *UpdateDispatchRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DispatchRule)) {
		query["DispatchRule"] = request.DispatchRule
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDispatchRule"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDispatchRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateDispatchRule(request *UpdateDispatchRuleRequest) (_result *UpdateDispatchRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDispatchRuleResponse{}
	_body, _err := client.UpdateDispatchRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateEnvCustomJobWithOptions(request *UpdateEnvCustomJobRequest, runtime *util.RuntimeOptions) (_result *UpdateEnvCustomJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliyunLang)) {
		query["AliyunLang"] = request.AliyunLang
	}

	if !tea.BoolValue(util.IsUnset(request.CustomJobName)) {
		query["CustomJobName"] = request.CustomJobName
	}

	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigYaml)) {
		body["ConfigYaml"] = request.ConfigYaml
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateEnvCustomJob"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateEnvCustomJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateEnvCustomJob(request *UpdateEnvCustomJobRequest) (_result *UpdateEnvCustomJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateEnvCustomJobResponse{}
	_body, _err := client.UpdateEnvCustomJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateEnvPodMonitorWithOptions(request *UpdateEnvPodMonitorRequest, runtime *util.RuntimeOptions) (_result *UpdateEnvPodMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliyunLang)) {
		query["AliyunLang"] = request.AliyunLang
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.PodMonitorName)) {
		query["PodMonitorName"] = request.PodMonitorName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigYaml)) {
		body["ConfigYaml"] = request.ConfigYaml
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateEnvPodMonitor"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateEnvPodMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateEnvPodMonitor(request *UpdateEnvPodMonitorRequest) (_result *UpdateEnvPodMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateEnvPodMonitorResponse{}
	_body, _err := client.UpdateEnvPodMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateEnvServiceMonitorWithOptions(request *UpdateEnvServiceMonitorRequest, runtime *util.RuntimeOptions) (_result *UpdateEnvServiceMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliyunLang)) {
		query["AliyunLang"] = request.AliyunLang
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceMonitorName)) {
		query["ServiceMonitorName"] = request.ServiceMonitorName
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigYaml)) {
		body["ConfigYaml"] = request.ConfigYaml
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateEnvServiceMonitor"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateEnvServiceMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateEnvServiceMonitor(request *UpdateEnvServiceMonitorRequest) (_result *UpdateEnvServiceMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateEnvServiceMonitorResponse{}
	_body, _err := client.UpdateEnvServiceMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateEnvironmentWithOptions(request *UpdateEnvironmentRequest, runtime *util.RuntimeOptions) (_result *UpdateEnvironmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliyunLang)) {
		query["AliyunLang"] = request.AliyunLang
	}

	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.EnvironmentName)) {
		query["EnvironmentName"] = request.EnvironmentName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateEnvironment"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateEnvironmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateEnvironment(request *UpdateEnvironmentRequest) (_result *UpdateEnvironmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateEnvironmentResponse{}
	_body, _err := client.UpdateEnvironmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGrafanaWorkspaceWithOptions(request *UpdateGrafanaWorkspaceRequest, runtime *util.RuntimeOptions) (_result *UpdateGrafanaWorkspaceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliyunLang)) {
		query["AliyunLang"] = request.AliyunLang
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.GrafanaWorkspaceId)) {
		query["GrafanaWorkspaceId"] = request.GrafanaWorkspaceId
	}

	if !tea.BoolValue(util.IsUnset(request.GrafanaWorkspaceName)) {
		query["GrafanaWorkspaceName"] = request.GrafanaWorkspaceName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGrafanaWorkspace"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGrafanaWorkspaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGrafanaWorkspace(request *UpdateGrafanaWorkspaceRequest) (_result *UpdateGrafanaWorkspaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGrafanaWorkspaceResponse{}
	_body, _err := client.UpdateGrafanaWorkspaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGrafanaWorkspaceVersionWithOptions(request *UpdateGrafanaWorkspaceVersionRequest, runtime *util.RuntimeOptions) (_result *UpdateGrafanaWorkspaceVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliyunLang)) {
		query["AliyunLang"] = request.AliyunLang
	}

	if !tea.BoolValue(util.IsUnset(request.GrafanaVersion)) {
		query["GrafanaVersion"] = request.GrafanaVersion
	}

	if !tea.BoolValue(util.IsUnset(request.GrafanaWorkspaceId)) {
		query["GrafanaWorkspaceId"] = request.GrafanaWorkspaceId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGrafanaWorkspaceVersion"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGrafanaWorkspaceVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGrafanaWorkspaceVersion(request *UpdateGrafanaWorkspaceVersionRequest) (_result *UpdateGrafanaWorkspaceVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGrafanaWorkspaceVersionResponse{}
	_body, _err := client.UpdateGrafanaWorkspaceVersionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateIntegrationWithOptions(request *UpdateIntegrationRequest, runtime *util.RuntimeOptions) (_result *UpdateIntegrationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoRecover)) {
		body["AutoRecover"] = request.AutoRecover
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DuplicateKey)) {
		body["DuplicateKey"] = request.DuplicateKey
	}

	if !tea.BoolValue(util.IsUnset(request.ExtendedFieldRedefineRules)) {
		body["ExtendedFieldRedefineRules"] = request.ExtendedFieldRedefineRules
	}

	if !tea.BoolValue(util.IsUnset(request.FieldRedefineRules)) {
		body["FieldRedefineRules"] = request.FieldRedefineRules
	}

	if !tea.BoolValue(util.IsUnset(request.InitiativeRecoverField)) {
		body["InitiativeRecoverField"] = request.InitiativeRecoverField
	}

	if !tea.BoolValue(util.IsUnset(request.InitiativeRecoverValue)) {
		body["InitiativeRecoverValue"] = request.InitiativeRecoverValue
	}

	if !tea.BoolValue(util.IsUnset(request.IntegrationId)) {
		body["IntegrationId"] = request.IntegrationId
	}

	if !tea.BoolValue(util.IsUnset(request.IntegrationName)) {
		body["IntegrationName"] = request.IntegrationName
	}

	if !tea.BoolValue(util.IsUnset(request.IntegrationProductType)) {
		body["IntegrationProductType"] = request.IntegrationProductType
	}

	if !tea.BoolValue(util.IsUnset(request.Liveness)) {
		body["Liveness"] = request.Liveness
	}

	if !tea.BoolValue(util.IsUnset(request.RecoverTime)) {
		body["RecoverTime"] = request.RecoverTime
	}

	if !tea.BoolValue(util.IsUnset(request.Stat)) {
		body["Stat"] = request.Stat
	}

	if !tea.BoolValue(util.IsUnset(request.State)) {
		body["State"] = request.State
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateIntegration"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateIntegrationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateIntegration(request *UpdateIntegrationRequest) (_result *UpdateIntegrationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateIntegrationResponse{}
	_body, _err := client.UpdateIntegrationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateMetricDropWithOptions(request *UpdateMetricDropRequest, runtime *util.RuntimeOptions) (_result *UpdateMetricDropResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.MetricDrop)) {
		query["MetricDrop"] = request.MetricDrop
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateMetricDrop"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateMetricDropResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateMetricDrop(request *UpdateMetricDropRequest) (_result *UpdateMetricDropResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateMetricDropResponse{}
	_body, _err := client.UpdateMetricDropWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdatePrometheusAlertRuleWithOptions(request *UpdatePrometheusAlertRuleRequest, runtime *util.RuntimeOptions) (_result *UpdatePrometheusAlertRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertId)) {
		query["AlertId"] = request.AlertId
	}

	if !tea.BoolValue(util.IsUnset(request.AlertName)) {
		query["AlertName"] = request.AlertName
	}

	if !tea.BoolValue(util.IsUnset(request.Annotations)) {
		query["Annotations"] = request.Annotations
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.DispatchRuleId)) {
		query["DispatchRuleId"] = request.DispatchRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.Duration)) {
		query["Duration"] = request.Duration
	}

	if !tea.BoolValue(util.IsUnset(request.Expression)) {
		query["Expression"] = request.Expression
	}

	if !tea.BoolValue(util.IsUnset(request.Labels)) {
		query["Labels"] = request.Labels
	}

	if !tea.BoolValue(util.IsUnset(request.Message)) {
		query["Message"] = request.Message
	}

	if !tea.BoolValue(util.IsUnset(request.NotifyType)) {
		query["NotifyType"] = request.NotifyType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdatePrometheusAlertRule"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdatePrometheusAlertRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdatePrometheusAlertRule(request *UpdatePrometheusAlertRuleRequest) (_result *UpdatePrometheusAlertRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdatePrometheusAlertRuleResponse{}
	_body, _err := client.UpdatePrometheusAlertRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdatePrometheusGlobalViewWithOptions(request *UpdatePrometheusGlobalViewRequest, runtime *util.RuntimeOptions) (_result *UpdatePrometheusGlobalViewResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AllSubClustersSuccess)) {
		query["AllSubClustersSuccess"] = request.AllSubClustersSuccess
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.MostRegionId)) {
		query["MostRegionId"] = request.MostRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SubClustersJson)) {
		query["SubClustersJson"] = request.SubClustersJson
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdatePrometheusGlobalView"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdatePrometheusGlobalViewResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdatePrometheusGlobalView(request *UpdatePrometheusGlobalViewRequest) (_result *UpdatePrometheusGlobalViewResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdatePrometheusGlobalViewResponse{}
	_body, _err := client.UpdatePrometheusGlobalViewWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdatePrometheusIntegrationWithOptions(request *UpdatePrometheusIntegrationRequest, runtime *util.RuntimeOptions) (_result *UpdatePrometheusIntegrationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IntegrationType)) {
		query["IntegrationType"] = request.IntegrationType
	}

	if !tea.BoolValue(util.IsUnset(request.Param)) {
		query["Param"] = request.Param
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdatePrometheusIntegration"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdatePrometheusIntegrationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdatePrometheusIntegration(request *UpdatePrometheusIntegrationRequest) (_result *UpdatePrometheusIntegrationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdatePrometheusIntegrationResponse{}
	_body, _err := client.UpdatePrometheusIntegrationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdatePrometheusMonitoringWithOptions(request *UpdatePrometheusMonitoringRequest, runtime *util.RuntimeOptions) (_result *UpdatePrometheusMonitoringResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.MonitoringName)) {
		query["MonitoringName"] = request.MonitoringName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigYaml)) {
		body["ConfigYaml"] = request.ConfigYaml
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdatePrometheusMonitoring"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdatePrometheusMonitoringResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdatePrometheusMonitoring(request *UpdatePrometheusMonitoringRequest) (_result *UpdatePrometheusMonitoringResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdatePrometheusMonitoringResponse{}
	_body, _err := client.UpdatePrometheusMonitoringWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdatePrometheusMonitoringStatusWithOptions(request *UpdatePrometheusMonitoringStatusRequest, runtime *util.RuntimeOptions) (_result *UpdatePrometheusMonitoringStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.MonitoringName)) {
		query["MonitoringName"] = request.MonitoringName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdatePrometheusMonitoringStatus"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdatePrometheusMonitoringStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdatePrometheusMonitoringStatus(request *UpdatePrometheusMonitoringStatusRequest) (_result *UpdatePrometheusMonitoringStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdatePrometheusMonitoringStatusResponse{}
	_body, _err := client.UpdatePrometheusMonitoringStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdatePrometheusRemoteWriteWithOptions(request *UpdatePrometheusRemoteWriteRequest, runtime *util.RuntimeOptions) (_result *UpdatePrometheusRemoteWriteResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RemoteWriteName)) {
		query["RemoteWriteName"] = request.RemoteWriteName
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RemoteWriteYaml)) {
		body["RemoteWriteYaml"] = request.RemoteWriteYaml
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdatePrometheusRemoteWrite"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdatePrometheusRemoteWriteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdatePrometheusRemoteWrite(request *UpdatePrometheusRemoteWriteRequest) (_result *UpdatePrometheusRemoteWriteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdatePrometheusRemoteWriteResponse{}
	_body, _err := client.UpdatePrometheusRemoteWriteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateTimingSyntheticTaskWithOptions(tmpReq *UpdateTimingSyntheticTaskRequest, runtime *util.RuntimeOptions) (_result *UpdateTimingSyntheticTaskResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateTimingSyntheticTaskShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.AvailableAssertions)) {
		request.AvailableAssertionsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.AvailableAssertions, tea.String("AvailableAssertions"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.CommonSetting)) {
		request.CommonSettingShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.CommonSetting, tea.String("CommonSetting"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.CustomPeriod)) {
		request.CustomPeriodShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.CustomPeriod, tea.String("CustomPeriod"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.MonitorConf)) {
		request.MonitorConfShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.MonitorConf, tea.String("MonitorConf"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.Monitors)) {
		request.MonitorsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Monitors, tea.String("Monitors"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.Tags)) {
		request.TagsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Tags, tea.String("Tags"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AvailableAssertionsShrink)) {
		query["AvailableAssertions"] = request.AvailableAssertionsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.CommonSettingShrink)) {
		query["CommonSetting"] = request.CommonSettingShrink
	}

	if !tea.BoolValue(util.IsUnset(request.CustomPeriodShrink)) {
		query["CustomPeriod"] = request.CustomPeriodShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Frequency)) {
		query["Frequency"] = request.Frequency
	}

	if !tea.BoolValue(util.IsUnset(request.MonitorConfShrink)) {
		query["MonitorConf"] = request.MonitorConfShrink
	}

	if !tea.BoolValue(util.IsUnset(request.MonitorsShrink)) {
		query["Monitors"] = request.MonitorsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.TagsShrink)) {
		query["Tags"] = request.TagsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTimingSyntheticTask"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTimingSyntheticTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateTimingSyntheticTask(request *UpdateTimingSyntheticTaskRequest) (_result *UpdateTimingSyntheticTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTimingSyntheticTaskResponse{}
	_body, _err := client.UpdateTimingSyntheticTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is no longer maintained. Call the CreateOrUpdateWebhookContact operation in the new alter management module to create or modify a webhook alert contact.
 *
 * @param request UpdateWebhookRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateWebhookResponse
 */
func (client *Client) UpdateWebhookWithOptions(request *UpdateWebhookRequest, runtime *util.RuntimeOptions) (_result *UpdateWebhookResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Body)) {
		query["Body"] = request.Body
	}

	if !tea.BoolValue(util.IsUnset(request.ContactId)) {
		query["ContactId"] = request.ContactId
	}

	if !tea.BoolValue(util.IsUnset(request.ContactName)) {
		query["ContactName"] = request.ContactName
	}

	if !tea.BoolValue(util.IsUnset(request.HttpHeaders)) {
		query["HttpHeaders"] = request.HttpHeaders
	}

	if !tea.BoolValue(util.IsUnset(request.HttpParams)) {
		query["HttpParams"] = request.HttpParams
	}

	if !tea.BoolValue(util.IsUnset(request.Method)) {
		query["Method"] = request.Method
	}

	if !tea.BoolValue(util.IsUnset(request.RecoverBody)) {
		query["RecoverBody"] = request.RecoverBody
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Url)) {
		query["Url"] = request.Url
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateWebhook"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateWebhookResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is no longer maintained. Call the CreateOrUpdateWebhookContact operation in the new alter management module to create or modify a webhook alert contact.
 *
 * @param request UpdateWebhookRequest
 * @return UpdateWebhookResponse
 */
func (client *Client) UpdateWebhook(request *UpdateWebhookRequest) (_result *UpdateWebhookResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateWebhookResponse{}
	_body, _err := client.UpdateWebhookWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpgradeAddonReleaseWithOptions(request *UpgradeAddonReleaseRequest, runtime *util.RuntimeOptions) (_result *UpgradeAddonReleaseResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AddonVersion)) {
		query["AddonVersion"] = request.AddonVersion
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ReleaseName)) {
		query["ReleaseName"] = request.ReleaseName
	}

	if !tea.BoolValue(util.IsUnset(request.Values)) {
		query["Values"] = request.Values
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpgradeAddonRelease"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpgradeAddonReleaseResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpgradeAddonRelease(request *UpgradeAddonReleaseRequest) (_result *UpgradeAddonReleaseResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpgradeAddonReleaseResponse{}
	_body, _err := client.UpgradeAddonReleaseWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpgradeEnvironmentFeatureWithOptions(request *UpgradeEnvironmentFeatureRequest, runtime *util.RuntimeOptions) (_result *UpgradeEnvironmentFeatureResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliyunLang)) {
		query["AliyunLang"] = request.AliyunLang
	}

	if !tea.BoolValue(util.IsUnset(request.EnvironmentId)) {
		query["EnvironmentId"] = request.EnvironmentId
	}

	if !tea.BoolValue(util.IsUnset(request.FeatureName)) {
		query["FeatureName"] = request.FeatureName
	}

	if !tea.BoolValue(util.IsUnset(request.FeatureVersion)) {
		query["FeatureVersion"] = request.FeatureVersion
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Values)) {
		query["Values"] = request.Values
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpgradeEnvironmentFeature"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpgradeEnvironmentFeatureResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpgradeEnvironmentFeature(request *UpgradeEnvironmentFeatureRequest) (_result *UpgradeEnvironmentFeatureResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpgradeEnvironmentFeatureResponse{}
	_body, _err := client.UpgradeEnvironmentFeatureWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UploadWithOptions(request *UploadRequest, runtime *util.RuntimeOptions) (_result *UploadResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Edition)) {
		query["Edition"] = request.Edition
	}

	if !tea.BoolValue(util.IsUnset(request.FileName)) {
		query["FileName"] = request.FileName
	}

	if !tea.BoolValue(util.IsUnset(request.Pid)) {
		query["Pid"] = request.Pid
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Version)) {
		query["Version"] = request.Version
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.File)) {
		body["File"] = request.File
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("Upload"),
		Version:     tea.String("2019-08-08"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UploadResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) Upload(request *UploadRequest) (_result *UploadResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UploadResponse{}
	_body, _err := client.UploadWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
