// This file is auto-generated, don't edit it. Thanks.
/**
 *
 */
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	endpointutil "github.com/alibabacloud-go/endpoint-util/service"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
)

type AttachAlbServerGroupsRequest struct {
	// Details of the ALB server group.
	AlbServerGroups []*AttachAlbServerGroupsRequestAlbServerGroups `json:"AlbServerGroups,omitempty" xml:"AlbServerGroups,omitempty" type:"Repeated"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request](~~25965~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to add the ECS instances in the scaling group to the ALB server group. Valid values:
	//
	// *   true: adds the ECS instances to the ALB server group and returns the value of the `ScalingActivityId` parameter. You can check whether the ECS instances are added to the ALB server group by using the ID of the scaling activity.
	// *   false: does not add the ECS instances to the ALB server group.
	//
	// Default value: false.
	ForceAttach *bool  `json:"ForceAttach,omitempty" xml:"ForceAttach,omitempty"`
	OwnerId     *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group, such as cn-hangzhou and cn-shanghai. For more information, see [Regions and zones](~~40654~~).
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s AttachAlbServerGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachAlbServerGroupsRequest) GoString() string {
	return s.String()
}

func (s *AttachAlbServerGroupsRequest) SetAlbServerGroups(v []*AttachAlbServerGroupsRequestAlbServerGroups) *AttachAlbServerGroupsRequest {
	s.AlbServerGroups = v
	return s
}

func (s *AttachAlbServerGroupsRequest) SetClientToken(v string) *AttachAlbServerGroupsRequest {
	s.ClientToken = &v
	return s
}

func (s *AttachAlbServerGroupsRequest) SetForceAttach(v bool) *AttachAlbServerGroupsRequest {
	s.ForceAttach = &v
	return s
}

func (s *AttachAlbServerGroupsRequest) SetOwnerId(v int64) *AttachAlbServerGroupsRequest {
	s.OwnerId = &v
	return s
}

func (s *AttachAlbServerGroupsRequest) SetRegionId(v string) *AttachAlbServerGroupsRequest {
	s.RegionId = &v
	return s
}

func (s *AttachAlbServerGroupsRequest) SetResourceOwnerAccount(v string) *AttachAlbServerGroupsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AttachAlbServerGroupsRequest) SetScalingGroupId(v string) *AttachAlbServerGroupsRequest {
	s.ScalingGroupId = &v
	return s
}

type AttachAlbServerGroupsRequestAlbServerGroups struct {
	// The ID of the ALB server group.
	//
	// You can associate only a limited number of ALB server groups with a scaling group. To view the quota or manually request a quota increase, go to [Quota Center](https://quotas.console.aliyun.com/products/ess/quotas).
	AlbServerGroupId *string `json:"AlbServerGroupId,omitempty" xml:"AlbServerGroupId,omitempty"`
	// The port number used by the ECS instance after the ECS instance is added to the ALB server group. Valid values: 1 to 65535.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The weight of the ECS instance as a backend server after the instance is added to the ALB server group.
	//
	// If you increase the weight of an ECS instance in an ALB server group, the number of access requests that are forwarded to the ECS instance increases. If you set the Weight parameter for an ECS instance to 0, no access requests are forwarded to the ECS instance. Valid values: 0 to 100.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s AttachAlbServerGroupsRequestAlbServerGroups) String() string {
	return tea.Prettify(s)
}

func (s AttachAlbServerGroupsRequestAlbServerGroups) GoString() string {
	return s.String()
}

func (s *AttachAlbServerGroupsRequestAlbServerGroups) SetAlbServerGroupId(v string) *AttachAlbServerGroupsRequestAlbServerGroups {
	s.AlbServerGroupId = &v
	return s
}

func (s *AttachAlbServerGroupsRequestAlbServerGroups) SetPort(v int32) *AttachAlbServerGroupsRequestAlbServerGroups {
	s.Port = &v
	return s
}

func (s *AttachAlbServerGroupsRequestAlbServerGroups) SetWeight(v int32) *AttachAlbServerGroupsRequestAlbServerGroups {
	s.Weight = &v
	return s
}

type AttachAlbServerGroupsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the scaling activity in which Auto Scaling associates the ALB server group with the scaling group and adds ECS instances in the scaling group to the ALB server group. This parameter is returned only if you set the `ForceAttach` parameter to `true`.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s AttachAlbServerGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachAlbServerGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *AttachAlbServerGroupsResponseBody) SetRequestId(v string) *AttachAlbServerGroupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *AttachAlbServerGroupsResponseBody) SetScalingActivityId(v string) *AttachAlbServerGroupsResponseBody {
	s.ScalingActivityId = &v
	return s
}

type AttachAlbServerGroupsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachAlbServerGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachAlbServerGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachAlbServerGroupsResponse) GoString() string {
	return s.String()
}

func (s *AttachAlbServerGroupsResponse) SetHeaders(v map[string]*string) *AttachAlbServerGroupsResponse {
	s.Headers = v
	return s
}

func (s *AttachAlbServerGroupsResponse) SetStatusCode(v int32) *AttachAlbServerGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachAlbServerGroupsResponse) SetBody(v *AttachAlbServerGroupsResponseBody) *AttachAlbServerGroupsResponse {
	s.Body = v
	return s
}

type AttachDBInstancesRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.
	//
	// The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request](~~25965~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the ApsaraDB RDS instance.
	DBInstances []*string `json:"DBInstances,omitempty" xml:"DBInstances,omitempty" type:"Repeated"`
	// Specifies whether to add the private IP addresses of all instances in the scaling group to the IP address whitelist of the ApsaraDB RDS instance. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	ForceAttach *bool  `json:"ForceAttach,omitempty" xml:"ForceAttach,omitempty"`
	OwnerId     *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s AttachDBInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachDBInstancesRequest) GoString() string {
	return s.String()
}

func (s *AttachDBInstancesRequest) SetClientToken(v string) *AttachDBInstancesRequest {
	s.ClientToken = &v
	return s
}

func (s *AttachDBInstancesRequest) SetDBInstances(v []*string) *AttachDBInstancesRequest {
	s.DBInstances = v
	return s
}

func (s *AttachDBInstancesRequest) SetForceAttach(v bool) *AttachDBInstancesRequest {
	s.ForceAttach = &v
	return s
}

func (s *AttachDBInstancesRequest) SetOwnerId(v int64) *AttachDBInstancesRequest {
	s.OwnerId = &v
	return s
}

func (s *AttachDBInstancesRequest) SetRegionId(v string) *AttachDBInstancesRequest {
	s.RegionId = &v
	return s
}

func (s *AttachDBInstancesRequest) SetResourceOwnerAccount(v string) *AttachDBInstancesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AttachDBInstancesRequest) SetScalingGroupId(v string) *AttachDBInstancesRequest {
	s.ScalingGroupId = &v
	return s
}

type AttachDBInstancesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AttachDBInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachDBInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *AttachDBInstancesResponseBody) SetRequestId(v string) *AttachDBInstancesResponseBody {
	s.RequestId = &v
	return s
}

type AttachDBInstancesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachDBInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachDBInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachDBInstancesResponse) GoString() string {
	return s.String()
}

func (s *AttachDBInstancesResponse) SetHeaders(v map[string]*string) *AttachDBInstancesResponse {
	s.Headers = v
	return s
}

func (s *AttachDBInstancesResponse) SetStatusCode(v int32) *AttachDBInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachDBInstancesResponse) SetBody(v *AttachDBInstancesResponseBody) *AttachDBInstancesResponse {
	s.Body = v
	return s
}

type AttachInstancesRequest struct {
	// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25965~~)。
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether the scaling group manages the lifecycles of instances that are manually added to the scaling group. Valid values:
	//
	// *   true: The scaling group manages the lifecycles of instances that are manually added in a similar manner in which the scaling group manages the lifecycles of automatically created instances. After Auto Scaling removes instances from the scaling group, Auto Scaling releases the instances. After you call the DetachInstances operation to remove instances from the scaling group, Auto Scaling does not release the instances.
	// *   false: The scaling group does not manage the lifecycles of instances that are manually added. After Auto Scaling removes instances from the scaling group, Auto Scaling does not release the instances.
	//
	// > You cannot specify this parameter for subscription instances.
	//
	// Default value: false.
	Entrusted *bool `json:"Entrusted,omitempty" xml:"Entrusted,omitempty"`
	// The IDs of the ECS instances or elastic container instances that you want to add.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// Specifies whether to trigger a lifecycle hook for a scale-out activity. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	LifecycleHook *bool `json:"LifecycleHook,omitempty" xml:"LifecycleHook,omitempty"`
	// The weights of the ECS instances or elastic container instances as the backend servers of the associated Classic Load Balancer (CLB) instance.
	LoadBalancerWeights []*int32 `json:"LoadBalancerWeights,omitempty" xml:"LoadBalancerWeights,omitempty" type:"Repeated"`
	OwnerAccount        *string  `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId             *int64   `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s AttachInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachInstancesRequest) GoString() string {
	return s.String()
}

func (s *AttachInstancesRequest) SetClientToken(v string) *AttachInstancesRequest {
	s.ClientToken = &v
	return s
}

func (s *AttachInstancesRequest) SetEntrusted(v bool) *AttachInstancesRequest {
	s.Entrusted = &v
	return s
}

func (s *AttachInstancesRequest) SetInstanceIds(v []*string) *AttachInstancesRequest {
	s.InstanceIds = v
	return s
}

func (s *AttachInstancesRequest) SetLifecycleHook(v bool) *AttachInstancesRequest {
	s.LifecycleHook = &v
	return s
}

func (s *AttachInstancesRequest) SetLoadBalancerWeights(v []*int32) *AttachInstancesRequest {
	s.LoadBalancerWeights = v
	return s
}

func (s *AttachInstancesRequest) SetOwnerAccount(v string) *AttachInstancesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AttachInstancesRequest) SetOwnerId(v int64) *AttachInstancesRequest {
	s.OwnerId = &v
	return s
}

func (s *AttachInstancesRequest) SetRegionId(v string) *AttachInstancesRequest {
	s.RegionId = &v
	return s
}

func (s *AttachInstancesRequest) SetResourceOwnerAccount(v string) *AttachInstancesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AttachInstancesRequest) SetResourceOwnerId(v int64) *AttachInstancesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AttachInstancesRequest) SetScalingGroupId(v string) *AttachInstancesRequest {
	s.ScalingGroupId = &v
	return s
}

type AttachInstancesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the scaling activity.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s AttachInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *AttachInstancesResponseBody) SetRequestId(v string) *AttachInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *AttachInstancesResponseBody) SetScalingActivityId(v string) *AttachInstancesResponseBody {
	s.ScalingActivityId = &v
	return s
}

type AttachInstancesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachInstancesResponse) GoString() string {
	return s.String()
}

func (s *AttachInstancesResponse) SetHeaders(v map[string]*string) *AttachInstancesResponse {
	s.Headers = v
	return s
}

func (s *AttachInstancesResponse) SetStatusCode(v int32) *AttachInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachInstancesResponse) SetBody(v *AttachInstancesResponseBody) *AttachInstancesResponse {
	s.Body = v
	return s
}

type AttachLoadBalancersRequest struct {
	// Specifies whether to attach the CLB instance to the scaling group in an asynchronous manner. If you attach the CLB instance from the scaling group in an asynchronous manner, the call is successful only after all operations are successful. If a specific operation fails, the call fails. We recommend that you set this parameter to true. Valid values:
	//
	// *   true: attaches the CLB instance to the scaling group in an asynchronous manner. In this case, the ID of the scaling activity is returned.
	// *   false: does not attach the CLB instance to the scaling group in an asynchronous manner.
	//
	// Default value: false.
	Async *bool `json:"Async,omitempty" xml:"Async,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to add all instances in the scaling group to the vServer groups of the CLB instance. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	ForceAttach *bool `json:"ForceAttach,omitempty" xml:"ForceAttach,omitempty"`
	// 负载均衡配置列表。
	LoadBalancerConfigs []*AttachLoadBalancersRequestLoadBalancerConfigs `json:"LoadBalancerConfigs,omitempty" xml:"LoadBalancerConfigs,omitempty" type:"Repeated"`
	// The IDs of the CLB instances.
	LoadBalancers        []*string `json:"LoadBalancers,omitempty" xml:"LoadBalancers,omitempty" type:"Repeated"`
	OwnerId              *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s AttachLoadBalancersRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachLoadBalancersRequest) GoString() string {
	return s.String()
}

func (s *AttachLoadBalancersRequest) SetAsync(v bool) *AttachLoadBalancersRequest {
	s.Async = &v
	return s
}

func (s *AttachLoadBalancersRequest) SetClientToken(v string) *AttachLoadBalancersRequest {
	s.ClientToken = &v
	return s
}

func (s *AttachLoadBalancersRequest) SetForceAttach(v bool) *AttachLoadBalancersRequest {
	s.ForceAttach = &v
	return s
}

func (s *AttachLoadBalancersRequest) SetLoadBalancerConfigs(v []*AttachLoadBalancersRequestLoadBalancerConfigs) *AttachLoadBalancersRequest {
	s.LoadBalancerConfigs = v
	return s
}

func (s *AttachLoadBalancersRequest) SetLoadBalancers(v []*string) *AttachLoadBalancersRequest {
	s.LoadBalancers = v
	return s
}

func (s *AttachLoadBalancersRequest) SetOwnerId(v int64) *AttachLoadBalancersRequest {
	s.OwnerId = &v
	return s
}

func (s *AttachLoadBalancersRequest) SetResourceOwnerAccount(v string) *AttachLoadBalancersRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AttachLoadBalancersRequest) SetScalingGroupId(v string) *AttachLoadBalancersRequest {
	s.ScalingGroupId = &v
	return s
}

type AttachLoadBalancersRequestLoadBalancerConfigs struct {
	// 负载均衡CLB（原SLB）实例的ID。
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// 弹性伸缩将ECS实例添加到SLB服务器组后，ECS实例作为后端服务器的权重。权重越高，ECS实例将被分配到越多的访问请求。如果权重为0，则ECS实例不会收到访问请求。取值范围：0~100。
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s AttachLoadBalancersRequestLoadBalancerConfigs) String() string {
	return tea.Prettify(s)
}

func (s AttachLoadBalancersRequestLoadBalancerConfigs) GoString() string {
	return s.String()
}

func (s *AttachLoadBalancersRequestLoadBalancerConfigs) SetLoadBalancerId(v string) *AttachLoadBalancersRequestLoadBalancerConfigs {
	s.LoadBalancerId = &v
	return s
}

func (s *AttachLoadBalancersRequestLoadBalancerConfigs) SetWeight(v int32) *AttachLoadBalancersRequestLoadBalancerConfigs {
	s.Weight = &v
	return s
}

type AttachLoadBalancersResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the scaling activity.
	//
	// The value of this parameter is returned only after you set the Async parameter to true. You can call the DescribeScalingActivities operation to query all scaling activity IDs and use the scaling activity IDs to check the status of the scaling activities.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s AttachLoadBalancersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachLoadBalancersResponseBody) GoString() string {
	return s.String()
}

func (s *AttachLoadBalancersResponseBody) SetRequestId(v string) *AttachLoadBalancersResponseBody {
	s.RequestId = &v
	return s
}

func (s *AttachLoadBalancersResponseBody) SetScalingActivityId(v string) *AttachLoadBalancersResponseBody {
	s.ScalingActivityId = &v
	return s
}

type AttachLoadBalancersResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachLoadBalancersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachLoadBalancersResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachLoadBalancersResponse) GoString() string {
	return s.String()
}

func (s *AttachLoadBalancersResponse) SetHeaders(v map[string]*string) *AttachLoadBalancersResponse {
	s.Headers = v
	return s
}

func (s *AttachLoadBalancersResponse) SetStatusCode(v int32) *AttachLoadBalancersResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachLoadBalancersResponse) SetBody(v *AttachLoadBalancersResponseBody) *AttachLoadBalancersResponse {
	s.Body = v
	return s
}

type AttachServerGroupsRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [Ensure idempotence](~~25965~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to add the Elastic Compute Service (ECS) instances in the scaling group to the new server group.
	//
	// *   true
	// *   false
	//
	// Default value: false.
	ForceAttach *bool  `json:"ForceAttach,omitempty" xml:"ForceAttach,omitempty"`
	OwnerId     *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// Details of the server groups.
	ServerGroups []*AttachServerGroupsRequestServerGroups `json:"ServerGroups,omitempty" xml:"ServerGroups,omitempty" type:"Repeated"`
}

func (s AttachServerGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachServerGroupsRequest) GoString() string {
	return s.String()
}

func (s *AttachServerGroupsRequest) SetClientToken(v string) *AttachServerGroupsRequest {
	s.ClientToken = &v
	return s
}

func (s *AttachServerGroupsRequest) SetForceAttach(v bool) *AttachServerGroupsRequest {
	s.ForceAttach = &v
	return s
}

func (s *AttachServerGroupsRequest) SetOwnerId(v int64) *AttachServerGroupsRequest {
	s.OwnerId = &v
	return s
}

func (s *AttachServerGroupsRequest) SetRegionId(v string) *AttachServerGroupsRequest {
	s.RegionId = &v
	return s
}

func (s *AttachServerGroupsRequest) SetResourceOwnerAccount(v string) *AttachServerGroupsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AttachServerGroupsRequest) SetScalingGroupId(v string) *AttachServerGroupsRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *AttachServerGroupsRequest) SetServerGroups(v []*AttachServerGroupsRequestServerGroups) *AttachServerGroupsRequest {
	s.ServerGroups = v
	return s
}

type AttachServerGroupsRequestServerGroups struct {
	// The port number that is used by an ECS instance after Auto Scaling adds the ECS instance to the server group. Valid values: 1 to 65535.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The ID of the server group.
	ServerGroupId *string `json:"ServerGroupId,omitempty" xml:"ServerGroupId,omitempty"`
	// The type of the server group. Valid values:
	//
	// *   ALB
	// *   NLB
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The weight of an ECS instance after Auto Scaling adds the ECS instance to the server group as a backend server.
	//
	// A higher weight specifies that a larger number of requests are forwarded to the ECS instance. If you set the Weight parameter for an ECS instance in the server group to 0, no access requests are forwarded to the ECS instance. Valid values: 0 to 100.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s AttachServerGroupsRequestServerGroups) String() string {
	return tea.Prettify(s)
}

func (s AttachServerGroupsRequestServerGroups) GoString() string {
	return s.String()
}

func (s *AttachServerGroupsRequestServerGroups) SetPort(v int32) *AttachServerGroupsRequestServerGroups {
	s.Port = &v
	return s
}

func (s *AttachServerGroupsRequestServerGroups) SetServerGroupId(v string) *AttachServerGroupsRequestServerGroups {
	s.ServerGroupId = &v
	return s
}

func (s *AttachServerGroupsRequestServerGroups) SetType(v string) *AttachServerGroupsRequestServerGroups {
	s.Type = &v
	return s
}

func (s *AttachServerGroupsRequestServerGroups) SetWeight(v int32) *AttachServerGroupsRequestServerGroups {
	s.Weight = &v
	return s
}

type AttachServerGroupsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the scaling activity in which you attach the server group to the scaling group and Auto Scaling adds the ECS instances in the scaling group to the server group.
	//
	// > This parameter is returned only if you set the ForceAttach parameter to true.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s AttachServerGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachServerGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *AttachServerGroupsResponseBody) SetRequestId(v string) *AttachServerGroupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *AttachServerGroupsResponseBody) SetScalingActivityId(v string) *AttachServerGroupsResponseBody {
	s.ScalingActivityId = &v
	return s
}

type AttachServerGroupsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachServerGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachServerGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachServerGroupsResponse) GoString() string {
	return s.String()
}

func (s *AttachServerGroupsResponse) SetHeaders(v map[string]*string) *AttachServerGroupsResponse {
	s.Headers = v
	return s
}

func (s *AttachServerGroupsResponse) SetStatusCode(v int32) *AttachServerGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachServerGroupsResponse) SetBody(v *AttachServerGroupsResponseBody) *AttachServerGroupsResponse {
	s.Body = v
	return s
}

type AttachVServerGroupsRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request](~~25965~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to add Elastic Compute Service (ECS) instances in the scaling group to the vServer group. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	ForceAttach *bool  `json:"ForceAttach,omitempty" xml:"ForceAttach,omitempty"`
	OwnerId     *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group. Examples: cn-hangzhou and cn-shanghai.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// Details of the vServer groups.
	VServerGroups []*AttachVServerGroupsRequestVServerGroups `json:"VServerGroups,omitempty" xml:"VServerGroups,omitempty" type:"Repeated"`
}

func (s AttachVServerGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachVServerGroupsRequest) GoString() string {
	return s.String()
}

func (s *AttachVServerGroupsRequest) SetClientToken(v string) *AttachVServerGroupsRequest {
	s.ClientToken = &v
	return s
}

func (s *AttachVServerGroupsRequest) SetForceAttach(v bool) *AttachVServerGroupsRequest {
	s.ForceAttach = &v
	return s
}

func (s *AttachVServerGroupsRequest) SetOwnerId(v int64) *AttachVServerGroupsRequest {
	s.OwnerId = &v
	return s
}

func (s *AttachVServerGroupsRequest) SetRegionId(v string) *AttachVServerGroupsRequest {
	s.RegionId = &v
	return s
}

func (s *AttachVServerGroupsRequest) SetResourceOwnerAccount(v string) *AttachVServerGroupsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AttachVServerGroupsRequest) SetScalingGroupId(v string) *AttachVServerGroupsRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *AttachVServerGroupsRequest) SetVServerGroups(v []*AttachVServerGroupsRequestVServerGroups) *AttachVServerGroupsRequest {
	s.VServerGroups = v
	return s
}

type AttachVServerGroupsRequestVServerGroups struct {
	// The ID of the CLB instance to which the vServer group belongs.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// Details of the vServer group attributes.
	VServerGroupAttributes []*AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes `json:"VServerGroupAttributes,omitempty" xml:"VServerGroupAttributes,omitempty" type:"Repeated"`
}

func (s AttachVServerGroupsRequestVServerGroups) String() string {
	return tea.Prettify(s)
}

func (s AttachVServerGroupsRequestVServerGroups) GoString() string {
	return s.String()
}

func (s *AttachVServerGroupsRequestVServerGroups) SetLoadBalancerId(v string) *AttachVServerGroupsRequestVServerGroups {
	s.LoadBalancerId = &v
	return s
}

func (s *AttachVServerGroupsRequestVServerGroups) SetVServerGroupAttributes(v []*AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes) *AttachVServerGroupsRequestVServerGroups {
	s.VServerGroupAttributes = v
	return s
}

type AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes struct {
	// The port number that is used when Auto Scaling adds ECS instances to the vServer group. Valid values: 1 to 65535.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The ID of the vServer group.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	// The weight of an ECS instance as a backend server in the vServer group. Valid values: 0 to 100.
	//
	// Default value: 50.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes) String() string {
	return tea.Prettify(s)
}

func (s AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes) GoString() string {
	return s.String()
}

func (s *AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes) SetPort(v int32) *AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes {
	s.Port = &v
	return s
}

func (s *AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes) SetVServerGroupId(v string) *AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes {
	s.VServerGroupId = &v
	return s
}

func (s *AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes) SetWeight(v int32) *AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes {
	s.Weight = &v
	return s
}

type AttachVServerGroupsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AttachVServerGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachVServerGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *AttachVServerGroupsResponseBody) SetRequestId(v string) *AttachVServerGroupsResponseBody {
	s.RequestId = &v
	return s
}

type AttachVServerGroupsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachVServerGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachVServerGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachVServerGroupsResponse) GoString() string {
	return s.String()
}

func (s *AttachVServerGroupsResponse) SetHeaders(v map[string]*string) *AttachVServerGroupsResponse {
	s.Headers = v
	return s
}

func (s *AttachVServerGroupsResponse) SetStatusCode(v int32) *AttachVServerGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachVServerGroupsResponse) SetBody(v *AttachVServerGroupsResponseBody) *AttachVServerGroupsResponse {
	s.Body = v
	return s
}

type ChangeResourceGroupRequest struct {
	NewResourceGroupId   *string `json:"NewResourceGroupId,omitempty" xml:"NewResourceGroupId,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceId           *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceType         *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s ChangeResourceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceGroupRequest) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupRequest) SetNewResourceGroupId(v string) *ChangeResourceGroupRequest {
	s.NewResourceGroupId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetOwnerId(v int64) *ChangeResourceGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetRegionId(v string) *ChangeResourceGroupRequest {
	s.RegionId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetResourceId(v string) *ChangeResourceGroupRequest {
	s.ResourceId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetResourceOwnerAccount(v string) *ChangeResourceGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetResourceType(v string) *ChangeResourceGroupRequest {
	s.ResourceType = &v
	return s
}

type ChangeResourceGroupResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ChangeResourceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupResponseBody) SetRequestId(v string) *ChangeResourceGroupResponseBody {
	s.RequestId = &v
	return s
}

type ChangeResourceGroupResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ChangeResourceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ChangeResourceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceGroupResponse) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupResponse) SetHeaders(v map[string]*string) *ChangeResourceGroupResponse {
	s.Headers = v
	return s
}

func (s *ChangeResourceGroupResponse) SetStatusCode(v int32) *ChangeResourceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ChangeResourceGroupResponse) SetBody(v *ChangeResourceGroupResponseBody) *ChangeResourceGroupResponse {
	s.Body = v
	return s
}

type CompleteLifecycleActionRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The action that you want Auto Scaling to perform after the lifecycle hook times out. Valid values:
	//
	// *   CONTINUE: Auto Scaling continues to respond to a scale-in or scale-out request.
	// *   ABANDON: Auto Scaling releases Elastic Compute Service (ECS) instances that are created during scale-out activities or removes ECS instances from the scaling group during scale-in activities.
	// *   ROLLBACK: For scale-in activities, Auto Scaling rejects the requests to release ECS instances but rolls back ECS instances. For scale-out activities, the ROLLBACK setting has the same effect as the ABANDON setting.
	//
	// If you do not specify this parameter, Auto Scaling performs the action that is specified by the `DefaultResult` parameter after the lifecycle hook times out.
	//
	// If multiple lifecycle hooks exist in a scaling group and the lifecycle hooks are triggered at the same time, the following rules apply:
	//
	// *   For scale-in activities, when lifecycle hooks whose LifecycleActionResult parameter is set to ABANDON or ROLLBACK time out, other lifecycle hooks time out ahead of schedule.
	// *   For scale-in and scale-out activities, if you set the LifecycleActionResult parameter for all lifecycle hooks to CONTINUE, Auto Scaling performs the next action only after the last lifecycle hook times out. The action that Auto Scaling performs varies based on the value that you specify for the LifecycleActionResult parameter of the lifecycle hook that last times out.
	LifecycleActionResult *string `json:"LifecycleActionResult,omitempty" xml:"LifecycleActionResult,omitempty"`
	// The token of the lifecycle hook. You can obtain this token by using a Message Service (MNS) queue or an MNS topic that is specified for the lifecycle hook.
	LifecycleActionToken *string `json:"LifecycleActionToken,omitempty" xml:"LifecycleActionToken,omitempty"`
	// The ID of the lifecycle hook.
	LifecycleHookId *string `json:"LifecycleHookId,omitempty" xml:"LifecycleHookId,omitempty"`
	OwnerAccount    *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId         *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
}

func (s CompleteLifecycleActionRequest) String() string {
	return tea.Prettify(s)
}

func (s CompleteLifecycleActionRequest) GoString() string {
	return s.String()
}

func (s *CompleteLifecycleActionRequest) SetClientToken(v string) *CompleteLifecycleActionRequest {
	s.ClientToken = &v
	return s
}

func (s *CompleteLifecycleActionRequest) SetLifecycleActionResult(v string) *CompleteLifecycleActionRequest {
	s.LifecycleActionResult = &v
	return s
}

func (s *CompleteLifecycleActionRequest) SetLifecycleActionToken(v string) *CompleteLifecycleActionRequest {
	s.LifecycleActionToken = &v
	return s
}

func (s *CompleteLifecycleActionRequest) SetLifecycleHookId(v string) *CompleteLifecycleActionRequest {
	s.LifecycleHookId = &v
	return s
}

func (s *CompleteLifecycleActionRequest) SetOwnerAccount(v string) *CompleteLifecycleActionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CompleteLifecycleActionRequest) SetOwnerId(v int64) *CompleteLifecycleActionRequest {
	s.OwnerId = &v
	return s
}

func (s *CompleteLifecycleActionRequest) SetRegionId(v string) *CompleteLifecycleActionRequest {
	s.RegionId = &v
	return s
}

func (s *CompleteLifecycleActionRequest) SetResourceOwnerAccount(v string) *CompleteLifecycleActionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

type CompleteLifecycleActionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CompleteLifecycleActionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CompleteLifecycleActionResponseBody) GoString() string {
	return s.String()
}

func (s *CompleteLifecycleActionResponseBody) SetRequestId(v string) *CompleteLifecycleActionResponseBody {
	s.RequestId = &v
	return s
}

type CompleteLifecycleActionResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CompleteLifecycleActionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CompleteLifecycleActionResponse) String() string {
	return tea.Prettify(s)
}

func (s CompleteLifecycleActionResponse) GoString() string {
	return s.String()
}

func (s *CompleteLifecycleActionResponse) SetHeaders(v map[string]*string) *CompleteLifecycleActionResponse {
	s.Headers = v
	return s
}

func (s *CompleteLifecycleActionResponse) SetStatusCode(v int32) *CompleteLifecycleActionResponse {
	s.StatusCode = &v
	return s
}

func (s *CompleteLifecycleActionResponse) SetBody(v *CompleteLifecycleActionResponseBody) *CompleteLifecycleActionResponse {
	s.Body = v
	return s
}

type CreateAlarmRequest struct {
	AlarmActions             []*string                        `json:"AlarmActions,omitempty" xml:"AlarmActions,omitempty" type:"Repeated"`
	ComparisonOperator       *string                          `json:"ComparisonOperator,omitempty" xml:"ComparisonOperator,omitempty"`
	Description              *string                          `json:"Description,omitempty" xml:"Description,omitempty"`
	Dimensions               []*CreateAlarmRequestDimensions  `json:"Dimensions,omitempty" xml:"Dimensions,omitempty" type:"Repeated"`
	Effective                *string                          `json:"Effective,omitempty" xml:"Effective,omitempty"`
	EvaluationCount          *int32                           `json:"EvaluationCount,omitempty" xml:"EvaluationCount,omitempty"`
	Expressions              []*CreateAlarmRequestExpressions `json:"Expressions,omitempty" xml:"Expressions,omitempty" type:"Repeated"`
	ExpressionsLogicOperator *string                          `json:"ExpressionsLogicOperator,omitempty" xml:"ExpressionsLogicOperator,omitempty"`
	GroupId                  *int32                           `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	MetricName               *string                          `json:"MetricName,omitempty" xml:"MetricName,omitempty"`
	MetricType               *string                          `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
	Name                     *string                          `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerId                  *int64                           `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	Period                   *int32                           `json:"Period,omitempty" xml:"Period,omitempty"`
	RegionId                 *string                          `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount     *string                          `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ScalingGroupId           *string                          `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	Statistics               *string                          `json:"Statistics,omitempty" xml:"Statistics,omitempty"`
	Threshold                *float32                         `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s CreateAlarmRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAlarmRequest) GoString() string {
	return s.String()
}

func (s *CreateAlarmRequest) SetAlarmActions(v []*string) *CreateAlarmRequest {
	s.AlarmActions = v
	return s
}

func (s *CreateAlarmRequest) SetComparisonOperator(v string) *CreateAlarmRequest {
	s.ComparisonOperator = &v
	return s
}

func (s *CreateAlarmRequest) SetDescription(v string) *CreateAlarmRequest {
	s.Description = &v
	return s
}

func (s *CreateAlarmRequest) SetDimensions(v []*CreateAlarmRequestDimensions) *CreateAlarmRequest {
	s.Dimensions = v
	return s
}

func (s *CreateAlarmRequest) SetEffective(v string) *CreateAlarmRequest {
	s.Effective = &v
	return s
}

func (s *CreateAlarmRequest) SetEvaluationCount(v int32) *CreateAlarmRequest {
	s.EvaluationCount = &v
	return s
}

func (s *CreateAlarmRequest) SetExpressions(v []*CreateAlarmRequestExpressions) *CreateAlarmRequest {
	s.Expressions = v
	return s
}

func (s *CreateAlarmRequest) SetExpressionsLogicOperator(v string) *CreateAlarmRequest {
	s.ExpressionsLogicOperator = &v
	return s
}

func (s *CreateAlarmRequest) SetGroupId(v int32) *CreateAlarmRequest {
	s.GroupId = &v
	return s
}

func (s *CreateAlarmRequest) SetMetricName(v string) *CreateAlarmRequest {
	s.MetricName = &v
	return s
}

func (s *CreateAlarmRequest) SetMetricType(v string) *CreateAlarmRequest {
	s.MetricType = &v
	return s
}

func (s *CreateAlarmRequest) SetName(v string) *CreateAlarmRequest {
	s.Name = &v
	return s
}

func (s *CreateAlarmRequest) SetOwnerId(v int64) *CreateAlarmRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateAlarmRequest) SetPeriod(v int32) *CreateAlarmRequest {
	s.Period = &v
	return s
}

func (s *CreateAlarmRequest) SetRegionId(v string) *CreateAlarmRequest {
	s.RegionId = &v
	return s
}

func (s *CreateAlarmRequest) SetResourceOwnerAccount(v string) *CreateAlarmRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateAlarmRequest) SetScalingGroupId(v string) *CreateAlarmRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *CreateAlarmRequest) SetStatistics(v string) *CreateAlarmRequest {
	s.Statistics = &v
	return s
}

func (s *CreateAlarmRequest) SetThreshold(v float32) *CreateAlarmRequest {
	s.Threshold = &v
	return s
}

type CreateAlarmRequestDimensions struct {
	DimensionKey   *string `json:"DimensionKey,omitempty" xml:"DimensionKey,omitempty"`
	DimensionValue *string `json:"DimensionValue,omitempty" xml:"DimensionValue,omitempty"`
}

func (s CreateAlarmRequestDimensions) String() string {
	return tea.Prettify(s)
}

func (s CreateAlarmRequestDimensions) GoString() string {
	return s.String()
}

func (s *CreateAlarmRequestDimensions) SetDimensionKey(v string) *CreateAlarmRequestDimensions {
	s.DimensionKey = &v
	return s
}

func (s *CreateAlarmRequestDimensions) SetDimensionValue(v string) *CreateAlarmRequestDimensions {
	s.DimensionValue = &v
	return s
}

type CreateAlarmRequestExpressions struct {
	ComparisonOperator *string  `json:"ComparisonOperator,omitempty" xml:"ComparisonOperator,omitempty"`
	MetricName         *string  `json:"MetricName,omitempty" xml:"MetricName,omitempty"`
	Period             *int32   `json:"Period,omitempty" xml:"Period,omitempty"`
	Statistics         *string  `json:"Statistics,omitempty" xml:"Statistics,omitempty"`
	Threshold          *float32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s CreateAlarmRequestExpressions) String() string {
	return tea.Prettify(s)
}

func (s CreateAlarmRequestExpressions) GoString() string {
	return s.String()
}

func (s *CreateAlarmRequestExpressions) SetComparisonOperator(v string) *CreateAlarmRequestExpressions {
	s.ComparisonOperator = &v
	return s
}

func (s *CreateAlarmRequestExpressions) SetMetricName(v string) *CreateAlarmRequestExpressions {
	s.MetricName = &v
	return s
}

func (s *CreateAlarmRequestExpressions) SetPeriod(v int32) *CreateAlarmRequestExpressions {
	s.Period = &v
	return s
}

func (s *CreateAlarmRequestExpressions) SetStatistics(v string) *CreateAlarmRequestExpressions {
	s.Statistics = &v
	return s
}

func (s *CreateAlarmRequestExpressions) SetThreshold(v float32) *CreateAlarmRequestExpressions {
	s.Threshold = &v
	return s
}

type CreateAlarmResponseBody struct {
	AlarmTaskId *string `json:"AlarmTaskId,omitempty" xml:"AlarmTaskId,omitempty"`
	RequestId   *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAlarmResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateAlarmResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAlarmResponseBody) SetAlarmTaskId(v string) *CreateAlarmResponseBody {
	s.AlarmTaskId = &v
	return s
}

func (s *CreateAlarmResponseBody) SetRequestId(v string) *CreateAlarmResponseBody {
	s.RequestId = &v
	return s
}

type CreateAlarmResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateAlarmResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateAlarmResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAlarmResponse) GoString() string {
	return s.String()
}

func (s *CreateAlarmResponse) SetHeaders(v map[string]*string) *CreateAlarmResponse {
	s.Headers = v
	return s
}

func (s *CreateAlarmResponse) SetStatusCode(v int32) *CreateAlarmResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAlarmResponse) SetBody(v *CreateAlarmResponseBody) *CreateAlarmResponse {
	s.Body = v
	return s
}

type CreateEciScalingConfigurationRequest struct {
	// Information about the Container Registry Enterprise Edition instance.
	AcrRegistryInfos []*CreateEciScalingConfigurationRequestAcrRegistryInfos `json:"AcrRegistryInfos,omitempty" xml:"AcrRegistryInfos,omitempty" type:"Repeated"`
	// The validity period. Unit: seconds.
	ActiveDeadlineSeconds *int64 `json:"ActiveDeadlineSeconds,omitempty" xml:"ActiveDeadlineSeconds,omitempty"`
	// Specifies whether to automatically create an elastic IP address (EIP) and bind the EIP to the elastic container instance.
	AutoCreateEip *bool `json:"AutoCreateEip,omitempty" xml:"AutoCreateEip,omitempty"`
	// Specifies whether to automatically match the image cache. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	AutoMatchImageCache *bool `json:"AutoMatchImageCache,omitempty" xml:"AutoMatchImageCache,omitempty"`
	// The name of the elastic container instance.
	ContainerGroupName *string `json:"ContainerGroupName,omitempty" xml:"ContainerGroupName,omitempty"`
	// The containers in the elastic container instance.
	Containers []*CreateEciScalingConfigurationRequestContainers `json:"Containers,omitempty" xml:"Containers,omitempty" type:"Repeated"`
	// Specifies whether to enable the cost optimization feature. Valid values:
	//
	// *   true
	// *   false
	CostOptimization *bool `json:"CostOptimization,omitempty" xml:"CostOptimization,omitempty"`
	// The number of vCPUs of the elastic container instance.
	Cpu *float32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// Number of physical CPU cores This parameter is not available for all instance types. For more information, see [Specify custom CPU options](~~197781~~).
	CpuOptionsCore *int32 `json:"CpuOptionsCore,omitempty" xml:"CpuOptionsCore,omitempty"`
	// The number of threads per core. This parameter is not available for all instance types. A value of 1 indicates that Hyper-Threading is disabled. For more information, see [Specify custom CPU options](~~197781~~).
	CpuOptionsThreadsPerCore *int32  `json:"CpuOptionsThreadsPerCore,omitempty" xml:"CpuOptionsThreadsPerCore,omitempty"`
	DataCacheBucket          *string `json:"DataCacheBucket,omitempty" xml:"DataCacheBucket,omitempty"`
	DataCacheBurstingEnabled *bool   `json:"DataCacheBurstingEnabled,omitempty" xml:"DataCacheBurstingEnabled,omitempty"`
	DataCachePL              *string `json:"DataCachePL,omitempty" xml:"DataCachePL,omitempty"`
	DataCacheProvisionedIops *int32  `json:"DataCacheProvisionedIops,omitempty" xml:"DataCacheProvisionedIops,omitempty"`
	// > This parameter is unavailable.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The IP addresses of the DNS servers.
	DnsConfigNameServers []*string `json:"DnsConfigNameServers,omitempty" xml:"DnsConfigNameServers,omitempty" type:"Repeated"`
	// The options. Each option is in the name-value pair format. The value in the name-value pair is optional.
	DnsConfigOptions []*CreateEciScalingConfigurationRequestDnsConfigOptions `json:"DnsConfigOptions,omitempty" xml:"DnsConfigOptions,omitempty" type:"Repeated"`
	// The DNS lookup domains.
	DnsConfigSearchs []*string `json:"DnsConfigSearchs,omitempty" xml:"DnsConfigSearchs,omitempty" type:"Repeated"`
	// The Domain Name System (DNS) policy. Valid values:
	//
	// *   None: uses the DNS that is set for the DnsConfig field.
	// *   Default: use the DNS that is set for the runtime environment.
	DnsPolicy *string `json:"DnsPolicy,omitempty" xml:"DnsPolicy,omitempty"`
	// The maximum outbound bandwidth. Unit: bytes.
	EgressBandwidth *int64 `json:"EgressBandwidth,omitempty" xml:"EgressBandwidth,omitempty"`
	// The bandwidth of the EIP. Default value: 5 Mbit/s.
	EipBandwidth *int32 `json:"EipBandwidth,omitempty" xml:"EipBandwidth,omitempty"`
	// > This parameter is unavailable.
	EnableSls *bool `json:"EnableSls,omitempty" xml:"EnableSls,omitempty"`
	// The size of the temporary storage space. By default, an ESSD of the PL1 type is used. Unit: GiB.
	EphemeralStorage *int32 `json:"EphemeralStorage,omitempty" xml:"EphemeralStorage,omitempty"`
	// The hostnames and IP addresses of a container that you want to add to the hosts file of the elastic container instance.
	HostAliases []*CreateEciScalingConfigurationRequestHostAliases `json:"HostAliases,omitempty" xml:"HostAliases,omitempty" type:"Repeated"`
	// The name of the elastic container instance.
	HostName *string `json:"HostName,omitempty" xml:"HostName,omitempty"`
	// Information about the image repository.
	ImageRegistryCredentials []*CreateEciScalingConfigurationRequestImageRegistryCredentials `json:"ImageRegistryCredentials,omitempty" xml:"ImageRegistryCredentials,omitempty" type:"Repeated"`
	// The ID of the image cache.
	ImageSnapshotId *string `json:"ImageSnapshotId,omitempty" xml:"ImageSnapshotId,omitempty"`
	// The maximum inbound bandwidth. Unit: bit/s.
	IngressBandwidth *int64 `json:"IngressBandwidth,omitempty" xml:"IngressBandwidth,omitempty"`
	// The init containers.
	InitContainers []*CreateEciScalingConfigurationRequestInitContainers `json:"InitContainers,omitempty" xml:"InitContainers,omitempty" type:"Repeated"`
	// The level of the instance type, which is used to filter the instance types that meet the specified criteria. This parameter takes effect only if you set the `CostOptimization` parameter to true. Valid values:
	//
	// *   EntryLevel: shared instance type. Instances of this level are the most cost-effective but may not provide stable computing performance in a consistent manner. Instances of this level are suitable for business scenarios in which the CPU utilization is low. For more information, see [Shared instance families](~~108489~~).
	// *   EnterpriseLevel: Instances of this level provide stable performance and dedicated resources, and are suitable for business scenarios that require high stability. For more information, see [Instance family](~~25378~~).
	// *   CreditEntryLevel: This value is valid only for burstable instances. CPU credits are used to ensure computing performance. Instances of this level are suitable for scenarios in which the CPU utilization is low but may fluctuate in specific cases. For more information, see the [Overview](~~59977~~) topic of burstable instances.
	InstanceFamilyLevel *string   `json:"InstanceFamilyLevel,omitempty" xml:"InstanceFamilyLevel,omitempty"`
	InstanceTypes       []*string `json:"InstanceTypes,omitempty" xml:"InstanceTypes,omitempty" type:"Repeated"`
	// The number of IPv6 addresses.
	Ipv6AddressCount *int32 `json:"Ipv6AddressCount,omitempty" xml:"Ipv6AddressCount,omitempty"`
	// The weight of the elastic container instance as a backend server. Valid values: 1 to 100.
	//
	// Default value: 50.
	LoadBalancerWeight *int32 `json:"LoadBalancerWeight,omitempty" xml:"LoadBalancerWeight,omitempty"`
	// The memory size of the elastic container instance. Unit: GiB.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The domain name of the Network Time Protocol (NTP) server.
	NtpServers []*string `json:"NtpServers,omitempty" xml:"NtpServers,omitempty" type:"Repeated"`
	OwnerId    *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The name of the RAM role for the elastic container instance. You can use an instance RAM role to access both elastic container instances and Elastic Compute Service (ECS) instances. For more information, see [Use an instance RAM role by calling API operations](~~61178~~).
	RamRoleName *string `json:"RamRoleName,omitempty" xml:"RamRoleName,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The restart policy of the elastic container instance. Valid values:
	//
	// *   Always: always restarts the elastic container instance.
	// *   Never: never restarts the elastic container instance.
	// *   OnFailure: restarts the elastic container instance upon failures.
	//
	// Default value: Always.
	RestartPolicy *string `json:"RestartPolicy,omitempty" xml:"RestartPolicy,omitempty"`
	// The name of the scaling configuration. The name must be 2 to 64 characters in length, and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). The name must start with a letter or a digit.
	//
	// The name of the scaling configuration must be unique within a scaling group in a region. If you do not specify this parameter, the value of the ScalingConfigurationId parameter is used.
	ScalingConfigurationName *string `json:"ScalingConfigurationName,omitempty" xml:"ScalingConfigurationName,omitempty"`
	// The ID of the scaling group in which you want to create the scaling configuration.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The system information of the security context in which the elastic container instance runs.
	SecurityContextSysctls []*CreateEciScalingConfigurationRequestSecurityContextSysctls `json:"SecurityContextSysctls,omitempty" xml:"SecurityContextSysctls,omitempty" type:"Repeated"`
	// The ID of the security group with which you want to associate the elastic container instance. Elastic container instances that are associated with the same security group can access each other.
	//
	// If you do not specify a security group, the system uses the default security group in the region that you selected. Make sure that the inbound rules of the security group contain the protocols and the port numbers of the containers that you want to expose. If you do not have a default security group in the region, the system creates a default security group, and then adds the declared container protocols and port numbers to the inbound rules of the security group.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// The maximum hourly price of the preemptible elastic container instance. The value can be accurate to three decimal places.
	//
	// If you set the SpotStrategy parameter to SpotWithPriceLimit, you must also specify the SpotPriceLimit parameter.
	SpotPriceLimit *float32 `json:"SpotPriceLimit,omitempty" xml:"SpotPriceLimit,omitempty"`
	// The bidding policy for the elastic container instance. Valid values:
	//
	// *   NoSpot: The instance is a pay-as-you-go instance.
	// *   SpotWithPriceLimit: The instance is a preemptible instance with a user-defined maximum hourly price.
	// *   SpotAsPriceGo: The instance is a preemptible instance for which the market price at the time of purchase is used as the bid price.
	//
	// Default value: NoSpot.
	SpotStrategy *string `json:"SpotStrategy,omitempty" xml:"SpotStrategy,omitempty"`
	// The tags of the elastic container instance. The tags must be specified in the key-value pair format. You can specify up to 20 tags. When you specify tag keys and tag values, take note of the following items:
	//
	// *   A tag key can be up to 64 characters in length. The key cannot start with acs: or aliyun and cannot contain `http://` or `https://`. You cannot specify an empty string as a tag key.
	// *   A tag value can be up to 128 characters in length. The value cannot start with acs: or aliyun and cannot contain `http://` or `https://`. You can specify an empty string as a tag value.
	Tags []*CreateEciScalingConfigurationRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The buffer time in which the program handles operations before the program is stopped. Unit: seconds.
	TerminationGracePeriodSeconds *int64 `json:"TerminationGracePeriodSeconds,omitempty" xml:"TerminationGracePeriodSeconds,omitempty"`
	// Information about the volumes.
	Volumes []*CreateEciScalingConfigurationRequestVolumes `json:"Volumes,omitempty" xml:"Volumes,omitempty" type:"Repeated"`
}

func (s CreateEciScalingConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequest) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequest) SetAcrRegistryInfos(v []*CreateEciScalingConfigurationRequestAcrRegistryInfos) *CreateEciScalingConfigurationRequest {
	s.AcrRegistryInfos = v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetActiveDeadlineSeconds(v int64) *CreateEciScalingConfigurationRequest {
	s.ActiveDeadlineSeconds = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetAutoCreateEip(v bool) *CreateEciScalingConfigurationRequest {
	s.AutoCreateEip = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetAutoMatchImageCache(v bool) *CreateEciScalingConfigurationRequest {
	s.AutoMatchImageCache = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetContainerGroupName(v string) *CreateEciScalingConfigurationRequest {
	s.ContainerGroupName = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetContainers(v []*CreateEciScalingConfigurationRequestContainers) *CreateEciScalingConfigurationRequest {
	s.Containers = v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetCostOptimization(v bool) *CreateEciScalingConfigurationRequest {
	s.CostOptimization = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetCpu(v float32) *CreateEciScalingConfigurationRequest {
	s.Cpu = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetCpuOptionsCore(v int32) *CreateEciScalingConfigurationRequest {
	s.CpuOptionsCore = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetCpuOptionsThreadsPerCore(v int32) *CreateEciScalingConfigurationRequest {
	s.CpuOptionsThreadsPerCore = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetDataCacheBucket(v string) *CreateEciScalingConfigurationRequest {
	s.DataCacheBucket = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetDataCacheBurstingEnabled(v bool) *CreateEciScalingConfigurationRequest {
	s.DataCacheBurstingEnabled = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetDataCachePL(v string) *CreateEciScalingConfigurationRequest {
	s.DataCachePL = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetDataCacheProvisionedIops(v int32) *CreateEciScalingConfigurationRequest {
	s.DataCacheProvisionedIops = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetDescription(v string) *CreateEciScalingConfigurationRequest {
	s.Description = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetDnsConfigNameServers(v []*string) *CreateEciScalingConfigurationRequest {
	s.DnsConfigNameServers = v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetDnsConfigOptions(v []*CreateEciScalingConfigurationRequestDnsConfigOptions) *CreateEciScalingConfigurationRequest {
	s.DnsConfigOptions = v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetDnsConfigSearchs(v []*string) *CreateEciScalingConfigurationRequest {
	s.DnsConfigSearchs = v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetDnsPolicy(v string) *CreateEciScalingConfigurationRequest {
	s.DnsPolicy = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetEgressBandwidth(v int64) *CreateEciScalingConfigurationRequest {
	s.EgressBandwidth = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetEipBandwidth(v int32) *CreateEciScalingConfigurationRequest {
	s.EipBandwidth = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetEnableSls(v bool) *CreateEciScalingConfigurationRequest {
	s.EnableSls = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetEphemeralStorage(v int32) *CreateEciScalingConfigurationRequest {
	s.EphemeralStorage = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetHostAliases(v []*CreateEciScalingConfigurationRequestHostAliases) *CreateEciScalingConfigurationRequest {
	s.HostAliases = v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetHostName(v string) *CreateEciScalingConfigurationRequest {
	s.HostName = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetImageRegistryCredentials(v []*CreateEciScalingConfigurationRequestImageRegistryCredentials) *CreateEciScalingConfigurationRequest {
	s.ImageRegistryCredentials = v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetImageSnapshotId(v string) *CreateEciScalingConfigurationRequest {
	s.ImageSnapshotId = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetIngressBandwidth(v int64) *CreateEciScalingConfigurationRequest {
	s.IngressBandwidth = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetInitContainers(v []*CreateEciScalingConfigurationRequestInitContainers) *CreateEciScalingConfigurationRequest {
	s.InitContainers = v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetInstanceFamilyLevel(v string) *CreateEciScalingConfigurationRequest {
	s.InstanceFamilyLevel = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetInstanceTypes(v []*string) *CreateEciScalingConfigurationRequest {
	s.InstanceTypes = v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetIpv6AddressCount(v int32) *CreateEciScalingConfigurationRequest {
	s.Ipv6AddressCount = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetLoadBalancerWeight(v int32) *CreateEciScalingConfigurationRequest {
	s.LoadBalancerWeight = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetMemory(v float32) *CreateEciScalingConfigurationRequest {
	s.Memory = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetNtpServers(v []*string) *CreateEciScalingConfigurationRequest {
	s.NtpServers = v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetOwnerId(v int64) *CreateEciScalingConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetRamRoleName(v string) *CreateEciScalingConfigurationRequest {
	s.RamRoleName = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetResourceGroupId(v string) *CreateEciScalingConfigurationRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetResourceOwnerAccount(v string) *CreateEciScalingConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetRestartPolicy(v string) *CreateEciScalingConfigurationRequest {
	s.RestartPolicy = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetScalingConfigurationName(v string) *CreateEciScalingConfigurationRequest {
	s.ScalingConfigurationName = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetScalingGroupId(v string) *CreateEciScalingConfigurationRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetSecurityContextSysctls(v []*CreateEciScalingConfigurationRequestSecurityContextSysctls) *CreateEciScalingConfigurationRequest {
	s.SecurityContextSysctls = v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetSecurityGroupId(v string) *CreateEciScalingConfigurationRequest {
	s.SecurityGroupId = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetSpotPriceLimit(v float32) *CreateEciScalingConfigurationRequest {
	s.SpotPriceLimit = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetSpotStrategy(v string) *CreateEciScalingConfigurationRequest {
	s.SpotStrategy = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetTags(v []*CreateEciScalingConfigurationRequestTags) *CreateEciScalingConfigurationRequest {
	s.Tags = v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetTerminationGracePeriodSeconds(v int64) *CreateEciScalingConfigurationRequest {
	s.TerminationGracePeriodSeconds = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetVolumes(v []*CreateEciScalingConfigurationRequestVolumes) *CreateEciScalingConfigurationRequest {
	s.Volumes = v
	return s
}

type CreateEciScalingConfigurationRequestAcrRegistryInfos struct {
	// The domain names of the Container Registry Enterprise Edition instances. By default, all domain names of the Container Registry Enterprise Edition instances are displayed. You can specify one or more domain names. Separate multiple domain names with commas (,).
	Domains []*string `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Repeated"`
	// The ID of the Container Registry Enterprise Edition instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the Container Registry Enterprise Edition instance.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The region ID of the Container Registry Enterprise Edition instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateEciScalingConfigurationRequestAcrRegistryInfos) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestAcrRegistryInfos) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestAcrRegistryInfos) SetDomains(v []*string) *CreateEciScalingConfigurationRequestAcrRegistryInfos {
	s.Domains = v
	return s
}

func (s *CreateEciScalingConfigurationRequestAcrRegistryInfos) SetInstanceId(v string) *CreateEciScalingConfigurationRequestAcrRegistryInfos {
	s.InstanceId = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestAcrRegistryInfos) SetInstanceName(v string) *CreateEciScalingConfigurationRequestAcrRegistryInfos {
	s.InstanceName = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestAcrRegistryInfos) SetRegionId(v string) *CreateEciScalingConfigurationRequestAcrRegistryInfos {
	s.RegionId = &v
	return s
}

type CreateEciScalingConfigurationRequestContainers struct {
	LivenessProbe   *CreateEciScalingConfigurationRequestContainersLivenessProbe   `json:"LivenessProbe,omitempty" xml:"LivenessProbe,omitempty" type:"Struct"`
	ReadinessProbe  *CreateEciScalingConfigurationRequestContainersReadinessProbe  `json:"ReadinessProbe,omitempty" xml:"ReadinessProbe,omitempty" type:"Struct"`
	SecurityContext *CreateEciScalingConfigurationRequestContainersSecurityContext `json:"SecurityContext,omitempty" xml:"SecurityContext,omitempty" type:"Struct"`
	// The arguments that correspond to the startup commands of the container. You can specify up to 10 arguments.
	Args []*string `json:"Args,omitempty" xml:"Args,omitempty" type:"Repeated"`
	// The commands that you want to run in the container when you use the CLI to perform probes.
	Commands []*string `json:"Commands,omitempty" xml:"Commands,omitempty" type:"Repeated"`
	// The number of CPU cores in the container.
	Cpu *float32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// Information about environment variables.
	EnvironmentVars []*CreateEciScalingConfigurationRequestContainersEnvironmentVars `json:"EnvironmentVars,omitempty" xml:"EnvironmentVars,omitempty" type:"Repeated"`
	// The number of GPUs that you want to allocate to the container.
	Gpu *int32 `json:"Gpu,omitempty" xml:"Gpu,omitempty"`
	// The image of the container.
	Image *string `json:"Image,omitempty" xml:"Image,omitempty"`
	// The image pulling policy. Valid values:
	//
	// *   Always: pulls images each time.
	// *   IfNotPresent: pulls images only if no on-premises images are available. On-premises images are preferentially used. If no on-premises images are available, image pulling is performed.
	// *   Never: never pulls images. On-premises images are always used.
	ImagePullPolicy *string `json:"ImagePullPolicy,omitempty" xml:"ImagePullPolicy,omitempty"`
	// The memory size of the container. Unit: GiB.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The name of the container image.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ports.
	Ports []*CreateEciScalingConfigurationRequestContainersPorts `json:"Ports,omitempty" xml:"Ports,omitempty" type:"Repeated"`
	// Specifies whether the container allocates buffer resources to standard input streams when the container is running. If you do not specify this parameter, an end-of-file (EOF) error may occur.
	//
	// Default value: false.
	Stdin *bool `json:"Stdin,omitempty" xml:"Stdin,omitempty"`
	// Specifies whether to disconnect standard input streams after a client is disconnected.
	//
	// If you set the StdinOnce parameter to true, standard input streams are connected after the container is started, and remain idle until a client is connected to receive data. After the client is disconnected, streams are also disconnected, and remain disconnected until the container is started again.
	StdinOnce *bool `json:"StdinOnce,omitempty" xml:"StdinOnce,omitempty"`
	// Specifies whether to enable interaction. Valid values:
	//
	// *   true
	// *   false
	//
	// If the value of the Command parameter is /bin/bash, you must set this parameter to true.
	//
	// Default value: false.
	Tty *bool `json:"Tty,omitempty" xml:"Tty,omitempty"`
	// Information about the volume mount of the container.
	VolumeMounts []*CreateEciScalingConfigurationRequestContainersVolumeMounts `json:"VolumeMounts,omitempty" xml:"VolumeMounts,omitempty" type:"Repeated"`
	// The working directory of the container.
	WorkingDir *string `json:"WorkingDir,omitempty" xml:"WorkingDir,omitempty"`
}

func (s CreateEciScalingConfigurationRequestContainers) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainers) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainers) SetLivenessProbe(v *CreateEciScalingConfigurationRequestContainersLivenessProbe) *CreateEciScalingConfigurationRequestContainers {
	s.LivenessProbe = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetReadinessProbe(v *CreateEciScalingConfigurationRequestContainersReadinessProbe) *CreateEciScalingConfigurationRequestContainers {
	s.ReadinessProbe = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetSecurityContext(v *CreateEciScalingConfigurationRequestContainersSecurityContext) *CreateEciScalingConfigurationRequestContainers {
	s.SecurityContext = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetArgs(v []*string) *CreateEciScalingConfigurationRequestContainers {
	s.Args = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetCommands(v []*string) *CreateEciScalingConfigurationRequestContainers {
	s.Commands = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetCpu(v float32) *CreateEciScalingConfigurationRequestContainers {
	s.Cpu = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetEnvironmentVars(v []*CreateEciScalingConfigurationRequestContainersEnvironmentVars) *CreateEciScalingConfigurationRequestContainers {
	s.EnvironmentVars = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetGpu(v int32) *CreateEciScalingConfigurationRequestContainers {
	s.Gpu = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetImage(v string) *CreateEciScalingConfigurationRequestContainers {
	s.Image = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetImagePullPolicy(v string) *CreateEciScalingConfigurationRequestContainers {
	s.ImagePullPolicy = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetMemory(v float32) *CreateEciScalingConfigurationRequestContainers {
	s.Memory = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetName(v string) *CreateEciScalingConfigurationRequestContainers {
	s.Name = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetPorts(v []*CreateEciScalingConfigurationRequestContainersPorts) *CreateEciScalingConfigurationRequestContainers {
	s.Ports = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetStdin(v bool) *CreateEciScalingConfigurationRequestContainers {
	s.Stdin = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetStdinOnce(v bool) *CreateEciScalingConfigurationRequestContainers {
	s.StdinOnce = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetTty(v bool) *CreateEciScalingConfigurationRequestContainers {
	s.Tty = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetVolumeMounts(v []*CreateEciScalingConfigurationRequestContainersVolumeMounts) *CreateEciScalingConfigurationRequestContainers {
	s.VolumeMounts = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetWorkingDir(v string) *CreateEciScalingConfigurationRequestContainers {
	s.WorkingDir = &v
	return s
}

type CreateEciScalingConfigurationRequestContainersLivenessProbe struct {
	Exec                *CreateEciScalingConfigurationRequestContainersLivenessProbeExec      `json:"Exec,omitempty" xml:"Exec,omitempty" type:"Struct"`
	FailureThreshold    *int32                                                                `json:"FailureThreshold,omitempty" xml:"FailureThreshold,omitempty"`
	HttpGet             *CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet   `json:"HttpGet,omitempty" xml:"HttpGet,omitempty" type:"Struct"`
	InitialDelaySeconds *int32                                                                `json:"InitialDelaySeconds,omitempty" xml:"InitialDelaySeconds,omitempty"`
	PeriodSeconds       *int32                                                                `json:"PeriodSeconds,omitempty" xml:"PeriodSeconds,omitempty"`
	SuccessThreshold    *int32                                                                `json:"SuccessThreshold,omitempty" xml:"SuccessThreshold,omitempty"`
	TcpSocket           *CreateEciScalingConfigurationRequestContainersLivenessProbeTcpSocket `json:"TcpSocket,omitempty" xml:"TcpSocket,omitempty" type:"Struct"`
	TimeoutSeconds      *int32                                                                `json:"TimeoutSeconds,omitempty" xml:"TimeoutSeconds,omitempty"`
}

func (s CreateEciScalingConfigurationRequestContainersLivenessProbe) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersLivenessProbe) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbe) SetExec(v *CreateEciScalingConfigurationRequestContainersLivenessProbeExec) *CreateEciScalingConfigurationRequestContainersLivenessProbe {
	s.Exec = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbe) SetFailureThreshold(v int32) *CreateEciScalingConfigurationRequestContainersLivenessProbe {
	s.FailureThreshold = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbe) SetHttpGet(v *CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet) *CreateEciScalingConfigurationRequestContainersLivenessProbe {
	s.HttpGet = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbe) SetInitialDelaySeconds(v int32) *CreateEciScalingConfigurationRequestContainersLivenessProbe {
	s.InitialDelaySeconds = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbe) SetPeriodSeconds(v int32) *CreateEciScalingConfigurationRequestContainersLivenessProbe {
	s.PeriodSeconds = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbe) SetSuccessThreshold(v int32) *CreateEciScalingConfigurationRequestContainersLivenessProbe {
	s.SuccessThreshold = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbe) SetTcpSocket(v *CreateEciScalingConfigurationRequestContainersLivenessProbeTcpSocket) *CreateEciScalingConfigurationRequestContainersLivenessProbe {
	s.TcpSocket = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbe) SetTimeoutSeconds(v int32) *CreateEciScalingConfigurationRequestContainersLivenessProbe {
	s.TimeoutSeconds = &v
	return s
}

type CreateEciScalingConfigurationRequestContainersLivenessProbeExec struct {
	Commands []*string `json:"Commands,omitempty" xml:"Commands,omitempty" type:"Repeated"`
}

func (s CreateEciScalingConfigurationRequestContainersLivenessProbeExec) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersLivenessProbeExec) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbeExec) SetCommands(v []*string) *CreateEciScalingConfigurationRequestContainersLivenessProbeExec {
	s.Commands = v
	return s
}

type CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet struct {
	Path   *string `json:"Path,omitempty" xml:"Path,omitempty"`
	Port   *int32  `json:"Port,omitempty" xml:"Port,omitempty"`
	Scheme *string `json:"Scheme,omitempty" xml:"Scheme,omitempty"`
}

func (s CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet) SetPath(v string) *CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet {
	s.Path = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet) SetPort(v int32) *CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet {
	s.Port = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet) SetScheme(v string) *CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet {
	s.Scheme = &v
	return s
}

type CreateEciScalingConfigurationRequestContainersLivenessProbeTcpSocket struct {
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
}

func (s CreateEciScalingConfigurationRequestContainersLivenessProbeTcpSocket) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersLivenessProbeTcpSocket) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbeTcpSocket) SetPort(v int32) *CreateEciScalingConfigurationRequestContainersLivenessProbeTcpSocket {
	s.Port = &v
	return s
}

type CreateEciScalingConfigurationRequestContainersReadinessProbe struct {
	Exec                *CreateEciScalingConfigurationRequestContainersReadinessProbeExec      `json:"Exec,omitempty" xml:"Exec,omitempty" type:"Struct"`
	FailureThreshold    *int32                                                                 `json:"FailureThreshold,omitempty" xml:"FailureThreshold,omitempty"`
	HttpGet             *CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet   `json:"HttpGet,omitempty" xml:"HttpGet,omitempty" type:"Struct"`
	InitialDelaySeconds *int32                                                                 `json:"InitialDelaySeconds,omitempty" xml:"InitialDelaySeconds,omitempty"`
	PeriodSeconds       *int32                                                                 `json:"PeriodSeconds,omitempty" xml:"PeriodSeconds,omitempty"`
	SuccessThreshold    *int32                                                                 `json:"SuccessThreshold,omitempty" xml:"SuccessThreshold,omitempty"`
	TcpSocket           *CreateEciScalingConfigurationRequestContainersReadinessProbeTcpSocket `json:"TcpSocket,omitempty" xml:"TcpSocket,omitempty" type:"Struct"`
	TimeoutSeconds      *int32                                                                 `json:"TimeoutSeconds,omitempty" xml:"TimeoutSeconds,omitempty"`
}

func (s CreateEciScalingConfigurationRequestContainersReadinessProbe) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersReadinessProbe) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbe) SetExec(v *CreateEciScalingConfigurationRequestContainersReadinessProbeExec) *CreateEciScalingConfigurationRequestContainersReadinessProbe {
	s.Exec = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbe) SetFailureThreshold(v int32) *CreateEciScalingConfigurationRequestContainersReadinessProbe {
	s.FailureThreshold = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbe) SetHttpGet(v *CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet) *CreateEciScalingConfigurationRequestContainersReadinessProbe {
	s.HttpGet = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbe) SetInitialDelaySeconds(v int32) *CreateEciScalingConfigurationRequestContainersReadinessProbe {
	s.InitialDelaySeconds = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbe) SetPeriodSeconds(v int32) *CreateEciScalingConfigurationRequestContainersReadinessProbe {
	s.PeriodSeconds = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbe) SetSuccessThreshold(v int32) *CreateEciScalingConfigurationRequestContainersReadinessProbe {
	s.SuccessThreshold = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbe) SetTcpSocket(v *CreateEciScalingConfigurationRequestContainersReadinessProbeTcpSocket) *CreateEciScalingConfigurationRequestContainersReadinessProbe {
	s.TcpSocket = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbe) SetTimeoutSeconds(v int32) *CreateEciScalingConfigurationRequestContainersReadinessProbe {
	s.TimeoutSeconds = &v
	return s
}

type CreateEciScalingConfigurationRequestContainersReadinessProbeExec struct {
	Commands []*string `json:"Commands,omitempty" xml:"Commands,omitempty" type:"Repeated"`
}

func (s CreateEciScalingConfigurationRequestContainersReadinessProbeExec) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersReadinessProbeExec) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbeExec) SetCommands(v []*string) *CreateEciScalingConfigurationRequestContainersReadinessProbeExec {
	s.Commands = v
	return s
}

type CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet struct {
	Path   *string `json:"Path,omitempty" xml:"Path,omitempty"`
	Port   *int32  `json:"Port,omitempty" xml:"Port,omitempty"`
	Scheme *string `json:"Scheme,omitempty" xml:"Scheme,omitempty"`
}

func (s CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet) SetPath(v string) *CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet {
	s.Path = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet) SetPort(v int32) *CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet {
	s.Port = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet) SetScheme(v string) *CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet {
	s.Scheme = &v
	return s
}

type CreateEciScalingConfigurationRequestContainersReadinessProbeTcpSocket struct {
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
}

func (s CreateEciScalingConfigurationRequestContainersReadinessProbeTcpSocket) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersReadinessProbeTcpSocket) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbeTcpSocket) SetPort(v int32) *CreateEciScalingConfigurationRequestContainersReadinessProbeTcpSocket {
	s.Port = &v
	return s
}

type CreateEciScalingConfigurationRequestContainersSecurityContext struct {
	Capability             *CreateEciScalingConfigurationRequestContainersSecurityContextCapability `json:"Capability,omitempty" xml:"Capability,omitempty" type:"Struct"`
	ReadOnlyRootFilesystem *bool                                                                    `json:"ReadOnlyRootFilesystem,omitempty" xml:"ReadOnlyRootFilesystem,omitempty"`
	RunAsUser              *int64                                                                   `json:"RunAsUser,omitempty" xml:"RunAsUser,omitempty"`
}

func (s CreateEciScalingConfigurationRequestContainersSecurityContext) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersSecurityContext) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersSecurityContext) SetCapability(v *CreateEciScalingConfigurationRequestContainersSecurityContextCapability) *CreateEciScalingConfigurationRequestContainersSecurityContext {
	s.Capability = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersSecurityContext) SetReadOnlyRootFilesystem(v bool) *CreateEciScalingConfigurationRequestContainersSecurityContext {
	s.ReadOnlyRootFilesystem = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersSecurityContext) SetRunAsUser(v int64) *CreateEciScalingConfigurationRequestContainersSecurityContext {
	s.RunAsUser = &v
	return s
}

type CreateEciScalingConfigurationRequestContainersSecurityContextCapability struct {
	Add []*string `json:"Add,omitempty" xml:"Add,omitempty" type:"Repeated"`
}

func (s CreateEciScalingConfigurationRequestContainersSecurityContextCapability) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersSecurityContextCapability) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersSecurityContextCapability) SetAdd(v []*string) *CreateEciScalingConfigurationRequestContainersSecurityContextCapability {
	s.Add = v
	return s
}

type CreateEciScalingConfigurationRequestContainersEnvironmentVars struct {
	// > This parameter is unavailable.
	FieldRefFieldPath *string `json:"FieldRefFieldPath,omitempty" xml:"FieldRefFieldPath,omitempty"`
	// The name of the environment variable. The name must be 1 to 128 characters in length and can contain letters, digits, and underscores (\_). The name cannot start with a digit. Specify the name in the \[0-9a-zA-Z] format.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the environment variable. The value must be 0 to 256 characters in length.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateEciScalingConfigurationRequestContainersEnvironmentVars) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersEnvironmentVars) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersEnvironmentVars) SetFieldRefFieldPath(v string) *CreateEciScalingConfigurationRequestContainersEnvironmentVars {
	s.FieldRefFieldPath = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersEnvironmentVars) SetKey(v string) *CreateEciScalingConfigurationRequestContainersEnvironmentVars {
	s.Key = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersEnvironmentVars) SetValue(v string) *CreateEciScalingConfigurationRequestContainersEnvironmentVars {
	s.Value = &v
	return s
}

type CreateEciScalingConfigurationRequestContainersPorts struct {
	// The port number. Valid values: 1 to 65535.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The type of the protocol. Valid values:
	//
	// *   TCP
	// *   UDP
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s CreateEciScalingConfigurationRequestContainersPorts) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersPorts) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersPorts) SetPort(v int32) *CreateEciScalingConfigurationRequestContainersPorts {
	s.Port = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersPorts) SetProtocol(v string) *CreateEciScalingConfigurationRequestContainersPorts {
	s.Protocol = &v
	return s
}

type CreateEciScalingConfigurationRequestContainersVolumeMounts struct {
	// The directory on which the container mounts the volume.
	//
	// > Data in this directory is overwritten by the data on the volume.
	MountPath *string `json:"MountPath,omitempty" xml:"MountPath,omitempty"`
	// The mount propagation settings of the volume. Mount propagation allows volumes that are mounted on one container to be shared with other containers in the same pod, or even with other pods on the same node. Valid values:
	//
	// *   None: The volume mount does not receive subsequent mounts that are mounted to this volume or its subdirectories.
	// *   HostToCotainer: The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories.
	// *   Bidirectional: This value is similar to HostToCotainer. The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories. In addition, all volume mounts that are created by the container are propagated back to the instance and to all containers of all pods that use the same volume.
	//
	// Default value: None.
	MountPropagation *string `json:"MountPropagation,omitempty" xml:"MountPropagation,omitempty"`
	// The name of the volume. The value of this parameter is the same as the value of the VolumeName parameter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Specifies whether the volume is read-only. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	ReadOnly *bool `json:"ReadOnly,omitempty" xml:"ReadOnly,omitempty"`
	// The subdirectory of the volume.
	SubPath *string `json:"SubPath,omitempty" xml:"SubPath,omitempty"`
}

func (s CreateEciScalingConfigurationRequestContainersVolumeMounts) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersVolumeMounts) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersVolumeMounts) SetMountPath(v string) *CreateEciScalingConfigurationRequestContainersVolumeMounts {
	s.MountPath = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersVolumeMounts) SetMountPropagation(v string) *CreateEciScalingConfigurationRequestContainersVolumeMounts {
	s.MountPropagation = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersVolumeMounts) SetName(v string) *CreateEciScalingConfigurationRequestContainersVolumeMounts {
	s.Name = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersVolumeMounts) SetReadOnly(v bool) *CreateEciScalingConfigurationRequestContainersVolumeMounts {
	s.ReadOnly = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersVolumeMounts) SetSubPath(v string) *CreateEciScalingConfigurationRequestContainersVolumeMounts {
	s.SubPath = &v
	return s
}

type CreateEciScalingConfigurationRequestDnsConfigOptions struct {
	// The variable name of the option.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The variable value of the option.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateEciScalingConfigurationRequestDnsConfigOptions) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestDnsConfigOptions) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestDnsConfigOptions) SetName(v string) *CreateEciScalingConfigurationRequestDnsConfigOptions {
	s.Name = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestDnsConfigOptions) SetValue(v string) *CreateEciScalingConfigurationRequestDnsConfigOptions {
	s.Value = &v
	return s
}

type CreateEciScalingConfigurationRequestHostAliases struct {
	// The hostname that you want to add.
	Hostnames []*string `json:"Hostnames,omitempty" xml:"Hostnames,omitempty" type:"Repeated"`
	// The IP address that you want to add.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
}

func (s CreateEciScalingConfigurationRequestHostAliases) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestHostAliases) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestHostAliases) SetHostnames(v []*string) *CreateEciScalingConfigurationRequestHostAliases {
	s.Hostnames = v
	return s
}

func (s *CreateEciScalingConfigurationRequestHostAliases) SetIp(v string) *CreateEciScalingConfigurationRequestHostAliases {
	s.Ip = &v
	return s
}

type CreateEciScalingConfigurationRequestImageRegistryCredentials struct {
	// The password that is used to access the image repository.
	Password *string `json:"Password,omitempty" xml:"Password,omitempty"`
	// The domain name of the image repository.
	Server *string `json:"Server,omitempty" xml:"Server,omitempty"`
	// The username that is used to access the image repository.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
}

func (s CreateEciScalingConfigurationRequestImageRegistryCredentials) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestImageRegistryCredentials) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestImageRegistryCredentials) SetPassword(v string) *CreateEciScalingConfigurationRequestImageRegistryCredentials {
	s.Password = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestImageRegistryCredentials) SetServer(v string) *CreateEciScalingConfigurationRequestImageRegistryCredentials {
	s.Server = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestImageRegistryCredentials) SetUserName(v string) *CreateEciScalingConfigurationRequestImageRegistryCredentials {
	s.UserName = &v
	return s
}

type CreateEciScalingConfigurationRequestInitContainers struct {
	SecurityContext *CreateEciScalingConfigurationRequestInitContainersSecurityContext `json:"SecurityContext,omitempty" xml:"SecurityContext,omitempty" type:"Struct"`
	// The arguments that correspond to the startup commands of the container. You can specify up to 10 arguments.
	Args []*string `json:"Args,omitempty" xml:"Args,omitempty" type:"Repeated"`
	// The list of commands that you want to run to start the container.
	Commands []*string `json:"Commands,omitempty" xml:"Commands,omitempty" type:"Repeated"`
	// The number of vCPUs that you want to allocate to the container.
	Cpu *float32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The number of GPUs that you want to allocate to the container.
	Gpu *int32 `json:"Gpu,omitempty" xml:"Gpu,omitempty"`
	// The container image.
	Image *string `json:"Image,omitempty" xml:"Image,omitempty"`
	// The image pulling policy.
	ImagePullPolicy *string `json:"ImagePullPolicy,omitempty" xml:"ImagePullPolicy,omitempty"`
	// The environment variables of the init container.
	InitContainerEnvironmentVars []*CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars `json:"InitContainerEnvironmentVars,omitempty" xml:"InitContainerEnvironmentVars,omitempty" type:"Repeated"`
	// The ports of the init container.
	InitContainerPorts []*CreateEciScalingConfigurationRequestInitContainersInitContainerPorts `json:"InitContainerPorts,omitempty" xml:"InitContainerPorts,omitempty" type:"Repeated"`
	// Information about the volume mounts of the init container.
	InitContainerVolumeMounts []*CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts `json:"InitContainerVolumeMounts,omitempty" xml:"InitContainerVolumeMounts,omitempty" type:"Repeated"`
	// The size of the memory. Unit: GiB.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The name of the container.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The working directory.
	WorkingDir *string `json:"WorkingDir,omitempty" xml:"WorkingDir,omitempty"`
}

func (s CreateEciScalingConfigurationRequestInitContainers) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestInitContainers) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetSecurityContext(v *CreateEciScalingConfigurationRequestInitContainersSecurityContext) *CreateEciScalingConfigurationRequestInitContainers {
	s.SecurityContext = v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetArgs(v []*string) *CreateEciScalingConfigurationRequestInitContainers {
	s.Args = v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetCommands(v []*string) *CreateEciScalingConfigurationRequestInitContainers {
	s.Commands = v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetCpu(v float32) *CreateEciScalingConfigurationRequestInitContainers {
	s.Cpu = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetGpu(v int32) *CreateEciScalingConfigurationRequestInitContainers {
	s.Gpu = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetImage(v string) *CreateEciScalingConfigurationRequestInitContainers {
	s.Image = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetImagePullPolicy(v string) *CreateEciScalingConfigurationRequestInitContainers {
	s.ImagePullPolicy = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetInitContainerEnvironmentVars(v []*CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) *CreateEciScalingConfigurationRequestInitContainers {
	s.InitContainerEnvironmentVars = v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetInitContainerPorts(v []*CreateEciScalingConfigurationRequestInitContainersInitContainerPorts) *CreateEciScalingConfigurationRequestInitContainers {
	s.InitContainerPorts = v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetInitContainerVolumeMounts(v []*CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) *CreateEciScalingConfigurationRequestInitContainers {
	s.InitContainerVolumeMounts = v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetMemory(v float32) *CreateEciScalingConfigurationRequestInitContainers {
	s.Memory = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetName(v string) *CreateEciScalingConfigurationRequestInitContainers {
	s.Name = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetWorkingDir(v string) *CreateEciScalingConfigurationRequestInitContainers {
	s.WorkingDir = &v
	return s
}

type CreateEciScalingConfigurationRequestInitContainersSecurityContext struct {
	Capability             *CreateEciScalingConfigurationRequestInitContainersSecurityContextCapability `json:"Capability,omitempty" xml:"Capability,omitempty" type:"Struct"`
	ReadOnlyRootFilesystem *bool                                                                        `json:"ReadOnlyRootFilesystem,omitempty" xml:"ReadOnlyRootFilesystem,omitempty"`
	RunAsUser              *int64                                                                       `json:"RunAsUser,omitempty" xml:"RunAsUser,omitempty"`
}

func (s CreateEciScalingConfigurationRequestInitContainersSecurityContext) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestInitContainersSecurityContext) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestInitContainersSecurityContext) SetCapability(v *CreateEciScalingConfigurationRequestInitContainersSecurityContextCapability) *CreateEciScalingConfigurationRequestInitContainersSecurityContext {
	s.Capability = v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainersSecurityContext) SetReadOnlyRootFilesystem(v bool) *CreateEciScalingConfigurationRequestInitContainersSecurityContext {
	s.ReadOnlyRootFilesystem = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainersSecurityContext) SetRunAsUser(v int64) *CreateEciScalingConfigurationRequestInitContainersSecurityContext {
	s.RunAsUser = &v
	return s
}

type CreateEciScalingConfigurationRequestInitContainersSecurityContextCapability struct {
	Adds []*string `json:"Adds,omitempty" xml:"Adds,omitempty" type:"Repeated"`
}

func (s CreateEciScalingConfigurationRequestInitContainersSecurityContextCapability) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestInitContainersSecurityContextCapability) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestInitContainersSecurityContextCapability) SetAdds(v []*string) *CreateEciScalingConfigurationRequestInitContainersSecurityContextCapability {
	s.Adds = v
	return s
}

type CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars struct {
	// > This parameter is unavailable.
	FieldRefFieldPath *string `json:"FieldRefFieldPath,omitempty" xml:"FieldRefFieldPath,omitempty"`
	// The key of the environment variable. Specify the key in the `[0-9a-zA-Z]` format. The key must be 1 to 128 characters in length. The key can contain underscores (\_) and cannot start with a digit.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the environment variable. The value must be 0 to 256 characters in length.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) SetFieldRefFieldPath(v string) *CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars {
	s.FieldRefFieldPath = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) SetKey(v string) *CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars {
	s.Key = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) SetValue(v string) *CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars {
	s.Value = &v
	return s
}

type CreateEciScalingConfigurationRequestInitContainersInitContainerPorts struct {
	// The port number. Valid values: 1 to 65535.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The type of the protocol. Valid values:
	//
	// *   TCP
	// *   UDP
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s CreateEciScalingConfigurationRequestInitContainersInitContainerPorts) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestInitContainersInitContainerPorts) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestInitContainersInitContainerPorts) SetPort(v int32) *CreateEciScalingConfigurationRequestInitContainersInitContainerPorts {
	s.Port = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainersInitContainerPorts) SetProtocol(v string) *CreateEciScalingConfigurationRequestInitContainersInitContainerPorts {
	s.Protocol = &v
	return s
}

type CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts struct {
	// The path to which the volume is mounted. Data under this path is overwritten by the data on the volume.
	MountPath *string `json:"MountPath,omitempty" xml:"MountPath,omitempty"`
	// The mount propagation settings of the volume . Mount propagation allows volumes that are mounted on one container to be shared with other containers in the same pod, or even with other pods on the same node. Valid values:
	//
	// *   None: The volume mount does not receive subsequent mounts that are mounted to this volume or its subdirectories.
	// *   HostToCotainer: The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories.
	// *   Bidirectional: This value is similar to HostToCotainer. The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories. In addition, all volume mounts that are created by the container are propagated back to the instance and to all containers of all pods that use the same volume.
	MountPropagation *string `json:"MountPropagation,omitempty" xml:"MountPropagation,omitempty"`
	// The name of the volume.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Specifies whether the mount path is read-only.
	//
	// Default value: false.
	ReadOnly *bool `json:"ReadOnly,omitempty" xml:"ReadOnly,omitempty"`
	// The subdirectory of the volume. The elastic container instance can mount different directories of the same volume to different subdirectories of containers.
	SubPath *string `json:"SubPath,omitempty" xml:"SubPath,omitempty"`
}

func (s CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) SetMountPath(v string) *CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts {
	s.MountPath = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) SetMountPropagation(v string) *CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts {
	s.MountPropagation = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) SetName(v string) *CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts {
	s.Name = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) SetReadOnly(v bool) *CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts {
	s.ReadOnly = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) SetSubPath(v string) *CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts {
	s.SubPath = &v
	return s
}

type CreateEciScalingConfigurationRequestSecurityContextSysctls struct {
	// The variable name of the security context in which the elastic container instance runs.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The variable value of the security context in which the elastic container instance runs.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateEciScalingConfigurationRequestSecurityContextSysctls) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestSecurityContextSysctls) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestSecurityContextSysctls) SetName(v string) *CreateEciScalingConfigurationRequestSecurityContextSysctls {
	s.Name = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestSecurityContextSysctls) SetValue(v string) *CreateEciScalingConfigurationRequestSecurityContextSysctls {
	s.Value = &v
	return s
}

type CreateEciScalingConfigurationRequestTags struct {
	// The tag key of the elastic container instance. You can specify 1 to 20 tags.
	//
	// You cannot specify an empty string as a tag key. The tag key can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value of the elastic container instance. You can specify 1 to 20 tags.
	//
	// You can specify an empty string as a tag value. The tag value can be up to 128 characters in length and cannot start with `acs:`. It cannot contain `http://` or `https://`.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateEciScalingConfigurationRequestTags) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestTags) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestTags) SetKey(v string) *CreateEciScalingConfigurationRequestTags {
	s.Key = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestTags) SetValue(v string) *CreateEciScalingConfigurationRequestTags {
	s.Value = &v
	return s
}

type CreateEciScalingConfigurationRequestVolumes struct {
	DiskVolume     *CreateEciScalingConfigurationRequestVolumesDiskVolume     `json:"DiskVolume,omitempty" xml:"DiskVolume,omitempty" type:"Struct"`
	EmptyDirVolume *CreateEciScalingConfigurationRequestVolumesEmptyDirVolume `json:"EmptyDirVolume,omitempty" xml:"EmptyDirVolume,omitempty" type:"Struct"`
	FlexVolume     *CreateEciScalingConfigurationRequestVolumesFlexVolume     `json:"FlexVolume,omitempty" xml:"FlexVolume,omitempty" type:"Struct"`
	HostPathVolume *CreateEciScalingConfigurationRequestVolumesHostPathVolume `json:"HostPathVolume,omitempty" xml:"HostPathVolume,omitempty" type:"Struct"`
	NFSVolume      *CreateEciScalingConfigurationRequestVolumesNFSVolume      `json:"NFSVolume,omitempty" xml:"NFSVolume,omitempty" type:"Struct"`
	// The paths to the configuration files.
	ConfigFileVolumeConfigFileToPaths []*CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths `json:"ConfigFileVolumeConfigFileToPaths,omitempty" xml:"ConfigFileVolumeConfigFileToPaths,omitempty" type:"Repeated"`
	// The default permissions on the ConfigFile volume.
	ConfigFileVolumeDefaultMode *int32 `json:"ConfigFileVolumeDefaultMode,omitempty" xml:"ConfigFileVolumeDefaultMode,omitempty"`
	// The name of the volume.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the Host file or path. Examples: File, Directory, and Socket.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateEciScalingConfigurationRequestVolumes) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestVolumes) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestVolumes) SetDiskVolume(v *CreateEciScalingConfigurationRequestVolumesDiskVolume) *CreateEciScalingConfigurationRequestVolumes {
	s.DiskVolume = v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumes) SetEmptyDirVolume(v *CreateEciScalingConfigurationRequestVolumesEmptyDirVolume) *CreateEciScalingConfigurationRequestVolumes {
	s.EmptyDirVolume = v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumes) SetFlexVolume(v *CreateEciScalingConfigurationRequestVolumesFlexVolume) *CreateEciScalingConfigurationRequestVolumes {
	s.FlexVolume = v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumes) SetHostPathVolume(v *CreateEciScalingConfigurationRequestVolumesHostPathVolume) *CreateEciScalingConfigurationRequestVolumes {
	s.HostPathVolume = v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumes) SetNFSVolume(v *CreateEciScalingConfigurationRequestVolumesNFSVolume) *CreateEciScalingConfigurationRequestVolumes {
	s.NFSVolume = v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumes) SetConfigFileVolumeConfigFileToPaths(v []*CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths) *CreateEciScalingConfigurationRequestVolumes {
	s.ConfigFileVolumeConfigFileToPaths = v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumes) SetConfigFileVolumeDefaultMode(v int32) *CreateEciScalingConfigurationRequestVolumes {
	s.ConfigFileVolumeDefaultMode = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumes) SetName(v string) *CreateEciScalingConfigurationRequestVolumes {
	s.Name = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumes) SetType(v string) *CreateEciScalingConfigurationRequestVolumes {
	s.Type = &v
	return s
}

type CreateEciScalingConfigurationRequestVolumesDiskVolume struct {
	DiskId   *string `json:"DiskId,omitempty" xml:"DiskId,omitempty"`
	DiskSize *int32  `json:"DiskSize,omitempty" xml:"DiskSize,omitempty"`
	FsType   *string `json:"FsType,omitempty" xml:"FsType,omitempty"`
}

func (s CreateEciScalingConfigurationRequestVolumesDiskVolume) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestVolumesDiskVolume) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestVolumesDiskVolume) SetDiskId(v string) *CreateEciScalingConfigurationRequestVolumesDiskVolume {
	s.DiskId = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumesDiskVolume) SetDiskSize(v int32) *CreateEciScalingConfigurationRequestVolumesDiskVolume {
	s.DiskSize = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumesDiskVolume) SetFsType(v string) *CreateEciScalingConfigurationRequestVolumesDiskVolume {
	s.FsType = &v
	return s
}

type CreateEciScalingConfigurationRequestVolumesEmptyDirVolume struct {
	Medium    *string `json:"Medium,omitempty" xml:"Medium,omitempty"`
	SizeLimit *string `json:"SizeLimit,omitempty" xml:"SizeLimit,omitempty"`
}

func (s CreateEciScalingConfigurationRequestVolumesEmptyDirVolume) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestVolumesEmptyDirVolume) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestVolumesEmptyDirVolume) SetMedium(v string) *CreateEciScalingConfigurationRequestVolumesEmptyDirVolume {
	s.Medium = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumesEmptyDirVolume) SetSizeLimit(v string) *CreateEciScalingConfigurationRequestVolumesEmptyDirVolume {
	s.SizeLimit = &v
	return s
}

type CreateEciScalingConfigurationRequestVolumesFlexVolume struct {
	Driver  *string `json:"Driver,omitempty" xml:"Driver,omitempty"`
	FsType  *string `json:"FsType,omitempty" xml:"FsType,omitempty"`
	Options *string `json:"Options,omitempty" xml:"Options,omitempty"`
}

func (s CreateEciScalingConfigurationRequestVolumesFlexVolume) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestVolumesFlexVolume) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestVolumesFlexVolume) SetDriver(v string) *CreateEciScalingConfigurationRequestVolumesFlexVolume {
	s.Driver = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumesFlexVolume) SetFsType(v string) *CreateEciScalingConfigurationRequestVolumesFlexVolume {
	s.FsType = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumesFlexVolume) SetOptions(v string) *CreateEciScalingConfigurationRequestVolumesFlexVolume {
	s.Options = &v
	return s
}

type CreateEciScalingConfigurationRequestVolumesHostPathVolume struct {
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateEciScalingConfigurationRequestVolumesHostPathVolume) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestVolumesHostPathVolume) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestVolumesHostPathVolume) SetPath(v string) *CreateEciScalingConfigurationRequestVolumesHostPathVolume {
	s.Path = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumesHostPathVolume) SetType(v string) *CreateEciScalingConfigurationRequestVolumesHostPathVolume {
	s.Type = &v
	return s
}

type CreateEciScalingConfigurationRequestVolumesNFSVolume struct {
	Path     *string `json:"Path,omitempty" xml:"Path,omitempty"`
	ReadOnly *bool   `json:"ReadOnly,omitempty" xml:"ReadOnly,omitempty"`
	Server   *string `json:"Server,omitempty" xml:"Server,omitempty"`
}

func (s CreateEciScalingConfigurationRequestVolumesNFSVolume) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestVolumesNFSVolume) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestVolumesNFSVolume) SetPath(v string) *CreateEciScalingConfigurationRequestVolumesNFSVolume {
	s.Path = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumesNFSVolume) SetReadOnly(v bool) *CreateEciScalingConfigurationRequestVolumesNFSVolume {
	s.ReadOnly = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumesNFSVolume) SetServer(v string) *CreateEciScalingConfigurationRequestVolumesNFSVolume {
	s.Server = &v
	return s
}

type CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths struct {
	// The content of the configuration file, which can be up to 32 KB in size.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The permissions on ConfigFileVolume.
	Mode *int32 `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The name of the environment variable. The name must be 1 to 128 characters in length. Specify the name in the `[0-9a-zA-Z]` format. The name can contain underscores and cannot start with a digit.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths) SetContent(v string) *CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths {
	s.Content = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths) SetMode(v int32) *CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths {
	s.Mode = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths) SetPath(v string) *CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths {
	s.Path = &v
	return s
}

type CreateEciScalingConfigurationResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the elastic container instance.
	ScalingConfigurationId *string `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
}

func (s CreateEciScalingConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationResponseBody) SetRequestId(v string) *CreateEciScalingConfigurationResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateEciScalingConfigurationResponseBody) SetScalingConfigurationId(v string) *CreateEciScalingConfigurationResponseBody {
	s.ScalingConfigurationId = &v
	return s
}

type CreateEciScalingConfigurationResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateEciScalingConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateEciScalingConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationResponse) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationResponse) SetHeaders(v map[string]*string) *CreateEciScalingConfigurationResponse {
	s.Headers = v
	return s
}

func (s *CreateEciScalingConfigurationResponse) SetStatusCode(v int32) *CreateEciScalingConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateEciScalingConfigurationResponse) SetBody(v *CreateEciScalingConfigurationResponseBody) *CreateEciScalingConfigurationResponse {
	s.Body = v
	return s
}

type CreateLifecycleHookRequest struct {
	// The action that you want Auto Scaling to perform after the lifecycle hook times out. Valid values:
	//
	// *   CONTINUE: Auto Scaling continues to respond to scale-in or scale-out requests.
	// *   ABANDON: Auto Scaling releases ECS instances that are created during scale-out activities or removes ECS instances from the scaling group during scale-in activities.
	// *   ROLLBACK: For scale-in activities, Auto Scaling rejects the requests to release ECS instances but rolls back ECS instances. For scale-out activities, the ROLLBACK setting has the same effect as the ABANDON setting.
	//
	// If a scaling group has multiple lifecycle hooks in effect and you set the DefaultResult parameter for one of the lifecycle hooks to ABANDON or ROLLBACK, the following rule applies to scale-in activities: When the lifecycle hook whose DefaultResult parameter is set to ABANDON or ROLLBACK times out, other lifecycle hooks time out ahead of schedule. In other cases, Auto Scaling performs the action only after all lifecycle hooks time out. The action that Auto Scaling performs is specified by the DefaultResult parameter of the last lifecycle hook that times out.
	//
	// Default value: CONTINUE.
	DefaultResult *string `json:"DefaultResult,omitempty" xml:"DefaultResult,omitempty"`
	// The period of time before the lifecycle hook times out. When the lifecycle hook times out, Auto Scaling performs the action specified by the DefaultResult parameter. Valid values: 30 to 21600. Unit: seconds.
	//
	// After you create a lifecycle hook, you can call the RecordLifecycleActionHeartbeat operation to extend the timeout period of the lifecycle hook. You can also call the CompleteLifecycleAction operation to end the timeout period ahead of schedule.
	//
	// Default value: 600.
	HeartbeatTimeout *int32 `json:"HeartbeatTimeout,omitempty" xml:"HeartbeatTimeout,omitempty"`
	// The name of the lifecycle hook. Each lifecycle hook name must be unique within a scaling group. The name must be 2 to 64 characters in length, and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). The name must start with a letter or a digit.
	//
	// If you do not specify this parameter, the value of the LifecycleHookId parameter is used.
	LifecycleHookName *string `json:"LifecycleHookName,omitempty" xml:"LifecycleHookName,omitempty"`
	// The type of the scaling activity to which you want to apply the lifecycle hook. Valid values:
	//
	// *   SCALE_OUT: scale-out activity.
	// *   SCALE_IN: scale-in activity.
	LifecycleTransition *string `json:"LifecycleTransition,omitempty" xml:"LifecycleTransition,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the notification method. If you do not specify this parameter, no notification is sent when the lifecycle hook takes effect. If you specify this parameter, the following rules apply:
	//
	// *   If you use a Message Service (MNS) queue as the notification method, specify the value in the acs:mns:{region-id}:{account-id}:queue/{queuename} format.
	// *   If you use an MNS topic as the notification method, specify the value in the acs:mns:{region-id}:{account-id}:topic/{topicname} format.
	// *   If you use an OOS template as the notification method, specify the value in the acs:oos:{region-id}:{account-id}:template/{templatename} format.
	//
	// The variables in the preceding formats have the following meanings:
	//
	// *   region-id: the region ID of the scaling group.
	// *   account-id: the ID of the Alibaba Cloud account. The ID of a RAM user is not supported.
	// *   queuename: the name of the MNS queue.
	// *   topicname: the name of the MNS topic.
	// *   templatename: the name of the OOS template.
	NotificationArn *string `json:"NotificationArn,omitempty" xml:"NotificationArn,omitempty"`
	// The notification metadata that is sent when the lifecycle hook takes effect. This helps you manage and categorize notifications in an efficient manner. If you specify this parameter, you must also specify the NotificationArn parameter. The value of this parameter cannot exceed 4,096 characters in length.
	//
	// The fixed string that is included in a notification that Auto Scaling sends when the lifecycle hook takes effect. Auto Scaling sends the value of the NotificationMetadata parameter together with the notification. This helps you categorize your notifications. For example, your OOS template includes the following parameters: `{"dbInstanceId": "dds-bp17661e0135****", "modifyMode": "Append"}`, `dbInstanceId`, and `modifyMode`. Specific parameters that are defined in your OOS template have default values. When you specify the NotificationMetadata parameter, specify parameters that do not have default values. If you specify parameters that have default values, the default values are overwritten. The default values of the following parameters must be retained to obtain information about scaling activities that are in progress:
	//
	// *   `regionId`: the region ID of the scaling activity that is in progress. Default value: ${regionId}.
	// *   `instanceIds`: the IDs of ECS instances that are scaled in the scaling activity. Default value: ${instanceIds}.
	// *   `lifecycleHookId`: the ID of the lifecycle hook. Default value: ${lifecycleHookId}.
	// *   `lifecycleActionToken`: the token of the lifecycle hook. You can use the token to end the timeout period of the lifecycle hook ahead of schedule. Default value: ${lifecycleActionToken}
	// *   `scalingGroupId`: the ID of the scaling group in which the scaling activity is executed. Default value: ${scalingGroupId}.
	// *   `lifecycleActionResult`: the action that Auto Scaling performs after the lifecycle hook times out. If the OOS template fails to be executed, the lifecycle hook times out ahead of schedule. If you set the DefalutResult parameter to ROLLBACK, the default value of this parameter is ROLLBACK. If you set the DefaultResult parameter to other values, the default value of this parameter is ABANDON.
	//
	// >
	//
	// *   You can specify a value for the lifecycleActionResult parameter to overwrite the default value. Valid values: ABANDON, CONTINUE, ROLLBACK, and ${lifecycleActionResult}.
	//
	// A value of ${lifecycleActionResult} specifies that the value of the lifecycleActionResult parameter is the same as the value of the DefaultResult parameter.
	//
	// *   You can view the details of the OOS template that you specify in the [OOS](https://oos.console.aliyun.com/) console.
	NotificationMetadata *string `json:"NotificationMetadata,omitempty" xml:"NotificationMetadata,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s CreateLifecycleHookRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateLifecycleHookRequest) GoString() string {
	return s.String()
}

func (s *CreateLifecycleHookRequest) SetDefaultResult(v string) *CreateLifecycleHookRequest {
	s.DefaultResult = &v
	return s
}

func (s *CreateLifecycleHookRequest) SetHeartbeatTimeout(v int32) *CreateLifecycleHookRequest {
	s.HeartbeatTimeout = &v
	return s
}

func (s *CreateLifecycleHookRequest) SetLifecycleHookName(v string) *CreateLifecycleHookRequest {
	s.LifecycleHookName = &v
	return s
}

func (s *CreateLifecycleHookRequest) SetLifecycleTransition(v string) *CreateLifecycleHookRequest {
	s.LifecycleTransition = &v
	return s
}

func (s *CreateLifecycleHookRequest) SetNotificationArn(v string) *CreateLifecycleHookRequest {
	s.NotificationArn = &v
	return s
}

func (s *CreateLifecycleHookRequest) SetNotificationMetadata(v string) *CreateLifecycleHookRequest {
	s.NotificationMetadata = &v
	return s
}

func (s *CreateLifecycleHookRequest) SetOwnerAccount(v string) *CreateLifecycleHookRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateLifecycleHookRequest) SetOwnerId(v int64) *CreateLifecycleHookRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateLifecycleHookRequest) SetResourceOwnerAccount(v string) *CreateLifecycleHookRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateLifecycleHookRequest) SetScalingGroupId(v string) *CreateLifecycleHookRequest {
	s.ScalingGroupId = &v
	return s
}

type CreateLifecycleHookResponseBody struct {
	// The ID of the lifecycle hook.
	LifecycleHookId *string `json:"LifecycleHookId,omitempty" xml:"LifecycleHookId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateLifecycleHookResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateLifecycleHookResponseBody) GoString() string {
	return s.String()
}

func (s *CreateLifecycleHookResponseBody) SetLifecycleHookId(v string) *CreateLifecycleHookResponseBody {
	s.LifecycleHookId = &v
	return s
}

func (s *CreateLifecycleHookResponseBody) SetRequestId(v string) *CreateLifecycleHookResponseBody {
	s.RequestId = &v
	return s
}

type CreateLifecycleHookResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateLifecycleHookResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateLifecycleHookResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateLifecycleHookResponse) GoString() string {
	return s.String()
}

func (s *CreateLifecycleHookResponse) SetHeaders(v map[string]*string) *CreateLifecycleHookResponse {
	s.Headers = v
	return s
}

func (s *CreateLifecycleHookResponse) SetStatusCode(v int32) *CreateLifecycleHookResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateLifecycleHookResponse) SetBody(v *CreateLifecycleHookResponseBody) *CreateLifecycleHookResponse {
	s.Body = v
	return s
}

type CreateNotificationConfigurationRequest struct {
	// The Alibaba Cloud Resource Name (ARN) of the notification method. The following list describes the value formats of this parameter:
	//
	// *   If you use CloudMonitor as the notification method, the value format of this parameter is acs:ess:{region-id}:{account-id}:cloudmonitor.
	// *   If you use an MNS queue as the notification method, the value format of this parameter is acs:mns:{region-id}:{account-id}:queue/{queuename}.
	// *   If you use an MNS topic as the notification method, the value format of this parameter is acs:mns:{region-id}:{account-id}:topic/{topicname}.
	//
	// The variables in the preceding formats have the following meanings:
	//
	// *   region-id: the region ID of the scaling group.
	// *   account-id: the ID of the Alibaba Cloud account.
	// *   queuename: the name of the MNS queue.
	// *   topicname: the name of the MNS topic.
	NotificationArn *string `json:"NotificationArn,omitempty" xml:"NotificationArn,omitempty"`
	// The types of the notifications that you want to create. You can create one to eight notifications. Specify multiple values in the repeated list form.
	//
	// You can call the DescribeNotificationTypes operation to query the values of this parameter.
	NotificationTypes []*string `json:"NotificationTypes,omitempty" xml:"NotificationTypes,omitempty" type:"Repeated"`
	OwnerId           *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s CreateNotificationConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateNotificationConfigurationRequest) GoString() string {
	return s.String()
}

func (s *CreateNotificationConfigurationRequest) SetNotificationArn(v string) *CreateNotificationConfigurationRequest {
	s.NotificationArn = &v
	return s
}

func (s *CreateNotificationConfigurationRequest) SetNotificationTypes(v []*string) *CreateNotificationConfigurationRequest {
	s.NotificationTypes = v
	return s
}

func (s *CreateNotificationConfigurationRequest) SetOwnerId(v int64) *CreateNotificationConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateNotificationConfigurationRequest) SetRegionId(v string) *CreateNotificationConfigurationRequest {
	s.RegionId = &v
	return s
}

func (s *CreateNotificationConfigurationRequest) SetResourceOwnerAccount(v string) *CreateNotificationConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateNotificationConfigurationRequest) SetScalingGroupId(v string) *CreateNotificationConfigurationRequest {
	s.ScalingGroupId = &v
	return s
}

type CreateNotificationConfigurationResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateNotificationConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateNotificationConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *CreateNotificationConfigurationResponseBody) SetRequestId(v string) *CreateNotificationConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type CreateNotificationConfigurationResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateNotificationConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateNotificationConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateNotificationConfigurationResponse) GoString() string {
	return s.String()
}

func (s *CreateNotificationConfigurationResponse) SetHeaders(v map[string]*string) *CreateNotificationConfigurationResponse {
	s.Headers = v
	return s
}

func (s *CreateNotificationConfigurationResponse) SetStatusCode(v int32) *CreateNotificationConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateNotificationConfigurationResponse) SetBody(v *CreateNotificationConfigurationResponseBody) *CreateNotificationConfigurationResponse {
	s.Body = v
	return s
}

type CreateScalingConfigurationRequest struct {
	ImageOptions       *CreateScalingConfigurationRequestImageOptions       `json:"ImageOptions,omitempty" xml:"ImageOptions,omitempty" type:"Struct"`
	PrivatePoolOptions *CreateScalingConfigurationRequestPrivatePoolOptions `json:"PrivatePoolOptions,omitempty" xml:"PrivatePoolOptions,omitempty" type:"Struct"`
	SystemDisk         *CreateScalingConfigurationRequestSystemDisk         `json:"SystemDisk,omitempty" xml:"SystemDisk,omitempty" type:"Struct"`
	// Specifies whether to associate an ECS instance on a dedicated host with the dedicated host. Valid values:
	//
	// *   default: does not associate the ECS instance with the dedicated host. If you start an ECS instance that was stopped in economical mode and the original dedicated host has insufficient resources, the ECS instance is automatically deployed to another dedicated host in the automatic deployment resource pool.
	// *   host: associates the ECS instance with the dedicated host. If you start an ECS instance that was stopped in economical mode, the instance remains on the original dedicated host. If the original dedicated host has insufficient resources, the ECS instance fails to start.
	//
	// Default value: default
	Affinity *string `json:"Affinity,omitempty" xml:"Affinity,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see the "[How to ensure the idempotence of a request](~~25693~~)" topic.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The number of vCPUs.
	//
	// You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set CPU to 2 and Memory to 16 to specify instance types that have 2 vCPUs and 16 GiB of memory. If you specify Cpu and Memory, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances by using the lowest-priced instance type.
	//
	// > You can specify Cpu and Memory to determine the range of instance types only if you set Scaling Policy to Cost Optimization Policy and you do not specify instance types in the scaling configuration.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The performance mode of the burstable instance. Valid values:
	//
	// *   Standard: standard mode
	// *   Unlimited: unlimited mode
	//
	// For more information, see the "Performance modes" section in the "[Overview](~~59977~~)" topic.
	CreditSpecification *string `json:"CreditSpecification,omitempty" xml:"CreditSpecification,omitempty"`
	// The data disks.
	DataDisks []*CreateScalingConfigurationRequestDataDisks `json:"DataDisks,omitempty" xml:"DataDisks,omitempty" type:"Repeated"`
	// The ID of the dedicated host on which you want to create an ECS instance. You cannot create preemptible instances on dedicated hosts. If you specify DedicatedHostId, SpotStrategy and SpotPriceLimit are ignored.
	//
	// You can call the DescribeDedicatedHosts operation to query dedicated host IDs.
	DedicatedHostId    *string `json:"DedicatedHostId,omitempty" xml:"DedicatedHostId,omitempty"`
	DeletionProtection *bool   `json:"DeletionProtection,omitempty" xml:"DeletionProtection,omitempty"`
	// The ID of the deployment set of the ECS instances that are created by using the scaling configuration.
	DeploymentSetId *string `json:"DeploymentSetId,omitempty" xml:"DeploymentSetId,omitempty"`
	// The hostname of the ECS instance. The hostname cannot start or end with a period (.) or a hyphen (-). The hostname cannot contain consecutive periods (.) or hyphens (-). Naming conventions for different types of instances:
	//
	// *   Windows instances: The hostname must be 2 to 15 characters in length and can contain letters, digits, and hyphens (-). The hostname cannot contain periods (.) or contain only digits.
	// *   Other instances, such as Linux instances: The hostname must be 2 to 64 characters in length. You can use periods (.) to separate a hostname into multiple segments. Each segment can contain letters, digits, and hyphens (-).
	HostName *string `json:"HostName,omitempty" xml:"HostName,omitempty"`
	// The ID of the Elastic High Performance Computing (E-HPC) cluster to which the ECS instances that are created by using the scaling configuration belong.
	HpcClusterId *string `json:"HpcClusterId,omitempty" xml:"HpcClusterId,omitempty"`
	// The name of the image family. If you specify this parameter, the most recent custom images that are available in the specified image family are returned. You can use the images to create instances. If you specify ImageId, you cannot specify ImageFamily.
	ImageFamily *string `json:"ImageFamily,omitempty" xml:"ImageFamily,omitempty"`
	// The ID of the image that Auto Scaling uses to automatically create ECS instances.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The name of the image. Each image name must be unique in a region. If you specify ImageId, ImageName is ignored.
	//
	// You cannot use ImageName to specify images that are purchased from Alibaba Cloud Marketplace.
	ImageName *string `json:"ImageName,omitempty" xml:"ImageName,omitempty"`
	// The description of the ECS instance. The description must be 2 to 256 characters in length. The description can contain letters and cannot start with `http://` or `https://`.
	InstanceDescription *string `json:"InstanceDescription,omitempty" xml:"InstanceDescription,omitempty"`
	// The name of the ECS instance that Auto Scaling creates based on the scaling configuration.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// Details of the intelligent configuration settings that determine the range of instance types that meet the specified criteria.
	InstancePatternInfos []*CreateScalingConfigurationRequestInstancePatternInfos `json:"InstancePatternInfos,omitempty" xml:"InstancePatternInfos,omitempty" type:"Repeated"`
	// The instance type of the ECS instance. For more information, see the "Instance families" topic.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The instance types.
	InstanceTypeOverrides []*CreateScalingConfigurationRequestInstanceTypeOverrides `json:"InstanceTypeOverrides,omitempty" xml:"InstanceTypeOverrides,omitempty" type:"Repeated"`
	// The instance types. If you specify InstanceTypes, InstanceType is ignored.
	//
	// Auto Scaling creates instances based on the priorities of the instance types. If Auto Scaling cannot create instances by using the instance type that has the highest priority, Auto Scaling creates instances by using the instance type that has the next highest priority.
	InstanceTypes []*string `json:"InstanceTypes,omitempty" xml:"InstanceTypes,omitempty" type:"Repeated"`
	// The metering method for network usage. Valid values:
	//
	// *   PayByBandwidth: You are charged for the maximum available bandwidth that is specified by InternetMaxBandwidthOut.
	// *   PayByTraffic: You are charged based on the amount of transferred data. InternetMaxBandwidthOut specifies only the maximum available bandwidth.
	//
	// For the classic network, the default value is PayByBandwidth. For VPCs, the default value is PayByTraffic.
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The maximum inbound public bandwidth. Unit: Mbit/s. Valid values: 1 to 200.
	//
	// Default value: 200 This parameter is not used for billing because inbound traffic to instances is free of charge.
	InternetMaxBandwidthIn *int32 `json:"InternetMaxBandwidthIn,omitempty" xml:"InternetMaxBandwidthIn,omitempty"`
	// The maximum outbound public bandwidth. Unit: Mbit/s. Valid values:
	//
	// *   Valid values if you set InternetChargeType to PayByBandwidth: 0 to 100. If you leave this parameter empty, this parameter is automatically set to 0.
	// *   Valid values if you set InternetChargeType to PayByTraffic: 0 to 100. If you leave this parameter empty, an error is returned.
	InternetMaxBandwidthOut *int32 `json:"InternetMaxBandwidthOut,omitempty" xml:"InternetMaxBandwidthOut,omitempty"`
	// Specifies whether to create an I/O optimized instance. Valid values:
	//
	// none: does not create an I/O optimized instance. optimized: creates an I/O optimized instance.
	//
	// For instances of retired instance types, the default value is none. For instances of other instance types, the default value is optimized.
	IoOptimized *string `json:"IoOptimized,omitempty" xml:"IoOptimized,omitempty"`
	// The number of randomly generated IPv6 addresses that you want to allocate to the elastic network interface (ENI).
	Ipv6AddressCount *int32 `json:"Ipv6AddressCount,omitempty" xml:"Ipv6AddressCount,omitempty"`
	// The name of the key pair that you want to use to log on to an ECS instance.
	//
	// *   Windows instances do not support this parameter.
	// *   By default, the username and password authentication method is disabled for Linux instances.
	KeyPairName *string `json:"KeyPairName,omitempty" xml:"KeyPairName,omitempty"`
	// The weight of an ECS instance as a backend server. Valid values: 1 to 100.
	//
	// Default value: 50
	LoadBalancerWeight *int32 `json:"LoadBalancerWeight,omitempty" xml:"LoadBalancerWeight,omitempty"`
	// The memory size. Unit: GiB.
	//
	// You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set Cpu to 2 and Memory to 16 to specify instance types that have 2 vCPUs and 16 GiB of memory. If you specify Cpu and Memory, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances by using the lowest-priced instance type.
	//
	// > You can specify Cpu and Memory to determine the range of instance types only if you set Scaling Policy to Cost Optimization Policy and you do not specify instance types in the scaling configuration.
	Memory       *int32  `json:"Memory,omitempty" xml:"Memory,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The password that you want to use to log on to an ECS instance. The password must be 8 to 30 characters in length and must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. The following special characters are supported:
	//
	// `` `() ~!@#$%^&*-_+=\|{}[]:;\"<>,.?/ ``
	//
	// The password of a Windows instance cannot start with a forward slash (/).
	//
	// > For security reasons, we recommend that you use HTTPS to send requests if you specify Password.
	Password *string `json:"Password,omitempty" xml:"Password,omitempty"`
	// Specifies whether to use the password that is preconfigured in the image. Before you use this parameter, make sure that a password is configured in the image. Valid values:
	//
	// *   true
	// *   false
	PasswordInherit *bool `json:"PasswordInherit,omitempty" xml:"PasswordInherit,omitempty"`
	// The name of the RAM role that you attach to the ECS instance. The name is provided and maintained by Resource Access Management (RAM). You can call the ListRoles operation to query the available RAM roles.
	RamRoleName *string `json:"RamRoleName,omitempty" xml:"RamRoleName,omitempty"`
	// The ID of the resource group to which the ECS instances that are created by using the scaling configuration belong.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The name of the scaling configuration. The name must be 2 to 64 characters in length and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). The name must start with a letter or a digit.
	//
	// The name of the scaling configuration must be unique in a region. If you do not specify this parameter, the scaling configuration ID is used.
	ScalingConfigurationName *string `json:"ScalingConfigurationName,omitempty" xml:"ScalingConfigurationName,omitempty"`
	// The ID of the scaling group in which you want to create a scaling configuration.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The scheduler options.
	SchedulerOptions map[string]interface{} `json:"SchedulerOptions,omitempty" xml:"SchedulerOptions,omitempty"`
	// Specifies whether to enable security hardening. Valid values:
	//
	// *   Active: enables security hardening. This value is applicable only to public images.
	// *   Deactive: disables security hardening. This value is applicable to all image types.
	SecurityEnhancementStrategy *string `json:"SecurityEnhancementStrategy,omitempty" xml:"SecurityEnhancementStrategy,omitempty"`
	// The ID of the security group with which ECS instances are associated. ECS instances that are associated with the same security group can access each other.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// The IDs of the security groups with which you want to associate the ECS instances that are created by using the scaling configuration. For more information, see the "Security group limits" section of the "[Limits](~~25412~~)" topic.
	//
	// > If you specify SecurityGroupId, you cannot specify SecurityGroupIds.
	SecurityGroupIds []*string `json:"SecurityGroupIds,omitempty" xml:"SecurityGroupIds,omitempty" type:"Repeated"`
	// The retention period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.
	//
	// *   The following retention periods are available in invitational preview: 2, 3, 4, 5, and 6 hours. If you want to set this parameter to one of these values, submit a ticket.
	// *   If you set this parameter to 0, no protection period is specified for the preemptible instance.
	//
	// Default value: 1
	SpotDuration *int32 `json:"SpotDuration,omitempty" xml:"SpotDuration,omitempty"`
	// The interruption mode of the preemptible instance. Set the value to Terminate. The value specifies that the preemptible instance is to be released.
	SpotInterruptionBehavior *string `json:"SpotInterruptionBehavior,omitempty" xml:"SpotInterruptionBehavior,omitempty"`
	// The billing information of the preemptible instances.
	SpotPriceLimits []*CreateScalingConfigurationRequestSpotPriceLimits `json:"SpotPriceLimits,omitempty" xml:"SpotPriceLimits,omitempty" type:"Repeated"`
	// The preemption policy that you want to apply to pay-as-you-go and preemptible instances. Valid values:
	//
	// *   NoSpot: The instance is created as a pay-as-you-go instance.
	// *   SpotWithPriceLimit: The instance is a preemptible instance that has a user-defined maximum hourly price.
	// *   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.
	//
	// Default value: NoSpot
	SpotStrategy              *string `json:"SpotStrategy,omitempty" xml:"SpotStrategy,omitempty"`
	StorageSetId              *string `json:"StorageSetId,omitempty" xml:"StorageSetId,omitempty"`
	StorageSetPartitionNumber *int32  `json:"StorageSetPartitionNumber,omitempty" xml:"StorageSetPartitionNumber,omitempty"`
	// The categories of the system disks. If Auto Scaling cannot create instances by using the disk category that has the highest priority, Auto Scaling creates instances by using the disk category that has the next highest priority. Valid values:
	//
	// *   cloud: basic disk
	// *   cloud_efficiency: ultra disk
	// *   cloud_ssd: standard SSD
	// *   cloud_essd: ESSD
	//
	// > If you specify SystemDiskCategories, you cannot specify `SystemDisk.Category`.
	SystemDiskCategories []*string `json:"SystemDiskCategories,omitempty" xml:"SystemDiskCategories,omitempty" type:"Repeated"`
	// The tags of the ECS instance. Tags must be specified as key-value pairs. You can specify up to 20 tags. When you specify tag keys and tag values, take note of the following items:
	//
	// *   A tag key can be up to 64 characters in length. The key cannot start with acs: or aliyun and cannot contain `http://` or `https://`. You cannot specify an empty string as a tag key.
	// *   A tag value can be up to 128 characters in length. The value cannot start with acs: or aliyun and cannot contain `http://` or `https://`. You can specify an empty string as a tag value.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// Specifies whether to create an ECS instance on a dedicated host. Valid values:
	//
	// *   default: does not create an ECS instance on a dedicated host.
	// *   host: creates an ECS instance on a dedicated host. If you do not specify DedicatedHostId, Alibaba Cloud selects a dedicated host for the ECS instance.
	//
	// Default value: default
	Tenancy *string `json:"Tenancy,omitempty" xml:"Tenancy,omitempty"`
	// The user data of the ECS instance. The data must be encoded in Base64. The maximum size of the data before encoding is 16 KB.
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The zone ID of the ECS instance.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s CreateScalingConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationRequest) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationRequest) SetImageOptions(v *CreateScalingConfigurationRequestImageOptions) *CreateScalingConfigurationRequest {
	s.ImageOptions = v
	return s
}

func (s *CreateScalingConfigurationRequest) SetPrivatePoolOptions(v *CreateScalingConfigurationRequestPrivatePoolOptions) *CreateScalingConfigurationRequest {
	s.PrivatePoolOptions = v
	return s
}

func (s *CreateScalingConfigurationRequest) SetSystemDisk(v *CreateScalingConfigurationRequestSystemDisk) *CreateScalingConfigurationRequest {
	s.SystemDisk = v
	return s
}

func (s *CreateScalingConfigurationRequest) SetAffinity(v string) *CreateScalingConfigurationRequest {
	s.Affinity = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetClientToken(v string) *CreateScalingConfigurationRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetCpu(v int32) *CreateScalingConfigurationRequest {
	s.Cpu = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetCreditSpecification(v string) *CreateScalingConfigurationRequest {
	s.CreditSpecification = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetDataDisks(v []*CreateScalingConfigurationRequestDataDisks) *CreateScalingConfigurationRequest {
	s.DataDisks = v
	return s
}

func (s *CreateScalingConfigurationRequest) SetDedicatedHostId(v string) *CreateScalingConfigurationRequest {
	s.DedicatedHostId = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetDeletionProtection(v bool) *CreateScalingConfigurationRequest {
	s.DeletionProtection = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetDeploymentSetId(v string) *CreateScalingConfigurationRequest {
	s.DeploymentSetId = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetHostName(v string) *CreateScalingConfigurationRequest {
	s.HostName = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetHpcClusterId(v string) *CreateScalingConfigurationRequest {
	s.HpcClusterId = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetImageFamily(v string) *CreateScalingConfigurationRequest {
	s.ImageFamily = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetImageId(v string) *CreateScalingConfigurationRequest {
	s.ImageId = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetImageName(v string) *CreateScalingConfigurationRequest {
	s.ImageName = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetInstanceDescription(v string) *CreateScalingConfigurationRequest {
	s.InstanceDescription = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetInstanceName(v string) *CreateScalingConfigurationRequest {
	s.InstanceName = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetInstancePatternInfos(v []*CreateScalingConfigurationRequestInstancePatternInfos) *CreateScalingConfigurationRequest {
	s.InstancePatternInfos = v
	return s
}

func (s *CreateScalingConfigurationRequest) SetInstanceType(v string) *CreateScalingConfigurationRequest {
	s.InstanceType = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetInstanceTypeOverrides(v []*CreateScalingConfigurationRequestInstanceTypeOverrides) *CreateScalingConfigurationRequest {
	s.InstanceTypeOverrides = v
	return s
}

func (s *CreateScalingConfigurationRequest) SetInstanceTypes(v []*string) *CreateScalingConfigurationRequest {
	s.InstanceTypes = v
	return s
}

func (s *CreateScalingConfigurationRequest) SetInternetChargeType(v string) *CreateScalingConfigurationRequest {
	s.InternetChargeType = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetInternetMaxBandwidthIn(v int32) *CreateScalingConfigurationRequest {
	s.InternetMaxBandwidthIn = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetInternetMaxBandwidthOut(v int32) *CreateScalingConfigurationRequest {
	s.InternetMaxBandwidthOut = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetIoOptimized(v string) *CreateScalingConfigurationRequest {
	s.IoOptimized = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetIpv6AddressCount(v int32) *CreateScalingConfigurationRequest {
	s.Ipv6AddressCount = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetKeyPairName(v string) *CreateScalingConfigurationRequest {
	s.KeyPairName = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetLoadBalancerWeight(v int32) *CreateScalingConfigurationRequest {
	s.LoadBalancerWeight = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetMemory(v int32) *CreateScalingConfigurationRequest {
	s.Memory = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetOwnerAccount(v string) *CreateScalingConfigurationRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetOwnerId(v int64) *CreateScalingConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetPassword(v string) *CreateScalingConfigurationRequest {
	s.Password = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetPasswordInherit(v bool) *CreateScalingConfigurationRequest {
	s.PasswordInherit = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetRamRoleName(v string) *CreateScalingConfigurationRequest {
	s.RamRoleName = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetResourceGroupId(v string) *CreateScalingConfigurationRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetResourceOwnerAccount(v string) *CreateScalingConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetScalingConfigurationName(v string) *CreateScalingConfigurationRequest {
	s.ScalingConfigurationName = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetScalingGroupId(v string) *CreateScalingConfigurationRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetSchedulerOptions(v map[string]interface{}) *CreateScalingConfigurationRequest {
	s.SchedulerOptions = v
	return s
}

func (s *CreateScalingConfigurationRequest) SetSecurityEnhancementStrategy(v string) *CreateScalingConfigurationRequest {
	s.SecurityEnhancementStrategy = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetSecurityGroupId(v string) *CreateScalingConfigurationRequest {
	s.SecurityGroupId = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetSecurityGroupIds(v []*string) *CreateScalingConfigurationRequest {
	s.SecurityGroupIds = v
	return s
}

func (s *CreateScalingConfigurationRequest) SetSpotDuration(v int32) *CreateScalingConfigurationRequest {
	s.SpotDuration = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetSpotInterruptionBehavior(v string) *CreateScalingConfigurationRequest {
	s.SpotInterruptionBehavior = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetSpotPriceLimits(v []*CreateScalingConfigurationRequestSpotPriceLimits) *CreateScalingConfigurationRequest {
	s.SpotPriceLimits = v
	return s
}

func (s *CreateScalingConfigurationRequest) SetSpotStrategy(v string) *CreateScalingConfigurationRequest {
	s.SpotStrategy = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetStorageSetId(v string) *CreateScalingConfigurationRequest {
	s.StorageSetId = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetStorageSetPartitionNumber(v int32) *CreateScalingConfigurationRequest {
	s.StorageSetPartitionNumber = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetSystemDiskCategories(v []*string) *CreateScalingConfigurationRequest {
	s.SystemDiskCategories = v
	return s
}

func (s *CreateScalingConfigurationRequest) SetTags(v string) *CreateScalingConfigurationRequest {
	s.Tags = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetTenancy(v string) *CreateScalingConfigurationRequest {
	s.Tenancy = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetUserData(v string) *CreateScalingConfigurationRequest {
	s.UserData = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetZoneId(v string) *CreateScalingConfigurationRequest {
	s.ZoneId = &v
	return s
}

type CreateScalingConfigurationRequestImageOptions struct {
	LoginAsNonRoot *bool `json:"LoginAsNonRoot,omitempty" xml:"LoginAsNonRoot,omitempty"`
}

func (s CreateScalingConfigurationRequestImageOptions) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationRequestImageOptions) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationRequestImageOptions) SetLoginAsNonRoot(v bool) *CreateScalingConfigurationRequestImageOptions {
	s.LoginAsNonRoot = &v
	return s
}

type CreateScalingConfigurationRequestPrivatePoolOptions struct {
	// The ID of the private pool. The ID of a private pool is the same as the ID of the elasticity assurance or capacity reservation for which the private pool is generated.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The type of the private pool that you want to use to start ECS instances. A private pool is generated when an elasticity assurance or a capacity reservation takes effect. You can select a private pool to create ECS instances. Valid values:
	//
	// *   Open: open private pool. Auto Scaling selects a matching open private pool to start instances. If no matching open private pools are found, Auto Scaling uses the resources in the public pool to start instances. In this case, you do not need to specify PrivatePoolOptions.Id.
	// *   Target: specified private pool. Auto Scaling uses the resources in the specified private pool to start ECS instances. If the specified private pool is unavailable, Auto Scaling cannot start ECS instances. If you set this parameter to Target, you must specify PrivatePoolOptions.Id.
	// *   None: no private pool. Auto Scaling does not use the resources in private pools to start ECS instances.
	MatchCriteria *string `json:"MatchCriteria,omitempty" xml:"MatchCriteria,omitempty"`
}

func (s CreateScalingConfigurationRequestPrivatePoolOptions) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationRequestPrivatePoolOptions) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationRequestPrivatePoolOptions) SetId(v string) *CreateScalingConfigurationRequestPrivatePoolOptions {
	s.Id = &v
	return s
}

func (s *CreateScalingConfigurationRequestPrivatePoolOptions) SetMatchCriteria(v string) *CreateScalingConfigurationRequestPrivatePoolOptions {
	s.MatchCriteria = &v
	return s
}

type CreateScalingConfigurationRequestSystemDisk struct {
	// The ID of the automatic snapshot policy that you want to apply to the system disk.
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// Specifies whether to enable the burst feature for the system disk. Valid values:
	//
	// *   true
	// *   false
	//
	// > This parameter is available only if you set `SystemDisk.Category` to `cloud_auto`.
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The category of the system disk. Valid values:
	//
	// *   cloud: basic disk
	// *   cloud_efficiency: ultra disk
	// *   cloud_ssd: standard SSD
	// *   ephemeral_ssd: local SSD
	// *   cloud_essd: enhanced SSD (ESSD)
	// *   cloud_auto: ESSD AutoPL disk
	//
	// If you specify SystemDisk.Category, you cannot specify `SystemDiskCategories`. If you do not specify SystemDisk.Category or `SystemDiskCategories`, the default value of SystemDisk.Category is used.
	//
	// *   For I/O optimized instances, the default value is cloud_efficiency.
	// *   For non-I/O optimized instances, the default value is cloud.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The description of the system disk. The description must be 2 to 256 characters in length. The description can contain letters and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the system disk. The name must be 2 to 128 characters in length. The name can contain letters, digits, colons (:), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
	DiskName *string `json:"DiskName,omitempty" xml:"DiskName,omitempty"`
	// The encryption algorithm that you want to use to encrypt the system disk. Valid values:
	//
	// *   AES-256
	// *   SM4-128
	//
	// Default value: AES-256
	EncryptAlgorithm *string `json:"EncryptAlgorithm,omitempty" xml:"EncryptAlgorithm,omitempty"`
	// Specifies whether to encrypt the system disk. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false
	Encrypted *bool `json:"Encrypted,omitempty" xml:"Encrypted,omitempty"`
	// The ID of the KMS key that you want to use to encrypt the system disk.
	KMSKeyId *string `json:"KMSKeyId,omitempty" xml:"KMSKeyId,omitempty"`
	// The performance level (PL) of the system disk that is an ESSD. Valid values:
	//
	// *   PL0: An ESSD can provide up to 10,000 random read/write IOPS.
	// *   PL1: An ESSD can provide up to 50,000 random read/write IOPS.
	// *   PL2: An ESSD can provide up to 100,000 random read/write IOPS.
	// *   PL3: An ESSD can provide up to 1,000,000 random read/write IOPS.
	//
	// Default value: PL0
	PerformanceLevel *string `json:"PerformanceLevel,omitempty" xml:"PerformanceLevel,omitempty"`
	// The IOPS metric that is preconfigured for the system disk.
	//
	// > IOPS measures the number of read and write operations that an EBS device can process per second.
	ProvisionedIops *int64 `json:"ProvisionedIops,omitempty" xml:"ProvisionedIops,omitempty"`
	// The size of the system disk. Unit: GiB.
	//
	// *   If you set SystemDisk.Category cloud: 20 to 500.
	// *   If you set SystemDisk.Category to cloud_efficiency: 20 to 500.
	// *   If you set SystemDisk.Category to cloud_ssd: 20 to 500.
	// *   If you set SystemDisk.Category to cloud_essd: 20 to 500.
	// *   If you set SystemDisk.Category to cloud_essd: 20 to 500.
	//
	// The value of SystemDisk.Size must be greater than or equal to the value of max{20, ImageSize}.
	//
	// Default value: 40 or the size of the image, whichever is greater.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
}

func (s CreateScalingConfigurationRequestSystemDisk) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationRequestSystemDisk) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationRequestSystemDisk) SetAutoSnapshotPolicyId(v string) *CreateScalingConfigurationRequestSystemDisk {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *CreateScalingConfigurationRequestSystemDisk) SetBurstingEnabled(v bool) *CreateScalingConfigurationRequestSystemDisk {
	s.BurstingEnabled = &v
	return s
}

func (s *CreateScalingConfigurationRequestSystemDisk) SetCategory(v string) *CreateScalingConfigurationRequestSystemDisk {
	s.Category = &v
	return s
}

func (s *CreateScalingConfigurationRequestSystemDisk) SetDescription(v string) *CreateScalingConfigurationRequestSystemDisk {
	s.Description = &v
	return s
}

func (s *CreateScalingConfigurationRequestSystemDisk) SetDiskName(v string) *CreateScalingConfigurationRequestSystemDisk {
	s.DiskName = &v
	return s
}

func (s *CreateScalingConfigurationRequestSystemDisk) SetEncryptAlgorithm(v string) *CreateScalingConfigurationRequestSystemDisk {
	s.EncryptAlgorithm = &v
	return s
}

func (s *CreateScalingConfigurationRequestSystemDisk) SetEncrypted(v bool) *CreateScalingConfigurationRequestSystemDisk {
	s.Encrypted = &v
	return s
}

func (s *CreateScalingConfigurationRequestSystemDisk) SetKMSKeyId(v string) *CreateScalingConfigurationRequestSystemDisk {
	s.KMSKeyId = &v
	return s
}

func (s *CreateScalingConfigurationRequestSystemDisk) SetPerformanceLevel(v string) *CreateScalingConfigurationRequestSystemDisk {
	s.PerformanceLevel = &v
	return s
}

func (s *CreateScalingConfigurationRequestSystemDisk) SetProvisionedIops(v int64) *CreateScalingConfigurationRequestSystemDisk {
	s.ProvisionedIops = &v
	return s
}

func (s *CreateScalingConfigurationRequestSystemDisk) SetSize(v int32) *CreateScalingConfigurationRequestSystemDisk {
	s.Size = &v
	return s
}

type CreateScalingConfigurationRequestDataDisks struct {
	// The ID of the automatic snapshot policy that you want to apply to the data disk.
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// Specifies whether to enable the burst feature for the system disk. Valid values:
	//
	// *   true
	// *   false
	//
	// > This parameter is available only if you set `SystemDisk.Category` to `cloud_auto`.
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The categories of the data disks. If Auto Scaling cannot create instances by using the disk category that has the highest priority, Auto Scaling creates instances by using the disk category that has the next highest priority. Valid values:
	//
	// *   cloud: basic disk. For a basic disk that is created together with the instance, DeleteWithInstance is set to true.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   cloud_essd: ESSD.
	//
	// > If you specify Categories, you cannot specify `DataDisks.Category`.
	Categories []*string `json:"Categories,omitempty" xml:"Categories,omitempty" type:"Repeated"`
	// The category of the data disk. Valid values:
	//
	// *   cloud: basic disk
	// *   cloud_efficiency: ultra disk
	// *   cloud_ssd: standard SSD
	// *   cloud_essd: ESSD
	// *   ephemeral_ssd: local SSD
	// *   cloud_auto: ESSD AutoPL disk
	//
	// If you specify this parameter, you cannot specify Categories. If you do not specify Category or Categories, the default value of Category is used.
	//
	// *   For I/O optimized instances, the default value is cloud_efficiency.
	// *   For non-I/O optimized instances, the default value is cloud.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// Specifies whether to release the data disk when the instance to which the data disk is attached is released. Valid values:
	//
	// *   true
	// *   false
	//
	// This parameter is available only for independent disks whose value of Category is set to cloud, cloud_efficiency, cloud_ssd, or cloud_essd. If you specify this parameter for other disks, an error is reported.
	//
	// Default value: true
	DeleteWithInstance *bool `json:"DeleteWithInstance,omitempty" xml:"DeleteWithInstance,omitempty"`
	// The description of the data disk. The description must be 2 to 256 characters in length. The description can contain letters and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The mount target of the data disk. If you do not specify Device, a mount target is automatically assigned when Auto Scaling creates ECS instances. The names of mount targets range from /dev/xvdb to /dev/xvdz.
	Device *string `json:"Device,omitempty" xml:"Device,omitempty"`
	// The name of the system disk. The name must be 2 to 128 characters in length and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
	DiskName *string `json:"DiskName,omitempty" xml:"DiskName,omitempty"`
	// Specifies whether to encrypt the data disk. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false
	Encrypted *string `json:"Encrypted,omitempty" xml:"Encrypted,omitempty"`
	// The ID of the KMS key that you want to use to encrypt the data disk.
	KMSKeyId *string `json:"KMSKeyId,omitempty" xml:"KMSKeyId,omitempty"`
	// The PL of the data disk that is an ESSD. Valid values:
	//
	// *   PL0: An ESSD can provide up to 10,000 random read/write IOPS.
	// *   PL1: An ESSD can provide up to 50,000 random read/write IOPS.
	// *   PL2: An ESSD can provide up to 100,000 random read/write IOPS.
	// *   PL3: An ESSD can provide up to 1,000,000 random read/write IOPS.
	//
	// > For more information about how to select ESSD PLs, see [ESSD](~~122389~~).
	PerformanceLevel *string `json:"PerformanceLevel,omitempty" xml:"PerformanceLevel,omitempty"`
	// The IOPS metric that is preconfigured for the data disk.
	//
	// > IOPS measures the number of read and write operations that an EBS device can process per second.
	ProvisionedIops *int64 `json:"ProvisionedIops,omitempty" xml:"ProvisionedIops,omitempty"`
	// The size of the data disk. Unit: GiB. Valid values:
	//
	// *   If you set Categories to cloud: 5 to 2000.
	// *   If you set Categories to cloud_efficiency: 20 to 32768.
	// *   If you set Categories to cloud_essd: 20 to 32768.
	// *   If you set Categories to ephemeral_ssd: 5 to 800.
	//
	// The size of the data disk must be greater than or equal to the size of the snapshot that is specified by SnapshotId.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The ID of the snapshot that you want to use to create data disks. If you specify this parameter, DataDisks.Size is ignored. The size of the data disk is the same as the size of the specified snapshot.
	//
	// If you specify a snapshot that is created on or before July 15, 2013, the operation fails and the system returns InvalidSnapshot.TooOld.
	SnapshotId *string `json:"SnapshotId,omitempty" xml:"SnapshotId,omitempty"`
}

func (s CreateScalingConfigurationRequestDataDisks) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationRequestDataDisks) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationRequestDataDisks) SetAutoSnapshotPolicyId(v string) *CreateScalingConfigurationRequestDataDisks {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetBurstingEnabled(v bool) *CreateScalingConfigurationRequestDataDisks {
	s.BurstingEnabled = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetCategories(v []*string) *CreateScalingConfigurationRequestDataDisks {
	s.Categories = v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetCategory(v string) *CreateScalingConfigurationRequestDataDisks {
	s.Category = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetDeleteWithInstance(v bool) *CreateScalingConfigurationRequestDataDisks {
	s.DeleteWithInstance = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetDescription(v string) *CreateScalingConfigurationRequestDataDisks {
	s.Description = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetDevice(v string) *CreateScalingConfigurationRequestDataDisks {
	s.Device = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetDiskName(v string) *CreateScalingConfigurationRequestDataDisks {
	s.DiskName = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetEncrypted(v string) *CreateScalingConfigurationRequestDataDisks {
	s.Encrypted = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetKMSKeyId(v string) *CreateScalingConfigurationRequestDataDisks {
	s.KMSKeyId = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetPerformanceLevel(v string) *CreateScalingConfigurationRequestDataDisks {
	s.PerformanceLevel = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetProvisionedIops(v int64) *CreateScalingConfigurationRequestDataDisks {
	s.ProvisionedIops = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetSize(v int32) *CreateScalingConfigurationRequestDataDisks {
	s.Size = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetSnapshotId(v string) *CreateScalingConfigurationRequestDataDisks {
	s.SnapshotId = &v
	return s
}

type CreateScalingConfigurationRequestInstancePatternInfos struct {
	// The architectures of the instance types. Valid values:
	//
	// *   X86: x86 architecture.
	// *   Heterogeneous: heterogeneous architecture, such as GPUs and FPGAs.
	// *   BareMetal: ECS Bare Metal Instance architecture.
	// *   Arm: ARM architecture.
	// *   SuperComputeCluster: Super Computing Cluster architecture.
	//
	// By default, all values are included.
	Architectures []*string `json:"Architectures,omitempty" xml:"Architectures,omitempty" type:"Repeated"`
	// Specifies whether to include burstable instance types. Valid values:
	//
	// *   Exclude: does not include burstable instance types.
	// *   Include: includes burstable instance types.
	// *   Required: includes only burstable instance types.
	//
	// Default value: Include
	BurstablePerformance *string `json:"BurstablePerformance,omitempty" xml:"BurstablePerformance,omitempty"`
	// The number of vCPUs that you want to allocate to an instance type in intelligent configuration mode. This parameter is used to filter the available instance types that meet the specified criteria. For more information, see the "[Instance families](~~25378~~)" topic.
	//
	// Take note of the following items when you specify Cores:
	//
	// *   InstancePatternInfos is available only for scaling groups that reside in VPCs.
	// *   If you specify InstancePatternInfos, you must specify Cores and Memory.
	// *   If you specify an instance type by using InstanceType or InstanceTypes, Auto Scaling preferentially uses the instance type that is specified by InstanceType or InstanceTypes for scale-outs. If the specified instance type does not have sufficient inventory, Auto Scaling creates instances by using the lowest-priced instance type that is specified by InstancePatternInfos.
	Cores *int32 `json:"Cores,omitempty" xml:"Cores,omitempty"`
	// The instance types that you want to exclude. You can use wildcard characters, such as asterisks (\*), to exclude an instance type or an instance family. Examples:
	//
	// *   ecs.c6.large: excludes the ecs.c6.large instance type.
	// *   ecs.c6.\*: excludes the c6 instance family.
	ExcludedInstanceTypes []*string `json:"ExcludedInstanceTypes,omitempty" xml:"ExcludedInstanceTypes,omitempty" type:"Repeated"`
	// The level of the instance type, which is used to filter instance types that meet the specified criteria. This parameter takes effect only if you set `CostOptimization` to true. Valid values:
	//
	// *   EntryLevel: entry level (shared instance type). Instance types of this level are the most cost-effective but may not provide stable computing performance in a consistent manner. Instance types of this level are suitable for business scenarios in which the CPU utilization is low. For more information, see the "[Shared instance families](~~108489~~)" topic.
	// *   EnterpriseLevel: enterprise level. Instance types of this level provide stable performance and dedicated resources and are suitable for business scenarios that require high stability. For more information, see the "[Instance families](~~25378~~)" topic.
	// *   CreditEntryLevel: credit entry level. This value is valid only for burstable instances. CPU credits are used to ensure computing performance. Instance types of this level are suitable for business scenarios in which the CPU utilization is low but may fluctuate in specific cases. For more information, see the "[Overview](~~59977~~)" topic of burstable instances.
	InstanceFamilyLevel *string `json:"InstanceFamilyLevel,omitempty" xml:"InstanceFamilyLevel,omitempty"`
	// The maximum hourly price of a pay-as-you-go or preemptible instance in intelligent configuration mode. This parameter is used to filter the available instance types that meet the specified criteria.
	//
	// > If you set SpotStrategy to SpotWithPriceLimit, you must specify MaxPrice. In other cases, MaxPrice is optional.
	MaxPrice *float32 `json:"MaxPrice,omitempty" xml:"MaxPrice,omitempty"`
	// The memory size that you want to allocate to an instance type in intelligent configuration mode. Unit: GiB. This parameter is used to filter the available instance types that meet the specified criteria.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
}

func (s CreateScalingConfigurationRequestInstancePatternInfos) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationRequestInstancePatternInfos) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationRequestInstancePatternInfos) SetArchitectures(v []*string) *CreateScalingConfigurationRequestInstancePatternInfos {
	s.Architectures = v
	return s
}

func (s *CreateScalingConfigurationRequestInstancePatternInfos) SetBurstablePerformance(v string) *CreateScalingConfigurationRequestInstancePatternInfos {
	s.BurstablePerformance = &v
	return s
}

func (s *CreateScalingConfigurationRequestInstancePatternInfos) SetCores(v int32) *CreateScalingConfigurationRequestInstancePatternInfos {
	s.Cores = &v
	return s
}

func (s *CreateScalingConfigurationRequestInstancePatternInfos) SetExcludedInstanceTypes(v []*string) *CreateScalingConfigurationRequestInstancePatternInfos {
	s.ExcludedInstanceTypes = v
	return s
}

func (s *CreateScalingConfigurationRequestInstancePatternInfos) SetInstanceFamilyLevel(v string) *CreateScalingConfigurationRequestInstancePatternInfos {
	s.InstanceFamilyLevel = &v
	return s
}

func (s *CreateScalingConfigurationRequestInstancePatternInfos) SetMaxPrice(v float32) *CreateScalingConfigurationRequestInstancePatternInfos {
	s.MaxPrice = &v
	return s
}

func (s *CreateScalingConfigurationRequestInstancePatternInfos) SetMemory(v float32) *CreateScalingConfigurationRequestInstancePatternInfos {
	s.Memory = &v
	return s
}

type CreateScalingConfigurationRequestInstanceTypeOverrides struct {
	// Instance type N that you want to use to override the instance type that is specified in the launch template.
	//
	// If you want to trigger scale-outs based on the weighted capacities of instances, specify InstanceType and WeightedCapacity at the same time. You can specify N instance types by using the Extended Configurations feature. Valid values of N: 1 to 10.
	//
	// > This parameter takes effect only if you specify LaunchTemplateId.
	//
	// You can specify an instance type that is available for purchase as the value of InstanceType.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The weight of instance type N. If you want to trigger scale-outs based on the weighted capacities of instances, you must specify WeightedCapacity after you specify InstanceType.
	//
	// The weight of an instance type specifies the capacity of an instance of the instance type in the scaling group. A higher weight specifies that a smaller number of instances of the specified instance type is required to meet the expected capacity requirement.
	//
	// Performance metrics, such as the number of vCPUs and the memory size of each instance type, may vary. You can specify different weights for different instance types based on your business requirements.
	//
	// Example:
	//
	// *   Current capacity: 0
	// *   Expected capacity: 6
	// *   Capacity of ecs.c5.xlarge: 4
	//
	// To meet the expected capacity requirement, Auto Scaling must create and add two ecs.c5.xlarge instances.
	//
	// > The capacity of the scaling group cannot exceed the sum of the maximum number of instances that is specified by MaxSize and the maximum weight of the instance types.
	//
	// Valid values of WeightedCapacity: 1 to 500.
	WeightedCapacity *int32 `json:"WeightedCapacity,omitempty" xml:"WeightedCapacity,omitempty"`
}

func (s CreateScalingConfigurationRequestInstanceTypeOverrides) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationRequestInstanceTypeOverrides) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationRequestInstanceTypeOverrides) SetInstanceType(v string) *CreateScalingConfigurationRequestInstanceTypeOverrides {
	s.InstanceType = &v
	return s
}

func (s *CreateScalingConfigurationRequestInstanceTypeOverrides) SetWeightedCapacity(v int32) *CreateScalingConfigurationRequestInstanceTypeOverrides {
	s.WeightedCapacity = &v
	return s
}

type CreateScalingConfigurationRequestSpotPriceLimits struct {
	// The instance type of the preemptible instance. This parameter takes effect only if you set SpotStrategy to SpotWithPriceLimit.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The price limit of the preemptible instance. This parameter takes effect only if you set SpotStrategy to SpotWithPriceLimit.
	PriceLimit *float32 `json:"PriceLimit,omitempty" xml:"PriceLimit,omitempty"`
}

func (s CreateScalingConfigurationRequestSpotPriceLimits) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationRequestSpotPriceLimits) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationRequestSpotPriceLimits) SetInstanceType(v string) *CreateScalingConfigurationRequestSpotPriceLimits {
	s.InstanceType = &v
	return s
}

func (s *CreateScalingConfigurationRequestSpotPriceLimits) SetPriceLimit(v float32) *CreateScalingConfigurationRequestSpotPriceLimits {
	s.PriceLimit = &v
	return s
}

type CreateScalingConfigurationShrinkRequest struct {
	ImageOptions       *CreateScalingConfigurationShrinkRequestImageOptions       `json:"ImageOptions,omitempty" xml:"ImageOptions,omitempty" type:"Struct"`
	PrivatePoolOptions *CreateScalingConfigurationShrinkRequestPrivatePoolOptions `json:"PrivatePoolOptions,omitempty" xml:"PrivatePoolOptions,omitempty" type:"Struct"`
	SystemDisk         *CreateScalingConfigurationShrinkRequestSystemDisk         `json:"SystemDisk,omitempty" xml:"SystemDisk,omitempty" type:"Struct"`
	// Specifies whether to associate an ECS instance on a dedicated host with the dedicated host. Valid values:
	//
	// *   default: does not associate the ECS instance with the dedicated host. If you start an ECS instance that was stopped in economical mode and the original dedicated host has insufficient resources, the ECS instance is automatically deployed to another dedicated host in the automatic deployment resource pool.
	// *   host: associates the ECS instance with the dedicated host. If you start an ECS instance that was stopped in economical mode, the instance remains on the original dedicated host. If the original dedicated host has insufficient resources, the ECS instance fails to start.
	//
	// Default value: default
	Affinity *string `json:"Affinity,omitempty" xml:"Affinity,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see the "[How to ensure the idempotence of a request](~~25693~~)" topic.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The number of vCPUs.
	//
	// You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set CPU to 2 and Memory to 16 to specify instance types that have 2 vCPUs and 16 GiB of memory. If you specify Cpu and Memory, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances by using the lowest-priced instance type.
	//
	// > You can specify Cpu and Memory to determine the range of instance types only if you set Scaling Policy to Cost Optimization Policy and you do not specify instance types in the scaling configuration.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The performance mode of the burstable instance. Valid values:
	//
	// *   Standard: standard mode
	// *   Unlimited: unlimited mode
	//
	// For more information, see the "Performance modes" section in the "[Overview](~~59977~~)" topic.
	CreditSpecification *string `json:"CreditSpecification,omitempty" xml:"CreditSpecification,omitempty"`
	// The data disks.
	DataDisks []*CreateScalingConfigurationShrinkRequestDataDisks `json:"DataDisks,omitempty" xml:"DataDisks,omitempty" type:"Repeated"`
	// The ID of the dedicated host on which you want to create an ECS instance. You cannot create preemptible instances on dedicated hosts. If you specify DedicatedHostId, SpotStrategy and SpotPriceLimit are ignored.
	//
	// You can call the DescribeDedicatedHosts operation to query dedicated host IDs.
	DedicatedHostId    *string `json:"DedicatedHostId,omitempty" xml:"DedicatedHostId,omitempty"`
	DeletionProtection *bool   `json:"DeletionProtection,omitempty" xml:"DeletionProtection,omitempty"`
	// The ID of the deployment set of the ECS instances that are created by using the scaling configuration.
	DeploymentSetId *string `json:"DeploymentSetId,omitempty" xml:"DeploymentSetId,omitempty"`
	// The hostname of the ECS instance. The hostname cannot start or end with a period (.) or a hyphen (-). The hostname cannot contain consecutive periods (.) or hyphens (-). Naming conventions for different types of instances:
	//
	// *   Windows instances: The hostname must be 2 to 15 characters in length and can contain letters, digits, and hyphens (-). The hostname cannot contain periods (.) or contain only digits.
	// *   Other instances, such as Linux instances: The hostname must be 2 to 64 characters in length. You can use periods (.) to separate a hostname into multiple segments. Each segment can contain letters, digits, and hyphens (-).
	HostName *string `json:"HostName,omitempty" xml:"HostName,omitempty"`
	// The ID of the Elastic High Performance Computing (E-HPC) cluster to which the ECS instances that are created by using the scaling configuration belong.
	HpcClusterId *string `json:"HpcClusterId,omitempty" xml:"HpcClusterId,omitempty"`
	// The name of the image family. If you specify this parameter, the most recent custom images that are available in the specified image family are returned. You can use the images to create instances. If you specify ImageId, you cannot specify ImageFamily.
	ImageFamily *string `json:"ImageFamily,omitempty" xml:"ImageFamily,omitempty"`
	// The ID of the image that Auto Scaling uses to automatically create ECS instances.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The name of the image. Each image name must be unique in a region. If you specify ImageId, ImageName is ignored.
	//
	// You cannot use ImageName to specify images that are purchased from Alibaba Cloud Marketplace.
	ImageName *string `json:"ImageName,omitempty" xml:"ImageName,omitempty"`
	// The description of the ECS instance. The description must be 2 to 256 characters in length. The description can contain letters and cannot start with `http://` or `https://`.
	InstanceDescription *string `json:"InstanceDescription,omitempty" xml:"InstanceDescription,omitempty"`
	// The name of the ECS instance that Auto Scaling creates based on the scaling configuration.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// Details of the intelligent configuration settings that determine the range of instance types that meet the specified criteria.
	InstancePatternInfos []*CreateScalingConfigurationShrinkRequestInstancePatternInfos `json:"InstancePatternInfos,omitempty" xml:"InstancePatternInfos,omitempty" type:"Repeated"`
	// The instance type of the ECS instance. For more information, see the "Instance families" topic.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The instance types.
	InstanceTypeOverrides []*CreateScalingConfigurationShrinkRequestInstanceTypeOverrides `json:"InstanceTypeOverrides,omitempty" xml:"InstanceTypeOverrides,omitempty" type:"Repeated"`
	// The instance types. If you specify InstanceTypes, InstanceType is ignored.
	//
	// Auto Scaling creates instances based on the priorities of the instance types. If Auto Scaling cannot create instances by using the instance type that has the highest priority, Auto Scaling creates instances by using the instance type that has the next highest priority.
	InstanceTypes []*string `json:"InstanceTypes,omitempty" xml:"InstanceTypes,omitempty" type:"Repeated"`
	// The metering method for network usage. Valid values:
	//
	// *   PayByBandwidth: You are charged for the maximum available bandwidth that is specified by InternetMaxBandwidthOut.
	// *   PayByTraffic: You are charged based on the amount of transferred data. InternetMaxBandwidthOut specifies only the maximum available bandwidth.
	//
	// For the classic network, the default value is PayByBandwidth. For VPCs, the default value is PayByTraffic.
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The maximum inbound public bandwidth. Unit: Mbit/s. Valid values: 1 to 200.
	//
	// Default value: 200 This parameter is not used for billing because inbound traffic to instances is free of charge.
	InternetMaxBandwidthIn *int32 `json:"InternetMaxBandwidthIn,omitempty" xml:"InternetMaxBandwidthIn,omitempty"`
	// The maximum outbound public bandwidth. Unit: Mbit/s. Valid values:
	//
	// *   Valid values if you set InternetChargeType to PayByBandwidth: 0 to 100. If you leave this parameter empty, this parameter is automatically set to 0.
	// *   Valid values if you set InternetChargeType to PayByTraffic: 0 to 100. If you leave this parameter empty, an error is returned.
	InternetMaxBandwidthOut *int32 `json:"InternetMaxBandwidthOut,omitempty" xml:"InternetMaxBandwidthOut,omitempty"`
	// Specifies whether to create an I/O optimized instance. Valid values:
	//
	// none: does not create an I/O optimized instance. optimized: creates an I/O optimized instance.
	//
	// For instances of retired instance types, the default value is none. For instances of other instance types, the default value is optimized.
	IoOptimized *string `json:"IoOptimized,omitempty" xml:"IoOptimized,omitempty"`
	// The number of randomly generated IPv6 addresses that you want to allocate to the elastic network interface (ENI).
	Ipv6AddressCount *int32 `json:"Ipv6AddressCount,omitempty" xml:"Ipv6AddressCount,omitempty"`
	// The name of the key pair that you want to use to log on to an ECS instance.
	//
	// *   Windows instances do not support this parameter.
	// *   By default, the username and password authentication method is disabled for Linux instances.
	KeyPairName *string `json:"KeyPairName,omitempty" xml:"KeyPairName,omitempty"`
	// The weight of an ECS instance as a backend server. Valid values: 1 to 100.
	//
	// Default value: 50
	LoadBalancerWeight *int32 `json:"LoadBalancerWeight,omitempty" xml:"LoadBalancerWeight,omitempty"`
	// The memory size. Unit: GiB.
	//
	// You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set Cpu to 2 and Memory to 16 to specify instance types that have 2 vCPUs and 16 GiB of memory. If you specify Cpu and Memory, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances by using the lowest-priced instance type.
	//
	// > You can specify Cpu and Memory to determine the range of instance types only if you set Scaling Policy to Cost Optimization Policy and you do not specify instance types in the scaling configuration.
	Memory       *int32  `json:"Memory,omitempty" xml:"Memory,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The password that you want to use to log on to an ECS instance. The password must be 8 to 30 characters in length and must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. The following special characters are supported:
	//
	// `` `() ~!@#$%^&*-_+=\|{}[]:;\"<>,.?/ ``
	//
	// The password of a Windows instance cannot start with a forward slash (/).
	//
	// > For security reasons, we recommend that you use HTTPS to send requests if you specify Password.
	Password *string `json:"Password,omitempty" xml:"Password,omitempty"`
	// Specifies whether to use the password that is preconfigured in the image. Before you use this parameter, make sure that a password is configured in the image. Valid values:
	//
	// *   true
	// *   false
	PasswordInherit *bool `json:"PasswordInherit,omitempty" xml:"PasswordInherit,omitempty"`
	// The name of the RAM role that you attach to the ECS instance. The name is provided and maintained by Resource Access Management (RAM). You can call the ListRoles operation to query the available RAM roles.
	RamRoleName *string `json:"RamRoleName,omitempty" xml:"RamRoleName,omitempty"`
	// The ID of the resource group to which the ECS instances that are created by using the scaling configuration belong.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The name of the scaling configuration. The name must be 2 to 64 characters in length and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). The name must start with a letter or a digit.
	//
	// The name of the scaling configuration must be unique in a region. If you do not specify this parameter, the scaling configuration ID is used.
	ScalingConfigurationName *string `json:"ScalingConfigurationName,omitempty" xml:"ScalingConfigurationName,omitempty"`
	// The ID of the scaling group in which you want to create a scaling configuration.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The scheduler options.
	SchedulerOptionsShrink *string `json:"SchedulerOptions,omitempty" xml:"SchedulerOptions,omitempty"`
	// Specifies whether to enable security hardening. Valid values:
	//
	// *   Active: enables security hardening. This value is applicable only to public images.
	// *   Deactive: disables security hardening. This value is applicable to all image types.
	SecurityEnhancementStrategy *string `json:"SecurityEnhancementStrategy,omitempty" xml:"SecurityEnhancementStrategy,omitempty"`
	// The ID of the security group with which ECS instances are associated. ECS instances that are associated with the same security group can access each other.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// The IDs of the security groups with which you want to associate the ECS instances that are created by using the scaling configuration. For more information, see the "Security group limits" section of the "[Limits](~~25412~~)" topic.
	//
	// > If you specify SecurityGroupId, you cannot specify SecurityGroupIds.
	SecurityGroupIds []*string `json:"SecurityGroupIds,omitempty" xml:"SecurityGroupIds,omitempty" type:"Repeated"`
	// The retention period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.
	//
	// *   The following retention periods are available in invitational preview: 2, 3, 4, 5, and 6 hours. If you want to set this parameter to one of these values, submit a ticket.
	// *   If you set this parameter to 0, no protection period is specified for the preemptible instance.
	//
	// Default value: 1
	SpotDuration *int32 `json:"SpotDuration,omitempty" xml:"SpotDuration,omitempty"`
	// The interruption mode of the preemptible instance. Set the value to Terminate. The value specifies that the preemptible instance is to be released.
	SpotInterruptionBehavior *string `json:"SpotInterruptionBehavior,omitempty" xml:"SpotInterruptionBehavior,omitempty"`
	// The billing information of the preemptible instances.
	SpotPriceLimits []*CreateScalingConfigurationShrinkRequestSpotPriceLimits `json:"SpotPriceLimits,omitempty" xml:"SpotPriceLimits,omitempty" type:"Repeated"`
	// The preemption policy that you want to apply to pay-as-you-go and preemptible instances. Valid values:
	//
	// *   NoSpot: The instance is created as a pay-as-you-go instance.
	// *   SpotWithPriceLimit: The instance is a preemptible instance that has a user-defined maximum hourly price.
	// *   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.
	//
	// Default value: NoSpot
	SpotStrategy              *string `json:"SpotStrategy,omitempty" xml:"SpotStrategy,omitempty"`
	StorageSetId              *string `json:"StorageSetId,omitempty" xml:"StorageSetId,omitempty"`
	StorageSetPartitionNumber *int32  `json:"StorageSetPartitionNumber,omitempty" xml:"StorageSetPartitionNumber,omitempty"`
	// The categories of the system disks. If Auto Scaling cannot create instances by using the disk category that has the highest priority, Auto Scaling creates instances by using the disk category that has the next highest priority. Valid values:
	//
	// *   cloud: basic disk
	// *   cloud_efficiency: ultra disk
	// *   cloud_ssd: standard SSD
	// *   cloud_essd: ESSD
	//
	// > If you specify SystemDiskCategories, you cannot specify `SystemDisk.Category`.
	SystemDiskCategories []*string `json:"SystemDiskCategories,omitempty" xml:"SystemDiskCategories,omitempty" type:"Repeated"`
	// The tags of the ECS instance. Tags must be specified as key-value pairs. You can specify up to 20 tags. When you specify tag keys and tag values, take note of the following items:
	//
	// *   A tag key can be up to 64 characters in length. The key cannot start with acs: or aliyun and cannot contain `http://` or `https://`. You cannot specify an empty string as a tag key.
	// *   A tag value can be up to 128 characters in length. The value cannot start with acs: or aliyun and cannot contain `http://` or `https://`. You can specify an empty string as a tag value.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// Specifies whether to create an ECS instance on a dedicated host. Valid values:
	//
	// *   default: does not create an ECS instance on a dedicated host.
	// *   host: creates an ECS instance on a dedicated host. If you do not specify DedicatedHostId, Alibaba Cloud selects a dedicated host for the ECS instance.
	//
	// Default value: default
	Tenancy *string `json:"Tenancy,omitempty" xml:"Tenancy,omitempty"`
	// The user data of the ECS instance. The data must be encoded in Base64. The maximum size of the data before encoding is 16 KB.
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The zone ID of the ECS instance.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s CreateScalingConfigurationShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationShrinkRequest) SetImageOptions(v *CreateScalingConfigurationShrinkRequestImageOptions) *CreateScalingConfigurationShrinkRequest {
	s.ImageOptions = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetPrivatePoolOptions(v *CreateScalingConfigurationShrinkRequestPrivatePoolOptions) *CreateScalingConfigurationShrinkRequest {
	s.PrivatePoolOptions = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetSystemDisk(v *CreateScalingConfigurationShrinkRequestSystemDisk) *CreateScalingConfigurationShrinkRequest {
	s.SystemDisk = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetAffinity(v string) *CreateScalingConfigurationShrinkRequest {
	s.Affinity = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetClientToken(v string) *CreateScalingConfigurationShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetCpu(v int32) *CreateScalingConfigurationShrinkRequest {
	s.Cpu = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetCreditSpecification(v string) *CreateScalingConfigurationShrinkRequest {
	s.CreditSpecification = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetDataDisks(v []*CreateScalingConfigurationShrinkRequestDataDisks) *CreateScalingConfigurationShrinkRequest {
	s.DataDisks = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetDedicatedHostId(v string) *CreateScalingConfigurationShrinkRequest {
	s.DedicatedHostId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetDeletionProtection(v bool) *CreateScalingConfigurationShrinkRequest {
	s.DeletionProtection = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetDeploymentSetId(v string) *CreateScalingConfigurationShrinkRequest {
	s.DeploymentSetId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetHostName(v string) *CreateScalingConfigurationShrinkRequest {
	s.HostName = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetHpcClusterId(v string) *CreateScalingConfigurationShrinkRequest {
	s.HpcClusterId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetImageFamily(v string) *CreateScalingConfigurationShrinkRequest {
	s.ImageFamily = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetImageId(v string) *CreateScalingConfigurationShrinkRequest {
	s.ImageId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetImageName(v string) *CreateScalingConfigurationShrinkRequest {
	s.ImageName = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetInstanceDescription(v string) *CreateScalingConfigurationShrinkRequest {
	s.InstanceDescription = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetInstanceName(v string) *CreateScalingConfigurationShrinkRequest {
	s.InstanceName = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetInstancePatternInfos(v []*CreateScalingConfigurationShrinkRequestInstancePatternInfos) *CreateScalingConfigurationShrinkRequest {
	s.InstancePatternInfos = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetInstanceType(v string) *CreateScalingConfigurationShrinkRequest {
	s.InstanceType = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetInstanceTypeOverrides(v []*CreateScalingConfigurationShrinkRequestInstanceTypeOverrides) *CreateScalingConfigurationShrinkRequest {
	s.InstanceTypeOverrides = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetInstanceTypes(v []*string) *CreateScalingConfigurationShrinkRequest {
	s.InstanceTypes = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetInternetChargeType(v string) *CreateScalingConfigurationShrinkRequest {
	s.InternetChargeType = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetInternetMaxBandwidthIn(v int32) *CreateScalingConfigurationShrinkRequest {
	s.InternetMaxBandwidthIn = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetInternetMaxBandwidthOut(v int32) *CreateScalingConfigurationShrinkRequest {
	s.InternetMaxBandwidthOut = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetIoOptimized(v string) *CreateScalingConfigurationShrinkRequest {
	s.IoOptimized = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetIpv6AddressCount(v int32) *CreateScalingConfigurationShrinkRequest {
	s.Ipv6AddressCount = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetKeyPairName(v string) *CreateScalingConfigurationShrinkRequest {
	s.KeyPairName = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetLoadBalancerWeight(v int32) *CreateScalingConfigurationShrinkRequest {
	s.LoadBalancerWeight = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetMemory(v int32) *CreateScalingConfigurationShrinkRequest {
	s.Memory = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetOwnerAccount(v string) *CreateScalingConfigurationShrinkRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetOwnerId(v int64) *CreateScalingConfigurationShrinkRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetPassword(v string) *CreateScalingConfigurationShrinkRequest {
	s.Password = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetPasswordInherit(v bool) *CreateScalingConfigurationShrinkRequest {
	s.PasswordInherit = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetRamRoleName(v string) *CreateScalingConfigurationShrinkRequest {
	s.RamRoleName = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetResourceGroupId(v string) *CreateScalingConfigurationShrinkRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetResourceOwnerAccount(v string) *CreateScalingConfigurationShrinkRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetScalingConfigurationName(v string) *CreateScalingConfigurationShrinkRequest {
	s.ScalingConfigurationName = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetScalingGroupId(v string) *CreateScalingConfigurationShrinkRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetSchedulerOptionsShrink(v string) *CreateScalingConfigurationShrinkRequest {
	s.SchedulerOptionsShrink = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetSecurityEnhancementStrategy(v string) *CreateScalingConfigurationShrinkRequest {
	s.SecurityEnhancementStrategy = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetSecurityGroupId(v string) *CreateScalingConfigurationShrinkRequest {
	s.SecurityGroupId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetSecurityGroupIds(v []*string) *CreateScalingConfigurationShrinkRequest {
	s.SecurityGroupIds = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetSpotDuration(v int32) *CreateScalingConfigurationShrinkRequest {
	s.SpotDuration = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetSpotInterruptionBehavior(v string) *CreateScalingConfigurationShrinkRequest {
	s.SpotInterruptionBehavior = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetSpotPriceLimits(v []*CreateScalingConfigurationShrinkRequestSpotPriceLimits) *CreateScalingConfigurationShrinkRequest {
	s.SpotPriceLimits = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetSpotStrategy(v string) *CreateScalingConfigurationShrinkRequest {
	s.SpotStrategy = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetStorageSetId(v string) *CreateScalingConfigurationShrinkRequest {
	s.StorageSetId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetStorageSetPartitionNumber(v int32) *CreateScalingConfigurationShrinkRequest {
	s.StorageSetPartitionNumber = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetSystemDiskCategories(v []*string) *CreateScalingConfigurationShrinkRequest {
	s.SystemDiskCategories = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetTags(v string) *CreateScalingConfigurationShrinkRequest {
	s.Tags = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetTenancy(v string) *CreateScalingConfigurationShrinkRequest {
	s.Tenancy = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetUserData(v string) *CreateScalingConfigurationShrinkRequest {
	s.UserData = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetZoneId(v string) *CreateScalingConfigurationShrinkRequest {
	s.ZoneId = &v
	return s
}

type CreateScalingConfigurationShrinkRequestImageOptions struct {
	LoginAsNonRoot *bool `json:"LoginAsNonRoot,omitempty" xml:"LoginAsNonRoot,omitempty"`
}

func (s CreateScalingConfigurationShrinkRequestImageOptions) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationShrinkRequestImageOptions) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationShrinkRequestImageOptions) SetLoginAsNonRoot(v bool) *CreateScalingConfigurationShrinkRequestImageOptions {
	s.LoginAsNonRoot = &v
	return s
}

type CreateScalingConfigurationShrinkRequestPrivatePoolOptions struct {
	// The ID of the private pool. The ID of a private pool is the same as the ID of the elasticity assurance or capacity reservation for which the private pool is generated.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The type of the private pool that you want to use to start ECS instances. A private pool is generated when an elasticity assurance or a capacity reservation takes effect. You can select a private pool to create ECS instances. Valid values:
	//
	// *   Open: open private pool. Auto Scaling selects a matching open private pool to start instances. If no matching open private pools are found, Auto Scaling uses the resources in the public pool to start instances. In this case, you do not need to specify PrivatePoolOptions.Id.
	// *   Target: specified private pool. Auto Scaling uses the resources in the specified private pool to start ECS instances. If the specified private pool is unavailable, Auto Scaling cannot start ECS instances. If you set this parameter to Target, you must specify PrivatePoolOptions.Id.
	// *   None: no private pool. Auto Scaling does not use the resources in private pools to start ECS instances.
	MatchCriteria *string `json:"MatchCriteria,omitempty" xml:"MatchCriteria,omitempty"`
}

func (s CreateScalingConfigurationShrinkRequestPrivatePoolOptions) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationShrinkRequestPrivatePoolOptions) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationShrinkRequestPrivatePoolOptions) SetId(v string) *CreateScalingConfigurationShrinkRequestPrivatePoolOptions {
	s.Id = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestPrivatePoolOptions) SetMatchCriteria(v string) *CreateScalingConfigurationShrinkRequestPrivatePoolOptions {
	s.MatchCriteria = &v
	return s
}

type CreateScalingConfigurationShrinkRequestSystemDisk struct {
	// The ID of the automatic snapshot policy that you want to apply to the system disk.
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// Specifies whether to enable the burst feature for the system disk. Valid values:
	//
	// *   true
	// *   false
	//
	// > This parameter is available only if you set `SystemDisk.Category` to `cloud_auto`.
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The category of the system disk. Valid values:
	//
	// *   cloud: basic disk
	// *   cloud_efficiency: ultra disk
	// *   cloud_ssd: standard SSD
	// *   ephemeral_ssd: local SSD
	// *   cloud_essd: enhanced SSD (ESSD)
	// *   cloud_auto: ESSD AutoPL disk
	//
	// If you specify SystemDisk.Category, you cannot specify `SystemDiskCategories`. If you do not specify SystemDisk.Category or `SystemDiskCategories`, the default value of SystemDisk.Category is used.
	//
	// *   For I/O optimized instances, the default value is cloud_efficiency.
	// *   For non-I/O optimized instances, the default value is cloud.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The description of the system disk. The description must be 2 to 256 characters in length. The description can contain letters and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the system disk. The name must be 2 to 128 characters in length. The name can contain letters, digits, colons (:), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
	DiskName *string `json:"DiskName,omitempty" xml:"DiskName,omitempty"`
	// The encryption algorithm that you want to use to encrypt the system disk. Valid values:
	//
	// *   AES-256
	// *   SM4-128
	//
	// Default value: AES-256
	EncryptAlgorithm *string `json:"EncryptAlgorithm,omitempty" xml:"EncryptAlgorithm,omitempty"`
	// Specifies whether to encrypt the system disk. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false
	Encrypted *bool `json:"Encrypted,omitempty" xml:"Encrypted,omitempty"`
	// The ID of the KMS key that you want to use to encrypt the system disk.
	KMSKeyId *string `json:"KMSKeyId,omitempty" xml:"KMSKeyId,omitempty"`
	// The performance level (PL) of the system disk that is an ESSD. Valid values:
	//
	// *   PL0: An ESSD can provide up to 10,000 random read/write IOPS.
	// *   PL1: An ESSD can provide up to 50,000 random read/write IOPS.
	// *   PL2: An ESSD can provide up to 100,000 random read/write IOPS.
	// *   PL3: An ESSD can provide up to 1,000,000 random read/write IOPS.
	//
	// Default value: PL0
	PerformanceLevel *string `json:"PerformanceLevel,omitempty" xml:"PerformanceLevel,omitempty"`
	// The IOPS metric that is preconfigured for the system disk.
	//
	// > IOPS measures the number of read and write operations that an EBS device can process per second.
	ProvisionedIops *int64 `json:"ProvisionedIops,omitempty" xml:"ProvisionedIops,omitempty"`
	// The size of the system disk. Unit: GiB.
	//
	// *   If you set SystemDisk.Category cloud: 20 to 500.
	// *   If you set SystemDisk.Category to cloud_efficiency: 20 to 500.
	// *   If you set SystemDisk.Category to cloud_ssd: 20 to 500.
	// *   If you set SystemDisk.Category to cloud_essd: 20 to 500.
	// *   If you set SystemDisk.Category to cloud_essd: 20 to 500.
	//
	// The value of SystemDisk.Size must be greater than or equal to the value of max{20, ImageSize}.
	//
	// Default value: 40 or the size of the image, whichever is greater.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
}

func (s CreateScalingConfigurationShrinkRequestSystemDisk) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationShrinkRequestSystemDisk) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationShrinkRequestSystemDisk) SetAutoSnapshotPolicyId(v string) *CreateScalingConfigurationShrinkRequestSystemDisk {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestSystemDisk) SetBurstingEnabled(v bool) *CreateScalingConfigurationShrinkRequestSystemDisk {
	s.BurstingEnabled = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestSystemDisk) SetCategory(v string) *CreateScalingConfigurationShrinkRequestSystemDisk {
	s.Category = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestSystemDisk) SetDescription(v string) *CreateScalingConfigurationShrinkRequestSystemDisk {
	s.Description = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestSystemDisk) SetDiskName(v string) *CreateScalingConfigurationShrinkRequestSystemDisk {
	s.DiskName = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestSystemDisk) SetEncryptAlgorithm(v string) *CreateScalingConfigurationShrinkRequestSystemDisk {
	s.EncryptAlgorithm = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestSystemDisk) SetEncrypted(v bool) *CreateScalingConfigurationShrinkRequestSystemDisk {
	s.Encrypted = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestSystemDisk) SetKMSKeyId(v string) *CreateScalingConfigurationShrinkRequestSystemDisk {
	s.KMSKeyId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestSystemDisk) SetPerformanceLevel(v string) *CreateScalingConfigurationShrinkRequestSystemDisk {
	s.PerformanceLevel = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestSystemDisk) SetProvisionedIops(v int64) *CreateScalingConfigurationShrinkRequestSystemDisk {
	s.ProvisionedIops = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestSystemDisk) SetSize(v int32) *CreateScalingConfigurationShrinkRequestSystemDisk {
	s.Size = &v
	return s
}

type CreateScalingConfigurationShrinkRequestDataDisks struct {
	// The ID of the automatic snapshot policy that you want to apply to the data disk.
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// Specifies whether to enable the burst feature for the system disk. Valid values:
	//
	// *   true
	// *   false
	//
	// > This parameter is available only if you set `SystemDisk.Category` to `cloud_auto`.
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The categories of the data disks. If Auto Scaling cannot create instances by using the disk category that has the highest priority, Auto Scaling creates instances by using the disk category that has the next highest priority. Valid values:
	//
	// *   cloud: basic disk. For a basic disk that is created together with the instance, DeleteWithInstance is set to true.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   cloud_essd: ESSD.
	//
	// > If you specify Categories, you cannot specify `DataDisks.Category`.
	Categories []*string `json:"Categories,omitempty" xml:"Categories,omitempty" type:"Repeated"`
	// The category of the data disk. Valid values:
	//
	// *   cloud: basic disk
	// *   cloud_efficiency: ultra disk
	// *   cloud_ssd: standard SSD
	// *   cloud_essd: ESSD
	// *   ephemeral_ssd: local SSD
	// *   cloud_auto: ESSD AutoPL disk
	//
	// If you specify this parameter, you cannot specify Categories. If you do not specify Category or Categories, the default value of Category is used.
	//
	// *   For I/O optimized instances, the default value is cloud_efficiency.
	// *   For non-I/O optimized instances, the default value is cloud.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// Specifies whether to release the data disk when the instance to which the data disk is attached is released. Valid values:
	//
	// *   true
	// *   false
	//
	// This parameter is available only for independent disks whose value of Category is set to cloud, cloud_efficiency, cloud_ssd, or cloud_essd. If you specify this parameter for other disks, an error is reported.
	//
	// Default value: true
	DeleteWithInstance *bool `json:"DeleteWithInstance,omitempty" xml:"DeleteWithInstance,omitempty"`
	// The description of the data disk. The description must be 2 to 256 characters in length. The description can contain letters and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The mount target of the data disk. If you do not specify Device, a mount target is automatically assigned when Auto Scaling creates ECS instances. The names of mount targets range from /dev/xvdb to /dev/xvdz.
	Device *string `json:"Device,omitempty" xml:"Device,omitempty"`
	// The name of the system disk. The name must be 2 to 128 characters in length and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
	DiskName *string `json:"DiskName,omitempty" xml:"DiskName,omitempty"`
	// Specifies whether to encrypt the data disk. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false
	Encrypted *string `json:"Encrypted,omitempty" xml:"Encrypted,omitempty"`
	// The ID of the KMS key that you want to use to encrypt the data disk.
	KMSKeyId *string `json:"KMSKeyId,omitempty" xml:"KMSKeyId,omitempty"`
	// The PL of the data disk that is an ESSD. Valid values:
	//
	// *   PL0: An ESSD can provide up to 10,000 random read/write IOPS.
	// *   PL1: An ESSD can provide up to 50,000 random read/write IOPS.
	// *   PL2: An ESSD can provide up to 100,000 random read/write IOPS.
	// *   PL3: An ESSD can provide up to 1,000,000 random read/write IOPS.
	//
	// > For more information about how to select ESSD PLs, see [ESSD](~~122389~~).
	PerformanceLevel *string `json:"PerformanceLevel,omitempty" xml:"PerformanceLevel,omitempty"`
	// The IOPS metric that is preconfigured for the data disk.
	//
	// > IOPS measures the number of read and write operations that an EBS device can process per second.
	ProvisionedIops *int64 `json:"ProvisionedIops,omitempty" xml:"ProvisionedIops,omitempty"`
	// The size of the data disk. Unit: GiB. Valid values:
	//
	// *   If you set Categories to cloud: 5 to 2000.
	// *   If you set Categories to cloud_efficiency: 20 to 32768.
	// *   If you set Categories to cloud_essd: 20 to 32768.
	// *   If you set Categories to ephemeral_ssd: 5 to 800.
	//
	// The size of the data disk must be greater than or equal to the size of the snapshot that is specified by SnapshotId.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The ID of the snapshot that you want to use to create data disks. If you specify this parameter, DataDisks.Size is ignored. The size of the data disk is the same as the size of the specified snapshot.
	//
	// If you specify a snapshot that is created on or before July 15, 2013, the operation fails and the system returns InvalidSnapshot.TooOld.
	SnapshotId *string `json:"SnapshotId,omitempty" xml:"SnapshotId,omitempty"`
}

func (s CreateScalingConfigurationShrinkRequestDataDisks) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationShrinkRequestDataDisks) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetAutoSnapshotPolicyId(v string) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetBurstingEnabled(v bool) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.BurstingEnabled = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetCategories(v []*string) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.Categories = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetCategory(v string) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.Category = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetDeleteWithInstance(v bool) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.DeleteWithInstance = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetDescription(v string) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.Description = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetDevice(v string) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.Device = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetDiskName(v string) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.DiskName = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetEncrypted(v string) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.Encrypted = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetKMSKeyId(v string) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.KMSKeyId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetPerformanceLevel(v string) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.PerformanceLevel = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetProvisionedIops(v int64) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.ProvisionedIops = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetSize(v int32) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.Size = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetSnapshotId(v string) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.SnapshotId = &v
	return s
}

type CreateScalingConfigurationShrinkRequestInstancePatternInfos struct {
	// The architectures of the instance types. Valid values:
	//
	// *   X86: x86 architecture.
	// *   Heterogeneous: heterogeneous architecture, such as GPUs and FPGAs.
	// *   BareMetal: ECS Bare Metal Instance architecture.
	// *   Arm: ARM architecture.
	// *   SuperComputeCluster: Super Computing Cluster architecture.
	//
	// By default, all values are included.
	Architectures []*string `json:"Architectures,omitempty" xml:"Architectures,omitempty" type:"Repeated"`
	// Specifies whether to include burstable instance types. Valid values:
	//
	// *   Exclude: does not include burstable instance types.
	// *   Include: includes burstable instance types.
	// *   Required: includes only burstable instance types.
	//
	// Default value: Include
	BurstablePerformance *string `json:"BurstablePerformance,omitempty" xml:"BurstablePerformance,omitempty"`
	// The number of vCPUs that you want to allocate to an instance type in intelligent configuration mode. This parameter is used to filter the available instance types that meet the specified criteria. For more information, see the "[Instance families](~~25378~~)" topic.
	//
	// Take note of the following items when you specify Cores:
	//
	// *   InstancePatternInfos is available only for scaling groups that reside in VPCs.
	// *   If you specify InstancePatternInfos, you must specify Cores and Memory.
	// *   If you specify an instance type by using InstanceType or InstanceTypes, Auto Scaling preferentially uses the instance type that is specified by InstanceType or InstanceTypes for scale-outs. If the specified instance type does not have sufficient inventory, Auto Scaling creates instances by using the lowest-priced instance type that is specified by InstancePatternInfos.
	Cores *int32 `json:"Cores,omitempty" xml:"Cores,omitempty"`
	// The instance types that you want to exclude. You can use wildcard characters, such as asterisks (\*), to exclude an instance type or an instance family. Examples:
	//
	// *   ecs.c6.large: excludes the ecs.c6.large instance type.
	// *   ecs.c6.\*: excludes the c6 instance family.
	ExcludedInstanceTypes []*string `json:"ExcludedInstanceTypes,omitempty" xml:"ExcludedInstanceTypes,omitempty" type:"Repeated"`
	// The level of the instance type, which is used to filter instance types that meet the specified criteria. This parameter takes effect only if you set `CostOptimization` to true. Valid values:
	//
	// *   EntryLevel: entry level (shared instance type). Instance types of this level are the most cost-effective but may not provide stable computing performance in a consistent manner. Instance types of this level are suitable for business scenarios in which the CPU utilization is low. For more information, see the "[Shared instance families](~~108489~~)" topic.
	// *   EnterpriseLevel: enterprise level. Instance types of this level provide stable performance and dedicated resources and are suitable for business scenarios that require high stability. For more information, see the "[Instance families](~~25378~~)" topic.
	// *   CreditEntryLevel: credit entry level. This value is valid only for burstable instances. CPU credits are used to ensure computing performance. Instance types of this level are suitable for business scenarios in which the CPU utilization is low but may fluctuate in specific cases. For more information, see the "[Overview](~~59977~~)" topic of burstable instances.
	InstanceFamilyLevel *string `json:"InstanceFamilyLevel,omitempty" xml:"InstanceFamilyLevel,omitempty"`
	// The maximum hourly price of a pay-as-you-go or preemptible instance in intelligent configuration mode. This parameter is used to filter the available instance types that meet the specified criteria.
	//
	// > If you set SpotStrategy to SpotWithPriceLimit, you must specify MaxPrice. In other cases, MaxPrice is optional.
	MaxPrice *float32 `json:"MaxPrice,omitempty" xml:"MaxPrice,omitempty"`
	// The memory size that you want to allocate to an instance type in intelligent configuration mode. Unit: GiB. This parameter is used to filter the available instance types that meet the specified criteria.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
}

func (s CreateScalingConfigurationShrinkRequestInstancePatternInfos) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationShrinkRequestInstancePatternInfos) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationShrinkRequestInstancePatternInfos) SetArchitectures(v []*string) *CreateScalingConfigurationShrinkRequestInstancePatternInfos {
	s.Architectures = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestInstancePatternInfos) SetBurstablePerformance(v string) *CreateScalingConfigurationShrinkRequestInstancePatternInfos {
	s.BurstablePerformance = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestInstancePatternInfos) SetCores(v int32) *CreateScalingConfigurationShrinkRequestInstancePatternInfos {
	s.Cores = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestInstancePatternInfos) SetExcludedInstanceTypes(v []*string) *CreateScalingConfigurationShrinkRequestInstancePatternInfos {
	s.ExcludedInstanceTypes = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestInstancePatternInfos) SetInstanceFamilyLevel(v string) *CreateScalingConfigurationShrinkRequestInstancePatternInfos {
	s.InstanceFamilyLevel = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestInstancePatternInfos) SetMaxPrice(v float32) *CreateScalingConfigurationShrinkRequestInstancePatternInfos {
	s.MaxPrice = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestInstancePatternInfos) SetMemory(v float32) *CreateScalingConfigurationShrinkRequestInstancePatternInfos {
	s.Memory = &v
	return s
}

type CreateScalingConfigurationShrinkRequestInstanceTypeOverrides struct {
	// Instance type N that you want to use to override the instance type that is specified in the launch template.
	//
	// If you want to trigger scale-outs based on the weighted capacities of instances, specify InstanceType and WeightedCapacity at the same time. You can specify N instance types by using the Extended Configurations feature. Valid values of N: 1 to 10.
	//
	// > This parameter takes effect only if you specify LaunchTemplateId.
	//
	// You can specify an instance type that is available for purchase as the value of InstanceType.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The weight of instance type N. If you want to trigger scale-outs based on the weighted capacities of instances, you must specify WeightedCapacity after you specify InstanceType.
	//
	// The weight of an instance type specifies the capacity of an instance of the instance type in the scaling group. A higher weight specifies that a smaller number of instances of the specified instance type is required to meet the expected capacity requirement.
	//
	// Performance metrics, such as the number of vCPUs and the memory size of each instance type, may vary. You can specify different weights for different instance types based on your business requirements.
	//
	// Example:
	//
	// *   Current capacity: 0
	// *   Expected capacity: 6
	// *   Capacity of ecs.c5.xlarge: 4
	//
	// To meet the expected capacity requirement, Auto Scaling must create and add two ecs.c5.xlarge instances.
	//
	// > The capacity of the scaling group cannot exceed the sum of the maximum number of instances that is specified by MaxSize and the maximum weight of the instance types.
	//
	// Valid values of WeightedCapacity: 1 to 500.
	WeightedCapacity *int32 `json:"WeightedCapacity,omitempty" xml:"WeightedCapacity,omitempty"`
}

func (s CreateScalingConfigurationShrinkRequestInstanceTypeOverrides) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationShrinkRequestInstanceTypeOverrides) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationShrinkRequestInstanceTypeOverrides) SetInstanceType(v string) *CreateScalingConfigurationShrinkRequestInstanceTypeOverrides {
	s.InstanceType = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestInstanceTypeOverrides) SetWeightedCapacity(v int32) *CreateScalingConfigurationShrinkRequestInstanceTypeOverrides {
	s.WeightedCapacity = &v
	return s
}

type CreateScalingConfigurationShrinkRequestSpotPriceLimits struct {
	// The instance type of the preemptible instance. This parameter takes effect only if you set SpotStrategy to SpotWithPriceLimit.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The price limit of the preemptible instance. This parameter takes effect only if you set SpotStrategy to SpotWithPriceLimit.
	PriceLimit *float32 `json:"PriceLimit,omitempty" xml:"PriceLimit,omitempty"`
}

func (s CreateScalingConfigurationShrinkRequestSpotPriceLimits) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationShrinkRequestSpotPriceLimits) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationShrinkRequestSpotPriceLimits) SetInstanceType(v string) *CreateScalingConfigurationShrinkRequestSpotPriceLimits {
	s.InstanceType = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestSpotPriceLimits) SetPriceLimit(v float32) *CreateScalingConfigurationShrinkRequestSpotPriceLimits {
	s.PriceLimit = &v
	return s
}

type CreateScalingConfigurationResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the scaling configuration.
	ScalingConfigurationId *string `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
}

func (s CreateScalingConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationResponseBody) SetRequestId(v string) *CreateScalingConfigurationResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateScalingConfigurationResponseBody) SetScalingConfigurationId(v string) *CreateScalingConfigurationResponseBody {
	s.ScalingConfigurationId = &v
	return s
}

type CreateScalingConfigurationResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateScalingConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateScalingConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationResponse) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationResponse) SetHeaders(v map[string]*string) *CreateScalingConfigurationResponse {
	s.Headers = v
	return s
}

func (s *CreateScalingConfigurationResponse) SetStatusCode(v int32) *CreateScalingConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateScalingConfigurationResponse) SetBody(v *CreateScalingConfigurationResponseBody) *CreateScalingConfigurationResponse {
	s.Body = v
	return s
}

type CreateScalingGroupRequest struct {
	// Details of the Application Load Balancer (ALB) server groups that you want to associate with the scaling group.
	AlbServerGroups []*CreateScalingGroupRequestAlbServerGroups `json:"AlbServerGroups,omitempty" xml:"AlbServerGroups,omitempty" type:"Repeated"`
	// The allocation policy of instances. Auto Scaling selects instance types based on the allocation policy to create the required number of instances. The policy can be applied to pay-as-you-go instances and preemptible instances. This parameter takes effect only when you set the `MultiAZPolicy` parameter to `COMPOSABLE`. Valid values:
	//
	// *   priority: Auto Scaling selects instance types based on the specified order of the instance types to create the required number of instances.
	// *   lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of instances.
	//
	// Default value: priority.
	AllocationStrategy *string `json:"AllocationStrategy,omitempty" xml:"AllocationStrategy,omitempty"`
	// Specifies whether to evenly distribute instances in the scaling group across zones. This parameter is available only if you set the `MultiAZPolicy` parameter to `COMPOSABLE`. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	AzBalance *bool `json:"AzBalance,omitempty" xml:"AzBalance,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [Ensure idempotence](~~25965~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to automatically create pay-as-you-go instances to meet the requirement on the number of ECS instances when the expected capacity of preemptible instances cannot be provided due to reasons such as cost-related issues and insufficient resources. This parameter is available only if you set the MultiAZPolicy parameter to COST_OPTIMIZED. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: true.
	CompensateWithOnDemand *bool `json:"CompensateWithOnDemand,omitempty" xml:"CompensateWithOnDemand,omitempty"`
	// The ID of the elastic container instance.
	ContainerGroupId *string `json:"ContainerGroupId,omitempty" xml:"ContainerGroupId,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the custom scale-in policy (Function). This parameter is available only if you specify CustomPolicy as the first step to remove instances.
	CustomPolicyARN *string `json:"CustomPolicyARN,omitempty" xml:"CustomPolicyARN,omitempty"`
	// The IDs of the ApsaraDB RDS instances that you want to associate with the scaling group. The value can be a JSON array that contains multiple ApsaraDB RDS instance IDs. Separate multiple IDs with commas (,).
	//
	// You can associate only a limited number of ApsaraDB RDS instances with a scaling group. Go to [Quota Center](https://quotas.console.aliyun.com/products/ess/quotas) to check the maximum number of ApsaraDB RDS instances that you can associate with a scaling group.
	DBInstanceIds *string `json:"DBInstanceIds,omitempty" xml:"DBInstanceIds,omitempty"`
	// The cooldown period of the scaling group after a scaling activity is complete. Valid values: 0 to 86400. Unit: seconds.
	//
	// During the cooldown period, Auto Scaling executes only scaling activities that are triggered by CloudMonitor event-triggered tasks.
	//
	// Default value: 300.
	DefaultCooldown *int32 `json:"DefaultCooldown,omitempty" xml:"DefaultCooldown,omitempty"`
	// The expected number of ECS instances in the scaling group. Auto Scaling automatically maintains the expected number of ECS instances. The value of the DesiredCapacity parameter cannot be greater than the value of the MaxSize parameter and less than the value of the MinSize parameter.
	DesiredCapacity *int32 `json:"DesiredCapacity,omitempty" xml:"DesiredCapacity,omitempty"`
	// Specifies whether to enable deletion protection for the scaling group. Valid values:
	//
	// *   true: enables deletion protection for the scaling group. This way, the scaling group cannot be deleted.
	// *   false: disables deletion protection for the scaling group.
	//
	// Default value: false.
	GroupDeletionProtection *bool `json:"GroupDeletionProtection,omitempty" xml:"GroupDeletionProtection,omitempty"`
	// The type of the instances that are managed by the scaling group. Valid values:
	//
	// *   ECS: ECS instances.
	// *   ECI: elastic container instances.
	//
	// Default value: ECS.
	GroupType *string `json:"GroupType,omitempty" xml:"GroupType,omitempty"`
	// The health check mode of the scaling group. Valid values:
	//
	// *   NONE: Auto Scaling does not perform health checks on instances in the scaling group.
	// *   ECS: Auto Scaling performs health checks on ECS instances in the scaling group.
	//
	// Default value: ECS.
	HealthCheckType *string `json:"HealthCheckType,omitempty" xml:"HealthCheckType,omitempty"`
	// The ID of the existing ECS instance that provides instance configurations for Auto Scaling to create a scaling configuration.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the launch template that provides instance configurations for Auto Scaling to create instances.
	LaunchTemplateId *string `json:"LaunchTemplateId,omitempty" xml:"LaunchTemplateId,omitempty"`
	// Details of the instance types that you specify by using the Extended Configurations feature of the launch template.
	LaunchTemplateOverrides []*CreateScalingGroupRequestLaunchTemplateOverrides `json:"LaunchTemplateOverrides,omitempty" xml:"LaunchTemplateOverrides,omitempty" type:"Repeated"`
	// The version number of the launch template. Valid values:
	//
	// *   A fixed template version number.
	// *   Default: the default template version.
	// *   Latest: the latest template version.
	LaunchTemplateVersion *string `json:"LaunchTemplateVersion,omitempty" xml:"LaunchTemplateVersion,omitempty"`
	// The lifecycle hooks.
	LifecycleHooks      []*CreateScalingGroupRequestLifecycleHooks      `json:"LifecycleHooks,omitempty" xml:"LifecycleHooks,omitempty" type:"Repeated"`
	LoadBalancerConfigs []*CreateScalingGroupRequestLoadBalancerConfigs `json:"LoadBalancerConfigs,omitempty" xml:"LoadBalancerConfigs,omitempty" type:"Repeated"`
	// The IDs of the CLB instances that you want to associate with the scaling group. The value can be a JSON array that contains multiple CLB instance IDs. Separate multiple IDs with commas (,).
	//
	// You can associate only a limited number of CLB instances with a scaling group. Go to [Quota Center](https://quotas.console.aliyun.com/products/ess/quotas) to check the maximum number of CLB instances that you can associate with a scaling group.
	LoadBalancerIds *string `json:"LoadBalancerIds,omitempty" xml:"LoadBalancerIds,omitempty"`
	// The maximum life span of an instance in the scaling group. Unit: seconds.
	//
	// Valid values: 86400 to the value of the Integer.maxValue parameter.
	//
	// Default value: null.
	MaxInstanceLifetime *int32 `json:"MaxInstanceLifetime,omitempty" xml:"MaxInstanceLifetime,omitempty"`
	// The maximum number of ECS instances that can be contained in the scaling group. If the number of ECS instances in the scaling group is greater than the value of the MaxSize parameter, Auto Scaling removes ECS instances from the scaling group to ensure that the number of ECS instances is equal to the value of the MaxSize parameter.
	//
	// The value range of the MaxSize parameter varies based on the instance quota. You can go to [Quota Center](https://quotas.console.aliyun.com/products/ess/quotas) to check the maximum number of instances that a scaling group can contain.****
	//
	// For example, if the instance quota is 2,000, the value range of the **MaxSize** parameter is 0 to 2000.
	MaxSize *int32 `json:"MaxSize,omitempty" xml:"MaxSize,omitempty"`
	// The minimum number of ECS instances that must be contained in the scaling group. If the number of ECS instances in the scaling group is less than the value of the MinSize parameter, Auto Scaling adds ECS instances to the scaling group to ensure that the number of ECS instances in the scaling group is equal to the value of the MinSize parameter.
	//
	// > The value of the MinSize parameter must be less than or equal to the value of the MaxSize parameter.
	MinSize *int32 `json:"MinSize,omitempty" xml:"MinSize,omitempty"`
	// The scaling policy for the multi-zone scaling group that contains ECS instances. Valid values:
	//
	// *   PRIORITY: scales ECS instances based on the priority of the vSwitch that is specified by the VSwitchIds parameter. Auto Scaling preferentially scales instances in the zone where the vSwitch that has the highest priority resides. If the scaling fails, Auto Scaling scales instances in the zone where the vSwitch that has the next highest priority resides.
	//
	// *   COST_OPTIMIZED: scales ECS instances based on the unit price of vCPUs. Auto Scaling preferentially scales out ECS instances whose vCPUs are provided at the lowest price and scales in ECS instances whose vCPUs are provided at the highest price. If preemptible instance types are specified in the scaling configuration, Auto Scaling preferentially scales out preemptible instances. You can use the CompensateWithOnDemand parameter to specify whether to automatically create pay-as-you-go instances when preemptible instances cannot be created due to insufficient resources.
	//
	//     **
	//
	//     **Note**The COST_OPTIMIZED setting takes effect only when multiple instance types are specified or at least one preemptible instance type is specified.
	//
	// *   BALANCE: evenly distributes ECS instances across zones that are specified for the scaling group. If ECS instances are unevenly distributed across zones due to insufficient resources, you can call the [RebalanceInstance](~~71516~~) operation to evenly redistribute the instances across the zones.
	//
	// Default value: PRIORITY.
	MultiAZPolicy *string `json:"MultiAZPolicy,omitempty" xml:"MultiAZPolicy,omitempty"`
	// The minimum number of pay-as-you-go instances that must be contained in the scaling group. Valid values: 0 to 1000. If the number of pay-as-you-go instances is less than the value of this parameter, Auto Scaling preferentially creates pay-as-you-go instances.
	OnDemandBaseCapacity *int32 `json:"OnDemandBaseCapacity,omitempty" xml:"OnDemandBaseCapacity,omitempty"`
	// The percentage of pay-as-you-go instances in the excess instances when the minimum number of pay-as-you-go instances reaches the requirement. Valid values: 0 to 100.
	OnDemandPercentageAboveBaseCapacity *int32  `json:"OnDemandPercentageAboveBaseCapacity,omitempty" xml:"OnDemandPercentageAboveBaseCapacity,omitempty"`
	OwnerAccount                        *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                             *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The instance removal policies. Valid values:
	//
	// *   OldestInstance: removes ECS instances that are added at the earliest point in time to the scaling group.
	// *   NewestInstance: removes ECS instances that are most recently added to the scaling group.
	// *   OldestScalingConfiguration: removes ECS instances that are created based on the earliest scaling configuration.
	// *   CustomPolicy: removes ECS instances based on the custom scale-in policy (Function).
	//
	// The scaling configuration source specified by the OldestScalingConfiguration setting can be a scaling configuration or a launch template. The CustomPolicy setting takes effect only if you specify it as the first step to remove instances. If you specify CustomPolicy, you must also specify the CustomPolicyARN parameter.
	//
	// > The removal of ECS instances from a scaling group is also affected by the value of the MultiAZPolicy parameter. For more information, see the [Configure a combination policy for removing instances](~~254822~~) topic.
	RemovalPolicies []*string `json:"RemovalPolicies,omitempty" xml:"RemovalPolicies,omitempty" type:"Repeated"`
	// The ID of the resource group to which you want to add the scaling group.
	//
	// > If you specify this parameter, new scaling groups are added to the specified resource group. If you do not specify this parameter, new scaling groups are added to the default resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The name of the scaling group. The name of each scaling group must be unique in a region.
	//
	// The name must be 2 to 64 characters in length, and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). The name must start with a letter or a digit.
	//
	// If you do not specify this parameter, the value of the ScalingGroupId parameter is used.
	ScalingGroupName *string `json:"ScalingGroupName,omitempty" xml:"ScalingGroupName,omitempty"`
	// The reclaim mode of the scaling group. Valid values:
	//
	// *   recycle: economical mode.
	// *   release: release mode.
	//
	// The ScalingPolicy parameter specifies the reclaim mode of the scaling group. The RemovePolicy parameter of the RemoveInstances operation specifies how to remove instances in a specific manner.
	ScalingPolicy *string `json:"ScalingPolicy,omitempty" xml:"ScalingPolicy,omitempty"`
	// Details of the server groups.
	//
	// >  You cannot use the AlbServerGroups parameter and the ServerGroups parameter to specify the same server group.
	ServerGroups []*CreateScalingGroupRequestServerGroups `json:"ServerGroups,omitempty" xml:"ServerGroups,omitempty" type:"Repeated"`
	// The allocation policy of preemptible instances. You can use this parameter to individually specify the allocation policy of preemptible instances. This parameter takes effect only if you set the `MultiAZPolicy` parameter to `COMPOSABLE`. Valid values:
	//
	// *   priority: Auto Scaling selects instance types based on the specified order of the instance types to create the required number of preemptible instances.
	// *   lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of preemptible instances.
	//
	// Default value: priority.
	SpotAllocationStrategy *string `json:"SpotAllocationStrategy,omitempty" xml:"SpotAllocationStrategy,omitempty"`
	// The number of available instance types. Auto Scaling evenly creates preemptible instances of multiple instance types that are provided at the lowest cost in the scaling group. Valid values: 1 to 10.
	SpotInstancePools *int32 `json:"SpotInstancePools,omitempty" xml:"SpotInstancePools,omitempty"`
	// Specifies whether to supplement preemptible instances. If you set this parameter to true, Auto Scaling creates an instance to replace a preemptible instance when Auto Scaling receives a system message which indicates that the preemptible instance is to be reclaimed.
	SpotInstanceRemedy *bool `json:"SpotInstanceRemedy,omitempty" xml:"SpotInstanceRemedy,omitempty"`
	// > This parameter is unavailable.
	SyncAlarmRuleToCms *bool `json:"SyncAlarmRuleToCms,omitempty" xml:"SyncAlarmRuleToCms,omitempty"`
	// Details of the tags that you want to add to the scaling group.
	Tags []*CreateScalingGroupRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// Details of the backend vServer groups that you want to associate with the scaling group.
	VServerGroups []*CreateScalingGroupRequestVServerGroups `json:"VServerGroups,omitempty" xml:"VServerGroups,omitempty" type:"Repeated"`
	// The ID of the vSwitch. If you specify the VSwitchId parameter, the network type of the scaling group is VPC.
	//
	// > If you do not specify the VSwitchId or VSwitchIds parameter, the network type of the scaling group is classic network.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The IDs of vSwitches. If you specify the VSwitchIds parameter, the VSwitchId parameter is ignored. If you specify the VSwitchIds parameter, the network type of the scaling group is VPC.
	//
	// If you specify multiple vSwitches, take note of the following items:
	//
	// *   The vSwitches must belong to the same VPC.
	// *   The vSwitches can belong to different zones.
	// *   The vSwitches are sorted in ascending order of priority. The first vSwitch that is specified by the VSwitchIds parameter has the highest priority. If Auto Scaling fails to create ECS instances in the zone where the vSwitch that has the highest priority resides, Auto Scaling creates ECS instances in the zone where the vSwitch that has the next highest priority resides.
	//
	// > If you do not specify the VSwitchId or VSwitchIds parameter, the network type of the scaling group is classic network.
	VSwitchIds []*string `json:"VSwitchIds,omitempty" xml:"VSwitchIds,omitempty" type:"Repeated"`
}

func (s CreateScalingGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateScalingGroupRequest) SetAlbServerGroups(v []*CreateScalingGroupRequestAlbServerGroups) *CreateScalingGroupRequest {
	s.AlbServerGroups = v
	return s
}

func (s *CreateScalingGroupRequest) SetAllocationStrategy(v string) *CreateScalingGroupRequest {
	s.AllocationStrategy = &v
	return s
}

func (s *CreateScalingGroupRequest) SetAzBalance(v bool) *CreateScalingGroupRequest {
	s.AzBalance = &v
	return s
}

func (s *CreateScalingGroupRequest) SetClientToken(v string) *CreateScalingGroupRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateScalingGroupRequest) SetCompensateWithOnDemand(v bool) *CreateScalingGroupRequest {
	s.CompensateWithOnDemand = &v
	return s
}

func (s *CreateScalingGroupRequest) SetContainerGroupId(v string) *CreateScalingGroupRequest {
	s.ContainerGroupId = &v
	return s
}

func (s *CreateScalingGroupRequest) SetCustomPolicyARN(v string) *CreateScalingGroupRequest {
	s.CustomPolicyARN = &v
	return s
}

func (s *CreateScalingGroupRequest) SetDBInstanceIds(v string) *CreateScalingGroupRequest {
	s.DBInstanceIds = &v
	return s
}

func (s *CreateScalingGroupRequest) SetDefaultCooldown(v int32) *CreateScalingGroupRequest {
	s.DefaultCooldown = &v
	return s
}

func (s *CreateScalingGroupRequest) SetDesiredCapacity(v int32) *CreateScalingGroupRequest {
	s.DesiredCapacity = &v
	return s
}

func (s *CreateScalingGroupRequest) SetGroupDeletionProtection(v bool) *CreateScalingGroupRequest {
	s.GroupDeletionProtection = &v
	return s
}

func (s *CreateScalingGroupRequest) SetGroupType(v string) *CreateScalingGroupRequest {
	s.GroupType = &v
	return s
}

func (s *CreateScalingGroupRequest) SetHealthCheckType(v string) *CreateScalingGroupRequest {
	s.HealthCheckType = &v
	return s
}

func (s *CreateScalingGroupRequest) SetInstanceId(v string) *CreateScalingGroupRequest {
	s.InstanceId = &v
	return s
}

func (s *CreateScalingGroupRequest) SetLaunchTemplateId(v string) *CreateScalingGroupRequest {
	s.LaunchTemplateId = &v
	return s
}

func (s *CreateScalingGroupRequest) SetLaunchTemplateOverrides(v []*CreateScalingGroupRequestLaunchTemplateOverrides) *CreateScalingGroupRequest {
	s.LaunchTemplateOverrides = v
	return s
}

func (s *CreateScalingGroupRequest) SetLaunchTemplateVersion(v string) *CreateScalingGroupRequest {
	s.LaunchTemplateVersion = &v
	return s
}

func (s *CreateScalingGroupRequest) SetLifecycleHooks(v []*CreateScalingGroupRequestLifecycleHooks) *CreateScalingGroupRequest {
	s.LifecycleHooks = v
	return s
}

func (s *CreateScalingGroupRequest) SetLoadBalancerConfigs(v []*CreateScalingGroupRequestLoadBalancerConfigs) *CreateScalingGroupRequest {
	s.LoadBalancerConfigs = v
	return s
}

func (s *CreateScalingGroupRequest) SetLoadBalancerIds(v string) *CreateScalingGroupRequest {
	s.LoadBalancerIds = &v
	return s
}

func (s *CreateScalingGroupRequest) SetMaxInstanceLifetime(v int32) *CreateScalingGroupRequest {
	s.MaxInstanceLifetime = &v
	return s
}

func (s *CreateScalingGroupRequest) SetMaxSize(v int32) *CreateScalingGroupRequest {
	s.MaxSize = &v
	return s
}

func (s *CreateScalingGroupRequest) SetMinSize(v int32) *CreateScalingGroupRequest {
	s.MinSize = &v
	return s
}

func (s *CreateScalingGroupRequest) SetMultiAZPolicy(v string) *CreateScalingGroupRequest {
	s.MultiAZPolicy = &v
	return s
}

func (s *CreateScalingGroupRequest) SetOnDemandBaseCapacity(v int32) *CreateScalingGroupRequest {
	s.OnDemandBaseCapacity = &v
	return s
}

func (s *CreateScalingGroupRequest) SetOnDemandPercentageAboveBaseCapacity(v int32) *CreateScalingGroupRequest {
	s.OnDemandPercentageAboveBaseCapacity = &v
	return s
}

func (s *CreateScalingGroupRequest) SetOwnerAccount(v string) *CreateScalingGroupRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateScalingGroupRequest) SetOwnerId(v int64) *CreateScalingGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateScalingGroupRequest) SetRegionId(v string) *CreateScalingGroupRequest {
	s.RegionId = &v
	return s
}

func (s *CreateScalingGroupRequest) SetRemovalPolicies(v []*string) *CreateScalingGroupRequest {
	s.RemovalPolicies = v
	return s
}

func (s *CreateScalingGroupRequest) SetResourceGroupId(v string) *CreateScalingGroupRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateScalingGroupRequest) SetResourceOwnerAccount(v string) *CreateScalingGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateScalingGroupRequest) SetScalingGroupName(v string) *CreateScalingGroupRequest {
	s.ScalingGroupName = &v
	return s
}

func (s *CreateScalingGroupRequest) SetScalingPolicy(v string) *CreateScalingGroupRequest {
	s.ScalingPolicy = &v
	return s
}

func (s *CreateScalingGroupRequest) SetServerGroups(v []*CreateScalingGroupRequestServerGroups) *CreateScalingGroupRequest {
	s.ServerGroups = v
	return s
}

func (s *CreateScalingGroupRequest) SetSpotAllocationStrategy(v string) *CreateScalingGroupRequest {
	s.SpotAllocationStrategy = &v
	return s
}

func (s *CreateScalingGroupRequest) SetSpotInstancePools(v int32) *CreateScalingGroupRequest {
	s.SpotInstancePools = &v
	return s
}

func (s *CreateScalingGroupRequest) SetSpotInstanceRemedy(v bool) *CreateScalingGroupRequest {
	s.SpotInstanceRemedy = &v
	return s
}

func (s *CreateScalingGroupRequest) SetSyncAlarmRuleToCms(v bool) *CreateScalingGroupRequest {
	s.SyncAlarmRuleToCms = &v
	return s
}

func (s *CreateScalingGroupRequest) SetTags(v []*CreateScalingGroupRequestTags) *CreateScalingGroupRequest {
	s.Tags = v
	return s
}

func (s *CreateScalingGroupRequest) SetVServerGroups(v []*CreateScalingGroupRequestVServerGroups) *CreateScalingGroupRequest {
	s.VServerGroups = v
	return s
}

func (s *CreateScalingGroupRequest) SetVSwitchId(v string) *CreateScalingGroupRequest {
	s.VSwitchId = &v
	return s
}

func (s *CreateScalingGroupRequest) SetVSwitchIds(v []*string) *CreateScalingGroupRequest {
	s.VSwitchIds = v
	return s
}

type CreateScalingGroupRequestAlbServerGroups struct {
	// The ID of the ALB server group that you want to associate with the scaling group.
	//
	// You can associate only a limited number of ALB server groups with a scaling group. Go to [Quota Center](https://quotas.console.aliyun.com/products/ess/quotas) to check the maximum number of ALB server groups that you can associate with a scaling group.
	AlbServerGroupId *string `json:"AlbServerGroupId,omitempty" xml:"AlbServerGroupId,omitempty"`
	// The port number that is used by an ECS instance after Auto Scaling adds the ECS instance to the ALB server group. Valid values: 1 to 65535.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The weight of an ECS instance after Auto Scaling adds the ECS instance to the ALB server group as a backend server. If you increase the weight of an ECS instance in the ALB server group, the number of access requests that are forwarded to the ECS instance increases. If you set the Weight parameter for an ECS instance in the ALB server group to 0, no access requests are forwarded to the ECS instance. Valid values: 0 to 100.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s CreateScalingGroupRequestAlbServerGroups) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingGroupRequestAlbServerGroups) GoString() string {
	return s.String()
}

func (s *CreateScalingGroupRequestAlbServerGroups) SetAlbServerGroupId(v string) *CreateScalingGroupRequestAlbServerGroups {
	s.AlbServerGroupId = &v
	return s
}

func (s *CreateScalingGroupRequestAlbServerGroups) SetPort(v int32) *CreateScalingGroupRequestAlbServerGroups {
	s.Port = &v
	return s
}

func (s *CreateScalingGroupRequestAlbServerGroups) SetWeight(v int32) *CreateScalingGroupRequestAlbServerGroups {
	s.Weight = &v
	return s
}

type CreateScalingGroupRequestLaunchTemplateOverrides struct {
	// The instance type that you want to use to override the instance type that is specified in the launch template.
	//
	// If you want to scale instances based on the weighted capacities of the instances, you must specify both the InstanceType and WeightedCapacity parameters.
	//
	// > This parameter is available only if you specify the LaunchTemplateId parameter.
	//
	// You can use the InstanceType parameter to specify only instance types that are available for purchase.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The maximum bid price of the instance type that is specified by the `InstanceType` parameter. You can specify 1 to 10 instance types by using the Extended Configurations feature of the launch template.
	//
	// > This parameter is available only if you specify the `LaunchTemplateId` parameter.
	SpotPriceLimit *float32 `json:"SpotPriceLimit,omitempty" xml:"SpotPriceLimit,omitempty"`
	// The weight of the instance type. The weight specifies the capacity of an instance of the specified instance type in the scaling group. If you want to scale instances based on the weighted capacities of the instances, you must specify the WeightedCapacity parameter after you specify the InstanceType parameter.
	//
	// A higher weight specifies that a smaller number of instances of the specified instance type are required to meet the expected capacity requirement.
	//
	// Performance metrics, such as the number of vCPUs and the memory size of each instance type, may vary. You can specify different weights for different instance types based on your business requirements.
	//
	// Example:
	//
	// *   Current capacity: 0
	// *   Expected capacity: 6
	// *   Capacity of ecs.c5.xlarge: 4
	//
	// To meet the expected capacity requirement, Auto Scaling must create and add two ecs.c5.xlarge instances.
	//
	// > The capacity of the scaling group cannot exceed the sum of the maximum number of instances that is specified by the MaxSize parameter and the maximum weight of the instance types.
	//
	// Valid values of the WeightedCapacity parameter: 1 to 500.
	WeightedCapacity *int32 `json:"WeightedCapacity,omitempty" xml:"WeightedCapacity,omitempty"`
}

func (s CreateScalingGroupRequestLaunchTemplateOverrides) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingGroupRequestLaunchTemplateOverrides) GoString() string {
	return s.String()
}

func (s *CreateScalingGroupRequestLaunchTemplateOverrides) SetInstanceType(v string) *CreateScalingGroupRequestLaunchTemplateOverrides {
	s.InstanceType = &v
	return s
}

func (s *CreateScalingGroupRequestLaunchTemplateOverrides) SetSpotPriceLimit(v float32) *CreateScalingGroupRequestLaunchTemplateOverrides {
	s.SpotPriceLimit = &v
	return s
}

func (s *CreateScalingGroupRequestLaunchTemplateOverrides) SetWeightedCapacity(v int32) *CreateScalingGroupRequestLaunchTemplateOverrides {
	s.WeightedCapacity = &v
	return s
}

type CreateScalingGroupRequestLifecycleHooks struct {
	// The action that Auto Scaling performs after the lifecycle hook of the scaling group times out. Valid values:
	//
	// *   CONTINUE: continues to respond to scaling requests.
	// *   ABANDON: releases ECS instances that are created during scale-out activities, or removes ECS instances from the scaling group during scale-in activities.
	//
	// If multiple lifecycle hooks in the scaling group are triggered during scale-in activities and you set the LifecycleHook.N.DefaultResult parameter to ABANDON for one of the lifecycle hooks, Auto Scaling immediately performs the action after the lifecycle hook whose DefaultResult parameter is set to ABANDON times out. In this case, other lifecycle hooks time out ahead of schedule. In other cases, Auto Scaling performs the action only after all lifecycle hooks time out. The action that Auto Scaling performs is determined by the value of the DefaultResult parameter that you set for the lifecycle hook that last times out.
	//
	// Default value: CONTINUE.
	DefaultResult *string `json:"DefaultResult,omitempty" xml:"DefaultResult,omitempty"`
	// The period of time before the lifecycle hook times out. When the lifecycle hook times out, Auto Scaling performs the action specified by the DefaultResult parameter. Valid values: 30 to 21600. Unit: seconds.
	//
	// After you create a lifecycle hook, you can call the RecordLifecycleActionHeartbeat operation to extend the timeout period of the lifecycle hook. You can also call the CompleteLifecycleAction operation to end the timeout period ahead of schedule.
	//
	// Default value: 600.
	HeartbeatTimeout *int32 `json:"HeartbeatTimeout,omitempty" xml:"HeartbeatTimeout,omitempty"`
	// The name of the lifecycle hook. After you specify this parameter, you cannot change the value of this parameter. If you do not specify this parameter, the ID of the lifecycle hook is used.
	LifecycleHookName *string `json:"LifecycleHookName,omitempty" xml:"LifecycleHookName,omitempty"`
	// The type of the scaling activity for which you create the lifecycle hook. Valid values:
	//
	// *   SCALE_OUT: scale-out activity
	// *   SCALE_IN: scale-in activity
	//
	// > If you create lifecycle hooks for your scaling group, you must specify the LifecycleTransition parameter.
	LifecycleTransition *string `json:"LifecycleTransition,omitempty" xml:"LifecycleTransition,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the notification method that Auto Scaling uses to send a notification when a lifecycle hook takes effect. This notification method can be a Message Service (MNS) queue or an MNS topic. Specify the value of this parameter in the following format: acs:ess:{region}:{account-id}:{resource-relative-id}.
	//
	// *   region: the region where the scaling group resides
	// *   account-id: the ID of the Alibaba Cloud account
	//
	// Examples:
	//
	// *   MNS queue: acs:ess:{region}:{account-id}:queue/{queuename}
	// *   MNS topic: acs:ess:{region}:{account-id}:topic/{topicname}
	NotificationArn *string `json:"NotificationArn,omitempty" xml:"NotificationArn,omitempty"`
	// The fixed string that is included in a notification. Auto Scaling sends the notification when the lifecycle hook takes effect. The value of this parameter cannot exceed 4,096 characters in length. Auto Scaling sends the value of the notificationmetadata parameter together with the notification. This way, you can categorize and manage your notifications in an efficient manner. If you specify the notificationmetadata parameter, you must also specify the notificationarn parameter.
	NotificationMetadata *string `json:"NotificationMetadata,omitempty" xml:"NotificationMetadata,omitempty"`
}

func (s CreateScalingGroupRequestLifecycleHooks) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingGroupRequestLifecycleHooks) GoString() string {
	return s.String()
}

func (s *CreateScalingGroupRequestLifecycleHooks) SetDefaultResult(v string) *CreateScalingGroupRequestLifecycleHooks {
	s.DefaultResult = &v
	return s
}

func (s *CreateScalingGroupRequestLifecycleHooks) SetHeartbeatTimeout(v int32) *CreateScalingGroupRequestLifecycleHooks {
	s.HeartbeatTimeout = &v
	return s
}

func (s *CreateScalingGroupRequestLifecycleHooks) SetLifecycleHookName(v string) *CreateScalingGroupRequestLifecycleHooks {
	s.LifecycleHookName = &v
	return s
}

func (s *CreateScalingGroupRequestLifecycleHooks) SetLifecycleTransition(v string) *CreateScalingGroupRequestLifecycleHooks {
	s.LifecycleTransition = &v
	return s
}

func (s *CreateScalingGroupRequestLifecycleHooks) SetNotificationArn(v string) *CreateScalingGroupRequestLifecycleHooks {
	s.NotificationArn = &v
	return s
}

func (s *CreateScalingGroupRequestLifecycleHooks) SetNotificationMetadata(v string) *CreateScalingGroupRequestLifecycleHooks {
	s.NotificationMetadata = &v
	return s
}

type CreateScalingGroupRequestLoadBalancerConfigs struct {
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	Weight         *int32  `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s CreateScalingGroupRequestLoadBalancerConfigs) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingGroupRequestLoadBalancerConfigs) GoString() string {
	return s.String()
}

func (s *CreateScalingGroupRequestLoadBalancerConfigs) SetLoadBalancerId(v string) *CreateScalingGroupRequestLoadBalancerConfigs {
	s.LoadBalancerId = &v
	return s
}

func (s *CreateScalingGroupRequestLoadBalancerConfigs) SetWeight(v int32) *CreateScalingGroupRequestLoadBalancerConfigs {
	s.Weight = &v
	return s
}

type CreateScalingGroupRequestServerGroups struct {
	// The port number that is used by an ECS instance after Auto Scaling adds the ECS instance to the server group. Valid values: 1 to 65535.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The ID of the server group.
	ServerGroupId *string `json:"ServerGroupId,omitempty" xml:"ServerGroupId,omitempty"`
	// The type of the server group. Valid values:
	//
	// *   ALB: Application Load Balancer (ALB) server group
	// *   NLB: Network Load Balancer (NLB) server group
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The weight of an Elastic Compute Service (ECS) instance in the scaling group as a backend server after Auto Scaling adds the ECS instance to the server group. Valid values: 0 to 100.
	//
	// If you increase the weight of an ECS instance in the server group, the number of access requests that are forwarded to the ECS instance also increases. If you set the Weight parameter of an ECS instance in the server group to 0, no access requests are forwarded to the ECS instance.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s CreateScalingGroupRequestServerGroups) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingGroupRequestServerGroups) GoString() string {
	return s.String()
}

func (s *CreateScalingGroupRequestServerGroups) SetPort(v int32) *CreateScalingGroupRequestServerGroups {
	s.Port = &v
	return s
}

func (s *CreateScalingGroupRequestServerGroups) SetServerGroupId(v string) *CreateScalingGroupRequestServerGroups {
	s.ServerGroupId = &v
	return s
}

func (s *CreateScalingGroupRequestServerGroups) SetType(v string) *CreateScalingGroupRequestServerGroups {
	s.Type = &v
	return s
}

func (s *CreateScalingGroupRequestServerGroups) SetWeight(v int32) *CreateScalingGroupRequestServerGroups {
	s.Weight = &v
	return s
}

type CreateScalingGroupRequestTags struct {
	// The tag key that you want to add to the scaling group.
	Key       *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Propagate *bool   `json:"Propagate,omitempty" xml:"Propagate,omitempty"`
	// The tag value that you want to add to the scaling group.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateScalingGroupRequestTags) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingGroupRequestTags) GoString() string {
	return s.String()
}

func (s *CreateScalingGroupRequestTags) SetKey(v string) *CreateScalingGroupRequestTags {
	s.Key = &v
	return s
}

func (s *CreateScalingGroupRequestTags) SetPropagate(v bool) *CreateScalingGroupRequestTags {
	s.Propagate = &v
	return s
}

func (s *CreateScalingGroupRequestTags) SetValue(v string) *CreateScalingGroupRequestTags {
	s.Value = &v
	return s
}

type CreateScalingGroupRequestVServerGroups struct {
	// The ID of the CLB instance to which the backend vServer group belongs.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The attributes of the backend vServer groups.
	VServerGroupAttributes []*CreateScalingGroupRequestVServerGroupsVServerGroupAttributes `json:"VServerGroupAttributes,omitempty" xml:"VServerGroupAttributes,omitempty" type:"Repeated"`
}

func (s CreateScalingGroupRequestVServerGroups) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingGroupRequestVServerGroups) GoString() string {
	return s.String()
}

func (s *CreateScalingGroupRequestVServerGroups) SetLoadBalancerId(v string) *CreateScalingGroupRequestVServerGroups {
	s.LoadBalancerId = &v
	return s
}

func (s *CreateScalingGroupRequestVServerGroups) SetVServerGroupAttributes(v []*CreateScalingGroupRequestVServerGroupsVServerGroupAttributes) *CreateScalingGroupRequestVServerGroups {
	s.VServerGroupAttributes = v
	return s
}

type CreateScalingGroupRequestVServerGroupsVServerGroupAttributes struct {
	// The port number that is used by an ECS instance after Auto Scaling adds the ECS instance to the backend vServer group. Valid values: 1 to 65535.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The ID of the backend vServer group.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	// The weight of an ECS instance after Auto Scaling adds the ECS instance to the backend vServer group as a backend server. If you increase the weight of an ECS instance in the backend vServer group, the number of access requests that are forwarded to the ECS instance also increases. If you set the Weight parameter of an ECS instance in the backend vServer group to 0, no access requests are forwarded to the ECS instance. Valid values: 0 to 100. Default value: 50.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s CreateScalingGroupRequestVServerGroupsVServerGroupAttributes) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingGroupRequestVServerGroupsVServerGroupAttributes) GoString() string {
	return s.String()
}

func (s *CreateScalingGroupRequestVServerGroupsVServerGroupAttributes) SetPort(v int32) *CreateScalingGroupRequestVServerGroupsVServerGroupAttributes {
	s.Port = &v
	return s
}

func (s *CreateScalingGroupRequestVServerGroupsVServerGroupAttributes) SetVServerGroupId(v string) *CreateScalingGroupRequestVServerGroupsVServerGroupAttributes {
	s.VServerGroupId = &v
	return s
}

func (s *CreateScalingGroupRequestVServerGroupsVServerGroupAttributes) SetWeight(v int32) *CreateScalingGroupRequestVServerGroupsVServerGroupAttributes {
	s.Weight = &v
	return s
}

type CreateScalingGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s CreateScalingGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingGroupResponseBody) GoString() string {
	return s.String()
}

func (s *CreateScalingGroupResponseBody) SetRequestId(v string) *CreateScalingGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateScalingGroupResponseBody) SetScalingGroupId(v string) *CreateScalingGroupResponseBody {
	s.ScalingGroupId = &v
	return s
}

type CreateScalingGroupResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateScalingGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateScalingGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateScalingGroupResponse) SetHeaders(v map[string]*string) *CreateScalingGroupResponse {
	s.Headers = v
	return s
}

func (s *CreateScalingGroupResponse) SetStatusCode(v int32) *CreateScalingGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateScalingGroupResponse) SetBody(v *CreateScalingGroupResponseBody) *CreateScalingGroupResponse {
	s.Body = v
	return s
}

type CreateScalingRuleRequest struct {
	// The scaling method of the scaling rule. This parameter is required only if you set the ScalingRuleType parameter to SimpleScalingRule or StepScalingRule. Valid values:
	//
	// *   QuantityChangeInCapacity: adds the specified number of ECS instances to or removes the specified number of ECS instances from the scaling group.
	// *   PercentChangeInCapacity: adds the specified percentage of ECS instances to or removes the specified percentage of ECS instances from the scaling group.
	// *   TotalCapacity: adjusts the number of ECS instances in the scaling group to a specified number.
	AdjustmentType *string `json:"AdjustmentType,omitempty" xml:"AdjustmentType,omitempty"`
	// The number of instances that must be scaled based on the scaling rule. This parameter is required only if you set the ScalingRuleType parameter to SimpleScalingRule or StepScalingRule. The number of ECS instances that are scaled in a single scaling activity cannot exceed 1,000.
	//
	// *   Valid values if you set the AdjustmentType parameter to QuantityChangeInCapacity: -1000 to 1000.
	// *   Valid values if you set the AdjustmentType parameter to PercentChangeInCapacity: -100 to 10000.
	// *   Valid values if you set the AdjustmentType parameter to TotalCapacity: 0 to 2000.
	AdjustmentValue *int32 `json:"AdjustmentValue,omitempty" xml:"AdjustmentValue,omitempty"`
	// 监控项维度信息值，适用于目标追踪规则，当监控项需额外维度信息时设置，例如LoadBalancerRealServerAverageQps监控项需指定rulePool维度键值信息。
	AlarmDimensions []*CreateScalingRuleRequestAlarmDimensions `json:"AlarmDimensions,omitempty" xml:"AlarmDimensions,omitempty" type:"Repeated"`
	// The cooldown time of the scaling rule. This parameter is available only if you set the ScalingRuleType parameter to SimpleScalingRule. Valid values: 0 to 86400. Unit: seconds.
	//
	// By default, this parameter is left empty.
	Cooldown *int32 `json:"Cooldown,omitempty" xml:"Cooldown,omitempty"`
	// Specifies whether to disable scale-in. This parameter is available only if you set the ScalingRuleType parameter to TargetTrackingScalingRule.
	//
	// Default value: false.
	DisableScaleIn *bool `json:"DisableScaleIn,omitempty" xml:"DisableScaleIn,omitempty"`
	// The warmup period of an instance. This parameter is available only if you set the ScalingRuleType parameter to TargetTrackingScalingRule or PredictiveScalingRule. Auto Scaling adds ECS instances that are in the warmup state to a scaling group but does not report monitoring data to CloudMonitor during the warmup period.
	//
	// > Auto Scaling calculates the number of ECS instances that must be scaled. ECS instances in the warmup state are not counted towards the current capacity of the scaling group.
	//
	// Valid values: 0 to 86400. Unit: seconds.
	//
	// Default value: 300.
	EstimatedInstanceWarmup *int32 `json:"EstimatedInstanceWarmup,omitempty" xml:"EstimatedInstanceWarmup,omitempty"`
	// The maximum number of ECS instances in the scaling group. If you specify this parameter, you must also specify the PredictiveValueBehavior parameter.
	//
	// The default value of this parameter is the value of the MaxSize parameter.
	InitialMaxSize *int32 `json:"InitialMaxSize,omitempty" xml:"InitialMaxSize,omitempty"`
	// The predefined metric that you want to monitor. This parameter is required only if you set the ScalingRuleType parameter to TargetTrackingScalingRule or PredictiveScalingRule.
	//
	// Valid values if you set the ScalingRuleType parameter to TargetTrackingScalingRule:
	//
	// *   CpuUtilization: the average CPU utilization
	// *   ClassicInternetRx: the average inbound Internet traffic over the classic network
	// *   ClassicInternetTx: the average outbound Internet traffic over the classic network
	// *   VpcInternetRx: the average inbound Internet traffic over the virtual private cloud (VPC)
	// *   VpcInternetTx: the average outbound Internet traffic over the VPC
	// *   IntranetRx: the average inbound traffic over the internal network
	// *   IntranetTx: the average outbound traffic over the internal network
	//
	// Valid values if you set the ScalingRuleType parameter to PredictiveScalingRule:
	//
	// *   CpuUtilization: the average CPU utilization
	// *   IntranetRx: the average inbound traffic over the internal network
	// *   IntranetTx: the average outbound traffic over the internal network
	MetricName *string `json:"MetricName,omitempty" xml:"MetricName,omitempty"`
	// The minimum number of instances that must be scaled when the AdjustmentType parameter is set to PercentChangeInCapacity. This parameter takes effect only if you set the ScalingRuleType parameter to SimpleScalingRule or StepScalingRule.
	MinAdjustmentMagnitude *int32  `json:"MinAdjustmentMagnitude,omitempty" xml:"MinAdjustmentMagnitude,omitempty"`
	OwnerAccount           *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The mode of the predictive scaling rule. Valid values:
	//
	// *   PredictAndScale: produces predictions and creates prediction tasks.
	// *   PredictOnly: produces predictions but does not create prediction tasks.
	//
	// Default value: PredictAndScale.
	PredictiveScalingMode *string `json:"PredictiveScalingMode,omitempty" xml:"PredictiveScalingMode,omitempty"`
	// The amount of buffer time before the prediction task is executed. By default, all prediction tasks that are automatically created for a predictive scaling rule are executed on the hour. You can specify an amount of buffer time for resource preparation before the prediction tasks are executed. Valid values: 0 to 60. Unit: minutes.
	//
	// Default value: 0.
	PredictiveTaskBufferTime *int32 `json:"PredictiveTaskBufferTime,omitempty" xml:"PredictiveTaskBufferTime,omitempty"`
	// The maximum value for predication tasks. Valid values:
	//
	// *   MaxOverridePredictiveValue: uses the initial maximum capacity as the maximum value for prediction tasks if the predicted value is greater than the initial maximum capacity.
	// *   PredictiveValueOverrideMax: uses the predicted value as the maximum value for prediction tasks if the predicted value is greater than the initial maximum capacity.
	// *   PredictiveValueOverrideMaxWithBuffer: increases the predicted value by a percentage that is specified by the PredictiveValueBuffer parameter. If the predicted value that is increased by the percentage is greater than the initial maximum capacity, the increased value is used as the maximum value for prediction tasks.
	//
	// Default value: MaxOverridePredictiveValue.
	PredictiveValueBehavior *string `json:"PredictiveValueBehavior,omitempty" xml:"PredictiveValueBehavior,omitempty"`
	// The percentage of the increment to the predicted value when the PredictiveValueBehavior parameter is set to PredictiveValueOverrideMaxWithBuffer. If the predicted value increased by this percentage is greater than the initial maximum capacity, the increased value is used as the maximum value for prediction tasks. Valid values: 0 to 100.
	//
	// Default value: 0.
	PredictiveValueBuffer *int32 `json:"PredictiveValueBuffer,omitempty" xml:"PredictiveValueBuffer,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The number of consecutive times that the event-triggered task created for scale-in activities must meet the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.
	//
	// Default value: 15.
	ScaleInEvaluationCount *int32 `json:"ScaleInEvaluationCount,omitempty" xml:"ScaleInEvaluationCount,omitempty"`
	// The number of consecutive times that the event-triggered task created for scale-out activities must meet the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.
	//
	// Default value: 3.
	ScaleOutEvaluationCount *int32 `json:"ScaleOutEvaluationCount,omitempty" xml:"ScaleOutEvaluationCount,omitempty"`
	// The ID of the scaling group to which the scaling rule belongs.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The name of the scaling rule. It must be 2 to 64 characters in length, and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). It must start with a letter or a digit. The name of a scaling rule must be unique in the scaling group to which the scaling rule belongs and within an Alibaba Cloud account.
	//
	// If you do not specify this parameter, the value of the ScalingRuleId parameter is used.
	ScalingRuleName *string `json:"ScalingRuleName,omitempty" xml:"ScalingRuleName,omitempty"`
	// The type of the scaling rule. Valid values:
	//
	// *   SimpleScalingRule: scales the number of ECS instances based on the values that are specified for the AdjustmentType and AdjustmentValue parameters.
	// *   TargetTrackingScalingRule: calculates the number of ECS instances that must be scaled and maintains the value of a predefined metric close to the value that is specified for the TargetValue parameter.
	// *   StepScalingRule: scales ECS instances in steps based on the specified thresholds and metric values.
	// *   PredictiveScalingRule: uses machine learning to analyze historical monitoring data of the scaling group and predicts the future values of metrics. In addition, Auto Scaling automatically creates scheduled tasks to specify the boundary values for the scaling group.
	//
	// Default value: SimpleScalingRule.
	ScalingRuleType *string `json:"ScalingRuleType,omitempty" xml:"ScalingRuleType,omitempty"`
	// Details of the step adjustments.
	StepAdjustments []*CreateScalingRuleRequestStepAdjustments `json:"StepAdjustments,omitempty" xml:"StepAdjustments,omitempty" type:"Repeated"`
	// The target value. This parameter is required only if you set the ScalingRuleType parameter to TargetTrackingScalingRule or PredictiveScalingRule. The value must be greater than 0 and can have up to three decimal places.
	TargetValue *float32 `json:"TargetValue,omitempty" xml:"TargetValue,omitempty"`
}

func (s CreateScalingRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingRuleRequest) GoString() string {
	return s.String()
}

func (s *CreateScalingRuleRequest) SetAdjustmentType(v string) *CreateScalingRuleRequest {
	s.AdjustmentType = &v
	return s
}

func (s *CreateScalingRuleRequest) SetAdjustmentValue(v int32) *CreateScalingRuleRequest {
	s.AdjustmentValue = &v
	return s
}

func (s *CreateScalingRuleRequest) SetAlarmDimensions(v []*CreateScalingRuleRequestAlarmDimensions) *CreateScalingRuleRequest {
	s.AlarmDimensions = v
	return s
}

func (s *CreateScalingRuleRequest) SetCooldown(v int32) *CreateScalingRuleRequest {
	s.Cooldown = &v
	return s
}

func (s *CreateScalingRuleRequest) SetDisableScaleIn(v bool) *CreateScalingRuleRequest {
	s.DisableScaleIn = &v
	return s
}

func (s *CreateScalingRuleRequest) SetEstimatedInstanceWarmup(v int32) *CreateScalingRuleRequest {
	s.EstimatedInstanceWarmup = &v
	return s
}

func (s *CreateScalingRuleRequest) SetInitialMaxSize(v int32) *CreateScalingRuleRequest {
	s.InitialMaxSize = &v
	return s
}

func (s *CreateScalingRuleRequest) SetMetricName(v string) *CreateScalingRuleRequest {
	s.MetricName = &v
	return s
}

func (s *CreateScalingRuleRequest) SetMinAdjustmentMagnitude(v int32) *CreateScalingRuleRequest {
	s.MinAdjustmentMagnitude = &v
	return s
}

func (s *CreateScalingRuleRequest) SetOwnerAccount(v string) *CreateScalingRuleRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateScalingRuleRequest) SetOwnerId(v int64) *CreateScalingRuleRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateScalingRuleRequest) SetPredictiveScalingMode(v string) *CreateScalingRuleRequest {
	s.PredictiveScalingMode = &v
	return s
}

func (s *CreateScalingRuleRequest) SetPredictiveTaskBufferTime(v int32) *CreateScalingRuleRequest {
	s.PredictiveTaskBufferTime = &v
	return s
}

func (s *CreateScalingRuleRequest) SetPredictiveValueBehavior(v string) *CreateScalingRuleRequest {
	s.PredictiveValueBehavior = &v
	return s
}

func (s *CreateScalingRuleRequest) SetPredictiveValueBuffer(v int32) *CreateScalingRuleRequest {
	s.PredictiveValueBuffer = &v
	return s
}

func (s *CreateScalingRuleRequest) SetRegionId(v string) *CreateScalingRuleRequest {
	s.RegionId = &v
	return s
}

func (s *CreateScalingRuleRequest) SetResourceOwnerAccount(v string) *CreateScalingRuleRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateScalingRuleRequest) SetScaleInEvaluationCount(v int32) *CreateScalingRuleRequest {
	s.ScaleInEvaluationCount = &v
	return s
}

func (s *CreateScalingRuleRequest) SetScaleOutEvaluationCount(v int32) *CreateScalingRuleRequest {
	s.ScaleOutEvaluationCount = &v
	return s
}

func (s *CreateScalingRuleRequest) SetScalingGroupId(v string) *CreateScalingRuleRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *CreateScalingRuleRequest) SetScalingRuleName(v string) *CreateScalingRuleRequest {
	s.ScalingRuleName = &v
	return s
}

func (s *CreateScalingRuleRequest) SetScalingRuleType(v string) *CreateScalingRuleRequest {
	s.ScalingRuleType = &v
	return s
}

func (s *CreateScalingRuleRequest) SetStepAdjustments(v []*CreateScalingRuleRequestStepAdjustments) *CreateScalingRuleRequest {
	s.StepAdjustments = v
	return s
}

func (s *CreateScalingRuleRequest) SetTargetValue(v float32) *CreateScalingRuleRequest {
	s.TargetValue = &v
	return s
}

type CreateScalingRuleRequestAlarmDimensions struct {
	// 监控项关联的维度信息键。
	DimensionKey *string `json:"DimensionKey,omitempty" xml:"DimensionKey,omitempty"`
	// 监控项关联的维度信息值。
	DimensionValue *string `json:"DimensionValue,omitempty" xml:"DimensionValue,omitempty"`
}

func (s CreateScalingRuleRequestAlarmDimensions) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingRuleRequestAlarmDimensions) GoString() string {
	return s.String()
}

func (s *CreateScalingRuleRequestAlarmDimensions) SetDimensionKey(v string) *CreateScalingRuleRequestAlarmDimensions {
	s.DimensionKey = &v
	return s
}

func (s *CreateScalingRuleRequestAlarmDimensions) SetDimensionValue(v string) *CreateScalingRuleRequestAlarmDimensions {
	s.DimensionValue = &v
	return s
}

type CreateScalingRuleRequestStepAdjustments struct {
	// The lower limit specified in a step adjustment. This parameter is available only if you set the ScalingRuleType parameter to StepScalingRule. Valid values: -9.999999E18 to 9.999999E18.
	MetricIntervalLowerBound *float32 `json:"MetricIntervalLowerBound,omitempty" xml:"MetricIntervalLowerBound,omitempty"`
	// The upper limit that is specified in a step adjustment. Valid values: -9.999999E18 to 9.999999E18.
	MetricIntervalUpperBound *float32 `json:"MetricIntervalUpperBound,omitempty" xml:"MetricIntervalUpperBound,omitempty"`
	// The number of ECS instances that you want to scale in a step adjustment. This parameter is available only if you set the ScalingRuleType parameter to StepScalingRule.
	ScalingAdjustment *int32 `json:"ScalingAdjustment,omitempty" xml:"ScalingAdjustment,omitempty"`
}

func (s CreateScalingRuleRequestStepAdjustments) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingRuleRequestStepAdjustments) GoString() string {
	return s.String()
}

func (s *CreateScalingRuleRequestStepAdjustments) SetMetricIntervalLowerBound(v float32) *CreateScalingRuleRequestStepAdjustments {
	s.MetricIntervalLowerBound = &v
	return s
}

func (s *CreateScalingRuleRequestStepAdjustments) SetMetricIntervalUpperBound(v float32) *CreateScalingRuleRequestStepAdjustments {
	s.MetricIntervalUpperBound = &v
	return s
}

func (s *CreateScalingRuleRequestStepAdjustments) SetScalingAdjustment(v int32) *CreateScalingRuleRequestStepAdjustments {
	s.ScalingAdjustment = &v
	return s
}

type CreateScalingRuleResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The unique identifier of the scaling rule.
	ScalingRuleAri *string `json:"ScalingRuleAri,omitempty" xml:"ScalingRuleAri,omitempty"`
	// The ID of the scaling rule, which is generated by the system and is globally unique.
	ScalingRuleId *string `json:"ScalingRuleId,omitempty" xml:"ScalingRuleId,omitempty"`
}

func (s CreateScalingRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingRuleResponseBody) GoString() string {
	return s.String()
}

func (s *CreateScalingRuleResponseBody) SetRequestId(v string) *CreateScalingRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateScalingRuleResponseBody) SetScalingRuleAri(v string) *CreateScalingRuleResponseBody {
	s.ScalingRuleAri = &v
	return s
}

func (s *CreateScalingRuleResponseBody) SetScalingRuleId(v string) *CreateScalingRuleResponseBody {
	s.ScalingRuleId = &v
	return s
}

type CreateScalingRuleResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateScalingRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateScalingRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingRuleResponse) GoString() string {
	return s.String()
}

func (s *CreateScalingRuleResponse) SetHeaders(v map[string]*string) *CreateScalingRuleResponse {
	s.Headers = v
	return s
}

func (s *CreateScalingRuleResponse) SetStatusCode(v int32) *CreateScalingRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateScalingRuleResponse) SetBody(v *CreateScalingRuleResponseBody) *CreateScalingRuleResponse {
	s.Body = v
	return s
}

type CreateScheduledTaskRequest struct {
	// The description of the scheduled task. The description must be 2 to 200 characters in length.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The expected number of instances in the scaling group if you specify the ScalingGroupId parameter.
	//
	// > You must specify the `DesiredCapacity` parameter when you create a scaling group.
	DesiredCapacity *int32 `json:"DesiredCapacity,omitempty" xml:"DesiredCapacity,omitempty"`
	// The time period during which the failed scheduled task can be retried. Unit: seconds. Valid values: 0 to 1800.
	//
	// Default value: 600.
	LaunchExpirationTime *int32 `json:"LaunchExpirationTime,omitempty" xml:"LaunchExpirationTime,omitempty"`
	// The point in time at which the scheduled task is triggered. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mmZ format. The time must be in UTC. You cannot enter a point in time that is later than 90 days from the point in time at which the scheduled task is created.
	//
	// *   If you specify the `RecurrenceType` parameter, the scheduled task is repeatedly executed at the point in time that is specified by the LaunchTime parameter.
	// *   If you do not specify the `RecurrenceType` parameter, the task is executed only once at the point in time that is specified by the LaunchTime parameter.
	LaunchTime *string `json:"LaunchTime,omitempty" xml:"LaunchTime,omitempty"`
	// The maximum number of instances in the scaling group if you specify the ScalingGroupId parameter.
	MaxValue *int32 `json:"MaxValue,omitempty" xml:"MaxValue,omitempty"`
	// The minimum number of instances in the scaling group if you specify the ScalingGroupId parameter.
	MinValue     *int32  `json:"MinValue,omitempty" xml:"MinValue,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The end time of the scheduled task. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mmZ format.
	//
	// The time must be in UTC. You cannot enter a point in time that is later than 365 days from the point in time at which the scheduled task is created.
	RecurrenceEndTime *string `json:"RecurrenceEndTime,omitempty" xml:"RecurrenceEndTime,omitempty"`
	// The interval at which the scheduled task is repeated. Valid values:
	//
	// *   Daily: The scheduled task is executed once every specified number of days.
	// *   Weekly: The scheduled task is executed on each specified day of the week.
	// *   Monthly: The scheduled task is executed on each specified day of the month.
	// *   Cron: The scheduled task is executed based on the specified cron expression.
	//
	// You must specify the `RecurrenceType` and `RecurrenceValue` parameters at the same time.
	RecurrenceType *string `json:"RecurrenceType,omitempty" xml:"RecurrenceType,omitempty"`
	// The number of recurrences of the scheduled task.
	//
	// *   If you set the `RecurrenceType` parameter to `Daily`, you can specify only one value for this parameter. Valid values: 1 to 31.
	// *   If you set the `RecurrenceType` parameter to `Weekly`, you can specify multiple values for this parameter. Separate the values with commas (,). The values that correspond to Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, and Saturday are 0, 1, 2, 3, 4, 5, and 6.``
	// *   If you set the `RecurrenceType` parameter to `Monthly`, you can specify two values in the `A-B` format for this parameter. Valid values of A and B: 1 to 31. B must be greater than or equal to A.
	// *   If you set the `RecurrenceType` parameter to `Cron`, you can specify a cron expression. A cron expression is written in UTC time and consists of the following fields: minute, hour, day, month, and week. The expression can contain the letters L and W and the following wildcard characters: commas (,), question marks (?), hyphens (-), asterisks (\*), number signs (#), and forward slashes (/).
	//
	// You must specify both the `RecurrenceType` parameter and the `RecurrenceValue` parameter.
	RecurrenceValue *string `json:"RecurrenceValue,omitempty" xml:"RecurrenceValue,omitempty"`
	// The region ID of the scheduled task.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group whose number of instances must be modified when the scheduled task is triggered. If you specify the `ScalingGroupId` parameter for a scheduled task, you must specify the minimum, maximum, or expected numbers of instances for a scaling group in the scheduled task. That is, you must specify at least one of the `MinValue`, `MaxValue`, and `DesiredCapacity` parameters.
	//
	// > You cannot specify the `ScheduledAction` and `ScalingGroupId` parameters at the same time.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The scaling rule that you want to execute when the scheduled task is triggered. Specify the unique identifier of the scaling rule. If you specify the `ScheduledAction` parameter, you must select an existing scaling rule for the scheduled task.
	//
	// > You cannot specify the `ScheduledAction` and `ScalingGroupId` parameters at the same time.
	ScheduledAction *string `json:"ScheduledAction,omitempty" xml:"ScheduledAction,omitempty"`
	// The name of the scheduled task. The name must be 2 to 64 characters in length, and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). The name must start with a letter or a digit. The name of the scheduled task must be unique in the region and within the Alibaba Cloud account.
	//
	// If you do not specify this parameter, the value of the `ScheduledTaskId` parameter is used.
	ScheduledTaskName *string `json:"ScheduledTaskName,omitempty" xml:"ScheduledTaskName,omitempty"`
	// Specifies whether to enable the scheduled task.
	//
	// *   true
	// *   false
	//
	// Default value: true.
	TaskEnabled *bool `json:"TaskEnabled,omitempty" xml:"TaskEnabled,omitempty"`
}

func (s CreateScheduledTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateScheduledTaskRequest) GoString() string {
	return s.String()
}

func (s *CreateScheduledTaskRequest) SetDescription(v string) *CreateScheduledTaskRequest {
	s.Description = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetDesiredCapacity(v int32) *CreateScheduledTaskRequest {
	s.DesiredCapacity = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetLaunchExpirationTime(v int32) *CreateScheduledTaskRequest {
	s.LaunchExpirationTime = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetLaunchTime(v string) *CreateScheduledTaskRequest {
	s.LaunchTime = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetMaxValue(v int32) *CreateScheduledTaskRequest {
	s.MaxValue = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetMinValue(v int32) *CreateScheduledTaskRequest {
	s.MinValue = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetOwnerAccount(v string) *CreateScheduledTaskRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetOwnerId(v int64) *CreateScheduledTaskRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetRecurrenceEndTime(v string) *CreateScheduledTaskRequest {
	s.RecurrenceEndTime = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetRecurrenceType(v string) *CreateScheduledTaskRequest {
	s.RecurrenceType = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetRecurrenceValue(v string) *CreateScheduledTaskRequest {
	s.RecurrenceValue = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetRegionId(v string) *CreateScheduledTaskRequest {
	s.RegionId = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetResourceOwnerAccount(v string) *CreateScheduledTaskRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetScalingGroupId(v string) *CreateScheduledTaskRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetScheduledAction(v string) *CreateScheduledTaskRequest {
	s.ScheduledAction = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetScheduledTaskName(v string) *CreateScheduledTaskRequest {
	s.ScheduledTaskName = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetTaskEnabled(v bool) *CreateScheduledTaskRequest {
	s.TaskEnabled = &v
	return s
}

type CreateScheduledTaskResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The globally unique ID of the scheduled task. The globally unique ID is generated by the system.
	ScheduledTaskId *string `json:"ScheduledTaskId,omitempty" xml:"ScheduledTaskId,omitempty"`
}

func (s CreateScheduledTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateScheduledTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CreateScheduledTaskResponseBody) SetRequestId(v string) *CreateScheduledTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateScheduledTaskResponseBody) SetScheduledTaskId(v string) *CreateScheduledTaskResponseBody {
	s.ScheduledTaskId = &v
	return s
}

type CreateScheduledTaskResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateScheduledTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateScheduledTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateScheduledTaskResponse) GoString() string {
	return s.String()
}

func (s *CreateScheduledTaskResponse) SetHeaders(v map[string]*string) *CreateScheduledTaskResponse {
	s.Headers = v
	return s
}

func (s *CreateScheduledTaskResponse) SetStatusCode(v int32) *CreateScheduledTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateScheduledTaskResponse) SetBody(v *CreateScheduledTaskResponseBody) *CreateScheduledTaskResponse {
	s.Body = v
	return s
}

type DeactivateScalingConfigurationRequest struct {
	OwnerAccount           *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount   *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ScalingConfigurationId *string `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
}

func (s DeactivateScalingConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s DeactivateScalingConfigurationRequest) GoString() string {
	return s.String()
}

func (s *DeactivateScalingConfigurationRequest) SetOwnerAccount(v string) *DeactivateScalingConfigurationRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeactivateScalingConfigurationRequest) SetOwnerId(v int64) *DeactivateScalingConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *DeactivateScalingConfigurationRequest) SetResourceOwnerAccount(v string) *DeactivateScalingConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeactivateScalingConfigurationRequest) SetScalingConfigurationId(v string) *DeactivateScalingConfigurationRequest {
	s.ScalingConfigurationId = &v
	return s
}

type DeactivateScalingConfigurationResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeactivateScalingConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeactivateScalingConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *DeactivateScalingConfigurationResponseBody) SetRequestId(v string) *DeactivateScalingConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type DeactivateScalingConfigurationResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeactivateScalingConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeactivateScalingConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s DeactivateScalingConfigurationResponse) GoString() string {
	return s.String()
}

func (s *DeactivateScalingConfigurationResponse) SetHeaders(v map[string]*string) *DeactivateScalingConfigurationResponse {
	s.Headers = v
	return s
}

func (s *DeactivateScalingConfigurationResponse) SetStatusCode(v int32) *DeactivateScalingConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *DeactivateScalingConfigurationResponse) SetBody(v *DeactivateScalingConfigurationResponseBody) *DeactivateScalingConfigurationResponse {
	s.Body = v
	return s
}

type DeleteAlarmRequest struct {
	// The ID of the event-triggered task.
	AlarmTaskId *string `json:"AlarmTaskId,omitempty" xml:"AlarmTaskId,omitempty"`
	OwnerId     *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
}

func (s DeleteAlarmRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAlarmRequest) GoString() string {
	return s.String()
}

func (s *DeleteAlarmRequest) SetAlarmTaskId(v string) *DeleteAlarmRequest {
	s.AlarmTaskId = &v
	return s
}

func (s *DeleteAlarmRequest) SetOwnerId(v int64) *DeleteAlarmRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteAlarmRequest) SetRegionId(v string) *DeleteAlarmRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteAlarmRequest) SetResourceOwnerAccount(v string) *DeleteAlarmRequest {
	s.ResourceOwnerAccount = &v
	return s
}

type DeleteAlarmResponseBody struct {
	// The ID of the event-triggered task.
	AlarmTaskId *string `json:"AlarmTaskId,omitempty" xml:"AlarmTaskId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAlarmResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAlarmResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAlarmResponseBody) SetAlarmTaskId(v string) *DeleteAlarmResponseBody {
	s.AlarmTaskId = &v
	return s
}

func (s *DeleteAlarmResponseBody) SetRequestId(v string) *DeleteAlarmResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAlarmResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAlarmResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAlarmResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAlarmResponse) GoString() string {
	return s.String()
}

func (s *DeleteAlarmResponse) SetHeaders(v map[string]*string) *DeleteAlarmResponse {
	s.Headers = v
	return s
}

func (s *DeleteAlarmResponse) SetStatusCode(v int32) *DeleteAlarmResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAlarmResponse) SetBody(v *DeleteAlarmResponseBody) *DeleteAlarmResponse {
	s.Body = v
	return s
}

type DeleteEciScalingConfigurationRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling configuration that you want to delete.
	ScalingConfigurationId *string `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
}

func (s DeleteEciScalingConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteEciScalingConfigurationRequest) GoString() string {
	return s.String()
}

func (s *DeleteEciScalingConfigurationRequest) SetOwnerAccount(v string) *DeleteEciScalingConfigurationRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteEciScalingConfigurationRequest) SetOwnerId(v int64) *DeleteEciScalingConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteEciScalingConfigurationRequest) SetRegionId(v string) *DeleteEciScalingConfigurationRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteEciScalingConfigurationRequest) SetResourceOwnerAccount(v string) *DeleteEciScalingConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteEciScalingConfigurationRequest) SetScalingConfigurationId(v string) *DeleteEciScalingConfigurationRequest {
	s.ScalingConfigurationId = &v
	return s
}

type DeleteEciScalingConfigurationResponseBody struct {
	// The ID of the request. This request ID is returned regardless of whether the request is successful.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteEciScalingConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteEciScalingConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteEciScalingConfigurationResponseBody) SetRequestId(v string) *DeleteEciScalingConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type DeleteEciScalingConfigurationResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteEciScalingConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteEciScalingConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteEciScalingConfigurationResponse) GoString() string {
	return s.String()
}

func (s *DeleteEciScalingConfigurationResponse) SetHeaders(v map[string]*string) *DeleteEciScalingConfigurationResponse {
	s.Headers = v
	return s
}

func (s *DeleteEciScalingConfigurationResponse) SetStatusCode(v int32) *DeleteEciScalingConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteEciScalingConfigurationResponse) SetBody(v *DeleteEciScalingConfigurationResponseBody) *DeleteEciScalingConfigurationResponse {
	s.Body = v
	return s
}

type DeleteLifecycleHookRequest struct {
	LifecycleHookId      *string `json:"LifecycleHookId,omitempty" xml:"LifecycleHookId,omitempty"`
	LifecycleHookName    *string `json:"LifecycleHookName,omitempty" xml:"LifecycleHookName,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ScalingGroupId       *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DeleteLifecycleHookRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteLifecycleHookRequest) GoString() string {
	return s.String()
}

func (s *DeleteLifecycleHookRequest) SetLifecycleHookId(v string) *DeleteLifecycleHookRequest {
	s.LifecycleHookId = &v
	return s
}

func (s *DeleteLifecycleHookRequest) SetLifecycleHookName(v string) *DeleteLifecycleHookRequest {
	s.LifecycleHookName = &v
	return s
}

func (s *DeleteLifecycleHookRequest) SetOwnerAccount(v string) *DeleteLifecycleHookRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteLifecycleHookRequest) SetOwnerId(v int64) *DeleteLifecycleHookRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteLifecycleHookRequest) SetRegionId(v string) *DeleteLifecycleHookRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteLifecycleHookRequest) SetResourceOwnerAccount(v string) *DeleteLifecycleHookRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteLifecycleHookRequest) SetScalingGroupId(v string) *DeleteLifecycleHookRequest {
	s.ScalingGroupId = &v
	return s
}

type DeleteLifecycleHookResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteLifecycleHookResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteLifecycleHookResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteLifecycleHookResponseBody) SetRequestId(v string) *DeleteLifecycleHookResponseBody {
	s.RequestId = &v
	return s
}

type DeleteLifecycleHookResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteLifecycleHookResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteLifecycleHookResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteLifecycleHookResponse) GoString() string {
	return s.String()
}

func (s *DeleteLifecycleHookResponse) SetHeaders(v map[string]*string) *DeleteLifecycleHookResponse {
	s.Headers = v
	return s
}

func (s *DeleteLifecycleHookResponse) SetStatusCode(v int32) *DeleteLifecycleHookResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteLifecycleHookResponse) SetBody(v *DeleteLifecycleHookResponseBody) *DeleteLifecycleHookResponse {
	s.Body = v
	return s
}

type DeleteNotificationConfigurationRequest struct {
	// The Alibaba Cloud Resource Name (ARN) of the notification method. The following list describes the value formats of this parameter:
	//
	// *   If you use CloudMonitor as the notification party, the value format of this parameter is acs:ess:{region-id}:{account-id}:cloudmonitor.
	// *   If you use an MNS queue as the notification party, the value format of this parameter is acs:mns:{region-id}:{account-id}:queue/{queuename}.
	// *   If you use an MNS topic as the notification party, the value format of this parameter is acs:mns:{region-id}:{account-id}:topic/{topicname}.
	//
	// The variables in the preceding formats have the following meanings:
	//
	// *   region-id: the region ID of the scaling group.
	// *   account-id: the ID of the Alibaba Cloud account.
	// *   queuename: the name of the MNS queue.
	// *   topicname: the name of the MNS topic.
	NotificationArn *string `json:"NotificationArn,omitempty" xml:"NotificationArn,omitempty"`
	OwnerId         *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DeleteNotificationConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteNotificationConfigurationRequest) GoString() string {
	return s.String()
}

func (s *DeleteNotificationConfigurationRequest) SetNotificationArn(v string) *DeleteNotificationConfigurationRequest {
	s.NotificationArn = &v
	return s
}

func (s *DeleteNotificationConfigurationRequest) SetOwnerId(v int64) *DeleteNotificationConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteNotificationConfigurationRequest) SetRegionId(v string) *DeleteNotificationConfigurationRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteNotificationConfigurationRequest) SetResourceOwnerAccount(v string) *DeleteNotificationConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteNotificationConfigurationRequest) SetScalingGroupId(v string) *DeleteNotificationConfigurationRequest {
	s.ScalingGroupId = &v
	return s
}

type DeleteNotificationConfigurationResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteNotificationConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteNotificationConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteNotificationConfigurationResponseBody) SetRequestId(v string) *DeleteNotificationConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type DeleteNotificationConfigurationResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteNotificationConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteNotificationConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteNotificationConfigurationResponse) GoString() string {
	return s.String()
}

func (s *DeleteNotificationConfigurationResponse) SetHeaders(v map[string]*string) *DeleteNotificationConfigurationResponse {
	s.Headers = v
	return s
}

func (s *DeleteNotificationConfigurationResponse) SetStatusCode(v int32) *DeleteNotificationConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteNotificationConfigurationResponse) SetBody(v *DeleteNotificationConfigurationResponseBody) *DeleteNotificationConfigurationResponse {
	s.Body = v
	return s
}

type DeleteScalingConfigurationRequest struct {
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling configuration that you want to delete.
	ScalingConfigurationId *string `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
}

func (s DeleteScalingConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteScalingConfigurationRequest) GoString() string {
	return s.String()
}

func (s *DeleteScalingConfigurationRequest) SetOwnerAccount(v string) *DeleteScalingConfigurationRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteScalingConfigurationRequest) SetOwnerId(v int64) *DeleteScalingConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteScalingConfigurationRequest) SetResourceOwnerAccount(v string) *DeleteScalingConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteScalingConfigurationRequest) SetScalingConfigurationId(v string) *DeleteScalingConfigurationRequest {
	s.ScalingConfigurationId = &v
	return s
}

type DeleteScalingConfigurationResponseBody struct {
	// The ID of the request. The request ID is returned regardless of whether the call is successful.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteScalingConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteScalingConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteScalingConfigurationResponseBody) SetRequestId(v string) *DeleteScalingConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type DeleteScalingConfigurationResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteScalingConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteScalingConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteScalingConfigurationResponse) GoString() string {
	return s.String()
}

func (s *DeleteScalingConfigurationResponse) SetHeaders(v map[string]*string) *DeleteScalingConfigurationResponse {
	s.Headers = v
	return s
}

func (s *DeleteScalingConfigurationResponse) SetStatusCode(v int32) *DeleteScalingConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteScalingConfigurationResponse) SetBody(v *DeleteScalingConfigurationResponseBody) *DeleteScalingConfigurationResponse {
	s.Body = v
	return s
}

type DeleteScalingGroupRequest struct {
	// Specifies whether to forcefully delete the VPC. Valid values:
	//
	// - **true**: yes
	// - **false** (default): no
	//
	// You can forcefully delete a VPC in the following scenarios:
	//
	// - Only an IPv4 gateway and routes that point to the IPv4 gateway exist in the VPC.
	// - Only an IPv6 gateway and routes that point to the IPv6 gateway exist in the VPC.
	ForceDelete  *bool   `json:"ForceDelete,omitempty" xml:"ForceDelete,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DeleteScalingGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteScalingGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteScalingGroupRequest) SetForceDelete(v bool) *DeleteScalingGroupRequest {
	s.ForceDelete = &v
	return s
}

func (s *DeleteScalingGroupRequest) SetOwnerAccount(v string) *DeleteScalingGroupRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteScalingGroupRequest) SetOwnerId(v int64) *DeleteScalingGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteScalingGroupRequest) SetRegionId(v string) *DeleteScalingGroupRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteScalingGroupRequest) SetResourceOwnerAccount(v string) *DeleteScalingGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteScalingGroupRequest) SetScalingGroupId(v string) *DeleteScalingGroupRequest {
	s.ScalingGroupId = &v
	return s
}

type DeleteScalingGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteScalingGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteScalingGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteScalingGroupResponseBody) SetRequestId(v string) *DeleteScalingGroupResponseBody {
	s.RequestId = &v
	return s
}

type DeleteScalingGroupResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteScalingGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteScalingGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteScalingGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteScalingGroupResponse) SetHeaders(v map[string]*string) *DeleteScalingGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteScalingGroupResponse) SetStatusCode(v int32) *DeleteScalingGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteScalingGroupResponse) SetBody(v *DeleteScalingGroupResponseBody) *DeleteScalingGroupResponse {
	s.Body = v
	return s
}

type DeleteScalingRuleRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling rule that you want to delete.
	ScalingRuleId *string `json:"ScalingRuleId,omitempty" xml:"ScalingRuleId,omitempty"`
}

func (s DeleteScalingRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteScalingRuleRequest) GoString() string {
	return s.String()
}

func (s *DeleteScalingRuleRequest) SetOwnerAccount(v string) *DeleteScalingRuleRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteScalingRuleRequest) SetOwnerId(v int64) *DeleteScalingRuleRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteScalingRuleRequest) SetRegionId(v string) *DeleteScalingRuleRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteScalingRuleRequest) SetResourceOwnerAccount(v string) *DeleteScalingRuleRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteScalingRuleRequest) SetScalingRuleId(v string) *DeleteScalingRuleRequest {
	s.ScalingRuleId = &v
	return s
}

type DeleteScalingRuleResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteScalingRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteScalingRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteScalingRuleResponseBody) SetRequestId(v string) *DeleteScalingRuleResponseBody {
	s.RequestId = &v
	return s
}

type DeleteScalingRuleResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteScalingRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteScalingRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteScalingRuleResponse) GoString() string {
	return s.String()
}

func (s *DeleteScalingRuleResponse) SetHeaders(v map[string]*string) *DeleteScalingRuleResponse {
	s.Headers = v
	return s
}

func (s *DeleteScalingRuleResponse) SetStatusCode(v int32) *DeleteScalingRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteScalingRuleResponse) SetBody(v *DeleteScalingRuleResponseBody) *DeleteScalingRuleResponse {
	s.Body = v
	return s
}

type DeleteScheduledTaskRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scheduled task.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scheduled task. An ID is a globally unique identifier (GUID) that is generated by the system for a scheduled task.
	ScheduledTaskId *string `json:"ScheduledTaskId,omitempty" xml:"ScheduledTaskId,omitempty"`
}

func (s DeleteScheduledTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteScheduledTaskRequest) GoString() string {
	return s.String()
}

func (s *DeleteScheduledTaskRequest) SetOwnerAccount(v string) *DeleteScheduledTaskRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteScheduledTaskRequest) SetOwnerId(v int64) *DeleteScheduledTaskRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteScheduledTaskRequest) SetRegionId(v string) *DeleteScheduledTaskRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteScheduledTaskRequest) SetResourceOwnerAccount(v string) *DeleteScheduledTaskRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteScheduledTaskRequest) SetScheduledTaskId(v string) *DeleteScheduledTaskRequest {
	s.ScheduledTaskId = &v
	return s
}

type DeleteScheduledTaskResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteScheduledTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteScheduledTaskResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteScheduledTaskResponseBody) SetRequestId(v string) *DeleteScheduledTaskResponseBody {
	s.RequestId = &v
	return s
}

type DeleteScheduledTaskResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteScheduledTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteScheduledTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteScheduledTaskResponse) GoString() string {
	return s.String()
}

func (s *DeleteScheduledTaskResponse) SetHeaders(v map[string]*string) *DeleteScheduledTaskResponse {
	s.Headers = v
	return s
}

func (s *DeleteScheduledTaskResponse) SetStatusCode(v int32) *DeleteScheduledTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteScheduledTaskResponse) SetBody(v *DeleteScheduledTaskResponseBody) *DeleteScheduledTaskResponse {
	s.Body = v
	return s
}

type DescribeAlarmsRequest struct {
	AlarmTaskId          *string `json:"AlarmTaskId,omitempty" xml:"AlarmTaskId,omitempty"`
	IsEnable             *bool   `json:"IsEnable,omitempty" xml:"IsEnable,omitempty"`
	MetricName           *string `json:"MetricName,omitempty" xml:"MetricName,omitempty"`
	MetricType           *string `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	PageNumber           *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ScalingGroupId       *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	State                *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s DescribeAlarmsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAlarmsRequest) GoString() string {
	return s.String()
}

func (s *DescribeAlarmsRequest) SetAlarmTaskId(v string) *DescribeAlarmsRequest {
	s.AlarmTaskId = &v
	return s
}

func (s *DescribeAlarmsRequest) SetIsEnable(v bool) *DescribeAlarmsRequest {
	s.IsEnable = &v
	return s
}

func (s *DescribeAlarmsRequest) SetMetricName(v string) *DescribeAlarmsRequest {
	s.MetricName = &v
	return s
}

func (s *DescribeAlarmsRequest) SetMetricType(v string) *DescribeAlarmsRequest {
	s.MetricType = &v
	return s
}

func (s *DescribeAlarmsRequest) SetOwnerId(v int64) *DescribeAlarmsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeAlarmsRequest) SetPageNumber(v int32) *DescribeAlarmsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeAlarmsRequest) SetPageSize(v int32) *DescribeAlarmsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeAlarmsRequest) SetRegionId(v string) *DescribeAlarmsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeAlarmsRequest) SetResourceOwnerAccount(v string) *DescribeAlarmsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeAlarmsRequest) SetScalingGroupId(v string) *DescribeAlarmsRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeAlarmsRequest) SetState(v string) *DescribeAlarmsRequest {
	s.State = &v
	return s
}

type DescribeAlarmsResponseBody struct {
	AlarmList  []*DescribeAlarmsResponseBodyAlarmList `json:"AlarmList,omitempty" xml:"AlarmList,omitempty" type:"Repeated"`
	PageNumber *int32                                 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int32                                 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RequestId  *string                                `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount *int32                                 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeAlarmsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAlarmsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAlarmsResponseBody) SetAlarmList(v []*DescribeAlarmsResponseBodyAlarmList) *DescribeAlarmsResponseBody {
	s.AlarmList = v
	return s
}

func (s *DescribeAlarmsResponseBody) SetPageNumber(v int32) *DescribeAlarmsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeAlarmsResponseBody) SetPageSize(v int32) *DescribeAlarmsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeAlarmsResponseBody) SetRequestId(v string) *DescribeAlarmsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeAlarmsResponseBody) SetTotalCount(v int32) *DescribeAlarmsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeAlarmsResponseBodyAlarmList struct {
	AlarmActions             []*string                                         `json:"AlarmActions,omitempty" xml:"AlarmActions,omitempty" type:"Repeated"`
	AlarmTaskId              *string                                           `json:"AlarmTaskId,omitempty" xml:"AlarmTaskId,omitempty"`
	ComparisonOperator       *string                                           `json:"ComparisonOperator,omitempty" xml:"ComparisonOperator,omitempty"`
	Description              *string                                           `json:"Description,omitempty" xml:"Description,omitempty"`
	Dimensions               []*DescribeAlarmsResponseBodyAlarmListDimensions  `json:"Dimensions,omitempty" xml:"Dimensions,omitempty" type:"Repeated"`
	Effective                *string                                           `json:"Effective,omitempty" xml:"Effective,omitempty"`
	Enable                   *bool                                             `json:"Enable,omitempty" xml:"Enable,omitempty"`
	EvaluationCount          *int32                                            `json:"EvaluationCount,omitempty" xml:"EvaluationCount,omitempty"`
	Expressions              []*DescribeAlarmsResponseBodyAlarmListExpressions `json:"Expressions,omitempty" xml:"Expressions,omitempty" type:"Repeated"`
	ExpressionsLogicOperator *string                                           `json:"ExpressionsLogicOperator,omitempty" xml:"ExpressionsLogicOperator,omitempty"`
	MetricName               *string                                           `json:"MetricName,omitempty" xml:"MetricName,omitempty"`
	MetricType               *string                                           `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
	Name                     *string                                           `json:"Name,omitempty" xml:"Name,omitempty"`
	Period                   *int32                                            `json:"Period,omitempty" xml:"Period,omitempty"`
	ScalingGroupId           *string                                           `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	State                    *string                                           `json:"State,omitempty" xml:"State,omitempty"`
	Statistics               *string                                           `json:"Statistics,omitempty" xml:"Statistics,omitempty"`
	Threshold                *float32                                          `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s DescribeAlarmsResponseBodyAlarmList) String() string {
	return tea.Prettify(s)
}

func (s DescribeAlarmsResponseBodyAlarmList) GoString() string {
	return s.String()
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetAlarmActions(v []*string) *DescribeAlarmsResponseBodyAlarmList {
	s.AlarmActions = v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetAlarmTaskId(v string) *DescribeAlarmsResponseBodyAlarmList {
	s.AlarmTaskId = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetComparisonOperator(v string) *DescribeAlarmsResponseBodyAlarmList {
	s.ComparisonOperator = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetDescription(v string) *DescribeAlarmsResponseBodyAlarmList {
	s.Description = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetDimensions(v []*DescribeAlarmsResponseBodyAlarmListDimensions) *DescribeAlarmsResponseBodyAlarmList {
	s.Dimensions = v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetEffective(v string) *DescribeAlarmsResponseBodyAlarmList {
	s.Effective = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetEnable(v bool) *DescribeAlarmsResponseBodyAlarmList {
	s.Enable = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetEvaluationCount(v int32) *DescribeAlarmsResponseBodyAlarmList {
	s.EvaluationCount = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetExpressions(v []*DescribeAlarmsResponseBodyAlarmListExpressions) *DescribeAlarmsResponseBodyAlarmList {
	s.Expressions = v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetExpressionsLogicOperator(v string) *DescribeAlarmsResponseBodyAlarmList {
	s.ExpressionsLogicOperator = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetMetricName(v string) *DescribeAlarmsResponseBodyAlarmList {
	s.MetricName = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetMetricType(v string) *DescribeAlarmsResponseBodyAlarmList {
	s.MetricType = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetName(v string) *DescribeAlarmsResponseBodyAlarmList {
	s.Name = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetPeriod(v int32) *DescribeAlarmsResponseBodyAlarmList {
	s.Period = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetScalingGroupId(v string) *DescribeAlarmsResponseBodyAlarmList {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetState(v string) *DescribeAlarmsResponseBodyAlarmList {
	s.State = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetStatistics(v string) *DescribeAlarmsResponseBodyAlarmList {
	s.Statistics = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetThreshold(v float32) *DescribeAlarmsResponseBodyAlarmList {
	s.Threshold = &v
	return s
}

type DescribeAlarmsResponseBodyAlarmListDimensions struct {
	DimensionKey   *string `json:"DimensionKey,omitempty" xml:"DimensionKey,omitempty"`
	DimensionValue *string `json:"DimensionValue,omitempty" xml:"DimensionValue,omitempty"`
}

func (s DescribeAlarmsResponseBodyAlarmListDimensions) String() string {
	return tea.Prettify(s)
}

func (s DescribeAlarmsResponseBodyAlarmListDimensions) GoString() string {
	return s.String()
}

func (s *DescribeAlarmsResponseBodyAlarmListDimensions) SetDimensionKey(v string) *DescribeAlarmsResponseBodyAlarmListDimensions {
	s.DimensionKey = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmListDimensions) SetDimensionValue(v string) *DescribeAlarmsResponseBodyAlarmListDimensions {
	s.DimensionValue = &v
	return s
}

type DescribeAlarmsResponseBodyAlarmListExpressions struct {
	ComparisonOperator *string  `json:"ComparisonOperator,omitempty" xml:"ComparisonOperator,omitempty"`
	MetricName         *string  `json:"MetricName,omitempty" xml:"MetricName,omitempty"`
	Period             *int32   `json:"Period,omitempty" xml:"Period,omitempty"`
	Statistics         *string  `json:"Statistics,omitempty" xml:"Statistics,omitempty"`
	Threshold          *float32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s DescribeAlarmsResponseBodyAlarmListExpressions) String() string {
	return tea.Prettify(s)
}

func (s DescribeAlarmsResponseBodyAlarmListExpressions) GoString() string {
	return s.String()
}

func (s *DescribeAlarmsResponseBodyAlarmListExpressions) SetComparisonOperator(v string) *DescribeAlarmsResponseBodyAlarmListExpressions {
	s.ComparisonOperator = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmListExpressions) SetMetricName(v string) *DescribeAlarmsResponseBodyAlarmListExpressions {
	s.MetricName = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmListExpressions) SetPeriod(v int32) *DescribeAlarmsResponseBodyAlarmListExpressions {
	s.Period = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmListExpressions) SetStatistics(v string) *DescribeAlarmsResponseBodyAlarmListExpressions {
	s.Statistics = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmListExpressions) SetThreshold(v float32) *DescribeAlarmsResponseBodyAlarmListExpressions {
	s.Threshold = &v
	return s
}

type DescribeAlarmsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeAlarmsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeAlarmsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAlarmsResponse) GoString() string {
	return s.String()
}

func (s *DescribeAlarmsResponse) SetHeaders(v map[string]*string) *DescribeAlarmsResponse {
	s.Headers = v
	return s
}

func (s *DescribeAlarmsResponse) SetStatusCode(v int32) *DescribeAlarmsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAlarmsResponse) SetBody(v *DescribeAlarmsResponseBody) *DescribeAlarmsResponse {
	s.Body = v
	return s
}

type DescribeEciScalingConfigurationsRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Pages start from page 1.
	//
	// Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: 50.
	//
	// Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the scaling group to which the scaling configuration belongs.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The IDs of the scaling configurations that you want to query.
	//
	// The IDs of active and inactive scaling configurations are displayed in the query results. You can differentiate between active and inactive scaling configurations based on the value of the `LifecycleState` parameter.
	ScalingConfigurationIds []*string `json:"ScalingConfigurationIds,omitempty" xml:"ScalingConfigurationIds,omitempty" type:"Repeated"`
	// The names of the scaling configurations that you want to query.
	//
	// The names of inactive scaling configurations are not displayed in the query results, and no error is reported.
	ScalingConfigurationNames []*string `json:"ScalingConfigurationNames,omitempty" xml:"ScalingConfigurationNames,omitempty" type:"Repeated"`
	// The ID of the scaling group. You can use the ID to query all scaling configurations in the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DescribeEciScalingConfigurationsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsRequest) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsRequest) SetOwnerAccount(v string) *DescribeEciScalingConfigurationsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeEciScalingConfigurationsRequest) SetOwnerId(v int64) *DescribeEciScalingConfigurationsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsRequest) SetPageNumber(v int32) *DescribeEciScalingConfigurationsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeEciScalingConfigurationsRequest) SetPageSize(v int32) *DescribeEciScalingConfigurationsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeEciScalingConfigurationsRequest) SetRegionId(v string) *DescribeEciScalingConfigurationsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsRequest) SetResourceOwnerAccount(v string) *DescribeEciScalingConfigurationsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeEciScalingConfigurationsRequest) SetResourceOwnerId(v int64) *DescribeEciScalingConfigurationsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsRequest) SetScalingConfigurationIds(v []*string) *DescribeEciScalingConfigurationsRequest {
	s.ScalingConfigurationIds = v
	return s
}

func (s *DescribeEciScalingConfigurationsRequest) SetScalingConfigurationNames(v []*string) *DescribeEciScalingConfigurationsRequest {
	s.ScalingConfigurationNames = v
	return s
}

func (s *DescribeEciScalingConfigurationsRequest) SetScalingGroupId(v string) *DescribeEciScalingConfigurationsRequest {
	s.ScalingGroupId = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Details of the scaling configurations.
	ScalingConfigurations []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurations `json:"ScalingConfigurations,omitempty" xml:"ScalingConfigurations,omitempty" type:"Repeated"`
	// The total number of scaling configurations.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBody) SetPageNumber(v int32) *DescribeEciScalingConfigurationsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBody) SetPageSize(v int32) *DescribeEciScalingConfigurationsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBody) SetRequestId(v string) *DescribeEciScalingConfigurationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBody) SetScalingConfigurations(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) *DescribeEciScalingConfigurationsResponseBody {
	s.ScalingConfigurations = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBody) SetTotalCount(v int32) *DescribeEciScalingConfigurationsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurations struct {
	// Details of the Container Registry Enterprise Edition instances.
	AcrRegistryInfos []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos `json:"AcrRegistryInfos,omitempty" xml:"AcrRegistryInfos,omitempty" type:"Repeated"`
	// The validity period. Unit: seconds.
	ActiveDeadlineSeconds *int32 `json:"ActiveDeadlineSeconds,omitempty" xml:"ActiveDeadlineSeconds,omitempty"`
	// Indicates whether an elastic IP address (EIP) is automatically created, and then bound to the elastic container instance.
	AutoCreateEip *bool `json:"AutoCreateEip,omitempty" xml:"AutoCreateEip,omitempty"`
	// Indicates whether the image cache is automatically matched. Default value: false.
	AutoMatchImageCache *bool `json:"AutoMatchImageCache,omitempty" xml:"AutoMatchImageCache,omitempty"`
	// The name of the elastic container instance.
	ContainerGroupName *string `json:"ContainerGroupName,omitempty" xml:"ContainerGroupName,omitempty"`
	// The containers in the elastic container instance.
	Containers []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers `json:"Containers,omitempty" xml:"Containers,omitempty" type:"Repeated"`
	// Indicates whether the cost optimization feature is enabled. Valid values:
	//
	// *   true
	// *   false
	CostOptimization *bool `json:"CostOptimization,omitempty" xml:"CostOptimization,omitempty"`
	// The number of vCPUs of the elastic container instance.
	Cpu *float32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The number of physical CPU cores. This parameter can be specified for only some instance types. For more information, see [Specify custom CPU options](~~197781~~).
	CpuOptionsCore *int32 `json:"CpuOptionsCore,omitempty" xml:"CpuOptionsCore,omitempty"`
	// The number of threads per core. This parameter can be specified for only some instance types. If you set this parameter to 1, Hyper-Threading is disabled. For more information, see [Specify custom CPU options](~~197781~~).
	CpuOptionsThreadsPerCore *int32 `json:"CpuOptionsThreadsPerCore,omitempty" xml:"CpuOptionsThreadsPerCore,omitempty"`
	// The time when the scaling configuration was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// 数据缓存Bucket。
	DataCacheBucket *string `json:"DataCacheBucket,omitempty" xml:"DataCacheBucket,omitempty"`
	// 数据缓存使用ESSD AutoPL云盘时，是否开启Burst（性能突发）。可能值：
	//
	// - true：开启。
	// - false：未开启。
	// >关于ESSD AutoPL云盘的更多信息，请参见[ESSD AutoPL云盘](~~368372~~)。
	DataCacheBurstingEnabled *bool `json:"DataCacheBurstingEnabled,omitempty" xml:"DataCacheBurstingEnabled,omitempty"`
	// 数据缓存使用的云盘的性能等级。建议优先使用ESSD云盘，该云盘的性能等级的可能值：
	//
	// - PL0：单盘最高随机读写IOPS 1万。
	// - PL1：单盘最高随机读写IOPS 5万。
	// - PL2：单盘最高随机读写IOPS 10万。
	// - PL3：单盘最高随机读写IOPS 100万。
	//
	// >关于ESSD云盘的更多信息，请参见[ESSD云盘](~~122389~~)。
	DataCachePL *string `json:"DataCachePL,omitempty" xml:"DataCachePL,omitempty"`
	// 数据缓存使用ESSD AutoPL云盘时，ESSD AutoPL云盘预配置的读写IOPS。可能值：0~min{50000, 1000*容量-基准性能}，其中，基准性能=min{1800+50*容量, 50000}。
	//
	// >关于ESSD AutoPL云盘的更多信息，请参见[ESSD AutoPL云盘](~~368372~~)。
	DataCacheProvisionedIops *int32 `json:"DataCacheProvisionedIops,omitempty" xml:"DataCacheProvisionedIops,omitempty"`
	// > This parameter is unavailable.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The IP addresses of the DNS servers.
	DnsConfigNameServers []*string `json:"DnsConfigNameServers,omitempty" xml:"DnsConfigNameServers,omitempty" type:"Repeated"`
	// The options. Each option is a name-value pair. The value in the name-value pair is optional.
	DnsConfigOptions []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions `json:"DnsConfigOptions,omitempty" xml:"DnsConfigOptions,omitempty" type:"Repeated"`
	// The DNS lookup domains.
	DnsConfigSearches []*string `json:"DnsConfigSearches,omitempty" xml:"DnsConfigSearches,omitempty" type:"Repeated"`
	// The Domain Name System (DNS) policy.
	DnsPolicy *string `json:"DnsPolicy,omitempty" xml:"DnsPolicy,omitempty"`
	// The maximum outbound bandwidth. Unit: bytes.
	EgressBandwidth *int64 `json:"EgressBandwidth,omitempty" xml:"EgressBandwidth,omitempty"`
	// The bandwidth of the EIP. Default value: 5 Mbit/s.
	EipBandwidth *int32 `json:"EipBandwidth,omitempty" xml:"EipBandwidth,omitempty"`
	// The size of the temporary storage space. Unit: GiB.
	EphemeralStorage *int32 `json:"EphemeralStorage,omitempty" xml:"EphemeralStorage,omitempty"`
	// The hostname aliases of a container.
	HostAliases []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases `json:"HostAliases,omitempty" xml:"HostAliases,omitempty" type:"Repeated"`
	// The hostname.
	HostName *string `json:"HostName,omitempty" xml:"HostName,omitempty"`
	// The information about the image repository.
	ImageRegistryCredentials []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials `json:"ImageRegistryCredentials,omitempty" xml:"ImageRegistryCredentials,omitempty" type:"Repeated"`
	// The ID of the image cache snapshot.
	ImageSnapshotId *string `json:"ImageSnapshotId,omitempty" xml:"ImageSnapshotId,omitempty"`
	// The maximum inbound bandwidth. Unit: bit/s.
	IngressBandwidth *int64 `json:"IngressBandwidth,omitempty" xml:"IngressBandwidth,omitempty"`
	// The init containers.
	InitContainers []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers `json:"InitContainers,omitempty" xml:"InitContainers,omitempty" type:"Repeated"`
	// The instance family level, which is used to filter the range of instance types that meet the requirements. This parameter takes effect when the `CostOptimization` parameter is set to true. Valid values:
	//
	// *   EntryLevel: shared instance type. Instances of this level are the most cost-effective but may not provide stable computing performance in a consistent manner. Instances of this level are suitable for business scenarios in which the CPU utilization is low. For more information, see [Shared instance families](~~108489~~).
	// *   EnterpriseLevel: Instances of this level provide stable performance and dedicated resources, and are suitable for business scenarios that require high stability. For more information, see [Instance family](~~25378~~).
	// *   CreditEntryLevel: This value is valid only for burstable instances. CPU credits are used to ensure computing performance. Instances of this level are suitable for scenarios in which the CPU utilization is low but may fluctuate in specific cases. For more information, see [Overview](~~59977~~) of burstable instances.
	InstanceFamilyLevel *string `json:"InstanceFamilyLevel,omitempty" xml:"InstanceFamilyLevel,omitempty"`
	// 指定的ECS实例规格，支持多规格（最多支持5个）。
	InstanceTypes []*string `json:"InstanceTypes,omitempty" xml:"InstanceTypes,omitempty" type:"Repeated"`
	// The number of IPv6 addresses.
	Ipv6AddressCount *int32 `json:"Ipv6AddressCount,omitempty" xml:"Ipv6AddressCount,omitempty"`
	// The state of the scaling configuration in the scaling group. Valid values:
	//
	// *   Active: The scaling configuration is active in the scaling group. Auto Scaling uses active scaling configurations to automatically create ECS instances.
	// *   Inactive: The scaling configuration is inactive in the scaling group. Auto Scaling does not use inactive scaling configurations to automatically create ECS instances. Inactive scaling configurations are retained in the scaling group.
	LifecycleState *string `json:"LifecycleState,omitempty" xml:"LifecycleState,omitempty"`
	// The weight of the elastic container instance as a backend server. Valid values: 1 to 100.
	LoadBalancerWeight *int32 `json:"LoadBalancerWeight,omitempty" xml:"LoadBalancerWeight,omitempty"`
	// The size of the memory.
	//
	// You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. If you specify the Cpu and Memory parameters, Auto Scaling determines available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.
	//
	// > You can specify CPU and memory specifications to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The domain names of the Network Time Protocol (NTP) servers.
	NtpServers []*string `json:"NtpServers,omitempty" xml:"NtpServers,omitempty" type:"Repeated"`
	// The name of the instance RAM role. You can use an instance RAM role to access both elastic container instances and Elastic Compute Service (ECS) instances. For more information, see [Use the instance RAM role by calling APIs](~~61178~~).
	RamRoleName *string `json:"RamRoleName,omitempty" xml:"RamRoleName,omitempty"`
	// The region ID of the elastic container instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The restart policy of the elastic container instance. Valid values:
	//
	// *   Never: never restarts the elastic container instance.
	// *   Always: always restarts the elastic container instance.
	// *   OnFailure: restarts the elastic container instance upon failures.
	RestartPolicy *string `json:"RestartPolicy,omitempty" xml:"RestartPolicy,omitempty"`
	// The ID of the scaling configuration.
	ScalingConfigurationId *string `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
	// The name of the scaling configuration.
	ScalingConfigurationName *string `json:"ScalingConfigurationName,omitempty" xml:"ScalingConfigurationName,omitempty"`
	// The scaling group ID of the scaling configuration.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The system information of the security context in which the elastic container instance runs.
	SecurityContextSysCtls []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls `json:"SecurityContextSysCtls,omitempty" xml:"SecurityContextSysCtls,omitempty" type:"Repeated"`
	// The ID of the security group with which the elastic container instance is associated. Elastic container instances that are associated with the same security group can access each other.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// > This parameter is unavailable.
	SlsEnable *bool `json:"SlsEnable,omitempty" xml:"SlsEnable,omitempty"`
	// The maximum hourly price for the preemptible instance.
	//
	// This parameter is returned only if you set the SpotStrategy parameter to SpotWithPriceLimit.
	SpotPriceLimit *float32 `json:"SpotPriceLimit,omitempty" xml:"SpotPriceLimit,omitempty"`
	// The preemption policy of the instance. Valid values:
	//
	// *   NoSpot: The instance is created as a regular pay-as-you-go instance.
	// *   SpotWithPriceLimit: The instance is created as a preemptible instance with a user-defined maximum hourly price.
	// *   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.
	SpotStrategy *string `json:"SpotStrategy,omitempty" xml:"SpotStrategy,omitempty"`
	// The tags of the elastic container instance. The tags are specified in the key-value pair format.
	Tags []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The buffer time in which the program handles operations before the program stops.
	TerminationGracePeriodSeconds *int32 `json:"TerminationGracePeriodSeconds,omitempty" xml:"TerminationGracePeriodSeconds,omitempty"`
	// Details of the volumes.
	Volumes []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes `json:"Volumes,omitempty" xml:"Volumes,omitempty" type:"Repeated"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetAcrRegistryInfos(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.AcrRegistryInfos = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetActiveDeadlineSeconds(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.ActiveDeadlineSeconds = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetAutoCreateEip(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.AutoCreateEip = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetAutoMatchImageCache(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.AutoMatchImageCache = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetContainerGroupName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.ContainerGroupName = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetContainers(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.Containers = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetCostOptimization(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.CostOptimization = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetCpu(v float32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.Cpu = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetCpuOptionsCore(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.CpuOptionsCore = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetCpuOptionsThreadsPerCore(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.CpuOptionsThreadsPerCore = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetCreationTime(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.CreationTime = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetDataCacheBucket(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.DataCacheBucket = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetDataCacheBurstingEnabled(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.DataCacheBurstingEnabled = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetDataCachePL(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.DataCachePL = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetDataCacheProvisionedIops(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.DataCacheProvisionedIops = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetDescription(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.Description = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetDnsConfigNameServers(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.DnsConfigNameServers = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetDnsConfigOptions(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.DnsConfigOptions = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetDnsConfigSearches(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.DnsConfigSearches = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetDnsPolicy(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.DnsPolicy = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetEgressBandwidth(v int64) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.EgressBandwidth = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetEipBandwidth(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.EipBandwidth = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetEphemeralStorage(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.EphemeralStorage = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetHostAliases(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.HostAliases = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetHostName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.HostName = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetImageRegistryCredentials(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.ImageRegistryCredentials = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetImageSnapshotId(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.ImageSnapshotId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetIngressBandwidth(v int64) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.IngressBandwidth = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetInitContainers(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.InitContainers = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetInstanceFamilyLevel(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.InstanceFamilyLevel = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetInstanceTypes(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.InstanceTypes = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetIpv6AddressCount(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.Ipv6AddressCount = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetLifecycleState(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.LifecycleState = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetLoadBalancerWeight(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.LoadBalancerWeight = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetMemory(v float32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.Memory = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetNtpServers(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.NtpServers = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetRamRoleName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.RamRoleName = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetRegionId(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.RegionId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetResourceGroupId(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetRestartPolicy(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.RestartPolicy = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetScalingConfigurationId(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.ScalingConfigurationId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetScalingConfigurationName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.ScalingConfigurationName = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetScalingGroupId(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetSecurityContextSysCtls(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.SecurityContextSysCtls = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetSecurityGroupId(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.SecurityGroupId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetSlsEnable(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.SlsEnable = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetSpotPriceLimit(v float32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.SpotPriceLimit = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetSpotStrategy(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.SpotStrategy = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetTags(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.Tags = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetTerminationGracePeriodSeconds(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.TerminationGracePeriodSeconds = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetVolumes(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.Volumes = v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos struct {
	// The domain name of the Container Registry Enterprise Edition instance. By default, all domain names of the Container Registry Enterprise Edition instance are displayed. You can specify one or more domain names. Separate multiple domain names with commas (,).
	Domains []*string `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Repeated"`
	// The ID of the Container Registry Enterprise Edition instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the Container Registry Enterprise Edition instance.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The region ID of the Container Registry Enterprise Edition instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos) SetDomains(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos {
	s.Domains = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos) SetInstanceId(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos {
	s.InstanceId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos) SetInstanceName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos {
	s.InstanceName = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos) SetRegionId(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos {
	s.RegionId = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers struct {
	// The arguments that are passed to the container startup commands. You can specify up to 10 arguments.
	Args []*string `json:"Args,omitempty" xml:"Args,omitempty" type:"Repeated"`
	// The container startup commands. You can specify up to 20 commands. Each command can contain up to 256 characters.
	Commands []*string `json:"Commands,omitempty" xml:"Commands,omitempty" type:"Repeated"`
	// The number of vCPUs that are allocated to the container.
	Cpu *float32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// Details of the environment variables.
	EnvironmentVars []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars `json:"EnvironmentVars,omitempty" xml:"EnvironmentVars,omitempty" type:"Repeated"`
	// The number of GPUs.
	Gpu *int32 `json:"Gpu,omitempty" xml:"Gpu,omitempty"`
	// The image of the container.
	Image *string `json:"Image,omitempty" xml:"Image,omitempty"`
	// The image pulling policy. Valid values:
	//
	// *   Always: Image pulling is performed each time.
	// *   IfNotPresent: Image pulling is performed only if on-premises images are unavailable. On-premises images are preferentially used. If no on-premises images are available, image pulling is performed.
	// *   Never: On-premises images are always used. Image pulling is not performed.
	ImagePullPolicy *string `json:"ImagePullPolicy,omitempty" xml:"ImagePullPolicy,omitempty"`
	// The commands that are run in the container when you use the CLI to perform probes.
	LivenessProbeExecCommands []*string `json:"LivenessProbeExecCommands,omitempty" xml:"LivenessProbeExecCommands,omitempty" type:"Repeated"`
	// The minimum number of consecutive failures for a probe to be considered failed after having been successful.
	//
	// Default value: 3.
	LivenessProbeFailureThreshold *int32 `json:"LivenessProbeFailureThreshold,omitempty" xml:"LivenessProbeFailureThreshold,omitempty"`
	// The path to which the system sends an HTTP GET request for a probe.
	LivenessProbeHttpGetPath *string `json:"LivenessProbeHttpGetPath,omitempty" xml:"LivenessProbeHttpGetPath,omitempty"`
	// The port to which HTTP GET requests were sent.
	LivenessProbeHttpGetPort *int32 `json:"LivenessProbeHttpGetPort,omitempty" xml:"LivenessProbeHttpGetPort,omitempty"`
	// The protocol type of HTTP GET requests when you use HTTP requests to perform probes. Valid values:
	//
	// *   HTTP
	// *   HTTPS
	LivenessProbeHttpGetScheme *string `json:"LivenessProbeHttpGetScheme,omitempty" xml:"LivenessProbeHttpGetScheme,omitempty"`
	// The number of seconds between the time when the startup of the container ends and the time when the probe starts.
	LivenessProbeInitialDelaySeconds *int32 `json:"LivenessProbeInitialDelaySeconds,omitempty" xml:"LivenessProbeInitialDelaySeconds,omitempty"`
	// The interval at which probes are performed. Default value: 10. Minimum value: 1. Unit: seconds.
	LivenessProbePeriodSeconds *int32 `json:"LivenessProbePeriodSeconds,omitempty" xml:"LivenessProbePeriodSeconds,omitempty"`
	// The minimum number of consecutive successes for a probe to be considered successful after having failed. Default value: 1. Valid value: 1.
	LivenessProbeSuccessThreshold *int32 `json:"LivenessProbeSuccessThreshold,omitempty" xml:"LivenessProbeSuccessThreshold,omitempty"`
	// The port number of TcpSocket.
	LivenessProbeTcpSocketPort *int32 `json:"LivenessProbeTcpSocketPort,omitempty" xml:"LivenessProbeTcpSocketPort,omitempty"`
	// The timeout period of a probe. Default value: 1. Minimum value: 1. Unit: seconds.
	LivenessProbeTimeoutSeconds *int32 `json:"LivenessProbeTimeoutSeconds,omitempty" xml:"LivenessProbeTimeoutSeconds,omitempty"`
	// The memory size of the container.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The name of the container.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The exposed ports and protocols of the container.
	Ports []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts `json:"Ports,omitempty" xml:"Ports,omitempty" type:"Repeated"`
	// The commands that are run in the container when you use the CLI to perform probes.
	ReadinessProbeExecCommands []*string `json:"ReadinessProbeExecCommands,omitempty" xml:"ReadinessProbeExecCommands,omitempty" type:"Repeated"`
	// The minimum number of consecutive failures for a probe to be considered failed after having been successful.
	//
	// Default value: 3.
	ReadinessProbeFailureThreshold *int32 `json:"ReadinessProbeFailureThreshold,omitempty" xml:"ReadinessProbeFailureThreshold,omitempty"`
	// The path to which the system sends an HTTP GET request for a probe.
	ReadinessProbeHttpGetPath *string `json:"ReadinessProbeHttpGetPath,omitempty" xml:"ReadinessProbeHttpGetPath,omitempty"`
	// The path to which the system sends an HTTP GET request for a probe.
	ReadinessProbeHttpGetPort *int32 `json:"ReadinessProbeHttpGetPort,omitempty" xml:"ReadinessProbeHttpGetPort,omitempty"`
	// The protocol type of HTTP GET requests when you use HTTP requests to perform probes. Valid values:
	//
	// *   HTTP
	// *   HTTPS
	ReadinessProbeHttpGetScheme *string `json:"ReadinessProbeHttpGetScheme,omitempty" xml:"ReadinessProbeHttpGetScheme,omitempty"`
	// The number of seconds between the time when the startup of the container ends and the time when the probe starts.
	ReadinessProbeInitialDelaySeconds *int32 `json:"ReadinessProbeInitialDelaySeconds,omitempty" xml:"ReadinessProbeInitialDelaySeconds,omitempty"`
	// The interval at which probes are performed. Default value: 10. Minimum value: 1. Unit: seconds.
	ReadinessProbePeriodSeconds *int32 `json:"ReadinessProbePeriodSeconds,omitempty" xml:"ReadinessProbePeriodSeconds,omitempty"`
	// The minimum number of consecutive successes for a probe to be considered successful after having failed. Default value: 1. Valid value: 1.
	ReadinessProbeSuccessThreshold *int32 `json:"ReadinessProbeSuccessThreshold,omitempty" xml:"ReadinessProbeSuccessThreshold,omitempty"`
	// The port number of TcpSocket.
	ReadinessProbeTcpSocketPort *int32 `json:"ReadinessProbeTcpSocketPort,omitempty" xml:"ReadinessProbeTcpSocketPort,omitempty"`
	// The timeout period of a probe. Default value: 1. Minimum value: 1. Unit: seconds.
	ReadinessProbeTimeoutSeconds *int32 `json:"ReadinessProbeTimeoutSeconds,omitempty" xml:"ReadinessProbeTimeoutSeconds,omitempty"`
	// The permissions granted to processes in the container. Valid values: NET_ADMIN and NET_RAW.
	//
	// > To use NET_RAW, you need to submit a ticket.
	SecurityContextCapabilityAdds []*string `json:"SecurityContextCapabilityAdds,omitempty" xml:"SecurityContextCapabilityAdds,omitempty" type:"Repeated"`
	// Indicates whether the root file system is set to the read-only mode. The only valid value is true.
	SecurityContextReadOnlyRootFilesystem *bool `json:"SecurityContextReadOnlyRootFilesystem,omitempty" xml:"SecurityContextReadOnlyRootFilesystem,omitempty"`
	// The user ID (UID) that is used to run the entry point of the container process.
	SecurityContextRunAsUser *int64 `json:"SecurityContextRunAsUser,omitempty" xml:"SecurityContextRunAsUser,omitempty"`
	// Indicates whether the container allocates buffer resources to standard input streams when the container runs. If you do not specify this parameter, an end-of-file (EOF) error may occur. Default value: false.
	Stdin *bool `json:"Stdin,omitempty" xml:"Stdin,omitempty"`
	// Indicates whether standard input streams are disconnected after a client is disconnected. If Stdin is set to true, standard input streams remain connected during multiple sessions.
	//
	// If StdinOnce is set to true, standard input streams are connected after the container is started and remain idle until a client is connected to receive data. After the client is disconnected, streams are also disconnected and remain in the disconnected state until the container is started again.
	StdinOnce *bool `json:"StdinOnce,omitempty" xml:"StdinOnce,omitempty"`
	// Indicates whether interaction is enabled. Valid values:
	//
	// *   true
	// *   false
	//
	// If the value of the Command parameter is /bin/bash, the value of this parameter is true.
	//
	// Default value: false.
	Tty *bool `json:"Tty,omitempty" xml:"Tty,omitempty"`
	// The volumes that are mounted on the container.
	VolumeMounts []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts `json:"VolumeMounts,omitempty" xml:"VolumeMounts,omitempty" type:"Repeated"`
	// The working directory of the container.
	WorkingDir *string `json:"WorkingDir,omitempty" xml:"WorkingDir,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetArgs(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.Args = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetCommands(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.Commands = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetCpu(v float32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.Cpu = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetEnvironmentVars(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.EnvironmentVars = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetGpu(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.Gpu = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetImage(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.Image = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetImagePullPolicy(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.ImagePullPolicy = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetLivenessProbeExecCommands(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.LivenessProbeExecCommands = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetLivenessProbeFailureThreshold(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.LivenessProbeFailureThreshold = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetLivenessProbeHttpGetPath(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.LivenessProbeHttpGetPath = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetLivenessProbeHttpGetPort(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.LivenessProbeHttpGetPort = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetLivenessProbeHttpGetScheme(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.LivenessProbeHttpGetScheme = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetLivenessProbeInitialDelaySeconds(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.LivenessProbeInitialDelaySeconds = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetLivenessProbePeriodSeconds(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.LivenessProbePeriodSeconds = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetLivenessProbeSuccessThreshold(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.LivenessProbeSuccessThreshold = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetLivenessProbeTcpSocketPort(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.LivenessProbeTcpSocketPort = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetLivenessProbeTimeoutSeconds(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.LivenessProbeTimeoutSeconds = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetMemory(v float32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.Memory = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.Name = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetPorts(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.Ports = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetReadinessProbeExecCommands(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.ReadinessProbeExecCommands = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetReadinessProbeFailureThreshold(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.ReadinessProbeFailureThreshold = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetReadinessProbeHttpGetPath(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.ReadinessProbeHttpGetPath = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetReadinessProbeHttpGetPort(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.ReadinessProbeHttpGetPort = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetReadinessProbeHttpGetScheme(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.ReadinessProbeHttpGetScheme = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetReadinessProbeInitialDelaySeconds(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.ReadinessProbeInitialDelaySeconds = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetReadinessProbePeriodSeconds(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.ReadinessProbePeriodSeconds = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetReadinessProbeSuccessThreshold(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.ReadinessProbeSuccessThreshold = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetReadinessProbeTcpSocketPort(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.ReadinessProbeTcpSocketPort = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetReadinessProbeTimeoutSeconds(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.ReadinessProbeTimeoutSeconds = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetSecurityContextCapabilityAdds(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.SecurityContextCapabilityAdds = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetSecurityContextReadOnlyRootFilesystem(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.SecurityContextReadOnlyRootFilesystem = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetSecurityContextRunAsUser(v int64) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.SecurityContextRunAsUser = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetStdin(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.Stdin = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetStdinOnce(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.StdinOnce = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetTty(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.Tty = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetVolumeMounts(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.VolumeMounts = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetWorkingDir(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.WorkingDir = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars struct {
	// > This parameter is unavailable.
	FieldRefFieldPath *string `json:"FieldRefFieldPath,omitempty" xml:"FieldRefFieldPath,omitempty"`
	// The name of the environment variable.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the environment variable.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars) SetFieldRefFieldPath(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars {
	s.FieldRefFieldPath = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars) SetKey(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars {
	s.Key = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars) SetValue(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars {
	s.Value = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts struct {
	// The port number. Valid values: 1 to 65535.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The protocol. Valid values:
	//
	// *   TCP
	// *   UDP
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts) SetPort(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts {
	s.Port = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts) SetProtocol(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts {
	s.Protocol = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts struct {
	// The directory in which the container mounts the volume.
	//
	// > Data in this directory is overwritten by the data on the volume.
	MountPath *string `json:"MountPath,omitempty" xml:"MountPath,omitempty"`
	// The mount propagation setting of the volume. Mount propagation allows the sharing of volumes that are mounted on one container with other containers in the same pod, or even with other pods on the same node. Valid values:
	//
	// *   None: The volume mount does not receive subsequent mounts that are mounted to this volume or its subdirectories.
	// *   HostToCotainer: The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories.
	// *   Bidirectional: This value is similar to HostToCotainer. The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories. In addition, all volume mounts that are created by the container are propagated back to the instance and to all containers of all pods that use the same volume.
	//
	// Default value: None.
	MountPropagation *string `json:"MountPropagation,omitempty" xml:"MountPropagation,omitempty"`
	// The name of the volume. The value of this parameter is the same as the value of the Volumes.Name parameter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Indicates whether the volume is read-only.
	//
	// Default value: false.
	ReadOnly *bool `json:"ReadOnly,omitempty" xml:"ReadOnly,omitempty"`
	// The subdirectory of the volume.
	SubPath *string `json:"SubPath,omitempty" xml:"SubPath,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts) SetMountPath(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts {
	s.MountPath = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts) SetMountPropagation(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts {
	s.MountPropagation = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts) SetName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts {
	s.Name = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts) SetReadOnly(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts {
	s.ReadOnly = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts) SetSubPath(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts {
	s.SubPath = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions struct {
	// The variable name of the option.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The variable value of the option.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions) SetName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions {
	s.Name = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions) SetValue(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions {
	s.Value = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases struct {
	// The hostnames that are added.
	Hostnames []*string `json:"Hostnames,omitempty" xml:"Hostnames,omitempty" type:"Repeated"`
	// The IP address that is added.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases) SetHostnames(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases {
	s.Hostnames = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases) SetIp(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases {
	s.Ip = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials struct {
	// The password that is used to access the image repository.
	Password *string `json:"Password,omitempty" xml:"Password,omitempty"`
	// The domain name of the image repository.
	Server *string `json:"Server,omitempty" xml:"Server,omitempty"`
	// The username that is used to access the image repository.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials) SetPassword(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials {
	s.Password = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials) SetServer(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials {
	s.Server = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials) SetUserName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials {
	s.UserName = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers struct {
	// The number of vCPUs.
	Cpu *float32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The number of GPUs that are allocated to the container.
	Gpu *int32 `json:"Gpu,omitempty" xml:"Gpu,omitempty"`
	// The container image.
	Image *string `json:"Image,omitempty" xml:"Image,omitempty"`
	// The image pulling policy.
	ImagePullPolicy *string `json:"ImagePullPolicy,omitempty" xml:"ImagePullPolicy,omitempty"`
	// The container startup arguments.
	InitContainerArgs []*string `json:"InitContainerArgs,omitempty" xml:"InitContainerArgs,omitempty" type:"Repeated"`
	// The container startup commands.
	InitContainerCommands []*string `json:"InitContainerCommands,omitempty" xml:"InitContainerCommands,omitempty" type:"Repeated"`
	// Details of the environment variables.
	InitContainerEnvironmentVars []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars `json:"InitContainerEnvironmentVars,omitempty" xml:"InitContainerEnvironmentVars,omitempty" type:"Repeated"`
	// Details of the init container ports.
	InitContainerPorts []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts `json:"InitContainerPorts,omitempty" xml:"InitContainerPorts,omitempty" type:"Repeated"`
	// The volumes that are mounted on the container.
	InitContainerVolumeMounts []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts `json:"InitContainerVolumeMounts,omitempty" xml:"InitContainerVolumeMounts,omitempty" type:"Repeated"`
	// The size of the memory.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The name of the container.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The permissions that are granted to the processes in the container. Valid values: NET_ADMIN and NET_RAW.
	//
	// > To use NET_RAW, you need to submit a ticket.
	SecurityContextCapabilityAdds []*string `json:"SecurityContextCapabilityAdds,omitempty" xml:"SecurityContextCapabilityAdds,omitempty" type:"Repeated"`
	// Indicates whether the root file system is read-only. The only valid value is true.
	SecurityContextReadOnlyRootFilesystem *bool `json:"SecurityContextReadOnlyRootFilesystem,omitempty" xml:"SecurityContextReadOnlyRootFilesystem,omitempty"`
	// The ID of the user that runs the container.
	SecurityContextRunAsUser *string `json:"SecurityContextRunAsUser,omitempty" xml:"SecurityContextRunAsUser,omitempty"`
	// The working directory.
	WorkingDir *string `json:"WorkingDir,omitempty" xml:"WorkingDir,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetCpu(v float32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.Cpu = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetGpu(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.Gpu = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetImage(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.Image = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetImagePullPolicy(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.ImagePullPolicy = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetInitContainerArgs(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.InitContainerArgs = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetInitContainerCommands(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.InitContainerCommands = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetInitContainerEnvironmentVars(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.InitContainerEnvironmentVars = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetInitContainerPorts(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.InitContainerPorts = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetInitContainerVolumeMounts(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.InitContainerVolumeMounts = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetMemory(v float32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.Memory = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.Name = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetSecurityContextCapabilityAdds(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.SecurityContextCapabilityAdds = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetSecurityContextReadOnlyRootFilesystem(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.SecurityContextReadOnlyRootFilesystem = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetSecurityContextRunAsUser(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.SecurityContextRunAsUser = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetWorkingDir(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.WorkingDir = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars struct {
	// > This parameter is unavailable.
	FieldRefFieldPath *string `json:"FieldRefFieldPath,omitempty" xml:"FieldRefFieldPath,omitempty"`
	// The name of the environment variable.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the environment variable.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars) SetFieldRefFieldPath(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars {
	s.FieldRefFieldPath = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars) SetKey(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars {
	s.Key = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars) SetValue(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars {
	s.Value = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts struct {
	// The port number. Valid values: 1 to 65535.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The protocol. Valid values:
	//
	// *   TCP
	// *   UDP
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts) SetPort(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts {
	s.Port = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts) SetProtocol(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts {
	s.Protocol = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts struct {
	// The directory to which the volume is mounted. Data under this directory is overwritten by the data on the volume.
	MountPath *string `json:"MountPath,omitempty" xml:"MountPath,omitempty"`
	// The mount propagation setting of the volume. Mount propagation allows the sharing of volumes that are mounted on one container with other containers in the same pod, or even with other pods on the same node. Valid values:
	//
	// *   None: The volume mount does not receive subsequent mounts that are mounted to this volume or its subdirectories.
	// *   HostToCotainer: The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories.
	// *   Bidirectional: This value is similar to HostToCotainer. The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories. In addition, all volume mounts that are created by the container are propagated back to the instance and to all containers of all pods that use the same volume.
	//
	// Default value: None.
	MountPropagation *string `json:"MountPropagation,omitempty" xml:"MountPropagation,omitempty"`
	// The name of the volume.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Indicates whether the mount path is read-only.
	//
	// Default value: false.
	ReadOnly *bool `json:"ReadOnly,omitempty" xml:"ReadOnly,omitempty"`
	// The subdirectory of the volume. The elastic container instance can mount different directories of the same volume to different subdirectories of containers.
	SubPath *string `json:"SubPath,omitempty" xml:"SubPath,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts) SetMountPath(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts {
	s.MountPath = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts) SetMountPropagation(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts {
	s.MountPropagation = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts) SetName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts {
	s.Name = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts) SetReadOnly(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts {
	s.ReadOnly = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts) SetSubPath(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts {
	s.SubPath = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls struct {
	// The name of the security context in which the elastic container instance runs.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The variable value of the security context in which the elastic container instance runs.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls) SetName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls {
	s.Name = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls) SetValue(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls {
	s.Value = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags struct {
	// The key of the tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags) SetKey(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags {
	s.Key = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags) SetValue(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags {
	s.Value = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes struct {
	// The paths to configuration files.
	ConfigFileVolumeConfigFileToPaths []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths `json:"ConfigFileVolumeConfigFileToPaths,omitempty" xml:"ConfigFileVolumeConfigFileToPaths,omitempty" type:"Repeated"`
	// The default permissions on the ConfigFile volume.
	ConfigFileVolumeDefaultMode *int32 `json:"ConfigFileVolumeDefaultMode,omitempty" xml:"ConfigFileVolumeDefaultMode,omitempty"`
	// The storage size of a disk volume. Unit: GiB.
	DiskVolumeDiskId *string `json:"DiskVolumeDiskId,omitempty" xml:"DiskVolumeDiskId,omitempty"`
	// The storage size of a disk volume. Unit: GiB.
	DiskVolumeDiskSize *int32 `json:"DiskVolumeDiskSize,omitempty" xml:"DiskVolumeDiskSize,omitempty"`
	// The file system type of a disk volume.
	DiskVolumeFsType *string `json:"DiskVolumeFsType,omitempty" xml:"DiskVolumeFsType,omitempty"`
	// The storage medium of EmptyDirVolume. If this parameter is left empty, the file system that backs the node is used as the storage medium. If this parameter is set to memory, the memory is used as the storage medium.
	EmptyDirVolumeMedium *string `json:"EmptyDirVolumeMedium,omitempty" xml:"EmptyDirVolumeMedium,omitempty"`
	// EmptyDir数据卷的大小。
	EmptyDirVolumeSizeLimit *string `json:"EmptyDirVolumeSizeLimit,omitempty" xml:"EmptyDirVolumeSizeLimit,omitempty"`
	// The FlexVolume driver name of the volume.
	FlexVolumeDriver *string `json:"FlexVolumeDriver,omitempty" xml:"FlexVolumeDriver,omitempty"`
	// The file system type of the volume. The default value is determined by the script of FlexVolume.
	FlexVolumeFsType *string `json:"FlexVolumeFsType,omitempty" xml:"FlexVolumeFsType,omitempty"`
	// The FlexVolume options. Each option is a key-value pair in a JSON string.
	//
	// For example, when you use FlexVolume to mount a disk, the format of options is `{"volumeId":"d-2zehdahrwoa7srg****","performanceLevel": "PL2"}`.
	FlexVolumeOptions *string `json:"FlexVolumeOptions,omitempty" xml:"FlexVolumeOptions,omitempty"`
	// HostPath Volume在主机上的目录路径。
	HostPathVolumePath *string `json:"HostPathVolumePath,omitempty" xml:"HostPathVolumePath,omitempty"`
	// HostPath Volume的类型。
	HostPathVolumeType *string `json:"HostPathVolumeType,omitempty" xml:"HostPathVolumeType,omitempty"`
	// The path to the Network File System (NFS) volume.
	NFSVolumePath *string `json:"NFSVolumePath,omitempty" xml:"NFSVolumePath,omitempty"`
	// Indicates whether the NFS volume is read-only.
	//
	// Default value: false.
	NFSVolumeReadOnly *bool `json:"NFSVolumeReadOnly,omitempty" xml:"NFSVolumeReadOnly,omitempty"`
	// The endpoint of the NFS server.
	NFSVolumeServer *string `json:"NFSVolumeServer,omitempty" xml:"NFSVolumeServer,omitempty"`
	// The name of the volume.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the volume. Valid values:
	//
	// *   EmptyDirVolume
	// *   NFSVolume
	// *   ConfigFileVolume
	// *   FlexVolume
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetConfigFileVolumeConfigFileToPaths(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.ConfigFileVolumeConfigFileToPaths = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetConfigFileVolumeDefaultMode(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.ConfigFileVolumeDefaultMode = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetDiskVolumeDiskId(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.DiskVolumeDiskId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetDiskVolumeDiskSize(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.DiskVolumeDiskSize = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetDiskVolumeFsType(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.DiskVolumeFsType = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetEmptyDirVolumeMedium(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.EmptyDirVolumeMedium = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetEmptyDirVolumeSizeLimit(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.EmptyDirVolumeSizeLimit = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetFlexVolumeDriver(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.FlexVolumeDriver = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetFlexVolumeFsType(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.FlexVolumeFsType = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetFlexVolumeOptions(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.FlexVolumeOptions = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetHostPathVolumePath(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.HostPathVolumePath = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetHostPathVolumeType(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.HostPathVolumeType = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetNFSVolumePath(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.NFSVolumePath = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetNFSVolumeReadOnly(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.NFSVolumeReadOnly = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetNFSVolumeServer(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.NFSVolumeServer = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.Name = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetType(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.Type = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths struct {
	// The content of the configuration file (32 KB).
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The permissions on the ConfigFile volume.
	Mode *int32 `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The relative path to the configuration file.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths) SetContent(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths {
	s.Content = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths) SetMode(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths {
	s.Mode = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths) SetPath(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths {
	s.Path = &v
	return s
}

type DescribeEciScalingConfigurationsResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeEciScalingConfigurationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeEciScalingConfigurationsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponse) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponse) SetHeaders(v map[string]*string) *DescribeEciScalingConfigurationsResponse {
	s.Headers = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponse) SetStatusCode(v int32) *DescribeEciScalingConfigurationsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponse) SetBody(v *DescribeEciScalingConfigurationsResponseBody) *DescribeEciScalingConfigurationsResponse {
	s.Body = v
	return s
}

type DescribeLifecycleActionsRequest struct {
	// The status of the lifecycle action. Valid values:
	//
	// *   If a lifecycle action is in the Pending state, Elastic Compute Service (ECS) instances are waiting to be added to a scaling group or waiting to be removed from a scaling group.
	// *   If a lifecycle action is in the Timeout state, the lifecycle hook that triggers the lifecycle action ends, and ECS instances are added to or removed from the scaling group.
	// *   If a lifecycle action is in the Completed state, you manually end the lifecycle hook that triggers the lifecycle action ahead of schedule.
	LifecycleActionStatus *string `json:"LifecycleActionStatus,omitempty" xml:"LifecycleActionStatus,omitempty"`
	// The maximum number of entries to return on each page. Valid values: 1 to 50.
	//
	// Default value: 10.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used to specify the lifecycle action from which the query starts.
	//
	// For example, after the first 10 lifecycle actions are queried, the query starts from the 11th lifecycle action. Set this parameter to the NextToken value that is returned in the previous API call. If you do not specify this parameter, the query starts from the beginning.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerId   *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling activity.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s DescribeLifecycleActionsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeLifecycleActionsRequest) GoString() string {
	return s.String()
}

func (s *DescribeLifecycleActionsRequest) SetLifecycleActionStatus(v string) *DescribeLifecycleActionsRequest {
	s.LifecycleActionStatus = &v
	return s
}

func (s *DescribeLifecycleActionsRequest) SetMaxResults(v int32) *DescribeLifecycleActionsRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeLifecycleActionsRequest) SetNextToken(v string) *DescribeLifecycleActionsRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeLifecycleActionsRequest) SetOwnerId(v int64) *DescribeLifecycleActionsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeLifecycleActionsRequest) SetRegionId(v string) *DescribeLifecycleActionsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeLifecycleActionsRequest) SetResourceOwnerAccount(v string) *DescribeLifecycleActionsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeLifecycleActionsRequest) SetScalingActivityId(v string) *DescribeLifecycleActionsRequest {
	s.ScalingActivityId = &v
	return s
}

type DescribeLifecycleActionsResponseBody struct {
	// The lifecycle actions.
	LifecycleActions []*DescribeLifecycleActionsResponseBodyLifecycleActions `json:"LifecycleActions,omitempty" xml:"LifecycleActions,omitempty" type:"Repeated"`
	// The maximum number of entries returned per page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The query token returned in this call.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of the queried lifecycle actions.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeLifecycleActionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeLifecycleActionsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeLifecycleActionsResponseBody) SetLifecycleActions(v []*DescribeLifecycleActionsResponseBodyLifecycleActions) *DescribeLifecycleActionsResponseBody {
	s.LifecycleActions = v
	return s
}

func (s *DescribeLifecycleActionsResponseBody) SetMaxResults(v int32) *DescribeLifecycleActionsResponseBody {
	s.MaxResults = &v
	return s
}

func (s *DescribeLifecycleActionsResponseBody) SetNextToken(v string) *DescribeLifecycleActionsResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeLifecycleActionsResponseBody) SetRequestId(v string) *DescribeLifecycleActionsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeLifecycleActionsResponseBody) SetTotalCount(v int32) *DescribeLifecycleActionsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeLifecycleActionsResponseBodyLifecycleActions struct {
	// The IDs of the ECS instances to which the lifecycle hook applies.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The action that is performed after the lifecycle action triggered by the lifecycle hook is complete. Valid values:
	//
	// *   CONTINUE: Auto Scaling continues to add ECS instances to the scaling group, or continues to remove ECS instances from the scaling group.
	// *   ABANDON: Auto Scaling stops adding ECS instances to the scaling group and releases the ECS instances, or continues to respond to scale-in requests and remove ECS instances from the scaling group.
	LifecycleActionResult *string `json:"LifecycleActionResult,omitempty" xml:"LifecycleActionResult,omitempty"`
	// The status of the lifecycle action.
	LifecycleActionStatus *string `json:"LifecycleActionStatus,omitempty" xml:"LifecycleActionStatus,omitempty"`
	// The token of the lifecycle action.
	LifecycleActionToken *string `json:"LifecycleActionToken,omitempty" xml:"LifecycleActionToken,omitempty"`
	// The ID of the lifecycle hook.
	LifecycleHookId *string `json:"LifecycleHookId,omitempty" xml:"LifecycleHookId,omitempty"`
}

func (s DescribeLifecycleActionsResponseBodyLifecycleActions) String() string {
	return tea.Prettify(s)
}

func (s DescribeLifecycleActionsResponseBodyLifecycleActions) GoString() string {
	return s.String()
}

func (s *DescribeLifecycleActionsResponseBodyLifecycleActions) SetInstanceIds(v []*string) *DescribeLifecycleActionsResponseBodyLifecycleActions {
	s.InstanceIds = v
	return s
}

func (s *DescribeLifecycleActionsResponseBodyLifecycleActions) SetLifecycleActionResult(v string) *DescribeLifecycleActionsResponseBodyLifecycleActions {
	s.LifecycleActionResult = &v
	return s
}

func (s *DescribeLifecycleActionsResponseBodyLifecycleActions) SetLifecycleActionStatus(v string) *DescribeLifecycleActionsResponseBodyLifecycleActions {
	s.LifecycleActionStatus = &v
	return s
}

func (s *DescribeLifecycleActionsResponseBodyLifecycleActions) SetLifecycleActionToken(v string) *DescribeLifecycleActionsResponseBodyLifecycleActions {
	s.LifecycleActionToken = &v
	return s
}

func (s *DescribeLifecycleActionsResponseBodyLifecycleActions) SetLifecycleHookId(v string) *DescribeLifecycleActionsResponseBodyLifecycleActions {
	s.LifecycleHookId = &v
	return s
}

type DescribeLifecycleActionsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeLifecycleActionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeLifecycleActionsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeLifecycleActionsResponse) GoString() string {
	return s.String()
}

func (s *DescribeLifecycleActionsResponse) SetHeaders(v map[string]*string) *DescribeLifecycleActionsResponse {
	s.Headers = v
	return s
}

func (s *DescribeLifecycleActionsResponse) SetStatusCode(v int32) *DescribeLifecycleActionsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeLifecycleActionsResponse) SetBody(v *DescribeLifecycleActionsResponseBody) *DescribeLifecycleActionsResponse {
	s.Body = v
	return s
}

type DescribeLifecycleHooksRequest struct {
	LifecycleHookIds     []*string `json:"LifecycleHookIds,omitempty" xml:"LifecycleHookIds,omitempty" type:"Repeated"`
	LifecycleHookName    *string   `json:"LifecycleHookName,omitempty" xml:"LifecycleHookName,omitempty"`
	OwnerAccount         *string   `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	PageNumber           *int32    `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize             *int32    `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RegionId             *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ScalingGroupId       *string   `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DescribeLifecycleHooksRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeLifecycleHooksRequest) GoString() string {
	return s.String()
}

func (s *DescribeLifecycleHooksRequest) SetLifecycleHookIds(v []*string) *DescribeLifecycleHooksRequest {
	s.LifecycleHookIds = v
	return s
}

func (s *DescribeLifecycleHooksRequest) SetLifecycleHookName(v string) *DescribeLifecycleHooksRequest {
	s.LifecycleHookName = &v
	return s
}

func (s *DescribeLifecycleHooksRequest) SetOwnerAccount(v string) *DescribeLifecycleHooksRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeLifecycleHooksRequest) SetOwnerId(v int64) *DescribeLifecycleHooksRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeLifecycleHooksRequest) SetPageNumber(v int32) *DescribeLifecycleHooksRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeLifecycleHooksRequest) SetPageSize(v int32) *DescribeLifecycleHooksRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeLifecycleHooksRequest) SetRegionId(v string) *DescribeLifecycleHooksRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeLifecycleHooksRequest) SetResourceOwnerAccount(v string) *DescribeLifecycleHooksRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeLifecycleHooksRequest) SetScalingGroupId(v string) *DescribeLifecycleHooksRequest {
	s.ScalingGroupId = &v
	return s
}

type DescribeLifecycleHooksResponseBody struct {
	LifecycleHooks []*DescribeLifecycleHooksResponseBodyLifecycleHooks `json:"LifecycleHooks,omitempty" xml:"LifecycleHooks,omitempty" type:"Repeated"`
	PageNumber     *int32                                              `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize       *int32                                              `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RequestId      *string                                             `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount     *int32                                              `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeLifecycleHooksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeLifecycleHooksResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeLifecycleHooksResponseBody) SetLifecycleHooks(v []*DescribeLifecycleHooksResponseBodyLifecycleHooks) *DescribeLifecycleHooksResponseBody {
	s.LifecycleHooks = v
	return s
}

func (s *DescribeLifecycleHooksResponseBody) SetPageNumber(v int32) *DescribeLifecycleHooksResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeLifecycleHooksResponseBody) SetPageSize(v int32) *DescribeLifecycleHooksResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeLifecycleHooksResponseBody) SetRequestId(v string) *DescribeLifecycleHooksResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeLifecycleHooksResponseBody) SetTotalCount(v int32) *DescribeLifecycleHooksResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeLifecycleHooksResponseBodyLifecycleHooks struct {
	DefaultResult        *string `json:"DefaultResult,omitempty" xml:"DefaultResult,omitempty"`
	HeartbeatTimeout     *int32  `json:"HeartbeatTimeout,omitempty" xml:"HeartbeatTimeout,omitempty"`
	LifecycleHookId      *string `json:"LifecycleHookId,omitempty" xml:"LifecycleHookId,omitempty"`
	LifecycleHookName    *string `json:"LifecycleHookName,omitempty" xml:"LifecycleHookName,omitempty"`
	LifecycleHookStatus  *string `json:"LifecycleHookStatus,omitempty" xml:"LifecycleHookStatus,omitempty"`
	LifecycleTransition  *string `json:"LifecycleTransition,omitempty" xml:"LifecycleTransition,omitempty"`
	NotificationArn      *string `json:"NotificationArn,omitempty" xml:"NotificationArn,omitempty"`
	NotificationMetadata *string `json:"NotificationMetadata,omitempty" xml:"NotificationMetadata,omitempty"`
	ScalingGroupId       *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DescribeLifecycleHooksResponseBodyLifecycleHooks) String() string {
	return tea.Prettify(s)
}

func (s DescribeLifecycleHooksResponseBodyLifecycleHooks) GoString() string {
	return s.String()
}

func (s *DescribeLifecycleHooksResponseBodyLifecycleHooks) SetDefaultResult(v string) *DescribeLifecycleHooksResponseBodyLifecycleHooks {
	s.DefaultResult = &v
	return s
}

func (s *DescribeLifecycleHooksResponseBodyLifecycleHooks) SetHeartbeatTimeout(v int32) *DescribeLifecycleHooksResponseBodyLifecycleHooks {
	s.HeartbeatTimeout = &v
	return s
}

func (s *DescribeLifecycleHooksResponseBodyLifecycleHooks) SetLifecycleHookId(v string) *DescribeLifecycleHooksResponseBodyLifecycleHooks {
	s.LifecycleHookId = &v
	return s
}

func (s *DescribeLifecycleHooksResponseBodyLifecycleHooks) SetLifecycleHookName(v string) *DescribeLifecycleHooksResponseBodyLifecycleHooks {
	s.LifecycleHookName = &v
	return s
}

func (s *DescribeLifecycleHooksResponseBodyLifecycleHooks) SetLifecycleHookStatus(v string) *DescribeLifecycleHooksResponseBodyLifecycleHooks {
	s.LifecycleHookStatus = &v
	return s
}

func (s *DescribeLifecycleHooksResponseBodyLifecycleHooks) SetLifecycleTransition(v string) *DescribeLifecycleHooksResponseBodyLifecycleHooks {
	s.LifecycleTransition = &v
	return s
}

func (s *DescribeLifecycleHooksResponseBodyLifecycleHooks) SetNotificationArn(v string) *DescribeLifecycleHooksResponseBodyLifecycleHooks {
	s.NotificationArn = &v
	return s
}

func (s *DescribeLifecycleHooksResponseBodyLifecycleHooks) SetNotificationMetadata(v string) *DescribeLifecycleHooksResponseBodyLifecycleHooks {
	s.NotificationMetadata = &v
	return s
}

func (s *DescribeLifecycleHooksResponseBodyLifecycleHooks) SetScalingGroupId(v string) *DescribeLifecycleHooksResponseBodyLifecycleHooks {
	s.ScalingGroupId = &v
	return s
}

type DescribeLifecycleHooksResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeLifecycleHooksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeLifecycleHooksResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeLifecycleHooksResponse) GoString() string {
	return s.String()
}

func (s *DescribeLifecycleHooksResponse) SetHeaders(v map[string]*string) *DescribeLifecycleHooksResponse {
	s.Headers = v
	return s
}

func (s *DescribeLifecycleHooksResponse) SetStatusCode(v int32) *DescribeLifecycleHooksResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeLifecycleHooksResponse) SetBody(v *DescribeLifecycleHooksResponseBody) *DescribeLifecycleHooksResponse {
	s.Body = v
	return s
}

type DescribeLimitationRequest struct {
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
}

func (s DescribeLimitationRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeLimitationRequest) GoString() string {
	return s.String()
}

func (s *DescribeLimitationRequest) SetOwnerId(v int64) *DescribeLimitationRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeLimitationRequest) SetResourceOwnerAccount(v string) *DescribeLimitationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

type DescribeLimitationResponseBody struct {
	MaxNumberOfAlbServerGroup             *int32  `json:"MaxNumberOfAlbServerGroup,omitempty" xml:"MaxNumberOfAlbServerGroup,omitempty"`
	MaxNumberOfDBInstances                *int32  `json:"MaxNumberOfDBInstances,omitempty" xml:"MaxNumberOfDBInstances,omitempty"`
	MaxNumberOfLifecycleHooks             *int32  `json:"MaxNumberOfLifecycleHooks,omitempty" xml:"MaxNumberOfLifecycleHooks,omitempty"`
	MaxNumberOfLoadBalancers              *int32  `json:"MaxNumberOfLoadBalancers,omitempty" xml:"MaxNumberOfLoadBalancers,omitempty"`
	MaxNumberOfMaxSize                    *int32  `json:"MaxNumberOfMaxSize,omitempty" xml:"MaxNumberOfMaxSize,omitempty"`
	MaxNumberOfMinSize                    *int32  `json:"MaxNumberOfMinSize,omitempty" xml:"MaxNumberOfMinSize,omitempty"`
	MaxNumberOfNlbServerGroup             *int32  `json:"MaxNumberOfNlbServerGroup,omitempty" xml:"MaxNumberOfNlbServerGroup,omitempty"`
	MaxNumberOfNotificationConfigurations *int32  `json:"MaxNumberOfNotificationConfigurations,omitempty" xml:"MaxNumberOfNotificationConfigurations,omitempty"`
	MaxNumberOfScalingConfigurations      *int32  `json:"MaxNumberOfScalingConfigurations,omitempty" xml:"MaxNumberOfScalingConfigurations,omitempty"`
	MaxNumberOfScalingGroups              *int32  `json:"MaxNumberOfScalingGroups,omitempty" xml:"MaxNumberOfScalingGroups,omitempty"`
	MaxNumberOfScalingInstances           *int32  `json:"MaxNumberOfScalingInstances,omitempty" xml:"MaxNumberOfScalingInstances,omitempty"`
	MaxNumberOfScalingRules               *int32  `json:"MaxNumberOfScalingRules,omitempty" xml:"MaxNumberOfScalingRules,omitempty"`
	MaxNumberOfScheduledTasks             *int32  `json:"MaxNumberOfScheduledTasks,omitempty" xml:"MaxNumberOfScheduledTasks,omitempty"`
	MaxNumberOfVServerGroups              *int32  `json:"MaxNumberOfVServerGroups,omitempty" xml:"MaxNumberOfVServerGroups,omitempty"`
	RequestId                             *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeLimitationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeLimitationResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfAlbServerGroup(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfAlbServerGroup = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfDBInstances(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfDBInstances = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfLifecycleHooks(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfLifecycleHooks = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfLoadBalancers(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfLoadBalancers = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfMaxSize(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfMaxSize = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfMinSize(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfMinSize = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfNlbServerGroup(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfNlbServerGroup = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfNotificationConfigurations(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfNotificationConfigurations = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfScalingConfigurations(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfScalingConfigurations = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfScalingGroups(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfScalingGroups = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfScalingInstances(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfScalingInstances = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfScalingRules(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfScalingRules = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfScheduledTasks(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfScheduledTasks = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfVServerGroups(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfVServerGroups = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetRequestId(v string) *DescribeLimitationResponseBody {
	s.RequestId = &v
	return s
}

type DescribeLimitationResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeLimitationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeLimitationResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeLimitationResponse) GoString() string {
	return s.String()
}

func (s *DescribeLimitationResponse) SetHeaders(v map[string]*string) *DescribeLimitationResponse {
	s.Headers = v
	return s
}

func (s *DescribeLimitationResponse) SetStatusCode(v int32) *DescribeLimitationResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeLimitationResponse) SetBody(v *DescribeLimitationResponseBody) *DescribeLimitationResponse {
	s.Body = v
	return s
}

type DescribeNotificationConfigurationsRequest struct {
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DescribeNotificationConfigurationsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeNotificationConfigurationsRequest) GoString() string {
	return s.String()
}

func (s *DescribeNotificationConfigurationsRequest) SetOwnerId(v int64) *DescribeNotificationConfigurationsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeNotificationConfigurationsRequest) SetRegionId(v string) *DescribeNotificationConfigurationsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeNotificationConfigurationsRequest) SetResourceOwnerAccount(v string) *DescribeNotificationConfigurationsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeNotificationConfigurationsRequest) SetScalingGroupId(v string) *DescribeNotificationConfigurationsRequest {
	s.ScalingGroupId = &v
	return s
}

type DescribeNotificationConfigurationsResponseBody struct {
	// Details of the notifications.
	NotificationConfigurationModels []*DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels `json:"NotificationConfigurationModels,omitempty" xml:"NotificationConfigurationModels,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeNotificationConfigurationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeNotificationConfigurationsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeNotificationConfigurationsResponseBody) SetNotificationConfigurationModels(v []*DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels) *DescribeNotificationConfigurationsResponseBody {
	s.NotificationConfigurationModels = v
	return s
}

func (s *DescribeNotificationConfigurationsResponseBody) SetRequestId(v string) *DescribeNotificationConfigurationsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels struct {
	// The Alibaba Cloud Resource Name (ARN) of the notification method. The following list describes the value formats of this parameter:
	//
	// *   If you use CloudMonitor as the notification method, the value format of this parameter is acs:ess:{region-id}:{account-id}:cloudmonitor.
	// *   If you use a Message Service (MNS) queue as the notification method, the value format of this parameter is acs:mns:{region-id}:{account-id}:queue/{queuename}.
	// *   If you use an MNS topic as the notification method, the value format of this parameter is acs:mns:{region-id}:{account-id}:topic/{topicname}.
	//
	// The variables in the preceding formats have the following meanings:
	//
	// *   region-id: the region ID of the scaling group.
	// *   account-id: the ID of the Alibaba Cloud account.
	// *   queuename: the name of the MNS queue.
	// *   topicname: the name of the MNS topic.
	NotificationArn *string `json:"NotificationArn,omitempty" xml:"NotificationArn,omitempty"`
	// The types of notifications for scaling activities and resource changes.
	//
	// *   AUTOSCALING:SCALE_OUT_SUCCESS: The scale-out event is successful.
	// *   AUTOSCALING:SCALE_IN_SUCCESS: The scale-in event is successful.
	// *   AUTOSCALING:SCALE_OUT_ERROR: The scale-out event fails.
	// *   AUTOSCALING:SCALE_IN_ERROR: The scale-in event fails.
	// *   AUTOSCALING:SCALE_REJECT: The scaling activity is rejected.
	// *   AUTOSCALING:SCALE_OUT_START: The scale-out event is started.
	// *   AUTOSCALING:SCALE_IN_START: The scale-in event is started.
	// *   AUTOSCALING:SCHEDULE_TASK_EXPIRING: Auto Scaling sends a notification when a scheduled task is about to expire.
	NotificationTypes []*string `json:"NotificationTypes,omitempty" xml:"NotificationTypes,omitempty" type:"Repeated"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels) String() string {
	return tea.Prettify(s)
}

func (s DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels) GoString() string {
	return s.String()
}

func (s *DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels) SetNotificationArn(v string) *DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels {
	s.NotificationArn = &v
	return s
}

func (s *DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels) SetNotificationTypes(v []*string) *DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels {
	s.NotificationTypes = v
	return s
}

func (s *DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels) SetScalingGroupId(v string) *DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels {
	s.ScalingGroupId = &v
	return s
}

type DescribeNotificationConfigurationsResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeNotificationConfigurationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeNotificationConfigurationsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeNotificationConfigurationsResponse) GoString() string {
	return s.String()
}

func (s *DescribeNotificationConfigurationsResponse) SetHeaders(v map[string]*string) *DescribeNotificationConfigurationsResponse {
	s.Headers = v
	return s
}

func (s *DescribeNotificationConfigurationsResponse) SetStatusCode(v int32) *DescribeNotificationConfigurationsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeNotificationConfigurationsResponse) SetBody(v *DescribeNotificationConfigurationsResponseBody) *DescribeNotificationConfigurationsResponse {
	s.Body = v
	return s
}

type DescribeNotificationTypesRequest struct {
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
}

func (s DescribeNotificationTypesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeNotificationTypesRequest) GoString() string {
	return s.String()
}

func (s *DescribeNotificationTypesRequest) SetOwnerId(v int64) *DescribeNotificationTypesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeNotificationTypesRequest) SetResourceOwnerAccount(v string) *DescribeNotificationTypesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

type DescribeNotificationTypesResponseBody struct {
	// The types of the notifications.
	//
	// *   AUTOSCALING:SCALE_OUT_SUCCESS: The scale-out activity succeeds.
	// *   AUTOSCALING:SCALE_IN_SUCCESS: The scale-in activity succeeds.
	// *   AUTOSCALING:SCALE_OUT_ERROR: The scale-out activity fails.
	// *   AUTOSCALING:SCALE_IN_ERROR: The scale-in activity fails.
	// *   AUTOSCALING:SCALE_REJECT: The request for scaling activities is rejected.
	// *   AUTOSCALING:SCALE_OUT_START: The scale-out activity starts.
	// *   AUTOSCALING:SCALE_IN_START: The scale-in activity starts.
	// *   AUTOSCALING:SCHEDULE_TASK_EXPIRING: Auto Scaling sends a notification when a scheduled task is about to expire.
	NotificationTypes []*string `json:"NotificationTypes,omitempty" xml:"NotificationTypes,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeNotificationTypesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeNotificationTypesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeNotificationTypesResponseBody) SetNotificationTypes(v []*string) *DescribeNotificationTypesResponseBody {
	s.NotificationTypes = v
	return s
}

func (s *DescribeNotificationTypesResponseBody) SetRequestId(v string) *DescribeNotificationTypesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeNotificationTypesResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeNotificationTypesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeNotificationTypesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeNotificationTypesResponse) GoString() string {
	return s.String()
}

func (s *DescribeNotificationTypesResponse) SetHeaders(v map[string]*string) *DescribeNotificationTypesResponse {
	s.Headers = v
	return s
}

func (s *DescribeNotificationTypesResponse) SetStatusCode(v int32) *DescribeNotificationTypesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeNotificationTypesResponse) SetBody(v *DescribeNotificationTypesResponseBody) *DescribeNotificationTypesResponse {
	s.Body = v
	return s
}

type DescribeRegionsRequest struct {
	// The language used for the returned value. Valid values:
	//
	// *   **zh-CN**: Chinese.
	// *   **en-US**: English.
	//
	// >  Default value: **zh-CN**.
	AcceptLanguage       *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeRegionsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsRequest) GoString() string {
	return s.String()
}

func (s *DescribeRegionsRequest) SetAcceptLanguage(v string) *DescribeRegionsRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DescribeRegionsRequest) SetOwnerId(v int64) *DescribeRegionsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeRegionsRequest) SetResourceOwnerAccount(v string) *DescribeRegionsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeRegionsRequest) SetResourceOwnerId(v int64) *DescribeRegionsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeRegionsResponseBody struct {
	// Details of the regions.
	Regions []*DescribeRegionsResponseBodyRegions `json:"Regions,omitempty" xml:"Regions,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeRegionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBody) SetRegions(v []*DescribeRegionsResponseBodyRegions) *DescribeRegionsResponseBody {
	s.Regions = v
	return s
}

func (s *DescribeRegionsResponseBody) SetRequestId(v string) *DescribeRegionsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeRegionsResponseBodyRegions struct {
	// Indicates whether the region supports scaling groups of the classic network type. Valid values:
	//
	// *   true
	// *   false
	ClassicUnavailable *bool `json:"ClassicUnavailable,omitempty" xml:"ClassicUnavailable,omitempty"`
	// The name of the region.
	LocalName *string `json:"LocalName,omitempty" xml:"LocalName,omitempty"`
	// The endpoint of the region.
	RegionEndpoint *string `json:"RegionEndpoint,omitempty" xml:"RegionEndpoint,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Indicates whether the region supports scaling groups of the virtual private cloud (VPC) type. Valid values:
	//
	// *   true: The region does not support scaling groups of the VPC type.
	// *   false: The region supports scaling groups of the VPC type.
	VpcUnavailable *bool `json:"VpcUnavailable,omitempty" xml:"VpcUnavailable,omitempty"`
}

func (s DescribeRegionsResponseBodyRegions) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponseBodyRegions) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBodyRegions) SetClassicUnavailable(v bool) *DescribeRegionsResponseBodyRegions {
	s.ClassicUnavailable = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegions) SetLocalName(v string) *DescribeRegionsResponseBodyRegions {
	s.LocalName = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegions) SetRegionEndpoint(v string) *DescribeRegionsResponseBodyRegions {
	s.RegionEndpoint = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegions) SetRegionId(v string) *DescribeRegionsResponseBodyRegions {
	s.RegionId = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegions) SetVpcUnavailable(v bool) *DescribeRegionsResponseBodyRegions {
	s.VpcUnavailable = &v
	return s
}

type DescribeRegionsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRegionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRegionsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponse) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponse) SetHeaders(v map[string]*string) *DescribeRegionsResponse {
	s.Headers = v
	return s
}

func (s *DescribeRegionsResponse) SetStatusCode(v int32) *DescribeRegionsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRegionsResponse) SetBody(v *DescribeRegionsResponseBody) *DescribeRegionsResponse {
	s.Body = v
	return s
}

type DescribeScalingActivitiesRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Pages start from page 1.
	//
	// Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: 50.
	//
	// Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the scaling group to which the scaling activity that you want to query belongs.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The IDs of the scaling activities that you want to query.
	//
	// > When you call this operation, you must specify one of the `ScalingGroupId` and `ScalingActivityId.N` parameters. Otherwise, an error is reported.
	ScalingActivityIds []*string `json:"ScalingActivityIds,omitempty" xml:"ScalingActivityIds,omitempty" type:"Repeated"`
	// The ID of the scaling group.
	//
	// > When you call this operation, you must specify one of the `ScalingGroupId` and `ScalingActivityId.N` parameters. Otherwise, an error is reported.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The status of the scaling activity. Valid values:
	//
	// *   Successful: The scaling activity is successful.
	// *   Warning: The scaling activity is partially successful.
	// *   Failed: The scaling activity failed.
	// *   InProgress: The scaling activity is in progress.
	// *   Rejected: The request to trigger the scaling activity is rejected.
	StatusCode *string `json:"StatusCode,omitempty" xml:"StatusCode,omitempty"`
}

func (s DescribeScalingActivitiesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingActivitiesRequest) GoString() string {
	return s.String()
}

func (s *DescribeScalingActivitiesRequest) SetOwnerAccount(v string) *DescribeScalingActivitiesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeScalingActivitiesRequest) SetOwnerId(v int64) *DescribeScalingActivitiesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeScalingActivitiesRequest) SetPageNumber(v int32) *DescribeScalingActivitiesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeScalingActivitiesRequest) SetPageSize(v int32) *DescribeScalingActivitiesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeScalingActivitiesRequest) SetRegionId(v string) *DescribeScalingActivitiesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeScalingActivitiesRequest) SetResourceOwnerAccount(v string) *DescribeScalingActivitiesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeScalingActivitiesRequest) SetResourceOwnerId(v int64) *DescribeScalingActivitiesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeScalingActivitiesRequest) SetScalingActivityIds(v []*string) *DescribeScalingActivitiesRequest {
	s.ScalingActivityIds = v
	return s
}

func (s *DescribeScalingActivitiesRequest) SetScalingGroupId(v string) *DescribeScalingActivitiesRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeScalingActivitiesRequest) SetStatusCode(v string) *DescribeScalingActivitiesRequest {
	s.StatusCode = &v
	return s
}

type DescribeScalingActivitiesResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Details of the scaling activities.
	ScalingActivities []*DescribeScalingActivitiesResponseBodyScalingActivities `json:"ScalingActivities,omitempty" xml:"ScalingActivities,omitempty" type:"Repeated"`
	// The total number of scaling activities.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeScalingActivitiesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingActivitiesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeScalingActivitiesResponseBody) SetPageNumber(v int32) *DescribeScalingActivitiesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBody) SetPageSize(v int32) *DescribeScalingActivitiesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBody) SetRequestId(v string) *DescribeScalingActivitiesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBody) SetScalingActivities(v []*DescribeScalingActivitiesResponseBodyScalingActivities) *DescribeScalingActivitiesResponseBody {
	s.ScalingActivities = v
	return s
}

func (s *DescribeScalingActivitiesResponseBody) SetTotalCount(v int32) *DescribeScalingActivitiesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeScalingActivitiesResponseBodyScalingActivities struct {
	// The total number of instances that were manually added to the scaling group after the scaling activity was complete.
	AttachedCapacity *string `json:"AttachedCapacity,omitempty" xml:"AttachedCapacity,omitempty"`
	// The total number of instances that were created by Auto Scaling after the scaling activity was complete.
	AutoCreatedCapacity *string `json:"AutoCreatedCapacity,omitempty" xml:"AutoCreatedCapacity,omitempty"`
	// The reason why the scaling activity was triggered.
	Cause *string `json:"Cause,omitempty" xml:"Cause,omitempty"`
	// The number of instances that were created during the scaling activity.
	CreatedCapacity *int32 `json:"CreatedCapacity,omitempty" xml:"CreatedCapacity,omitempty"`
	// The instances that were created during the scaling activity.
	CreatedInstances []*string `json:"CreatedInstances,omitempty" xml:"CreatedInstances,omitempty" type:"Repeated"`
	// The description of the scaling activity.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The number of instances that were released during the scaling activity.
	DestroyedCapacity *int32 `json:"DestroyedCapacity,omitempty" xml:"DestroyedCapacity,omitempty"`
	// The instances that were released during the scaling activity.
	DestroyedInstances []*string `json:"DestroyedInstances,omitempty" xml:"DestroyedInstances,omitempty" type:"Repeated"`
	// Details of the scaling activity.
	Detail *string `json:"Detail,omitempty" xml:"Detail,omitempty"`
	// The time when the scaling activity was complete.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The error code that is returned when the scaling activity failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message that is returned when the scaling activity failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The execution progress of the scaling activity.
	Progress *int32 `json:"Progress,omitempty" xml:"Progress,omitempty"`
	// The ID of the scaling activity.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// If the scaling activity is a scale-out activity, the value of this parameter indicates the number of instances that were created during the scaling activity or the number of instances that were started from Economical Mode.
	//
	// If the scaling activity is a scale-in activity, the value of this parameter indicates the number of instances that were deleted during the scaling activity or the number of instances that were stopped in Economical Mode.
	ScalingInstanceNumber *int32 `json:"ScalingInstanceNumber,omitempty" xml:"ScalingInstanceNumber,omitempty"`
	// The time when the scaling activity started.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The number of instances that were started from Economical Mode during the scaling activity.
	StartedCapacity *int32 `json:"StartedCapacity,omitempty" xml:"StartedCapacity,omitempty"`
	// The instances that were started from Economical Mode during the scaling activity.
	StartedInstances []*string `json:"StartedInstances,omitempty" xml:"StartedInstances,omitempty" type:"Repeated"`
	// The status of the scaling activity. Valid values:
	//
	// *   Successful: The scaling activity is successful.
	// *   Warning: The scaling activity is partially successful.
	// *   Failed: The scaling activity failed.
	// *   InProgress: The scaling activity is in progress.
	// *   Rejected: The request to trigger the scaling activity is rejected.
	StatusCode *string `json:"StatusCode,omitempty" xml:"StatusCode,omitempty"`
	// The status message of the scaling activity.
	StatusMessage *string `json:"StatusMessage,omitempty" xml:"StatusMessage,omitempty"`
	// The number of instances that were stopped in Economical Mode during the scaling activity.
	StoppedCapacity *int32 `json:"StoppedCapacity,omitempty" xml:"StoppedCapacity,omitempty"`
	// The instances that were stopped in Economical Mode during the scaling activity.
	StoppedInstances []*string `json:"StoppedInstances,omitempty" xml:"StoppedInstances,omitempty" type:"Repeated"`
	// The total number of instances in the scaling group after the scaling activity was complete.
	TotalCapacity *string `json:"TotalCapacity,omitempty" xml:"TotalCapacity,omitempty"`
}

func (s DescribeScalingActivitiesResponseBodyScalingActivities) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingActivitiesResponseBodyScalingActivities) GoString() string {
	return s.String()
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetAttachedCapacity(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.AttachedCapacity = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetAutoCreatedCapacity(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.AutoCreatedCapacity = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetCause(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.Cause = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetCreatedCapacity(v int32) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.CreatedCapacity = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetCreatedInstances(v []*string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.CreatedInstances = v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetDescription(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.Description = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetDestroyedCapacity(v int32) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.DestroyedCapacity = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetDestroyedInstances(v []*string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.DestroyedInstances = v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetDetail(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.Detail = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetEndTime(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.EndTime = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetErrorCode(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.ErrorCode = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetErrorMessage(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.ErrorMessage = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetProgress(v int32) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.Progress = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetScalingActivityId(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.ScalingActivityId = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetScalingGroupId(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetScalingInstanceNumber(v int32) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.ScalingInstanceNumber = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetStartTime(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.StartTime = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetStartedCapacity(v int32) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.StartedCapacity = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetStartedInstances(v []*string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.StartedInstances = v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetStatusCode(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.StatusCode = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetStatusMessage(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.StatusMessage = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetStoppedCapacity(v int32) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.StoppedCapacity = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetStoppedInstances(v []*string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.StoppedInstances = v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetTotalCapacity(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.TotalCapacity = &v
	return s
}

type DescribeScalingActivitiesResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeScalingActivitiesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeScalingActivitiesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingActivitiesResponse) GoString() string {
	return s.String()
}

func (s *DescribeScalingActivitiesResponse) SetHeaders(v map[string]*string) *DescribeScalingActivitiesResponse {
	s.Headers = v
	return s
}

func (s *DescribeScalingActivitiesResponse) SetStatusCode(v int32) *DescribeScalingActivitiesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeScalingActivitiesResponse) SetBody(v *DescribeScalingActivitiesResponseBody) *DescribeScalingActivitiesResponse {
	s.Body = v
	return s
}

type DescribeScalingActivityDetailRequest struct {
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the scaling activity.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s DescribeScalingActivityDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingActivityDetailRequest) GoString() string {
	return s.String()
}

func (s *DescribeScalingActivityDetailRequest) SetOwnerId(v int64) *DescribeScalingActivityDetailRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeScalingActivityDetailRequest) SetResourceOwnerAccount(v string) *DescribeScalingActivityDetailRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeScalingActivityDetailRequest) SetResourceOwnerId(v int64) *DescribeScalingActivityDetailRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeScalingActivityDetailRequest) SetScalingActivityId(v string) *DescribeScalingActivityDetailRequest {
	s.ScalingActivityId = &v
	return s
}

type DescribeScalingActivityDetailResponseBody struct {
	// The details about the event.
	Detail *string `json:"Detail,omitempty" xml:"Detail,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the scaling activity.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s DescribeScalingActivityDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingActivityDetailResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeScalingActivityDetailResponseBody) SetDetail(v string) *DescribeScalingActivityDetailResponseBody {
	s.Detail = &v
	return s
}

func (s *DescribeScalingActivityDetailResponseBody) SetRequestId(v string) *DescribeScalingActivityDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeScalingActivityDetailResponseBody) SetScalingActivityId(v string) *DescribeScalingActivityDetailResponseBody {
	s.ScalingActivityId = &v
	return s
}

type DescribeScalingActivityDetailResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeScalingActivityDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeScalingActivityDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingActivityDetailResponse) GoString() string {
	return s.String()
}

func (s *DescribeScalingActivityDetailResponse) SetHeaders(v map[string]*string) *DescribeScalingActivityDetailResponse {
	s.Headers = v
	return s
}

func (s *DescribeScalingActivityDetailResponse) SetStatusCode(v int32) *DescribeScalingActivityDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeScalingActivityDetailResponse) SetBody(v *DescribeScalingActivityDetailResponseBody) *DescribeScalingActivityDetailResponse {
	s.Body = v
	return s
}

type DescribeScalingConfigurationsRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Pages start from page 1.
	//
	// Default value: 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: 50.
	//
	// Default value: 10
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the scaling group to which the scaling configuration that you want to query belongs.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The IDs of the scaling configurations that you want to query.
	//
	// The IDs of active and inactive scaling configurations are displayed in the query results. You can differentiate between active and inactive scaling configurations based on the value of the `LifecycleState` parameter.
	ScalingConfigurationIds []*string `json:"ScalingConfigurationIds,omitempty" xml:"ScalingConfigurationIds,omitempty" type:"Repeated"`
	// The names of the scaling configurations that you want to query.
	//
	// The names of inactive scaling configurations are not displayed in the query results, and no error is reported.
	ScalingConfigurationNames []*string `json:"ScalingConfigurationNames,omitempty" xml:"ScalingConfigurationNames,omitempty" type:"Repeated"`
	// The ID of the scaling group. You can use the ID to query all scaling configurations in the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DescribeScalingConfigurationsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingConfigurationsRequest) GoString() string {
	return s.String()
}

func (s *DescribeScalingConfigurationsRequest) SetOwnerAccount(v string) *DescribeScalingConfigurationsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeScalingConfigurationsRequest) SetOwnerId(v int64) *DescribeScalingConfigurationsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeScalingConfigurationsRequest) SetPageNumber(v int32) *DescribeScalingConfigurationsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeScalingConfigurationsRequest) SetPageSize(v int32) *DescribeScalingConfigurationsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeScalingConfigurationsRequest) SetRegionId(v string) *DescribeScalingConfigurationsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeScalingConfigurationsRequest) SetResourceOwnerAccount(v string) *DescribeScalingConfigurationsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeScalingConfigurationsRequest) SetResourceOwnerId(v int64) *DescribeScalingConfigurationsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeScalingConfigurationsRequest) SetScalingConfigurationIds(v []*string) *DescribeScalingConfigurationsRequest {
	s.ScalingConfigurationIds = v
	return s
}

func (s *DescribeScalingConfigurationsRequest) SetScalingConfigurationNames(v []*string) *DescribeScalingConfigurationsRequest {
	s.ScalingConfigurationNames = v
	return s
}

func (s *DescribeScalingConfigurationsRequest) SetScalingGroupId(v string) *DescribeScalingConfigurationsRequest {
	s.ScalingGroupId = &v
	return s
}

type DescribeScalingConfigurationsResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Details of the scaling configurations.
	ScalingConfigurations []*DescribeScalingConfigurationsResponseBodyScalingConfigurations `json:"ScalingConfigurations,omitempty" xml:"ScalingConfigurations,omitempty" type:"Repeated"`
	// The total number of scaling configurations.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeScalingConfigurationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingConfigurationsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeScalingConfigurationsResponseBody) SetPageNumber(v int32) *DescribeScalingConfigurationsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBody) SetPageSize(v int32) *DescribeScalingConfigurationsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBody) SetRequestId(v string) *DescribeScalingConfigurationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBody) SetScalingConfigurations(v []*DescribeScalingConfigurationsResponseBodyScalingConfigurations) *DescribeScalingConfigurationsResponseBody {
	s.ScalingConfigurations = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBody) SetTotalCount(v int32) *DescribeScalingConfigurationsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeScalingConfigurationsResponseBodyScalingConfigurations struct {
	// Indicates whether the instance on the dedicated host is associated with the dedicated host. Valid values:
	//
	// *   default: The instance is not associated with the dedicated host. If you start an instance that was stopped in Economical Mode and the original dedicated host has insufficient resources, the instance is automatically deployed to another dedicated host in the automatic deployment resource pool.
	// *   host: The instance is associated with the dedicated host. If you start an instance that was stopped in Economical Mode, the instance remains on the original dedicated host. If the original dedicated host has insufficient resources, the instance cannot be started.
	Affinity *string `json:"Affinity,omitempty" xml:"Affinity,omitempty"`
	// The number of vCPUs.
	//
	// You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. If you specify the Cpu and Memory parameters, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.
	//
	// > You can specify CPU and memory specifications to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The time when the scaling configuration was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The performance mode of the burstable instance. Valid values:
	//
	// *   Standard: standard mode. For more information, see the "Standard mode" section in the [Burstable instances](~~59977~~) topic.
	// *   Unlimited: unlimited mode. For more information, see the "Unlimited mode" section in the [Burstable instances](~~59977~~) topic.
	CreditSpecification *string `json:"CreditSpecification,omitempty" xml:"CreditSpecification,omitempty"`
	// Details of the data disks.
	DataDisks []*DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks `json:"DataDisks,omitempty" xml:"DataDisks,omitempty" type:"Repeated"`
	// The ID of the dedicated host on which the ECS instance is created. Preemptible instances cannot be created on dedicated hosts. If you specify the DedicatedHostId parameter, the SpotStrategy and SpotPriceLimit parameters are ignored.
	//
	// You can call the DescribeDedicatedHosts operation to query dedicated host IDs.
	DedicatedHostId    *string `json:"DedicatedHostId,omitempty" xml:"DedicatedHostId,omitempty"`
	DeletionProtection *bool   `json:"DeletionProtection,omitempty" xml:"DeletionProtection,omitempty"`
	// The ID of the deployment set to which the Elastic Compute Service (ECS) instance belongs.
	DeploymentSetId *string `json:"DeploymentSetId,omitempty" xml:"DeploymentSetId,omitempty"`
	// The hostname of the ECS instance.
	HostName *string `json:"HostName,omitempty" xml:"HostName,omitempty"`
	// The ID of the Elastic High Performance Computing (E-HPC) cluster to which the ECS instance belongs.
	HpcClusterId *string `json:"HpcClusterId,omitempty" xml:"HpcClusterId,omitempty"`
	// The name of the image family. If you specify this parameter, the latest custom images that are available in the specified image family are returned. You can use the images to create instances. If the ImageId parameter is specified, you cannot specify the ImageFamily parameter.
	ImageFamily *string `json:"ImageFamily,omitempty" xml:"ImageFamily,omitempty"`
	// The ID of the image that is used by Auto Scaling to create instances.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The name of the image file.
	ImageName *string `json:"ImageName,omitempty" xml:"ImageName,omitempty"`
	// ECS实例是否使用ecs-user用户登录。可能值：
	//
	// - true：是。
	// - false：否。
	ImageOptionsLoginAsNonRoot *bool `json:"ImageOptionsLoginAsNonRoot,omitempty" xml:"ImageOptionsLoginAsNonRoot,omitempty"`
	// The source of the image. Valid values:
	//
	// *   system: public images provided by Alibaba Cloud
	// *   self: custom images that you create
	// *   others: shared images from other Alibaba Cloud accounts or community images published by other Alibaba Cloud accounts
	// *   marketplace: images that are available in Alibaba Cloud Marketplace
	ImageOwnerAlias *string `json:"ImageOwnerAlias,omitempty" xml:"ImageOwnerAlias,omitempty"`
	// The description of the ECS instance.
	InstanceDescription *string `json:"InstanceDescription,omitempty" xml:"InstanceDescription,omitempty"`
	// The generation of the ECS instance.
	InstanceGeneration *string `json:"InstanceGeneration,omitempty" xml:"InstanceGeneration,omitempty"`
	// The name of the ECS instance.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// Details of the intelligent configuration settings, which determines the range of instance types that meet the specified criteria.
	InstancePatternInfos []*DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos `json:"InstancePatternInfos,omitempty" xml:"InstancePatternInfos,omitempty" type:"Repeated"`
	// The instance type of the ECS instance.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// Details of the ECS instance types.
	InstanceTypes []*string `json:"InstanceTypes,omitempty" xml:"InstanceTypes,omitempty" type:"Repeated"`
	// The billing method for network usage. Valid values:
	//
	// *   PayByBandwidth: You are charged for the maximum available bandwidth that is specified by the InternetMaxBandwidthOut parameter.
	// *   PayByTraffic: You are charged for the actual data transfer. The InternetMaxBandwidthOut parameter specifies only the maximum available bandwidth.
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The maximum inbound public bandwidth. Unit: Mbit/s. Valid values: 1 to 200.
	InternetMaxBandwidthIn *int32 `json:"InternetMaxBandwidthIn,omitempty" xml:"InternetMaxBandwidthIn,omitempty"`
	// The maximum outbound public bandwidth. Unit: Mbit/s. Valid values:
	//
	// *   0 to 100 if you set the InternetChargeType parameter to PayByBandwidth. If you leave this parameter empty, this parameter is automatically set to 0.
	// *   0 to 100 if you set the InternetChargeType parameter to PayByTraffic. If you leave this parameter empty, an error is reported.
	InternetMaxBandwidthOut *int32 `json:"InternetMaxBandwidthOut,omitempty" xml:"InternetMaxBandwidthOut,omitempty"`
	// Indicates whether the instance is I/O optimized. Valid values:
	//
	// *   none: The instance is not I/O optimized.
	// *   optimized: The instance is I/O optimized.
	IoOptimized *string `json:"IoOptimized,omitempty" xml:"IoOptimized,omitempty"`
	// The number of randomly generated IPv6 addresses that are allocated to the elastic network interface (ENI).
	Ipv6AddressCount *int32 `json:"Ipv6AddressCount,omitempty" xml:"Ipv6AddressCount,omitempty"`
	// The name of the key pair that is used to log on to the ECS instance.
	KeyPairName *string `json:"KeyPairName,omitempty" xml:"KeyPairName,omitempty"`
	// The status of the scaling configuration in the scaling group. Valid values:
	//
	// *   Active: The scaling configuration is active in the scaling group. Auto Scaling uses the active scaling configuration to automatically create ECS instances.
	// *   Inactive: The scaling configuration is inactive in the scaling group. Auto Scaling does not use inactive scaling configurations to automatically create ECS instances. Inactive scaling configurations are retained in the scaling group.
	LifecycleState *string `json:"LifecycleState,omitempty" xml:"LifecycleState,omitempty"`
	// The weight of the ECS instance as a backend server. Valid values: 1 to 100.
	LoadBalancerWeight *int32 `json:"LoadBalancerWeight,omitempty" xml:"LoadBalancerWeight,omitempty"`
	// The memory size. Unit: GiB.
	//
	// You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. If you specify the Cpu and Memory parameters, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.
	//
	// > You can specify CPU and memory specifications to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
	Memory *int32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// Indicates whether the password preconfigured in the image is used.
	PasswordInherit                  *bool   `json:"PasswordInherit,omitempty" xml:"PasswordInherit,omitempty"`
	PrivatePoolOptions_id            *string `json:"PrivatePoolOptions.Id,omitempty" xml:"PrivatePoolOptions.Id,omitempty"`
	PrivatePoolOptions_matchCriteria *string `json:"PrivatePoolOptions.MatchCriteria,omitempty" xml:"PrivatePoolOptions.MatchCriteria,omitempty"`
	// The name of the RAM role that is associated with the ECS instance. The name is provided and maintained by Resource Access Management (RAM). You can call the ListRoles operation to query the available RAM roles.
	RamRoleName *string `json:"RamRoleName,omitempty" xml:"RamRoleName,omitempty"`
	// The ID of the resource group to which the ECS instance belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of the scaling configuration.
	ScalingConfigurationId *string `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
	// The name of the scaling configuration.
	ScalingConfigurationName *string `json:"ScalingConfigurationName,omitempty" xml:"ScalingConfigurationName,omitempty"`
	// The ID of the scaling group to which the scaling configuration belongs.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// > This parameter is in invitational preview and is unavailable.
	SchedulerOptions *DescribeScalingConfigurationsResponseBodyScalingConfigurationsSchedulerOptions `json:"SchedulerOptions,omitempty" xml:"SchedulerOptions,omitempty" type:"Struct"`
	// Indicates whether security hardening is enabled. Valid values:
	//
	// *   Active: Security hardening is enabled. This value is available only to public images.
	// *   Deactive: Security hardening is disabled. This value is available to all types of images.
	SecurityEnhancementStrategy *string `json:"SecurityEnhancementStrategy,omitempty" xml:"SecurityEnhancementStrategy,omitempty"`
	// The ID of the security group with which the ECS instance is associated. ECS instances that are associated with the same security group can access each other.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// The IDs of the security groups with which the ECS instance is associated. ECS instances that are associated with the same security group can access each other.
	SecurityGroupIds []*string `json:"SecurityGroupIds,omitempty" xml:"SecurityGroupIds,omitempty" type:"Repeated"`
	// The protection period of the preemptible instance. Unit: hours.
	SpotDuration *int32 `json:"SpotDuration,omitempty" xml:"SpotDuration,omitempty"`
	// The interruption mode of the preemptible instance.
	SpotInterruptionBehavior *string `json:"SpotInterruptionBehavior,omitempty" xml:"SpotInterruptionBehavior,omitempty"`
	// Details of the preemptible instances.
	SpotPriceLimits []*DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits `json:"SpotPriceLimits,omitempty" xml:"SpotPriceLimits,omitempty" type:"Repeated"`
	// The preemption policy that is applied to pay-as-you-go instances and preemptible instances. Valid values:
	//
	// *   NoSpot: The instance is created as a pay-as-you-go instance.
	// *   SpotWithPriceLimit: The instance is a preemptible instance that has a user-defined maximum hourly price.
	// *   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.
	SpotStrategy              *string `json:"SpotStrategy,omitempty" xml:"SpotStrategy,omitempty"`
	StorageSetId              *string `json:"StorageSetId,omitempty" xml:"StorageSetId,omitempty"`
	StorageSetPartitionNumber *int32  `json:"StorageSetPartitionNumber,omitempty" xml:"StorageSetPartitionNumber,omitempty"`
	// The ID of the automatic snapshot policy that is applied to the system disk.
	SystemDiskAutoSnapshotPolicyId *string `json:"SystemDiskAutoSnapshotPolicyId,omitempty" xml:"SystemDiskAutoSnapshotPolicyId,omitempty"`
	// Indicates whether the burst feature is enabled for the system disk. Valid values:
	//
	// *   true
	// *   false
	//
	// > This parameter is available only if you set the SystemDisk.Category parameter to cloud_auto.
	SystemDiskBurstingEnabled *bool `json:"SystemDiskBurstingEnabled,omitempty" xml:"SystemDiskBurstingEnabled,omitempty"`
	// The categories of the system disks. The values are sorted based on their priorities. The first value has the highest priority. If Auto Scaling cannot create instances by using the disk that has the highest priority, Auto Scaling creates instances by using the disk that has the next highest priority. Valid values:
	//
	// *   cloud: basic disk
	// *   cloud_efficiency: ultra disk
	// *   cloud_ssd: standard SSD
	// *   cloud_essd: ESSD
	SystemDiskCategories []*string `json:"SystemDiskCategories,omitempty" xml:"SystemDiskCategories,omitempty" type:"Repeated"`
	// The category of the system disk. Valid values:
	//
	// *   cloud: basic disk
	// *   cloud_efficiency: ultra disk
	// *   cloud_ssd: standard SSD
	// *   ephemeral_ssd: local standard SSD
	// *   cloud_essd: enhanced SSD (ESSD)
	// *   cloud_auto: ESSD AutoPL disk
	SystemDiskCategory *string `json:"SystemDiskCategory,omitempty" xml:"SystemDiskCategory,omitempty"`
	// The description of the system disk.
	SystemDiskDescription *string `json:"SystemDiskDescription,omitempty" xml:"SystemDiskDescription,omitempty"`
	// The algorithm that is used to encrypt the system disk. Valid values:
	//
	// *   AES-256
	// *   SM4-128
	SystemDiskEncryptAlgorithm *string `json:"SystemDiskEncryptAlgorithm,omitempty" xml:"SystemDiskEncryptAlgorithm,omitempty"`
	// Indicates whether the system disk is encrypted. Valid values:
	//
	// *   true
	// *   false
	SystemDiskEncrypted *bool `json:"SystemDiskEncrypted,omitempty" xml:"SystemDiskEncrypted,omitempty"`
	// The ID of the KMS key that is used to encrypt the system disk.
	SystemDiskKMSKeyId *string `json:"SystemDiskKMSKeyId,omitempty" xml:"SystemDiskKMSKeyId,omitempty"`
	// The name of the system disk.
	SystemDiskName *string `json:"SystemDiskName,omitempty" xml:"SystemDiskName,omitempty"`
	// The performance level (PL) of the system disk of the ESSD category.
	SystemDiskPerformanceLevel *string `json:"SystemDiskPerformanceLevel,omitempty" xml:"SystemDiskPerformanceLevel,omitempty"`
	// The provisioned IOPS for the system disk.
	//
	// > IOPS measures the number of read and write operations that an EBS device can process per second.
	SystemDiskProvisionedIops *int64 `json:"SystemDiskProvisionedIops,omitempty" xml:"SystemDiskProvisionedIops,omitempty"`
	// The size of the system disk. Unit: GiB.
	SystemDiskSize *int32 `json:"SystemDiskSize,omitempty" xml:"SystemDiskSize,omitempty"`
	// Details of the tags.
	Tags []*DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// Indicates whether the instance is created on a dedicated host. Valid values:
	//
	// *   default: The instance is created on a non-dedicated host.
	// *   host: The instance is created on a dedicated host. If you do not specify the DedicatedHostId parameter, Alibaba Cloud selects a dedicated host for the instance.
	//
	// Default value: default.
	Tenancy *string `json:"Tenancy,omitempty" xml:"Tenancy,omitempty"`
	// The user data of the ECS instance.
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The weight of the instance type. The weight of an instance type indicates the capacity of an instance of the specified instance type in the scaling group. A higher weight indicates that a smaller number of instances of the specified instance type are required to meet the expected capacity requirement.
	WeightedCapacities []*int32 `json:"WeightedCapacities,omitempty" xml:"WeightedCapacities,omitempty" type:"Repeated"`
	// The zone ID of the ECS instance. You can call the DescribeZones operation to query the most recent zone list.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurations) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurations) GoString() string {
	return s.String()
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetAffinity(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.Affinity = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetCpu(v int32) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.Cpu = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetCreationTime(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.CreationTime = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetCreditSpecification(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.CreditSpecification = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetDataDisks(v []*DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.DataDisks = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetDedicatedHostId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.DedicatedHostId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetDeletionProtection(v bool) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.DeletionProtection = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetDeploymentSetId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.DeploymentSetId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetHostName(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.HostName = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetHpcClusterId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.HpcClusterId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetImageFamily(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.ImageFamily = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetImageId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.ImageId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetImageName(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.ImageName = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetImageOptionsLoginAsNonRoot(v bool) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.ImageOptionsLoginAsNonRoot = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetImageOwnerAlias(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.ImageOwnerAlias = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetInstanceDescription(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.InstanceDescription = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetInstanceGeneration(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.InstanceGeneration = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetInstanceName(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.InstanceName = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetInstancePatternInfos(v []*DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.InstancePatternInfos = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetInstanceType(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.InstanceType = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetInstanceTypes(v []*string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.InstanceTypes = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetInternetChargeType(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.InternetChargeType = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetInternetMaxBandwidthIn(v int32) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.InternetMaxBandwidthIn = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetInternetMaxBandwidthOut(v int32) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.InternetMaxBandwidthOut = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetIoOptimized(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.IoOptimized = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetIpv6AddressCount(v int32) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.Ipv6AddressCount = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetKeyPairName(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.KeyPairName = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetLifecycleState(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.LifecycleState = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetLoadBalancerWeight(v int32) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.LoadBalancerWeight = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetMemory(v int32) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.Memory = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetPasswordInherit(v bool) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.PasswordInherit = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetPrivatePoolOptions_id(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.PrivatePoolOptions_id = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetPrivatePoolOptions_matchCriteria(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.PrivatePoolOptions_matchCriteria = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetRamRoleName(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.RamRoleName = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetResourceGroupId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetScalingConfigurationId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.ScalingConfigurationId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetScalingConfigurationName(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.ScalingConfigurationName = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetScalingGroupId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSchedulerOptions(v *DescribeScalingConfigurationsResponseBodyScalingConfigurationsSchedulerOptions) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SchedulerOptions = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSecurityEnhancementStrategy(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SecurityEnhancementStrategy = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSecurityGroupId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SecurityGroupId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSecurityGroupIds(v []*string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SecurityGroupIds = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSpotDuration(v int32) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SpotDuration = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSpotInterruptionBehavior(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SpotInterruptionBehavior = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSpotPriceLimits(v []*DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SpotPriceLimits = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSpotStrategy(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SpotStrategy = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetStorageSetId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.StorageSetId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetStorageSetPartitionNumber(v int32) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.StorageSetPartitionNumber = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskAutoSnapshotPolicyId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskAutoSnapshotPolicyId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskBurstingEnabled(v bool) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskBurstingEnabled = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskCategories(v []*string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskCategories = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskCategory(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskCategory = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskDescription(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskDescription = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskEncryptAlgorithm(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskEncryptAlgorithm = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskEncrypted(v bool) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskEncrypted = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskKMSKeyId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskKMSKeyId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskName(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskName = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskPerformanceLevel(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskPerformanceLevel = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskProvisionedIops(v int64) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskProvisionedIops = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskSize(v int32) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskSize = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetTags(v []*DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.Tags = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetTenancy(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.Tenancy = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetUserData(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.UserData = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetWeightedCapacities(v []*int32) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.WeightedCapacities = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetZoneId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.ZoneId = &v
	return s
}

type DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks struct {
	// The ID of the automatic snapshot policy that is applied to the data disk.
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// Indicates whether the burst feature is enabled for the data disk. Valid values:
	//
	// *   true
	// *   false
	//
	// > This parameter is available only if you set the `DataDisk.Category` parameter to `cloud_auto`.
	//
	// For more information, see the [ESSD AutoPL disks](~~368372~~) topic.
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The categories of the data disks. The values are sorted based on their priorities. The first value has the highest priority. If Auto Scaling cannot create instances by using the disk that has the highest priority, Auto Scaling creates instances by using the disk that has the next highest priority. Valid values:
	//
	// *   cloud: basic disk. The DeleteWithInstance parameter of a basic disk that is created together with the instance is set to true.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   cloud_essd: ESSD.
	Categories []*string `json:"Categories,omitempty" xml:"Categories,omitempty" type:"Repeated"`
	// The category of the data disk. Valid values:
	//
	// *   cloud: basic disk. The DeleteWithInstance parameter of a basic disk that is created together with the instance is set to true.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   ephemeral_ssd: local standard SSD.
	// *   cloud_essd: ESSD.
	// *   cloud_auto: ESSD AutoPL disk.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// Indicates whether the data disk is released if the instance to which the data disk is attached is released. Valid values:
	//
	// *   true
	// *   false
	DeleteWithInstance *bool `json:"DeleteWithInstance,omitempty" xml:"DeleteWithInstance,omitempty"`
	// The description of the data disk.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The mount target of the data disk.
	Device *string `json:"Device,omitempty" xml:"Device,omitempty"`
	// The name of the data disk.
	DiskName *string `json:"DiskName,omitempty" xml:"DiskName,omitempty"`
	// Indicates whether the data disk is encrypted. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	Encrypted *string `json:"Encrypted,omitempty" xml:"Encrypted,omitempty"`
	// The ID of the Key Management Service (KMS) key that is used to encrypt the data disk.
	KMSKeyId *string `json:"KMSKeyId,omitempty" xml:"KMSKeyId,omitempty"`
	// The PL of the data disk of the ESSD category.
	PerformanceLevel *string `json:"PerformanceLevel,omitempty" xml:"PerformanceLevel,omitempty"`
	// The provisioned input/output operations per second (IOPS) for the data disk.
	//
	// > IOPS measures the number of read and write operations that an Elastic Block Storage (EBS) device can process per second.
	ProvisionedIops *int64 `json:"ProvisionedIops,omitempty" xml:"ProvisionedIops,omitempty"`
	// The size of the data disk. Unit: GiB.
	//
	// *   Valid values if you set the Category parameter to cloud: 5 to 2000.
	// *   Valid values if you set the Category parameter to cloud_efficiency: 20 to 32768.
	// *   Valid values if you set the Category parameter to cloud_ssd: 20 to 32768.
	// *   Valid values if you set the Category parameter to cloud_essd: 20 to 32768.
	// *   Valid values if you set the Category parameter to ephemeral_ssd: 5 to 800.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The ID of the snapshot that is used to create the data disk.
	SnapshotId *string `json:"SnapshotId,omitempty" xml:"SnapshotId,omitempty"`
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) GoString() string {
	return s.String()
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetAutoSnapshotPolicyId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetBurstingEnabled(v bool) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.BurstingEnabled = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetCategories(v []*string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.Categories = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetCategory(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.Category = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetDeleteWithInstance(v bool) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.DeleteWithInstance = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetDescription(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.Description = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetDevice(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.Device = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetDiskName(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.DiskName = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetEncrypted(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.Encrypted = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetKMSKeyId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.KMSKeyId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetPerformanceLevel(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.PerformanceLevel = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetProvisionedIops(v int64) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.ProvisionedIops = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetSize(v int32) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.Size = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetSnapshotId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.SnapshotId = &v
	return s
}

type DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos struct {
	// The architectures of the instance types. Valid values:
	//
	// *   X86: x86 architecture.
	// *   Heterogeneous: heterogeneous architecture, such as GPUs and FPGAs.
	// *   BareMetal: ECS Bare Metal Instance architecture.
	// *   Arm: ARM architecture.
	// *   SuperComputeCluster: Super Computing Cluster architecture.
	Architectures []*string `json:"Architectures,omitempty" xml:"Architectures,omitempty" type:"Repeated"`
	// Indicates whether burstable instance types are included. Valid values:
	//
	// *   Exclude: Burstable instance types are not included.
	// *   Include: Burstable instance types are included.
	// *   Required: Only burstable instance types are included.
	BurstablePerformance *string `json:"BurstablePerformance,omitempty" xml:"BurstablePerformance,omitempty"`
	// The number of vCPUs of the instance type.
	Cores *int32 `json:"Cores,omitempty" xml:"Cores,omitempty"`
	// The instance types that are excluded. You can use wildcard characters such as an asterisk (\*) to exclude an instance type or an instance family. Examples:
	//
	// *   ecs.c6.large: The ecs.c6.large instance type is excluded.
	// *   ecs.c6.\*: The c6 instance family is excluded.
	ExcludedInstanceTypes []*string `json:"ExcludedInstanceTypes,omitempty" xml:"ExcludedInstanceTypes,omitempty" type:"Repeated"`
	// The level of the instance family.
	//
	// *   EntryLevel: shared instance type. Instances of this level are cost-effective, but do not provide stable computing performance. Instances of this level are suitable for scenarios in which the CPU utilization is low. For more information, see [Shared instance families](~~108489~~).
	// *   EnterpriseLevel: Instances of this level provide stable performance and dedicated resources, and are suitable for scenarios in which high stability is required. For more information, see [Overview of instance families](~~25378~~).
	// *   CreditEntryLevel: This value is available only for burstable instances. CPU credits are used to ensure computing performance. Instances of this level are suitable for scenarios in which the CPU utilization is low but may fluctuate in specific cases. For more information, see [Overview](~~59977~~) of burstable instances
	InstanceFamilyLevel *string `json:"InstanceFamilyLevel,omitempty" xml:"InstanceFamilyLevel,omitempty"`
	// The maximum hourly price for pay-as-you-go instances or preemptible instances.
	MaxPrice *float32 `json:"MaxPrice,omitempty" xml:"MaxPrice,omitempty"`
	// The memory size of the instance type. Unit: GiB.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos) GoString() string {
	return s.String()
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos) SetArchitectures(v []*string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos {
	s.Architectures = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos) SetBurstablePerformance(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos {
	s.BurstablePerformance = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos) SetCores(v int32) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos {
	s.Cores = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos) SetExcludedInstanceTypes(v []*string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos {
	s.ExcludedInstanceTypes = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos) SetInstanceFamilyLevel(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos {
	s.InstanceFamilyLevel = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos) SetMaxPrice(v float32) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos {
	s.MaxPrice = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos) SetMemory(v float32) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos {
	s.Memory = &v
	return s
}

type DescribeScalingConfigurationsResponseBodyScalingConfigurationsSchedulerOptions struct {
	// > This parameter is in invitational preview and is unavailable.
	ManagedPrivateSpaceId *string `json:"ManagedPrivateSpaceId,omitempty" xml:"ManagedPrivateSpaceId,omitempty"`
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurationsSchedulerOptions) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurationsSchedulerOptions) GoString() string {
	return s.String()
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsSchedulerOptions) SetManagedPrivateSpaceId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsSchedulerOptions {
	s.ManagedPrivateSpaceId = &v
	return s
}

type DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits struct {
	// The instance type of the preemptible instance.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The price limit of the preemptible instance.
	PriceLimit *float32 `json:"PriceLimit,omitempty" xml:"PriceLimit,omitempty"`
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits) GoString() string {
	return s.String()
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits) SetInstanceType(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits {
	s.InstanceType = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits) SetPriceLimit(v float32) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits {
	s.PriceLimit = &v
	return s
}

type DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags struct {
	// The key of tag N. Valid values of N: 1 to 20.
	//
	// The tag key cannot be an empty string. The tag key can be up to 128 characters in length, and cannot start with `acs:` or `aliyun`. The tag key cannot contain `http://` or `https://`.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of tag N. Valid values of N: 1 to 20.
	//
	// The tag value can be an empty string. The tag value can be up to 128 characters in length, and cannot start with `acs:`. The tag value cannot contain `http://` or `https://`.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags) GoString() string {
	return s.String()
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags) SetKey(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags {
	s.Key = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags) SetValue(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags {
	s.Value = &v
	return s
}

type DescribeScalingConfigurationsResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeScalingConfigurationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeScalingConfigurationsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingConfigurationsResponse) GoString() string {
	return s.String()
}

func (s *DescribeScalingConfigurationsResponse) SetHeaders(v map[string]*string) *DescribeScalingConfigurationsResponse {
	s.Headers = v
	return s
}

func (s *DescribeScalingConfigurationsResponse) SetStatusCode(v int32) *DescribeScalingConfigurationsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeScalingConfigurationsResponse) SetBody(v *DescribeScalingConfigurationsResponseBody) *DescribeScalingConfigurationsResponse {
	s.Body = v
	return s
}

type DescribeScalingGroupsRequest struct {
	GroupType            *string                             `json:"GroupType,omitempty" xml:"GroupType,omitempty"`
	OwnerAccount         *string                             `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64                              `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	PageNumber           *int32                              `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize             *int32                              `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RegionId             *string                             `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId      *string                             `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                             `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                              `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	ScalingGroupIds      []*string                           `json:"ScalingGroupIds,omitempty" xml:"ScalingGroupIds,omitempty" type:"Repeated"`
	ScalingGroupName     *string                             `json:"ScalingGroupName,omitempty" xml:"ScalingGroupName,omitempty"`
	ScalingGroupNames    []*string                           `json:"ScalingGroupNames,omitempty" xml:"ScalingGroupNames,omitempty" type:"Repeated"`
	Tags                 []*DescribeScalingGroupsRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s DescribeScalingGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingGroupsRequest) GoString() string {
	return s.String()
}

func (s *DescribeScalingGroupsRequest) SetGroupType(v string) *DescribeScalingGroupsRequest {
	s.GroupType = &v
	return s
}

func (s *DescribeScalingGroupsRequest) SetOwnerAccount(v string) *DescribeScalingGroupsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeScalingGroupsRequest) SetOwnerId(v int64) *DescribeScalingGroupsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeScalingGroupsRequest) SetPageNumber(v int32) *DescribeScalingGroupsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeScalingGroupsRequest) SetPageSize(v int32) *DescribeScalingGroupsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeScalingGroupsRequest) SetRegionId(v string) *DescribeScalingGroupsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeScalingGroupsRequest) SetResourceGroupId(v string) *DescribeScalingGroupsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeScalingGroupsRequest) SetResourceOwnerAccount(v string) *DescribeScalingGroupsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeScalingGroupsRequest) SetResourceOwnerId(v int64) *DescribeScalingGroupsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeScalingGroupsRequest) SetScalingGroupIds(v []*string) *DescribeScalingGroupsRequest {
	s.ScalingGroupIds = v
	return s
}

func (s *DescribeScalingGroupsRequest) SetScalingGroupName(v string) *DescribeScalingGroupsRequest {
	s.ScalingGroupName = &v
	return s
}

func (s *DescribeScalingGroupsRequest) SetScalingGroupNames(v []*string) *DescribeScalingGroupsRequest {
	s.ScalingGroupNames = v
	return s
}

func (s *DescribeScalingGroupsRequest) SetTags(v []*DescribeScalingGroupsRequestTags) *DescribeScalingGroupsRequest {
	s.Tags = v
	return s
}

type DescribeScalingGroupsRequestTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeScalingGroupsRequestTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingGroupsRequestTags) GoString() string {
	return s.String()
}

func (s *DescribeScalingGroupsRequestTags) SetKey(v string) *DescribeScalingGroupsRequestTags {
	s.Key = &v
	return s
}

func (s *DescribeScalingGroupsRequestTags) SetValue(v string) *DescribeScalingGroupsRequestTags {
	s.Value = &v
	return s
}

type DescribeScalingGroupsResponseBody struct {
	PageNumber    *int32                                            `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize      *int32                                            `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RequestId     *string                                           `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	ScalingGroups []*DescribeScalingGroupsResponseBodyScalingGroups `json:"ScalingGroups,omitempty" xml:"ScalingGroups,omitempty" type:"Repeated"`
	TotalCount    *int32                                            `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeScalingGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeScalingGroupsResponseBody) SetPageNumber(v int32) *DescribeScalingGroupsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeScalingGroupsResponseBody) SetPageSize(v int32) *DescribeScalingGroupsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeScalingGroupsResponseBody) SetRequestId(v string) *DescribeScalingGroupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBody) SetScalingGroups(v []*DescribeScalingGroupsResponseBodyScalingGroups) *DescribeScalingGroupsResponseBody {
	s.ScalingGroups = v
	return s
}

func (s *DescribeScalingGroupsResponseBody) SetTotalCount(v int32) *DescribeScalingGroupsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeScalingGroupsResponseBodyScalingGroups struct {
	ActiveCapacity                      *int32                                                                   `json:"ActiveCapacity,omitempty" xml:"ActiveCapacity,omitempty"`
	ActiveScalingConfigurationId        *string                                                                  `json:"ActiveScalingConfigurationId,omitempty" xml:"ActiveScalingConfigurationId,omitempty"`
	AlbServerGroups                     []*DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups         `json:"AlbServerGroups,omitempty" xml:"AlbServerGroups,omitempty" type:"Repeated"`
	AllocationStrategy                  *string                                                                  `json:"AllocationStrategy,omitempty" xml:"AllocationStrategy,omitempty"`
	AzBalance                           *bool                                                                    `json:"AzBalance,omitempty" xml:"AzBalance,omitempty"`
	CompensateWithOnDemand              *bool                                                                    `json:"CompensateWithOnDemand,omitempty" xml:"CompensateWithOnDemand,omitempty"`
	CreationTime                        *string                                                                  `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	CurrentHostName                     *string                                                                  `json:"CurrentHostName,omitempty" xml:"CurrentHostName,omitempty"`
	CustomPolicyARN                     *string                                                                  `json:"CustomPolicyARN,omitempty" xml:"CustomPolicyARN,omitempty"`
	DBInstanceIds                       []*string                                                                `json:"DBInstanceIds,omitempty" xml:"DBInstanceIds,omitempty" type:"Repeated"`
	DefaultCooldown                     *int32                                                                   `json:"DefaultCooldown,omitempty" xml:"DefaultCooldown,omitempty"`
	DesiredCapacity                     *int32                                                                   `json:"DesiredCapacity,omitempty" xml:"DesiredCapacity,omitempty"`
	EnableDesiredCapacity               *bool                                                                    `json:"EnableDesiredCapacity,omitempty" xml:"EnableDesiredCapacity,omitempty"`
	GroupDeletionProtection             *bool                                                                    `json:"GroupDeletionProtection,omitempty" xml:"GroupDeletionProtection,omitempty"`
	GroupType                           *string                                                                  `json:"GroupType,omitempty" xml:"GroupType,omitempty"`
	HealthCheckType                     *string                                                                  `json:"HealthCheckType,omitempty" xml:"HealthCheckType,omitempty"`
	InitCapacity                        *int32                                                                   `json:"InitCapacity,omitempty" xml:"InitCapacity,omitempty"`
	IsElasticStrengthInAlarm            *bool                                                                    `json:"IsElasticStrengthInAlarm,omitempty" xml:"IsElasticStrengthInAlarm,omitempty"`
	LaunchTemplateId                    *string                                                                  `json:"LaunchTemplateId,omitempty" xml:"LaunchTemplateId,omitempty"`
	LaunchTemplateOverrides             []*DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides `json:"LaunchTemplateOverrides,omitempty" xml:"LaunchTemplateOverrides,omitempty" type:"Repeated"`
	LaunchTemplateVersion               *string                                                                  `json:"LaunchTemplateVersion,omitempty" xml:"LaunchTemplateVersion,omitempty"`
	LifecycleState                      *string                                                                  `json:"LifecycleState,omitempty" xml:"LifecycleState,omitempty"`
	LoadBalancerConfigs                 []*DescribeScalingGroupsResponseBodyScalingGroupsLoadBalancerConfigs     `json:"LoadBalancerConfigs,omitempty" xml:"LoadBalancerConfigs,omitempty" type:"Repeated"`
	LoadBalancerIds                     []*string                                                                `json:"LoadBalancerIds,omitempty" xml:"LoadBalancerIds,omitempty" type:"Repeated"`
	MaxInstanceLifetime                 *int32                                                                   `json:"MaxInstanceLifetime,omitempty" xml:"MaxInstanceLifetime,omitempty"`
	MaxSize                             *int32                                                                   `json:"MaxSize,omitempty" xml:"MaxSize,omitempty"`
	MinSize                             *int32                                                                   `json:"MinSize,omitempty" xml:"MinSize,omitempty"`
	ModificationTime                    *string                                                                  `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	MonitorGroupId                      *string                                                                  `json:"MonitorGroupId,omitempty" xml:"MonitorGroupId,omitempty"`
	MultiAZPolicy                       *string                                                                  `json:"MultiAZPolicy,omitempty" xml:"MultiAZPolicy,omitempty"`
	OnDemandBaseCapacity                *int32                                                                   `json:"OnDemandBaseCapacity,omitempty" xml:"OnDemandBaseCapacity,omitempty"`
	OnDemandPercentageAboveBaseCapacity *int32                                                                   `json:"OnDemandPercentageAboveBaseCapacity,omitempty" xml:"OnDemandPercentageAboveBaseCapacity,omitempty"`
	PendingCapacity                     *int32                                                                   `json:"PendingCapacity,omitempty" xml:"PendingCapacity,omitempty"`
	PendingWaitCapacity                 *int32                                                                   `json:"PendingWaitCapacity,omitempty" xml:"PendingWaitCapacity,omitempty"`
	ProtectedCapacity                   *int32                                                                   `json:"ProtectedCapacity,omitempty" xml:"ProtectedCapacity,omitempty"`
	RegionId                            *string                                                                  `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	RemovalPolicies                     []*string                                                                `json:"RemovalPolicies,omitempty" xml:"RemovalPolicies,omitempty" type:"Repeated"`
	RemovingCapacity                    *int32                                                                   `json:"RemovingCapacity,omitempty" xml:"RemovingCapacity,omitempty"`
	RemovingWaitCapacity                *int32                                                                   `json:"RemovingWaitCapacity,omitempty" xml:"RemovingWaitCapacity,omitempty"`
	ResourceGroupId                     *string                                                                  `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ScalingGroupId                      *string                                                                  `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	ScalingGroupName                    *string                                                                  `json:"ScalingGroupName,omitempty" xml:"ScalingGroupName,omitempty"`
	ScalingPolicy                       *string                                                                  `json:"ScalingPolicy,omitempty" xml:"ScalingPolicy,omitempty"`
	ServerGroups                        []*DescribeScalingGroupsResponseBodyScalingGroupsServerGroups            `json:"ServerGroups,omitempty" xml:"ServerGroups,omitempty" type:"Repeated"`
	SpotAllocationStrategy              *string                                                                  `json:"SpotAllocationStrategy,omitempty" xml:"SpotAllocationStrategy,omitempty"`
	SpotInstancePools                   *int32                                                                   `json:"SpotInstancePools,omitempty" xml:"SpotInstancePools,omitempty"`
	SpotInstanceRemedy                  *bool                                                                    `json:"SpotInstanceRemedy,omitempty" xml:"SpotInstanceRemedy,omitempty"`
	StandbyCapacity                     *int32                                                                   `json:"StandbyCapacity,omitempty" xml:"StandbyCapacity,omitempty"`
	StoppedCapacity                     *int32                                                                   `json:"StoppedCapacity,omitempty" xml:"StoppedCapacity,omitempty"`
	SuspendedProcesses                  []*string                                                                `json:"SuspendedProcesses,omitempty" xml:"SuspendedProcesses,omitempty" type:"Repeated"`
	SystemSuspended                     *bool                                                                    `json:"SystemSuspended,omitempty" xml:"SystemSuspended,omitempty"`
	Tags                                []*DescribeScalingGroupsResponseBodyScalingGroupsTags                    `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	TotalCapacity                       *int32                                                                   `json:"TotalCapacity,omitempty" xml:"TotalCapacity,omitempty"`
	TotalInstanceCount                  *int32                                                                   `json:"TotalInstanceCount,omitempty" xml:"TotalInstanceCount,omitempty"`
	VServerGroups                       []*DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups           `json:"VServerGroups,omitempty" xml:"VServerGroups,omitempty" type:"Repeated"`
	VSwitchId                           *string                                                                  `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	VSwitchIds                          []*string                                                                `json:"VSwitchIds,omitempty" xml:"VSwitchIds,omitempty" type:"Repeated"`
	VpcId                               *string                                                                  `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeScalingGroupsResponseBodyScalingGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingGroupsResponseBodyScalingGroups) GoString() string {
	return s.String()
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetActiveCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.ActiveCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetActiveScalingConfigurationId(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.ActiveScalingConfigurationId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetAlbServerGroups(v []*DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.AlbServerGroups = v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetAllocationStrategy(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.AllocationStrategy = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetAzBalance(v bool) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.AzBalance = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetCompensateWithOnDemand(v bool) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.CompensateWithOnDemand = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetCreationTime(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.CreationTime = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetCurrentHostName(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.CurrentHostName = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetCustomPolicyARN(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.CustomPolicyARN = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetDBInstanceIds(v []*string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.DBInstanceIds = v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetDefaultCooldown(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.DefaultCooldown = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetDesiredCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.DesiredCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetEnableDesiredCapacity(v bool) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.EnableDesiredCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetGroupDeletionProtection(v bool) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.GroupDeletionProtection = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetGroupType(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.GroupType = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetHealthCheckType(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.HealthCheckType = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetInitCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.InitCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetIsElasticStrengthInAlarm(v bool) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.IsElasticStrengthInAlarm = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetLaunchTemplateId(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.LaunchTemplateId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetLaunchTemplateOverrides(v []*DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.LaunchTemplateOverrides = v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetLaunchTemplateVersion(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.LaunchTemplateVersion = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetLifecycleState(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.LifecycleState = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetLoadBalancerConfigs(v []*DescribeScalingGroupsResponseBodyScalingGroupsLoadBalancerConfigs) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.LoadBalancerConfigs = v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetLoadBalancerIds(v []*string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.LoadBalancerIds = v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetMaxInstanceLifetime(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.MaxInstanceLifetime = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetMaxSize(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.MaxSize = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetMinSize(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.MinSize = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetModificationTime(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.ModificationTime = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetMonitorGroupId(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.MonitorGroupId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetMultiAZPolicy(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.MultiAZPolicy = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetOnDemandBaseCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.OnDemandBaseCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetOnDemandPercentageAboveBaseCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.OnDemandPercentageAboveBaseCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetPendingCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.PendingCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetPendingWaitCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.PendingWaitCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetProtectedCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.ProtectedCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetRegionId(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.RegionId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetRemovalPolicies(v []*string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.RemovalPolicies = v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetRemovingCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.RemovingCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetRemovingWaitCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.RemovingWaitCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetResourceGroupId(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetScalingGroupId(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetScalingGroupName(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.ScalingGroupName = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetScalingPolicy(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.ScalingPolicy = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetServerGroups(v []*DescribeScalingGroupsResponseBodyScalingGroupsServerGroups) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.ServerGroups = v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetSpotAllocationStrategy(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.SpotAllocationStrategy = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetSpotInstancePools(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.SpotInstancePools = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetSpotInstanceRemedy(v bool) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.SpotInstanceRemedy = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetStandbyCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.StandbyCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetStoppedCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.StoppedCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetSuspendedProcesses(v []*string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.SuspendedProcesses = v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetSystemSuspended(v bool) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.SystemSuspended = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetTags(v []*DescribeScalingGroupsResponseBodyScalingGroupsTags) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.Tags = v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetTotalCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.TotalCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetTotalInstanceCount(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.TotalInstanceCount = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetVServerGroups(v []*DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.VServerGroups = v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetVSwitchId(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.VSwitchId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetVSwitchIds(v []*string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.VSwitchIds = v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetVpcId(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.VpcId = &v
	return s
}

type DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups struct {
	AlbServerGroupId *string `json:"AlbServerGroupId,omitempty" xml:"AlbServerGroupId,omitempty"`
	Port             *int32  `json:"Port,omitempty" xml:"Port,omitempty"`
	Weight           *int32  `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups) GoString() string {
	return s.String()
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups) SetAlbServerGroupId(v string) *DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups {
	s.AlbServerGroupId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups) SetPort(v int32) *DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups {
	s.Port = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups) SetWeight(v int32) *DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups {
	s.Weight = &v
	return s
}

type DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides struct {
	InstanceType     *string  `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	SpotPriceLimit   *float32 `json:"SpotPriceLimit,omitempty" xml:"SpotPriceLimit,omitempty"`
	WeightedCapacity *int32   `json:"WeightedCapacity,omitempty" xml:"WeightedCapacity,omitempty"`
}

func (s DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides) GoString() string {
	return s.String()
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides) SetInstanceType(v string) *DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides {
	s.InstanceType = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides) SetSpotPriceLimit(v float32) *DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides {
	s.SpotPriceLimit = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides) SetWeightedCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides {
	s.WeightedCapacity = &v
	return s
}

type DescribeScalingGroupsResponseBodyScalingGroupsLoadBalancerConfigs struct {
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	Weight         *int32  `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeScalingGroupsResponseBodyScalingGroupsLoadBalancerConfigs) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingGroupsResponseBodyScalingGroupsLoadBalancerConfigs) GoString() string {
	return s.String()
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsLoadBalancerConfigs) SetLoadBalancerId(v string) *DescribeScalingGroupsResponseBodyScalingGroupsLoadBalancerConfigs {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsLoadBalancerConfigs) SetWeight(v int32) *DescribeScalingGroupsResponseBodyScalingGroupsLoadBalancerConfigs {
	s.Weight = &v
	return s
}

type DescribeScalingGroupsResponseBodyScalingGroupsServerGroups struct {
	Port          *int32  `json:"Port,omitempty" xml:"Port,omitempty"`
	ServerGroupId *string `json:"ServerGroupId,omitempty" xml:"ServerGroupId,omitempty"`
	Type          *string `json:"Type,omitempty" xml:"Type,omitempty"`
	Weight        *int32  `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeScalingGroupsResponseBodyScalingGroupsServerGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingGroupsResponseBodyScalingGroupsServerGroups) GoString() string {
	return s.String()
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsServerGroups) SetPort(v int32) *DescribeScalingGroupsResponseBodyScalingGroupsServerGroups {
	s.Port = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsServerGroups) SetServerGroupId(v string) *DescribeScalingGroupsResponseBodyScalingGroupsServerGroups {
	s.ServerGroupId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsServerGroups) SetType(v string) *DescribeScalingGroupsResponseBodyScalingGroupsServerGroups {
	s.Type = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsServerGroups) SetWeight(v int32) *DescribeScalingGroupsResponseBodyScalingGroupsServerGroups {
	s.Weight = &v
	return s
}

type DescribeScalingGroupsResponseBodyScalingGroupsTags struct {
	Propagate *bool   `json:"Propagate,omitempty" xml:"Propagate,omitempty"`
	TagKey    *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	TagValue  *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s DescribeScalingGroupsResponseBodyScalingGroupsTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingGroupsResponseBodyScalingGroupsTags) GoString() string {
	return s.String()
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsTags) SetPropagate(v bool) *DescribeScalingGroupsResponseBodyScalingGroupsTags {
	s.Propagate = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsTags) SetTagKey(v string) *DescribeScalingGroupsResponseBodyScalingGroupsTags {
	s.TagKey = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsTags) SetTagValue(v string) *DescribeScalingGroupsResponseBodyScalingGroupsTags {
	s.TagValue = &v
	return s
}

type DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups struct {
	LoadBalancerId         *string                                                                              `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	VServerGroupAttributes []*DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes `json:"VServerGroupAttributes,omitempty" xml:"VServerGroupAttributes,omitempty" type:"Repeated"`
}

func (s DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups) GoString() string {
	return s.String()
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups) SetLoadBalancerId(v string) *DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups) SetVServerGroupAttributes(v []*DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes) *DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups {
	s.VServerGroupAttributes = v
	return s
}

type DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes struct {
	Port           *int32  `json:"Port,omitempty" xml:"Port,omitempty"`
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	Weight         *int32  `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes) GoString() string {
	return s.String()
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes) SetPort(v int32) *DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes {
	s.Port = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes) SetVServerGroupId(v string) *DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes {
	s.VServerGroupId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes) SetWeight(v int32) *DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes {
	s.Weight = &v
	return s
}

type DescribeScalingGroupsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeScalingGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeScalingGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingGroupsResponse) GoString() string {
	return s.String()
}

func (s *DescribeScalingGroupsResponse) SetHeaders(v map[string]*string) *DescribeScalingGroupsResponse {
	s.Headers = v
	return s
}

func (s *DescribeScalingGroupsResponse) SetStatusCode(v int32) *DescribeScalingGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeScalingGroupsResponse) SetBody(v *DescribeScalingGroupsResponseBody) *DescribeScalingGroupsResponse {
	s.Body = v
	return s
}

type DescribeScalingInstancesRequest struct {
	CreationType           *string   `json:"CreationType,omitempty" xml:"CreationType,omitempty"`
	CreationTypes          []*string `json:"CreationTypes,omitempty" xml:"CreationTypes,omitempty" type:"Repeated"`
	HealthStatus           *string   `json:"HealthStatus,omitempty" xml:"HealthStatus,omitempty"`
	InstanceIds            []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	LifecycleState         *string   `json:"LifecycleState,omitempty" xml:"LifecycleState,omitempty"`
	LifecycleStates        []*string `json:"LifecycleStates,omitempty" xml:"LifecycleStates,omitempty" type:"Repeated"`
	OwnerAccount           *string   `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	PageNumber             *int32    `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize               *int32    `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RegionId               *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount   *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId        *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	ScalingActivityId      *string   `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
	ScalingConfigurationId *string   `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
	ScalingGroupId         *string   `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DescribeScalingInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingInstancesRequest) GoString() string {
	return s.String()
}

func (s *DescribeScalingInstancesRequest) SetCreationType(v string) *DescribeScalingInstancesRequest {
	s.CreationType = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetCreationTypes(v []*string) *DescribeScalingInstancesRequest {
	s.CreationTypes = v
	return s
}

func (s *DescribeScalingInstancesRequest) SetHealthStatus(v string) *DescribeScalingInstancesRequest {
	s.HealthStatus = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetInstanceIds(v []*string) *DescribeScalingInstancesRequest {
	s.InstanceIds = v
	return s
}

func (s *DescribeScalingInstancesRequest) SetLifecycleState(v string) *DescribeScalingInstancesRequest {
	s.LifecycleState = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetLifecycleStates(v []*string) *DescribeScalingInstancesRequest {
	s.LifecycleStates = v
	return s
}

func (s *DescribeScalingInstancesRequest) SetOwnerAccount(v string) *DescribeScalingInstancesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetOwnerId(v int64) *DescribeScalingInstancesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetPageNumber(v int32) *DescribeScalingInstancesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetPageSize(v int32) *DescribeScalingInstancesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetRegionId(v string) *DescribeScalingInstancesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetResourceOwnerAccount(v string) *DescribeScalingInstancesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetResourceOwnerId(v int64) *DescribeScalingInstancesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetScalingActivityId(v string) *DescribeScalingInstancesRequest {
	s.ScalingActivityId = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetScalingConfigurationId(v string) *DescribeScalingInstancesRequest {
	s.ScalingConfigurationId = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetScalingGroupId(v string) *DescribeScalingInstancesRequest {
	s.ScalingGroupId = &v
	return s
}

type DescribeScalingInstancesResponseBody struct {
	PageNumber       *int32                                                  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize         *int32                                                  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RequestId        *string                                                 `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	ScalingInstances []*DescribeScalingInstancesResponseBodyScalingInstances `json:"ScalingInstances,omitempty" xml:"ScalingInstances,omitempty" type:"Repeated"`
	TotalCount       *int32                                                  `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	TotalSpotCount   *int32                                                  `json:"TotalSpotCount,omitempty" xml:"TotalSpotCount,omitempty"`
}

func (s DescribeScalingInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeScalingInstancesResponseBody) SetPageNumber(v int32) *DescribeScalingInstancesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeScalingInstancesResponseBody) SetPageSize(v int32) *DescribeScalingInstancesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeScalingInstancesResponseBody) SetRequestId(v string) *DescribeScalingInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeScalingInstancesResponseBody) SetScalingInstances(v []*DescribeScalingInstancesResponseBodyScalingInstances) *DescribeScalingInstancesResponseBody {
	s.ScalingInstances = v
	return s
}

func (s *DescribeScalingInstancesResponseBody) SetTotalCount(v int32) *DescribeScalingInstancesResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeScalingInstancesResponseBody) SetTotalSpotCount(v int32) *DescribeScalingInstancesResponseBody {
	s.TotalSpotCount = &v
	return s
}

type DescribeScalingInstancesResponseBodyScalingInstances struct {
	CreatedTime            *string `json:"CreatedTime,omitempty" xml:"CreatedTime,omitempty"`
	CreationTime           *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	CreationType           *string `json:"CreationType,omitempty" xml:"CreationType,omitempty"`
	Entrusted              *bool   `json:"Entrusted,omitempty" xml:"Entrusted,omitempty"`
	HealthStatus           *string `json:"HealthStatus,omitempty" xml:"HealthStatus,omitempty"`
	InstanceId             *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	LaunchTemplateId       *string `json:"LaunchTemplateId,omitempty" xml:"LaunchTemplateId,omitempty"`
	LaunchTemplateVersion  *string `json:"LaunchTemplateVersion,omitempty" xml:"LaunchTemplateVersion,omitempty"`
	LifecycleState         *string `json:"LifecycleState,omitempty" xml:"LifecycleState,omitempty"`
	LoadBalancerWeight     *int32  `json:"LoadBalancerWeight,omitempty" xml:"LoadBalancerWeight,omitempty"`
	PrivateIpAddress       *string `json:"PrivateIpAddress,omitempty" xml:"PrivateIpAddress,omitempty"`
	ScalingActivityId      *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
	ScalingConfigurationId *string `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
	ScalingGroupId         *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	ScalingInstanceId      *string `json:"ScalingInstanceId,omitempty" xml:"ScalingInstanceId,omitempty"`
	SpotStrategy           *string `json:"SpotStrategy,omitempty" xml:"SpotStrategy,omitempty"`
	WarmupState            *string `json:"WarmupState,omitempty" xml:"WarmupState,omitempty"`
	WeightedCapacity       *int32  `json:"WeightedCapacity,omitempty" xml:"WeightedCapacity,omitempty"`
	ZoneId                 *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeScalingInstancesResponseBodyScalingInstances) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingInstancesResponseBodyScalingInstances) GoString() string {
	return s.String()
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetCreatedTime(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.CreatedTime = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetCreationTime(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.CreationTime = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetCreationType(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.CreationType = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetEntrusted(v bool) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.Entrusted = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetHealthStatus(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.HealthStatus = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetInstanceId(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.InstanceId = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetLaunchTemplateId(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.LaunchTemplateId = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetLaunchTemplateVersion(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.LaunchTemplateVersion = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetLifecycleState(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.LifecycleState = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetLoadBalancerWeight(v int32) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.LoadBalancerWeight = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetPrivateIpAddress(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.PrivateIpAddress = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetScalingActivityId(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.ScalingActivityId = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetScalingConfigurationId(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.ScalingConfigurationId = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetScalingGroupId(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetScalingInstanceId(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.ScalingInstanceId = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetSpotStrategy(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.SpotStrategy = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetWarmupState(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.WarmupState = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetWeightedCapacity(v int32) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.WeightedCapacity = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetZoneId(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.ZoneId = &v
	return s
}

type DescribeScalingInstancesResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeScalingInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeScalingInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingInstancesResponse) GoString() string {
	return s.String()
}

func (s *DescribeScalingInstancesResponse) SetHeaders(v map[string]*string) *DescribeScalingInstancesResponse {
	s.Headers = v
	return s
}

func (s *DescribeScalingInstancesResponse) SetStatusCode(v int32) *DescribeScalingInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeScalingInstancesResponse) SetBody(v *DescribeScalingInstancesResponseBody) *DescribeScalingInstancesResponse {
	s.Body = v
	return s
}

type DescribeScalingRulesRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Pages start from page 1.
	//
	// Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: 50.
	//
	// Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the scaling group to which the scaling rules that you want to query belong.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The unique identifiers of the scaling rules that you want to query.
	ScalingRuleAris []*string `json:"ScalingRuleAris,omitempty" xml:"ScalingRuleAris,omitempty" type:"Repeated"`
	// The IDs of the scaling rules that you want to query.
	ScalingRuleIds []*string `json:"ScalingRuleIds,omitempty" xml:"ScalingRuleIds,omitempty" type:"Repeated"`
	// The names of the scaling rules that you want to query.
	ScalingRuleNames []*string `json:"ScalingRuleNames,omitempty" xml:"ScalingRuleNames,omitempty" type:"Repeated"`
	// The type of the scaling rule. Valid values:
	//
	// *   SimpleScalingRule: adjusts the number of ECS instances based on the values of the AdjustmentType and AdjustmentValue parameters.
	// *   TargetTrackingScalingRule: calculates the number of ECS instances that need to be scaled in a dynamic manner and maintains the value of a predefined metric close to the value of the TargetValue parameter.
	// *   StepScalingRule: scales ECS instances in steps based on the specified thresholds and metric values.
	// *   PredictiveScalingRule: uses machine learning to analyze historical monitoring data of the scaling group and predicts the future values of metrics. In addition, Auto Scaling automatically creates scheduled tasks to adjust the boundary values for the scaling group.
	ScalingRuleType *string `json:"ScalingRuleType,omitempty" xml:"ScalingRuleType,omitempty"`
	// Specifies whether to return CloudMonitor event-triggered tasks associated with scaling rules. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	ShowAlarmRules *bool `json:"ShowAlarmRules,omitempty" xml:"ShowAlarmRules,omitempty"`
}

func (s DescribeScalingRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingRulesRequest) GoString() string {
	return s.String()
}

func (s *DescribeScalingRulesRequest) SetOwnerAccount(v string) *DescribeScalingRulesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeScalingRulesRequest) SetOwnerId(v int64) *DescribeScalingRulesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeScalingRulesRequest) SetPageNumber(v int32) *DescribeScalingRulesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeScalingRulesRequest) SetPageSize(v int32) *DescribeScalingRulesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeScalingRulesRequest) SetRegionId(v string) *DescribeScalingRulesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeScalingRulesRequest) SetResourceOwnerAccount(v string) *DescribeScalingRulesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeScalingRulesRequest) SetResourceOwnerId(v int64) *DescribeScalingRulesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeScalingRulesRequest) SetScalingGroupId(v string) *DescribeScalingRulesRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeScalingRulesRequest) SetScalingRuleAris(v []*string) *DescribeScalingRulesRequest {
	s.ScalingRuleAris = v
	return s
}

func (s *DescribeScalingRulesRequest) SetScalingRuleIds(v []*string) *DescribeScalingRulesRequest {
	s.ScalingRuleIds = v
	return s
}

func (s *DescribeScalingRulesRequest) SetScalingRuleNames(v []*string) *DescribeScalingRulesRequest {
	s.ScalingRuleNames = v
	return s
}

func (s *DescribeScalingRulesRequest) SetScalingRuleType(v string) *DescribeScalingRulesRequest {
	s.ScalingRuleType = &v
	return s
}

func (s *DescribeScalingRulesRequest) SetShowAlarmRules(v bool) *DescribeScalingRulesRequest {
	s.ShowAlarmRules = &v
	return s
}

type DescribeScalingRulesResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Details of the scaling rules.
	ScalingRules []*DescribeScalingRulesResponseBodyScalingRules `json:"ScalingRules,omitempty" xml:"ScalingRules,omitempty" type:"Repeated"`
	// The total number of scaling rules.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeScalingRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingRulesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeScalingRulesResponseBody) SetPageNumber(v int32) *DescribeScalingRulesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeScalingRulesResponseBody) SetPageSize(v int32) *DescribeScalingRulesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeScalingRulesResponseBody) SetRequestId(v string) *DescribeScalingRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeScalingRulesResponseBody) SetScalingRules(v []*DescribeScalingRulesResponseBodyScalingRules) *DescribeScalingRulesResponseBody {
	s.ScalingRules = v
	return s
}

func (s *DescribeScalingRulesResponseBody) SetTotalCount(v int32) *DescribeScalingRulesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeScalingRulesResponseBodyScalingRules struct {
	// The scaling mode of the scaling rule. Valid values:
	//
	// *   QuantityChangeInCapacity: adds the specified number of ECS instances to or removes the specified number of ECS instances from the scaling group.
	// *   PercentChangeInCapacity: adds the specified percentage of ECS instances to or removes the specified percentage of ECS instances from the scaling group.
	// *   TotalCapacity: adjusts the number of ECS instances in the scaling group to the specified number.
	AdjustmentType *string `json:"AdjustmentType,omitempty" xml:"AdjustmentType,omitempty"`
	// The adjustment value that is specified in the scaling rule.
	AdjustmentValue *int32 `json:"AdjustmentValue,omitempty" xml:"AdjustmentValue,omitempty"`
	// 监控项维度信息值，适用于目标追踪规则，当监控项需额外维度信息时设置，例如LoadBalancerRealServerAverageQps监控项需指定rulePool维度信息。
	AlarmDimensions []*DescribeScalingRulesResponseBodyScalingRulesAlarmDimensions `json:"AlarmDimensions,omitempty" xml:"AlarmDimensions,omitempty" type:"Repeated"`
	// The event-triggered tasks that are associated with the scaling rule. Event-triggered tasks that are associated with the scaling rule are returned only if you set the ShowAlarmRules parameter to true. Otherwise, an empty list is returned.
	Alarms []*DescribeScalingRulesResponseBodyScalingRulesAlarms `json:"Alarms,omitempty" xml:"Alarms,omitempty" type:"Repeated"`
	// The cooldown time of the scaling rule. This parameter is available only if you set the ScalingRuleType parameter to SimpleScalingRule. Valid values: 0 to 86400. Unit: seconds.
	Cooldown *int32 `json:"Cooldown,omitempty" xml:"Cooldown,omitempty"`
	// Specifies whether to disable scale-in. This parameter is available only if you set the ScalingRuleType parameter to TargetTrackingScalingRule. Valid values:
	//
	// *   true
	// *   false
	DisableScaleIn *bool `json:"DisableScaleIn,omitempty" xml:"DisableScaleIn,omitempty"`
	// The warmup period of the ECS instance.
	EstimatedInstanceWarmup *int32 `json:"EstimatedInstanceWarmup,omitempty" xml:"EstimatedInstanceWarmup,omitempty"`
	// The maximum number of ECS instances in the scaling group. You must specify the InitialMaxSize and PredictiveValueBehavior parameters.
	InitialMaxSize *int32 `json:"InitialMaxSize,omitempty" xml:"InitialMaxSize,omitempty"`
	// The maximum number of ECS instances in the scaling group.
	MaxSize *int32 `json:"MaxSize,omitempty" xml:"MaxSize,omitempty"`
	// The name of the metric of the event-triggered task that is associated with the scaling rule.
	MetricName *string `json:"MetricName,omitempty" xml:"MetricName,omitempty"`
	// The minimum number of instances that must be scaled when the AdjustmentType parameter is set to PercentChangeInCapacity. This parameter takes effect only if you set the ScalingRuleType parameter to SimpleScalingRule or StepScalingRule.
	MinAdjustmentMagnitude *int32 `json:"MinAdjustmentMagnitude,omitempty" xml:"MinAdjustmentMagnitude,omitempty"`
	// The minimum number of ECS instances in the scaling group.
	MinSize *int32 `json:"MinSize,omitempty" xml:"MinSize,omitempty"`
	// The mode of the predictive scaling rule. Valid values:
	//
	// *   PredictAndScale: produces predictions and creates prediction tasks.
	// *   PredictOnly: produces predictions but does not create prediction tasks.
	PredictiveScalingMode *string `json:"PredictiveScalingMode,omitempty" xml:"PredictiveScalingMode,omitempty"`
	// The amount of buffer time before the prediction task is executed. By default, all scheduled tasks that are automatically created for a predictive scaling rule are executed on the hour. You can specify a buffer time for resource preparation before prediction tasks are executed. Valid values: 0 to 60. Unit: minutes.
	PredictiveTaskBufferTime *int32 `json:"PredictiveTaskBufferTime,omitempty" xml:"PredictiveTaskBufferTime,omitempty"`
	// Specifies which one of the initial maximum capacity and the predicted value can be used as the maximum value for prediction tasks. Valid values:
	//
	// *   MaxOverridePredictiveValue: uses the initial maximum capacity as the maximum value for prediction tasks if the predicted value is greater than the initial maximum capacity.
	// *   PredictiveValueOverrideMax: uses the predicted value as the maximum value for prediction tasks when the predicted value is greater than the initial maximum capacity.
	// *   PredictiveValueOverrideMaxWithBuffer: increases the predicted value by a percentage that is specified by the PredictiveValueBuffer parameter. If the predicted value that is increased by the percentage is greater than the initial maximum capacity, the increased value is used as the maximum value for prediction tasks.
	PredictiveValueBehavior *string `json:"PredictiveValueBehavior,omitempty" xml:"PredictiveValueBehavior,omitempty"`
	// The percentage of the increment to the predicted value when the PredictiveValueBehavior parameter is set to PredictiveValueOverrideMaxWithBuffer. If the predicted value increased by this percentage is greater than the initial maximum capacity, the increased value is used as the maximum value for prediction tasks. Valid values: 0 to 100.
	PredictiveValueBuffer *int32 `json:"PredictiveValueBuffer,omitempty" xml:"PredictiveValueBuffer,omitempty"`
	// The number of consecutive times that the event-triggered task created for scale-out activities must meet the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.
	ScaleInEvaluationCount *int32 `json:"ScaleInEvaluationCount,omitempty" xml:"ScaleInEvaluationCount,omitempty"`
	// The number of consecutive times that the event-triggered task created for scale-in activities must meet the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.
	ScaleOutEvaluationCount *int32 `json:"ScaleOutEvaluationCount,omitempty" xml:"ScaleOutEvaluationCount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The unique identifier of the scaling rule.
	ScalingRuleAri *string `json:"ScalingRuleAri,omitempty" xml:"ScalingRuleAri,omitempty"`
	// The ID of the scaling rule.
	ScalingRuleId *string `json:"ScalingRuleId,omitempty" xml:"ScalingRuleId,omitempty"`
	// The name of the scaling rule.
	ScalingRuleName *string `json:"ScalingRuleName,omitempty" xml:"ScalingRuleName,omitempty"`
	// The type of the scaling rule. Valid values:
	//
	// *   SimpleScalingRule: adjusts the number of ECS instances based on the values of the AdjustmentType and AdjustmentValue parameters.
	// *   TargetTrackingScalingRule: calculates the number of ECS instances that need to be scaled in a dynamic manner and maintains the value of a predefined metric close to the value of the TargetValue parameter.
	// *   StepScalingRule: scales ECS instances in steps based on specified thresholds and metric values.
	// *   PredictiveScalingRule: uses machine learning to analyze historical monitoring data of the scaling group and predicts the future values of metrics. In addition, Auto Scaling automatically creates scheduled tasks to adjust the boundary values for the scaling group.
	ScalingRuleType *string `json:"ScalingRuleType,omitempty" xml:"ScalingRuleType,omitempty"`
	// The step adjustments of the step scaling rule.
	StepAdjustments []*DescribeScalingRulesResponseBodyScalingRulesStepAdjustments `json:"StepAdjustments,omitempty" xml:"StepAdjustments,omitempty" type:"Repeated"`
	// The target value of the metric.
	TargetValue *float32 `json:"TargetValue,omitempty" xml:"TargetValue,omitempty"`
}

func (s DescribeScalingRulesResponseBodyScalingRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingRulesResponseBodyScalingRules) GoString() string {
	return s.String()
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetAdjustmentType(v string) *DescribeScalingRulesResponseBodyScalingRules {
	s.AdjustmentType = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetAdjustmentValue(v int32) *DescribeScalingRulesResponseBodyScalingRules {
	s.AdjustmentValue = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetAlarmDimensions(v []*DescribeScalingRulesResponseBodyScalingRulesAlarmDimensions) *DescribeScalingRulesResponseBodyScalingRules {
	s.AlarmDimensions = v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetAlarms(v []*DescribeScalingRulesResponseBodyScalingRulesAlarms) *DescribeScalingRulesResponseBodyScalingRules {
	s.Alarms = v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetCooldown(v int32) *DescribeScalingRulesResponseBodyScalingRules {
	s.Cooldown = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetDisableScaleIn(v bool) *DescribeScalingRulesResponseBodyScalingRules {
	s.DisableScaleIn = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetEstimatedInstanceWarmup(v int32) *DescribeScalingRulesResponseBodyScalingRules {
	s.EstimatedInstanceWarmup = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetInitialMaxSize(v int32) *DescribeScalingRulesResponseBodyScalingRules {
	s.InitialMaxSize = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetMaxSize(v int32) *DescribeScalingRulesResponseBodyScalingRules {
	s.MaxSize = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetMetricName(v string) *DescribeScalingRulesResponseBodyScalingRules {
	s.MetricName = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetMinAdjustmentMagnitude(v int32) *DescribeScalingRulesResponseBodyScalingRules {
	s.MinAdjustmentMagnitude = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetMinSize(v int32) *DescribeScalingRulesResponseBodyScalingRules {
	s.MinSize = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetPredictiveScalingMode(v string) *DescribeScalingRulesResponseBodyScalingRules {
	s.PredictiveScalingMode = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetPredictiveTaskBufferTime(v int32) *DescribeScalingRulesResponseBodyScalingRules {
	s.PredictiveTaskBufferTime = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetPredictiveValueBehavior(v string) *DescribeScalingRulesResponseBodyScalingRules {
	s.PredictiveValueBehavior = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetPredictiveValueBuffer(v int32) *DescribeScalingRulesResponseBodyScalingRules {
	s.PredictiveValueBuffer = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetScaleInEvaluationCount(v int32) *DescribeScalingRulesResponseBodyScalingRules {
	s.ScaleInEvaluationCount = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetScaleOutEvaluationCount(v int32) *DescribeScalingRulesResponseBodyScalingRules {
	s.ScaleOutEvaluationCount = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetScalingGroupId(v string) *DescribeScalingRulesResponseBodyScalingRules {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetScalingRuleAri(v string) *DescribeScalingRulesResponseBodyScalingRules {
	s.ScalingRuleAri = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetScalingRuleId(v string) *DescribeScalingRulesResponseBodyScalingRules {
	s.ScalingRuleId = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetScalingRuleName(v string) *DescribeScalingRulesResponseBodyScalingRules {
	s.ScalingRuleName = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetScalingRuleType(v string) *DescribeScalingRulesResponseBodyScalingRules {
	s.ScalingRuleType = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetStepAdjustments(v []*DescribeScalingRulesResponseBodyScalingRulesStepAdjustments) *DescribeScalingRulesResponseBodyScalingRules {
	s.StepAdjustments = v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetTargetValue(v float32) *DescribeScalingRulesResponseBodyScalingRules {
	s.TargetValue = &v
	return s
}

type DescribeScalingRulesResponseBodyScalingRulesAlarmDimensions struct {
	// 监控项关联的维度信息键。
	DimensionKey *string `json:"DimensionKey,omitempty" xml:"DimensionKey,omitempty"`
	// 监控项关联的维度信息值。
	DimensionValue *string `json:"DimensionValue,omitempty" xml:"DimensionValue,omitempty"`
}

func (s DescribeScalingRulesResponseBodyScalingRulesAlarmDimensions) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingRulesResponseBodyScalingRulesAlarmDimensions) GoString() string {
	return s.String()
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarmDimensions) SetDimensionKey(v string) *DescribeScalingRulesResponseBodyScalingRulesAlarmDimensions {
	s.DimensionKey = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarmDimensions) SetDimensionValue(v string) *DescribeScalingRulesResponseBodyScalingRulesAlarmDimensions {
	s.DimensionValue = &v
	return s
}

type DescribeScalingRulesResponseBodyScalingRulesAlarms struct {
	// The ID of the event-triggered task that is associated with the scaling rule.
	AlarmTaskId *string `json:"AlarmTaskId,omitempty" xml:"AlarmTaskId,omitempty"`
	// The name of the event-triggered task that is associated with the scaling rule.
	AlarmTaskName *string `json:"AlarmTaskName,omitempty" xml:"AlarmTaskName,omitempty"`
	// The comparison operator between the metric value and the threshold for the event-triggered task that is associated with the scaling rule. The comparison operator indicates the relationship between the metric value and the threshold that is required to meet the condition.
	//
	// *   Valid value if the metric value is greater than or equal to the threshold: >=.
	// *   Valid value if the metric value is less than or equal to the threshold: <=.
	// *   Valid value if the metric value is greater than the threshold: >.
	// *   Valid value if the metric value is less than the threshold: <.
	ComparisonOperator *string `json:"ComparisonOperator,omitempty" xml:"ComparisonOperator,omitempty"`
	// The dimensions of the event-triggered task that is associated with the scaling rule.
	Dimensions []*DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions `json:"Dimensions,omitempty" xml:"Dimensions,omitempty" type:"Repeated"`
	// The number of consecutive times for which the event-triggered task that is associated with the scaling rule meets the threshold expressions before an alert is triggered.
	EvaluationCount *int32 `json:"EvaluationCount,omitempty" xml:"EvaluationCount,omitempty"`
	// The name of the metric of the event-triggered task that is associated with the scaling rule.
	MetricName *string `json:"MetricName,omitempty" xml:"MetricName,omitempty"`
	// The type of the event-triggered task that is associated with the scaling rule. Valid values:
	//
	// *   system: system monitoring event-triggered tasks
	// *   custom: custom monitoring event-triggered tasks
	MetricType *string `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
	// The statistical method of the event-triggered task that is associated with the scaling rule. Valid values:
	//
	// *   Average
	// *   Maximum
	// *   Minimum
	Statistics *string `json:"Statistics,omitempty" xml:"Statistics,omitempty"`
	// The alert threshold of the event-triggered task that is associated with the scaling rule.
	Threshold *float32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s DescribeScalingRulesResponseBodyScalingRulesAlarms) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingRulesResponseBodyScalingRulesAlarms) GoString() string {
	return s.String()
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarms) SetAlarmTaskId(v string) *DescribeScalingRulesResponseBodyScalingRulesAlarms {
	s.AlarmTaskId = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarms) SetAlarmTaskName(v string) *DescribeScalingRulesResponseBodyScalingRulesAlarms {
	s.AlarmTaskName = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarms) SetComparisonOperator(v string) *DescribeScalingRulesResponseBodyScalingRulesAlarms {
	s.ComparisonOperator = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarms) SetDimensions(v []*DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions) *DescribeScalingRulesResponseBodyScalingRulesAlarms {
	s.Dimensions = v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarms) SetEvaluationCount(v int32) *DescribeScalingRulesResponseBodyScalingRulesAlarms {
	s.EvaluationCount = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarms) SetMetricName(v string) *DescribeScalingRulesResponseBodyScalingRulesAlarms {
	s.MetricName = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarms) SetMetricType(v string) *DescribeScalingRulesResponseBodyScalingRulesAlarms {
	s.MetricType = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarms) SetStatistics(v string) *DescribeScalingRulesResponseBodyScalingRulesAlarms {
	s.Statistics = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarms) SetThreshold(v float32) *DescribeScalingRulesResponseBodyScalingRulesAlarms {
	s.Threshold = &v
	return s
}

type DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions struct {
	// The key of the dimension that is associated with the metric. Valid values:
	//
	// *   scaling_group: the ID of the scaling group
	// *   userId: the ID of the Alibaba Cloud account
	DimensionKey *string `json:"DimensionKey,omitempty" xml:"DimensionKey,omitempty"`
	// The value of the dimension that is associated with the metric.
	DimensionValue *string `json:"DimensionValue,omitempty" xml:"DimensionValue,omitempty"`
}

func (s DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions) GoString() string {
	return s.String()
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions) SetDimensionKey(v string) *DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions {
	s.DimensionKey = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions) SetDimensionValue(v string) *DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions {
	s.DimensionValue = &v
	return s
}

type DescribeScalingRulesResponseBodyScalingRulesStepAdjustments struct {
	// The lower limit that is specified in a step adjustment. Valid values: -9.999999E18 to 9.999999E18.
	MetricIntervalLowerBound *float32 `json:"MetricIntervalLowerBound,omitempty" xml:"MetricIntervalLowerBound,omitempty"`
	// The upper limit that is specified in a step adjustment. Valid values: -9.999999E18 to 9.999999E18.
	MetricIntervalUpperBound *float32 `json:"MetricIntervalUpperBound,omitempty" xml:"MetricIntervalUpperBound,omitempty"`
	// The number of ECS instances that are scaled in a step adjustment.
	ScalingAdjustment *int32 `json:"ScalingAdjustment,omitempty" xml:"ScalingAdjustment,omitempty"`
}

func (s DescribeScalingRulesResponseBodyScalingRulesStepAdjustments) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingRulesResponseBodyScalingRulesStepAdjustments) GoString() string {
	return s.String()
}

func (s *DescribeScalingRulesResponseBodyScalingRulesStepAdjustments) SetMetricIntervalLowerBound(v float32) *DescribeScalingRulesResponseBodyScalingRulesStepAdjustments {
	s.MetricIntervalLowerBound = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRulesStepAdjustments) SetMetricIntervalUpperBound(v float32) *DescribeScalingRulesResponseBodyScalingRulesStepAdjustments {
	s.MetricIntervalUpperBound = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRulesStepAdjustments) SetScalingAdjustment(v int32) *DescribeScalingRulesResponseBodyScalingRulesStepAdjustments {
	s.ScalingAdjustment = &v
	return s
}

type DescribeScalingRulesResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeScalingRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeScalingRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingRulesResponse) GoString() string {
	return s.String()
}

func (s *DescribeScalingRulesResponse) SetHeaders(v map[string]*string) *DescribeScalingRulesResponse {
	s.Headers = v
	return s
}

func (s *DescribeScalingRulesResponse) SetStatusCode(v int32) *DescribeScalingRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeScalingRulesResponse) SetBody(v *DescribeScalingRulesResponseBody) *DescribeScalingRulesResponse {
	s.Body = v
	return s
}

type DescribeScheduledTasksRequest struct {
	OwnerAccount         *string   `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	PageNumber           *int32    `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize             *int32    `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RegionId             *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	ScalingGroupId       *string   `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	ScheduledActions     []*string `json:"ScheduledActions,omitempty" xml:"ScheduledActions,omitempty" type:"Repeated"`
	ScheduledTaskIds     []*string `json:"ScheduledTaskIds,omitempty" xml:"ScheduledTaskIds,omitempty" type:"Repeated"`
	ScheduledTaskNames   []*string `json:"ScheduledTaskNames,omitempty" xml:"ScheduledTaskNames,omitempty" type:"Repeated"`
}

func (s DescribeScheduledTasksRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeScheduledTasksRequest) GoString() string {
	return s.String()
}

func (s *DescribeScheduledTasksRequest) SetOwnerAccount(v string) *DescribeScheduledTasksRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeScheduledTasksRequest) SetOwnerId(v int64) *DescribeScheduledTasksRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeScheduledTasksRequest) SetPageNumber(v int32) *DescribeScheduledTasksRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeScheduledTasksRequest) SetPageSize(v int32) *DescribeScheduledTasksRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeScheduledTasksRequest) SetRegionId(v string) *DescribeScheduledTasksRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeScheduledTasksRequest) SetResourceOwnerAccount(v string) *DescribeScheduledTasksRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeScheduledTasksRequest) SetResourceOwnerId(v int64) *DescribeScheduledTasksRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeScheduledTasksRequest) SetScalingGroupId(v string) *DescribeScheduledTasksRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeScheduledTasksRequest) SetScheduledActions(v []*string) *DescribeScheduledTasksRequest {
	s.ScheduledActions = v
	return s
}

func (s *DescribeScheduledTasksRequest) SetScheduledTaskIds(v []*string) *DescribeScheduledTasksRequest {
	s.ScheduledTaskIds = v
	return s
}

func (s *DescribeScheduledTasksRequest) SetScheduledTaskNames(v []*string) *DescribeScheduledTasksRequest {
	s.ScheduledTaskNames = v
	return s
}

type DescribeScheduledTasksResponseBody struct {
	PageNumber     *int32                                              `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize       *int32                                              `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RequestId      *string                                             `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	ScheduledTasks []*DescribeScheduledTasksResponseBodyScheduledTasks `json:"ScheduledTasks,omitempty" xml:"ScheduledTasks,omitempty" type:"Repeated"`
	TotalCount     *int32                                              `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeScheduledTasksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeScheduledTasksResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeScheduledTasksResponseBody) SetPageNumber(v int32) *DescribeScheduledTasksResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeScheduledTasksResponseBody) SetPageSize(v int32) *DescribeScheduledTasksResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeScheduledTasksResponseBody) SetRequestId(v string) *DescribeScheduledTasksResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeScheduledTasksResponseBody) SetScheduledTasks(v []*DescribeScheduledTasksResponseBodyScheduledTasks) *DescribeScheduledTasksResponseBody {
	s.ScheduledTasks = v
	return s
}

func (s *DescribeScheduledTasksResponseBody) SetTotalCount(v int32) *DescribeScheduledTasksResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeScheduledTasksResponseBodyScheduledTasks struct {
	Description          *string `json:"Description,omitempty" xml:"Description,omitempty"`
	DesiredCapacity      *int32  `json:"DesiredCapacity,omitempty" xml:"DesiredCapacity,omitempty"`
	LaunchExpirationTime *int32  `json:"LaunchExpirationTime,omitempty" xml:"LaunchExpirationTime,omitempty"`
	LaunchTime           *string `json:"LaunchTime,omitempty" xml:"LaunchTime,omitempty"`
	MaxValue             *int32  `json:"MaxValue,omitempty" xml:"MaxValue,omitempty"`
	MinValue             *int32  `json:"MinValue,omitempty" xml:"MinValue,omitempty"`
	RecurrenceEndTime    *string `json:"RecurrenceEndTime,omitempty" xml:"RecurrenceEndTime,omitempty"`
	RecurrenceType       *string `json:"RecurrenceType,omitempty" xml:"RecurrenceType,omitempty"`
	RecurrenceValue      *string `json:"RecurrenceValue,omitempty" xml:"RecurrenceValue,omitempty"`
	ScalingGroupId       *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	ScheduledAction      *string `json:"ScheduledAction,omitempty" xml:"ScheduledAction,omitempty"`
	ScheduledTaskId      *string `json:"ScheduledTaskId,omitempty" xml:"ScheduledTaskId,omitempty"`
	ScheduledTaskName    *string `json:"ScheduledTaskName,omitempty" xml:"ScheduledTaskName,omitempty"`
	TaskEnabled          *bool   `json:"TaskEnabled,omitempty" xml:"TaskEnabled,omitempty"`
}

func (s DescribeScheduledTasksResponseBodyScheduledTasks) String() string {
	return tea.Prettify(s)
}

func (s DescribeScheduledTasksResponseBodyScheduledTasks) GoString() string {
	return s.String()
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetDescription(v string) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.Description = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetDesiredCapacity(v int32) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.DesiredCapacity = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetLaunchExpirationTime(v int32) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.LaunchExpirationTime = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetLaunchTime(v string) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.LaunchTime = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetMaxValue(v int32) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.MaxValue = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetMinValue(v int32) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.MinValue = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetRecurrenceEndTime(v string) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.RecurrenceEndTime = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetRecurrenceType(v string) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.RecurrenceType = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetRecurrenceValue(v string) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.RecurrenceValue = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetScalingGroupId(v string) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetScheduledAction(v string) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.ScheduledAction = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetScheduledTaskId(v string) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.ScheduledTaskId = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetScheduledTaskName(v string) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.ScheduledTaskName = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetTaskEnabled(v bool) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.TaskEnabled = &v
	return s
}

type DescribeScheduledTasksResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeScheduledTasksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeScheduledTasksResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeScheduledTasksResponse) GoString() string {
	return s.String()
}

func (s *DescribeScheduledTasksResponse) SetHeaders(v map[string]*string) *DescribeScheduledTasksResponse {
	s.Headers = v
	return s
}

func (s *DescribeScheduledTasksResponse) SetStatusCode(v int32) *DescribeScheduledTasksResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeScheduledTasksResponse) SetBody(v *DescribeScheduledTasksResponseBody) *DescribeScheduledTasksResponse {
	s.Body = v
	return s
}

type DetachAlbServerGroupsRequest struct {
	// Details of the ALB server groups.
	AlbServerGroups []*DetachAlbServerGroupsRequestAlbServerGroups `json:"AlbServerGroups,omitempty" xml:"AlbServerGroups,omitempty" type:"Repeated"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request](~~25965~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to remove existing Elastic Compute Service (ECS) instances from the ALB server group that you want to disassociate from the scaling group. Valid values:
	//
	// *   true: removes existing ECS instances and returns the value of the `ScalingActivityId` parameter. You can use the scaling activity ID to check whether the ECS instances are removed.
	// *   false: does not remove existing ECS instances.
	//
	// Default value: false.
	ForceDetach *bool  `json:"ForceDetach,omitempty" xml:"ForceDetach,omitempty"`
	OwnerId     *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group. Examples: cn-hangzhou and cn-shanghai.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DetachAlbServerGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachAlbServerGroupsRequest) GoString() string {
	return s.String()
}

func (s *DetachAlbServerGroupsRequest) SetAlbServerGroups(v []*DetachAlbServerGroupsRequestAlbServerGroups) *DetachAlbServerGroupsRequest {
	s.AlbServerGroups = v
	return s
}

func (s *DetachAlbServerGroupsRequest) SetClientToken(v string) *DetachAlbServerGroupsRequest {
	s.ClientToken = &v
	return s
}

func (s *DetachAlbServerGroupsRequest) SetForceDetach(v bool) *DetachAlbServerGroupsRequest {
	s.ForceDetach = &v
	return s
}

func (s *DetachAlbServerGroupsRequest) SetOwnerId(v int64) *DetachAlbServerGroupsRequest {
	s.OwnerId = &v
	return s
}

func (s *DetachAlbServerGroupsRequest) SetRegionId(v string) *DetachAlbServerGroupsRequest {
	s.RegionId = &v
	return s
}

func (s *DetachAlbServerGroupsRequest) SetResourceOwnerAccount(v string) *DetachAlbServerGroupsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DetachAlbServerGroupsRequest) SetScalingGroupId(v string) *DetachAlbServerGroupsRequest {
	s.ScalingGroupId = &v
	return s
}

type DetachAlbServerGroupsRequestAlbServerGroups struct {
	// The ID of the ALB server group.
	AlbServerGroupId *string `json:"AlbServerGroupId,omitempty" xml:"AlbServerGroupId,omitempty"`
	// The port number used by the ECS instances in the ALB server group.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
}

func (s DetachAlbServerGroupsRequestAlbServerGroups) String() string {
	return tea.Prettify(s)
}

func (s DetachAlbServerGroupsRequestAlbServerGroups) GoString() string {
	return s.String()
}

func (s *DetachAlbServerGroupsRequestAlbServerGroups) SetAlbServerGroupId(v string) *DetachAlbServerGroupsRequestAlbServerGroups {
	s.AlbServerGroupId = &v
	return s
}

func (s *DetachAlbServerGroupsRequestAlbServerGroups) SetPort(v int32) *DetachAlbServerGroupsRequestAlbServerGroups {
	s.Port = &v
	return s
}

type DetachAlbServerGroupsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the scaling activity in which the ALB server group is disassociated from the scaling group and the ECS instances in the ALB server group are removed from the ALB server group. This parameter is returned only after you set the `ForceDetach` parameter to `true`.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s DetachAlbServerGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachAlbServerGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *DetachAlbServerGroupsResponseBody) SetRequestId(v string) *DetachAlbServerGroupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DetachAlbServerGroupsResponseBody) SetScalingActivityId(v string) *DetachAlbServerGroupsResponseBody {
	s.ScalingActivityId = &v
	return s
}

type DetachAlbServerGroupsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachAlbServerGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachAlbServerGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachAlbServerGroupsResponse) GoString() string {
	return s.String()
}

func (s *DetachAlbServerGroupsResponse) SetHeaders(v map[string]*string) *DetachAlbServerGroupsResponse {
	s.Headers = v
	return s
}

func (s *DetachAlbServerGroupsResponse) SetStatusCode(v int32) *DetachAlbServerGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachAlbServerGroupsResponse) SetBody(v *DetachAlbServerGroupsResponseBody) *DetachAlbServerGroupsResponse {
	s.Body = v
	return s
}

type DetachDBInstancesRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The IDs of the ApsaraDB RDS instances. You can specify up to five ApsaraDB RDS instances.
	DBInstances []*string `json:"DBInstances,omitempty" xml:"DBInstances,omitempty" type:"Repeated"`
	// Specifies whether to remove the private IP addresses of instances in the scaling group from the whitelist that manages access to the ApsaraDB RDS instance with which the scaling group is associated. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	ForceDetach *bool  `json:"ForceDetach,omitempty" xml:"ForceDetach,omitempty"`
	OwnerId     *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DetachDBInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachDBInstancesRequest) GoString() string {
	return s.String()
}

func (s *DetachDBInstancesRequest) SetClientToken(v string) *DetachDBInstancesRequest {
	s.ClientToken = &v
	return s
}

func (s *DetachDBInstancesRequest) SetDBInstances(v []*string) *DetachDBInstancesRequest {
	s.DBInstances = v
	return s
}

func (s *DetachDBInstancesRequest) SetForceDetach(v bool) *DetachDBInstancesRequest {
	s.ForceDetach = &v
	return s
}

func (s *DetachDBInstancesRequest) SetOwnerId(v int64) *DetachDBInstancesRequest {
	s.OwnerId = &v
	return s
}

func (s *DetachDBInstancesRequest) SetRegionId(v string) *DetachDBInstancesRequest {
	s.RegionId = &v
	return s
}

func (s *DetachDBInstancesRequest) SetResourceOwnerAccount(v string) *DetachDBInstancesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DetachDBInstancesRequest) SetScalingGroupId(v string) *DetachDBInstancesRequest {
	s.ScalingGroupId = &v
	return s
}

type DetachDBInstancesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DetachDBInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachDBInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *DetachDBInstancesResponseBody) SetRequestId(v string) *DetachDBInstancesResponseBody {
	s.RequestId = &v
	return s
}

type DetachDBInstancesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachDBInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachDBInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachDBInstancesResponse) GoString() string {
	return s.String()
}

func (s *DetachDBInstancesResponse) SetHeaders(v map[string]*string) *DetachDBInstancesResponse {
	s.Headers = v
	return s
}

func (s *DetachDBInstancesResponse) SetStatusCode(v int32) *DetachDBInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachDBInstancesResponse) SetBody(v *DetachDBInstancesResponseBody) *DetachDBInstancesResponse {
	s.Body = v
	return s
}

type DetachInstancesRequest struct {
	// 保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。只支持ASCII字符，且不能超过64个字符。更多信息，请参见[如何保证幂等性](~~25965~~)。
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to adjust the expected number of instances in the scaling group. Valid values:
	//
	// *   true: After a specific number of instances are removed from the scaling group, the expected number of instances in the scaling group decreases.
	// *   false: After a specific number of instances are removed from the scaling group, the expected number of instances in the scaling group remains unchanged.
	//
	// Default value: true.
	DecreaseDesiredCapacity *bool `json:"DecreaseDesiredCapacity,omitempty" xml:"DecreaseDesiredCapacity,omitempty"`
	// Specifies whether to remove the instances from the default server group and vServer groups of the Classic Load Balancer (CLB) instance that is associated with the scaling group, and whether to remove the IP addresses of the instances from the whitelist that manages access to the ApsaraDB RDS instance that is associated with the scaling group.
	//
	// If you set this parameter to both, the instances are removed from the default sever group and vServer groups of the associated CLB instance, and the IP addresses of the instances are removed from the whitelist that manages access to the associated ApsaraDB RDS instance.
	DetachOption *string `json:"DetachOption,omitempty" xml:"DetachOption,omitempty"`
	// The IDs of the ECS instances or elastic container instances that you want to remove from the scaling group.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// Specifies whether to trigger a lifecycle hook for a scale-in activity. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	LifecycleHook        *bool   `json:"LifecycleHook,omitempty" xml:"LifecycleHook,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DetachInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachInstancesRequest) GoString() string {
	return s.String()
}

func (s *DetachInstancesRequest) SetClientToken(v string) *DetachInstancesRequest {
	s.ClientToken = &v
	return s
}

func (s *DetachInstancesRequest) SetDecreaseDesiredCapacity(v bool) *DetachInstancesRequest {
	s.DecreaseDesiredCapacity = &v
	return s
}

func (s *DetachInstancesRequest) SetDetachOption(v string) *DetachInstancesRequest {
	s.DetachOption = &v
	return s
}

func (s *DetachInstancesRequest) SetInstanceIds(v []*string) *DetachInstancesRequest {
	s.InstanceIds = v
	return s
}

func (s *DetachInstancesRequest) SetLifecycleHook(v bool) *DetachInstancesRequest {
	s.LifecycleHook = &v
	return s
}

func (s *DetachInstancesRequest) SetOwnerAccount(v string) *DetachInstancesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DetachInstancesRequest) SetOwnerId(v int64) *DetachInstancesRequest {
	s.OwnerId = &v
	return s
}

func (s *DetachInstancesRequest) SetResourceOwnerAccount(v string) *DetachInstancesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DetachInstancesRequest) SetResourceOwnerId(v int64) *DetachInstancesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DetachInstancesRequest) SetScalingGroupId(v string) *DetachInstancesRequest {
	s.ScalingGroupId = &v
	return s
}

type DetachInstancesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the scaling activity.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s DetachInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *DetachInstancesResponseBody) SetRequestId(v string) *DetachInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DetachInstancesResponseBody) SetScalingActivityId(v string) *DetachInstancesResponseBody {
	s.ScalingActivityId = &v
	return s
}

type DetachInstancesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachInstancesResponse) GoString() string {
	return s.String()
}

func (s *DetachInstancesResponse) SetHeaders(v map[string]*string) *DetachInstancesResponse {
	s.Headers = v
	return s
}

func (s *DetachInstancesResponse) SetStatusCode(v int32) *DetachInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachInstancesResponse) SetBody(v *DetachInstancesResponseBody) *DetachInstancesResponse {
	s.Body = v
	return s
}

type DetachLoadBalancersRequest struct {
	Async                *bool     `json:"Async,omitempty" xml:"Async,omitempty"`
	ClientToken          *string   `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	ForceDetach          *bool     `json:"ForceDetach,omitempty" xml:"ForceDetach,omitempty"`
	LoadBalancers        []*string `json:"LoadBalancers,omitempty" xml:"LoadBalancers,omitempty" type:"Repeated"`
	OwnerId              *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	RegionId             *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ScalingGroupId       *string   `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DetachLoadBalancersRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachLoadBalancersRequest) GoString() string {
	return s.String()
}

func (s *DetachLoadBalancersRequest) SetAsync(v bool) *DetachLoadBalancersRequest {
	s.Async = &v
	return s
}

func (s *DetachLoadBalancersRequest) SetClientToken(v string) *DetachLoadBalancersRequest {
	s.ClientToken = &v
	return s
}

func (s *DetachLoadBalancersRequest) SetForceDetach(v bool) *DetachLoadBalancersRequest {
	s.ForceDetach = &v
	return s
}

func (s *DetachLoadBalancersRequest) SetLoadBalancers(v []*string) *DetachLoadBalancersRequest {
	s.LoadBalancers = v
	return s
}

func (s *DetachLoadBalancersRequest) SetOwnerId(v int64) *DetachLoadBalancersRequest {
	s.OwnerId = &v
	return s
}

func (s *DetachLoadBalancersRequest) SetRegionId(v string) *DetachLoadBalancersRequest {
	s.RegionId = &v
	return s
}

func (s *DetachLoadBalancersRequest) SetResourceOwnerAccount(v string) *DetachLoadBalancersRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DetachLoadBalancersRequest) SetScalingGroupId(v string) *DetachLoadBalancersRequest {
	s.ScalingGroupId = &v
	return s
}

type DetachLoadBalancersResponseBody struct {
	RequestId         *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s DetachLoadBalancersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachLoadBalancersResponseBody) GoString() string {
	return s.String()
}

func (s *DetachLoadBalancersResponseBody) SetRequestId(v string) *DetachLoadBalancersResponseBody {
	s.RequestId = &v
	return s
}

func (s *DetachLoadBalancersResponseBody) SetScalingActivityId(v string) *DetachLoadBalancersResponseBody {
	s.ScalingActivityId = &v
	return s
}

type DetachLoadBalancersResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachLoadBalancersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachLoadBalancersResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachLoadBalancersResponse) GoString() string {
	return s.String()
}

func (s *DetachLoadBalancersResponse) SetHeaders(v map[string]*string) *DetachLoadBalancersResponse {
	s.Headers = v
	return s
}

func (s *DetachLoadBalancersResponse) SetStatusCode(v int32) *DetachLoadBalancersResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachLoadBalancersResponse) SetBody(v *DetachLoadBalancersResponseBody) *DetachLoadBalancersResponse {
	s.Body = v
	return s
}

type DetachServerGroupsRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [Ensure idempotence](~~25965~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to remove the Elastic Compute Service (ECS) instances in the scaling group from the detached server group.
	//
	// *   true
	// *   false
	//
	// Default value: false.
	ForceDetach *bool  `json:"ForceDetach,omitempty" xml:"ForceDetach,omitempty"`
	OwnerId     *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// Details of the server groups.
	ServerGroups []*DetachServerGroupsRequestServerGroups `json:"ServerGroups,omitempty" xml:"ServerGroups,omitempty" type:"Repeated"`
}

func (s DetachServerGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachServerGroupsRequest) GoString() string {
	return s.String()
}

func (s *DetachServerGroupsRequest) SetClientToken(v string) *DetachServerGroupsRequest {
	s.ClientToken = &v
	return s
}

func (s *DetachServerGroupsRequest) SetForceDetach(v bool) *DetachServerGroupsRequest {
	s.ForceDetach = &v
	return s
}

func (s *DetachServerGroupsRequest) SetOwnerId(v int64) *DetachServerGroupsRequest {
	s.OwnerId = &v
	return s
}

func (s *DetachServerGroupsRequest) SetRegionId(v string) *DetachServerGroupsRequest {
	s.RegionId = &v
	return s
}

func (s *DetachServerGroupsRequest) SetResourceOwnerAccount(v string) *DetachServerGroupsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DetachServerGroupsRequest) SetScalingGroupId(v string) *DetachServerGroupsRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *DetachServerGroupsRequest) SetServerGroups(v []*DetachServerGroupsRequestServerGroups) *DetachServerGroupsRequest {
	s.ServerGroups = v
	return s
}

type DetachServerGroupsRequestServerGroups struct {
	// The port number that is used by an ECS instance after Auto Scaling adds the ECS instance to the server group.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The ID of the server group.
	ServerGroupId *string `json:"ServerGroupId,omitempty" xml:"ServerGroupId,omitempty"`
	// The type of the server group. Valid values:
	//
	// *   ALB
	// *   NLB
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DetachServerGroupsRequestServerGroups) String() string {
	return tea.Prettify(s)
}

func (s DetachServerGroupsRequestServerGroups) GoString() string {
	return s.String()
}

func (s *DetachServerGroupsRequestServerGroups) SetPort(v int32) *DetachServerGroupsRequestServerGroups {
	s.Port = &v
	return s
}

func (s *DetachServerGroupsRequestServerGroups) SetServerGroupId(v string) *DetachServerGroupsRequestServerGroups {
	s.ServerGroupId = &v
	return s
}

func (s *DetachServerGroupsRequestServerGroups) SetType(v string) *DetachServerGroupsRequestServerGroups {
	s.Type = &v
	return s
}

type DetachServerGroupsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the scaling activity in which you detach the server group from the scaling group and Auto Scaling removes the ECS instances from the server group.
	//
	// > This parameter is returned only if you set the ForceAttach parameter to true.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s DetachServerGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachServerGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *DetachServerGroupsResponseBody) SetRequestId(v string) *DetachServerGroupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DetachServerGroupsResponseBody) SetScalingActivityId(v string) *DetachServerGroupsResponseBody {
	s.ScalingActivityId = &v
	return s
}

type DetachServerGroupsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachServerGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachServerGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachServerGroupsResponse) GoString() string {
	return s.String()
}

func (s *DetachServerGroupsResponse) SetHeaders(v map[string]*string) *DetachServerGroupsResponse {
	s.Headers = v
	return s
}

func (s *DetachServerGroupsResponse) SetStatusCode(v int32) *DetachServerGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachServerGroupsResponse) SetBody(v *DetachServerGroupsResponseBody) *DetachServerGroupsResponse {
	s.Body = v
	return s
}

type DetachVServerGroupsRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to remove ECS instances in your scaling group from the vServer group.
	//
	// *   true
	// *   false
	//
	// Default value: false.
	ForceDetach *bool  `json:"ForceDetach,omitempty" xml:"ForceDetach,omitempty"`
	OwnerId     *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group. Examples: cn-hangzhou and cn-shanghai.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// Details of the vServer groups.
	VServerGroups []*DetachVServerGroupsRequestVServerGroups `json:"VServerGroups,omitempty" xml:"VServerGroups,omitempty" type:"Repeated"`
}

func (s DetachVServerGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachVServerGroupsRequest) GoString() string {
	return s.String()
}

func (s *DetachVServerGroupsRequest) SetClientToken(v string) *DetachVServerGroupsRequest {
	s.ClientToken = &v
	return s
}

func (s *DetachVServerGroupsRequest) SetForceDetach(v bool) *DetachVServerGroupsRequest {
	s.ForceDetach = &v
	return s
}

func (s *DetachVServerGroupsRequest) SetOwnerId(v int64) *DetachVServerGroupsRequest {
	s.OwnerId = &v
	return s
}

func (s *DetachVServerGroupsRequest) SetRegionId(v string) *DetachVServerGroupsRequest {
	s.RegionId = &v
	return s
}

func (s *DetachVServerGroupsRequest) SetResourceOwnerAccount(v string) *DetachVServerGroupsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DetachVServerGroupsRequest) SetScalingGroupId(v string) *DetachVServerGroupsRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *DetachVServerGroupsRequest) SetVServerGroups(v []*DetachVServerGroupsRequestVServerGroups) *DetachVServerGroupsRequest {
	s.VServerGroups = v
	return s
}

type DetachVServerGroupsRequestVServerGroups struct {
	// The ID of the Classic Load Balancer (CLB) instance to which the vServer group belongs.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// Details of the vServer group attributes.
	VServerGroupAttributes []*DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes `json:"VServerGroupAttributes,omitempty" xml:"VServerGroupAttributes,omitempty" type:"Repeated"`
}

func (s DetachVServerGroupsRequestVServerGroups) String() string {
	return tea.Prettify(s)
}

func (s DetachVServerGroupsRequestVServerGroups) GoString() string {
	return s.String()
}

func (s *DetachVServerGroupsRequestVServerGroups) SetLoadBalancerId(v string) *DetachVServerGroupsRequestVServerGroups {
	s.LoadBalancerId = &v
	return s
}

func (s *DetachVServerGroupsRequestVServerGroups) SetVServerGroupAttributes(v []*DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes) *DetachVServerGroupsRequestVServerGroups {
	s.VServerGroupAttributes = v
	return s
}

type DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes struct {
	// The port number that is used when Auto Scaling adds ECS instances to the vServer group. Valid values: 1 to 65535.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The ID of the vServer group.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes) String() string {
	return tea.Prettify(s)
}

func (s DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes) GoString() string {
	return s.String()
}

func (s *DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes) SetPort(v int32) *DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes {
	s.Port = &v
	return s
}

func (s *DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes) SetVServerGroupId(v string) *DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes {
	s.VServerGroupId = &v
	return s
}

type DetachVServerGroupsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DetachVServerGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachVServerGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *DetachVServerGroupsResponseBody) SetRequestId(v string) *DetachVServerGroupsResponseBody {
	s.RequestId = &v
	return s
}

type DetachVServerGroupsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachVServerGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachVServerGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachVServerGroupsResponse) GoString() string {
	return s.String()
}

func (s *DetachVServerGroupsResponse) SetHeaders(v map[string]*string) *DetachVServerGroupsResponse {
	s.Headers = v
	return s
}

func (s *DetachVServerGroupsResponse) SetStatusCode(v int32) *DetachVServerGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachVServerGroupsResponse) SetBody(v *DetachVServerGroupsResponseBody) *DetachVServerGroupsResponse {
	s.Body = v
	return s
}

type DisableAlarmRequest struct {
	// The ID of the event-triggered task.
	AlarmTaskId *string `json:"AlarmTaskId,omitempty" xml:"AlarmTaskId,omitempty"`
	OwnerId     *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
}

func (s DisableAlarmRequest) String() string {
	return tea.Prettify(s)
}

func (s DisableAlarmRequest) GoString() string {
	return s.String()
}

func (s *DisableAlarmRequest) SetAlarmTaskId(v string) *DisableAlarmRequest {
	s.AlarmTaskId = &v
	return s
}

func (s *DisableAlarmRequest) SetOwnerId(v int64) *DisableAlarmRequest {
	s.OwnerId = &v
	return s
}

func (s *DisableAlarmRequest) SetRegionId(v string) *DisableAlarmRequest {
	s.RegionId = &v
	return s
}

func (s *DisableAlarmRequest) SetResourceOwnerAccount(v string) *DisableAlarmRequest {
	s.ResourceOwnerAccount = &v
	return s
}

type DisableAlarmResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DisableAlarmResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DisableAlarmResponseBody) GoString() string {
	return s.String()
}

func (s *DisableAlarmResponseBody) SetRequestId(v string) *DisableAlarmResponseBody {
	s.RequestId = &v
	return s
}

type DisableAlarmResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DisableAlarmResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DisableAlarmResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableAlarmResponse) GoString() string {
	return s.String()
}

func (s *DisableAlarmResponse) SetHeaders(v map[string]*string) *DisableAlarmResponse {
	s.Headers = v
	return s
}

func (s *DisableAlarmResponse) SetStatusCode(v int32) *DisableAlarmResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableAlarmResponse) SetBody(v *DisableAlarmResponseBody) *DisableAlarmResponse {
	s.Body = v
	return s
}

type DisableScalingGroupRequest struct {
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DisableScalingGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DisableScalingGroupRequest) GoString() string {
	return s.String()
}

func (s *DisableScalingGroupRequest) SetOwnerAccount(v string) *DisableScalingGroupRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DisableScalingGroupRequest) SetOwnerId(v int64) *DisableScalingGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *DisableScalingGroupRequest) SetResourceOwnerAccount(v string) *DisableScalingGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DisableScalingGroupRequest) SetResourceOwnerId(v int64) *DisableScalingGroupRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DisableScalingGroupRequest) SetScalingGroupId(v string) *DisableScalingGroupRequest {
	s.ScalingGroupId = &v
	return s
}

type DisableScalingGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DisableScalingGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DisableScalingGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DisableScalingGroupResponseBody) SetRequestId(v string) *DisableScalingGroupResponseBody {
	s.RequestId = &v
	return s
}

type DisableScalingGroupResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DisableScalingGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DisableScalingGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableScalingGroupResponse) GoString() string {
	return s.String()
}

func (s *DisableScalingGroupResponse) SetHeaders(v map[string]*string) *DisableScalingGroupResponse {
	s.Headers = v
	return s
}

func (s *DisableScalingGroupResponse) SetStatusCode(v int32) *DisableScalingGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableScalingGroupResponse) SetBody(v *DisableScalingGroupResponseBody) *DisableScalingGroupResponse {
	s.Body = v
	return s
}

type EnableAlarmRequest struct {
	// The ID of the event-triggered task.
	AlarmTaskId *string `json:"AlarmTaskId,omitempty" xml:"AlarmTaskId,omitempty"`
	OwnerId     *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
}

func (s EnableAlarmRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableAlarmRequest) GoString() string {
	return s.String()
}

func (s *EnableAlarmRequest) SetAlarmTaskId(v string) *EnableAlarmRequest {
	s.AlarmTaskId = &v
	return s
}

func (s *EnableAlarmRequest) SetOwnerId(v int64) *EnableAlarmRequest {
	s.OwnerId = &v
	return s
}

func (s *EnableAlarmRequest) SetRegionId(v string) *EnableAlarmRequest {
	s.RegionId = &v
	return s
}

func (s *EnableAlarmRequest) SetResourceOwnerAccount(v string) *EnableAlarmRequest {
	s.ResourceOwnerAccount = &v
	return s
}

type EnableAlarmResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EnableAlarmResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableAlarmResponseBody) GoString() string {
	return s.String()
}

func (s *EnableAlarmResponseBody) SetRequestId(v string) *EnableAlarmResponseBody {
	s.RequestId = &v
	return s
}

type EnableAlarmResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EnableAlarmResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EnableAlarmResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableAlarmResponse) GoString() string {
	return s.String()
}

func (s *EnableAlarmResponse) SetHeaders(v map[string]*string) *EnableAlarmResponse {
	s.Headers = v
	return s
}

func (s *EnableAlarmResponse) SetStatusCode(v int32) *EnableAlarmResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableAlarmResponse) SetBody(v *EnableAlarmResponseBody) *EnableAlarmResponse {
	s.Body = v
	return s
}

type EnableScalingGroupRequest struct {
	// The ID of the scaling configuration that you want to put into the Active state.
	ActiveScalingConfigurationId *string `json:"ActiveScalingConfigurationId,omitempty" xml:"ActiveScalingConfigurationId,omitempty"`
	// The IDs of ECS instances that you want to add to the scaling group after you enable the scaling group.
	//
	// The ECS instances must meet the following requirements:
	//
	// *   The ECS instances and the scaling group must reside in the same region.
	// *   The ECS instances must be in the Running state.
	// *   The ECS instances are not added to other scaling groups.
	// *   The billing method of the ECS instances must be subscription or pay-as-you-go, or the ECS instances must be preemptible instances.
	// *   If you specify the VswitchID parameter for the scaling group, the ECS instances must reside in the same virtual private cloud (VPC) as the specified vSwitch. You cannot add the ECS instances that reside in the classic network or other VPCs to the scaling group.
	// *   If you do not specify the VswitchID parameter for the scaling group, you cannot add ECS instances that reside in VPCs to the scaling group.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The ID of the launch template that is used by Auto Scaling to create ECS instances.
	LaunchTemplateId *string `json:"LaunchTemplateId,omitempty" xml:"LaunchTemplateId,omitempty"`
	// Details of the instance types that you specify by using the Extended Configurations feature of the launch template.
	LaunchTemplateOverrides []*EnableScalingGroupRequestLaunchTemplateOverrides `json:"LaunchTemplateOverrides,omitempty" xml:"LaunchTemplateOverrides,omitempty" type:"Repeated"`
	// The version number of the launch template. Valid values:
	//
	// *   A fixed template version number.
	// *   Default: the default template version.
	// *   Latest: the latest template version.
	LaunchTemplateVersion *string `json:"LaunchTemplateVersion,omitempty" xml:"LaunchTemplateVersion,omitempty"`
	// The weight of an ECS instance as a backend server in the backend vServer group.
	//
	// Default value: 50.
	LoadBalancerWeights []*int32 `json:"LoadBalancerWeights,omitempty" xml:"LoadBalancerWeights,omitempty" type:"Repeated"`
	OwnerAccount        *string  `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId             *int64   `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s EnableScalingGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableScalingGroupRequest) GoString() string {
	return s.String()
}

func (s *EnableScalingGroupRequest) SetActiveScalingConfigurationId(v string) *EnableScalingGroupRequest {
	s.ActiveScalingConfigurationId = &v
	return s
}

func (s *EnableScalingGroupRequest) SetInstanceIds(v []*string) *EnableScalingGroupRequest {
	s.InstanceIds = v
	return s
}

func (s *EnableScalingGroupRequest) SetLaunchTemplateId(v string) *EnableScalingGroupRequest {
	s.LaunchTemplateId = &v
	return s
}

func (s *EnableScalingGroupRequest) SetLaunchTemplateOverrides(v []*EnableScalingGroupRequestLaunchTemplateOverrides) *EnableScalingGroupRequest {
	s.LaunchTemplateOverrides = v
	return s
}

func (s *EnableScalingGroupRequest) SetLaunchTemplateVersion(v string) *EnableScalingGroupRequest {
	s.LaunchTemplateVersion = &v
	return s
}

func (s *EnableScalingGroupRequest) SetLoadBalancerWeights(v []*int32) *EnableScalingGroupRequest {
	s.LoadBalancerWeights = v
	return s
}

func (s *EnableScalingGroupRequest) SetOwnerAccount(v string) *EnableScalingGroupRequest {
	s.OwnerAccount = &v
	return s
}

func (s *EnableScalingGroupRequest) SetOwnerId(v int64) *EnableScalingGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *EnableScalingGroupRequest) SetRegionId(v string) *EnableScalingGroupRequest {
	s.RegionId = &v
	return s
}

func (s *EnableScalingGroupRequest) SetResourceOwnerAccount(v string) *EnableScalingGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *EnableScalingGroupRequest) SetResourceOwnerId(v int64) *EnableScalingGroupRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *EnableScalingGroupRequest) SetScalingGroupId(v string) *EnableScalingGroupRequest {
	s.ScalingGroupId = &v
	return s
}

type EnableScalingGroupRequestLaunchTemplateOverrides struct {
	// The instance type that you want to use to override the instance type that is specified in the launch template.
	//
	// If you want to scale instances based on the weighted capacities of the instances, you must specify both the InstanceType and WeightedCapacity parameters.
	//
	// > This parameter is supported only if you specify the LaunchTemplateId parameter.
	//
	// You can specify an instance type that is available for purchase as the value of the InstanceType parameter.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The weight of the instance type. The weight specifies the capacity of a single instance of the specified instance type in the scaling group. If you want to scale instances based on the weighted capacities of the instances, you must specify the WeightedCapacity parameter after you specify the InstanceType parameter.
	//
	// A higher weight specifies that a smaller number of instances of the specified instance type are required to meet the expected capacity requirement.
	//
	// Performance metrics, such as the number of vCPUs and the memory size of each instance type, may vary. You can specify different weights for different instance types based on your business requirements.
	//
	// Example:
	//
	// *   Current capacity: 0
	// *   Expected capacity: 6
	// *   Capacity of ecs.c5.xlarge: 4
	//
	// To meet the expected capacity requirement, Auto Scaling must create and add two ecs.c5.xlarge instances.
	//
	// > The capacity of the scaling group cannot exceed the sum of the maximum number of instances that is specified by the MaxSize parameter and the maximum weight of the instance types.
	//
	// Valid values of the WeightedCapacity parameter: 1 to 500.
	WeightedCapacity *int32 `json:"WeightedCapacity,omitempty" xml:"WeightedCapacity,omitempty"`
}

func (s EnableScalingGroupRequestLaunchTemplateOverrides) String() string {
	return tea.Prettify(s)
}

func (s EnableScalingGroupRequestLaunchTemplateOverrides) GoString() string {
	return s.String()
}

func (s *EnableScalingGroupRequestLaunchTemplateOverrides) SetInstanceType(v string) *EnableScalingGroupRequestLaunchTemplateOverrides {
	s.InstanceType = &v
	return s
}

func (s *EnableScalingGroupRequestLaunchTemplateOverrides) SetWeightedCapacity(v int32) *EnableScalingGroupRequestLaunchTemplateOverrides {
	s.WeightedCapacity = &v
	return s
}

type EnableScalingGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EnableScalingGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableScalingGroupResponseBody) GoString() string {
	return s.String()
}

func (s *EnableScalingGroupResponseBody) SetRequestId(v string) *EnableScalingGroupResponseBody {
	s.RequestId = &v
	return s
}

type EnableScalingGroupResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EnableScalingGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EnableScalingGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableScalingGroupResponse) GoString() string {
	return s.String()
}

func (s *EnableScalingGroupResponse) SetHeaders(v map[string]*string) *EnableScalingGroupResponse {
	s.Headers = v
	return s
}

func (s *EnableScalingGroupResponse) SetStatusCode(v int32) *EnableScalingGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableScalingGroupResponse) SetBody(v *EnableScalingGroupResponseBody) *EnableScalingGroupResponse {
	s.Body = v
	return s
}

type EnterStandbyRequest struct {
	Async                *bool     `json:"Async,omitempty" xml:"Async,omitempty"`
	ClientToken          *string   `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	InstanceIds          []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	OwnerId              *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ScalingGroupId       *string   `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s EnterStandbyRequest) String() string {
	return tea.Prettify(s)
}

func (s EnterStandbyRequest) GoString() string {
	return s.String()
}

func (s *EnterStandbyRequest) SetAsync(v bool) *EnterStandbyRequest {
	s.Async = &v
	return s
}

func (s *EnterStandbyRequest) SetClientToken(v string) *EnterStandbyRequest {
	s.ClientToken = &v
	return s
}

func (s *EnterStandbyRequest) SetInstanceIds(v []*string) *EnterStandbyRequest {
	s.InstanceIds = v
	return s
}

func (s *EnterStandbyRequest) SetOwnerId(v int64) *EnterStandbyRequest {
	s.OwnerId = &v
	return s
}

func (s *EnterStandbyRequest) SetResourceOwnerAccount(v string) *EnterStandbyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *EnterStandbyRequest) SetScalingGroupId(v string) *EnterStandbyRequest {
	s.ScalingGroupId = &v
	return s
}

type EnterStandbyResponseBody struct {
	RequestId         *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s EnterStandbyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnterStandbyResponseBody) GoString() string {
	return s.String()
}

func (s *EnterStandbyResponseBody) SetRequestId(v string) *EnterStandbyResponseBody {
	s.RequestId = &v
	return s
}

func (s *EnterStandbyResponseBody) SetScalingActivityId(v string) *EnterStandbyResponseBody {
	s.ScalingActivityId = &v
	return s
}

type EnterStandbyResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EnterStandbyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EnterStandbyResponse) String() string {
	return tea.Prettify(s)
}

func (s EnterStandbyResponse) GoString() string {
	return s.String()
}

func (s *EnterStandbyResponse) SetHeaders(v map[string]*string) *EnterStandbyResponse {
	s.Headers = v
	return s
}

func (s *EnterStandbyResponse) SetStatusCode(v int32) *EnterStandbyResponse {
	s.StatusCode = &v
	return s
}

func (s *EnterStandbyResponse) SetBody(v *EnterStandbyResponseBody) *EnterStandbyResponse {
	s.Body = v
	return s
}

type ExecuteScalingRuleRequest struct {
	// The threshold specified when the step scaling rule is executed. Valid values: -9.999999E18 to 9.999999E18.
	BreachThreshold *float32 `json:"BreachThreshold,omitempty" xml:"BreachThreshold,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The metric value specified when the step scaling rule is executed. Valid values: -9.999999E18 to 9.999999E18.
	MetricValue  *float32 `json:"MetricValue,omitempty" xml:"MetricValue,omitempty"`
	OwnerAccount *string  `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64   `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The unique identifier of the scaling rule.
	//
	// > You can call the ExecuteScalingRule operation to execute only simple scaling rules and step scaling rules. To execute a step scaling rule, you must specify the BreachThreshold and MetricValue parameters.
	ScalingRuleAri *string `json:"ScalingRuleAri,omitempty" xml:"ScalingRuleAri,omitempty"`
}

func (s ExecuteScalingRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s ExecuteScalingRuleRequest) GoString() string {
	return s.String()
}

func (s *ExecuteScalingRuleRequest) SetBreachThreshold(v float32) *ExecuteScalingRuleRequest {
	s.BreachThreshold = &v
	return s
}

func (s *ExecuteScalingRuleRequest) SetClientToken(v string) *ExecuteScalingRuleRequest {
	s.ClientToken = &v
	return s
}

func (s *ExecuteScalingRuleRequest) SetMetricValue(v float32) *ExecuteScalingRuleRequest {
	s.MetricValue = &v
	return s
}

func (s *ExecuteScalingRuleRequest) SetOwnerAccount(v string) *ExecuteScalingRuleRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ExecuteScalingRuleRequest) SetOwnerId(v int64) *ExecuteScalingRuleRequest {
	s.OwnerId = &v
	return s
}

func (s *ExecuteScalingRuleRequest) SetRegionId(v string) *ExecuteScalingRuleRequest {
	s.RegionId = &v
	return s
}

func (s *ExecuteScalingRuleRequest) SetResourceOwnerAccount(v string) *ExecuteScalingRuleRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ExecuteScalingRuleRequest) SetResourceOwnerId(v int64) *ExecuteScalingRuleRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ExecuteScalingRuleRequest) SetScalingRuleAri(v string) *ExecuteScalingRuleRequest {
	s.ScalingRuleAri = &v
	return s
}

type ExecuteScalingRuleResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the scaling activity.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s ExecuteScalingRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ExecuteScalingRuleResponseBody) GoString() string {
	return s.String()
}

func (s *ExecuteScalingRuleResponseBody) SetRequestId(v string) *ExecuteScalingRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *ExecuteScalingRuleResponseBody) SetScalingActivityId(v string) *ExecuteScalingRuleResponseBody {
	s.ScalingActivityId = &v
	return s
}

type ExecuteScalingRuleResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ExecuteScalingRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ExecuteScalingRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s ExecuteScalingRuleResponse) GoString() string {
	return s.String()
}

func (s *ExecuteScalingRuleResponse) SetHeaders(v map[string]*string) *ExecuteScalingRuleResponse {
	s.Headers = v
	return s
}

func (s *ExecuteScalingRuleResponse) SetStatusCode(v int32) *ExecuteScalingRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *ExecuteScalingRuleResponse) SetBody(v *ExecuteScalingRuleResponseBody) *ExecuteScalingRuleResponse {
	s.Body = v
	return s
}

type ExitStandbyRequest struct {
	// Specifies whether to put the ECS instance into the Standby state in an asynchronous manner. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	Async *bool `json:"Async,omitempty" xml:"Async,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests.
	//
	// The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The IDs of the ECS instances.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	OwnerId     *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s ExitStandbyRequest) String() string {
	return tea.Prettify(s)
}

func (s ExitStandbyRequest) GoString() string {
	return s.String()
}

func (s *ExitStandbyRequest) SetAsync(v bool) *ExitStandbyRequest {
	s.Async = &v
	return s
}

func (s *ExitStandbyRequest) SetClientToken(v string) *ExitStandbyRequest {
	s.ClientToken = &v
	return s
}

func (s *ExitStandbyRequest) SetInstanceIds(v []*string) *ExitStandbyRequest {
	s.InstanceIds = v
	return s
}

func (s *ExitStandbyRequest) SetOwnerId(v int64) *ExitStandbyRequest {
	s.OwnerId = &v
	return s
}

func (s *ExitStandbyRequest) SetRegionId(v string) *ExitStandbyRequest {
	s.RegionId = &v
	return s
}

func (s *ExitStandbyRequest) SetResourceOwnerAccount(v string) *ExitStandbyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ExitStandbyRequest) SetScalingGroupId(v string) *ExitStandbyRequest {
	s.ScalingGroupId = &v
	return s
}

type ExitStandbyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the scaling activity.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s ExitStandbyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ExitStandbyResponseBody) GoString() string {
	return s.String()
}

func (s *ExitStandbyResponseBody) SetRequestId(v string) *ExitStandbyResponseBody {
	s.RequestId = &v
	return s
}

func (s *ExitStandbyResponseBody) SetScalingActivityId(v string) *ExitStandbyResponseBody {
	s.ScalingActivityId = &v
	return s
}

type ExitStandbyResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ExitStandbyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ExitStandbyResponse) String() string {
	return tea.Prettify(s)
}

func (s ExitStandbyResponse) GoString() string {
	return s.String()
}

func (s *ExitStandbyResponse) SetHeaders(v map[string]*string) *ExitStandbyResponse {
	s.Headers = v
	return s
}

func (s *ExitStandbyResponse) SetStatusCode(v int32) *ExitStandbyResponse {
	s.StatusCode = &v
	return s
}

func (s *ExitStandbyResponse) SetBody(v *ExitStandbyResponseBody) *ExitStandbyResponse {
	s.Body = v
	return s
}

type ListTagKeysRequest struct {
	// The token that determines the start point of the next query. If this parameter is empty, all results are returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerId   *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of entries to return on each page. Maximum value: 50.
	//
	// Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the Auto Scaling resource.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The type of the Auto Scaling resource. Set the value to scalinggroup. This indicates that the tags are added to scaling groups.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s ListTagKeysRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTagKeysRequest) GoString() string {
	return s.String()
}

func (s *ListTagKeysRequest) SetNextToken(v string) *ListTagKeysRequest {
	s.NextToken = &v
	return s
}

func (s *ListTagKeysRequest) SetOwnerId(v int64) *ListTagKeysRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTagKeysRequest) SetPageSize(v int32) *ListTagKeysRequest {
	s.PageSize = &v
	return s
}

func (s *ListTagKeysRequest) SetRegionId(v string) *ListTagKeysRequest {
	s.RegionId = &v
	return s
}

func (s *ListTagKeysRequest) SetResourceOwnerAccount(v string) *ListTagKeysRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTagKeysRequest) SetResourceType(v string) *ListTagKeysRequest {
	s.ResourceType = &v
	return s
}

type ListTagKeysResponseBody struct {
	// Details of the tag keys.
	Keys []*string `json:"Keys,omitempty" xml:"Keys,omitempty" type:"Repeated"`
	// The token that determines the start point of the next query. If this parameter is empty, all results are returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListTagKeysResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTagKeysResponseBody) GoString() string {
	return s.String()
}

func (s *ListTagKeysResponseBody) SetKeys(v []*string) *ListTagKeysResponseBody {
	s.Keys = v
	return s
}

func (s *ListTagKeysResponseBody) SetNextToken(v string) *ListTagKeysResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTagKeysResponseBody) SetPageSize(v int32) *ListTagKeysResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListTagKeysResponseBody) SetRequestId(v string) *ListTagKeysResponseBody {
	s.RequestId = &v
	return s
}

type ListTagKeysResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTagKeysResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTagKeysResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTagKeysResponse) GoString() string {
	return s.String()
}

func (s *ListTagKeysResponse) SetHeaders(v map[string]*string) *ListTagKeysResponse {
	s.Headers = v
	return s
}

func (s *ListTagKeysResponse) SetStatusCode(v int32) *ListTagKeysResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTagKeysResponse) SetBody(v *ListTagKeysResponseBody) *ListTagKeysResponse {
	s.Body = v
	return s
}

type ListTagResourcesRequest struct {
	NextToken            *string                        `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerId              *int64                         `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	RegionId             *string                        `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceIds          []*string                      `json:"ResourceIds,omitempty" xml:"ResourceIds,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string                        `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceType         *string                        `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	Tags                 []*ListTagResourcesRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s ListTagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequest) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequest) SetNextToken(v string) *ListTagResourcesRequest {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesRequest) SetOwnerId(v int64) *ListTagResourcesRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTagResourcesRequest) SetRegionId(v string) *ListTagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceIds(v []*string) *ListTagResourcesRequest {
	s.ResourceIds = v
	return s
}

func (s *ListTagResourcesRequest) SetResourceOwnerAccount(v string) *ListTagResourcesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceType(v string) *ListTagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesRequest) SetTags(v []*ListTagResourcesRequestTags) *ListTagResourcesRequest {
	s.Tags = v
	return s
}

type ListTagResourcesRequestTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTagResourcesRequestTags) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequestTags) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequestTags) SetKey(v string) *ListTagResourcesRequestTags {
	s.Key = &v
	return s
}

func (s *ListTagResourcesRequestTags) SetValue(v string) *ListTagResourcesRequestTags {
	s.Value = &v
	return s
}

type ListTagResourcesResponseBody struct {
	NextToken    *string                                     `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	RequestId    *string                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TagResources []*ListTagResourcesResponseBodyTagResources `json:"TagResources,omitempty" xml:"TagResources,omitempty" type:"Repeated"`
}

func (s ListTagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBody) SetNextToken(v string) *ListTagResourcesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetRequestId(v string) *ListTagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetTagResources(v []*ListTagResourcesResponseBodyTagResources) *ListTagResourcesResponseBody {
	s.TagResources = v
	return s
}

type ListTagResourcesResponseBodyTagResources struct {
	Propagate    *bool   `json:"Propagate,omitempty" xml:"Propagate,omitempty"`
	ResourceId   *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	TagKey       *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	TagValue     *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s ListTagResourcesResponseBodyTagResources) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResources) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResources) SetPropagate(v bool) *ListTagResourcesResponseBodyTagResources {
	s.Propagate = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResources) SetResourceId(v string) *ListTagResourcesResponseBodyTagResources {
	s.ResourceId = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResources) SetResourceType(v string) *ListTagResourcesResponseBodyTagResources {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResources) SetTagKey(v string) *ListTagResourcesResponseBodyTagResources {
	s.TagKey = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResources) SetTagValue(v string) *ListTagResourcesResponseBodyTagResources {
	s.TagValue = &v
	return s
}

type ListTagResourcesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponse) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponse) SetHeaders(v map[string]*string) *ListTagResourcesResponse {
	s.Headers = v
	return s
}

func (s *ListTagResourcesResponse) SetStatusCode(v int32) *ListTagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTagResourcesResponse) SetBody(v *ListTagResourcesResponseBody) *ListTagResourcesResponse {
	s.Body = v
	return s
}

type ListTagValuesRequest struct {
	// The key of the messages that you want to query.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The token that determines the start point of the query. The return value is the value of the NextToken response parameter that was returned last time the QueryInstanceByTag operation was called.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerId   *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The type of the Auto Scaling resource. Only scaling groups are supported. Set the value to scalinggroup.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s ListTagValuesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTagValuesRequest) GoString() string {
	return s.String()
}

func (s *ListTagValuesRequest) SetKey(v string) *ListTagValuesRequest {
	s.Key = &v
	return s
}

func (s *ListTagValuesRequest) SetNextToken(v string) *ListTagValuesRequest {
	s.NextToken = &v
	return s
}

func (s *ListTagValuesRequest) SetOwnerId(v int64) *ListTagValuesRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTagValuesRequest) SetPageSize(v int32) *ListTagValuesRequest {
	s.PageSize = &v
	return s
}

func (s *ListTagValuesRequest) SetRegionId(v string) *ListTagValuesRequest {
	s.RegionId = &v
	return s
}

func (s *ListTagValuesRequest) SetResourceOwnerAccount(v string) *ListTagValuesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTagValuesRequest) SetResourceType(v string) *ListTagValuesRequest {
	s.ResourceType = &v
	return s
}

type ListTagValuesResponseBody struct {
	// The token that is returned for the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information of the tag values.
	Values []*string `json:"Values,omitempty" xml:"Values,omitempty" type:"Repeated"`
}

func (s ListTagValuesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTagValuesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTagValuesResponseBody) SetNextToken(v string) *ListTagValuesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTagValuesResponseBody) SetPageSize(v int32) *ListTagValuesResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListTagValuesResponseBody) SetRequestId(v string) *ListTagValuesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTagValuesResponseBody) SetValues(v []*string) *ListTagValuesResponseBody {
	s.Values = v
	return s
}

type ListTagValuesResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTagValuesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTagValuesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTagValuesResponse) GoString() string {
	return s.String()
}

func (s *ListTagValuesResponse) SetHeaders(v map[string]*string) *ListTagValuesResponse {
	s.Headers = v
	return s
}

func (s *ListTagValuesResponse) SetStatusCode(v int32) *ListTagValuesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTagValuesResponse) SetBody(v *ListTagValuesResponseBody) *ListTagValuesResponse {
	s.Body = v
	return s
}

type ModifyAlarmRequest struct {
	// The unique identifiers of the scaling rules that are associated with the event-triggered task.
	AlarmActions []*string `json:"AlarmActions,omitempty" xml:"AlarmActions,omitempty" type:"Repeated"`
	// The ID of the event-triggered task.
	AlarmTaskId *string `json:"AlarmTaskId,omitempty" xml:"AlarmTaskId,omitempty"`
	// The operator that is used to compare the metric value and the metric threshold. Valid values:
	//
	// *   If the metric value is greater than or equal to the metric threshold, set the value to `>=`.
	// *   If the metric value is less than or equal to the metric threshold, set the value to `<=`.
	// *   If the metric value is greater than the metric threshold, set the value to `>`.
	// *   If the metric value is less than the metric threshold, set the value to `<`.
	ComparisonOperator *string `json:"ComparisonOperator,omitempty" xml:"ComparisonOperator,omitempty"`
	// The description of the event-triggered task.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The dimensions of the metric.
	Dimensions []*ModifyAlarmRequestDimensions `json:"Dimensions,omitempty" xml:"Dimensions,omitempty" type:"Repeated"`
	// The effective period of the event-triggered task.
	//
	// The Effective value follows the cron expression format. The default format is `X X X X X ?`. In the format:
	//
	// *   X: a placeholder for a field, which represents seconds, minutes, hours, days, and months in sequence. X can be a definite value or a special character that has logical meaning. For information about the valid values of X, see [Cron expression](~~25907~~).
	// *   ?: No value is specified.
	//
	// > By default, the value of this parameter is specified in **UTC+8**. You can specify the time zone in the `TZ=+yy` format before a cron expression. y indicates the time zone. For example, `TZ=+00 * * 1-2 * * ?` specifies that the event-triggered task is in effect between 01:00 and 02:59 (UTC+0) every day.
	//
	// Examples:
	//
	// *   ` * * * * * ?  `: The event-triggered task is in effect at all times.
	// *   ` * * 17-18 * * ?  `: The event-triggered task is in effect between 17:00:00 and 18:59:00 (UTC+8) every day.
	// *   `TZ=+00 * * 1-2 * * ?`: The event-triggered task is in effect between 01:00:00 and 02:59:00 (UTC+0) every day.
	Effective *string `json:"Effective,omitempty" xml:"Effective,omitempty"`
	// The number of times that the threshold must be reached before a scaling rule can be executed. For example, if you set this parameter to 3, the average CPU utilization must reach or exceed 80% three times in a row before a scaling rule is triggered.
	EvaluationCount *int32 `json:"EvaluationCount,omitempty" xml:"EvaluationCount,omitempty"`
	// The expressions that are specified in the multi-metric alert rule.
	Expressions []*ModifyAlarmRequestExpressions `json:"Expressions,omitempty" xml:"Expressions,omitempty" type:"Repeated"`
	// The relationship between the trigger conditions in the multi-metric alert rule. Valid values:
	//
	// *   `&&`: An alert is triggered only if all metrics in the multi-metric alert rule meet the trigger conditions. In this case, an alert is triggered only if the results of all trigger conditions that are specified in the multi-metric alert rule are `true`.
	// *   \`\`: An alert is triggered as long as one of the metrics in the multi-metric alert rule meets the trigger condition.
	//
	// Default value: `&&`
	ExpressionsLogicOperator *string `json:"ExpressionsLogicOperator,omitempty" xml:"ExpressionsLogicOperator,omitempty"`
	// The ID of the application group to which the custom metric belongs. This parameter must be specified when MetricType is set to custom.
	GroupId *int32 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the metric. Valid values of MetricName vary based on the value of MetricType.
	//
	// *   If you set MetricType to custom, the valid values of MetricName are your custom metrics.
	//
	// *   If you set MetricType to system, MetricName has the following valid values:
	//
	//     *   CpuUtilization: (ECS) the CPU utilization. Unit: %.
	//     *   IntranetTx: the outbound traffic over the internal network from an ECS instance. Unit: KB/min.
	//     *   IntranetRx: the inbound traffic over the internal network to an ECS instance. Unit: KB/min.
	//     *   VpcInternetTx: the outbound traffic over the Internet from an ECS instance that resides in a virtual private cloud (VPC). Unit: KB/min.
	//     *   VpcInternetRx: the inbound traffic over the Internet to an ECS instance that resides in a VPC. Unit: KB/min.
	//     *   SystemDiskReadBps: the number of bytes read from the system disk that is used by an ECS instance per second.
	//     *   SystemDiskWriteBps: the number of bytes written to the system disk that is used by an ECS instance per second.
	//     *   SystemDiskReadOps: the number of read operations on the system disk that is used by an ECS instance per second.
	//     *   SystemDiskWriteOps: the number of write operations on the system disk that is used by an ECS instance per second.
	//     *   CpuUtilizationAgent: the CPU utilization of an agent. Unit: %.
	//     *   GpuMemoryFreeUtilizationAgent: the percentage of idle GPU memory of an agent.
	//     *   GpuMemoryUtilizationAgent: the GPU memory usage of an agent. Unit: %.
	//     *   MemoryUtilization: the memory usage of an agent. Unit: %.
	//     *   LoadAverage: the average system load of an agent.
	//     *   TcpConnection: the total number of TCP connections of an agent.
	//     *   TcpConnection: the number of established TCP connections of an agent.
	//     *   PackagesNetOut: the number of packets that are sent by the internal network interface controller (NIC) used by an agent.
	//     *   PackagesNetIn: the number of packets that are received by the internal NIC used by an agent.
	//     *   EciPodCpuUtilization: the CPU utilization of an elastic container instance. Unit: %.
	//     *   EciPodMemoryUtilization: the memory usage of an elastic container instance. Unit: %.
	//
	// For more information, see [Event-triggered task for system monitoring](~~74854~~).
	MetricName *string `json:"MetricName,omitempty" xml:"MetricName,omitempty"`
	// The type of the metric. Valid values:
	//
	// *   system: system metrics of CloudMonitor
	// *   custom: custom metrics that are reported to CloudMonitor
	MetricType *string `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
	// The name of the event-triggered task.
	Name    *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The period of time during which statistics about the metric is collected. Unit: seconds. Valid values:
	//
	// *   15
	// *   60
	// *   120
	// *   300
	// *   900
	//
	// > If your scaling group is of the ECS type and uses CloudMonitor metrics, you can set Period to 15. In other cases, you can set Period to 60, 120, 300, or 900. In most cases, the name of a CloudMonitor metric contains Agent.
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The region ID of the event-triggered task.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The method that is used to aggregate statistics for the metric. Valid values:
	//
	// *   Average
	// *   Minimum
	// *   Maximum
	Statistics *string `json:"Statistics,omitempty" xml:"Statistics,omitempty"`
	// The threshold of a metric in the multi-metric alert rule. If the threshold is reached the specified number of times within the specified period, a scaling rule is executed.
	Threshold *float32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s ModifyAlarmRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyAlarmRequest) GoString() string {
	return s.String()
}

func (s *ModifyAlarmRequest) SetAlarmActions(v []*string) *ModifyAlarmRequest {
	s.AlarmActions = v
	return s
}

func (s *ModifyAlarmRequest) SetAlarmTaskId(v string) *ModifyAlarmRequest {
	s.AlarmTaskId = &v
	return s
}

func (s *ModifyAlarmRequest) SetComparisonOperator(v string) *ModifyAlarmRequest {
	s.ComparisonOperator = &v
	return s
}

func (s *ModifyAlarmRequest) SetDescription(v string) *ModifyAlarmRequest {
	s.Description = &v
	return s
}

func (s *ModifyAlarmRequest) SetDimensions(v []*ModifyAlarmRequestDimensions) *ModifyAlarmRequest {
	s.Dimensions = v
	return s
}

func (s *ModifyAlarmRequest) SetEffective(v string) *ModifyAlarmRequest {
	s.Effective = &v
	return s
}

func (s *ModifyAlarmRequest) SetEvaluationCount(v int32) *ModifyAlarmRequest {
	s.EvaluationCount = &v
	return s
}

func (s *ModifyAlarmRequest) SetExpressions(v []*ModifyAlarmRequestExpressions) *ModifyAlarmRequest {
	s.Expressions = v
	return s
}

func (s *ModifyAlarmRequest) SetExpressionsLogicOperator(v string) *ModifyAlarmRequest {
	s.ExpressionsLogicOperator = &v
	return s
}

func (s *ModifyAlarmRequest) SetGroupId(v int32) *ModifyAlarmRequest {
	s.GroupId = &v
	return s
}

func (s *ModifyAlarmRequest) SetMetricName(v string) *ModifyAlarmRequest {
	s.MetricName = &v
	return s
}

func (s *ModifyAlarmRequest) SetMetricType(v string) *ModifyAlarmRequest {
	s.MetricType = &v
	return s
}

func (s *ModifyAlarmRequest) SetName(v string) *ModifyAlarmRequest {
	s.Name = &v
	return s
}

func (s *ModifyAlarmRequest) SetOwnerId(v int64) *ModifyAlarmRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyAlarmRequest) SetPeriod(v int32) *ModifyAlarmRequest {
	s.Period = &v
	return s
}

func (s *ModifyAlarmRequest) SetRegionId(v string) *ModifyAlarmRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyAlarmRequest) SetResourceOwnerAccount(v string) *ModifyAlarmRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyAlarmRequest) SetStatistics(v string) *ModifyAlarmRequest {
	s.Statistics = &v
	return s
}

func (s *ModifyAlarmRequest) SetThreshold(v float32) *ModifyAlarmRequest {
	s.Threshold = &v
	return s
}

type ModifyAlarmRequestDimensions struct {
	// The dimension key of the metric. Valid values of DimensionKey vary based on the value of MetricType.
	//
	// *   If you set MetricType to custom, you can specify this parameter based on your business requirements.
	//
	// *   If you set MetricType to system, DimensionKey has the following valid values:
	//
	//     *   user_id: the ID of your Alibaba Cloud account
	//     *   scaling_group: the scaling group that is monitored by the event-triggered task.
	//     *   device: the type of the NIC.
	//     *   state: the state of the TCP connection
	DimensionKey *string `json:"DimensionKey,omitempty" xml:"DimensionKey,omitempty"`
	// The dimension value of the metric. Valid values of DimensionValue vary based on the value of DimensionKey.
	//
	// *   If you set MetricType to custom, you can specify this parameter based on your business requirements.
	//
	// *   If you set MetricType to system, DimensionKey has the following valid values:
	//
	//     *   user_id: The system specifies the value.
	//
	//     *   scaling_group: The system specifies the value.
	//
	//     *   If you set DimensionKey to device, you can set DimensionValue to eth0 or eth1.
	//
	//         *   For instances that reside in the classic network, eth0 specifies the internal NIC. Only one eth0 NIC exists on each instance that resides in a VPC.
	//         *   For instances that reside in the classic network, eth1 specifies the public NIC.
	//
	//     *   If you set DimensionKey to state, you can set DimensionValue to TCP_TOTAL or ESTABLISHED.
	//
	//         *   TCP_TOTAL specifies the total number of TCP connections.
	//         *   ESTABLISHED specifies the number of established TCP connections.
	DimensionValue *string `json:"DimensionValue,omitempty" xml:"DimensionValue,omitempty"`
}

func (s ModifyAlarmRequestDimensions) String() string {
	return tea.Prettify(s)
}

func (s ModifyAlarmRequestDimensions) GoString() string {
	return s.String()
}

func (s *ModifyAlarmRequestDimensions) SetDimensionKey(v string) *ModifyAlarmRequestDimensions {
	s.DimensionKey = &v
	return s
}

func (s *ModifyAlarmRequestDimensions) SetDimensionValue(v string) *ModifyAlarmRequestDimensions {
	s.DimensionValue = &v
	return s
}

type ModifyAlarmRequestExpressions struct {
	// The operator that is used to compare the metric value and the metric threshold. Valid values:
	//
	// *   If the metric value is greater than or equal to the metric threshold, set the value to `>=`.
	// *   If the metric value is less than or equal to the metric threshold, set the value to `<=`.
	// *   If the metric value is greater than the metric threshold, set the value to `>`.
	// *   If the metric value is less than the metric threshold, set the value to `<`.
	//
	// Default value: >=
	ComparisonOperator *string `json:"ComparisonOperator,omitempty" xml:"ComparisonOperator,omitempty"`
	// The name of the metric that is specified in the multi-metric alert rule. Valid values of MetricName vary based on the value of MetricType.
	//
	// *   If you set MetricType to custom, the valid values of MetricName are your custom metrics.
	//
	// *   If you set MetricType to system, MetricName has the following valid values:
	//
	//     *   CpuUtilization: (ECS) the CPU utilization. Unit: %.
	//     *   IntranetTx: the outbound traffic over the internal network from an ECS instance. Unit: KB/min.
	//     *   IntranetRx: the inbound traffic over the internal network to an ECS instance. Unit: KB/min.
	//     *   VpcInternetTx: the outbound traffic over the Internet from an ECS instance that resides in a VPC. Unit: KB/min.
	//     *   VpcInternetRx: the inbound traffic over the Internet to an ECS instance that resides in a VPC. Unit: KB/min.
	//     *   SystemDiskReadBps: the number of bytes read from the system disk that is used by an ECS instance per second.
	//     *   SystemDiskWriteBps: the number of bytes written to the system disk that is used by an ECS instance per second.
	//     *   SystemDiskReadOps: the number of read operations on the system disk that is used by an ECS instance per second.
	//     *   SystemDiskWriteOps: the number of write operations on the system disk that is used by an ECS instance per second.
	//     *   CpuUtilizationAgent: the CPU utilization of an agent. Unit: %.
	//     *   GpuUtilizationAgent: the GPU utilization of an agent. Unit: %.
	//     *   GpuMemoryFreeUtilizationAgent: the percentage of idle GPU memory of an agent.
	//     *   GpuMemoryUtilizationAgent: the GPU memory usage of an agent. Unit: %.
	//     *   MemoryUtilization: the memory usage of an agent. Unit: %.
	//     *   LoadAverage: the average system load of an agent.
	//     *   TcpConnection: the total number of TCP connections of an agent.
	//     *   TcpConnection: the number of established TCP connections of an agent.
	//     *   PackagesNetOut: the number of packets that are sent by the internal NIC used by an agent.
	//     *   PackagesNetIn: the number of packets that are received by the internal NIC used by an agent.
	//     *   EciPodCpuUtilization: the CPU utilization of an elastic container instance. Unit: %.
	//     *   EciPodMemoryUtilization: the memory usage of an elastic container instance. Unit: %.
	//
	// For more information, see [Event-triggered task for system monitoring](~~74854~~).
	MetricName *string `json:"MetricName,omitempty" xml:"MetricName,omitempty"`
	// The period of time during which the statistics of a metric in the multi-metric alert rule is collected. Unit: seconds. Valid values:
	//
	// *   15
	// *   60
	// *   120
	// *   300
	// *   900
	//
	// > If your scaling group is of the ECS type and uses CloudMonitor metrics, you can set Period to 15. In other cases, you can set Period to 60, 120, 300, or 900. In most cases, the name of a CloudMonitor metric contains Agent.
	//
	// Default value: 300
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The method that is used to aggregate the statistics of a metric that is specified in the multi-metric alert rule. Valid values:
	//
	// *   Average
	// *   Minimum
	// *   Maximum
	Statistics *string `json:"Statistics,omitempty" xml:"Statistics,omitempty"`
	// The threshold of a metric in the multi-metric alert rule. If the threshold is reached the specified number of times within the specified period, a scaling rule is executed.
	Threshold *float32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s ModifyAlarmRequestExpressions) String() string {
	return tea.Prettify(s)
}

func (s ModifyAlarmRequestExpressions) GoString() string {
	return s.String()
}

func (s *ModifyAlarmRequestExpressions) SetComparisonOperator(v string) *ModifyAlarmRequestExpressions {
	s.ComparisonOperator = &v
	return s
}

func (s *ModifyAlarmRequestExpressions) SetMetricName(v string) *ModifyAlarmRequestExpressions {
	s.MetricName = &v
	return s
}

func (s *ModifyAlarmRequestExpressions) SetPeriod(v int32) *ModifyAlarmRequestExpressions {
	s.Period = &v
	return s
}

func (s *ModifyAlarmRequestExpressions) SetStatistics(v string) *ModifyAlarmRequestExpressions {
	s.Statistics = &v
	return s
}

func (s *ModifyAlarmRequestExpressions) SetThreshold(v float32) *ModifyAlarmRequestExpressions {
	s.Threshold = &v
	return s
}

type ModifyAlarmResponseBody struct {
	// The ID of the event-triggered task.
	AlarmTaskId *string `json:"AlarmTaskId,omitempty" xml:"AlarmTaskId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyAlarmResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyAlarmResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyAlarmResponseBody) SetAlarmTaskId(v string) *ModifyAlarmResponseBody {
	s.AlarmTaskId = &v
	return s
}

func (s *ModifyAlarmResponseBody) SetRequestId(v string) *ModifyAlarmResponseBody {
	s.RequestId = &v
	return s
}

type ModifyAlarmResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyAlarmResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyAlarmResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyAlarmResponse) GoString() string {
	return s.String()
}

func (s *ModifyAlarmResponse) SetHeaders(v map[string]*string) *ModifyAlarmResponse {
	s.Headers = v
	return s
}

func (s *ModifyAlarmResponse) SetStatusCode(v int32) *ModifyAlarmResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyAlarmResponse) SetBody(v *ModifyAlarmResponseBody) *ModifyAlarmResponse {
	s.Body = v
	return s
}

type ModifyEciScalingConfigurationRequest struct {
	// Information about the Container Registry Enterprise Edition instance.
	AcrRegistryInfos []*ModifyEciScalingConfigurationRequestAcrRegistryInfos `json:"AcrRegistryInfos,omitempty" xml:"AcrRegistryInfos,omitempty" type:"Repeated"`
	// The validity period. Unit: seconds.
	ActiveDeadlineSeconds *int64 `json:"ActiveDeadlineSeconds,omitempty" xml:"ActiveDeadlineSeconds,omitempty"`
	// Specifies whether to automatically create an elastic IP address (EIP) and bind the EIP to the elastic container instance.
	AutoCreateEip *bool `json:"AutoCreateEip,omitempty" xml:"AutoCreateEip,omitempty"`
	// Specifies whether to automatically match the image cache.
	//
	// Default value: false.
	AutoMatchImageCache *bool `json:"AutoMatchImageCache,omitempty" xml:"AutoMatchImageCache,omitempty"`
	// The name of the elastic container instance. The name must meet the following requirements:
	//
	// *   The name must be 2 to 128 characters in length
	// *   The name can contain only lowercase letters, digits, and hyphens (-). It cannot start or end with a hyphen (-).
	ContainerGroupName *string `json:"ContainerGroupName,omitempty" xml:"ContainerGroupName,omitempty"`
	// The containers.
	Containers           []*ModifyEciScalingConfigurationRequestContainers `json:"Containers,omitempty" xml:"Containers,omitempty" type:"Repeated"`
	ContainersUpdateType *string                                           `json:"ContainersUpdateType,omitempty" xml:"ContainersUpdateType,omitempty"`
	// Specifies whether to enable the cost optimization feature. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	CostOptimization *bool `json:"CostOptimization,omitempty" xml:"CostOptimization,omitempty"`
	// The number of vCPUs of the elastic container instance.
	Cpu *float32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The number of physical CPU cores. This parameter is not available for all instance types. For more information, see [Specify custom CPU options](~~197781~~).
	CpuOptionsCore *int32 `json:"CpuOptionsCore,omitempty" xml:"CpuOptionsCore,omitempty"`
	// The number of threads per core. This parameter is not available for all instance types. A value of 1 indicates that Hyper-Threading is disabled. For more information, see [Specify custom CPU options](~~197781~~).
	CpuOptionsThreadsPerCore *int32  `json:"CpuOptionsThreadsPerCore,omitempty" xml:"CpuOptionsThreadsPerCore,omitempty"`
	DataCacheBucket          *string `json:"DataCacheBucket,omitempty" xml:"DataCacheBucket,omitempty"`
	DataCacheBurstingEnabled *bool   `json:"DataCacheBurstingEnabled,omitempty" xml:"DataCacheBurstingEnabled,omitempty"`
	DataCachePL              *string `json:"DataCachePL,omitempty" xml:"DataCachePL,omitempty"`
	DataCacheProvisionedIops *int32  `json:"DataCacheProvisionedIops,omitempty" xml:"DataCacheProvisionedIops,omitempty"`
	// > This parameter is unavailable.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The IP addresses of the DNS servers.
	DnsConfigNameServers []*string `json:"DnsConfigNameServers,omitempty" xml:"DnsConfigNameServers,omitempty" type:"Repeated"`
	// The options. Each option is a name-value pair. The value in the name-value pair is optional.
	DnsConfigOptions []*ModifyEciScalingConfigurationRequestDnsConfigOptions `json:"DnsConfigOptions,omitempty" xml:"DnsConfigOptions,omitempty" type:"Repeated"`
	// The DNS lookup domains.
	DnsConfigSearchs []*string `json:"DnsConfigSearchs,omitempty" xml:"DnsConfigSearchs,omitempty" type:"Repeated"`
	// The Domain Name System (DNS) policy. Valid values:
	//
	// *   None: uses the DNS that is set for the DnsConfig field.
	// *   Default: use the DNS that is set for the runtime environment.
	DnsPolicy *string `json:"DnsPolicy,omitempty" xml:"DnsPolicy,omitempty"`
	// The maximum outbound bandwidth. Unit: bit/s.
	EgressBandwidth *int64 `json:"EgressBandwidth,omitempty" xml:"EgressBandwidth,omitempty"`
	// The bandwidth of the EIP.
	//
	// Default value: 5. Unit: Mbit/s.
	EipBandwidth *int32 `json:"EipBandwidth,omitempty" xml:"EipBandwidth,omitempty"`
	// > This parameter is unavailable.
	EnableSls *bool `json:"EnableSls,omitempty" xml:"EnableSls,omitempty"`
	// The size of the temporary storage space. By default, an enhanced SSD (ESSD) of the PL1 level is used. Unit: GiB.
	EphemeralStorage *int32 `json:"EphemeralStorage,omitempty" xml:"EphemeralStorage,omitempty"`
	// Information about the hosts.
	HostAliases []*ModifyEciScalingConfigurationRequestHostAliases `json:"HostAliases,omitempty" xml:"HostAliases,omitempty" type:"Repeated"`
	// The name of the elastic container instance.
	HostName *string `json:"HostName,omitempty" xml:"HostName,omitempty"`
	// Information about the image repository.
	ImageRegistryCredentials []*ModifyEciScalingConfigurationRequestImageRegistryCredentials `json:"ImageRegistryCredentials,omitempty" xml:"ImageRegistryCredentials,omitempty" type:"Repeated"`
	// The ID of the image cache.
	ImageSnapshotId *string `json:"ImageSnapshotId,omitempty" xml:"ImageSnapshotId,omitempty"`
	// The maximum inbound bandwidth. Unit: bit/s.
	IngressBandwidth *int64 `json:"IngressBandwidth,omitempty" xml:"IngressBandwidth,omitempty"`
	// The init containers.
	InitContainers []*ModifyEciScalingConfigurationRequestInitContainers `json:"InitContainers,omitempty" xml:"InitContainers,omitempty" type:"Repeated"`
	// The level of the instance type, which is used to filter the instance types that meet the specified criteria. This parameter takes effect only if you set the `CostOptimization` parameter to true. Valid values:
	//
	// *   EntryLevel: shared instance type. Instances of this level are the most cost-effective but may not provide stable computing performance in a consistent manner. Instances of this level are suitable for business scenarios in which the CPU utilization is low. For more information, see [Shared instance families](~~108489~~).
	// *   EnterpriseLevel: Instances of this level provide stable performance and dedicated resources, and are suitable for business scenarios that require high stability. For more information, see [Instance family](~~25378~~).
	// *   CreditEntryLevel: This value is valid only for burstable instances. CPU credits are used to ensure computing performance. Instances of this level are suitable for scenarios in which the CPU utilization is low but may fluctuate in specific cases. For more information, see the [Overview](~~59977~~) topic of burstable instances.
	InstanceFamilyLevel *string   `json:"InstanceFamilyLevel,omitempty" xml:"InstanceFamilyLevel,omitempty"`
	InstanceTypes       []*string `json:"InstanceTypes,omitempty" xml:"InstanceTypes,omitempty" type:"Repeated"`
	// The number of IPv6 addresses.
	Ipv6AddressCount *int32 `json:"Ipv6AddressCount,omitempty" xml:"Ipv6AddressCount,omitempty"`
	// The weight of the elastic container instance as a backend server. Valid values: 1 to 100.
	LoadBalancerWeight *int32 `json:"LoadBalancerWeight,omitempty" xml:"LoadBalancerWeight,omitempty"`
	// The memory size of the elastic container instance. Unit: GiB.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The domain names of the NTP server.
	NtpServers []*string `json:"NtpServers,omitempty" xml:"NtpServers,omitempty" type:"Repeated"`
	OwnerId    *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The name of the RAM role for the instance. You can use an instance RAM role to access both elastic container instances and Elastic Compute Service (ECS) instances. For more information, see [Use an instance RAM role by calling API operations](~~61178~~).
	RamRoleName *string `json:"RamRoleName,omitempty" xml:"RamRoleName,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The instance restart policy. Valid values:
	//
	// *   Always: always restarts the elastic container instance.
	// *   Never: never restarts the elastic container instance.
	// *   OnFailure: restarts the elastic container instance upon failures.
	//
	// Default value: Always.
	RestartPolicy *string `json:"RestartPolicy,omitempty" xml:"RestartPolicy,omitempty"`
	// The ID of the scaling configuration that you want to modify.
	ScalingConfigurationId *string `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
	// The name of the scaling configuration. The name must be 2 to 64 characters in length and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). The name must start with a letter or a digit.
	//
	// The name of the scaling configuration must be unique within a scaling group in a region. If you do not specify this parameter, the value of the ScalingConfigurationId parameter is used.
	ScalingConfigurationName *string `json:"ScalingConfigurationName,omitempty" xml:"ScalingConfigurationName,omitempty"`
	// The system information of the security context in which the elastic container instance runs.
	SecurityContextSysCtls []*ModifyEciScalingConfigurationRequestSecurityContextSysCtls `json:"SecurityContextSysCtls,omitempty" xml:"SecurityContextSysCtls,omitempty" type:"Repeated"`
	// The ID of the security group with which you want to associate the elastic container instance. Elastic container instances that are associated with the same security group can access each other.
	//
	// If you do not specify a security group, the system uses the default security group in the region that you selected. Make sure that the inbound rules of the security group contain the protocols and the port numbers of the containers that you want to expose. If you do not have a default security group in the region, the system creates a default security group, and then adds the declared container protocols and port numbers to the inbound rules of the security group.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// The maximum hourly price of the preemptible elastic container instance. The value can be accurate to three decimal places.
	//
	// If you set the SpotStrategy parameter to SpotWithPriceLimit, you must also specify the SpotPriceLimit parameter.
	SpotPriceLimit *float32 `json:"SpotPriceLimit,omitempty" xml:"SpotPriceLimit,omitempty"`
	// The bidding policy for the elastic container instance. Valid values:
	//
	// *   NoSpot: The instance is a pay-as-you-go instance.
	// *   SpotWithPriceLimit: The instance is a preemptible instance with a user-defined maximum hourly price.
	// *   SpotAsPriceGo: The instance is a preemptible instance for which the market price at the time of purchase is used as the bid price.
	//
	// Default value: NoSpot.
	SpotStrategy *string `json:"SpotStrategy,omitempty" xml:"SpotStrategy,omitempty"`
	// Information about the tags.
	Tags []*ModifyEciScalingConfigurationRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The buffer time in which the program handles operations before the program is stopped. Unit: seconds.
	TerminationGracePeriodSeconds *int64 `json:"TerminationGracePeriodSeconds,omitempty" xml:"TerminationGracePeriodSeconds,omitempty"`
	// Information about the volumes.
	Volumes []*ModifyEciScalingConfigurationRequestVolumes `json:"Volumes,omitempty" xml:"Volumes,omitempty" type:"Repeated"`
}

func (s ModifyEciScalingConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequest) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequest) SetAcrRegistryInfos(v []*ModifyEciScalingConfigurationRequestAcrRegistryInfos) *ModifyEciScalingConfigurationRequest {
	s.AcrRegistryInfos = v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetActiveDeadlineSeconds(v int64) *ModifyEciScalingConfigurationRequest {
	s.ActiveDeadlineSeconds = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetAutoCreateEip(v bool) *ModifyEciScalingConfigurationRequest {
	s.AutoCreateEip = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetAutoMatchImageCache(v bool) *ModifyEciScalingConfigurationRequest {
	s.AutoMatchImageCache = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetContainerGroupName(v string) *ModifyEciScalingConfigurationRequest {
	s.ContainerGroupName = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetContainers(v []*ModifyEciScalingConfigurationRequestContainers) *ModifyEciScalingConfigurationRequest {
	s.Containers = v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetContainersUpdateType(v string) *ModifyEciScalingConfigurationRequest {
	s.ContainersUpdateType = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetCostOptimization(v bool) *ModifyEciScalingConfigurationRequest {
	s.CostOptimization = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetCpu(v float32) *ModifyEciScalingConfigurationRequest {
	s.Cpu = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetCpuOptionsCore(v int32) *ModifyEciScalingConfigurationRequest {
	s.CpuOptionsCore = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetCpuOptionsThreadsPerCore(v int32) *ModifyEciScalingConfigurationRequest {
	s.CpuOptionsThreadsPerCore = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetDataCacheBucket(v string) *ModifyEciScalingConfigurationRequest {
	s.DataCacheBucket = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetDataCacheBurstingEnabled(v bool) *ModifyEciScalingConfigurationRequest {
	s.DataCacheBurstingEnabled = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetDataCachePL(v string) *ModifyEciScalingConfigurationRequest {
	s.DataCachePL = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetDataCacheProvisionedIops(v int32) *ModifyEciScalingConfigurationRequest {
	s.DataCacheProvisionedIops = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetDescription(v string) *ModifyEciScalingConfigurationRequest {
	s.Description = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetDnsConfigNameServers(v []*string) *ModifyEciScalingConfigurationRequest {
	s.DnsConfigNameServers = v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetDnsConfigOptions(v []*ModifyEciScalingConfigurationRequestDnsConfigOptions) *ModifyEciScalingConfigurationRequest {
	s.DnsConfigOptions = v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetDnsConfigSearchs(v []*string) *ModifyEciScalingConfigurationRequest {
	s.DnsConfigSearchs = v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetDnsPolicy(v string) *ModifyEciScalingConfigurationRequest {
	s.DnsPolicy = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetEgressBandwidth(v int64) *ModifyEciScalingConfigurationRequest {
	s.EgressBandwidth = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetEipBandwidth(v int32) *ModifyEciScalingConfigurationRequest {
	s.EipBandwidth = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetEnableSls(v bool) *ModifyEciScalingConfigurationRequest {
	s.EnableSls = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetEphemeralStorage(v int32) *ModifyEciScalingConfigurationRequest {
	s.EphemeralStorage = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetHostAliases(v []*ModifyEciScalingConfigurationRequestHostAliases) *ModifyEciScalingConfigurationRequest {
	s.HostAliases = v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetHostName(v string) *ModifyEciScalingConfigurationRequest {
	s.HostName = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetImageRegistryCredentials(v []*ModifyEciScalingConfigurationRequestImageRegistryCredentials) *ModifyEciScalingConfigurationRequest {
	s.ImageRegistryCredentials = v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetImageSnapshotId(v string) *ModifyEciScalingConfigurationRequest {
	s.ImageSnapshotId = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetIngressBandwidth(v int64) *ModifyEciScalingConfigurationRequest {
	s.IngressBandwidth = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetInitContainers(v []*ModifyEciScalingConfigurationRequestInitContainers) *ModifyEciScalingConfigurationRequest {
	s.InitContainers = v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetInstanceFamilyLevel(v string) *ModifyEciScalingConfigurationRequest {
	s.InstanceFamilyLevel = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetInstanceTypes(v []*string) *ModifyEciScalingConfigurationRequest {
	s.InstanceTypes = v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetIpv6AddressCount(v int32) *ModifyEciScalingConfigurationRequest {
	s.Ipv6AddressCount = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetLoadBalancerWeight(v int32) *ModifyEciScalingConfigurationRequest {
	s.LoadBalancerWeight = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetMemory(v float32) *ModifyEciScalingConfigurationRequest {
	s.Memory = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetNtpServers(v []*string) *ModifyEciScalingConfigurationRequest {
	s.NtpServers = v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetOwnerId(v int64) *ModifyEciScalingConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetRamRoleName(v string) *ModifyEciScalingConfigurationRequest {
	s.RamRoleName = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetResourceGroupId(v string) *ModifyEciScalingConfigurationRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetResourceOwnerAccount(v string) *ModifyEciScalingConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetRestartPolicy(v string) *ModifyEciScalingConfigurationRequest {
	s.RestartPolicy = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetScalingConfigurationId(v string) *ModifyEciScalingConfigurationRequest {
	s.ScalingConfigurationId = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetScalingConfigurationName(v string) *ModifyEciScalingConfigurationRequest {
	s.ScalingConfigurationName = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetSecurityContextSysCtls(v []*ModifyEciScalingConfigurationRequestSecurityContextSysCtls) *ModifyEciScalingConfigurationRequest {
	s.SecurityContextSysCtls = v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetSecurityGroupId(v string) *ModifyEciScalingConfigurationRequest {
	s.SecurityGroupId = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetSpotPriceLimit(v float32) *ModifyEciScalingConfigurationRequest {
	s.SpotPriceLimit = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetSpotStrategy(v string) *ModifyEciScalingConfigurationRequest {
	s.SpotStrategy = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetTags(v []*ModifyEciScalingConfigurationRequestTags) *ModifyEciScalingConfigurationRequest {
	s.Tags = v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetTerminationGracePeriodSeconds(v int64) *ModifyEciScalingConfigurationRequest {
	s.TerminationGracePeriodSeconds = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetVolumes(v []*ModifyEciScalingConfigurationRequestVolumes) *ModifyEciScalingConfigurationRequest {
	s.Volumes = v
	return s
}

type ModifyEciScalingConfigurationRequestAcrRegistryInfos struct {
	// The domain names of the Container Registry Enterprise Edition instances. By default, all domain names of the Container Registry Enterprise Edition instances are displayed. You can specify one or more domain names. Separate multiple domain names with commas (,).
	Domains []*string `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Repeated"`
	// The ID of the Container Registry Enterprise Edition instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the Container Registry Enterprise Edition instance.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The region ID of the Container Registry Enterprise Edition instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestAcrRegistryInfos) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestAcrRegistryInfos) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestAcrRegistryInfos) SetDomains(v []*string) *ModifyEciScalingConfigurationRequestAcrRegistryInfos {
	s.Domains = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestAcrRegistryInfos) SetInstanceId(v string) *ModifyEciScalingConfigurationRequestAcrRegistryInfos {
	s.InstanceId = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestAcrRegistryInfos) SetInstanceName(v string) *ModifyEciScalingConfigurationRequestAcrRegistryInfos {
	s.InstanceName = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestAcrRegistryInfos) SetRegionId(v string) *ModifyEciScalingConfigurationRequestAcrRegistryInfos {
	s.RegionId = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainers struct {
	LivenessProbe   *ModifyEciScalingConfigurationRequestContainersLivenessProbe   `json:"LivenessProbe,omitempty" xml:"LivenessProbe,omitempty" type:"Struct"`
	ReadinessProbe  *ModifyEciScalingConfigurationRequestContainersReadinessProbe  `json:"ReadinessProbe,omitempty" xml:"ReadinessProbe,omitempty" type:"Struct"`
	SecurityContext *ModifyEciScalingConfigurationRequestContainersSecurityContext `json:"SecurityContext,omitempty" xml:"SecurityContext,omitempty" type:"Struct"`
	// The arguments that correspond to the startup commands of the container. You can specify up to 10 arguments.
	Args []*string `json:"Args,omitempty" xml:"Args,omitempty" type:"Repeated"`
	// The commands that you want to execute in the container when you use the command line interface (CLI) to perform probes.
	Commands []*string `json:"Commands,omitempty" xml:"Commands,omitempty" type:"Repeated"`
	// The number of vCPUs that you want to allocate to the container.
	Cpu *float32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// Information about the environment variables.
	EnvironmentVars []*ModifyEciScalingConfigurationRequestContainersEnvironmentVars `json:"EnvironmentVars,omitempty" xml:"EnvironmentVars,omitempty" type:"Repeated"`
	// The number of GPUs that you want to allocate to the container.
	Gpu *int32 `json:"Gpu,omitempty" xml:"Gpu,omitempty"`
	// The image of the container.
	Image *string `json:"Image,omitempty" xml:"Image,omitempty"`
	// The image pulling policy. Valid values:
	//
	// *   Always: pulls images each time.
	// *   IfNotPresent: pulls images only if no on-premises images are available. On-premises images are preferentially used. If no on-premises images are available, image pulling is performed.
	// *   Never: never pulls images. On-premises images are always used.
	ImagePullPolicy *string `json:"ImagePullPolicy,omitempty" xml:"ImagePullPolicy,omitempty"`
	// The memory size of the container. Unit: GiB.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The name of the container image.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Information about the ports.
	Ports []*ModifyEciScalingConfigurationRequestContainersPorts `json:"Ports,omitempty" xml:"Ports,omitempty" type:"Repeated"`
	// Specifies whether the container allocates buffer resources to standard input streams when the container is running. If you do not specify this parameter, an end-of-file (EOF) error may occur.
	//
	// Default value: false.
	Stdin *bool `json:"Stdin,omitempty" xml:"Stdin,omitempty"`
	// Specifies whether standard input streams are disconnected after a client is disconnected.
	//
	// If you set the StdinOnce parameter to true, standard input streams are connected after the container is started, and remain idle until a client is connected to receive data. After the client is disconnected, streams are also disconnected, and remain disconnected until the container is started again.
	StdinOnce *bool `json:"StdinOnce,omitempty" xml:"StdinOnce,omitempty"`
	// Specifies whether to enable interaction. Default value: false.
	//
	// If the command is a /bin/bash command, set the value to true.
	Tty *bool `json:"Tty,omitempty" xml:"Tty,omitempty"`
	// Information about the volume mount of the container.
	VolumeMounts []*ModifyEciScalingConfigurationRequestContainersVolumeMounts `json:"VolumeMounts,omitempty" xml:"VolumeMounts,omitempty" type:"Repeated"`
	// The working directory of the container.
	WorkingDir *string `json:"WorkingDir,omitempty" xml:"WorkingDir,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainers) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainers) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetLivenessProbe(v *ModifyEciScalingConfigurationRequestContainersLivenessProbe) *ModifyEciScalingConfigurationRequestContainers {
	s.LivenessProbe = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetReadinessProbe(v *ModifyEciScalingConfigurationRequestContainersReadinessProbe) *ModifyEciScalingConfigurationRequestContainers {
	s.ReadinessProbe = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetSecurityContext(v *ModifyEciScalingConfigurationRequestContainersSecurityContext) *ModifyEciScalingConfigurationRequestContainers {
	s.SecurityContext = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetArgs(v []*string) *ModifyEciScalingConfigurationRequestContainers {
	s.Args = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetCommands(v []*string) *ModifyEciScalingConfigurationRequestContainers {
	s.Commands = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetCpu(v float32) *ModifyEciScalingConfigurationRequestContainers {
	s.Cpu = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetEnvironmentVars(v []*ModifyEciScalingConfigurationRequestContainersEnvironmentVars) *ModifyEciScalingConfigurationRequestContainers {
	s.EnvironmentVars = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetGpu(v int32) *ModifyEciScalingConfigurationRequestContainers {
	s.Gpu = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetImage(v string) *ModifyEciScalingConfigurationRequestContainers {
	s.Image = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetImagePullPolicy(v string) *ModifyEciScalingConfigurationRequestContainers {
	s.ImagePullPolicy = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetMemory(v float32) *ModifyEciScalingConfigurationRequestContainers {
	s.Memory = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetName(v string) *ModifyEciScalingConfigurationRequestContainers {
	s.Name = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetPorts(v []*ModifyEciScalingConfigurationRequestContainersPorts) *ModifyEciScalingConfigurationRequestContainers {
	s.Ports = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetStdin(v bool) *ModifyEciScalingConfigurationRequestContainers {
	s.Stdin = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetStdinOnce(v bool) *ModifyEciScalingConfigurationRequestContainers {
	s.StdinOnce = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetTty(v bool) *ModifyEciScalingConfigurationRequestContainers {
	s.Tty = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetVolumeMounts(v []*ModifyEciScalingConfigurationRequestContainersVolumeMounts) *ModifyEciScalingConfigurationRequestContainers {
	s.VolumeMounts = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetWorkingDir(v string) *ModifyEciScalingConfigurationRequestContainers {
	s.WorkingDir = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainersLivenessProbe struct {
	Exec                *ModifyEciScalingConfigurationRequestContainersLivenessProbeExec      `json:"Exec,omitempty" xml:"Exec,omitempty" type:"Struct"`
	FailureThreshold    *int32                                                                `json:"FailureThreshold,omitempty" xml:"FailureThreshold,omitempty"`
	HttpGet             *ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet   `json:"HttpGet,omitempty" xml:"HttpGet,omitempty" type:"Struct"`
	InitialDelaySeconds *int32                                                                `json:"InitialDelaySeconds,omitempty" xml:"InitialDelaySeconds,omitempty"`
	PeriodSeconds       *int32                                                                `json:"PeriodSeconds,omitempty" xml:"PeriodSeconds,omitempty"`
	SuccessThreshold    *int32                                                                `json:"SuccessThreshold,omitempty" xml:"SuccessThreshold,omitempty"`
	TcpSocket           *ModifyEciScalingConfigurationRequestContainersLivenessProbeTcpSocket `json:"TcpSocket,omitempty" xml:"TcpSocket,omitempty" type:"Struct"`
	TimeoutSeconds      *int32                                                                `json:"TimeoutSeconds,omitempty" xml:"TimeoutSeconds,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainersLivenessProbe) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersLivenessProbe) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbe) SetExec(v *ModifyEciScalingConfigurationRequestContainersLivenessProbeExec) *ModifyEciScalingConfigurationRequestContainersLivenessProbe {
	s.Exec = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbe) SetFailureThreshold(v int32) *ModifyEciScalingConfigurationRequestContainersLivenessProbe {
	s.FailureThreshold = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbe) SetHttpGet(v *ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet) *ModifyEciScalingConfigurationRequestContainersLivenessProbe {
	s.HttpGet = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbe) SetInitialDelaySeconds(v int32) *ModifyEciScalingConfigurationRequestContainersLivenessProbe {
	s.InitialDelaySeconds = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbe) SetPeriodSeconds(v int32) *ModifyEciScalingConfigurationRequestContainersLivenessProbe {
	s.PeriodSeconds = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbe) SetSuccessThreshold(v int32) *ModifyEciScalingConfigurationRequestContainersLivenessProbe {
	s.SuccessThreshold = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbe) SetTcpSocket(v *ModifyEciScalingConfigurationRequestContainersLivenessProbeTcpSocket) *ModifyEciScalingConfigurationRequestContainersLivenessProbe {
	s.TcpSocket = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbe) SetTimeoutSeconds(v int32) *ModifyEciScalingConfigurationRequestContainersLivenessProbe {
	s.TimeoutSeconds = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainersLivenessProbeExec struct {
	Commands []*string `json:"Commands,omitempty" xml:"Commands,omitempty" type:"Repeated"`
}

func (s ModifyEciScalingConfigurationRequestContainersLivenessProbeExec) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersLivenessProbeExec) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbeExec) SetCommands(v []*string) *ModifyEciScalingConfigurationRequestContainersLivenessProbeExec {
	s.Commands = v
	return s
}

type ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet struct {
	Path   *string `json:"Path,omitempty" xml:"Path,omitempty"`
	Port   *int32  `json:"Port,omitempty" xml:"Port,omitempty"`
	Scheme *string `json:"Scheme,omitempty" xml:"Scheme,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet) SetPath(v string) *ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet {
	s.Path = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet) SetPort(v int32) *ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet {
	s.Port = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet) SetScheme(v string) *ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet {
	s.Scheme = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainersLivenessProbeTcpSocket struct {
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainersLivenessProbeTcpSocket) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersLivenessProbeTcpSocket) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbeTcpSocket) SetPort(v int32) *ModifyEciScalingConfigurationRequestContainersLivenessProbeTcpSocket {
	s.Port = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainersReadinessProbe struct {
	Exec                *ModifyEciScalingConfigurationRequestContainersReadinessProbeExec      `json:"Exec,omitempty" xml:"Exec,omitempty" type:"Struct"`
	FailureThreshold    *int32                                                                 `json:"FailureThreshold,omitempty" xml:"FailureThreshold,omitempty"`
	HttpGet             *ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet   `json:"HttpGet,omitempty" xml:"HttpGet,omitempty" type:"Struct"`
	InitialDelaySeconds *int32                                                                 `json:"InitialDelaySeconds,omitempty" xml:"InitialDelaySeconds,omitempty"`
	PeriodSeconds       *int32                                                                 `json:"PeriodSeconds,omitempty" xml:"PeriodSeconds,omitempty"`
	SuccessThreshold    *int32                                                                 `json:"SuccessThreshold,omitempty" xml:"SuccessThreshold,omitempty"`
	TcpSocket           *ModifyEciScalingConfigurationRequestContainersReadinessProbeTcpSocket `json:"TcpSocket,omitempty" xml:"TcpSocket,omitempty" type:"Struct"`
	TimeoutSeconds      *int32                                                                 `json:"TimeoutSeconds,omitempty" xml:"TimeoutSeconds,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainersReadinessProbe) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersReadinessProbe) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbe) SetExec(v *ModifyEciScalingConfigurationRequestContainersReadinessProbeExec) *ModifyEciScalingConfigurationRequestContainersReadinessProbe {
	s.Exec = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbe) SetFailureThreshold(v int32) *ModifyEciScalingConfigurationRequestContainersReadinessProbe {
	s.FailureThreshold = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbe) SetHttpGet(v *ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet) *ModifyEciScalingConfigurationRequestContainersReadinessProbe {
	s.HttpGet = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbe) SetInitialDelaySeconds(v int32) *ModifyEciScalingConfigurationRequestContainersReadinessProbe {
	s.InitialDelaySeconds = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbe) SetPeriodSeconds(v int32) *ModifyEciScalingConfigurationRequestContainersReadinessProbe {
	s.PeriodSeconds = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbe) SetSuccessThreshold(v int32) *ModifyEciScalingConfigurationRequestContainersReadinessProbe {
	s.SuccessThreshold = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbe) SetTcpSocket(v *ModifyEciScalingConfigurationRequestContainersReadinessProbeTcpSocket) *ModifyEciScalingConfigurationRequestContainersReadinessProbe {
	s.TcpSocket = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbe) SetTimeoutSeconds(v int32) *ModifyEciScalingConfigurationRequestContainersReadinessProbe {
	s.TimeoutSeconds = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainersReadinessProbeExec struct {
	Commands []*string `json:"Commands,omitempty" xml:"Commands,omitempty" type:"Repeated"`
}

func (s ModifyEciScalingConfigurationRequestContainersReadinessProbeExec) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersReadinessProbeExec) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbeExec) SetCommands(v []*string) *ModifyEciScalingConfigurationRequestContainersReadinessProbeExec {
	s.Commands = v
	return s
}

type ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet struct {
	Path   *string `json:"Path,omitempty" xml:"Path,omitempty"`
	Port   *int32  `json:"Port,omitempty" xml:"Port,omitempty"`
	Scheme *string `json:"Scheme,omitempty" xml:"Scheme,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet) SetPath(v string) *ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet {
	s.Path = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet) SetPort(v int32) *ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet {
	s.Port = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet) SetScheme(v string) *ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet {
	s.Scheme = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainersReadinessProbeTcpSocket struct {
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainersReadinessProbeTcpSocket) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersReadinessProbeTcpSocket) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbeTcpSocket) SetPort(v int32) *ModifyEciScalingConfigurationRequestContainersReadinessProbeTcpSocket {
	s.Port = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainersSecurityContext struct {
	Capability             *ModifyEciScalingConfigurationRequestContainersSecurityContextCapability `json:"Capability,omitempty" xml:"Capability,omitempty" type:"Struct"`
	ReadOnlyRootFilesystem *bool                                                                    `json:"ReadOnlyRootFilesystem,omitempty" xml:"ReadOnlyRootFilesystem,omitempty"`
	RunAsUser              *int64                                                                   `json:"RunAsUser,omitempty" xml:"RunAsUser,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainersSecurityContext) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersSecurityContext) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersSecurityContext) SetCapability(v *ModifyEciScalingConfigurationRequestContainersSecurityContextCapability) *ModifyEciScalingConfigurationRequestContainersSecurityContext {
	s.Capability = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersSecurityContext) SetReadOnlyRootFilesystem(v bool) *ModifyEciScalingConfigurationRequestContainersSecurityContext {
	s.ReadOnlyRootFilesystem = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersSecurityContext) SetRunAsUser(v int64) *ModifyEciScalingConfigurationRequestContainersSecurityContext {
	s.RunAsUser = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainersSecurityContextCapability struct {
	Adds []*string `json:"Adds,omitempty" xml:"Adds,omitempty" type:"Repeated"`
}

func (s ModifyEciScalingConfigurationRequestContainersSecurityContextCapability) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersSecurityContextCapability) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersSecurityContextCapability) SetAdds(v []*string) *ModifyEciScalingConfigurationRequestContainersSecurityContextCapability {
	s.Adds = v
	return s
}

type ModifyEciScalingConfigurationRequestContainersEnvironmentVars struct {
	FieldRef *ModifyEciScalingConfigurationRequestContainersEnvironmentVarsFieldRef `json:"FieldRef,omitempty" xml:"FieldRef,omitempty" type:"Struct"`
	// The key of the environment variable. Specify the name in the `[0-9a-zA-Z]` format. The name must be 1 to 128 characters in length, and can contain underscores (\_). It cannot start with a digit.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the environment variable. The value must be 0 to 256 characters in length.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainersEnvironmentVars) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersEnvironmentVars) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersEnvironmentVars) SetFieldRef(v *ModifyEciScalingConfigurationRequestContainersEnvironmentVarsFieldRef) *ModifyEciScalingConfigurationRequestContainersEnvironmentVars {
	s.FieldRef = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersEnvironmentVars) SetKey(v string) *ModifyEciScalingConfigurationRequestContainersEnvironmentVars {
	s.Key = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersEnvironmentVars) SetValue(v string) *ModifyEciScalingConfigurationRequestContainersEnvironmentVars {
	s.Value = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainersEnvironmentVarsFieldRef struct {
	FieldPath *string `json:"FieldPath,omitempty" xml:"FieldPath,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainersEnvironmentVarsFieldRef) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersEnvironmentVarsFieldRef) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersEnvironmentVarsFieldRef) SetFieldPath(v string) *ModifyEciScalingConfigurationRequestContainersEnvironmentVarsFieldRef {
	s.FieldPath = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainersPorts struct {
	// The port number. Valid values: 1 to 65535.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The type of the protocol. Valid values:
	//
	// *   TCP
	// *   UDP
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainersPorts) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersPorts) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersPorts) SetPort(v int32) *ModifyEciScalingConfigurationRequestContainersPorts {
	s.Port = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersPorts) SetProtocol(v string) *ModifyEciScalingConfigurationRequestContainersPorts {
	s.Protocol = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainersVolumeMounts struct {
	// The path where the container mounts the volume.
	//
	// >  Data stored in the path of the container is directly overwritten by the content of the volume.
	MountPath *string `json:"MountPath,omitempty" xml:"MountPath,omitempty"`
	// The mount propagation setting of the volume. Mount propagation allows the sharing of volumes that are mounted on one container with other containers in the same pod, or even with other pods on the same node. Valid values:
	//
	// *   None: The volume mount does not receive subsequent mounts that are mounted to this volume or its subdirectories.
	// *   HostToCotainer: The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories.
	// *   Bidirectional: This value is similar to HostToCotainer. The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories. In addition, all volume mounts that are created by the container are propagated back to the instance and to all containers of all pods that use the same volume.
	MountPropagation *string `json:"MountPropagation,omitempty" xml:"MountPropagation,omitempty"`
	// The name of the volume. The value of this parameter is the same as the value of the Volumes.Name parameter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Specifies whether the volume is read-only.
	//
	// Default value: false.
	ReadOnly *bool `json:"ReadOnly,omitempty" xml:"ReadOnly,omitempty"`
	// The subdirectory of the volume.
	SubPath *string `json:"SubPath,omitempty" xml:"SubPath,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainersVolumeMounts) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersVolumeMounts) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersVolumeMounts) SetMountPath(v string) *ModifyEciScalingConfigurationRequestContainersVolumeMounts {
	s.MountPath = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersVolumeMounts) SetMountPropagation(v string) *ModifyEciScalingConfigurationRequestContainersVolumeMounts {
	s.MountPropagation = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersVolumeMounts) SetName(v string) *ModifyEciScalingConfigurationRequestContainersVolumeMounts {
	s.Name = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersVolumeMounts) SetReadOnly(v bool) *ModifyEciScalingConfigurationRequestContainersVolumeMounts {
	s.ReadOnly = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersVolumeMounts) SetSubPath(v string) *ModifyEciScalingConfigurationRequestContainersVolumeMounts {
	s.SubPath = &v
	return s
}

type ModifyEciScalingConfigurationRequestDnsConfigOptions struct {
	// The variable name of the option.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The variable value of the option.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestDnsConfigOptions) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestDnsConfigOptions) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestDnsConfigOptions) SetName(v string) *ModifyEciScalingConfigurationRequestDnsConfigOptions {
	s.Name = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestDnsConfigOptions) SetValue(v string) *ModifyEciScalingConfigurationRequestDnsConfigOptions {
	s.Value = &v
	return s
}

type ModifyEciScalingConfigurationRequestHostAliases struct {
	// The hostnames that you want to add.
	Hostnames []*string `json:"Hostnames,omitempty" xml:"Hostnames,omitempty" type:"Repeated"`
	// The IP address that you want to add.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestHostAliases) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestHostAliases) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestHostAliases) SetHostnames(v []*string) *ModifyEciScalingConfigurationRequestHostAliases {
	s.Hostnames = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestHostAliases) SetIp(v string) *ModifyEciScalingConfigurationRequestHostAliases {
	s.Ip = &v
	return s
}

type ModifyEciScalingConfigurationRequestImageRegistryCredentials struct {
	// The password that is used to access the image repository.
	Password *string `json:"Password,omitempty" xml:"Password,omitempty"`
	// The domain name of the image repository.
	Server *string `json:"Server,omitempty" xml:"Server,omitempty"`
	// The username that is used to access the image repository.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestImageRegistryCredentials) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestImageRegistryCredentials) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestImageRegistryCredentials) SetPassword(v string) *ModifyEciScalingConfigurationRequestImageRegistryCredentials {
	s.Password = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestImageRegistryCredentials) SetServer(v string) *ModifyEciScalingConfigurationRequestImageRegistryCredentials {
	s.Server = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestImageRegistryCredentials) SetUserName(v string) *ModifyEciScalingConfigurationRequestImageRegistryCredentials {
	s.UserName = &v
	return s
}

type ModifyEciScalingConfigurationRequestInitContainers struct {
	SecurityContext *ModifyEciScalingConfigurationRequestInitContainersSecurityContext `json:"SecurityContext,omitempty" xml:"SecurityContext,omitempty" type:"Struct"`
	// The startup parameter of the container.
	Args []*string `json:"Args,omitempty" xml:"Args,omitempty" type:"Repeated"`
	// The commands that you want to run to start the container.
	Commands []*string `json:"Commands,omitempty" xml:"Commands,omitempty" type:"Repeated"`
	// The number of vCPUs that you want to allocate to the container.
	Cpu *float32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The number of GPUs that you want to allocate to the container.
	Gpu *int32 `json:"Gpu,omitempty" xml:"Gpu,omitempty"`
	// The container image.
	Image *string `json:"Image,omitempty" xml:"Image,omitempty"`
	// The image pulling policy. Valid values:
	//
	// *   Always: pulls images each time.
	// *   IfNotPresent: pulls images only if no on-premises images are available. On-premises images are preferentially used. If no on-premises images are available, image pulling is performed.
	// *   Never: never pulls images. On-premises images are always used. Image pulling is not performed.
	ImagePullPolicy *string `json:"ImagePullPolicy,omitempty" xml:"ImagePullPolicy,omitempty"`
	// The environment variables of the init container.
	InitContainerEnvironmentVars []*ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars `json:"InitContainerEnvironmentVars,omitempty" xml:"InitContainerEnvironmentVars,omitempty" type:"Repeated"`
	// The ports of the init container.
	InitContainerPorts []*ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts `json:"InitContainerPorts,omitempty" xml:"InitContainerPorts,omitempty" type:"Repeated"`
	// Information about the volume mounts of the init container.
	InitContainerVolumeMounts []*ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts `json:"InitContainerVolumeMounts,omitempty" xml:"InitContainerVolumeMounts,omitempty" type:"Repeated"`
	// The size of the memory. Unit: GiB.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The name of the container.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The working directory.
	WorkingDir *string `json:"WorkingDir,omitempty" xml:"WorkingDir,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestInitContainers) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestInitContainers) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetSecurityContext(v *ModifyEciScalingConfigurationRequestInitContainersSecurityContext) *ModifyEciScalingConfigurationRequestInitContainers {
	s.SecurityContext = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetArgs(v []*string) *ModifyEciScalingConfigurationRequestInitContainers {
	s.Args = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetCommands(v []*string) *ModifyEciScalingConfigurationRequestInitContainers {
	s.Commands = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetCpu(v float32) *ModifyEciScalingConfigurationRequestInitContainers {
	s.Cpu = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetGpu(v int32) *ModifyEciScalingConfigurationRequestInitContainers {
	s.Gpu = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetImage(v string) *ModifyEciScalingConfigurationRequestInitContainers {
	s.Image = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetImagePullPolicy(v string) *ModifyEciScalingConfigurationRequestInitContainers {
	s.ImagePullPolicy = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetInitContainerEnvironmentVars(v []*ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) *ModifyEciScalingConfigurationRequestInitContainers {
	s.InitContainerEnvironmentVars = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetInitContainerPorts(v []*ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts) *ModifyEciScalingConfigurationRequestInitContainers {
	s.InitContainerPorts = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetInitContainerVolumeMounts(v []*ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) *ModifyEciScalingConfigurationRequestInitContainers {
	s.InitContainerVolumeMounts = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetMemory(v float32) *ModifyEciScalingConfigurationRequestInitContainers {
	s.Memory = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetName(v string) *ModifyEciScalingConfigurationRequestInitContainers {
	s.Name = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetWorkingDir(v string) *ModifyEciScalingConfigurationRequestInitContainers {
	s.WorkingDir = &v
	return s
}

type ModifyEciScalingConfigurationRequestInitContainersSecurityContext struct {
	Capability             *ModifyEciScalingConfigurationRequestInitContainersSecurityContextCapability `json:"Capability,omitempty" xml:"Capability,omitempty" type:"Struct"`
	ReadOnlyRootFilesystem *bool                                                                        `json:"ReadOnlyRootFilesystem,omitempty" xml:"ReadOnlyRootFilesystem,omitempty"`
	RunAsUser              *int64                                                                       `json:"RunAsUser,omitempty" xml:"RunAsUser,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestInitContainersSecurityContext) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestInitContainersSecurityContext) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestInitContainersSecurityContext) SetCapability(v *ModifyEciScalingConfigurationRequestInitContainersSecurityContextCapability) *ModifyEciScalingConfigurationRequestInitContainersSecurityContext {
	s.Capability = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainersSecurityContext) SetReadOnlyRootFilesystem(v bool) *ModifyEciScalingConfigurationRequestInitContainersSecurityContext {
	s.ReadOnlyRootFilesystem = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainersSecurityContext) SetRunAsUser(v int64) *ModifyEciScalingConfigurationRequestInitContainersSecurityContext {
	s.RunAsUser = &v
	return s
}

type ModifyEciScalingConfigurationRequestInitContainersSecurityContextCapability struct {
	Adds []*string `json:"Adds,omitempty" xml:"Adds,omitempty" type:"Repeated"`
}

func (s ModifyEciScalingConfigurationRequestInitContainersSecurityContextCapability) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestInitContainersSecurityContextCapability) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestInitContainersSecurityContextCapability) SetAdds(v []*string) *ModifyEciScalingConfigurationRequestInitContainersSecurityContextCapability {
	s.Adds = v
	return s
}

type ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars struct {
	FieldRef *ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVarsFieldRef `json:"FieldRef,omitempty" xml:"FieldRef,omitempty" type:"Struct"`
	// The key of the environment variable. The key must be 1 to 128 characters in length. Specify the name in the `[0-9a-zA-Z]` format. The name can contain underscores and cannot start with a digit.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the environment variable. The value must be 0 to 256 characters in length.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) SetFieldRef(v *ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVarsFieldRef) *ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars {
	s.FieldRef = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) SetKey(v string) *ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars {
	s.Key = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) SetValue(v string) *ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars {
	s.Value = &v
	return s
}

type ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVarsFieldRef struct {
	FieldPath *string `json:"FieldPath,omitempty" xml:"FieldPath,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVarsFieldRef) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVarsFieldRef) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVarsFieldRef) SetFieldPath(v string) *ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVarsFieldRef {
	s.FieldPath = &v
	return s
}

type ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts struct {
	// The port number. Valid values: 1 to 65535.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The type of the protocol. Valid values:
	//
	// *   TCP
	// *   UDP
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts) SetPort(v int32) *ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts {
	s.Port = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts) SetProtocol(v string) *ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts {
	s.Protocol = &v
	return s
}

type ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts struct {
	// The path where the container mounts the volume.
	//
	// >  Data stored in the path of the container is overwritten by the content of the volume.
	MountPath *string `json:"MountPath,omitempty" xml:"MountPath,omitempty"`
	// The mount propagation setting of the volume. Mount propagation allows the sharing of volumes that are mounted on one container with other containers in the same pod, or even with other pods on the same node. Valid values:
	//
	// *   None: The volume mount does not receive subsequent mounts that are mounted to this volume or its subdirectories.
	// *   HostToCotainer: The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories.
	// *   Bidirectional: This value is similar to HostToCotainer. The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories. In addition, all volume mounts that are created by the container are propagated back to the instance and to all containers of all pods that use the same volume.
	//
	// Default value: None.
	MountPropagation *string `json:"MountPropagation,omitempty" xml:"MountPropagation,omitempty"`
	// The name of the volume.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Specifies whether the mount path is read-only.
	//
	// Default value: false.
	ReadOnly *bool `json:"ReadOnly,omitempty" xml:"ReadOnly,omitempty"`
	// The subdirectory of the volume. The elastic container instance can mount different directories of the same volume to different subdirectories of containers.
	SubPath *string `json:"SubPath,omitempty" xml:"SubPath,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) SetMountPath(v string) *ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts {
	s.MountPath = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) SetMountPropagation(v string) *ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts {
	s.MountPropagation = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) SetName(v string) *ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts {
	s.Name = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) SetReadOnly(v bool) *ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts {
	s.ReadOnly = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) SetSubPath(v string) *ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts {
	s.SubPath = &v
	return s
}

type ModifyEciScalingConfigurationRequestSecurityContextSysCtls struct {
	// The name of the security context in which the elastic container instance runs.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The variable value of the security context in which the elastic container instance runs.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestSecurityContextSysCtls) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestSecurityContextSysCtls) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestSecurityContextSysCtls) SetName(v string) *ModifyEciScalingConfigurationRequestSecurityContextSysCtls {
	s.Name = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestSecurityContextSysCtls) SetValue(v string) *ModifyEciScalingConfigurationRequestSecurityContextSysCtls {
	s.Value = &v
	return s
}

type ModifyEciScalingConfigurationRequestTags struct {
	// The key of the tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestTags) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestTags) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestTags) SetKey(v string) *ModifyEciScalingConfigurationRequestTags {
	s.Key = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestTags) SetValue(v string) *ModifyEciScalingConfigurationRequestTags {
	s.Value = &v
	return s
}

type ModifyEciScalingConfigurationRequestVolumes struct {
	DiskVolume     *ModifyEciScalingConfigurationRequestVolumesDiskVolume     `json:"DiskVolume,omitempty" xml:"DiskVolume,omitempty" type:"Struct"`
	EmptyDirVolume *ModifyEciScalingConfigurationRequestVolumesEmptyDirVolume `json:"EmptyDirVolume,omitempty" xml:"EmptyDirVolume,omitempty" type:"Struct"`
	FlexVolume     *ModifyEciScalingConfigurationRequestVolumesFlexVolume     `json:"FlexVolume,omitempty" xml:"FlexVolume,omitempty" type:"Struct"`
	HostPathVolume *ModifyEciScalingConfigurationRequestVolumesHostPathVolume `json:"HostPathVolume,omitempty" xml:"HostPathVolume,omitempty" type:"Struct"`
	NFSVolume      *ModifyEciScalingConfigurationRequestVolumesNFSVolume      `json:"NFSVolume,omitempty" xml:"NFSVolume,omitempty" type:"Struct"`
	// The paths to the configuration files.
	ConfigFileVolumeConfigFileToPath []*ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath `json:"ConfigFileVolumeConfigFileToPath,omitempty" xml:"ConfigFileVolumeConfigFileToPath,omitempty" type:"Repeated"`
	// The default permissions on ConfigFileVolume.
	ConfigFileVolumeDefaultMode *int32 `json:"ConfigFileVolumeDefaultMode,omitempty" xml:"ConfigFileVolumeDefaultMode,omitempty"`
	// The name of the volume.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of HostPathVolume. Examples: File, Directory, and Socket.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestVolumes) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestVolumes) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestVolumes) SetDiskVolume(v *ModifyEciScalingConfigurationRequestVolumesDiskVolume) *ModifyEciScalingConfigurationRequestVolumes {
	s.DiskVolume = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumes) SetEmptyDirVolume(v *ModifyEciScalingConfigurationRequestVolumesEmptyDirVolume) *ModifyEciScalingConfigurationRequestVolumes {
	s.EmptyDirVolume = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumes) SetFlexVolume(v *ModifyEciScalingConfigurationRequestVolumesFlexVolume) *ModifyEciScalingConfigurationRequestVolumes {
	s.FlexVolume = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumes) SetHostPathVolume(v *ModifyEciScalingConfigurationRequestVolumesHostPathVolume) *ModifyEciScalingConfigurationRequestVolumes {
	s.HostPathVolume = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumes) SetNFSVolume(v *ModifyEciScalingConfigurationRequestVolumesNFSVolume) *ModifyEciScalingConfigurationRequestVolumes {
	s.NFSVolume = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumes) SetConfigFileVolumeConfigFileToPath(v []*ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath) *ModifyEciScalingConfigurationRequestVolumes {
	s.ConfigFileVolumeConfigFileToPath = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumes) SetConfigFileVolumeDefaultMode(v int32) *ModifyEciScalingConfigurationRequestVolumes {
	s.ConfigFileVolumeDefaultMode = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumes) SetName(v string) *ModifyEciScalingConfigurationRequestVolumes {
	s.Name = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumes) SetType(v string) *ModifyEciScalingConfigurationRequestVolumes {
	s.Type = &v
	return s
}

type ModifyEciScalingConfigurationRequestVolumesDiskVolume struct {
	DiskId   *string `json:"DiskId,omitempty" xml:"DiskId,omitempty"`
	DiskSize *int32  `json:"DiskSize,omitempty" xml:"DiskSize,omitempty"`
	FsType   *string `json:"FsType,omitempty" xml:"FsType,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestVolumesDiskVolume) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestVolumesDiskVolume) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestVolumesDiskVolume) SetDiskId(v string) *ModifyEciScalingConfigurationRequestVolumesDiskVolume {
	s.DiskId = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumesDiskVolume) SetDiskSize(v int32) *ModifyEciScalingConfigurationRequestVolumesDiskVolume {
	s.DiskSize = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumesDiskVolume) SetFsType(v string) *ModifyEciScalingConfigurationRequestVolumesDiskVolume {
	s.FsType = &v
	return s
}

type ModifyEciScalingConfigurationRequestVolumesEmptyDirVolume struct {
	Medium    *string `json:"Medium,omitempty" xml:"Medium,omitempty"`
	SizeLimit *string `json:"SizeLimit,omitempty" xml:"SizeLimit,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestVolumesEmptyDirVolume) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestVolumesEmptyDirVolume) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestVolumesEmptyDirVolume) SetMedium(v string) *ModifyEciScalingConfigurationRequestVolumesEmptyDirVolume {
	s.Medium = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumesEmptyDirVolume) SetSizeLimit(v string) *ModifyEciScalingConfigurationRequestVolumesEmptyDirVolume {
	s.SizeLimit = &v
	return s
}

type ModifyEciScalingConfigurationRequestVolumesFlexVolume struct {
	Driver  *string `json:"Driver,omitempty" xml:"Driver,omitempty"`
	FsType  *string `json:"FsType,omitempty" xml:"FsType,omitempty"`
	Options *string `json:"Options,omitempty" xml:"Options,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestVolumesFlexVolume) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestVolumesFlexVolume) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestVolumesFlexVolume) SetDriver(v string) *ModifyEciScalingConfigurationRequestVolumesFlexVolume {
	s.Driver = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumesFlexVolume) SetFsType(v string) *ModifyEciScalingConfigurationRequestVolumesFlexVolume {
	s.FsType = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumesFlexVolume) SetOptions(v string) *ModifyEciScalingConfigurationRequestVolumesFlexVolume {
	s.Options = &v
	return s
}

type ModifyEciScalingConfigurationRequestVolumesHostPathVolume struct {
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestVolumesHostPathVolume) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestVolumesHostPathVolume) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestVolumesHostPathVolume) SetPath(v string) *ModifyEciScalingConfigurationRequestVolumesHostPathVolume {
	s.Path = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumesHostPathVolume) SetType(v string) *ModifyEciScalingConfigurationRequestVolumesHostPathVolume {
	s.Type = &v
	return s
}

type ModifyEciScalingConfigurationRequestVolumesNFSVolume struct {
	Path     *string `json:"Path,omitempty" xml:"Path,omitempty"`
	ReadOnly *bool   `json:"ReadOnly,omitempty" xml:"ReadOnly,omitempty"`
	Server   *string `json:"Server,omitempty" xml:"Server,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestVolumesNFSVolume) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestVolumesNFSVolume) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestVolumesNFSVolume) SetPath(v string) *ModifyEciScalingConfigurationRequestVolumesNFSVolume {
	s.Path = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumesNFSVolume) SetReadOnly(v bool) *ModifyEciScalingConfigurationRequestVolumesNFSVolume {
	s.ReadOnly = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumesNFSVolume) SetServer(v string) *ModifyEciScalingConfigurationRequestVolumesNFSVolume {
	s.Server = &v
	return s
}

type ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath struct {
	// The content of the configuration file, which can be up to 32 KB in size.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The permissions on ConfigFileVolume.
	Mode *int32 `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The relative path to the configuration file.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath) SetContent(v string) *ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath {
	s.Content = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath) SetMode(v int32) *ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath {
	s.Mode = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath) SetPath(v string) *ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath {
	s.Path = &v
	return s
}

type ModifyEciScalingConfigurationResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyEciScalingConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationResponseBody) SetRequestId(v string) *ModifyEciScalingConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type ModifyEciScalingConfigurationResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyEciScalingConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyEciScalingConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationResponse) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationResponse) SetHeaders(v map[string]*string) *ModifyEciScalingConfigurationResponse {
	s.Headers = v
	return s
}

func (s *ModifyEciScalingConfigurationResponse) SetStatusCode(v int32) *ModifyEciScalingConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyEciScalingConfigurationResponse) SetBody(v *ModifyEciScalingConfigurationResponseBody) *ModifyEciScalingConfigurationResponse {
	s.Body = v
	return s
}

type ModifyLifecycleHookRequest struct {
	// The action that you want Auto Scaling to perform after the lifecycle hook times out. Valid values:
	//
	// *   CONTINUE: Auto Scaling continues to respond to scale-in or scale-out requests.
	// *   ABANDON: Auto Scaling releases Elastic Compute Service (ECS) instances that are created during scale-out activities or removes ECS instances from the scaling group during scale-in activities.
	// *   ROLLBACK: For scale-in activities, Auto Scaling rejects the requests to release ECS instances but rolls back ECS instances. For scale-out activities, the ROLLBACK setting has the same effect as the ABANDON setting.
	//
	// If a scaling group has multiple lifecycle hooks in effect and you set the DefaultResult parameter for one of the lifecycle hooks to ABANDON or ROLLBACK, the following rule applies to scale-in activities: When the lifecycle hook whose DefaultResult parameter is set to ABANDON or ROLLBACK times out, other lifecycle hooks time out ahead of schedule. In other cases, Auto Scaling performs the action only after all lifecycle hooks time out. The action that Auto Scaling performs is specified by the DefaultResult parameter of the last lifecycle hook that times out.
	DefaultResult *string `json:"DefaultResult,omitempty" xml:"DefaultResult,omitempty"`
	// The period of time before the lifecycle hook times out. When the lifecycle hook times out, Auto Scaling performs the action specified by the DefaultResult parameter. Valid values: 30 to 21600. Unit: seconds.
	//
	// You can call the RecordLifecycleActionHeartbeat operation to extend the period of time before a lifecycle hook times out. You can also call the CompleteLifecycleAction operation to end a lifecycle hook ahead of schedule.
	HeartbeatTimeout *int32 `json:"HeartbeatTimeout,omitempty" xml:"HeartbeatTimeout,omitempty"`
	// The ID of the lifecycle hook that you want to modify.
	LifecycleHookId *string `json:"LifecycleHookId,omitempty" xml:"LifecycleHookId,omitempty"`
	// The name of the lifecycle hook that you want to modify.
	LifecycleHookName *string `json:"LifecycleHookName,omitempty" xml:"LifecycleHookName,omitempty"`
	// The status that you want to specify for the lifecycle hook. Valid values:
	//
	// *   Active
	// *   InActive
	//
	// If you do not specify this parameter, the status of the lifecycle hook remains unchanged after you call this operation.
	//
	// > By default, a lifecycle hook is in the Active state after you create it.
	LifecycleHookStatus *string `json:"LifecycleHookStatus,omitempty" xml:"LifecycleHookStatus,omitempty"`
	// The type of the scaling activity to which the lifecycle hook applies. Valid values:
	//
	// *   SCALE_OUT: scale-out activity
	// *   SCALE_IN: scale-in activity
	LifecycleTransition *string `json:"LifecycleTransition,omitempty" xml:"LifecycleTransition,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the notification method.
	//
	// *   If the notification method is a Message Service (MNS) queue, specify the value in the acs:mns:{region-id}:{account-id}:queue/{queuename} format.
	// *   If the notification method is an MNS topic, specify the value in the acs:mns:{region-id}:{account-id}:topic/{topicname} format.
	// *   If the notification method is an Operation Orchestration Service (OOS) template, specify the value in the acs:oos:{region-id}:{account-id}:template/{templatename} format.
	//
	// The variables in the preceding formats have the following meanings:
	//
	// *   region-id: the region ID of the scaling group.
	// *   account-id: the ID of the Alibaba Cloud account.
	// *   queuename: the name of the MNS queue.
	// *   topicname: the name of the MNS topic.
	// *   templatename: the name of the OOS template.
	NotificationArn *string `json:"NotificationArn,omitempty" xml:"NotificationArn,omitempty"`
	// The fixed string that is included in a notification. Auto Scaling sends the notification when the lifecycle hook takes effect. The value of this parameter cannot exceed 4,096 characters in length.
	//
	// Auto Scaling sends the value of the NotificationMetadata parameter together with the notification. This helps you categorize your notifications. If you specify the NotificationMetadata parameter, you must also specify the NotificationArn parameter.
	NotificationMetadata *string `json:"NotificationMetadata,omitempty" xml:"NotificationMetadata,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group to which the lifecycle hook belongs.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s ModifyLifecycleHookRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyLifecycleHookRequest) GoString() string {
	return s.String()
}

func (s *ModifyLifecycleHookRequest) SetDefaultResult(v string) *ModifyLifecycleHookRequest {
	s.DefaultResult = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetHeartbeatTimeout(v int32) *ModifyLifecycleHookRequest {
	s.HeartbeatTimeout = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetLifecycleHookId(v string) *ModifyLifecycleHookRequest {
	s.LifecycleHookId = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetLifecycleHookName(v string) *ModifyLifecycleHookRequest {
	s.LifecycleHookName = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetLifecycleHookStatus(v string) *ModifyLifecycleHookRequest {
	s.LifecycleHookStatus = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetLifecycleTransition(v string) *ModifyLifecycleHookRequest {
	s.LifecycleTransition = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetNotificationArn(v string) *ModifyLifecycleHookRequest {
	s.NotificationArn = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetNotificationMetadata(v string) *ModifyLifecycleHookRequest {
	s.NotificationMetadata = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetOwnerAccount(v string) *ModifyLifecycleHookRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetOwnerId(v int64) *ModifyLifecycleHookRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetRegionId(v string) *ModifyLifecycleHookRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetResourceOwnerAccount(v string) *ModifyLifecycleHookRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetScalingGroupId(v string) *ModifyLifecycleHookRequest {
	s.ScalingGroupId = &v
	return s
}

type ModifyLifecycleHookResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyLifecycleHookResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyLifecycleHookResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyLifecycleHookResponseBody) SetRequestId(v string) *ModifyLifecycleHookResponseBody {
	s.RequestId = &v
	return s
}

type ModifyLifecycleHookResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyLifecycleHookResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyLifecycleHookResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyLifecycleHookResponse) GoString() string {
	return s.String()
}

func (s *ModifyLifecycleHookResponse) SetHeaders(v map[string]*string) *ModifyLifecycleHookResponse {
	s.Headers = v
	return s
}

func (s *ModifyLifecycleHookResponse) SetStatusCode(v int32) *ModifyLifecycleHookResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyLifecycleHookResponse) SetBody(v *ModifyLifecycleHookResponseBody) *ModifyLifecycleHookResponse {
	s.Body = v
	return s
}

type ModifyNotificationConfigurationRequest struct {
	// The Alibaba Cloud Resource Name (ARN) of the notification method. The following list describes the value formats of this parameter:
	//
	// *   If you use CloudMonitor as the notification method, the value format of this parameter is acs:ess:{region-id}:{account-id}:cloudmonitor.
	// *   If you use an MNS queue as the notification method, the value format of this parameter is acs:mns:{region-id}:{account-id}:queue/{queuename}.
	// *   If you use an MNS topic as the notification method, the value format of this parameter is acs:mns:{region-id}:{account-id}:topic/{topicname}.
	//
	// The variables in the preceding formats have the following meanings:
	//
	// *   region-id: the region ID of the scaling group.
	// *   account-id: the ID of the Alibaba Cloud account.
	// *   queuename: the name of the MNS queue.
	// *   topicname: the name of the MNS topic.
	NotificationArn *string `json:"NotificationArn,omitempty" xml:"NotificationArn,omitempty"`
	// The types of the notifications that you want to modify. You can modify one to eight notifications. Specify multiple values in the repeated list form.
	//
	// You can call the DescribeNotificationTypes operation to query the values of this parameter.
	NotificationTypes []*string `json:"NotificationTypes,omitempty" xml:"NotificationTypes,omitempty" type:"Repeated"`
	OwnerId           *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s ModifyNotificationConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyNotificationConfigurationRequest) GoString() string {
	return s.String()
}

func (s *ModifyNotificationConfigurationRequest) SetNotificationArn(v string) *ModifyNotificationConfigurationRequest {
	s.NotificationArn = &v
	return s
}

func (s *ModifyNotificationConfigurationRequest) SetNotificationTypes(v []*string) *ModifyNotificationConfigurationRequest {
	s.NotificationTypes = v
	return s
}

func (s *ModifyNotificationConfigurationRequest) SetOwnerId(v int64) *ModifyNotificationConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyNotificationConfigurationRequest) SetRegionId(v string) *ModifyNotificationConfigurationRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyNotificationConfigurationRequest) SetResourceOwnerAccount(v string) *ModifyNotificationConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyNotificationConfigurationRequest) SetScalingGroupId(v string) *ModifyNotificationConfigurationRequest {
	s.ScalingGroupId = &v
	return s
}

type ModifyNotificationConfigurationResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyNotificationConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyNotificationConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyNotificationConfigurationResponseBody) SetRequestId(v string) *ModifyNotificationConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type ModifyNotificationConfigurationResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyNotificationConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyNotificationConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyNotificationConfigurationResponse) GoString() string {
	return s.String()
}

func (s *ModifyNotificationConfigurationResponse) SetHeaders(v map[string]*string) *ModifyNotificationConfigurationResponse {
	s.Headers = v
	return s
}

func (s *ModifyNotificationConfigurationResponse) SetStatusCode(v int32) *ModifyNotificationConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyNotificationConfigurationResponse) SetBody(v *ModifyNotificationConfigurationResponseBody) *ModifyNotificationConfigurationResponse {
	s.Body = v
	return s
}

type ModifyScalingConfigurationRequest struct {
	ImageOptions       *ModifyScalingConfigurationRequestImageOptions       `json:"ImageOptions,omitempty" xml:"ImageOptions,omitempty" type:"Struct"`
	PrivatePoolOptions *ModifyScalingConfigurationRequestPrivatePoolOptions `json:"PrivatePoolOptions,omitempty" xml:"PrivatePoolOptions,omitempty" type:"Struct"`
	SystemDisk         *ModifyScalingConfigurationRequestSystemDisk         `json:"SystemDisk,omitempty" xml:"SystemDisk,omitempty" type:"Struct"`
	// Specifies whether to associate an ECS instance on a dedicated host with the dedicated host. Valid values:
	//
	// *   default: does not associate the ECS instance with the dedicated host. If you start an instance that is stopped in economical mode and the original dedicated host has insufficient resources, the instance is automatically deployed to another dedicated host in the automatic deployment resource pool.
	// *   host: associates the ECS instance with the dedicated host. If you start an ECS instance that is stopped in economical mode, the ECS instance remains on the original dedicated host. If the original dedicated host has insufficient resources, the ECS instance fails to start.
	Affinity *string `json:"Affinity,omitempty" xml:"Affinity,omitempty"`
	// The number of vCPUs.
	//
	// You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set Cpu to 2 and Memory to 16 to specify instance types that have 2 vCPUs and 16 GiB of memory. If you specify Cpu and Memory, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances by using the lowest-priced instance type.
	//
	// > You can specify CPU and Memory to determine the range of instance types only if you set Scaling Policy to Cost Optimization Policy and you do not specify an instance type in the scaling configuration.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The performance mode of the burstable instance. Valid values:
	//
	// *   Standard: standard mode. For more information, see the "Standard mode" section in the [Burstable instances](~~59977~~) topic.
	// *   Unlimited: unlimited mode. For more information, see the "Unlimited mode" section in the [Burstable instances](~~59977~~) topic.
	CreditSpecification *string `json:"CreditSpecification,omitempty" xml:"CreditSpecification,omitempty"`
	// The data disks.
	DataDisks []*ModifyScalingConfigurationRequestDataDisks `json:"DataDisks,omitempty" xml:"DataDisks,omitempty" type:"Repeated"`
	// The ID of the dedicated host on which you want to create ECS instances. You cannot create preemptible instances on dedicated hosts. If you specify DedicatedHostId, SpotStrategy and SpotPriceLimit are ignored.
	//
	// You can call the DescribeDedicatedHosts operation to query the most recent list of dedicated host IDs.
	DedicatedHostId    *string `json:"DedicatedHostId,omitempty" xml:"DedicatedHostId,omitempty"`
	DeletionProtection *bool   `json:"DeletionProtection,omitempty" xml:"DeletionProtection,omitempty"`
	// The ID of the deployment set of the ECS instances that are created by using the scaling configuration.
	DeploymentSetId *string `json:"DeploymentSetId,omitempty" xml:"DeploymentSetId,omitempty"`
	// The hostname of the ECS instance. The hostname cannot start or end with a period (.) or a hyphen (-). The hostname cannot contain consecutive periods (.) or hyphens (-). Naming conventions for different types of instances:
	//
	// *   Windows instances: The hostname must be 2 to 15 characters in length, and can contain letters, digits, and hyphens (-). The hostname cannot contain periods (.) or contain only digits.
	// *   Other instances, such as Linux instances: The hostname must be 2 to 64 characters in length. Separate a hostname into multiple segments with periods (.). Each segment can contain letters, digits, and hyphens (-).
	HostName *string `json:"HostName,omitempty" xml:"HostName,omitempty"`
	// The ID of the Elastic High Performance Computing (E-HPC) cluster to which the ECS instances belong.
	HpcClusterId *string `json:"HpcClusterId,omitempty" xml:"HpcClusterId,omitempty"`
	// The name of the image family. If you specify this parameter, the latest custom images that are available in the specified image family are returned. Then, you can use the images to create instances. If you specify ImageId, you cannot specify ImageFamily.
	ImageFamily *string `json:"ImageFamily,omitempty" xml:"ImageFamily,omitempty"`
	// The ID of the image that is used by Auto Scaling to automatically create ECS instances.
	//
	// > If the image that is specified in the scaling configuration contains system disks and data disks, the data that is stored in the data disks is cleared after you modify the image.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The name of the image. Each image name must be unique in a region. If you specify ImageId, ImageName is ignored.
	//
	// You cannot use ImageName to specify images from Alibaba Cloud Marketplace.
	ImageName *string `json:"ImageName,omitempty" xml:"ImageName,omitempty"`
	// The description of the ECS instance. The description must be 2 to 256 characters in length. The description can contain letters but cannot start with `http://` or `https://`.
	InstanceDescription *string `json:"InstanceDescription,omitempty" xml:"InstanceDescription,omitempty"`
	// The name of the Elastic Compute Service (ECS) instance that is automatically created by using the scaling configuration.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The intelligent configuration settings, which determines the range of instance types that meet the specified criteria.
	InstancePatternInfos []*ModifyScalingConfigurationRequestInstancePatternInfos `json:"InstancePatternInfos,omitempty" xml:"InstancePatternInfos,omitempty" type:"Repeated"`
	// The instance types.
	InstanceTypeOverrides []*ModifyScalingConfigurationRequestInstanceTypeOverrides `json:"InstanceTypeOverrides,omitempty" xml:"InstanceTypeOverrides,omitempty" type:"Repeated"`
	// The instance type. If you specify InstanceTypes, InstanceType is ignored.
	//
	// Auto Scaling creates instances based on the priorities of instance types. If Auto Scaling cannot create instances by using the instance type that has the highest priority, Auto Scaling creates instances by using the instance type that has the next highest priority.
	InstanceTypes []*string `json:"InstanceTypes,omitempty" xml:"InstanceTypes,omitempty" type:"Repeated"`
	// The metering method for network usage. Valid values:
	//
	// *   PayByBandwidth: You are charged for the maximum available bandwidth that is specified by InternetMaxBandwidthOut.
	// *   PayByTraffic: You are charged for the actual data transfer. InternetMaxBandwidthOut specifies only the maximum available bandwidth.
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The maximum outbound public bandwidth. Unit: Mbit/s. Valid values:
	//
	// *   If you set InternetChargeType to PayByBandwidth: 0 to 100. If you leave this parameter empty, this parameter is automatically set to 0.
	// *   If you set InternetChargeType to PayByTraffic: 0 to 100. If you leave this parameter empty, an error is returned.
	InternetMaxBandwidthOut *int32 `json:"InternetMaxBandwidthOut,omitempty" xml:"InternetMaxBandwidthOut,omitempty"`
	// Specifies whether to create an I/O optimized instance. Valid values:
	//
	// *   none: does not create an I/O optimized instance.
	// *   optimized: creates an I/O optimized instance.
	IoOptimized *string `json:"IoOptimized,omitempty" xml:"IoOptimized,omitempty"`
	// The number of randomly generated IPv6 addresses that you want to allocate to the elastic network interface (ENI).
	Ipv6AddressCount *int32 `json:"Ipv6AddressCount,omitempty" xml:"Ipv6AddressCount,omitempty"`
	// The name of the key pair that you can use to log on to an ECS instance.
	//
	// *   Windows instances do not support this parameter.
	// *   By default, the username and password authentication method is disabled for Linux instances.
	KeyPairName *string `json:"KeyPairName,omitempty" xml:"KeyPairName,omitempty"`
	// The weight of an ECS instance as a backend server. Valid values: 1 to 100.
	LoadBalancerWeight *int32 `json:"LoadBalancerWeight,omitempty" xml:"LoadBalancerWeight,omitempty"`
	// The memory size. Unit: GiB.
	//
	// You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set Cpu to 2 and Memory to 16 to specify instance types that have 2 vCPUs and 16 GiB of memory. If you specify Cpu and Memory, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances by using the lowest-priced instance type.
	//
	// > You can specify CPU and Memory to determine the range of instance types only if you set Scaling Policy to Cost Optimization Policy and you do not specify an instance type in the scaling configuration.
	Memory *int32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// Specifies whether to overwrite existing data. Valid values:
	//
	// *   true
	// *   false
	Override     *bool   `json:"Override,omitempty" xml:"Override,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Specifies whether to use the password that is preconfigured in the image. Before you use this parameter, make sure that a password is configured in the image.
	PasswordInherit *bool `json:"PasswordInherit,omitempty" xml:"PasswordInherit,omitempty"`
	// The name of the RAM role that you want to attach to the ECS instance. The name is provided and maintained by Resource Access Management (RAM). You can call the ListRoles operation to query the available RAM roles. You can call the CreateRole operation to create RAM roles.
	RamRoleName *string `json:"RamRoleName,omitempty" xml:"RamRoleName,omitempty"`
	// The ID of the resource group to which the ECS instances belong.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling configuration that you want to modify.
	ScalingConfigurationId *string `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
	// The name of the scaling configuration. The name must be 2 to 64 characters in length, and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). The name must start with a letter or a digit.
	//
	// The name of the scaling configuration must be unique in a region. If you do not specify this parameter, the scaling configuration ID is used.
	ScalingConfigurationName *string `json:"ScalingConfigurationName,omitempty" xml:"ScalingConfigurationName,omitempty"`
	// The scheduler options.
	SchedulerOptions map[string]interface{} `json:"SchedulerOptions,omitempty" xml:"SchedulerOptions,omitempty"`
	// The ID of the security group with which ECS instances are associated. The ECS instances that are associated with the same security group can access each other.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// The IDs of the security groups.
	SecurityGroupIds []*string `json:"SecurityGroupIds,omitempty" xml:"SecurityGroupIds,omitempty" type:"Repeated"`
	// The retention period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.
	//
	// *   The following retention periods are available in invitational preview: 2, 3, 4, 5, and 6 hours. If you want to set this parameter to one of these values, submit a ticket.
	// *   If you set this parameter to 0, no retention period is specified for the preemptible instance.
	SpotDuration *int32 `json:"SpotDuration,omitempty" xml:"SpotDuration,omitempty"`
	// The interruption mode of the preemptible instance. Default value: Terminate. Set the value to Terminate. This value specifies that the preemptible instance is to be released.
	SpotInterruptionBehavior *string `json:"SpotInterruptionBehavior,omitempty" xml:"SpotInterruptionBehavior,omitempty"`
	// The preemptible instance types.
	SpotPriceLimits []*ModifyScalingConfigurationRequestSpotPriceLimits `json:"SpotPriceLimits,omitempty" xml:"SpotPriceLimits,omitempty" type:"Repeated"`
	// The preemption policy that you want to apply to pay-as-you-go instances and preemptible instances. Valid values:
	//
	// *   NoSpot: The instance is created as a pay-as-you-go instance.
	// *   SpotWithPriceLimit: The instance is a preemptible instance that has a user-defined maximum hourly price.
	// *   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bidding price.
	SpotStrategy              *string `json:"SpotStrategy,omitempty" xml:"SpotStrategy,omitempty"`
	StorageSetId              *string `json:"StorageSetId,omitempty" xml:"StorageSetId,omitempty"`
	StorageSetPartitionNumber *int32  `json:"StorageSetPartitionNumber,omitempty" xml:"StorageSetPartitionNumber,omitempty"`
	// The categories of the system disks. If Auto Scaling cannot create instances by using the disk category that has the highest priority, Auto Scaling creates instances by using the disk category that has the next highest priority. Valid values:
	//
	// *   cloud: basic disk
	// *   cloud_efficiency: ultra disk
	// *   cloud_ssd: standard SSD
	// *   cloud_essd: ESSD
	//
	// > If you specify SystemDiskCategories, you cannot specify `SystemDisk.Category`.
	SystemDiskCategories []*string `json:"SystemDiskCategories,omitempty" xml:"SystemDiskCategories,omitempty" type:"Repeated"`
	// The tags of the ECS instance. Specify the tags as key-value pairs. You can specify up to 20 tags. When you specify tag keys and tag values, take note of the following items:
	//
	// *   A tag key can be up to 64 characters in length. The key cannot start with `acs:` or `aliyun`, and cannot contain `http://` or `https://`. The tag key cannot be an empty string.
	// *   A tag value can be up to 128 characters in length. The value cannot start with `acs:` or `aliyun`, and cannot contain `http://` or `https://`. The tag value can be an empty string.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// Specifies whether to create an ECS instance on a dedicated host. Valid values:
	//
	// *   default: does not create the ECS instance on a dedicated host.
	// *   host: creates the ECS instance on a dedicated host. If you do not specify DedicatedHostId, Alibaba Cloud selects a dedicated host for the ECS instance.
	Tenancy *string `json:"Tenancy,omitempty" xml:"Tenancy,omitempty"`
	// The user data of the ECS instance. The data must be encoded in Base64. The maximum size of the data before encoding is 16 KB.
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The zone ID of the ECS instances that are created by using the scaling configuration.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s ModifyScalingConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationRequest) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationRequest) SetImageOptions(v *ModifyScalingConfigurationRequestImageOptions) *ModifyScalingConfigurationRequest {
	s.ImageOptions = v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetPrivatePoolOptions(v *ModifyScalingConfigurationRequestPrivatePoolOptions) *ModifyScalingConfigurationRequest {
	s.PrivatePoolOptions = v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetSystemDisk(v *ModifyScalingConfigurationRequestSystemDisk) *ModifyScalingConfigurationRequest {
	s.SystemDisk = v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetAffinity(v string) *ModifyScalingConfigurationRequest {
	s.Affinity = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetCpu(v int32) *ModifyScalingConfigurationRequest {
	s.Cpu = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetCreditSpecification(v string) *ModifyScalingConfigurationRequest {
	s.CreditSpecification = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetDataDisks(v []*ModifyScalingConfigurationRequestDataDisks) *ModifyScalingConfigurationRequest {
	s.DataDisks = v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetDedicatedHostId(v string) *ModifyScalingConfigurationRequest {
	s.DedicatedHostId = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetDeletionProtection(v bool) *ModifyScalingConfigurationRequest {
	s.DeletionProtection = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetDeploymentSetId(v string) *ModifyScalingConfigurationRequest {
	s.DeploymentSetId = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetHostName(v string) *ModifyScalingConfigurationRequest {
	s.HostName = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetHpcClusterId(v string) *ModifyScalingConfigurationRequest {
	s.HpcClusterId = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetImageFamily(v string) *ModifyScalingConfigurationRequest {
	s.ImageFamily = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetImageId(v string) *ModifyScalingConfigurationRequest {
	s.ImageId = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetImageName(v string) *ModifyScalingConfigurationRequest {
	s.ImageName = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetInstanceDescription(v string) *ModifyScalingConfigurationRequest {
	s.InstanceDescription = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetInstanceName(v string) *ModifyScalingConfigurationRequest {
	s.InstanceName = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetInstancePatternInfos(v []*ModifyScalingConfigurationRequestInstancePatternInfos) *ModifyScalingConfigurationRequest {
	s.InstancePatternInfos = v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetInstanceTypeOverrides(v []*ModifyScalingConfigurationRequestInstanceTypeOverrides) *ModifyScalingConfigurationRequest {
	s.InstanceTypeOverrides = v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetInstanceTypes(v []*string) *ModifyScalingConfigurationRequest {
	s.InstanceTypes = v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetInternetChargeType(v string) *ModifyScalingConfigurationRequest {
	s.InternetChargeType = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetInternetMaxBandwidthOut(v int32) *ModifyScalingConfigurationRequest {
	s.InternetMaxBandwidthOut = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetIoOptimized(v string) *ModifyScalingConfigurationRequest {
	s.IoOptimized = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetIpv6AddressCount(v int32) *ModifyScalingConfigurationRequest {
	s.Ipv6AddressCount = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetKeyPairName(v string) *ModifyScalingConfigurationRequest {
	s.KeyPairName = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetLoadBalancerWeight(v int32) *ModifyScalingConfigurationRequest {
	s.LoadBalancerWeight = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetMemory(v int32) *ModifyScalingConfigurationRequest {
	s.Memory = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetOverride(v bool) *ModifyScalingConfigurationRequest {
	s.Override = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetOwnerAccount(v string) *ModifyScalingConfigurationRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetOwnerId(v int64) *ModifyScalingConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetPasswordInherit(v bool) *ModifyScalingConfigurationRequest {
	s.PasswordInherit = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetRamRoleName(v string) *ModifyScalingConfigurationRequest {
	s.RamRoleName = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetResourceGroupId(v string) *ModifyScalingConfigurationRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetResourceOwnerAccount(v string) *ModifyScalingConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetScalingConfigurationId(v string) *ModifyScalingConfigurationRequest {
	s.ScalingConfigurationId = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetScalingConfigurationName(v string) *ModifyScalingConfigurationRequest {
	s.ScalingConfigurationName = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetSchedulerOptions(v map[string]interface{}) *ModifyScalingConfigurationRequest {
	s.SchedulerOptions = v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetSecurityGroupId(v string) *ModifyScalingConfigurationRequest {
	s.SecurityGroupId = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetSecurityGroupIds(v []*string) *ModifyScalingConfigurationRequest {
	s.SecurityGroupIds = v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetSpotDuration(v int32) *ModifyScalingConfigurationRequest {
	s.SpotDuration = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetSpotInterruptionBehavior(v string) *ModifyScalingConfigurationRequest {
	s.SpotInterruptionBehavior = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetSpotPriceLimits(v []*ModifyScalingConfigurationRequestSpotPriceLimits) *ModifyScalingConfigurationRequest {
	s.SpotPriceLimits = v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetSpotStrategy(v string) *ModifyScalingConfigurationRequest {
	s.SpotStrategy = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetStorageSetId(v string) *ModifyScalingConfigurationRequest {
	s.StorageSetId = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetStorageSetPartitionNumber(v int32) *ModifyScalingConfigurationRequest {
	s.StorageSetPartitionNumber = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetSystemDiskCategories(v []*string) *ModifyScalingConfigurationRequest {
	s.SystemDiskCategories = v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetTags(v string) *ModifyScalingConfigurationRequest {
	s.Tags = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetTenancy(v string) *ModifyScalingConfigurationRequest {
	s.Tenancy = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetUserData(v string) *ModifyScalingConfigurationRequest {
	s.UserData = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetZoneId(v string) *ModifyScalingConfigurationRequest {
	s.ZoneId = &v
	return s
}

type ModifyScalingConfigurationRequestImageOptions struct {
	LoginAsNonRoot *bool `json:"LoginAsNonRoot,omitempty" xml:"LoginAsNonRoot,omitempty"`
}

func (s ModifyScalingConfigurationRequestImageOptions) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationRequestImageOptions) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationRequestImageOptions) SetLoginAsNonRoot(v bool) *ModifyScalingConfigurationRequestImageOptions {
	s.LoginAsNonRoot = &v
	return s
}

type ModifyScalingConfigurationRequestPrivatePoolOptions struct {
	// The ID of the private pool. The ID of a private pool is the same as the ID of the elasticity assurance or capacity reservation for which the private pool is generated.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The type of the private pool that you want to use to start instances. A private pool is generated when an elasticity assurance or a capacity reservation takes effect. You can select a private pool for Auto Scaling to start instances. Valid values:
	//
	// *   Open: open private pool. Auto Scaling selects a matching open private pool to start instances. If no matching open private pools exist, Auto Scaling uses the resources in the public pool to start instances. In this case, you do not need to specify PrivatePoolOptions.Id.
	// *   Target: specified private pool. Auto Scaling uses the resources in the specified private pool to start instances. If the private pool is unavailable, Auto Scaling cannot start the instances. If you set this parameter to Target, you must specify PrivatePoolOptions.Id.
	// *   None: no private pool: Auto Scaling does not use the resources in private pools to start instances.
	MatchCriteria *string `json:"MatchCriteria,omitempty" xml:"MatchCriteria,omitempty"`
}

func (s ModifyScalingConfigurationRequestPrivatePoolOptions) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationRequestPrivatePoolOptions) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationRequestPrivatePoolOptions) SetId(v string) *ModifyScalingConfigurationRequestPrivatePoolOptions {
	s.Id = &v
	return s
}

func (s *ModifyScalingConfigurationRequestPrivatePoolOptions) SetMatchCriteria(v string) *ModifyScalingConfigurationRequestPrivatePoolOptions {
	s.MatchCriteria = &v
	return s
}

type ModifyScalingConfigurationRequestSystemDisk struct {
	// The ID of the automatic snapshot policy that you want to apply to the system disk.
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// Specifies whether to enable the burst feature for the system disk. Valid values:
	//
	// *   true
	// *   false
	//
	// > This parameter is available only if you set `SystemDisk.Category` to `cloud_auto`.
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The category of the system disk. Valid values:
	//
	// *   cloud: basic disk
	// *   cloud_efficiency: ultra disk
	// *   cloud_ssd: standard SSD
	// *   cloud_essd: enhanced SSD (ESSD)
	// *   ephemeral_ssd: local SSD
	//
	// If you specify SystemDisk.Category, you cannot specify `SystemDiskCategories`. If you do not specify SystemDisk.Category or `SystemDiskCategories`, the default value of SystemDisk.Category is used. For non-I/O optimized instances of Generation I instance types, the default value is cloud. For instances of other instance types, the default value is cloud_efficiency.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The description of the system disk. The description must be 2 to 256 characters in length. The description can contain letters but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the system disk. The name must be 2 to 128 characters in length, and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with [http:// or https://. Default value: null.](http://https://。、（:）、（\_）（-）。：)
	DiskName *string `json:"DiskName,omitempty" xml:"DiskName,omitempty"`
	// The algorithm that you want to use to encrypt the system disk. Valid values:
	//
	// *   AES-256
	// *   SM4-128
	//
	// Default value: AES-256
	EncryptAlgorithm *string `json:"EncryptAlgorithm,omitempty" xml:"EncryptAlgorithm,omitempty"`
	// Specifies whether to encrypt the system disk. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false
	Encrypted *bool `json:"Encrypted,omitempty" xml:"Encrypted,omitempty"`
	// The ID of the KMS key that you want to use to encrypt the system disk.
	KMSKeyId *string `json:"KMSKeyId,omitempty" xml:"KMSKeyId,omitempty"`
	// The performance level (PL) of the system disk that is an ESSD. Valid values:
	//
	// *   PL0: An ESSD can provide up to 10,000 random read/write IOPS.
	// *   PL1: An ESSD can provide up to 50,000 random read/write IOPS.
	// *   PL2: An ESSD can provide up to 100,000 random read/write IOPS.
	// *   PL3: An ESSD can provide up to 1,000,000 random read/write IOPS.
	//
	// > For more information about how to select ESSD PLs, see [ESSD](~~122389~~).
	PerformanceLevel *string `json:"PerformanceLevel,omitempty" xml:"PerformanceLevel,omitempty"`
	// The IOPS metric that is preconfigured for the system disk.
	//
	// > IOPS measures the number of read and write operations that an EBS device can process per second.
	ProvisionedIops *int64 `json:"ProvisionedIops,omitempty" xml:"ProvisionedIops,omitempty"`
	// The size of the system disk. Unit: GiB. Valid values:
	//
	// *   If you set SystemDisk.Category to cloud: 20 to 500.
	// *   If you set SystemDisk.Category to cloud_efficiency: 20 to 500.
	// *   If you set SystemDisk.Category to cloud_ssd: 20 to 500.
	// *   If you set SystemDisk.Category to cloud_essd: 20 to 500.
	// *   If you set SystemDisk.Category to ephemeral_ssd: 20 to 500.
	//
	// The value of SystemDisk.Size must be greater than or equal to max{20, ImageSize}.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
}

func (s ModifyScalingConfigurationRequestSystemDisk) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationRequestSystemDisk) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationRequestSystemDisk) SetAutoSnapshotPolicyId(v string) *ModifyScalingConfigurationRequestSystemDisk {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *ModifyScalingConfigurationRequestSystemDisk) SetBurstingEnabled(v bool) *ModifyScalingConfigurationRequestSystemDisk {
	s.BurstingEnabled = &v
	return s
}

func (s *ModifyScalingConfigurationRequestSystemDisk) SetCategory(v string) *ModifyScalingConfigurationRequestSystemDisk {
	s.Category = &v
	return s
}

func (s *ModifyScalingConfigurationRequestSystemDisk) SetDescription(v string) *ModifyScalingConfigurationRequestSystemDisk {
	s.Description = &v
	return s
}

func (s *ModifyScalingConfigurationRequestSystemDisk) SetDiskName(v string) *ModifyScalingConfigurationRequestSystemDisk {
	s.DiskName = &v
	return s
}

func (s *ModifyScalingConfigurationRequestSystemDisk) SetEncryptAlgorithm(v string) *ModifyScalingConfigurationRequestSystemDisk {
	s.EncryptAlgorithm = &v
	return s
}

func (s *ModifyScalingConfigurationRequestSystemDisk) SetEncrypted(v bool) *ModifyScalingConfigurationRequestSystemDisk {
	s.Encrypted = &v
	return s
}

func (s *ModifyScalingConfigurationRequestSystemDisk) SetKMSKeyId(v string) *ModifyScalingConfigurationRequestSystemDisk {
	s.KMSKeyId = &v
	return s
}

func (s *ModifyScalingConfigurationRequestSystemDisk) SetPerformanceLevel(v string) *ModifyScalingConfigurationRequestSystemDisk {
	s.PerformanceLevel = &v
	return s
}

func (s *ModifyScalingConfigurationRequestSystemDisk) SetProvisionedIops(v int64) *ModifyScalingConfigurationRequestSystemDisk {
	s.ProvisionedIops = &v
	return s
}

func (s *ModifyScalingConfigurationRequestSystemDisk) SetSize(v int32) *ModifyScalingConfigurationRequestSystemDisk {
	s.Size = &v
	return s
}

type ModifyScalingConfigurationRequestDataDisks struct {
	// The ID of the automatic snapshot policy that you want to apply to the data disk.
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// Specifies whether to enable the burst feature for the system disk. Valid values:
	//
	// *   true
	// *   false
	//
	// > This parameter is available only if you set `SystemDisk.Category` to `cloud_auto`.
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The categories of the data disks. Valid values:
	//
	// *   cloud: basic disk. The DeleteWithInstance attribute of a basic disk that is created together with the instance is set to true.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   cloud_essd: ESSD.
	//
	// > If you specify Categories, you cannot specify `DataDisk.Category`.
	Categories []*string `json:"Categories,omitempty" xml:"Categories,omitempty" type:"Repeated"`
	// The category of the data disk. Valid values:
	//
	// *   cloud: basic disk. The DeleteWithInstance attribute of a basic disk that is created together with the instance is set to true.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   ephemeral_ssd: local SSD.
	// *   cloud_essd: ESSD.
	//
	// If you specify Category, you cannot specify `Categories`. If you do not specify Category or `Categories`, the default value of Category is used:
	//
	// *   For I/O optimized instances, the default value is cloud_efficiency.
	// *   For non-I/O optimized instances, the default value is cloud.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// Specifies whether to release the data disk when the instance to which the data disk is attached is released. Valid values:
	//
	// *   true
	// *   false
	//
	// This parameter is available only for independent disks whose Category is set to cloud, cloud_efficiency, cloud_ssd, cloud_essd, or cloud_auto. If you specify this parameter for other disks, an error is reported.
	DeleteWithInstance *bool `json:"DeleteWithInstance,omitempty" xml:"DeleteWithInstance,omitempty"`
	// The description of the system disk. The description must be 2 to 256 characters in length. The description can contain letters but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The mount target of the data disk. If you do not specify Device, a mount target is automatically assigned when Auto Scaling creates ECS instances. The name of the mount target ranges from /dev/xvdb to /dev/xvdz.
	Device *string `json:"Device,omitempty" xml:"Device,omitempty"`
	// The name of the system disk. The name must be 2 to 128 characters in length, and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
	DiskName *string `json:"DiskName,omitempty" xml:"DiskName,omitempty"`
	// Specifies whether to encrypt the system disk. Valid values:
	//
	// *   true
	// *   false
	Encrypted *string `json:"Encrypted,omitempty" xml:"Encrypted,omitempty"`
	// The ID of the Key Management Service (KMS) key that you want to use to encrypt the data disk.
	KMSKeyId *string `json:"KMSKeyId,omitempty" xml:"KMSKeyId,omitempty"`
	// The PL of the data disk that is an ESSD. Valid values:
	//
	// *   PL0: An ESSD can provide up to 10,000 random read/write IOPS.
	// *   PL1: An ESSD can provide up to 50,000 random read/write IOPS.
	// *   PL2: An ESSD can provide up to 100,000 random read/write IOPS.
	// *   PL3: An ESSD can provide up to 1,000,000 random read/write IOPS.
	//
	// > For more information about how to select ESSD PLs, see [ESSD](~~122389~~).
	PerformanceLevel *string `json:"PerformanceLevel,omitempty" xml:"PerformanceLevel,omitempty"`
	// The IOPS metric that is preconfigured for the data disk.
	//
	// > IOPS measures the number of read and write operations that an Elastic Block Storage (EBS) device can process per second.
	ProvisionedIops *int64 `json:"ProvisionedIops,omitempty" xml:"ProvisionedIops,omitempty"`
	// The size of the data disk. Unit: GiB. Valid values:
	//
	// *   If you set Categories cloud: 5 to 2000.
	// *   If you set Categories to cloud_efficiency: 20 to 32768.
	// *   If you set Categories to cloud_ssd: 20 to 32768.
	// *   If you set Categories to cloud_essd: 20 to 32768.
	// *   If you set Categories to ephemeral_ssd: 5 to 800.
	//
	// The size of the data disk must be greater than or equal to the size of the snapshot that is specified by SnapshotId.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The ID of the snapshot that you want to use to create data disks. If you specify this parameter, DataDisk.N.Size is ignored. The size of the disk is the same as the size of the specified snapshot.
	//
	// If you specify a snapshot that is created on or before July 15, 2013, the operation fails and the system returns InvalidSnapshot.TooOld.
	SnapshotId *string `json:"SnapshotId,omitempty" xml:"SnapshotId,omitempty"`
}

func (s ModifyScalingConfigurationRequestDataDisks) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationRequestDataDisks) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetAutoSnapshotPolicyId(v string) *ModifyScalingConfigurationRequestDataDisks {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetBurstingEnabled(v bool) *ModifyScalingConfigurationRequestDataDisks {
	s.BurstingEnabled = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetCategories(v []*string) *ModifyScalingConfigurationRequestDataDisks {
	s.Categories = v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetCategory(v string) *ModifyScalingConfigurationRequestDataDisks {
	s.Category = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetDeleteWithInstance(v bool) *ModifyScalingConfigurationRequestDataDisks {
	s.DeleteWithInstance = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetDescription(v string) *ModifyScalingConfigurationRequestDataDisks {
	s.Description = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetDevice(v string) *ModifyScalingConfigurationRequestDataDisks {
	s.Device = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetDiskName(v string) *ModifyScalingConfigurationRequestDataDisks {
	s.DiskName = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetEncrypted(v string) *ModifyScalingConfigurationRequestDataDisks {
	s.Encrypted = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetKMSKeyId(v string) *ModifyScalingConfigurationRequestDataDisks {
	s.KMSKeyId = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetPerformanceLevel(v string) *ModifyScalingConfigurationRequestDataDisks {
	s.PerformanceLevel = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetProvisionedIops(v int64) *ModifyScalingConfigurationRequestDataDisks {
	s.ProvisionedIops = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetSize(v int32) *ModifyScalingConfigurationRequestDataDisks {
	s.Size = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetSnapshotId(v string) *ModifyScalingConfigurationRequestDataDisks {
	s.SnapshotId = &v
	return s
}

type ModifyScalingConfigurationRequestInstancePatternInfos struct {
	// The architectures of the instance types.
	//
	// *   X86: x86 architecture.
	// *   Heterogeneous: heterogeneous architecture, such as GPUs and FPGAs.
	// *   BareMetal: ECS Bare Metal Instance architecture.
	// *   Arm: ARM architecture.
	// *   SuperComputeCluster: Super Computing Cluster architecture.
	//
	// By default, all values are included.
	Architectures []*string `json:"Architectures,omitempty" xml:"Architectures,omitempty" type:"Repeated"`
	// Specifies whether to include burstable instance types. Valid values:
	//
	// *   Exclude: does not include burstable instance types.
	// *   Include: includes burstable instance types.
	// *   Required: includes only burstable instance types.
	//
	// Default value: Include
	BurstablePerformance *string `json:"BurstablePerformance,omitempty" xml:"BurstablePerformance,omitempty"`
	// The number of vCPUs that you want to allocate to an instance type in intelligent configuration mode. You can use this parameter to filter the available instance types that meet the specified criteria. For more information, see [Overview of instance families](~~25378~~).
	//
	// When you specify this parameter, take note of the following items:
	//
	// *   InstancePatternInfo is available only for scaling groups that reside in VPCs.
	// *   If you specify InstancePatternInfo, you must also specify Cores and Memory.
	// *   If you specify an instance type by using InstanceType or InstanceTypes, Auto Scaling preferentially creates instances by using the instance type that is specified by InstanceType or InstanceTypes for scale-outs. If the specified instance type does not have sufficient inventory, Auto Scaling creates instances by using the lowest-priced instance type that is specified by InstancePatternInfo.
	Cores *int32 `json:"Cores,omitempty" xml:"Cores,omitempty"`
	// The instance types that you want to exclude. You can use wildcard characters such as an asterisk (\*) to exclude an instance type or an instance family. Examples:
	//
	// *   ecs.c6.large: excludes the ecs.c6.large instance type.
	// *   ecs.c6.\*: excludes the c6 instance family.
	ExcludedInstanceTypes []*string `json:"ExcludedInstanceTypes,omitempty" xml:"ExcludedInstanceTypes,omitempty" type:"Repeated"`
	// The level of the instance family. You can use this parameter to filter instance types that meet the specified criteria. This parameter takes effect only if you set `CostOptimization` to true. Valid values:
	//
	// *   EntryLevel: entry level (shared instance type). Instance types of this level are the most cost-effective but may not provide stable computing performance in a consistent manner. Instance types of this level are suitable for business scenarios in which CPU utilization is low. For more information, see [Shared instance families](~~108489~~).
	// *   EnterpriseLevel: enterprise level. Instance types of this level provide stable performance and dedicated resources and are suitable for business scenarios that require high stability. For more information, see the [Overview of instance families](~~25378~~) topic.
	// *   CreditEntryLevel: credit entry level. This value is valid only for burstable instances. CPU credits are used to ensure computing performance. Instance types of this level are suitable for business scenarios in which CPU utilization is low but may fluctuate in specific scenarios. For more information, see [Overview](~~59977~~) of burstable instances.
	InstanceFamilyLevel *string `json:"InstanceFamilyLevel,omitempty" xml:"InstanceFamilyLevel,omitempty"`
	// The maximum hourly price for a pay-as-you-go instance or a preemptible instance in intelligent configuration mode. You can use this parameter to filter the available instance types that meet the specified criteria.
	//
	// > If you set SpotStrategy to SpotWithPriceLimit, specify MaxPrice. In other scenarios, MaxPrice is optional.
	MaxPrice *float32 `json:"MaxPrice,omitempty" xml:"MaxPrice,omitempty"`
	// The memory size that you want to allocate to an instance type in intelligent configuration mode. Unit: GiB. You can use this parameter to filter the available instance types that meet the specified criteria.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
}

func (s ModifyScalingConfigurationRequestInstancePatternInfos) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationRequestInstancePatternInfos) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationRequestInstancePatternInfos) SetArchitectures(v []*string) *ModifyScalingConfigurationRequestInstancePatternInfos {
	s.Architectures = v
	return s
}

func (s *ModifyScalingConfigurationRequestInstancePatternInfos) SetBurstablePerformance(v string) *ModifyScalingConfigurationRequestInstancePatternInfos {
	s.BurstablePerformance = &v
	return s
}

func (s *ModifyScalingConfigurationRequestInstancePatternInfos) SetCores(v int32) *ModifyScalingConfigurationRequestInstancePatternInfos {
	s.Cores = &v
	return s
}

func (s *ModifyScalingConfigurationRequestInstancePatternInfos) SetExcludedInstanceTypes(v []*string) *ModifyScalingConfigurationRequestInstancePatternInfos {
	s.ExcludedInstanceTypes = v
	return s
}

func (s *ModifyScalingConfigurationRequestInstancePatternInfos) SetInstanceFamilyLevel(v string) *ModifyScalingConfigurationRequestInstancePatternInfos {
	s.InstanceFamilyLevel = &v
	return s
}

func (s *ModifyScalingConfigurationRequestInstancePatternInfos) SetMaxPrice(v float32) *ModifyScalingConfigurationRequestInstancePatternInfos {
	s.MaxPrice = &v
	return s
}

func (s *ModifyScalingConfigurationRequestInstancePatternInfos) SetMemory(v float32) *ModifyScalingConfigurationRequestInstancePatternInfos {
	s.Memory = &v
	return s
}

type ModifyScalingConfigurationRequestInstanceTypeOverrides struct {
	// The instance type. If you want to specify the capacity of instance types in the scaling configuration, specify InstanceType and WeightedCapacity at the same time.
	//
	// You can use InstanceType to specify multiple instance types and WeightedCapacity to specify the weights of the instance types.
	//
	// > If you specify InstanceType, you cannot specify InstanceTypes.
	//
	// You can use InstanceType to specify only instance types that are available for purchase.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The weight of the instance type. The weight specifies the capacity of an instance of the specified instance type in the scaling group. If you want Auto Scaling to scale instances in the scaling group based on the weighted capacity of the instances, specify WeightedCapacity after you specify InstanceType.
	//
	// A higher weight specifies that a smaller number of instances of the specified instance type are required to meet the expected capacity requirement.
	//
	// Performance metrics, such as the number of vCPUs and the memory size of each instance type, may vary. You can specify different weights for different instance types based on your business requirements.
	//
	// Example:
	//
	// *   Current capacity: 0
	// *   Expected capacity: 6
	// *   Capacity of ecs.c5.xlarge: 4
	//
	// To meet the expected capacity requirement, Auto Scaling must create and add two ecs.c5.xlarge instances.
	//
	// > The capacity of the scaling group cannot exceed the sum of the maximum number of instances that is specified by MaxSize and the maximum weight of the instance types.
	//
	// Valid values of WeightedCapacity: 1 to 500.
	WeightedCapacity *int32 `json:"WeightedCapacity,omitempty" xml:"WeightedCapacity,omitempty"`
}

func (s ModifyScalingConfigurationRequestInstanceTypeOverrides) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationRequestInstanceTypeOverrides) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationRequestInstanceTypeOverrides) SetInstanceType(v string) *ModifyScalingConfigurationRequestInstanceTypeOverrides {
	s.InstanceType = &v
	return s
}

func (s *ModifyScalingConfigurationRequestInstanceTypeOverrides) SetWeightedCapacity(v int32) *ModifyScalingConfigurationRequestInstanceTypeOverrides {
	s.WeightedCapacity = &v
	return s
}

type ModifyScalingConfigurationRequestSpotPriceLimits struct {
	// The instance type of the preemptible instance. This parameter takes effect only if you set SpotStrategy to SpotWithPriceLimit.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The price limit of the preemptible instance. This parameter takes effect only if you set SpotStrategy to SpotWithPriceLimit.
	PriceLimit *float32 `json:"PriceLimit,omitempty" xml:"PriceLimit,omitempty"`
}

func (s ModifyScalingConfigurationRequestSpotPriceLimits) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationRequestSpotPriceLimits) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationRequestSpotPriceLimits) SetInstanceType(v string) *ModifyScalingConfigurationRequestSpotPriceLimits {
	s.InstanceType = &v
	return s
}

func (s *ModifyScalingConfigurationRequestSpotPriceLimits) SetPriceLimit(v float32) *ModifyScalingConfigurationRequestSpotPriceLimits {
	s.PriceLimit = &v
	return s
}

type ModifyScalingConfigurationShrinkRequest struct {
	ImageOptions       *ModifyScalingConfigurationShrinkRequestImageOptions       `json:"ImageOptions,omitempty" xml:"ImageOptions,omitempty" type:"Struct"`
	PrivatePoolOptions *ModifyScalingConfigurationShrinkRequestPrivatePoolOptions `json:"PrivatePoolOptions,omitempty" xml:"PrivatePoolOptions,omitempty" type:"Struct"`
	SystemDisk         *ModifyScalingConfigurationShrinkRequestSystemDisk         `json:"SystemDisk,omitempty" xml:"SystemDisk,omitempty" type:"Struct"`
	// Specifies whether to associate an ECS instance on a dedicated host with the dedicated host. Valid values:
	//
	// *   default: does not associate the ECS instance with the dedicated host. If you start an instance that is stopped in economical mode and the original dedicated host has insufficient resources, the instance is automatically deployed to another dedicated host in the automatic deployment resource pool.
	// *   host: associates the ECS instance with the dedicated host. If you start an ECS instance that is stopped in economical mode, the ECS instance remains on the original dedicated host. If the original dedicated host has insufficient resources, the ECS instance fails to start.
	Affinity *string `json:"Affinity,omitempty" xml:"Affinity,omitempty"`
	// The number of vCPUs.
	//
	// You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set Cpu to 2 and Memory to 16 to specify instance types that have 2 vCPUs and 16 GiB of memory. If you specify Cpu and Memory, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances by using the lowest-priced instance type.
	//
	// > You can specify CPU and Memory to determine the range of instance types only if you set Scaling Policy to Cost Optimization Policy and you do not specify an instance type in the scaling configuration.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The performance mode of the burstable instance. Valid values:
	//
	// *   Standard: standard mode. For more information, see the "Standard mode" section in the [Burstable instances](~~59977~~) topic.
	// *   Unlimited: unlimited mode. For more information, see the "Unlimited mode" section in the [Burstable instances](~~59977~~) topic.
	CreditSpecification *string `json:"CreditSpecification,omitempty" xml:"CreditSpecification,omitempty"`
	// The data disks.
	DataDisks []*ModifyScalingConfigurationShrinkRequestDataDisks `json:"DataDisks,omitempty" xml:"DataDisks,omitempty" type:"Repeated"`
	// The ID of the dedicated host on which you want to create ECS instances. You cannot create preemptible instances on dedicated hosts. If you specify DedicatedHostId, SpotStrategy and SpotPriceLimit are ignored.
	//
	// You can call the DescribeDedicatedHosts operation to query the most recent list of dedicated host IDs.
	DedicatedHostId    *string `json:"DedicatedHostId,omitempty" xml:"DedicatedHostId,omitempty"`
	DeletionProtection *bool   `json:"DeletionProtection,omitempty" xml:"DeletionProtection,omitempty"`
	// The ID of the deployment set of the ECS instances that are created by using the scaling configuration.
	DeploymentSetId *string `json:"DeploymentSetId,omitempty" xml:"DeploymentSetId,omitempty"`
	// The hostname of the ECS instance. The hostname cannot start or end with a period (.) or a hyphen (-). The hostname cannot contain consecutive periods (.) or hyphens (-). Naming conventions for different types of instances:
	//
	// *   Windows instances: The hostname must be 2 to 15 characters in length, and can contain letters, digits, and hyphens (-). The hostname cannot contain periods (.) or contain only digits.
	// *   Other instances, such as Linux instances: The hostname must be 2 to 64 characters in length. Separate a hostname into multiple segments with periods (.). Each segment can contain letters, digits, and hyphens (-).
	HostName *string `json:"HostName,omitempty" xml:"HostName,omitempty"`
	// The ID of the Elastic High Performance Computing (E-HPC) cluster to which the ECS instances belong.
	HpcClusterId *string `json:"HpcClusterId,omitempty" xml:"HpcClusterId,omitempty"`
	// The name of the image family. If you specify this parameter, the latest custom images that are available in the specified image family are returned. Then, you can use the images to create instances. If you specify ImageId, you cannot specify ImageFamily.
	ImageFamily *string `json:"ImageFamily,omitempty" xml:"ImageFamily,omitempty"`
	// The ID of the image that is used by Auto Scaling to automatically create ECS instances.
	//
	// > If the image that is specified in the scaling configuration contains system disks and data disks, the data that is stored in the data disks is cleared after you modify the image.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The name of the image. Each image name must be unique in a region. If you specify ImageId, ImageName is ignored.
	//
	// You cannot use ImageName to specify images from Alibaba Cloud Marketplace.
	ImageName *string `json:"ImageName,omitempty" xml:"ImageName,omitempty"`
	// The description of the ECS instance. The description must be 2 to 256 characters in length. The description can contain letters but cannot start with `http://` or `https://`.
	InstanceDescription *string `json:"InstanceDescription,omitempty" xml:"InstanceDescription,omitempty"`
	// The name of the Elastic Compute Service (ECS) instance that is automatically created by using the scaling configuration.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The intelligent configuration settings, which determines the range of instance types that meet the specified criteria.
	InstancePatternInfos []*ModifyScalingConfigurationShrinkRequestInstancePatternInfos `json:"InstancePatternInfos,omitempty" xml:"InstancePatternInfos,omitempty" type:"Repeated"`
	// The instance types.
	InstanceTypeOverrides []*ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides `json:"InstanceTypeOverrides,omitempty" xml:"InstanceTypeOverrides,omitempty" type:"Repeated"`
	// The instance type. If you specify InstanceTypes, InstanceType is ignored.
	//
	// Auto Scaling creates instances based on the priorities of instance types. If Auto Scaling cannot create instances by using the instance type that has the highest priority, Auto Scaling creates instances by using the instance type that has the next highest priority.
	InstanceTypes []*string `json:"InstanceTypes,omitempty" xml:"InstanceTypes,omitempty" type:"Repeated"`
	// The metering method for network usage. Valid values:
	//
	// *   PayByBandwidth: You are charged for the maximum available bandwidth that is specified by InternetMaxBandwidthOut.
	// *   PayByTraffic: You are charged for the actual data transfer. InternetMaxBandwidthOut specifies only the maximum available bandwidth.
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The maximum outbound public bandwidth. Unit: Mbit/s. Valid values:
	//
	// *   If you set InternetChargeType to PayByBandwidth: 0 to 100. If you leave this parameter empty, this parameter is automatically set to 0.
	// *   If you set InternetChargeType to PayByTraffic: 0 to 100. If you leave this parameter empty, an error is returned.
	InternetMaxBandwidthOut *int32 `json:"InternetMaxBandwidthOut,omitempty" xml:"InternetMaxBandwidthOut,omitempty"`
	// Specifies whether to create an I/O optimized instance. Valid values:
	//
	// *   none: does not create an I/O optimized instance.
	// *   optimized: creates an I/O optimized instance.
	IoOptimized *string `json:"IoOptimized,omitempty" xml:"IoOptimized,omitempty"`
	// The number of randomly generated IPv6 addresses that you want to allocate to the elastic network interface (ENI).
	Ipv6AddressCount *int32 `json:"Ipv6AddressCount,omitempty" xml:"Ipv6AddressCount,omitempty"`
	// The name of the key pair that you can use to log on to an ECS instance.
	//
	// *   Windows instances do not support this parameter.
	// *   By default, the username and password authentication method is disabled for Linux instances.
	KeyPairName *string `json:"KeyPairName,omitempty" xml:"KeyPairName,omitempty"`
	// The weight of an ECS instance as a backend server. Valid values: 1 to 100.
	LoadBalancerWeight *int32 `json:"LoadBalancerWeight,omitempty" xml:"LoadBalancerWeight,omitempty"`
	// The memory size. Unit: GiB.
	//
	// You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set Cpu to 2 and Memory to 16 to specify instance types that have 2 vCPUs and 16 GiB of memory. If you specify Cpu and Memory, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances by using the lowest-priced instance type.
	//
	// > You can specify CPU and Memory to determine the range of instance types only if you set Scaling Policy to Cost Optimization Policy and you do not specify an instance type in the scaling configuration.
	Memory *int32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// Specifies whether to overwrite existing data. Valid values:
	//
	// *   true
	// *   false
	Override     *bool   `json:"Override,omitempty" xml:"Override,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Specifies whether to use the password that is preconfigured in the image. Before you use this parameter, make sure that a password is configured in the image.
	PasswordInherit *bool `json:"PasswordInherit,omitempty" xml:"PasswordInherit,omitempty"`
	// The name of the RAM role that you want to attach to the ECS instance. The name is provided and maintained by Resource Access Management (RAM). You can call the ListRoles operation to query the available RAM roles. You can call the CreateRole operation to create RAM roles.
	RamRoleName *string `json:"RamRoleName,omitempty" xml:"RamRoleName,omitempty"`
	// The ID of the resource group to which the ECS instances belong.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling configuration that you want to modify.
	ScalingConfigurationId *string `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
	// The name of the scaling configuration. The name must be 2 to 64 characters in length, and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). The name must start with a letter or a digit.
	//
	// The name of the scaling configuration must be unique in a region. If you do not specify this parameter, the scaling configuration ID is used.
	ScalingConfigurationName *string `json:"ScalingConfigurationName,omitempty" xml:"ScalingConfigurationName,omitempty"`
	// The scheduler options.
	SchedulerOptionsShrink *string `json:"SchedulerOptions,omitempty" xml:"SchedulerOptions,omitempty"`
	// The ID of the security group with which ECS instances are associated. The ECS instances that are associated with the same security group can access each other.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// The IDs of the security groups.
	SecurityGroupIds []*string `json:"SecurityGroupIds,omitempty" xml:"SecurityGroupIds,omitempty" type:"Repeated"`
	// The retention period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.
	//
	// *   The following retention periods are available in invitational preview: 2, 3, 4, 5, and 6 hours. If you want to set this parameter to one of these values, submit a ticket.
	// *   If you set this parameter to 0, no retention period is specified for the preemptible instance.
	SpotDuration *int32 `json:"SpotDuration,omitempty" xml:"SpotDuration,omitempty"`
	// The interruption mode of the preemptible instance. Default value: Terminate. Set the value to Terminate. This value specifies that the preemptible instance is to be released.
	SpotInterruptionBehavior *string `json:"SpotInterruptionBehavior,omitempty" xml:"SpotInterruptionBehavior,omitempty"`
	// The preemptible instance types.
	SpotPriceLimits []*ModifyScalingConfigurationShrinkRequestSpotPriceLimits `json:"SpotPriceLimits,omitempty" xml:"SpotPriceLimits,omitempty" type:"Repeated"`
	// The preemption policy that you want to apply to pay-as-you-go instances and preemptible instances. Valid values:
	//
	// *   NoSpot: The instance is created as a pay-as-you-go instance.
	// *   SpotWithPriceLimit: The instance is a preemptible instance that has a user-defined maximum hourly price.
	// *   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bidding price.
	SpotStrategy              *string `json:"SpotStrategy,omitempty" xml:"SpotStrategy,omitempty"`
	StorageSetId              *string `json:"StorageSetId,omitempty" xml:"StorageSetId,omitempty"`
	StorageSetPartitionNumber *int32  `json:"StorageSetPartitionNumber,omitempty" xml:"StorageSetPartitionNumber,omitempty"`
	// The categories of the system disks. If Auto Scaling cannot create instances by using the disk category that has the highest priority, Auto Scaling creates instances by using the disk category that has the next highest priority. Valid values:
	//
	// *   cloud: basic disk
	// *   cloud_efficiency: ultra disk
	// *   cloud_ssd: standard SSD
	// *   cloud_essd: ESSD
	//
	// > If you specify SystemDiskCategories, you cannot specify `SystemDisk.Category`.
	SystemDiskCategories []*string `json:"SystemDiskCategories,omitempty" xml:"SystemDiskCategories,omitempty" type:"Repeated"`
	// The tags of the ECS instance. Specify the tags as key-value pairs. You can specify up to 20 tags. When you specify tag keys and tag values, take note of the following items:
	//
	// *   A tag key can be up to 64 characters in length. The key cannot start with `acs:` or `aliyun`, and cannot contain `http://` or `https://`. The tag key cannot be an empty string.
	// *   A tag value can be up to 128 characters in length. The value cannot start with `acs:` or `aliyun`, and cannot contain `http://` or `https://`. The tag value can be an empty string.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// Specifies whether to create an ECS instance on a dedicated host. Valid values:
	//
	// *   default: does not create the ECS instance on a dedicated host.
	// *   host: creates the ECS instance on a dedicated host. If you do not specify DedicatedHostId, Alibaba Cloud selects a dedicated host for the ECS instance.
	Tenancy *string `json:"Tenancy,omitempty" xml:"Tenancy,omitempty"`
	// The user data of the ECS instance. The data must be encoded in Base64. The maximum size of the data before encoding is 16 KB.
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The zone ID of the ECS instances that are created by using the scaling configuration.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s ModifyScalingConfigurationShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationShrinkRequest) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationShrinkRequest) SetImageOptions(v *ModifyScalingConfigurationShrinkRequestImageOptions) *ModifyScalingConfigurationShrinkRequest {
	s.ImageOptions = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetPrivatePoolOptions(v *ModifyScalingConfigurationShrinkRequestPrivatePoolOptions) *ModifyScalingConfigurationShrinkRequest {
	s.PrivatePoolOptions = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetSystemDisk(v *ModifyScalingConfigurationShrinkRequestSystemDisk) *ModifyScalingConfigurationShrinkRequest {
	s.SystemDisk = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetAffinity(v string) *ModifyScalingConfigurationShrinkRequest {
	s.Affinity = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetCpu(v int32) *ModifyScalingConfigurationShrinkRequest {
	s.Cpu = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetCreditSpecification(v string) *ModifyScalingConfigurationShrinkRequest {
	s.CreditSpecification = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetDataDisks(v []*ModifyScalingConfigurationShrinkRequestDataDisks) *ModifyScalingConfigurationShrinkRequest {
	s.DataDisks = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetDedicatedHostId(v string) *ModifyScalingConfigurationShrinkRequest {
	s.DedicatedHostId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetDeletionProtection(v bool) *ModifyScalingConfigurationShrinkRequest {
	s.DeletionProtection = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetDeploymentSetId(v string) *ModifyScalingConfigurationShrinkRequest {
	s.DeploymentSetId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetHostName(v string) *ModifyScalingConfigurationShrinkRequest {
	s.HostName = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetHpcClusterId(v string) *ModifyScalingConfigurationShrinkRequest {
	s.HpcClusterId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetImageFamily(v string) *ModifyScalingConfigurationShrinkRequest {
	s.ImageFamily = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetImageId(v string) *ModifyScalingConfigurationShrinkRequest {
	s.ImageId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetImageName(v string) *ModifyScalingConfigurationShrinkRequest {
	s.ImageName = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetInstanceDescription(v string) *ModifyScalingConfigurationShrinkRequest {
	s.InstanceDescription = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetInstanceName(v string) *ModifyScalingConfigurationShrinkRequest {
	s.InstanceName = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetInstancePatternInfos(v []*ModifyScalingConfigurationShrinkRequestInstancePatternInfos) *ModifyScalingConfigurationShrinkRequest {
	s.InstancePatternInfos = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetInstanceTypeOverrides(v []*ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides) *ModifyScalingConfigurationShrinkRequest {
	s.InstanceTypeOverrides = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetInstanceTypes(v []*string) *ModifyScalingConfigurationShrinkRequest {
	s.InstanceTypes = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetInternetChargeType(v string) *ModifyScalingConfigurationShrinkRequest {
	s.InternetChargeType = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetInternetMaxBandwidthOut(v int32) *ModifyScalingConfigurationShrinkRequest {
	s.InternetMaxBandwidthOut = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetIoOptimized(v string) *ModifyScalingConfigurationShrinkRequest {
	s.IoOptimized = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetIpv6AddressCount(v int32) *ModifyScalingConfigurationShrinkRequest {
	s.Ipv6AddressCount = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetKeyPairName(v string) *ModifyScalingConfigurationShrinkRequest {
	s.KeyPairName = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetLoadBalancerWeight(v int32) *ModifyScalingConfigurationShrinkRequest {
	s.LoadBalancerWeight = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetMemory(v int32) *ModifyScalingConfigurationShrinkRequest {
	s.Memory = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetOverride(v bool) *ModifyScalingConfigurationShrinkRequest {
	s.Override = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetOwnerAccount(v string) *ModifyScalingConfigurationShrinkRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetOwnerId(v int64) *ModifyScalingConfigurationShrinkRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetPasswordInherit(v bool) *ModifyScalingConfigurationShrinkRequest {
	s.PasswordInherit = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetRamRoleName(v string) *ModifyScalingConfigurationShrinkRequest {
	s.RamRoleName = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetResourceGroupId(v string) *ModifyScalingConfigurationShrinkRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetResourceOwnerAccount(v string) *ModifyScalingConfigurationShrinkRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetScalingConfigurationId(v string) *ModifyScalingConfigurationShrinkRequest {
	s.ScalingConfigurationId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetScalingConfigurationName(v string) *ModifyScalingConfigurationShrinkRequest {
	s.ScalingConfigurationName = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetSchedulerOptionsShrink(v string) *ModifyScalingConfigurationShrinkRequest {
	s.SchedulerOptionsShrink = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetSecurityGroupId(v string) *ModifyScalingConfigurationShrinkRequest {
	s.SecurityGroupId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetSecurityGroupIds(v []*string) *ModifyScalingConfigurationShrinkRequest {
	s.SecurityGroupIds = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetSpotDuration(v int32) *ModifyScalingConfigurationShrinkRequest {
	s.SpotDuration = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetSpotInterruptionBehavior(v string) *ModifyScalingConfigurationShrinkRequest {
	s.SpotInterruptionBehavior = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetSpotPriceLimits(v []*ModifyScalingConfigurationShrinkRequestSpotPriceLimits) *ModifyScalingConfigurationShrinkRequest {
	s.SpotPriceLimits = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetSpotStrategy(v string) *ModifyScalingConfigurationShrinkRequest {
	s.SpotStrategy = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetStorageSetId(v string) *ModifyScalingConfigurationShrinkRequest {
	s.StorageSetId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetStorageSetPartitionNumber(v int32) *ModifyScalingConfigurationShrinkRequest {
	s.StorageSetPartitionNumber = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetSystemDiskCategories(v []*string) *ModifyScalingConfigurationShrinkRequest {
	s.SystemDiskCategories = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetTags(v string) *ModifyScalingConfigurationShrinkRequest {
	s.Tags = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetTenancy(v string) *ModifyScalingConfigurationShrinkRequest {
	s.Tenancy = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetUserData(v string) *ModifyScalingConfigurationShrinkRequest {
	s.UserData = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetZoneId(v string) *ModifyScalingConfigurationShrinkRequest {
	s.ZoneId = &v
	return s
}

type ModifyScalingConfigurationShrinkRequestImageOptions struct {
	LoginAsNonRoot *bool `json:"LoginAsNonRoot,omitempty" xml:"LoginAsNonRoot,omitempty"`
}

func (s ModifyScalingConfigurationShrinkRequestImageOptions) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationShrinkRequestImageOptions) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationShrinkRequestImageOptions) SetLoginAsNonRoot(v bool) *ModifyScalingConfigurationShrinkRequestImageOptions {
	s.LoginAsNonRoot = &v
	return s
}

type ModifyScalingConfigurationShrinkRequestPrivatePoolOptions struct {
	// The ID of the private pool. The ID of a private pool is the same as the ID of the elasticity assurance or capacity reservation for which the private pool is generated.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The type of the private pool that you want to use to start instances. A private pool is generated when an elasticity assurance or a capacity reservation takes effect. You can select a private pool for Auto Scaling to start instances. Valid values:
	//
	// *   Open: open private pool. Auto Scaling selects a matching open private pool to start instances. If no matching open private pools exist, Auto Scaling uses the resources in the public pool to start instances. In this case, you do not need to specify PrivatePoolOptions.Id.
	// *   Target: specified private pool. Auto Scaling uses the resources in the specified private pool to start instances. If the private pool is unavailable, Auto Scaling cannot start the instances. If you set this parameter to Target, you must specify PrivatePoolOptions.Id.
	// *   None: no private pool: Auto Scaling does not use the resources in private pools to start instances.
	MatchCriteria *string `json:"MatchCriteria,omitempty" xml:"MatchCriteria,omitempty"`
}

func (s ModifyScalingConfigurationShrinkRequestPrivatePoolOptions) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationShrinkRequestPrivatePoolOptions) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationShrinkRequestPrivatePoolOptions) SetId(v string) *ModifyScalingConfigurationShrinkRequestPrivatePoolOptions {
	s.Id = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestPrivatePoolOptions) SetMatchCriteria(v string) *ModifyScalingConfigurationShrinkRequestPrivatePoolOptions {
	s.MatchCriteria = &v
	return s
}

type ModifyScalingConfigurationShrinkRequestSystemDisk struct {
	// The ID of the automatic snapshot policy that you want to apply to the system disk.
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// Specifies whether to enable the burst feature for the system disk. Valid values:
	//
	// *   true
	// *   false
	//
	// > This parameter is available only if you set `SystemDisk.Category` to `cloud_auto`.
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The category of the system disk. Valid values:
	//
	// *   cloud: basic disk
	// *   cloud_efficiency: ultra disk
	// *   cloud_ssd: standard SSD
	// *   cloud_essd: enhanced SSD (ESSD)
	// *   ephemeral_ssd: local SSD
	//
	// If you specify SystemDisk.Category, you cannot specify `SystemDiskCategories`. If you do not specify SystemDisk.Category or `SystemDiskCategories`, the default value of SystemDisk.Category is used. For non-I/O optimized instances of Generation I instance types, the default value is cloud. For instances of other instance types, the default value is cloud_efficiency.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The description of the system disk. The description must be 2 to 256 characters in length. The description can contain letters but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the system disk. The name must be 2 to 128 characters in length, and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with [http:// or https://. Default value: null.](http://https://。、（:）、（\_）（-）。：)
	DiskName *string `json:"DiskName,omitempty" xml:"DiskName,omitempty"`
	// The algorithm that you want to use to encrypt the system disk. Valid values:
	//
	// *   AES-256
	// *   SM4-128
	//
	// Default value: AES-256
	EncryptAlgorithm *string `json:"EncryptAlgorithm,omitempty" xml:"EncryptAlgorithm,omitempty"`
	// Specifies whether to encrypt the system disk. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false
	Encrypted *bool `json:"Encrypted,omitempty" xml:"Encrypted,omitempty"`
	// The ID of the KMS key that you want to use to encrypt the system disk.
	KMSKeyId *string `json:"KMSKeyId,omitempty" xml:"KMSKeyId,omitempty"`
	// The performance level (PL) of the system disk that is an ESSD. Valid values:
	//
	// *   PL0: An ESSD can provide up to 10,000 random read/write IOPS.
	// *   PL1: An ESSD can provide up to 50,000 random read/write IOPS.
	// *   PL2: An ESSD can provide up to 100,000 random read/write IOPS.
	// *   PL3: An ESSD can provide up to 1,000,000 random read/write IOPS.
	//
	// > For more information about how to select ESSD PLs, see [ESSD](~~122389~~).
	PerformanceLevel *string `json:"PerformanceLevel,omitempty" xml:"PerformanceLevel,omitempty"`
	// The IOPS metric that is preconfigured for the system disk.
	//
	// > IOPS measures the number of read and write operations that an EBS device can process per second.
	ProvisionedIops *int64 `json:"ProvisionedIops,omitempty" xml:"ProvisionedIops,omitempty"`
	// The size of the system disk. Unit: GiB. Valid values:
	//
	// *   If you set SystemDisk.Category to cloud: 20 to 500.
	// *   If you set SystemDisk.Category to cloud_efficiency: 20 to 500.
	// *   If you set SystemDisk.Category to cloud_ssd: 20 to 500.
	// *   If you set SystemDisk.Category to cloud_essd: 20 to 500.
	// *   If you set SystemDisk.Category to ephemeral_ssd: 20 to 500.
	//
	// The value of SystemDisk.Size must be greater than or equal to max{20, ImageSize}.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
}

func (s ModifyScalingConfigurationShrinkRequestSystemDisk) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationShrinkRequestSystemDisk) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationShrinkRequestSystemDisk) SetAutoSnapshotPolicyId(v string) *ModifyScalingConfigurationShrinkRequestSystemDisk {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestSystemDisk) SetBurstingEnabled(v bool) *ModifyScalingConfigurationShrinkRequestSystemDisk {
	s.BurstingEnabled = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestSystemDisk) SetCategory(v string) *ModifyScalingConfigurationShrinkRequestSystemDisk {
	s.Category = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestSystemDisk) SetDescription(v string) *ModifyScalingConfigurationShrinkRequestSystemDisk {
	s.Description = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestSystemDisk) SetDiskName(v string) *ModifyScalingConfigurationShrinkRequestSystemDisk {
	s.DiskName = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestSystemDisk) SetEncryptAlgorithm(v string) *ModifyScalingConfigurationShrinkRequestSystemDisk {
	s.EncryptAlgorithm = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestSystemDisk) SetEncrypted(v bool) *ModifyScalingConfigurationShrinkRequestSystemDisk {
	s.Encrypted = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestSystemDisk) SetKMSKeyId(v string) *ModifyScalingConfigurationShrinkRequestSystemDisk {
	s.KMSKeyId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestSystemDisk) SetPerformanceLevel(v string) *ModifyScalingConfigurationShrinkRequestSystemDisk {
	s.PerformanceLevel = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestSystemDisk) SetProvisionedIops(v int64) *ModifyScalingConfigurationShrinkRequestSystemDisk {
	s.ProvisionedIops = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestSystemDisk) SetSize(v int32) *ModifyScalingConfigurationShrinkRequestSystemDisk {
	s.Size = &v
	return s
}

type ModifyScalingConfigurationShrinkRequestDataDisks struct {
	// The ID of the automatic snapshot policy that you want to apply to the data disk.
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// Specifies whether to enable the burst feature for the system disk. Valid values:
	//
	// *   true
	// *   false
	//
	// > This parameter is available only if you set `SystemDisk.Category` to `cloud_auto`.
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The categories of the data disks. Valid values:
	//
	// *   cloud: basic disk. The DeleteWithInstance attribute of a basic disk that is created together with the instance is set to true.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   cloud_essd: ESSD.
	//
	// > If you specify Categories, you cannot specify `DataDisk.Category`.
	Categories []*string `json:"Categories,omitempty" xml:"Categories,omitempty" type:"Repeated"`
	// The category of the data disk. Valid values:
	//
	// *   cloud: basic disk. The DeleteWithInstance attribute of a basic disk that is created together with the instance is set to true.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   ephemeral_ssd: local SSD.
	// *   cloud_essd: ESSD.
	//
	// If you specify Category, you cannot specify `Categories`. If you do not specify Category or `Categories`, the default value of Category is used:
	//
	// *   For I/O optimized instances, the default value is cloud_efficiency.
	// *   For non-I/O optimized instances, the default value is cloud.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// Specifies whether to release the data disk when the instance to which the data disk is attached is released. Valid values:
	//
	// *   true
	// *   false
	//
	// This parameter is available only for independent disks whose Category is set to cloud, cloud_efficiency, cloud_ssd, cloud_essd, or cloud_auto. If you specify this parameter for other disks, an error is reported.
	DeleteWithInstance *bool `json:"DeleteWithInstance,omitempty" xml:"DeleteWithInstance,omitempty"`
	// The description of the system disk. The description must be 2 to 256 characters in length. The description can contain letters but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The mount target of the data disk. If you do not specify Device, a mount target is automatically assigned when Auto Scaling creates ECS instances. The name of the mount target ranges from /dev/xvdb to /dev/xvdz.
	Device *string `json:"Device,omitempty" xml:"Device,omitempty"`
	// The name of the system disk. The name must be 2 to 128 characters in length, and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
	DiskName *string `json:"DiskName,omitempty" xml:"DiskName,omitempty"`
	// Specifies whether to encrypt the system disk. Valid values:
	//
	// *   true
	// *   false
	Encrypted *string `json:"Encrypted,omitempty" xml:"Encrypted,omitempty"`
	// The ID of the Key Management Service (KMS) key that you want to use to encrypt the data disk.
	KMSKeyId *string `json:"KMSKeyId,omitempty" xml:"KMSKeyId,omitempty"`
	// The PL of the data disk that is an ESSD. Valid values:
	//
	// *   PL0: An ESSD can provide up to 10,000 random read/write IOPS.
	// *   PL1: An ESSD can provide up to 50,000 random read/write IOPS.
	// *   PL2: An ESSD can provide up to 100,000 random read/write IOPS.
	// *   PL3: An ESSD can provide up to 1,000,000 random read/write IOPS.
	//
	// > For more information about how to select ESSD PLs, see [ESSD](~~122389~~).
	PerformanceLevel *string `json:"PerformanceLevel,omitempty" xml:"PerformanceLevel,omitempty"`
	// The IOPS metric that is preconfigured for the data disk.
	//
	// > IOPS measures the number of read and write operations that an Elastic Block Storage (EBS) device can process per second.
	ProvisionedIops *int64 `json:"ProvisionedIops,omitempty" xml:"ProvisionedIops,omitempty"`
	// The size of the data disk. Unit: GiB. Valid values:
	//
	// *   If you set Categories cloud: 5 to 2000.
	// *   If you set Categories to cloud_efficiency: 20 to 32768.
	// *   If you set Categories to cloud_ssd: 20 to 32768.
	// *   If you set Categories to cloud_essd: 20 to 32768.
	// *   If you set Categories to ephemeral_ssd: 5 to 800.
	//
	// The size of the data disk must be greater than or equal to the size of the snapshot that is specified by SnapshotId.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The ID of the snapshot that you want to use to create data disks. If you specify this parameter, DataDisk.N.Size is ignored. The size of the disk is the same as the size of the specified snapshot.
	//
	// If you specify a snapshot that is created on or before July 15, 2013, the operation fails and the system returns InvalidSnapshot.TooOld.
	SnapshotId *string `json:"SnapshotId,omitempty" xml:"SnapshotId,omitempty"`
}

func (s ModifyScalingConfigurationShrinkRequestDataDisks) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationShrinkRequestDataDisks) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetAutoSnapshotPolicyId(v string) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetBurstingEnabled(v bool) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.BurstingEnabled = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetCategories(v []*string) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.Categories = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetCategory(v string) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.Category = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetDeleteWithInstance(v bool) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.DeleteWithInstance = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetDescription(v string) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.Description = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetDevice(v string) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.Device = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetDiskName(v string) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.DiskName = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetEncrypted(v string) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.Encrypted = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetKMSKeyId(v string) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.KMSKeyId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetPerformanceLevel(v string) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.PerformanceLevel = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetProvisionedIops(v int64) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.ProvisionedIops = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetSize(v int32) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.Size = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetSnapshotId(v string) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.SnapshotId = &v
	return s
}

type ModifyScalingConfigurationShrinkRequestInstancePatternInfos struct {
	// The architectures of the instance types.
	//
	// *   X86: x86 architecture.
	// *   Heterogeneous: heterogeneous architecture, such as GPUs and FPGAs.
	// *   BareMetal: ECS Bare Metal Instance architecture.
	// *   Arm: ARM architecture.
	// *   SuperComputeCluster: Super Computing Cluster architecture.
	//
	// By default, all values are included.
	Architectures []*string `json:"Architectures,omitempty" xml:"Architectures,omitempty" type:"Repeated"`
	// Specifies whether to include burstable instance types. Valid values:
	//
	// *   Exclude: does not include burstable instance types.
	// *   Include: includes burstable instance types.
	// *   Required: includes only burstable instance types.
	//
	// Default value: Include
	BurstablePerformance *string `json:"BurstablePerformance,omitempty" xml:"BurstablePerformance,omitempty"`
	// The number of vCPUs that you want to allocate to an instance type in intelligent configuration mode. You can use this parameter to filter the available instance types that meet the specified criteria. For more information, see [Overview of instance families](~~25378~~).
	//
	// When you specify this parameter, take note of the following items:
	//
	// *   InstancePatternInfo is available only for scaling groups that reside in VPCs.
	// *   If you specify InstancePatternInfo, you must also specify Cores and Memory.
	// *   If you specify an instance type by using InstanceType or InstanceTypes, Auto Scaling preferentially creates instances by using the instance type that is specified by InstanceType or InstanceTypes for scale-outs. If the specified instance type does not have sufficient inventory, Auto Scaling creates instances by using the lowest-priced instance type that is specified by InstancePatternInfo.
	Cores *int32 `json:"Cores,omitempty" xml:"Cores,omitempty"`
	// The instance types that you want to exclude. You can use wildcard characters such as an asterisk (\*) to exclude an instance type or an instance family. Examples:
	//
	// *   ecs.c6.large: excludes the ecs.c6.large instance type.
	// *   ecs.c6.\*: excludes the c6 instance family.
	ExcludedInstanceTypes []*string `json:"ExcludedInstanceTypes,omitempty" xml:"ExcludedInstanceTypes,omitempty" type:"Repeated"`
	// The level of the instance family. You can use this parameter to filter instance types that meet the specified criteria. This parameter takes effect only if you set `CostOptimization` to true. Valid values:
	//
	// *   EntryLevel: entry level (shared instance type). Instance types of this level are the most cost-effective but may not provide stable computing performance in a consistent manner. Instance types of this level are suitable for business scenarios in which CPU utilization is low. For more information, see [Shared instance families](~~108489~~).
	// *   EnterpriseLevel: enterprise level. Instance types of this level provide stable performance and dedicated resources and are suitable for business scenarios that require high stability. For more information, see the [Overview of instance families](~~25378~~) topic.
	// *   CreditEntryLevel: credit entry level. This value is valid only for burstable instances. CPU credits are used to ensure computing performance. Instance types of this level are suitable for business scenarios in which CPU utilization is low but may fluctuate in specific scenarios. For more information, see [Overview](~~59977~~) of burstable instances.
	InstanceFamilyLevel *string `json:"InstanceFamilyLevel,omitempty" xml:"InstanceFamilyLevel,omitempty"`
	// The maximum hourly price for a pay-as-you-go instance or a preemptible instance in intelligent configuration mode. You can use this parameter to filter the available instance types that meet the specified criteria.
	//
	// > If you set SpotStrategy to SpotWithPriceLimit, specify MaxPrice. In other scenarios, MaxPrice is optional.
	MaxPrice *float32 `json:"MaxPrice,omitempty" xml:"MaxPrice,omitempty"`
	// The memory size that you want to allocate to an instance type in intelligent configuration mode. Unit: GiB. You can use this parameter to filter the available instance types that meet the specified criteria.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
}

func (s ModifyScalingConfigurationShrinkRequestInstancePatternInfos) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationShrinkRequestInstancePatternInfos) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationShrinkRequestInstancePatternInfos) SetArchitectures(v []*string) *ModifyScalingConfigurationShrinkRequestInstancePatternInfos {
	s.Architectures = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestInstancePatternInfos) SetBurstablePerformance(v string) *ModifyScalingConfigurationShrinkRequestInstancePatternInfos {
	s.BurstablePerformance = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestInstancePatternInfos) SetCores(v int32) *ModifyScalingConfigurationShrinkRequestInstancePatternInfos {
	s.Cores = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestInstancePatternInfos) SetExcludedInstanceTypes(v []*string) *ModifyScalingConfigurationShrinkRequestInstancePatternInfos {
	s.ExcludedInstanceTypes = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestInstancePatternInfos) SetInstanceFamilyLevel(v string) *ModifyScalingConfigurationShrinkRequestInstancePatternInfos {
	s.InstanceFamilyLevel = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestInstancePatternInfos) SetMaxPrice(v float32) *ModifyScalingConfigurationShrinkRequestInstancePatternInfos {
	s.MaxPrice = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestInstancePatternInfos) SetMemory(v float32) *ModifyScalingConfigurationShrinkRequestInstancePatternInfos {
	s.Memory = &v
	return s
}

type ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides struct {
	// The instance type. If you want to specify the capacity of instance types in the scaling configuration, specify InstanceType and WeightedCapacity at the same time.
	//
	// You can use InstanceType to specify multiple instance types and WeightedCapacity to specify the weights of the instance types.
	//
	// > If you specify InstanceType, you cannot specify InstanceTypes.
	//
	// You can use InstanceType to specify only instance types that are available for purchase.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The weight of the instance type. The weight specifies the capacity of an instance of the specified instance type in the scaling group. If you want Auto Scaling to scale instances in the scaling group based on the weighted capacity of the instances, specify WeightedCapacity after you specify InstanceType.
	//
	// A higher weight specifies that a smaller number of instances of the specified instance type are required to meet the expected capacity requirement.
	//
	// Performance metrics, such as the number of vCPUs and the memory size of each instance type, may vary. You can specify different weights for different instance types based on your business requirements.
	//
	// Example:
	//
	// *   Current capacity: 0
	// *   Expected capacity: 6
	// *   Capacity of ecs.c5.xlarge: 4
	//
	// To meet the expected capacity requirement, Auto Scaling must create and add two ecs.c5.xlarge instances.
	//
	// > The capacity of the scaling group cannot exceed the sum of the maximum number of instances that is specified by MaxSize and the maximum weight of the instance types.
	//
	// Valid values of WeightedCapacity: 1 to 500.
	WeightedCapacity *int32 `json:"WeightedCapacity,omitempty" xml:"WeightedCapacity,omitempty"`
}

func (s ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides) SetInstanceType(v string) *ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides {
	s.InstanceType = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides) SetWeightedCapacity(v int32) *ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides {
	s.WeightedCapacity = &v
	return s
}

type ModifyScalingConfigurationShrinkRequestSpotPriceLimits struct {
	// The instance type of the preemptible instance. This parameter takes effect only if you set SpotStrategy to SpotWithPriceLimit.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The price limit of the preemptible instance. This parameter takes effect only if you set SpotStrategy to SpotWithPriceLimit.
	PriceLimit *float32 `json:"PriceLimit,omitempty" xml:"PriceLimit,omitempty"`
}

func (s ModifyScalingConfigurationShrinkRequestSpotPriceLimits) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationShrinkRequestSpotPriceLimits) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationShrinkRequestSpotPriceLimits) SetInstanceType(v string) *ModifyScalingConfigurationShrinkRequestSpotPriceLimits {
	s.InstanceType = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestSpotPriceLimits) SetPriceLimit(v float32) *ModifyScalingConfigurationShrinkRequestSpotPriceLimits {
	s.PriceLimit = &v
	return s
}

type ModifyScalingConfigurationResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyScalingConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationResponseBody) SetRequestId(v string) *ModifyScalingConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type ModifyScalingConfigurationResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyScalingConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyScalingConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationResponse) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationResponse) SetHeaders(v map[string]*string) *ModifyScalingConfigurationResponse {
	s.Headers = v
	return s
}

func (s *ModifyScalingConfigurationResponse) SetStatusCode(v int32) *ModifyScalingConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyScalingConfigurationResponse) SetBody(v *ModifyScalingConfigurationResponseBody) *ModifyScalingConfigurationResponse {
	s.Body = v
	return s
}

type ModifyScalingGroupRequest struct {
	// The health check mode of the scaling group. Valid values:
	//
	// *   NONE: Auto Scaling does not perform health checks on instances in the scaling group.
	// *   ECS: Auto Scaling performs health checks on ECS instances in the scaling group.
	ActiveScalingConfigurationId *string `json:"ActiveScalingConfigurationId,omitempty" xml:"ActiveScalingConfigurationId,omitempty"`
	// The allocation policy of preemptible instances. You can use this parameter to individually specify the allocation policy of preemptible instances. This parameter takes effect only when you set the `MultiAZPolicy` parameter to `COMPOSABLE`. Valid values:
	//
	// *   priority: Auto Scaling selects instance types based on the specified order to create the required number of preemptible instances.
	// *   lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of preemptible instances.
	//
	// Default value: priority.
	AllocationStrategy *string `json:"AllocationStrategy,omitempty" xml:"AllocationStrategy,omitempty"`
	// The allocation policy. Auto Scaling selects instance types based on the allocation policy to create the required number of instances. The policy can be applied to pay-as-you-go instances and preemptible instances at the same time. This parameter takes effect only when you set the MultiAZPolicy parameter to COMPOSABLE. Valid values:
	//
	// *   priority: Auto Scaling selects instance types based on the specified order to create the required number of instances.
	// *   lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of instances.
	//
	// Default value: priority.
	AzBalance *bool `json:"AzBalance,omitempty" xml:"AzBalance,omitempty"`
	// The number of instance types that you specify. Auto Scaling creates preemptible instances of multiple instance types that are provided at the lowest price. Valid values: 0 to 10.
	//
	// If you set the `MultiAZPolicy` parameter to `COMPOSABLE` Policy, the default value is 2.
	CompensateWithOnDemand *bool `json:"CompensateWithOnDemand,omitempty" xml:"CompensateWithOnDemand,omitempty"`
	// The ID of the request.
	CustomPolicyARN *string `json:"CustomPolicyARN,omitempty" xml:"CustomPolicyARN,omitempty"`
	// The policy that is used to remove ECS instances from the scaling group. Valid values:
	//
	// *   OldestInstance: removes ECS instances that are added at the earliest point in time to the scaling group.
	// *   NewestInstance: removes ECS instances that are most recently added to the scaling group.
	// *   OldestScalingConfiguration: removes ECS instances that are created based on the earliest scaling configuration.
	DefaultCooldown *int32 `json:"DefaultCooldown,omitempty" xml:"DefaultCooldown,omitempty"`
	// Specifies whether to enable deletion protection for the scaling group. Valid values:
	//
	// *   true: enables deletion protection for the scaling group. This way, the scaling group cannot be deleted.
	// *   false: disables deletion protection for the scaling group.
	DesiredCapacity        *int32 `json:"DesiredCapacity,omitempty" xml:"DesiredCapacity,omitempty"`
	DisableDesiredCapacity *bool  `json:"DisableDesiredCapacity,omitempty" xml:"DisableDesiredCapacity,omitempty"`
	// The scaling policy for the multi-zone scaling group that contains ECS instances. Valid values:
	//
	// *   PRIORITY: ECS instances are scaled based on the vSwitch priority. The first vSwitch specified by using the VSwitchIds parameter has the highest priority. Auto Scaling preferentially scales instances in the zone where the vSwitch that has the highest priority resides. If the scaling fails, Auto Scaling scales instances in the zone where the vSwitch that has the next highest priority resides.
	// *   COST_OPTIMIZED: During a scale-out activity, Auto Scaling preferentially creates ECS instances of the instance type that has the lowest unit price of vCPU. During a scale-in activity, Auto Scaling preferentially removes ECS instances of the instance types that have the highest unit price of vCPU. Auto Scaling preferentially creates preemptible instances when preemptible instance types are specified in the scaling configuration. You can use the `CompensateWithOnDemand` parameter to specify whether to automatically create pay-as-you-go instances when Auto Scaling fails to create preemptible instances.
	//
	// > The `COST_OPTIMIZED` setting takes effect only when multiple instance types are specified or at least one instance type is specified for preemptible instances.
	//
	// *   BALANCE: ECS instances are evenly distributed across zones that are specified in the scaling group. If ECS instances are unevenly distributed among zones due to insufficient resources, you can call the RebalanceInstance operation to evenly distribute the instances among the zones.
	// *   COMPOSABLE: You can flexibly combine the preceding policies based on your business requirements.
	GroupDeletionProtection *bool `json:"GroupDeletionProtection,omitempty" xml:"GroupDeletionProtection,omitempty"`
	// The ID of the launch template that is used by Auto Scaling to create instances.
	HealthCheckType *string `json:"HealthCheckType,omitempty" xml:"HealthCheckType,omitempty"`
	// The version number of the launch template. Valid values:
	//
	// *   A fixed template version number.
	// *   Default: The default template version is always used.
	// *   Latest: The latest template version is always used.
	LaunchTemplateId *string `json:"LaunchTemplateId,omitempty" xml:"LaunchTemplateId,omitempty"`
	// Details of the instance types that are specified in the extended configurations of the launch template.
	LaunchTemplateOverrides []*ModifyScalingGroupRequestLaunchTemplateOverrides `json:"LaunchTemplateOverrides,omitempty" xml:"LaunchTemplateOverrides,omitempty" type:"Repeated"`
	// The minimum number of pay-as-you-go instances that must be included in the scaling group. Valid values: 0 to 1000. If the number of pay-as-you-go instances is less than the value of this parameter, Auto Scaling preferentially creates pay-as-you-go instances.
	//
	// If you set the `MultiAZPolicy` parameter to `COMPOSABLE` Policy, the default value is 0.
	LaunchTemplateVersion *string `json:"LaunchTemplateVersion,omitempty" xml:"LaunchTemplateVersion,omitempty"`
	// Specifies whether to evenly distribute instances in the scaling group across zones. This parameter takes effect only when you set the `MultiAZPolicy` parameter to `COMPOSABLE`. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	MaxInstanceLifetime *int32 `json:"MaxInstanceLifetime,omitempty" xml:"MaxInstanceLifetime,omitempty"`
	// The default cooldown time of the scaling group. This parameter takes effect only for scaling groups that have simple scaling rules. Valid values: 0 to 86400. Unit: seconds. During the cooldown time, Auto Scaling executes only scaling activities that are triggered by event-triggered tasks associated with CloudMonitor.
	MaxSize *int32 `json:"MaxSize,omitempty" xml:"MaxSize,omitempty"`
	// The maximum number of ECS instances in the scaling group. When the number of ECS instances in the scaling group is greater than the value of the MaxSize parameter, Auto Scaling automatically removes ECS instances from the scaling group until the number of instances is equal to the value of the MaxSize parameter.
	//
	// The value range of the MaxSize parameter varies based on the instance quota. You can go to [Quota Center](https://quotas.console.aliyun.com/products/ess/quotas) to check the quota of **instances that can be included in a scaling group**.
	//
	// For example, if the quota of instances that can be included in a scaling group is 2000, the valid values of the MaxSize parameter range from 0 to 2000.
	MinSize *int32 `json:"MinSize,omitempty" xml:"MinSize,omitempty"`
	// The IDs of vSwitches.
	//
	// This parameter takes effect only when the network type of the scaling group is virtual private cloud (VPC). The specified vSwitches and the scaling group must reside in the same VPC.
	//
	// The vSwitches can reside in different zones. The vSwitches are sorted in ascending order. The first vSwitch specified by using the VSwitchIds parameter has the highest priority. If Auto Scaling fails to create ECS instances in the zone where the vSwitch that has the highest priority resides, Auto Scaling creates ECS instances in the zone where the vSwitch that has the next highest priority resides.
	MultiAZPolicy *string `json:"MultiAZPolicy,omitempty" xml:"MultiAZPolicy,omitempty"`
	// The expected percentage of pay-as-you-go instances in the excess instances when the minimum number of pay-as-you-go instances reaches the requirement. Valid values: 0 to 100.
	//
	// If you set the `MultiAZPolicy` parameter to `COMPOSABLE` Policy, the default value is 100.
	OnDemandBaseCapacity *int32 `json:"OnDemandBaseCapacity,omitempty" xml:"OnDemandBaseCapacity,omitempty"`
	// Specifies whether to supplement preemptible instances. If this parameter is set to true, Auto Scaling creates an instance to replace a preemptible instance when Auto Scaling receives the system message that the preemptible instance is to be reclaimed.
	OnDemandPercentageAboveBaseCapacity *int32  `json:"OnDemandPercentageAboveBaseCapacity,omitempty" xml:"OnDemandPercentageAboveBaseCapacity,omitempty"`
	OwnerAccount                        *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                             *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The policy that is used to remove ECS instances from the scaling group. Valid values:
	//
	// *   OldestInstance: removes ECS instances that are added at the earliest point in time to the scaling group.
	// *   NewestInstance: removes ECS instances that are most recently added to the scaling group.
	// *   OldestScalingConfiguration: removes ECS instances that are created based on the earliest scaling configuration.
	RemovalPolicies      []*string `json:"RemovalPolicies,omitempty" xml:"RemovalPolicies,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The name of the scaling group. The name of each scaling group must be unique in a region. The name must be 2 to 64 characters in length and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). The name must start with a letter or a digit.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The minimum number of ECS instances in the scaling group. When the number of ECS instances in the scaling group is less than the value of the MinSize parameter, Auto Scaling automatically creates ECS instances and adds the instances to the scaling group until the number of instances is equal to the value of the MinSize parameter.
	//
	// > The value of the MinSize parameter must be less than or equal to the value of the MaxSize parameter.
	ScalingGroupName *string `json:"ScalingGroupName,omitempty" xml:"ScalingGroupName,omitempty"`
	// The ARN of the custom scaling policy (Function). This parameter takes effect only when you specify CustomPolicy as the first step of the instance removal policy.
	SpotAllocationStrategy *string `json:"SpotAllocationStrategy,omitempty" xml:"SpotAllocationStrategy,omitempty"`
	// The expected number of ECS instances in the scaling group. Auto Scaling automatically maintains the specified expected number of ECS instances. The expected number cannot be greater than the value of the MaxSize parameter and cannot be less than the value of the MinSize parameter.
	SpotInstancePools *int32 `json:"SpotInstancePools,omitempty" xml:"SpotInstancePools,omitempty"`
	// Specifies whether to automatically create pay-as-you-go instances to meet the requirements on the number of ECS instances in the scaling group when the number of preemptible instances cannot be reached due to reasons such as costs and insufficient resources. This parameter takes effect only if you set the MultiAZPolicy parameter in the CreateScalingGroup operation to COST_OPTIMIZED. Valid values:
	//
	// *   true
	// *   false
	SpotInstanceRemedy *bool `json:"SpotInstanceRemedy,omitempty" xml:"SpotInstanceRemedy,omitempty"`
	// The IDs of vSwitches.
	//
	// This parameter takes effect only when the network type of the scaling group is VPC. The specified vSwitches and the scaling group must reside in the same VPC.
	//
	// The vSwitches can reside in different zones. The vSwitches are sorted in ascending order. The first vSwitch specified by using the VSwitchIds parameter has the highest priority. If Auto Scaling fails to create ECS instances in the zone where the vSwitch that has the highest priority resides, Auto Scaling creates ECS instances in the zone where the vSwitch that has the next highest priority resides.
	VSwitchIds []*string `json:"VSwitchIds,omitempty" xml:"VSwitchIds,omitempty" type:"Repeated"`
}

func (s ModifyScalingGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingGroupRequest) GoString() string {
	return s.String()
}

func (s *ModifyScalingGroupRequest) SetActiveScalingConfigurationId(v string) *ModifyScalingGroupRequest {
	s.ActiveScalingConfigurationId = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetAllocationStrategy(v string) *ModifyScalingGroupRequest {
	s.AllocationStrategy = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetAzBalance(v bool) *ModifyScalingGroupRequest {
	s.AzBalance = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetCompensateWithOnDemand(v bool) *ModifyScalingGroupRequest {
	s.CompensateWithOnDemand = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetCustomPolicyARN(v string) *ModifyScalingGroupRequest {
	s.CustomPolicyARN = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetDefaultCooldown(v int32) *ModifyScalingGroupRequest {
	s.DefaultCooldown = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetDesiredCapacity(v int32) *ModifyScalingGroupRequest {
	s.DesiredCapacity = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetDisableDesiredCapacity(v bool) *ModifyScalingGroupRequest {
	s.DisableDesiredCapacity = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetGroupDeletionProtection(v bool) *ModifyScalingGroupRequest {
	s.GroupDeletionProtection = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetHealthCheckType(v string) *ModifyScalingGroupRequest {
	s.HealthCheckType = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetLaunchTemplateId(v string) *ModifyScalingGroupRequest {
	s.LaunchTemplateId = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetLaunchTemplateOverrides(v []*ModifyScalingGroupRequestLaunchTemplateOverrides) *ModifyScalingGroupRequest {
	s.LaunchTemplateOverrides = v
	return s
}

func (s *ModifyScalingGroupRequest) SetLaunchTemplateVersion(v string) *ModifyScalingGroupRequest {
	s.LaunchTemplateVersion = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetMaxInstanceLifetime(v int32) *ModifyScalingGroupRequest {
	s.MaxInstanceLifetime = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetMaxSize(v int32) *ModifyScalingGroupRequest {
	s.MaxSize = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetMinSize(v int32) *ModifyScalingGroupRequest {
	s.MinSize = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetMultiAZPolicy(v string) *ModifyScalingGroupRequest {
	s.MultiAZPolicy = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetOnDemandBaseCapacity(v int32) *ModifyScalingGroupRequest {
	s.OnDemandBaseCapacity = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetOnDemandPercentageAboveBaseCapacity(v int32) *ModifyScalingGroupRequest {
	s.OnDemandPercentageAboveBaseCapacity = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetOwnerAccount(v string) *ModifyScalingGroupRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetOwnerId(v int64) *ModifyScalingGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetRemovalPolicies(v []*string) *ModifyScalingGroupRequest {
	s.RemovalPolicies = v
	return s
}

func (s *ModifyScalingGroupRequest) SetResourceOwnerAccount(v string) *ModifyScalingGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetResourceOwnerId(v int64) *ModifyScalingGroupRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetScalingGroupId(v string) *ModifyScalingGroupRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetScalingGroupName(v string) *ModifyScalingGroupRequest {
	s.ScalingGroupName = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetSpotAllocationStrategy(v string) *ModifyScalingGroupRequest {
	s.SpotAllocationStrategy = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetSpotInstancePools(v int32) *ModifyScalingGroupRequest {
	s.SpotInstancePools = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetSpotInstanceRemedy(v bool) *ModifyScalingGroupRequest {
	s.SpotInstanceRemedy = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetVSwitchIds(v []*string) *ModifyScalingGroupRequest {
	s.VSwitchIds = v
	return s
}

type ModifyScalingGroupRequestLaunchTemplateOverrides struct {
	// The weight of the instance type. The weight specifies the capacity of a single instance of the specified instance type in the scaling group. If you want Auto Scaling to scale instances in the scaling group based on the weighted capacity of instances, you must specify the WeightedCapacity parameter after you specify the InstanceType parameter.
	//
	// A higher weight specifies that a smaller number of instances of the specified instance type are required to meet the expected capacity.
	//
	// Performance metrics, such as the number of vCPUs and the memory size of each instance type, may vary. You can specify different weights for different instance types based on your business requirements.
	//
	// Example:
	//
	// *   Current capacity: 0
	// *   Expected capacity: 6
	// *   Capacity of ecs.c5.xlarge: 4
	//
	// To meet the expected capacity requirement, Auto Scaling must create and add two ecs.c5.xlarge instances.
	//
	// > The capacity of the scaling group cannot exceed the sum of the maximum number of instances that is specified by the MaxSize parameter and the maximum weight of the instance type.
	//
	// Valid values of the WeightedCapacity parameter: 1 to 500.
	InstanceType   *string  `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	SpotPriceLimit *float32 `json:"SpotPriceLimit,omitempty" xml:"SpotPriceLimit,omitempty"`
	// The maximum life span of the instance in the scaling group. Unit: seconds.
	//
	// Valid values: 86400 to Integer.maxValue. ``You can also set this parameter to 0. A value of 0 indicates that the instance has an unlimited life span in the scaling group.
	//
	// Default value: null.
	//
	// > You cannot specify this parameter for scaling groups that manage elastic container instances or scaling groups whose ScalingPolicy is set to recycle.
	WeightedCapacity *int32 `json:"WeightedCapacity,omitempty" xml:"WeightedCapacity,omitempty"`
}

func (s ModifyScalingGroupRequestLaunchTemplateOverrides) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingGroupRequestLaunchTemplateOverrides) GoString() string {
	return s.String()
}

func (s *ModifyScalingGroupRequestLaunchTemplateOverrides) SetInstanceType(v string) *ModifyScalingGroupRequestLaunchTemplateOverrides {
	s.InstanceType = &v
	return s
}

func (s *ModifyScalingGroupRequestLaunchTemplateOverrides) SetSpotPriceLimit(v float32) *ModifyScalingGroupRequestLaunchTemplateOverrides {
	s.SpotPriceLimit = &v
	return s
}

func (s *ModifyScalingGroupRequestLaunchTemplateOverrides) SetWeightedCapacity(v int32) *ModifyScalingGroupRequestLaunchTemplateOverrides {
	s.WeightedCapacity = &v
	return s
}

type ModifyScalingGroupResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyScalingGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyScalingGroupResponseBody) SetRequestId(v string) *ModifyScalingGroupResponseBody {
	s.RequestId = &v
	return s
}

type ModifyScalingGroupResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyScalingGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyScalingGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingGroupResponse) GoString() string {
	return s.String()
}

func (s *ModifyScalingGroupResponse) SetHeaders(v map[string]*string) *ModifyScalingGroupResponse {
	s.Headers = v
	return s
}

func (s *ModifyScalingGroupResponse) SetStatusCode(v int32) *ModifyScalingGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyScalingGroupResponse) SetBody(v *ModifyScalingGroupResponseBody) *ModifyScalingGroupResponse {
	s.Body = v
	return s
}

type ModifyScalingRuleRequest struct {
	// The adjustment method of the scaling rule. This is required when the ScalingRuleType parameter is set to SimpleScalingRule or StepScalingRule. Valid values:
	//
	// *   QuantityChangeInCapacity: adds the specified number of ECS instances to or removes the specified number of ECS instances from the scaling group.
	// *   PercentChangeInCapacity: adds the specified percentage of ECS instances to or removes the specified percentage of ECS instances from the scaling group.
	// *   TotalCapacity: adjusts the number of ECS instances in the scaling group to the specified number.
	AdjustmentType *string `json:"AdjustmentType,omitempty" xml:"AdjustmentType,omitempty"`
	// The target value specified in the scaling rule. This parameter is required when the ScalingRuleType parameter is set to SimpleScalingRule or StepScalingRule. The number of ECS instances that are scaled in a single scaling activity cannot exceed 1,000.
	//
	// *   Valid values if you set the AdjustmentType parameter to QuantityChangeInCapacity: -1000 to 1000.
	// *   Valid values if you set the AdjustmentType parameter to PercentChangeInCapacity: -100 to 10000.
	// *   Valid values if you set the AdjustmentType parameter to TotalCapacity: 0 to 2000.
	AdjustmentValue *int32 `json:"AdjustmentValue,omitempty" xml:"AdjustmentValue,omitempty"`
	// 监控项维度信息值，适用于目标追踪规则，当监控项需额外维度信息时设置，例如LoadBalancerRealServerAverageQps监控项需指定rulePool维度信息。
	AlarmDimensions []*ModifyScalingRuleRequestAlarmDimensions `json:"AlarmDimensions,omitempty" xml:"AlarmDimensions,omitempty" type:"Repeated"`
	// The cooldown time of the scaling rule. This parameter is available only if you set the ScalingRuleType parameter to SimpleScalingRule.
	//
	// Valid values: 0 to 86400. Unit: seconds.
	Cooldown *int32 `json:"Cooldown,omitempty" xml:"Cooldown,omitempty"`
	// Specifies whether to disable scale-in. This parameter is available only if you set the ScalingRuleType parameter to TargetTrackingScalingRule.
	DisableScaleIn *bool `json:"DisableScaleIn,omitempty" xml:"DisableScaleIn,omitempty"`
	// The warmup period of an instance. This parameter is available only if you set the ScalingRuleType parameter to TargetTrackingScalingRule or PredictiveScalingRule. Auto Scaling adds ECS instances that are in the warmup state to a scaling group but does not report monitoring data to CloudMonitor during the warmup period.
	//
	// > Auto Scaling calculates the number of ECS instances that need to be scaled. ECS instances in the warmup state are not counted towards the current capacity of the scaling group.
	//
	// Valid values: 0 to 86400. Unit: seconds.
	EstimatedInstanceWarmup *int32 `json:"EstimatedInstanceWarmup,omitempty" xml:"EstimatedInstanceWarmup,omitempty"`
	// The maximum number of ECS instances in the scaling group. If you specify this parameter, you must also specify the PredictiveValueBehavior parameter.
	InitialMaxSize *int32 `json:"InitialMaxSize,omitempty" xml:"InitialMaxSize,omitempty"`
	// The predefined metric that you want to monitor. This parameter is required only if you set the ScalingRuleType parameter to TargetTrackingScalingRule or PredictiveScalingRule.
	//
	// Valid values if you set the ScalingRuleType parameter to TargetTrackingScalingRule:
	//
	// *   CpuUtilization: the average CPU utilization
	// *   ClassicInternetRx: the average inbound Internet traffic over the classic network
	// *   ClassicInternetTx: the average outbound Internet traffic over the classic network
	// *   VpcInternetRx: the average inbound Internet traffic over the virtual private cloud (VPC)
	// *   VpcInternetTx: the average outbound Internet traffic over the VPC
	// *   IntranetRx: the average inbound traffic over the internal network
	// *   IntranetTx: the average outbound traffic over the internal network
	//
	// Valid values if you set the ScalingRuleType parameter to PredictiveScalingRule:
	//
	// *   CpuUtilization: the average CPU utilization
	// *   IntranetRx: the average inbound traffic over the internal network
	// *   IntranetTx: the average outbound traffic over the internal network
	MetricName *string `json:"MetricName,omitempty" xml:"MetricName,omitempty"`
	// The minimum number of instances that must be scaled when the AdjustmentType parameter is set to PercentChangeInCapacity. This parameter takes effect only if you set the ScalingRuleType parameter to SimpleScalingRule or StepScalingRule.
	MinAdjustmentMagnitude *int32  `json:"MinAdjustmentMagnitude,omitempty" xml:"MinAdjustmentMagnitude,omitempty"`
	OwnerAccount           *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The mode of the predictive scaling rule. Valid values:
	//
	// *   PredictAndScale: produces predictions and creates prediction tasks.
	// *   PredictOnly: produces predictions but does not create prediction tasks.
	PredictiveScalingMode *string `json:"PredictiveScalingMode,omitempty" xml:"PredictiveScalingMode,omitempty"`
	// The amount of buffer time before the prediction task is executed. By default, all prediction tasks that are automatically created for a predictive scaling rule are executed on the hour. You can specify an amount of buffer time for resource preparation before the prediction tasks are executed. Valid values: 0 to 60.
	PredictiveTaskBufferTime *int32 `json:"PredictiveTaskBufferTime,omitempty" xml:"PredictiveTaskBufferTime,omitempty"`
	// Specifies which one of the initial maximum capacity and the predicted value can be used as the maximum value for prediction tasks. Valid values:
	//
	// *   MaxOverridePredictiveValue: uses the initial maximum capacity as the maximum value for prediction tasks if the predicted value is greater than the initial maximum capacity.
	// *   PredictiveValueOverrideMax: uses the predicted value as the maximum value for prediction tasks when the predicted value is greater than the initial maximum capacity.
	// *   PredictiveValueOverrideMaxWithBuffer: increases the predicted value by a percentage that is specified by the PredictiveValueBuffer parameter. If the predicted value that is increased by the percentage is greater than the initial maximum capacity, the increased value is used as the maximum value for prediction tasks.
	PredictiveValueBehavior *string `json:"PredictiveValueBehavior,omitempty" xml:"PredictiveValueBehavior,omitempty"`
	// The percentage of the increment to the predicted value when the PredictiveValueBehavior parameter is set to PredictiveValueOverrideMaxWithBuffer. If the predicted value increased by this percentage is greater than the initial maximum capacity, the increased value is used as the maximum value for prediction tasks. Valid values: 0 to 100.
	PredictiveValueBuffer *int32  `json:"PredictiveValueBuffer,omitempty" xml:"PredictiveValueBuffer,omitempty"`
	ResourceOwnerAccount  *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId       *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The number of consecutive times that the event-triggered task created for scale-in activities must meet the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.
	ScaleInEvaluationCount *int32 `json:"ScaleInEvaluationCount,omitempty" xml:"ScaleInEvaluationCount,omitempty"`
	// The number of consecutive times that the event-triggered task created for scale-out activities must meet the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.
	ScaleOutEvaluationCount *int32 `json:"ScaleOutEvaluationCount,omitempty" xml:"ScaleOutEvaluationCount,omitempty"`
	// The ID of the scaling rule that you want to modify.
	ScalingRuleId *string `json:"ScalingRuleId,omitempty" xml:"ScalingRuleId,omitempty"`
	// The name of the scaling rule. The name must be 2 to 64 characters in length, and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). The name must start with a letter or a digit. The name of a scaling rule must be unique in the scaling group to which the scaling rule belongs and within an Alibaba Cloud account.
	ScalingRuleName *string `json:"ScalingRuleName,omitempty" xml:"ScalingRuleName,omitempty"`
	// Details of the step adjustments.
	StepAdjustments []*ModifyScalingRuleRequestStepAdjustments `json:"StepAdjustments,omitempty" xml:"StepAdjustments,omitempty" type:"Repeated"`
	// The target value. This parameter is available only if you set the ScalingRuleType parameter to TargetTrackingScalingRule or PredictiveScalingRule. The value must be greater than 0 and can have up to three decimal places.
	TargetValue *float32 `json:"TargetValue,omitempty" xml:"TargetValue,omitempty"`
}

func (s ModifyScalingRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingRuleRequest) GoString() string {
	return s.String()
}

func (s *ModifyScalingRuleRequest) SetAdjustmentType(v string) *ModifyScalingRuleRequest {
	s.AdjustmentType = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetAdjustmentValue(v int32) *ModifyScalingRuleRequest {
	s.AdjustmentValue = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetAlarmDimensions(v []*ModifyScalingRuleRequestAlarmDimensions) *ModifyScalingRuleRequest {
	s.AlarmDimensions = v
	return s
}

func (s *ModifyScalingRuleRequest) SetCooldown(v int32) *ModifyScalingRuleRequest {
	s.Cooldown = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetDisableScaleIn(v bool) *ModifyScalingRuleRequest {
	s.DisableScaleIn = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetEstimatedInstanceWarmup(v int32) *ModifyScalingRuleRequest {
	s.EstimatedInstanceWarmup = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetInitialMaxSize(v int32) *ModifyScalingRuleRequest {
	s.InitialMaxSize = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetMetricName(v string) *ModifyScalingRuleRequest {
	s.MetricName = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetMinAdjustmentMagnitude(v int32) *ModifyScalingRuleRequest {
	s.MinAdjustmentMagnitude = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetOwnerAccount(v string) *ModifyScalingRuleRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetOwnerId(v int64) *ModifyScalingRuleRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetPredictiveScalingMode(v string) *ModifyScalingRuleRequest {
	s.PredictiveScalingMode = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetPredictiveTaskBufferTime(v int32) *ModifyScalingRuleRequest {
	s.PredictiveTaskBufferTime = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetPredictiveValueBehavior(v string) *ModifyScalingRuleRequest {
	s.PredictiveValueBehavior = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetPredictiveValueBuffer(v int32) *ModifyScalingRuleRequest {
	s.PredictiveValueBuffer = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetResourceOwnerAccount(v string) *ModifyScalingRuleRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetResourceOwnerId(v int64) *ModifyScalingRuleRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetScaleInEvaluationCount(v int32) *ModifyScalingRuleRequest {
	s.ScaleInEvaluationCount = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetScaleOutEvaluationCount(v int32) *ModifyScalingRuleRequest {
	s.ScaleOutEvaluationCount = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetScalingRuleId(v string) *ModifyScalingRuleRequest {
	s.ScalingRuleId = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetScalingRuleName(v string) *ModifyScalingRuleRequest {
	s.ScalingRuleName = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetStepAdjustments(v []*ModifyScalingRuleRequestStepAdjustments) *ModifyScalingRuleRequest {
	s.StepAdjustments = v
	return s
}

func (s *ModifyScalingRuleRequest) SetTargetValue(v float32) *ModifyScalingRuleRequest {
	s.TargetValue = &v
	return s
}

type ModifyScalingRuleRequestAlarmDimensions struct {
	// 监控项关联的维度信息键。
	DimensionKey *string `json:"DimensionKey,omitempty" xml:"DimensionKey,omitempty"`
	// 监控项关联的维度信息值。
	DimensionValue *string `json:"DimensionValue,omitempty" xml:"DimensionValue,omitempty"`
}

func (s ModifyScalingRuleRequestAlarmDimensions) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingRuleRequestAlarmDimensions) GoString() string {
	return s.String()
}

func (s *ModifyScalingRuleRequestAlarmDimensions) SetDimensionKey(v string) *ModifyScalingRuleRequestAlarmDimensions {
	s.DimensionKey = &v
	return s
}

func (s *ModifyScalingRuleRequestAlarmDimensions) SetDimensionValue(v string) *ModifyScalingRuleRequestAlarmDimensions {
	s.DimensionValue = &v
	return s
}

type ModifyScalingRuleRequestStepAdjustments struct {
	// The lower limit that is specified in a step adjustment. This parameter is available only if you set the ScalingRuleType parameter to StepScalingRule. Valid values: -9.999999E18 to 9.999999E18.
	MetricIntervalLowerBound *float32 `json:"MetricIntervalLowerBound,omitempty" xml:"MetricIntervalLowerBound,omitempty"`
	// The upper limit specified in a step adjustment. This parameter is available only if you set the ScalingRuleType parameter to StepScalingRule. Valid values: -9.999999E18 to 9.999999E18.
	MetricIntervalUpperBound *float32 `json:"MetricIntervalUpperBound,omitempty" xml:"MetricIntervalUpperBound,omitempty"`
	// The number of ECS instances that you want to scale in a step adjustment. This parameter is available only if you set the ScalingRuleType parameter to StepScalingRule.
	ScalingAdjustment *int32 `json:"ScalingAdjustment,omitempty" xml:"ScalingAdjustment,omitempty"`
}

func (s ModifyScalingRuleRequestStepAdjustments) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingRuleRequestStepAdjustments) GoString() string {
	return s.String()
}

func (s *ModifyScalingRuleRequestStepAdjustments) SetMetricIntervalLowerBound(v float32) *ModifyScalingRuleRequestStepAdjustments {
	s.MetricIntervalLowerBound = &v
	return s
}

func (s *ModifyScalingRuleRequestStepAdjustments) SetMetricIntervalUpperBound(v float32) *ModifyScalingRuleRequestStepAdjustments {
	s.MetricIntervalUpperBound = &v
	return s
}

func (s *ModifyScalingRuleRequestStepAdjustments) SetScalingAdjustment(v int32) *ModifyScalingRuleRequestStepAdjustments {
	s.ScalingAdjustment = &v
	return s
}

type ModifyScalingRuleResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyScalingRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingRuleResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyScalingRuleResponseBody) SetRequestId(v string) *ModifyScalingRuleResponseBody {
	s.RequestId = &v
	return s
}

type ModifyScalingRuleResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyScalingRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyScalingRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingRuleResponse) GoString() string {
	return s.String()
}

func (s *ModifyScalingRuleResponse) SetHeaders(v map[string]*string) *ModifyScalingRuleResponse {
	s.Headers = v
	return s
}

func (s *ModifyScalingRuleResponse) SetStatusCode(v int32) *ModifyScalingRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyScalingRuleResponse) SetBody(v *ModifyScalingRuleResponseBody) *ModifyScalingRuleResponse {
	s.Body = v
	return s
}

type ModifyScheduledTaskRequest struct {
	// The description of the scheduled task. The description must be 2 to 200 characters in length.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The expected number of instances in the scaling group if you specify the ScalingGroupId parameter.
	//
	// > You must specify the `DesiredCapacity` parameter when you create a scaling group.
	DesiredCapacity *int32 `json:"DesiredCapacity,omitempty" xml:"DesiredCapacity,omitempty"`
	// The time period during which the failed scheduled task is retried. Unit: seconds. Valid values: 0 to 1800.
	//
	// Default value: 600.
	LaunchExpirationTime *int32 `json:"LaunchExpirationTime,omitempty" xml:"LaunchExpirationTime,omitempty"`
	// The point in time at which the scheduled task is triggered. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mmZ format. The time must be in UTC. You cannot enter a time point later than 90 days from the point in time at which the scheduled task is modified.
	//
	// *   If you specify the `RecurrenceType` parameter, the task is repeatedly executed at the time point that is specified by the LaunchTime parameter.
	// *   If you do not specify the `RecurrenceType` parameter, the task is executed only once at the point in time that is specified by the LaunchTime parameter.
	LaunchTime *string `json:"LaunchTime,omitempty" xml:"LaunchTime,omitempty"`
	// The maximum number of instances in the scaling group if you specify the ScalingGroupId parameter.
	MaxValue *int32 `json:"MaxValue,omitempty" xml:"MaxValue,omitempty"`
	// The minimum number of instances in the scaling group if you specify the ScalingGroupId parameter.
	MinValue     *int32  `json:"MinValue,omitempty" xml:"MinValue,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The end time of the scheduled task. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mmZ format. The time must be in UTC. You cannot enter a point in time that is later than 365 days from the point in time at which the scheduled task is modified.
	RecurrenceEndTime *string `json:"RecurrenceEndTime,omitempty" xml:"RecurrenceEndTime,omitempty"`
	// The interval at which the scheduled task is repeated. Valid values:
	//
	// *   Daily: The scheduled task is executed once every specified number of days.
	// *   Weekly: The scheduled task is executed on each specified day of the week.
	// *   Monthly: The scheduled task is executed on each specified day of the month.
	// *   Cron: The scheduled task is executed based on the specified cron expression.
	//
	// After you modify the scheduled task, the values that you specify for the `RecurrenceType` and `RecurrenceValue` parameters must be valid at the same time.
	RecurrenceType *string `json:"RecurrenceType,omitempty" xml:"RecurrenceType,omitempty"`
	// The number of recurrences of the scheduled task.
	//
	// *   If you set the `RecurrenceType` parameter to `Daily`, you can specify only one value for this parameter. Valid values: 1 to 31.
	// *   If you set the `RecurrenceType` parameter to `Weekly`, you can specify multiple values for this parameter. Separate the values with commas (,). The values that correspond to Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, and Saturday are 0, 1, 2, 3, 4, 5, and 6.``
	// *   If you set the `RecurrenceType` parameter to `Monthly`, you can specify two values in the `A-B` format for this parameter. Valid values of A and B: 1 to 31. B must be greater than or equal to A.
	// *   If you set the `RecurrenceType` parameter to `Cron`, you can specify a cron expression. A cron expression is written in UTC time and consists of the following fields: minute, hour, day, month, and week. The expression can contain the letters L and W and the following wildcard characters: commas (,), question marks (?), hyphens (-), asterisks (\*), number signs (#), and forward slashes (/).
	//
	// After you modify the scheduled task, the values that you specify for the `RecurrenceType` and `RecurrenceValue` parameters must be valid at the same time.
	RecurrenceValue      *string `json:"RecurrenceValue,omitempty" xml:"RecurrenceValue,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the scaling group whose number of instances must be modified when the scheduled task is triggered. If you specify the `ScalingGroupId` parameter for a scheduled task, you must specify the minimum, maximum, or expected numbers of instances for a scaling group in the scheduled task. That is, you must specify at least one of the `MinValue`, `MaxValue`, and `DesiredCapacity` parameters.
	//
	// > You cannot specify the `ScheduledAction` and `ScalingGroupId` parameters at the same time.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The scaling rule that you want to execute when the scheduled task is triggered. Specify the unique identifier of the scaling rule. If you specify the `ScheduledAction` parameter, you must select an existing scaling rule for the scheduled task.
	//
	// > You cannot specify the `ScheduledAction` and `ScalingGroupId` parameters at the same time.
	ScheduledAction *string `json:"ScheduledAction,omitempty" xml:"ScheduledAction,omitempty"`
	// The ID of the scheduled task.
	ScheduledTaskId *string `json:"ScheduledTaskId,omitempty" xml:"ScheduledTaskId,omitempty"`
	// The name of the scheduled task. The name must be 2 to 64 characters in length, and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). It must start with a letter or a digit. The name of the scheduled task must be unique in the region and within the Alibaba Cloud account.
	ScheduledTaskName *string `json:"ScheduledTaskName,omitempty" xml:"ScheduledTaskName,omitempty"`
	// Specifies whether to enable the scheduled task. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: true.
	TaskEnabled *bool `json:"TaskEnabled,omitempty" xml:"TaskEnabled,omitempty"`
}

func (s ModifyScheduledTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyScheduledTaskRequest) GoString() string {
	return s.String()
}

func (s *ModifyScheduledTaskRequest) SetDescription(v string) *ModifyScheduledTaskRequest {
	s.Description = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetDesiredCapacity(v int32) *ModifyScheduledTaskRequest {
	s.DesiredCapacity = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetLaunchExpirationTime(v int32) *ModifyScheduledTaskRequest {
	s.LaunchExpirationTime = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetLaunchTime(v string) *ModifyScheduledTaskRequest {
	s.LaunchTime = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetMaxValue(v int32) *ModifyScheduledTaskRequest {
	s.MaxValue = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetMinValue(v int32) *ModifyScheduledTaskRequest {
	s.MinValue = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetOwnerAccount(v string) *ModifyScheduledTaskRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetOwnerId(v int64) *ModifyScheduledTaskRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetRecurrenceEndTime(v string) *ModifyScheduledTaskRequest {
	s.RecurrenceEndTime = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetRecurrenceType(v string) *ModifyScheduledTaskRequest {
	s.RecurrenceType = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetRecurrenceValue(v string) *ModifyScheduledTaskRequest {
	s.RecurrenceValue = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetResourceOwnerAccount(v string) *ModifyScheduledTaskRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetResourceOwnerId(v int64) *ModifyScheduledTaskRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetScalingGroupId(v string) *ModifyScheduledTaskRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetScheduledAction(v string) *ModifyScheduledTaskRequest {
	s.ScheduledAction = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetScheduledTaskId(v string) *ModifyScheduledTaskRequest {
	s.ScheduledTaskId = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetScheduledTaskName(v string) *ModifyScheduledTaskRequest {
	s.ScheduledTaskName = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetTaskEnabled(v bool) *ModifyScheduledTaskRequest {
	s.TaskEnabled = &v
	return s
}

type ModifyScheduledTaskResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyScheduledTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyScheduledTaskResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyScheduledTaskResponseBody) SetRequestId(v string) *ModifyScheduledTaskResponseBody {
	s.RequestId = &v
	return s
}

type ModifyScheduledTaskResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyScheduledTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyScheduledTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyScheduledTaskResponse) GoString() string {
	return s.String()
}

func (s *ModifyScheduledTaskResponse) SetHeaders(v map[string]*string) *ModifyScheduledTaskResponse {
	s.Headers = v
	return s
}

func (s *ModifyScheduledTaskResponse) SetStatusCode(v int32) *ModifyScheduledTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyScheduledTaskResponse) SetBody(v *ModifyScheduledTaskResponseBody) *ModifyScheduledTaskResponse {
	s.Body = v
	return s
}

type RebalanceInstancesRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s RebalanceInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s RebalanceInstancesRequest) GoString() string {
	return s.String()
}

func (s *RebalanceInstancesRequest) SetOwnerAccount(v string) *RebalanceInstancesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RebalanceInstancesRequest) SetOwnerId(v int64) *RebalanceInstancesRequest {
	s.OwnerId = &v
	return s
}

func (s *RebalanceInstancesRequest) SetRegionId(v string) *RebalanceInstancesRequest {
	s.RegionId = &v
	return s
}

func (s *RebalanceInstancesRequest) SetResourceOwnerAccount(v string) *RebalanceInstancesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RebalanceInstancesRequest) SetResourceOwnerId(v int64) *RebalanceInstancesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *RebalanceInstancesRequest) SetScalingGroupId(v string) *RebalanceInstancesRequest {
	s.ScalingGroupId = &v
	return s
}

type RebalanceInstancesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the scaling activity.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s RebalanceInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RebalanceInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *RebalanceInstancesResponseBody) SetRequestId(v string) *RebalanceInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *RebalanceInstancesResponseBody) SetScalingActivityId(v string) *RebalanceInstancesResponseBody {
	s.ScalingActivityId = &v
	return s
}

type RebalanceInstancesResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RebalanceInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RebalanceInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s RebalanceInstancesResponse) GoString() string {
	return s.String()
}

func (s *RebalanceInstancesResponse) SetHeaders(v map[string]*string) *RebalanceInstancesResponse {
	s.Headers = v
	return s
}

func (s *RebalanceInstancesResponse) SetStatusCode(v int32) *RebalanceInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *RebalanceInstancesResponse) SetBody(v *RebalanceInstancesResponseBody) *RebalanceInstancesResponse {
	s.Body = v
	return s
}

type RecordLifecycleActionHeartbeatRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The period of time before the lifecycle hook ends. Auto Scaling performs the specified action after the lifecycle hook ends. Valid values: 30 to 21600. Unit: seconds.
	//
	// You can call this operation to prolong the length of a lifecycle hook. You can also call the CompleteLifecycleAction operation to end a lifecycle hook ahead of schedule.
	//
	// Default value: 600.
	HeartbeatTimeout *int32 `json:"heartbeatTimeout,omitempty" xml:"heartbeatTimeout,omitempty"`
	// The token of the lifecycle hook. You can obtain this token by using a Message Service (MNS) queue or an MNS topic that is specified for the lifecycle hook.
	LifecycleActionToken *string `json:"lifecycleActionToken,omitempty" xml:"lifecycleActionToken,omitempty"`
	// The ID of the lifecycle hook.
	LifecycleHookId *string `json:"lifecycleHookId,omitempty" xml:"lifecycleHookId,omitempty"`
}

func (s RecordLifecycleActionHeartbeatRequest) String() string {
	return tea.Prettify(s)
}

func (s RecordLifecycleActionHeartbeatRequest) GoString() string {
	return s.String()
}

func (s *RecordLifecycleActionHeartbeatRequest) SetOwnerAccount(v string) *RecordLifecycleActionHeartbeatRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RecordLifecycleActionHeartbeatRequest) SetOwnerId(v int64) *RecordLifecycleActionHeartbeatRequest {
	s.OwnerId = &v
	return s
}

func (s *RecordLifecycleActionHeartbeatRequest) SetRegionId(v string) *RecordLifecycleActionHeartbeatRequest {
	s.RegionId = &v
	return s
}

func (s *RecordLifecycleActionHeartbeatRequest) SetResourceOwnerAccount(v string) *RecordLifecycleActionHeartbeatRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RecordLifecycleActionHeartbeatRequest) SetHeartbeatTimeout(v int32) *RecordLifecycleActionHeartbeatRequest {
	s.HeartbeatTimeout = &v
	return s
}

func (s *RecordLifecycleActionHeartbeatRequest) SetLifecycleActionToken(v string) *RecordLifecycleActionHeartbeatRequest {
	s.LifecycleActionToken = &v
	return s
}

func (s *RecordLifecycleActionHeartbeatRequest) SetLifecycleHookId(v string) *RecordLifecycleActionHeartbeatRequest {
	s.LifecycleHookId = &v
	return s
}

type RecordLifecycleActionHeartbeatResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RecordLifecycleActionHeartbeatResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RecordLifecycleActionHeartbeatResponseBody) GoString() string {
	return s.String()
}

func (s *RecordLifecycleActionHeartbeatResponseBody) SetRequestId(v string) *RecordLifecycleActionHeartbeatResponseBody {
	s.RequestId = &v
	return s
}

type RecordLifecycleActionHeartbeatResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RecordLifecycleActionHeartbeatResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RecordLifecycleActionHeartbeatResponse) String() string {
	return tea.Prettify(s)
}

func (s RecordLifecycleActionHeartbeatResponse) GoString() string {
	return s.String()
}

func (s *RecordLifecycleActionHeartbeatResponse) SetHeaders(v map[string]*string) *RecordLifecycleActionHeartbeatResponse {
	s.Headers = v
	return s
}

func (s *RecordLifecycleActionHeartbeatResponse) SetStatusCode(v int32) *RecordLifecycleActionHeartbeatResponse {
	s.StatusCode = &v
	return s
}

func (s *RecordLifecycleActionHeartbeatResponse) SetBody(v *RecordLifecycleActionHeartbeatResponseBody) *RecordLifecycleActionHeartbeatResponse {
	s.Body = v
	return s
}

type RemoveInstancesRequest struct {
	ClientToken             *string   `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DecreaseDesiredCapacity *bool     `json:"DecreaseDesiredCapacity,omitempty" xml:"DecreaseDesiredCapacity,omitempty"`
	InstanceIds             []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	OwnerAccount            *string   `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                 *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	RegionId                *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	RemovePolicy            *string   `json:"RemovePolicy,omitempty" xml:"RemovePolicy,omitempty"`
	ResourceOwnerAccount    *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId         *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	ScalingGroupId          *string   `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s RemoveInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveInstancesRequest) GoString() string {
	return s.String()
}

func (s *RemoveInstancesRequest) SetClientToken(v string) *RemoveInstancesRequest {
	s.ClientToken = &v
	return s
}

func (s *RemoveInstancesRequest) SetDecreaseDesiredCapacity(v bool) *RemoveInstancesRequest {
	s.DecreaseDesiredCapacity = &v
	return s
}

func (s *RemoveInstancesRequest) SetInstanceIds(v []*string) *RemoveInstancesRequest {
	s.InstanceIds = v
	return s
}

func (s *RemoveInstancesRequest) SetOwnerAccount(v string) *RemoveInstancesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RemoveInstancesRequest) SetOwnerId(v int64) *RemoveInstancesRequest {
	s.OwnerId = &v
	return s
}

func (s *RemoveInstancesRequest) SetRegionId(v string) *RemoveInstancesRequest {
	s.RegionId = &v
	return s
}

func (s *RemoveInstancesRequest) SetRemovePolicy(v string) *RemoveInstancesRequest {
	s.RemovePolicy = &v
	return s
}

func (s *RemoveInstancesRequest) SetResourceOwnerAccount(v string) *RemoveInstancesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RemoveInstancesRequest) SetResourceOwnerId(v int64) *RemoveInstancesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *RemoveInstancesRequest) SetScalingGroupId(v string) *RemoveInstancesRequest {
	s.ScalingGroupId = &v
	return s
}

type RemoveInstancesResponseBody struct {
	RequestId         *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s RemoveInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveInstancesResponseBody) SetRequestId(v string) *RemoveInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *RemoveInstancesResponseBody) SetScalingActivityId(v string) *RemoveInstancesResponseBody {
	s.ScalingActivityId = &v
	return s
}

type RemoveInstancesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemoveInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemoveInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveInstancesResponse) GoString() string {
	return s.String()
}

func (s *RemoveInstancesResponse) SetHeaders(v map[string]*string) *RemoveInstancesResponse {
	s.Headers = v
	return s
}

func (s *RemoveInstancesResponse) SetStatusCode(v int32) *RemoveInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveInstancesResponse) SetBody(v *RemoveInstancesResponseBody) *RemoveInstancesResponse {
	s.Body = v
	return s
}

type ResumeProcessesRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.
	//
	// The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerId     *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Details of the processes that you want to resume.
	Processes []*string `json:"Processes,omitempty" xml:"Processes,omitempty" type:"Repeated"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s ResumeProcessesRequest) String() string {
	return tea.Prettify(s)
}

func (s ResumeProcessesRequest) GoString() string {
	return s.String()
}

func (s *ResumeProcessesRequest) SetClientToken(v string) *ResumeProcessesRequest {
	s.ClientToken = &v
	return s
}

func (s *ResumeProcessesRequest) SetOwnerId(v int64) *ResumeProcessesRequest {
	s.OwnerId = &v
	return s
}

func (s *ResumeProcessesRequest) SetProcesses(v []*string) *ResumeProcessesRequest {
	s.Processes = v
	return s
}

func (s *ResumeProcessesRequest) SetRegionId(v string) *ResumeProcessesRequest {
	s.RegionId = &v
	return s
}

func (s *ResumeProcessesRequest) SetResourceOwnerAccount(v string) *ResumeProcessesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ResumeProcessesRequest) SetScalingGroupId(v string) *ResumeProcessesRequest {
	s.ScalingGroupId = &v
	return s
}

type ResumeProcessesResponseBody struct {
	// The ID of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ResumeProcessesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ResumeProcessesResponseBody) GoString() string {
	return s.String()
}

func (s *ResumeProcessesResponseBody) SetRequestId(v string) *ResumeProcessesResponseBody {
	s.RequestId = &v
	return s
}

type ResumeProcessesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ResumeProcessesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ResumeProcessesResponse) String() string {
	return tea.Prettify(s)
}

func (s ResumeProcessesResponse) GoString() string {
	return s.String()
}

func (s *ResumeProcessesResponse) SetHeaders(v map[string]*string) *ResumeProcessesResponse {
	s.Headers = v
	return s
}

func (s *ResumeProcessesResponse) SetStatusCode(v int32) *ResumeProcessesResponse {
	s.StatusCode = &v
	return s
}

func (s *ResumeProcessesResponse) SetBody(v *ResumeProcessesResponseBody) *ResumeProcessesResponse {
	s.Body = v
	return s
}

type ScaleWithAdjustmentRequest struct {
	// The type of the scaling policy. Valid values:
	//
	// *   QuantityChangeInCapacity: adds the specified number of ECS instances to or removes the specified number of ECS instances from the scaling group.
	// *   PercentChangeInCapacity: adds the specified percentage of ECS instances to or removes the specified percentage of ECS instances from the scaling group.
	// *   TotalCapacity: adjusts the number of ECS instances in the scaling group to a specified number.
	AdjustmentType *string `json:"AdjustmentType,omitempty" xml:"AdjustmentType,omitempty"`
	// The number of instances in each adjustment. The number of ECS instances in each adjustment cannot exceed 1,000.
	//
	// *   Valid values if you set the AdjustmentType parameter to QuantityChangeInCapacity: -1000 to 1000.
	// *   Valid values if you set the AdjustmentType parameter to PercentChangeInCapacity: -100 to 10000.
	// *   Valid values if you set the AdjustmentType parameter to TotalCapacity: 0 to 2000.
	AdjustmentValue *int32 `json:"AdjustmentValue,omitempty" xml:"AdjustmentValue,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The minimum number of instances allowed in each adjustment. This parameter takes effect only if you set the `AdjustmentType` parameter to `PercentChangeInCapacity`.
	MinAdjustmentMagnitude *int32  `json:"MinAdjustmentMagnitude,omitempty" xml:"MinAdjustmentMagnitude,omitempty"`
	OwnerId                *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount   *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// Specifies whether to trigger the scaling activity in a synchronous manner. This parameter takes effect only on scaling groups for which you specified an expected number of instances. Valid values:
	//
	// *   true: triggers the scaling activity in a synchronous manner. The scaling activity is triggered at the time when the scaling rule is executed.
	// *   false: does not trigger the scaling activity in a synchronous manner. After you change the expected number of instances for the scaling group, Auto Scaling checks whether the total number of instances in the scaling group matches the new expected number of instances and determines whether to trigger the scaling activity based on the check result.
	//
	// > For more information about the Expected Number of Instances feature, see [Expected number of instances](~~146231~~).
	//
	// Default value: false.
	SyncActivity *bool `json:"SyncActivity,omitempty" xml:"SyncActivity,omitempty"`
}

func (s ScaleWithAdjustmentRequest) String() string {
	return tea.Prettify(s)
}

func (s ScaleWithAdjustmentRequest) GoString() string {
	return s.String()
}

func (s *ScaleWithAdjustmentRequest) SetAdjustmentType(v string) *ScaleWithAdjustmentRequest {
	s.AdjustmentType = &v
	return s
}

func (s *ScaleWithAdjustmentRequest) SetAdjustmentValue(v int32) *ScaleWithAdjustmentRequest {
	s.AdjustmentValue = &v
	return s
}

func (s *ScaleWithAdjustmentRequest) SetClientToken(v string) *ScaleWithAdjustmentRequest {
	s.ClientToken = &v
	return s
}

func (s *ScaleWithAdjustmentRequest) SetMinAdjustmentMagnitude(v int32) *ScaleWithAdjustmentRequest {
	s.MinAdjustmentMagnitude = &v
	return s
}

func (s *ScaleWithAdjustmentRequest) SetOwnerId(v int64) *ScaleWithAdjustmentRequest {
	s.OwnerId = &v
	return s
}

func (s *ScaleWithAdjustmentRequest) SetResourceOwnerAccount(v string) *ScaleWithAdjustmentRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ScaleWithAdjustmentRequest) SetScalingGroupId(v string) *ScaleWithAdjustmentRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *ScaleWithAdjustmentRequest) SetSyncActivity(v bool) *ScaleWithAdjustmentRequest {
	s.SyncActivity = &v
	return s
}

type ScaleWithAdjustmentResponseBody struct {
	// 伸缩活动的类型。
	//
	// 当ActivityType为CapacityChange时，表示返回值ScalingActivityId对应伸缩活动仅修改伸缩组期望实例数，没有立刻执行扩缩。适用范围：期望实例数类型伸缩组。
	ActivityType *string `json:"ActivityType,omitempty" xml:"ActivityType,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the scaling activity.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s ScaleWithAdjustmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ScaleWithAdjustmentResponseBody) GoString() string {
	return s.String()
}

func (s *ScaleWithAdjustmentResponseBody) SetActivityType(v string) *ScaleWithAdjustmentResponseBody {
	s.ActivityType = &v
	return s
}

func (s *ScaleWithAdjustmentResponseBody) SetRequestId(v string) *ScaleWithAdjustmentResponseBody {
	s.RequestId = &v
	return s
}

func (s *ScaleWithAdjustmentResponseBody) SetScalingActivityId(v string) *ScaleWithAdjustmentResponseBody {
	s.ScalingActivityId = &v
	return s
}

type ScaleWithAdjustmentResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ScaleWithAdjustmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ScaleWithAdjustmentResponse) String() string {
	return tea.Prettify(s)
}

func (s ScaleWithAdjustmentResponse) GoString() string {
	return s.String()
}

func (s *ScaleWithAdjustmentResponse) SetHeaders(v map[string]*string) *ScaleWithAdjustmentResponse {
	s.Headers = v
	return s
}

func (s *ScaleWithAdjustmentResponse) SetStatusCode(v int32) *ScaleWithAdjustmentResponse {
	s.StatusCode = &v
	return s
}

func (s *ScaleWithAdjustmentResponse) SetBody(v *ScaleWithAdjustmentResponseBody) *ScaleWithAdjustmentResponse {
	s.Body = v
	return s
}

type SetGroupDeletionProtectionRequest struct {
	// Specifies whether to enable deletion protection for the scaling group. Valid values:
	//
	// *   true: enables deletion protection for the scaling group. This way, the scaling group cannot be deleted.
	// *   false: disables deletion protection for the scaling group.
	GroupDeletionProtection *bool  `json:"GroupDeletionProtection,omitempty" xml:"GroupDeletionProtection,omitempty"`
	OwnerId                 *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s SetGroupDeletionProtectionRequest) String() string {
	return tea.Prettify(s)
}

func (s SetGroupDeletionProtectionRequest) GoString() string {
	return s.String()
}

func (s *SetGroupDeletionProtectionRequest) SetGroupDeletionProtection(v bool) *SetGroupDeletionProtectionRequest {
	s.GroupDeletionProtection = &v
	return s
}

func (s *SetGroupDeletionProtectionRequest) SetOwnerId(v int64) *SetGroupDeletionProtectionRequest {
	s.OwnerId = &v
	return s
}

func (s *SetGroupDeletionProtectionRequest) SetRegionId(v string) *SetGroupDeletionProtectionRequest {
	s.RegionId = &v
	return s
}

func (s *SetGroupDeletionProtectionRequest) SetResourceOwnerAccount(v string) *SetGroupDeletionProtectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetGroupDeletionProtectionRequest) SetScalingGroupId(v string) *SetGroupDeletionProtectionRequest {
	s.ScalingGroupId = &v
	return s
}

type SetGroupDeletionProtectionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetGroupDeletionProtectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetGroupDeletionProtectionResponseBody) GoString() string {
	return s.String()
}

func (s *SetGroupDeletionProtectionResponseBody) SetRequestId(v string) *SetGroupDeletionProtectionResponseBody {
	s.RequestId = &v
	return s
}

type SetGroupDeletionProtectionResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetGroupDeletionProtectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetGroupDeletionProtectionResponse) String() string {
	return tea.Prettify(s)
}

func (s SetGroupDeletionProtectionResponse) GoString() string {
	return s.String()
}

func (s *SetGroupDeletionProtectionResponse) SetHeaders(v map[string]*string) *SetGroupDeletionProtectionResponse {
	s.Headers = v
	return s
}

func (s *SetGroupDeletionProtectionResponse) SetStatusCode(v int32) *SetGroupDeletionProtectionResponse {
	s.StatusCode = &v
	return s
}

func (s *SetGroupDeletionProtectionResponse) SetBody(v *SetGroupDeletionProtectionResponseBody) *SetGroupDeletionProtectionResponse {
	s.Body = v
	return s
}

type SetInstanceHealthRequest struct {
	// The health status of the ECS instance in the scaling group. If ECS instances do not run as expected, Auto Scaling considers the ECS instances unhealthy. Valid values:
	//
	// *   Healthy
	// *   Unhealthy
	//
	// Auto Scaling automatically removes unhealthy ECS instances from the scaling group and then releases the automatically created instances among the unhealthy instances.
	//
	// Unhealthy ECS instances that are manually added to the scaling group are released based on the management mode of the instance lifecycles. If the lifecycles of the ECS instances are not managed by the scaling group, Auto Scaling removes the instances from the scaling group but does not release the instances. If the lifecycles of the ECS instances are managed by the scaling group, Auto Scaling removes the instances from the scaling group and releases the instances.
	//
	// >  Make sure that you have sufficient balance within your Alibaba Cloud account. If you have overdue payments within your Alibaba Cloud account, pay-as-you-go and preemptible instances are stopped or released. For information about how the states of ECS instances change when you have overdue payments within your Alibaba Cloud account, see [Overdue payments](~~170589~~).
	HealthStatus *string `json:"HealthStatus,omitempty" xml:"HealthStatus,omitempty"`
	// The ID of the instance.
	InstanceId           *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
}

func (s SetInstanceHealthRequest) String() string {
	return tea.Prettify(s)
}

func (s SetInstanceHealthRequest) GoString() string {
	return s.String()
}

func (s *SetInstanceHealthRequest) SetHealthStatus(v string) *SetInstanceHealthRequest {
	s.HealthStatus = &v
	return s
}

func (s *SetInstanceHealthRequest) SetInstanceId(v string) *SetInstanceHealthRequest {
	s.InstanceId = &v
	return s
}

func (s *SetInstanceHealthRequest) SetOwnerId(v int64) *SetInstanceHealthRequest {
	s.OwnerId = &v
	return s
}

func (s *SetInstanceHealthRequest) SetResourceOwnerAccount(v string) *SetInstanceHealthRequest {
	s.ResourceOwnerAccount = &v
	return s
}

type SetInstanceHealthResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetInstanceHealthResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetInstanceHealthResponseBody) GoString() string {
	return s.String()
}

func (s *SetInstanceHealthResponseBody) SetRequestId(v string) *SetInstanceHealthResponseBody {
	s.RequestId = &v
	return s
}

type SetInstanceHealthResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetInstanceHealthResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetInstanceHealthResponse) String() string {
	return tea.Prettify(s)
}

func (s SetInstanceHealthResponse) GoString() string {
	return s.String()
}

func (s *SetInstanceHealthResponse) SetHeaders(v map[string]*string) *SetInstanceHealthResponse {
	s.Headers = v
	return s
}

func (s *SetInstanceHealthResponse) SetStatusCode(v int32) *SetInstanceHealthResponse {
	s.StatusCode = &v
	return s
}

func (s *SetInstanceHealthResponse) SetBody(v *SetInstanceHealthResponseBody) *SetInstanceHealthResponse {
	s.Body = v
	return s
}

type SetInstancesProtectionRequest struct {
	// The IDs of the ECS instances.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	OwnerId     *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Specifies whether to put ECS instances into the Protected state. Auto Scaling does not remove ECS instances in the Protected state from scaling groups during scale-in activities.
	//
	// *   true
	// *   false
	ProtectedFromScaleIn *bool   `json:"ProtectedFromScaleIn,omitempty" xml:"ProtectedFromScaleIn,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s SetInstancesProtectionRequest) String() string {
	return tea.Prettify(s)
}

func (s SetInstancesProtectionRequest) GoString() string {
	return s.String()
}

func (s *SetInstancesProtectionRequest) SetInstanceIds(v []*string) *SetInstancesProtectionRequest {
	s.InstanceIds = v
	return s
}

func (s *SetInstancesProtectionRequest) SetOwnerId(v int64) *SetInstancesProtectionRequest {
	s.OwnerId = &v
	return s
}

func (s *SetInstancesProtectionRequest) SetProtectedFromScaleIn(v bool) *SetInstancesProtectionRequest {
	s.ProtectedFromScaleIn = &v
	return s
}

func (s *SetInstancesProtectionRequest) SetResourceOwnerAccount(v string) *SetInstancesProtectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetInstancesProtectionRequest) SetScalingGroupId(v string) *SetInstancesProtectionRequest {
	s.ScalingGroupId = &v
	return s
}

type SetInstancesProtectionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetInstancesProtectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetInstancesProtectionResponseBody) GoString() string {
	return s.String()
}

func (s *SetInstancesProtectionResponseBody) SetRequestId(v string) *SetInstancesProtectionResponseBody {
	s.RequestId = &v
	return s
}

type SetInstancesProtectionResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetInstancesProtectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetInstancesProtectionResponse) String() string {
	return tea.Prettify(s)
}

func (s SetInstancesProtectionResponse) GoString() string {
	return s.String()
}

func (s *SetInstancesProtectionResponse) SetHeaders(v map[string]*string) *SetInstancesProtectionResponse {
	s.Headers = v
	return s
}

func (s *SetInstancesProtectionResponse) SetStatusCode(v int32) *SetInstancesProtectionResponse {
	s.StatusCode = &v
	return s
}

func (s *SetInstancesProtectionResponse) SetBody(v *SetInstancesProtectionResponseBody) *SetInstancesProtectionResponse {
	s.Body = v
	return s
}

type SuspendProcessesRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.
	//
	// The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerId     *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The types of the processes that you want to suspend. Valid values:
	//
	// *   scalein
	// *   scaleout
	// *   healthcheck
	// *   alarmnotification
	// *   scheduledaction
	//
	// You can suspend five processes of the preceding types at the same time. If you try to suspend more than five processes at the same time, Auto Scaling automatically removes duplicate processes.
	Processes []*string `json:"Processes,omitempty" xml:"Processes,omitempty" type:"Repeated"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s SuspendProcessesRequest) String() string {
	return tea.Prettify(s)
}

func (s SuspendProcessesRequest) GoString() string {
	return s.String()
}

func (s *SuspendProcessesRequest) SetClientToken(v string) *SuspendProcessesRequest {
	s.ClientToken = &v
	return s
}

func (s *SuspendProcessesRequest) SetOwnerId(v int64) *SuspendProcessesRequest {
	s.OwnerId = &v
	return s
}

func (s *SuspendProcessesRequest) SetProcesses(v []*string) *SuspendProcessesRequest {
	s.Processes = v
	return s
}

func (s *SuspendProcessesRequest) SetRegionId(v string) *SuspendProcessesRequest {
	s.RegionId = &v
	return s
}

func (s *SuspendProcessesRequest) SetResourceOwnerAccount(v string) *SuspendProcessesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SuspendProcessesRequest) SetScalingGroupId(v string) *SuspendProcessesRequest {
	s.ScalingGroupId = &v
	return s
}

type SuspendProcessesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SuspendProcessesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SuspendProcessesResponseBody) GoString() string {
	return s.String()
}

func (s *SuspendProcessesResponseBody) SetRequestId(v string) *SuspendProcessesResponseBody {
	s.RequestId = &v
	return s
}

type SuspendProcessesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SuspendProcessesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SuspendProcessesResponse) String() string {
	return tea.Prettify(s)
}

func (s SuspendProcessesResponse) GoString() string {
	return s.String()
}

func (s *SuspendProcessesResponse) SetHeaders(v map[string]*string) *SuspendProcessesResponse {
	s.Headers = v
	return s
}

func (s *SuspendProcessesResponse) SetStatusCode(v int32) *SuspendProcessesResponse {
	s.StatusCode = &v
	return s
}

func (s *SuspendProcessesResponse) SetBody(v *SuspendProcessesResponseBody) *SuspendProcessesResponse {
	s.Body = v
	return s
}

type TagResourcesRequest struct {
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The IDs of the Auto Scaling resources. You can specify 1 to 50 resource IDs.
	ResourceIds          []*string `json:"ResourceIds,omitempty" xml:"ResourceIds,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The type of the resource. Only scaling groups are supported. Set the value to scalinggroup.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// Details of the tags.
	Tags []*TagResourcesRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s TagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequest) GoString() string {
	return s.String()
}

func (s *TagResourcesRequest) SetOwnerId(v int64) *TagResourcesRequest {
	s.OwnerId = &v
	return s
}

func (s *TagResourcesRequest) SetRegionId(v string) *TagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *TagResourcesRequest) SetResourceIds(v []*string) *TagResourcesRequest {
	s.ResourceIds = v
	return s
}

func (s *TagResourcesRequest) SetResourceOwnerAccount(v string) *TagResourcesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *TagResourcesRequest) SetResourceType(v string) *TagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *TagResourcesRequest) SetTags(v []*TagResourcesRequestTags) *TagResourcesRequest {
	s.Tags = v
	return s
}

type TagResourcesRequestTags struct {
	// The key of the tag that you want to add to the Auto Scaling resource.
	//
	// You cannot specify empty strings as tag keys. The tag key must be 1 to 128 characters in length and cannot contain `http://` or `https://`. The tag key cannot start with `acs:` or `aliyun`.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// Specifies whether to propagate the tag that you want to add. Valid values:
	//
	// *   true: propagates the tag only to instances that are newly created and does not propagate the tag to instances that are already running in the scaling group.
	// *   false: does not propagate the tag to any instances.
	//
	// Default value: false.
	Propagate *bool `json:"Propagate,omitempty" xml:"Propagate,omitempty"`
	// The value of the tag that you want to add to the Auto Scaling resource.
	//
	// You can specify empty strings as tag values. The tag value must be 0 to 128 characters in length and cannot contain `http://` or `https://`. The tag value cannot start with `acs:`.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s TagResourcesRequestTags) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequestTags) GoString() string {
	return s.String()
}

func (s *TagResourcesRequestTags) SetKey(v string) *TagResourcesRequestTags {
	s.Key = &v
	return s
}

func (s *TagResourcesRequestTags) SetPropagate(v bool) *TagResourcesRequestTags {
	s.Propagate = &v
	return s
}

func (s *TagResourcesRequestTags) SetValue(v string) *TagResourcesRequestTags {
	s.Value = &v
	return s
}

type TagResourcesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *TagResourcesResponseBody) SetRequestId(v string) *TagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type TagResourcesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponse) GoString() string {
	return s.String()
}

func (s *TagResourcesResponse) SetHeaders(v map[string]*string) *TagResourcesResponse {
	s.Headers = v
	return s
}

func (s *TagResourcesResponse) SetStatusCode(v int32) *TagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *TagResourcesResponse) SetBody(v *TagResourcesResponseBody) *TagResourcesResponse {
	s.Body = v
	return s
}

type UntagResourcesRequest struct {
	// Specifies whether to remove all tags from the Auto Scaling resource. This parameter takes effect only if you do not specify the `TagKeys` parameter. Valid values:
	//
	// *   true: removes all tags from the Auto Scaling resource.
	// *   false: does not remove tags from the Auto Scaling resource.
	//
	// Default value: false.
	All     *bool  `json:"All,omitempty" xml:"All,omitempty"`
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the Auto Scaling resource. You can call the DescribeRegions operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The IDs of the Auto Scaling resources. You can specify 1 to 50 resource IDs.
	ResourceIds          []*string `json:"ResourceIds,omitempty" xml:"ResourceIds,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The type of the resource. Only scaling groups are supported. Set the value to scalinggroup.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The keys of the tags that you want to remove from the Auto Scaling resource. You can specify 1 to 20 tag keys.
	TagKeys []*string `json:"TagKeys,omitempty" xml:"TagKeys,omitempty" type:"Repeated"`
}

func (s UntagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesRequest) GoString() string {
	return s.String()
}

func (s *UntagResourcesRequest) SetAll(v bool) *UntagResourcesRequest {
	s.All = &v
	return s
}

func (s *UntagResourcesRequest) SetOwnerId(v int64) *UntagResourcesRequest {
	s.OwnerId = &v
	return s
}

func (s *UntagResourcesRequest) SetRegionId(v string) *UntagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceIds(v []*string) *UntagResourcesRequest {
	s.ResourceIds = v
	return s
}

func (s *UntagResourcesRequest) SetResourceOwnerAccount(v string) *UntagResourcesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceType(v string) *UntagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *UntagResourcesRequest) SetTagKeys(v []*string) *UntagResourcesRequest {
	s.TagKeys = v
	return s
}

type UntagResourcesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UntagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponseBody) SetRequestId(v string) *UntagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type UntagResourcesResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UntagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UntagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponse) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponse) SetHeaders(v map[string]*string) *UntagResourcesResponse {
	s.Headers = v
	return s
}

func (s *UntagResourcesResponse) SetStatusCode(v int32) *UntagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *UntagResourcesResponse) SetBody(v *UntagResourcesResponseBody) *UntagResourcesResponse {
	s.Body = v
	return s
}

type VerifyAuthenticationRequest struct {
	OnlyCheck            *bool   `json:"OnlyCheck,omitempty" xml:"OnlyCheck,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Uid                  *int64  `json:"Uid,omitempty" xml:"Uid,omitempty"`
}

func (s VerifyAuthenticationRequest) String() string {
	return tea.Prettify(s)
}

func (s VerifyAuthenticationRequest) GoString() string {
	return s.String()
}

func (s *VerifyAuthenticationRequest) SetOnlyCheck(v bool) *VerifyAuthenticationRequest {
	s.OnlyCheck = &v
	return s
}

func (s *VerifyAuthenticationRequest) SetOwnerId(v int64) *VerifyAuthenticationRequest {
	s.OwnerId = &v
	return s
}

func (s *VerifyAuthenticationRequest) SetResourceOwnerAccount(v string) *VerifyAuthenticationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *VerifyAuthenticationRequest) SetResourceOwnerId(v int64) *VerifyAuthenticationRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *VerifyAuthenticationRequest) SetUid(v int64) *VerifyAuthenticationRequest {
	s.Uid = &v
	return s
}

type VerifyAuthenticationResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s VerifyAuthenticationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s VerifyAuthenticationResponseBody) GoString() string {
	return s.String()
}

func (s *VerifyAuthenticationResponseBody) SetRequestId(v string) *VerifyAuthenticationResponseBody {
	s.RequestId = &v
	return s
}

type VerifyAuthenticationResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *VerifyAuthenticationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s VerifyAuthenticationResponse) String() string {
	return tea.Prettify(s)
}

func (s VerifyAuthenticationResponse) GoString() string {
	return s.String()
}

func (s *VerifyAuthenticationResponse) SetHeaders(v map[string]*string) *VerifyAuthenticationResponse {
	s.Headers = v
	return s
}

func (s *VerifyAuthenticationResponse) SetStatusCode(v int32) *VerifyAuthenticationResponse {
	s.StatusCode = &v
	return s
}

func (s *VerifyAuthenticationResponse) SetBody(v *VerifyAuthenticationResponseBody) *VerifyAuthenticationResponse {
	s.Body = v
	return s
}

type VerifyUserRequest struct {
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s VerifyUserRequest) String() string {
	return tea.Prettify(s)
}

func (s VerifyUserRequest) GoString() string {
	return s.String()
}

func (s *VerifyUserRequest) SetOwnerId(v int64) *VerifyUserRequest {
	s.OwnerId = &v
	return s
}

func (s *VerifyUserRequest) SetRegionId(v string) *VerifyUserRequest {
	s.RegionId = &v
	return s
}

func (s *VerifyUserRequest) SetResourceOwnerAccount(v string) *VerifyUserRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *VerifyUserRequest) SetResourceOwnerId(v int64) *VerifyUserRequest {
	s.ResourceOwnerId = &v
	return s
}

type VerifyUserResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s VerifyUserResponseBody) String() string {
	return tea.Prettify(s)
}

func (s VerifyUserResponseBody) GoString() string {
	return s.String()
}

func (s *VerifyUserResponseBody) SetRequestId(v string) *VerifyUserResponseBody {
	s.RequestId = &v
	return s
}

type VerifyUserResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *VerifyUserResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s VerifyUserResponse) String() string {
	return tea.Prettify(s)
}

func (s VerifyUserResponse) GoString() string {
	return s.String()
}

func (s *VerifyUserResponse) SetHeaders(v map[string]*string) *VerifyUserResponse {
	s.Headers = v
	return s
}

func (s *VerifyUserResponse) SetStatusCode(v int32) *VerifyUserResponse {
	s.StatusCode = &v
	return s
}

func (s *VerifyUserResponse) SetBody(v *VerifyUserResponseBody) *VerifyUserResponse {
	s.Body = v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.EndpointRule = tea.String("regional")
	client.EndpointMap = map[string]*string{
		"cn-qingdao":                  tea.String("ess.aliyuncs.com"),
		"cn-beijing":                  tea.String("ess.aliyuncs.com"),
		"cn-hangzhou":                 tea.String("ess.aliyuncs.com"),
		"cn-shanghai":                 tea.String("ess.aliyuncs.com"),
		"cn-shenzhen":                 tea.String("ess.aliyuncs.com"),
		"cn-hongkong":                 tea.String("ess.aliyuncs.com"),
		"ap-southeast-1":              tea.String("ess.aliyuncs.com"),
		"us-east-1":                   tea.String("ess.aliyuncs.com"),
		"us-west-1":                   tea.String("ess.aliyuncs.com"),
		"cn-shanghai-finance-1":       tea.String("ess.aliyuncs.com"),
		"cn-shenzhen-finance-1":       tea.String("ess.aliyuncs.com"),
		"cn-north-2-gov-1":            tea.String("ess.aliyuncs.com"),
		"ap-northeast-2-pop":          tea.String("ess.aliyuncs.com"),
		"cn-beijing-finance-pop":      tea.String("ess.aliyuncs.com"),
		"cn-beijing-gov-1":            tea.String("ess.aliyuncs.com"),
		"cn-beijing-nu16-b01":         tea.String("ess.aliyuncs.com"),
		"cn-edge-1":                   tea.String("ess.aliyuncs.com"),
		"cn-fujian":                   tea.String("ess.aliyuncs.com"),
		"cn-haidian-cm12-c01":         tea.String("ess.aliyuncs.com"),
		"cn-hangzhou-bj-b01":          tea.String("ess.aliyuncs.com"),
		"cn-hangzhou-finance":         tea.String("ess.aliyuncs.com"),
		"cn-hangzhou-internal-prod-1": tea.String("ess.aliyuncs.com"),
		"cn-hangzhou-internal-test-1": tea.String("ess.aliyuncs.com"),
		"cn-hangzhou-internal-test-2": tea.String("ess.aliyuncs.com"),
		"cn-hangzhou-internal-test-3": tea.String("ess.aliyuncs.com"),
		"cn-hangzhou-test-306":        tea.String("ess.aliyuncs.com"),
		"cn-hongkong-finance-pop":     tea.String("ess.aliyuncs.com"),
		"cn-huhehaote-nebula-1":       tea.String("ess.aliyuncs.com"),
		"cn-qingdao-nebula":           tea.String("ess.aliyuncs.com"),
		"cn-shanghai-et15-b01":        tea.String("ess.aliyuncs.com"),
		"cn-shanghai-et2-b01":         tea.String("ess.aliyuncs.com"),
		"cn-shanghai-inner":           tea.String("ess.aliyuncs.com"),
		"cn-shanghai-internal-test-1": tea.String("ess.aliyuncs.com"),
		"cn-shenzhen-inner":           tea.String("ess.aliyuncs.com"),
		"cn-shenzhen-st4-d01":         tea.String("ess.aliyuncs.com"),
		"cn-shenzhen-su18-b01":        tea.String("ess.aliyuncs.com"),
		"cn-wuhan":                    tea.String("ess.aliyuncs.com"),
		"cn-yushanfang":               tea.String("ess.aliyuncs.com"),
		"cn-zhangbei":                 tea.String("ess.aliyuncs.com"),
		"cn-zhangbei-na61-b01":        tea.String("ess.aliyuncs.com"),
		"cn-zhangjiakou-na62-a01":     tea.String("ess.aliyuncs.com"),
		"cn-zhengzhou-nebula-1":       tea.String("ess.aliyuncs.com"),
		"eu-west-1-oxs":               tea.String("ess.aliyuncs.com"),
		"rus-west-1-pop":              tea.String("ess.aliyuncs.com"),
	}
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(tea.String("ess"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !tea.BoolValue(util.Empty(endpoint)) {
		_result = endpoint
		return _result, _err
	}

	if !tea.BoolValue(util.IsUnset(endpointMap)) && !tea.BoolValue(util.Empty(endpointMap[tea.StringValue(regionId)])) {
		_result = endpointMap[tea.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := endpointutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you associate an ALB server group with a scaling group, make sure that the following requirements are met:
 * *   The scaling group resides in a virtual private cloud (VPC). The scaling group and the ALB server group must reside in the same VPC.
 * *   The ALB server group is in the Available state.
 * *   You can associate only a limited number of ALB server groups with a scaling group. To view the quota or manually request a quota increase, go to [Quota Center](https://quotas.console.aliyun.com/products/ess/quotas).
 *
 * @param request AttachAlbServerGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachAlbServerGroupsResponse
 */
func (client *Client) AttachAlbServerGroupsWithOptions(request *AttachAlbServerGroupsRequest, runtime *util.RuntimeOptions) (_result *AttachAlbServerGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlbServerGroups)) {
		query["AlbServerGroups"] = request.AlbServerGroups
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ForceAttach)) {
		query["ForceAttach"] = request.ForceAttach
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachAlbServerGroups"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachAlbServerGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you associate an ALB server group with a scaling group, make sure that the following requirements are met:
 * *   The scaling group resides in a virtual private cloud (VPC). The scaling group and the ALB server group must reside in the same VPC.
 * *   The ALB server group is in the Available state.
 * *   You can associate only a limited number of ALB server groups with a scaling group. To view the quota or manually request a quota increase, go to [Quota Center](https://quotas.console.aliyun.com/products/ess/quotas).
 *
 * @param request AttachAlbServerGroupsRequest
 * @return AttachAlbServerGroupsResponse
 */
func (client *Client) AttachAlbServerGroups(request *AttachAlbServerGroupsRequest) (_result *AttachAlbServerGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachAlbServerGroupsResponse{}
	_body, _err := client.AttachAlbServerGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you associate an ApsaraDB RDS instance with a scaling group, make sure that the ApsaraDB RDS instance meets the following requirements:
 * *   The ApsaraDB RDS instance and the scaling group must belong to the same Alibaba Cloud account.
 * *   The ApsaraDB RDS instance must be unlocked. For more information about the lock policy, see [ApsaraDB RDS usage notes](~~41872~~).
 * *   The ApsaraDB RDS instance must be in the Running state.
 * After an ApsaraDB RDS instance is associated with the scaling group, the default IP address whitelist of the ApsaraDB RDS instance can contain no more than 1,000 IP addresses. For more information, see [Set the whitelist](~~43185~~).
 *
 * @param request AttachDBInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachDBInstancesResponse
 */
func (client *Client) AttachDBInstancesWithOptions(request *AttachDBInstancesRequest, runtime *util.RuntimeOptions) (_result *AttachDBInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstances)) {
		query["DBInstances"] = request.DBInstances
	}

	if !tea.BoolValue(util.IsUnset(request.ForceAttach)) {
		query["ForceAttach"] = request.ForceAttach
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachDBInstances"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachDBInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you associate an ApsaraDB RDS instance with a scaling group, make sure that the ApsaraDB RDS instance meets the following requirements:
 * *   The ApsaraDB RDS instance and the scaling group must belong to the same Alibaba Cloud account.
 * *   The ApsaraDB RDS instance must be unlocked. For more information about the lock policy, see [ApsaraDB RDS usage notes](~~41872~~).
 * *   The ApsaraDB RDS instance must be in the Running state.
 * After an ApsaraDB RDS instance is associated with the scaling group, the default IP address whitelist of the ApsaraDB RDS instance can contain no more than 1,000 IP addresses. For more information, see [Set the whitelist](~~43185~~).
 *
 * @param request AttachDBInstancesRequest
 * @return AttachDBInstancesResponse
 */
func (client *Client) AttachDBInstances(request *AttachDBInstancesRequest) (_result *AttachDBInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachDBInstancesResponse{}
	_body, _err := client.AttachDBInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this operation, take note of the following items:
 * *   The scaling group is in the Active state.
 * *   No scaling activities in the scaling group are in progress.
 * The ECS instances or the elastic container instances that you want to add to a scaling group must meet the following requirements:
 * *   The instances reside in the same region as the scaling group.
 * *   The instances must be in the Running state.
 * *   The instances are not added to other scaling groups.
 * *   The instances use the subscription or pay-as-you-go billing method, or are preemptible instances.
 * *   If the VswitchID parameter is specified for a scaling group, the instances that are in the classic network or those that are not in the same virtual private cloud (VPC) as the specified vSwitch cannot be added to the scaling group.
 * *   If the VswitchID parameter is not specified for a scaling group, the instances that are in VPCs cannot be added to the scaling group.
 * If no scaling activities in the specified scaling group are in progress, the operation can trigger scaling activities even before the cooldown time expires.
 * A successful call indicates that Auto Scaling accepts the request. However, the scaling activity may still fail. You can obtain the status of a scaling activity by using the value of the ScalingActivityId parameter in the response.
 * If the sum of the number of instances that you want to add and the number of existing instances in the scaling group is greater than the value of the MaxSize parameter, the call fails.
 * Instances that are manually added by calling the AttachInstances operation are not associated with the active scaling configuration of the scaling group.
 *
 * @param request AttachInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachInstancesResponse
 */
func (client *Client) AttachInstancesWithOptions(request *AttachInstancesRequest, runtime *util.RuntimeOptions) (_result *AttachInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Entrusted)) {
		query["Entrusted"] = request.Entrusted
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleHook)) {
		query["LifecycleHook"] = request.LifecycleHook
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerWeights)) {
		query["LoadBalancerWeights"] = request.LoadBalancerWeights
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachInstances"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this operation, take note of the following items:
 * *   The scaling group is in the Active state.
 * *   No scaling activities in the scaling group are in progress.
 * The ECS instances or the elastic container instances that you want to add to a scaling group must meet the following requirements:
 * *   The instances reside in the same region as the scaling group.
 * *   The instances must be in the Running state.
 * *   The instances are not added to other scaling groups.
 * *   The instances use the subscription or pay-as-you-go billing method, or are preemptible instances.
 * *   If the VswitchID parameter is specified for a scaling group, the instances that are in the classic network or those that are not in the same virtual private cloud (VPC) as the specified vSwitch cannot be added to the scaling group.
 * *   If the VswitchID parameter is not specified for a scaling group, the instances that are in VPCs cannot be added to the scaling group.
 * If no scaling activities in the specified scaling group are in progress, the operation can trigger scaling activities even before the cooldown time expires.
 * A successful call indicates that Auto Scaling accepts the request. However, the scaling activity may still fail. You can obtain the status of a scaling activity by using the value of the ScalingActivityId parameter in the response.
 * If the sum of the number of instances that you want to add and the number of existing instances in the scaling group is greater than the value of the MaxSize parameter, the call fails.
 * Instances that are manually added by calling the AttachInstances operation are not associated with the active scaling configuration of the scaling group.
 *
 * @param request AttachInstancesRequest
 * @return AttachInstancesResponse
 */
func (client *Client) AttachInstances(request *AttachInstancesRequest) (_result *AttachInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachInstancesResponse{}
	_body, _err := client.AttachInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this operation to attach a CLB instance to your scaling group, take note of the following items:
 * *   The CLB instance and the scaling group must belong to the same Alibaba Cloud account.
 * *   The CLB instance and the scaling group must reside in the same region.
 * *   The CLB instance must be in the Running state.
 * *   The CLB instance must be configured with at least one listener. Health check is enabled for the CLB instance.
 * *   The CLB instance and the scaling group must be in the same virtual private cloud (VPC) if their network type is VPC.
 * *   If the network type of the scaling group is VPC, the network type of the CLB instance is classic network, and the CLB backend server groups contain instances of the VPC network type, the instances and the scaling group must be in the same VPC.
 * *   You can attach only a limited number of CLB instances to a scaling group. Fore more information, see [Limits](~~25863~~).
 *
 * @param request AttachLoadBalancersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachLoadBalancersResponse
 */
func (client *Client) AttachLoadBalancersWithOptions(request *AttachLoadBalancersRequest, runtime *util.RuntimeOptions) (_result *AttachLoadBalancersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Async)) {
		query["Async"] = request.Async
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ForceAttach)) {
		query["ForceAttach"] = request.ForceAttach
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerConfigs)) {
		query["LoadBalancerConfigs"] = request.LoadBalancerConfigs
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancers)) {
		query["LoadBalancers"] = request.LoadBalancers
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachLoadBalancers"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachLoadBalancersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this operation to attach a CLB instance to your scaling group, take note of the following items:
 * *   The CLB instance and the scaling group must belong to the same Alibaba Cloud account.
 * *   The CLB instance and the scaling group must reside in the same region.
 * *   The CLB instance must be in the Running state.
 * *   The CLB instance must be configured with at least one listener. Health check is enabled for the CLB instance.
 * *   The CLB instance and the scaling group must be in the same virtual private cloud (VPC) if their network type is VPC.
 * *   If the network type of the scaling group is VPC, the network type of the CLB instance is classic network, and the CLB backend server groups contain instances of the VPC network type, the instances and the scaling group must be in the same VPC.
 * *   You can attach only a limited number of CLB instances to a scaling group. Fore more information, see [Limits](~~25863~~).
 *
 * @param request AttachLoadBalancersRequest
 * @return AttachLoadBalancersResponse
 */
func (client *Client) AttachLoadBalancers(request *AttachLoadBalancersRequest) (_result *AttachLoadBalancersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachLoadBalancersResponse{}
	_body, _err := client.AttachLoadBalancersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AttachServerGroupsWithOptions(request *AttachServerGroupsRequest, runtime *util.RuntimeOptions) (_result *AttachServerGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ForceAttach)) {
		query["ForceAttach"] = request.ForceAttach
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ServerGroups)) {
		query["ServerGroups"] = request.ServerGroups
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachServerGroups"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachServerGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AttachServerGroups(request *AttachServerGroupsRequest) (_result *AttachServerGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachServerGroupsResponse{}
	_body, _err := client.AttachServerGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this operation to attach a vServer group to your scaling group, take note of the following items:
 * *   The CLB instance and the scaling group must belong to the same Alibaba Cloud account.
 * *   The CLB instance and the scaling group must reside in the same region.
 * *   The CLB instance must be in the Running state.
 * *   The CLB instance must be configured with at least one listener. Health check is enabled for the CLB instance.
 * *   The CLB instance and the scaling group must be in the same VPC if their network type is VPC.
 * *   If the network type of the scaling group is VPC, the network type of the CLB instance is classic network, and the vServer groups of the CLB instance contain instances of the VPC network type, the instances and the scaling group must be in the same VPC.
 * *   The vServer group that you want to attach to your scaling group must belong to the CLB instance.
 * *   You can attach only a limited number of vServer groups to a scaling group. For information about the quota on vServer groups, see [Limits](~~25863~~).
 * When you call this operation, you must specify the following parameters:
 * *   LoadBalancerId: the ID of the CLB instance.
 * *   VServerGroupId: the ID of the vServer group.
 * *   Port: the port number of the vServer group.
 * If a vServer group is attached to a scaling group by using different ports, Auto Scaling considers that more than one vServer group is attached to the scaling group. If multiple vServer groups with the same group ID and port number are specified in the request parameters, only the first vServer group is used. The other vServer groups are ignored.
 *
 * @param request AttachVServerGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachVServerGroupsResponse
 */
func (client *Client) AttachVServerGroupsWithOptions(request *AttachVServerGroupsRequest, runtime *util.RuntimeOptions) (_result *AttachVServerGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ForceAttach)) {
		query["ForceAttach"] = request.ForceAttach
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroups)) {
		query["VServerGroups"] = request.VServerGroups
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachVServerGroups"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachVServerGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this operation to attach a vServer group to your scaling group, take note of the following items:
 * *   The CLB instance and the scaling group must belong to the same Alibaba Cloud account.
 * *   The CLB instance and the scaling group must reside in the same region.
 * *   The CLB instance must be in the Running state.
 * *   The CLB instance must be configured with at least one listener. Health check is enabled for the CLB instance.
 * *   The CLB instance and the scaling group must be in the same VPC if their network type is VPC.
 * *   If the network type of the scaling group is VPC, the network type of the CLB instance is classic network, and the vServer groups of the CLB instance contain instances of the VPC network type, the instances and the scaling group must be in the same VPC.
 * *   The vServer group that you want to attach to your scaling group must belong to the CLB instance.
 * *   You can attach only a limited number of vServer groups to a scaling group. For information about the quota on vServer groups, see [Limits](~~25863~~).
 * When you call this operation, you must specify the following parameters:
 * *   LoadBalancerId: the ID of the CLB instance.
 * *   VServerGroupId: the ID of the vServer group.
 * *   Port: the port number of the vServer group.
 * If a vServer group is attached to a scaling group by using different ports, Auto Scaling considers that more than one vServer group is attached to the scaling group. If multiple vServer groups with the same group ID and port number are specified in the request parameters, only the first vServer group is used. The other vServer groups are ignored.
 *
 * @param request AttachVServerGroupsRequest
 * @return AttachVServerGroupsResponse
 */
func (client *Client) AttachVServerGroups(request *AttachVServerGroupsRequest) (_result *AttachVServerGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachVServerGroupsResponse{}
	_body, _err := client.AttachVServerGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ChangeResourceGroupWithOptions(request *ChangeResourceGroupRequest, runtime *util.RuntimeOptions) (_result *ChangeResourceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NewResourceGroupId)) {
		query["NewResourceGroupId"] = request.NewResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ChangeResourceGroup"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ChangeResourceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ChangeResourceGroup(request *ChangeResourceGroupRequest) (_result *ChangeResourceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ChangeResourceGroupResponse{}
	_body, _err := client.ChangeResourceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If you set the LifecycleActionResult parameter for a lifecycle hook of a scaling group to CONTINUE in the operation, Auto Scaling continues to complete the scaling activity in the scaling group after the lifecycle hook times out. If you set the LifecycleActionResult parameter to ABANDON, Auto Scaling stops the scaling activity in the scaling group after the lifecycle hook times out.
 *
 * @param request CompleteLifecycleActionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CompleteLifecycleActionResponse
 */
func (client *Client) CompleteLifecycleActionWithOptions(request *CompleteLifecycleActionRequest, runtime *util.RuntimeOptions) (_result *CompleteLifecycleActionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleActionResult)) {
		query["LifecycleActionResult"] = request.LifecycleActionResult
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleActionToken)) {
		query["LifecycleActionToken"] = request.LifecycleActionToken
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleHookId)) {
		query["LifecycleHookId"] = request.LifecycleHookId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CompleteLifecycleAction"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CompleteLifecycleActionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If you set the LifecycleActionResult parameter for a lifecycle hook of a scaling group to CONTINUE in the operation, Auto Scaling continues to complete the scaling activity in the scaling group after the lifecycle hook times out. If you set the LifecycleActionResult parameter to ABANDON, Auto Scaling stops the scaling activity in the scaling group after the lifecycle hook times out.
 *
 * @param request CompleteLifecycleActionRequest
 * @return CompleteLifecycleActionResponse
 */
func (client *Client) CompleteLifecycleAction(request *CompleteLifecycleActionRequest) (_result *CompleteLifecycleActionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CompleteLifecycleActionResponse{}
	_body, _err := client.CompleteLifecycleActionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateAlarmWithOptions(request *CreateAlarmRequest, runtime *util.RuntimeOptions) (_result *CreateAlarmResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlarmActions)) {
		query["AlarmActions"] = request.AlarmActions
	}

	if !tea.BoolValue(util.IsUnset(request.ComparisonOperator)) {
		query["ComparisonOperator"] = request.ComparisonOperator
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Dimensions)) {
		query["Dimensions"] = request.Dimensions
	}

	if !tea.BoolValue(util.IsUnset(request.Effective)) {
		query["Effective"] = request.Effective
	}

	if !tea.BoolValue(util.IsUnset(request.EvaluationCount)) {
		query["EvaluationCount"] = request.EvaluationCount
	}

	if !tea.BoolValue(util.IsUnset(request.Expressions)) {
		query["Expressions"] = request.Expressions
	}

	if !tea.BoolValue(util.IsUnset(request.ExpressionsLogicOperator)) {
		query["ExpressionsLogicOperator"] = request.ExpressionsLogicOperator
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.MetricName)) {
		query["MetricName"] = request.MetricName
	}

	if !tea.BoolValue(util.IsUnset(request.MetricType)) {
		query["MetricType"] = request.MetricType
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Statistics)) {
		query["Statistics"] = request.Statistics
	}

	if !tea.BoolValue(util.IsUnset(request.Threshold)) {
		query["Threshold"] = request.Threshold
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAlarm"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateAlarmResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateAlarm(request *CreateAlarmRequest) (_result *CreateAlarmResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateAlarmResponse{}
	_body, _err := client.CreateAlarmWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * A scaling configuration is a template that is used to create elastic container instances during scale-out activities.
 * You can specify the Cpu and Memory parameters to determine the range of instance types. If you specify the parameters, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Auto Scaling preferentially creates elastic container instances of the instance type that is provided at the lowest price. This scaling mode is available only if Scaling Policy is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
 *
 * @param request CreateEciScalingConfigurationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEciScalingConfigurationResponse
 */
func (client *Client) CreateEciScalingConfigurationWithOptions(request *CreateEciScalingConfigurationRequest, runtime *util.RuntimeOptions) (_result *CreateEciScalingConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcrRegistryInfos)) {
		query["AcrRegistryInfos"] = request.AcrRegistryInfos
	}

	if !tea.BoolValue(util.IsUnset(request.ActiveDeadlineSeconds)) {
		query["ActiveDeadlineSeconds"] = request.ActiveDeadlineSeconds
	}

	if !tea.BoolValue(util.IsUnset(request.AutoCreateEip)) {
		query["AutoCreateEip"] = request.AutoCreateEip
	}

	if !tea.BoolValue(util.IsUnset(request.AutoMatchImageCache)) {
		query["AutoMatchImageCache"] = request.AutoMatchImageCache
	}

	if !tea.BoolValue(util.IsUnset(request.ContainerGroupName)) {
		query["ContainerGroupName"] = request.ContainerGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.Containers)) {
		query["Containers"] = request.Containers
	}

	if !tea.BoolValue(util.IsUnset(request.CostOptimization)) {
		query["CostOptimization"] = request.CostOptimization
	}

	if !tea.BoolValue(util.IsUnset(request.Cpu)) {
		query["Cpu"] = request.Cpu
	}

	if !tea.BoolValue(util.IsUnset(request.CpuOptionsCore)) {
		query["CpuOptionsCore"] = request.CpuOptionsCore
	}

	if !tea.BoolValue(util.IsUnset(request.CpuOptionsThreadsPerCore)) {
		query["CpuOptionsThreadsPerCore"] = request.CpuOptionsThreadsPerCore
	}

	if !tea.BoolValue(util.IsUnset(request.DataCacheBucket)) {
		query["DataCacheBucket"] = request.DataCacheBucket
	}

	if !tea.BoolValue(util.IsUnset(request.DataCacheBurstingEnabled)) {
		query["DataCacheBurstingEnabled"] = request.DataCacheBurstingEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.DataCachePL)) {
		query["DataCachePL"] = request.DataCachePL
	}

	if !tea.BoolValue(util.IsUnset(request.DataCacheProvisionedIops)) {
		query["DataCacheProvisionedIops"] = request.DataCacheProvisionedIops
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DnsConfigNameServers)) {
		query["DnsConfigNameServers"] = request.DnsConfigNameServers
	}

	if !tea.BoolValue(util.IsUnset(request.DnsConfigOptions)) {
		query["DnsConfigOptions"] = request.DnsConfigOptions
	}

	if !tea.BoolValue(util.IsUnset(request.DnsConfigSearchs)) {
		query["DnsConfigSearchs"] = request.DnsConfigSearchs
	}

	if !tea.BoolValue(util.IsUnset(request.DnsPolicy)) {
		query["DnsPolicy"] = request.DnsPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.EgressBandwidth)) {
		query["EgressBandwidth"] = request.EgressBandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.EipBandwidth)) {
		query["EipBandwidth"] = request.EipBandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.EnableSls)) {
		query["EnableSls"] = request.EnableSls
	}

	if !tea.BoolValue(util.IsUnset(request.EphemeralStorage)) {
		query["EphemeralStorage"] = request.EphemeralStorage
	}

	if !tea.BoolValue(util.IsUnset(request.HostAliases)) {
		query["HostAliases"] = request.HostAliases
	}

	if !tea.BoolValue(util.IsUnset(request.HostName)) {
		query["HostName"] = request.HostName
	}

	if !tea.BoolValue(util.IsUnset(request.ImageRegistryCredentials)) {
		query["ImageRegistryCredentials"] = request.ImageRegistryCredentials
	}

	if !tea.BoolValue(util.IsUnset(request.ImageSnapshotId)) {
		query["ImageSnapshotId"] = request.ImageSnapshotId
	}

	if !tea.BoolValue(util.IsUnset(request.IngressBandwidth)) {
		query["IngressBandwidth"] = request.IngressBandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.InitContainers)) {
		query["InitContainers"] = request.InitContainers
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceFamilyLevel)) {
		query["InstanceFamilyLevel"] = request.InstanceFamilyLevel
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceTypes)) {
		query["InstanceTypes"] = request.InstanceTypes
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6AddressCount)) {
		query["Ipv6AddressCount"] = request.Ipv6AddressCount
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerWeight)) {
		query["LoadBalancerWeight"] = request.LoadBalancerWeight
	}

	if !tea.BoolValue(util.IsUnset(request.Memory)) {
		query["Memory"] = request.Memory
	}

	if !tea.BoolValue(util.IsUnset(request.NtpServers)) {
		query["NtpServers"] = request.NtpServers
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RamRoleName)) {
		query["RamRoleName"] = request.RamRoleName
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.RestartPolicy)) {
		query["RestartPolicy"] = request.RestartPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationName)) {
		query["ScalingConfigurationName"] = request.ScalingConfigurationName
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityContextSysctls)) {
		query["SecurityContextSysctls"] = request.SecurityContextSysctls
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityGroupId)) {
		query["SecurityGroupId"] = request.SecurityGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SpotPriceLimit)) {
		query["SpotPriceLimit"] = request.SpotPriceLimit
	}

	if !tea.BoolValue(util.IsUnset(request.SpotStrategy)) {
		query["SpotStrategy"] = request.SpotStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.TerminationGracePeriodSeconds)) {
		query["TerminationGracePeriodSeconds"] = request.TerminationGracePeriodSeconds
	}

	if !tea.BoolValue(util.IsUnset(request.Volumes)) {
		query["Volumes"] = request.Volumes
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateEciScalingConfiguration"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateEciScalingConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * A scaling configuration is a template that is used to create elastic container instances during scale-out activities.
 * You can specify the Cpu and Memory parameters to determine the range of instance types. If you specify the parameters, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Auto Scaling preferentially creates elastic container instances of the instance type that is provided at the lowest price. This scaling mode is available only if Scaling Policy is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
 *
 * @param request CreateEciScalingConfigurationRequest
 * @return CreateEciScalingConfigurationResponse
 */
func (client *Client) CreateEciScalingConfiguration(request *CreateEciScalingConfigurationRequest) (_result *CreateEciScalingConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateEciScalingConfigurationResponse{}
	_body, _err := client.CreateEciScalingConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can create up to six lifecycle hooks for each scaling group. Elastic Compute Service (ECS) instances are not immediately added to or removed from scaling groups that have effective lifecycle hooks during scaling activities. The ECS instances are added to or removed from the scaling groups only after the lifecycle hooks time out. The period of time before the lifecycle hooks time out is specified by the HeartbeatTimeout parameter. Before lifecycle hooks time out, you can initialize the configurations of ECS instances and query data on the ECS instances.
 * If lifecycle hooks take effect for scale-out activities, the private IP addresses of ECS instances are added to the IP address whitelists of the associated ApsaraDB RDS instances and the ECS instances are added to the backend server groups of the associated Server Load Balancer (SLB) instances only after the lifecycle hooks time out. If lifecycle hooks take effect for scale-in activities, the private IP addresses of ECS instances are removed from the IP address whitelists of the disassociated ApsaraDB RDS instances and the ECS instances are removed from the backend server groups of the disassociated SLB instances only after the lifecycle hooks time out.
 * You can configure a notification method for a lifecycle hook. When the lifecycle hook takes effect, a notification can be sent by using a Message Service (MNS) topic, an MNS queue, or an Operation Orchestration Service (OOS) template. If you want to configure an OOS template, you must create a RAM role for OOS. For more information, see [Grant RAM permissions to OOS](~~120810~~).
 * > If your scaling group contains ECS instances and you configure an OOS template to add the private IP addresses of the ECS instances to or remove the private IP addresses of the ECS instances from the IP address whitelists of cloud databases other than ApsaraDB RDS databases, you must manually add the private IP addresses of the ECS instances to the IP address whitelists of the cloud databases.
 *
 * @param request CreateLifecycleHookRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLifecycleHookResponse
 */
func (client *Client) CreateLifecycleHookWithOptions(request *CreateLifecycleHookRequest, runtime *util.RuntimeOptions) (_result *CreateLifecycleHookResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DefaultResult)) {
		query["DefaultResult"] = request.DefaultResult
	}

	if !tea.BoolValue(util.IsUnset(request.HeartbeatTimeout)) {
		query["HeartbeatTimeout"] = request.HeartbeatTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleHookName)) {
		query["LifecycleHookName"] = request.LifecycleHookName
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleTransition)) {
		query["LifecycleTransition"] = request.LifecycleTransition
	}

	if !tea.BoolValue(util.IsUnset(request.NotificationArn)) {
		query["NotificationArn"] = request.NotificationArn
	}

	if !tea.BoolValue(util.IsUnset(request.NotificationMetadata)) {
		query["NotificationMetadata"] = request.NotificationMetadata
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateLifecycleHook"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateLifecycleHookResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can create up to six lifecycle hooks for each scaling group. Elastic Compute Service (ECS) instances are not immediately added to or removed from scaling groups that have effective lifecycle hooks during scaling activities. The ECS instances are added to or removed from the scaling groups only after the lifecycle hooks time out. The period of time before the lifecycle hooks time out is specified by the HeartbeatTimeout parameter. Before lifecycle hooks time out, you can initialize the configurations of ECS instances and query data on the ECS instances.
 * If lifecycle hooks take effect for scale-out activities, the private IP addresses of ECS instances are added to the IP address whitelists of the associated ApsaraDB RDS instances and the ECS instances are added to the backend server groups of the associated Server Load Balancer (SLB) instances only after the lifecycle hooks time out. If lifecycle hooks take effect for scale-in activities, the private IP addresses of ECS instances are removed from the IP address whitelists of the disassociated ApsaraDB RDS instances and the ECS instances are removed from the backend server groups of the disassociated SLB instances only after the lifecycle hooks time out.
 * You can configure a notification method for a lifecycle hook. When the lifecycle hook takes effect, a notification can be sent by using a Message Service (MNS) topic, an MNS queue, or an Operation Orchestration Service (OOS) template. If you want to configure an OOS template, you must create a RAM role for OOS. For more information, see [Grant RAM permissions to OOS](~~120810~~).
 * > If your scaling group contains ECS instances and you configure an OOS template to add the private IP addresses of the ECS instances to or remove the private IP addresses of the ECS instances from the IP address whitelists of cloud databases other than ApsaraDB RDS databases, you must manually add the private IP addresses of the ECS instances to the IP address whitelists of the cloud databases.
 *
 * @param request CreateLifecycleHookRequest
 * @return CreateLifecycleHookResponse
 */
func (client *Client) CreateLifecycleHook(request *CreateLifecycleHookRequest) (_result *CreateLifecycleHookResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateLifecycleHookResponse{}
	_body, _err := client.CreateLifecycleHookWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Description
 * You can configure CloudMonitor system events, Message Service (MNS) queues, or MNS topics to receive notifications. When a specified type of scaling activity or resource change occurs in a scaling group, Auto Scaling sends notifications by using CloudMonitor or MNS.
 *
 * @param request CreateNotificationConfigurationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateNotificationConfigurationResponse
 */
func (client *Client) CreateNotificationConfigurationWithOptions(request *CreateNotificationConfigurationRequest, runtime *util.RuntimeOptions) (_result *CreateNotificationConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NotificationArn)) {
		query["NotificationArn"] = request.NotificationArn
	}

	if !tea.BoolValue(util.IsUnset(request.NotificationTypes)) {
		query["NotificationTypes"] = request.NotificationTypes
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateNotificationConfiguration"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateNotificationConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Description
 * You can configure CloudMonitor system events, Message Service (MNS) queues, or MNS topics to receive notifications. When a specified type of scaling activity or resource change occurs in a scaling group, Auto Scaling sends notifications by using CloudMonitor or MNS.
 *
 * @param request CreateNotificationConfigurationRequest
 * @return CreateNotificationConfigurationResponse
 */
func (client *Client) CreateNotificationConfiguration(request *CreateNotificationConfigurationRequest) (_result *CreateNotificationConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateNotificationConfigurationResponse{}
	_body, _err := client.CreateNotificationConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Auto Scaling automatically creates Elastic Compute Service (ECS) instances based on the specified scaling configuration. ECS instances can be created in the following modes:
 * *   InstancePatternInfos: intelligent configuration mode. In this mode, you need to only specify the number of vCPUs, memory size, instance family, and maximum price. Auto Scaling selects the instance type that has the lowest price based on the configurations to create ECS instances. This mode is available only for scaling groups that reside in virtual private clouds (VPCs). This mode reduces scale-out failures caused by insufficient inventory of instance types.
 * *   InstanceType: In this mode, you must specify one instance type.
 * *   InstanceTypes: In this mode, you can specify more than one instance type.
 * *   InstanceTypeOverrides: In this mode, you can specify multiple instance types and weights for the instance types.
 * *   Cpu and Memory: In this mode, you must specify the number of vCPUs and the memory size. Auto Scaling determines the range of available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling creates ECS instances by using the lowest-priced instance type. This mode is available only if Scaling Policy is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
 * > You cannot specify InstanceType, InstanceTypes, InstanceTypeOverrides, and Cpu and Memory at the same time. You can specify InstanceType and InstancePatternInfos or specify InstanceTypes and InstancePatternInfo at the same time. If you specify InstanceType and InstancePatternInfos or specify InstanceTypes and InstancePatternInfos at the same time, Auto Scaling preferentially uses the instance types that are specified by InstanceType or InstanceTypes for scale-outs. If the instance types that are specified by InstanceType or InstanceTypes do not have sufficient inventory, Auto Scaling uses the instance types that are specified by InstancePatternInfos for scale-outs.
 *
 * @param tmpReq CreateScalingConfigurationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateScalingConfigurationResponse
 */
func (client *Client) CreateScalingConfigurationWithOptions(tmpReq *CreateScalingConfigurationRequest, runtime *util.RuntimeOptions) (_result *CreateScalingConfigurationResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateScalingConfigurationShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.SchedulerOptions)) {
		request.SchedulerOptionsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.SchedulerOptions, tea.String("SchedulerOptions"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Affinity)) {
		query["Affinity"] = request.Affinity
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Cpu)) {
		query["Cpu"] = request.Cpu
	}

	if !tea.BoolValue(util.IsUnset(request.CreditSpecification)) {
		query["CreditSpecification"] = request.CreditSpecification
	}

	if !tea.BoolValue(util.IsUnset(request.DataDisks)) {
		query["DataDisks"] = request.DataDisks
	}

	if !tea.BoolValue(util.IsUnset(request.DedicatedHostId)) {
		query["DedicatedHostId"] = request.DedicatedHostId
	}

	if !tea.BoolValue(util.IsUnset(request.DeletionProtection)) {
		query["DeletionProtection"] = request.DeletionProtection
	}

	if !tea.BoolValue(util.IsUnset(request.DeploymentSetId)) {
		query["DeploymentSetId"] = request.DeploymentSetId
	}

	if !tea.BoolValue(util.IsUnset(request.HostName)) {
		query["HostName"] = request.HostName
	}

	if !tea.BoolValue(util.IsUnset(request.HpcClusterId)) {
		query["HpcClusterId"] = request.HpcClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ImageFamily)) {
		query["ImageFamily"] = request.ImageFamily
	}

	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.ImageName)) {
		query["ImageName"] = request.ImageName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceDescription)) {
		query["InstanceDescription"] = request.InstanceDescription
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceName)) {
		query["InstanceName"] = request.InstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.InstancePatternInfos)) {
		query["InstancePatternInfos"] = request.InstancePatternInfos
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceTypeOverrides)) {
		query["InstanceTypeOverrides"] = request.InstanceTypeOverrides
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceTypes)) {
		query["InstanceTypes"] = request.InstanceTypes
	}

	if !tea.BoolValue(util.IsUnset(request.InternetChargeType)) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.InternetMaxBandwidthIn)) {
		query["InternetMaxBandwidthIn"] = request.InternetMaxBandwidthIn
	}

	if !tea.BoolValue(util.IsUnset(request.InternetMaxBandwidthOut)) {
		query["InternetMaxBandwidthOut"] = request.InternetMaxBandwidthOut
	}

	if !tea.BoolValue(util.IsUnset(request.IoOptimized)) {
		query["IoOptimized"] = request.IoOptimized
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6AddressCount)) {
		query["Ipv6AddressCount"] = request.Ipv6AddressCount
	}

	if !tea.BoolValue(util.IsUnset(request.KeyPairName)) {
		query["KeyPairName"] = request.KeyPairName
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerWeight)) {
		query["LoadBalancerWeight"] = request.LoadBalancerWeight
	}

	if !tea.BoolValue(util.IsUnset(request.Memory)) {
		query["Memory"] = request.Memory
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Password)) {
		query["Password"] = request.Password
	}

	if !tea.BoolValue(util.IsUnset(request.PasswordInherit)) {
		query["PasswordInherit"] = request.PasswordInherit
	}

	if !tea.BoolValue(util.IsUnset(request.RamRoleName)) {
		query["RamRoleName"] = request.RamRoleName
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationName)) {
		query["ScalingConfigurationName"] = request.ScalingConfigurationName
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SchedulerOptionsShrink)) {
		query["SchedulerOptions"] = request.SchedulerOptionsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityEnhancementStrategy)) {
		query["SecurityEnhancementStrategy"] = request.SecurityEnhancementStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityGroupId)) {
		query["SecurityGroupId"] = request.SecurityGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityGroupIds)) {
		query["SecurityGroupIds"] = request.SecurityGroupIds
	}

	if !tea.BoolValue(util.IsUnset(request.SpotDuration)) {
		query["SpotDuration"] = request.SpotDuration
	}

	if !tea.BoolValue(util.IsUnset(request.SpotInterruptionBehavior)) {
		query["SpotInterruptionBehavior"] = request.SpotInterruptionBehavior
	}

	if !tea.BoolValue(util.IsUnset(request.SpotPriceLimits)) {
		query["SpotPriceLimits"] = request.SpotPriceLimits
	}

	if !tea.BoolValue(util.IsUnset(request.SpotStrategy)) {
		query["SpotStrategy"] = request.SpotStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.StorageSetId)) {
		query["StorageSetId"] = request.StorageSetId
	}

	if !tea.BoolValue(util.IsUnset(request.StorageSetPartitionNumber)) {
		query["StorageSetPartitionNumber"] = request.StorageSetPartitionNumber
	}

	if !tea.BoolValue(util.IsUnset(request.SystemDiskCategories)) {
		query["SystemDiskCategories"] = request.SystemDiskCategories
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.Tenancy)) {
		query["Tenancy"] = request.Tenancy
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	if !tea.BoolValue(util.IsUnset(request.ImageOptions)) {
		query["ImageOptions"] = request.ImageOptions
	}

	if !tea.BoolValue(util.IsUnset(request.PrivatePoolOptions)) {
		query["PrivatePoolOptions"] = request.PrivatePoolOptions
	}

	if !tea.BoolValue(util.IsUnset(request.SystemDisk)) {
		query["SystemDisk"] = request.SystemDisk
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateScalingConfiguration"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateScalingConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Auto Scaling automatically creates Elastic Compute Service (ECS) instances based on the specified scaling configuration. ECS instances can be created in the following modes:
 * *   InstancePatternInfos: intelligent configuration mode. In this mode, you need to only specify the number of vCPUs, memory size, instance family, and maximum price. Auto Scaling selects the instance type that has the lowest price based on the configurations to create ECS instances. This mode is available only for scaling groups that reside in virtual private clouds (VPCs). This mode reduces scale-out failures caused by insufficient inventory of instance types.
 * *   InstanceType: In this mode, you must specify one instance type.
 * *   InstanceTypes: In this mode, you can specify more than one instance type.
 * *   InstanceTypeOverrides: In this mode, you can specify multiple instance types and weights for the instance types.
 * *   Cpu and Memory: In this mode, you must specify the number of vCPUs and the memory size. Auto Scaling determines the range of available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling creates ECS instances by using the lowest-priced instance type. This mode is available only if Scaling Policy is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
 * > You cannot specify InstanceType, InstanceTypes, InstanceTypeOverrides, and Cpu and Memory at the same time. You can specify InstanceType and InstancePatternInfos or specify InstanceTypes and InstancePatternInfo at the same time. If you specify InstanceType and InstancePatternInfos or specify InstanceTypes and InstancePatternInfos at the same time, Auto Scaling preferentially uses the instance types that are specified by InstanceType or InstanceTypes for scale-outs. If the instance types that are specified by InstanceType or InstanceTypes do not have sufficient inventory, Auto Scaling uses the instance types that are specified by InstancePatternInfos for scale-outs.
 *
 * @param request CreateScalingConfigurationRequest
 * @return CreateScalingConfigurationResponse
 */
func (client *Client) CreateScalingConfiguration(request *CreateScalingConfigurationRequest) (_result *CreateScalingConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateScalingConfigurationResponse{}
	_body, _err := client.CreateScalingConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * A scaling group is a group of Elastic Compute Service (ECS) instances that can be used in similar business scenarios.
 * You can create only a limited number of scaling groups in a region. Go to Quota Center to check the quota of the scaling groups.
 * A scaling group does not immediately take effect after you create the scaling group. You must call the EnableScalingGroup operation to enable the scaling group. After you enable the scaling group, Auto Scaling can execute scaling rules to trigger scaling activities in the scaling group.
 * The Classic Load Balancer (CLB) instances and ApsaraDB RDS instances that you want to associate with a scaling group must reside in the same region as the scaling group. CLB instances are formerly known as Server Load Balancer (SLB) instances. For more information, see the "Regions and zones" topic.
 * If you associate a CLB instance when you create a scaling group, Auto Scaling automatically adds ECS instances in the scaling group to the backend server group of the associated CLB instance. You can specify a server group to which ECS instances can be added. You can add ECS instances to the following types of server groups:
 * *   Default server group: a group of ECS instances that are used to receive requests. If you do not specify a vServer group or a primary/secondary server group for a listener, requests are forwarded to the ECS instances in the default server group.
 * *   vServer group: If you want to forward requests to backend servers that are not in the default server group or configure domain name-based or URL-based forwarding rules, you can use vServer groups.
 * > If you specify the default server group and multiple vServer groups at the same time, ECS instances are added to all specified server groups.
 * The default weight of an ECS instance that is added as a backend server of a CLB instance is 50. The CLB instance that you want to associate with your scaling group must meet the following requirements:
 * *   The CLB instance must be in the Active state. You can call the DescribeLoadBalancers operation to query the state of the CLB instance.
 * *   The health check feature must be enabled on all listener ports that are configured for the CLB instance. Otherwise, the scaling group fails to be created.
 * If you associate an Application Load Balancer (ALB) server group with a scaling group, Auto Scaling automatically adds ECS instances that are in the scaling group to the ALB server group to process requests distributed by the ALB instance to which the ALB server group belongs. You can specify multiple ALB server groups. The server groups must reside in the same virtual private cloud (VPC) as the scaling group. For more information, see the "AttachAlbServerGroups" topic.
 * If you associate an ApsaraDB RDS instance with a scaling group, Auto Scaling automatically adds the private IP addresses of the ECS instances in the scaling group to the IP address whitelist of the ApsaraDB RDS instance. The ApsaraDB RDS instance that you want to associate with your scaling group must meet the following requirements:
 * *   The ApsaraDB RDS instance must be in the Running state. You can call the DescribeDBInstances operation to query the state of the ApsaraDB RDS instance.
 * *   The number of IP addresses in the IP address whitelist of the ApsaraDB RDS instance cannot exceed the upper limit. For more information, see the "Configure whitelists" topic.
 * If you set the MultiAZPolicy parameter of the scaling group to COST_OPTIMIZED, take note of the following items:
 * *   You can use the OnDemandBaseCapacity, OnDemandPercentageAboveBaseCapacity, and SpotInstancePools parameters to specify the instance allocation method based on the cost optimization policy. This instance allocation method is prioritized during scaling.
 * *   If you do not specify the OnDemandBaseCapacity, OnDemandPercentageAboveBaseCapacity, or SpotInstancePools parameter, the instance types that are provided at the lowest price are used to create instances based on the cost optimization policy.
 * If you set the `Tags.Propagate` parameter of the scaling group to true, the following rules apply:
 * *   Tags that you add to the scaling group cannot be propagated to existing instances in the scaling group. Tags that you add to the scaling group are propagated to only new instances.
 * *   If you specify instance tags in the scaling configuration that is used to create instances and propagate the tags that you add to the scaling group to the instances, all tags exist at the same time.
 * *   If the tag key that you specify in a scaling configuration and the tag key that you add to the scaling group of the scaling configuration are the same, the tag value that you specify in the scaling configuration is preferentially used.
 *
 * @param request CreateScalingGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateScalingGroupResponse
 */
func (client *Client) CreateScalingGroupWithOptions(request *CreateScalingGroupRequest, runtime *util.RuntimeOptions) (_result *CreateScalingGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlbServerGroups)) {
		query["AlbServerGroups"] = request.AlbServerGroups
	}

	if !tea.BoolValue(util.IsUnset(request.AllocationStrategy)) {
		query["AllocationStrategy"] = request.AllocationStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.AzBalance)) {
		query["AzBalance"] = request.AzBalance
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CompensateWithOnDemand)) {
		query["CompensateWithOnDemand"] = request.CompensateWithOnDemand
	}

	if !tea.BoolValue(util.IsUnset(request.ContainerGroupId)) {
		query["ContainerGroupId"] = request.ContainerGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.CustomPolicyARN)) {
		query["CustomPolicyARN"] = request.CustomPolicyARN
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceIds)) {
		query["DBInstanceIds"] = request.DBInstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.DefaultCooldown)) {
		query["DefaultCooldown"] = request.DefaultCooldown
	}

	if !tea.BoolValue(util.IsUnset(request.DesiredCapacity)) {
		query["DesiredCapacity"] = request.DesiredCapacity
	}

	if !tea.BoolValue(util.IsUnset(request.GroupDeletionProtection)) {
		query["GroupDeletionProtection"] = request.GroupDeletionProtection
	}

	if !tea.BoolValue(util.IsUnset(request.GroupType)) {
		query["GroupType"] = request.GroupType
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckType)) {
		query["HealthCheckType"] = request.HealthCheckType
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchTemplateId)) {
		query["LaunchTemplateId"] = request.LaunchTemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchTemplateOverrides)) {
		query["LaunchTemplateOverrides"] = request.LaunchTemplateOverrides
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchTemplateVersion)) {
		query["LaunchTemplateVersion"] = request.LaunchTemplateVersion
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleHooks)) {
		query["LifecycleHooks"] = request.LifecycleHooks
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerConfigs)) {
		query["LoadBalancerConfigs"] = request.LoadBalancerConfigs
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerIds)) {
		query["LoadBalancerIds"] = request.LoadBalancerIds
	}

	if !tea.BoolValue(util.IsUnset(request.MaxInstanceLifetime)) {
		query["MaxInstanceLifetime"] = request.MaxInstanceLifetime
	}

	if !tea.BoolValue(util.IsUnset(request.MaxSize)) {
		query["MaxSize"] = request.MaxSize
	}

	if !tea.BoolValue(util.IsUnset(request.MinSize)) {
		query["MinSize"] = request.MinSize
	}

	if !tea.BoolValue(util.IsUnset(request.MultiAZPolicy)) {
		query["MultiAZPolicy"] = request.MultiAZPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.OnDemandBaseCapacity)) {
		query["OnDemandBaseCapacity"] = request.OnDemandBaseCapacity
	}

	if !tea.BoolValue(util.IsUnset(request.OnDemandPercentageAboveBaseCapacity)) {
		query["OnDemandPercentageAboveBaseCapacity"] = request.OnDemandPercentageAboveBaseCapacity
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RemovalPolicies)) {
		query["RemovalPolicies"] = request.RemovalPolicies
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupName)) {
		query["ScalingGroupName"] = request.ScalingGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingPolicy)) {
		query["ScalingPolicy"] = request.ScalingPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.ServerGroups)) {
		query["ServerGroups"] = request.ServerGroups
	}

	if !tea.BoolValue(util.IsUnset(request.SpotAllocationStrategy)) {
		query["SpotAllocationStrategy"] = request.SpotAllocationStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.SpotInstancePools)) {
		query["SpotInstancePools"] = request.SpotInstancePools
	}

	if !tea.BoolValue(util.IsUnset(request.SpotInstanceRemedy)) {
		query["SpotInstanceRemedy"] = request.SpotInstanceRemedy
	}

	if !tea.BoolValue(util.IsUnset(request.SyncAlarmRuleToCms)) {
		query["SyncAlarmRuleToCms"] = request.SyncAlarmRuleToCms
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroups)) {
		query["VServerGroups"] = request.VServerGroups
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchIds)) {
		query["VSwitchIds"] = request.VSwitchIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateScalingGroup"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateScalingGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * A scaling group is a group of Elastic Compute Service (ECS) instances that can be used in similar business scenarios.
 * You can create only a limited number of scaling groups in a region. Go to Quota Center to check the quota of the scaling groups.
 * A scaling group does not immediately take effect after you create the scaling group. You must call the EnableScalingGroup operation to enable the scaling group. After you enable the scaling group, Auto Scaling can execute scaling rules to trigger scaling activities in the scaling group.
 * The Classic Load Balancer (CLB) instances and ApsaraDB RDS instances that you want to associate with a scaling group must reside in the same region as the scaling group. CLB instances are formerly known as Server Load Balancer (SLB) instances. For more information, see the "Regions and zones" topic.
 * If you associate a CLB instance when you create a scaling group, Auto Scaling automatically adds ECS instances in the scaling group to the backend server group of the associated CLB instance. You can specify a server group to which ECS instances can be added. You can add ECS instances to the following types of server groups:
 * *   Default server group: a group of ECS instances that are used to receive requests. If you do not specify a vServer group or a primary/secondary server group for a listener, requests are forwarded to the ECS instances in the default server group.
 * *   vServer group: If you want to forward requests to backend servers that are not in the default server group or configure domain name-based or URL-based forwarding rules, you can use vServer groups.
 * > If you specify the default server group and multiple vServer groups at the same time, ECS instances are added to all specified server groups.
 * The default weight of an ECS instance that is added as a backend server of a CLB instance is 50. The CLB instance that you want to associate with your scaling group must meet the following requirements:
 * *   The CLB instance must be in the Active state. You can call the DescribeLoadBalancers operation to query the state of the CLB instance.
 * *   The health check feature must be enabled on all listener ports that are configured for the CLB instance. Otherwise, the scaling group fails to be created.
 * If you associate an Application Load Balancer (ALB) server group with a scaling group, Auto Scaling automatically adds ECS instances that are in the scaling group to the ALB server group to process requests distributed by the ALB instance to which the ALB server group belongs. You can specify multiple ALB server groups. The server groups must reside in the same virtual private cloud (VPC) as the scaling group. For more information, see the "AttachAlbServerGroups" topic.
 * If you associate an ApsaraDB RDS instance with a scaling group, Auto Scaling automatically adds the private IP addresses of the ECS instances in the scaling group to the IP address whitelist of the ApsaraDB RDS instance. The ApsaraDB RDS instance that you want to associate with your scaling group must meet the following requirements:
 * *   The ApsaraDB RDS instance must be in the Running state. You can call the DescribeDBInstances operation to query the state of the ApsaraDB RDS instance.
 * *   The number of IP addresses in the IP address whitelist of the ApsaraDB RDS instance cannot exceed the upper limit. For more information, see the "Configure whitelists" topic.
 * If you set the MultiAZPolicy parameter of the scaling group to COST_OPTIMIZED, take note of the following items:
 * *   You can use the OnDemandBaseCapacity, OnDemandPercentageAboveBaseCapacity, and SpotInstancePools parameters to specify the instance allocation method based on the cost optimization policy. This instance allocation method is prioritized during scaling.
 * *   If you do not specify the OnDemandBaseCapacity, OnDemandPercentageAboveBaseCapacity, or SpotInstancePools parameter, the instance types that are provided at the lowest price are used to create instances based on the cost optimization policy.
 * If you set the `Tags.Propagate` parameter of the scaling group to true, the following rules apply:
 * *   Tags that you add to the scaling group cannot be propagated to existing instances in the scaling group. Tags that you add to the scaling group are propagated to only new instances.
 * *   If you specify instance tags in the scaling configuration that is used to create instances and propagate the tags that you add to the scaling group to the instances, all tags exist at the same time.
 * *   If the tag key that you specify in a scaling configuration and the tag key that you add to the scaling group of the scaling configuration are the same, the tag value that you specify in the scaling configuration is preferentially used.
 *
 * @param request CreateScalingGroupRequest
 * @return CreateScalingGroupResponse
 */
func (client *Client) CreateScalingGroup(request *CreateScalingGroupRequest) (_result *CreateScalingGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateScalingGroupResponse{}
	_body, _err := client.CreateScalingGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Description
 * A scaling rule defines a specific scaling activity, such as adding or removing N instances. If the number of Elastic Compute Service (ECS) instances in a scaling group is less than the minimum number allowed or greater than the maximum number allowed after a scaling rule is executed, Auto Scaling adjusts the number of ECS instances that you want to add or remove. This way, the number of ECS instances can be maintained within the valid range after the scaling rule is executed. The number of ECS instances that is specified in the scaling rule remains unchanged. Example:
 * *   If your scaling group contains two ECS instances and allows up to three ECS instances, only one ECS instance is added to your scaling group after you execute a scale-out rule in which three ECS instances are specified. The number of ECS instances that is specified in the scaling rule remains unchanged.
 * *   If your scaling group contains three ECS instances and requires at least two ECS instances, only one ECS instance is removed from your scaling group after you execute a scale-in rule in which five ECS instances are specified. The number of ECS instances that is specified in the scaling rule remains unchanged.
 * Before you call this operation, take note of the following items:
 * *   If you set the AdjustmentType parameter to TotalCapacity, the number of ECS instances in the scaling group is adjusted to the specified value. The value of the AdjustmentValue parameter must be greater than or equal to 0.
 * *   If you set the AdjustmentType parameter to QuantityChangeInCapacity or PercentChangeInCapacity, a positive value of AdjustmentValue specifies the number of ECS instances that are added to the scaling group, and a negative value of AdjustmentValue specifies the number of ECS instances that are removed from the scaling group.
 * *   If you set the AdjustmentType parameter to PercentChangeInCapacity, Auto Scaling uses the following formula to calculate a value, and then rounds the value to the nearest integer to obtain the number of ECS instances that need to be scaled: Value of TotalCapacity × Value of AdjustmentValue/100.
 * *   If the cooldown time is specified in a scaling rule, the specified time applies to the scaling group after the rule is executed. Otherwise, the value of the DefaultCooldown parameter of the scaling group applies to the scaling group.
 * *   You can create only a limited number of scaling rules for a scaling group. For more information, see the "Limits" topic.
 * *   The unique identifier (ScalingRuleAri) of a scaling rule can be used by the following operations:
 *     *   ExecuteScalingRule: You can call this operation to manually execute a specific scaling rule by setting the ScalingRuleAri parameter to the unique identifier of the scaling rule.
 *     *   CreateScheduledTask: You can call this operation to create a scheduled task for a specific scaling rule by setting the ScheduledAction parameter to the unique identifier of the scaling rule.
 *
 * @param request CreateScalingRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateScalingRuleResponse
 */
func (client *Client) CreateScalingRuleWithOptions(request *CreateScalingRuleRequest, runtime *util.RuntimeOptions) (_result *CreateScalingRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AdjustmentType)) {
		query["AdjustmentType"] = request.AdjustmentType
	}

	if !tea.BoolValue(util.IsUnset(request.AdjustmentValue)) {
		query["AdjustmentValue"] = request.AdjustmentValue
	}

	if !tea.BoolValue(util.IsUnset(request.AlarmDimensions)) {
		query["AlarmDimensions"] = request.AlarmDimensions
	}

	if !tea.BoolValue(util.IsUnset(request.Cooldown)) {
		query["Cooldown"] = request.Cooldown
	}

	if !tea.BoolValue(util.IsUnset(request.DisableScaleIn)) {
		query["DisableScaleIn"] = request.DisableScaleIn
	}

	if !tea.BoolValue(util.IsUnset(request.EstimatedInstanceWarmup)) {
		query["EstimatedInstanceWarmup"] = request.EstimatedInstanceWarmup
	}

	if !tea.BoolValue(util.IsUnset(request.InitialMaxSize)) {
		query["InitialMaxSize"] = request.InitialMaxSize
	}

	if !tea.BoolValue(util.IsUnset(request.MetricName)) {
		query["MetricName"] = request.MetricName
	}

	if !tea.BoolValue(util.IsUnset(request.MinAdjustmentMagnitude)) {
		query["MinAdjustmentMagnitude"] = request.MinAdjustmentMagnitude
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PredictiveScalingMode)) {
		query["PredictiveScalingMode"] = request.PredictiveScalingMode
	}

	if !tea.BoolValue(util.IsUnset(request.PredictiveTaskBufferTime)) {
		query["PredictiveTaskBufferTime"] = request.PredictiveTaskBufferTime
	}

	if !tea.BoolValue(util.IsUnset(request.PredictiveValueBehavior)) {
		query["PredictiveValueBehavior"] = request.PredictiveValueBehavior
	}

	if !tea.BoolValue(util.IsUnset(request.PredictiveValueBuffer)) {
		query["PredictiveValueBuffer"] = request.PredictiveValueBuffer
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScaleInEvaluationCount)) {
		query["ScaleInEvaluationCount"] = request.ScaleInEvaluationCount
	}

	if !tea.BoolValue(util.IsUnset(request.ScaleOutEvaluationCount)) {
		query["ScaleOutEvaluationCount"] = request.ScaleOutEvaluationCount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleName)) {
		query["ScalingRuleName"] = request.ScalingRuleName
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleType)) {
		query["ScalingRuleType"] = request.ScalingRuleType
	}

	if !tea.BoolValue(util.IsUnset(request.StepAdjustments)) {
		query["StepAdjustments"] = request.StepAdjustments
	}

	if !tea.BoolValue(util.IsUnset(request.TargetValue)) {
		query["TargetValue"] = request.TargetValue
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateScalingRule"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateScalingRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Description
 * A scaling rule defines a specific scaling activity, such as adding or removing N instances. If the number of Elastic Compute Service (ECS) instances in a scaling group is less than the minimum number allowed or greater than the maximum number allowed after a scaling rule is executed, Auto Scaling adjusts the number of ECS instances that you want to add or remove. This way, the number of ECS instances can be maintained within the valid range after the scaling rule is executed. The number of ECS instances that is specified in the scaling rule remains unchanged. Example:
 * *   If your scaling group contains two ECS instances and allows up to three ECS instances, only one ECS instance is added to your scaling group after you execute a scale-out rule in which three ECS instances are specified. The number of ECS instances that is specified in the scaling rule remains unchanged.
 * *   If your scaling group contains three ECS instances and requires at least two ECS instances, only one ECS instance is removed from your scaling group after you execute a scale-in rule in which five ECS instances are specified. The number of ECS instances that is specified in the scaling rule remains unchanged.
 * Before you call this operation, take note of the following items:
 * *   If you set the AdjustmentType parameter to TotalCapacity, the number of ECS instances in the scaling group is adjusted to the specified value. The value of the AdjustmentValue parameter must be greater than or equal to 0.
 * *   If you set the AdjustmentType parameter to QuantityChangeInCapacity or PercentChangeInCapacity, a positive value of AdjustmentValue specifies the number of ECS instances that are added to the scaling group, and a negative value of AdjustmentValue specifies the number of ECS instances that are removed from the scaling group.
 * *   If you set the AdjustmentType parameter to PercentChangeInCapacity, Auto Scaling uses the following formula to calculate a value, and then rounds the value to the nearest integer to obtain the number of ECS instances that need to be scaled: Value of TotalCapacity × Value of AdjustmentValue/100.
 * *   If the cooldown time is specified in a scaling rule, the specified time applies to the scaling group after the rule is executed. Otherwise, the value of the DefaultCooldown parameter of the scaling group applies to the scaling group.
 * *   You can create only a limited number of scaling rules for a scaling group. For more information, see the "Limits" topic.
 * *   The unique identifier (ScalingRuleAri) of a scaling rule can be used by the following operations:
 *     *   ExecuteScalingRule: You can call this operation to manually execute a specific scaling rule by setting the ScalingRuleAri parameter to the unique identifier of the scaling rule.
 *     *   CreateScheduledTask: You can call this operation to create a scheduled task for a specific scaling rule by setting the ScheduledAction parameter to the unique identifier of the scaling rule.
 *
 * @param request CreateScalingRuleRequest
 * @return CreateScalingRuleResponse
 */
func (client *Client) CreateScalingRule(request *CreateScalingRuleRequest) (_result *CreateScalingRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateScalingRuleResponse{}
	_body, _err := client.CreateScalingRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If a scheduled task fails to trigger a scaling activity due to an ongoing scaling activity in a scaling group or because the scaling group is disabled, the scheduled task is automatically retried during the period that is specified by the LaunchExpirationTime parameter. If the scheduled task still fails to trigger a scaling activity after the period ends, the task is automatically skipped.
 * *   If multiple tasks are scheduled at similar points in time to trigger scaling activities in the same scaling group, the earliest task triggers the scaling activity first. Other tasks trigger scaling activities within their launch expiration time. Only one scaling activity can be triggered in a scaling group at a time.`` If the previous scaling activity is complete and another scheduled task attempts to trigger a scaling activity, Auto Scaling executes the scaling rule that is specified in the scheduled task and then triggers a scaling activity.``
 * *   A scheduled task supports the following scaling methods:
 *     *   `ScheduledAction`: Specify an existing scaling rule that you want Auto Scaling to execute when the scheduled task is triggered.
 *     *   `ScalingGroupId`: Specify the minimum number, maximum number, or expected number of instances for the scaling group for which you created the scheduled task.
 * > You cannot specify the `ScheduledAction` and ScalingGroupId parameters at the same time.
 *
 * @param request CreateScheduledTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateScheduledTaskResponse
 */
func (client *Client) CreateScheduledTaskWithOptions(request *CreateScheduledTaskRequest, runtime *util.RuntimeOptions) (_result *CreateScheduledTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DesiredCapacity)) {
		query["DesiredCapacity"] = request.DesiredCapacity
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchExpirationTime)) {
		query["LaunchExpirationTime"] = request.LaunchExpirationTime
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchTime)) {
		query["LaunchTime"] = request.LaunchTime
	}

	if !tea.BoolValue(util.IsUnset(request.MaxValue)) {
		query["MaxValue"] = request.MaxValue
	}

	if !tea.BoolValue(util.IsUnset(request.MinValue)) {
		query["MinValue"] = request.MinValue
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RecurrenceEndTime)) {
		query["RecurrenceEndTime"] = request.RecurrenceEndTime
	}

	if !tea.BoolValue(util.IsUnset(request.RecurrenceType)) {
		query["RecurrenceType"] = request.RecurrenceType
	}

	if !tea.BoolValue(util.IsUnset(request.RecurrenceValue)) {
		query["RecurrenceValue"] = request.RecurrenceValue
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduledAction)) {
		query["ScheduledAction"] = request.ScheduledAction
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduledTaskName)) {
		query["ScheduledTaskName"] = request.ScheduledTaskName
	}

	if !tea.BoolValue(util.IsUnset(request.TaskEnabled)) {
		query["TaskEnabled"] = request.TaskEnabled
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateScheduledTask"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateScheduledTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If a scheduled task fails to trigger a scaling activity due to an ongoing scaling activity in a scaling group or because the scaling group is disabled, the scheduled task is automatically retried during the period that is specified by the LaunchExpirationTime parameter. If the scheduled task still fails to trigger a scaling activity after the period ends, the task is automatically skipped.
 * *   If multiple tasks are scheduled at similar points in time to trigger scaling activities in the same scaling group, the earliest task triggers the scaling activity first. Other tasks trigger scaling activities within their launch expiration time. Only one scaling activity can be triggered in a scaling group at a time.`` If the previous scaling activity is complete and another scheduled task attempts to trigger a scaling activity, Auto Scaling executes the scaling rule that is specified in the scheduled task and then triggers a scaling activity.``
 * *   A scheduled task supports the following scaling methods:
 *     *   `ScheduledAction`: Specify an existing scaling rule that you want Auto Scaling to execute when the scheduled task is triggered.
 *     *   `ScalingGroupId`: Specify the minimum number, maximum number, or expected number of instances for the scaling group for which you created the scheduled task.
 * > You cannot specify the `ScheduledAction` and ScalingGroupId parameters at the same time.
 *
 * @param request CreateScheduledTaskRequest
 * @return CreateScheduledTaskResponse
 */
func (client *Client) CreateScheduledTask(request *CreateScheduledTaskRequest) (_result *CreateScheduledTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateScheduledTaskResponse{}
	_body, _err := client.CreateScheduledTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeactivateScalingConfigurationWithOptions(request *DeactivateScalingConfigurationRequest, runtime *util.RuntimeOptions) (_result *DeactivateScalingConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationId)) {
		query["ScalingConfigurationId"] = request.ScalingConfigurationId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeactivateScalingConfiguration"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeactivateScalingConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeactivateScalingConfiguration(request *DeactivateScalingConfigurationRequest) (_result *DeactivateScalingConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeactivateScalingConfigurationResponse{}
	_body, _err := client.DeactivateScalingConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteAlarmWithOptions(request *DeleteAlarmRequest, runtime *util.RuntimeOptions) (_result *DeleteAlarmResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlarmTaskId)) {
		query["AlarmTaskId"] = request.AlarmTaskId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAlarm"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAlarmResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteAlarm(request *DeleteAlarmRequest) (_result *DeleteAlarmResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAlarmResponse{}
	_body, _err := client.DeleteAlarmWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot delete a scaling configuration that is used to create elastic container instances in the following scenarios:
 * *   The scaling configuration is in the Active state.
 * *   The scaling group contains elastic container instances that are created based on the scaling configuration.
 *
 * @param request DeleteEciScalingConfigurationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteEciScalingConfigurationResponse
 */
func (client *Client) DeleteEciScalingConfigurationWithOptions(request *DeleteEciScalingConfigurationRequest, runtime *util.RuntimeOptions) (_result *DeleteEciScalingConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationId)) {
		query["ScalingConfigurationId"] = request.ScalingConfigurationId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteEciScalingConfiguration"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteEciScalingConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot delete a scaling configuration that is used to create elastic container instances in the following scenarios:
 * *   The scaling configuration is in the Active state.
 * *   The scaling group contains elastic container instances that are created based on the scaling configuration.
 *
 * @param request DeleteEciScalingConfigurationRequest
 * @return DeleteEciScalingConfigurationResponse
 */
func (client *Client) DeleteEciScalingConfiguration(request *DeleteEciScalingConfigurationRequest) (_result *DeleteEciScalingConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteEciScalingConfigurationResponse{}
	_body, _err := client.DeleteEciScalingConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteLifecycleHookWithOptions(request *DeleteLifecycleHookRequest, runtime *util.RuntimeOptions) (_result *DeleteLifecycleHookResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LifecycleHookId)) {
		query["LifecycleHookId"] = request.LifecycleHookId
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleHookName)) {
		query["LifecycleHookName"] = request.LifecycleHookName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteLifecycleHook"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteLifecycleHookResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteLifecycleHook(request *DeleteLifecycleHookRequest) (_result *DeleteLifecycleHookResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteLifecycleHookResponse{}
	_body, _err := client.DeleteLifecycleHookWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteNotificationConfigurationWithOptions(request *DeleteNotificationConfigurationRequest, runtime *util.RuntimeOptions) (_result *DeleteNotificationConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NotificationArn)) {
		query["NotificationArn"] = request.NotificationArn
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteNotificationConfiguration"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteNotificationConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteNotificationConfiguration(request *DeleteNotificationConfigurationRequest) (_result *DeleteNotificationConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteNotificationConfigurationResponse{}
	_body, _err := client.DeleteNotificationConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot delete a scaling configuration in one of the following scenarios:
 * *   The scaling configuration in your scaling group is in the Active state.
 * *   The scaling group contains ECS instances that were created based on the scaling configuration.
 *
 * @param request DeleteScalingConfigurationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteScalingConfigurationResponse
 */
func (client *Client) DeleteScalingConfigurationWithOptions(request *DeleteScalingConfigurationRequest, runtime *util.RuntimeOptions) (_result *DeleteScalingConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationId)) {
		query["ScalingConfigurationId"] = request.ScalingConfigurationId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteScalingConfiguration"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteScalingConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot delete a scaling configuration in one of the following scenarios:
 * *   The scaling configuration in your scaling group is in the Active state.
 * *   The scaling group contains ECS instances that were created based on the scaling configuration.
 *
 * @param request DeleteScalingConfigurationRequest
 * @return DeleteScalingConfigurationResponse
 */
func (client *Client) DeleteScalingConfiguration(request *DeleteScalingConfigurationRequest) (_result *DeleteScalingConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteScalingConfigurationResponse{}
	_body, _err := client.DeleteScalingConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteScalingGroupWithOptions(request *DeleteScalingGroupRequest, runtime *util.RuntimeOptions) (_result *DeleteScalingGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ForceDelete)) {
		query["ForceDelete"] = request.ForceDelete
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteScalingGroup"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteScalingGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteScalingGroup(request *DeleteScalingGroupRequest) (_result *DeleteScalingGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteScalingGroupResponse{}
	_body, _err := client.DeleteScalingGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteScalingRuleWithOptions(request *DeleteScalingRuleRequest, runtime *util.RuntimeOptions) (_result *DeleteScalingRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleId)) {
		query["ScalingRuleId"] = request.ScalingRuleId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteScalingRule"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteScalingRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteScalingRule(request *DeleteScalingRuleRequest) (_result *DeleteScalingRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteScalingRuleResponse{}
	_body, _err := client.DeleteScalingRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteScheduledTaskWithOptions(request *DeleteScheduledTaskRequest, runtime *util.RuntimeOptions) (_result *DeleteScheduledTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduledTaskId)) {
		query["ScheduledTaskId"] = request.ScheduledTaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteScheduledTask"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteScheduledTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteScheduledTask(request *DeleteScheduledTaskRequest) (_result *DeleteScheduledTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteScheduledTaskResponse{}
	_body, _err := client.DeleteScheduledTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeAlarmsWithOptions(request *DescribeAlarmsRequest, runtime *util.RuntimeOptions) (_result *DescribeAlarmsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlarmTaskId)) {
		query["AlarmTaskId"] = request.AlarmTaskId
	}

	if !tea.BoolValue(util.IsUnset(request.IsEnable)) {
		query["IsEnable"] = request.IsEnable
	}

	if !tea.BoolValue(util.IsUnset(request.MetricName)) {
		query["MetricName"] = request.MetricName
	}

	if !tea.BoolValue(util.IsUnset(request.MetricType)) {
		query["MetricType"] = request.MetricType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.State)) {
		query["State"] = request.State
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAlarms"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAlarmsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeAlarms(request *DescribeAlarmsRequest) (_result *DescribeAlarmsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAlarmsResponse{}
	_body, _err := client.DescribeAlarmsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeEciScalingConfigurationsWithOptions(request *DescribeEciScalingConfigurationsRequest, runtime *util.RuntimeOptions) (_result *DescribeEciScalingConfigurationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationIds)) {
		query["ScalingConfigurationIds"] = request.ScalingConfigurationIds
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationNames)) {
		query["ScalingConfigurationNames"] = request.ScalingConfigurationNames
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeEciScalingConfigurations"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeEciScalingConfigurationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeEciScalingConfigurations(request *DescribeEciScalingConfigurationsRequest) (_result *DescribeEciScalingConfigurationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeEciScalingConfigurationsResponse{}
	_body, _err := client.DescribeEciScalingConfigurationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If a scaling activity is executed and a lifecycle hook is created for the scaling activity, the lifecycle hook triggers a lifecycle action. A lifecycle action can be in one of the following states:
 * *   If a lifecycle action is in the Pending state, Elastic Compute Service (ECS) instances are waiting to be added to a scaling group or waiting to be removed from a scaling group.
 * *   If a lifecycle action is in the Timeout state, the lifecycle hook that triggers the lifecycle action expires and ECS instances are added to or removed from a scaling group.
 * *   If a lifecycle action is in the Completed state, you manually end the lifecycle hook that triggers the lifecycle action ahead of schedule.
 * If you do not specify the action to perform, such as execute a specific OOS template, after a lifecycle hook ends, you can call this operation to obtain the token of the lifecycle action that corresponds to the lifecycle hook. Then, you can specify a custom action to perform after the lifecycle hook ends.
 *
 * @param request DescribeLifecycleActionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLifecycleActionsResponse
 */
func (client *Client) DescribeLifecycleActionsWithOptions(request *DescribeLifecycleActionsRequest, runtime *util.RuntimeOptions) (_result *DescribeLifecycleActionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LifecycleActionStatus)) {
		query["LifecycleActionStatus"] = request.LifecycleActionStatus
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingActivityId)) {
		query["ScalingActivityId"] = request.ScalingActivityId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeLifecycleActions"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeLifecycleActionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If a scaling activity is executed and a lifecycle hook is created for the scaling activity, the lifecycle hook triggers a lifecycle action. A lifecycle action can be in one of the following states:
 * *   If a lifecycle action is in the Pending state, Elastic Compute Service (ECS) instances are waiting to be added to a scaling group or waiting to be removed from a scaling group.
 * *   If a lifecycle action is in the Timeout state, the lifecycle hook that triggers the lifecycle action expires and ECS instances are added to or removed from a scaling group.
 * *   If a lifecycle action is in the Completed state, you manually end the lifecycle hook that triggers the lifecycle action ahead of schedule.
 * If you do not specify the action to perform, such as execute a specific OOS template, after a lifecycle hook ends, you can call this operation to obtain the token of the lifecycle action that corresponds to the lifecycle hook. Then, you can specify a custom action to perform after the lifecycle hook ends.
 *
 * @param request DescribeLifecycleActionsRequest
 * @return DescribeLifecycleActionsResponse
 */
func (client *Client) DescribeLifecycleActions(request *DescribeLifecycleActionsRequest) (_result *DescribeLifecycleActionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeLifecycleActionsResponse{}
	_body, _err := client.DescribeLifecycleActionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeLifecycleHooksWithOptions(request *DescribeLifecycleHooksRequest, runtime *util.RuntimeOptions) (_result *DescribeLifecycleHooksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LifecycleHookIds)) {
		query["LifecycleHookIds"] = request.LifecycleHookIds
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleHookName)) {
		query["LifecycleHookName"] = request.LifecycleHookName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeLifecycleHooks"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeLifecycleHooksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeLifecycleHooks(request *DescribeLifecycleHooksRequest) (_result *DescribeLifecycleHooksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeLifecycleHooksResponse{}
	_body, _err := client.DescribeLifecycleHooksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeLimitationWithOptions(request *DescribeLimitationRequest, runtime *util.RuntimeOptions) (_result *DescribeLimitationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeLimitation"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeLimitationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeLimitation(request *DescribeLimitationRequest) (_result *DescribeLimitationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeLimitationResponse{}
	_body, _err := client.DescribeLimitationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeNotificationConfigurationsWithOptions(request *DescribeNotificationConfigurationsRequest, runtime *util.RuntimeOptions) (_result *DescribeNotificationConfigurationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeNotificationConfigurations"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeNotificationConfigurationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeNotificationConfigurations(request *DescribeNotificationConfigurationsRequest) (_result *DescribeNotificationConfigurationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeNotificationConfigurationsResponse{}
	_body, _err := client.DescribeNotificationConfigurationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeNotificationTypesWithOptions(request *DescribeNotificationTypesRequest, runtime *util.RuntimeOptions) (_result *DescribeNotificationTypesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeNotificationTypes"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeNotificationTypesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeNotificationTypes(request *DescribeNotificationTypesRequest) (_result *DescribeNotificationTypesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeNotificationTypesResponse{}
	_body, _err := client.DescribeNotificationTypesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeRegionsWithOptions(request *DescribeRegionsRequest, runtime *util.RuntimeOptions) (_result *DescribeRegionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRegions"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRegionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeRegions(request *DescribeRegionsRequest) (_result *DescribeRegionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRegionsResponse{}
	_body, _err := client.DescribeRegionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can specify a scaling group ID to query all scaling activities in the scaling group.
 * You can filter query results based on the status of scaling activities.
 * You can query scaling activities that are executed in the previous 30 days.
 *
 * @param request DescribeScalingActivitiesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeScalingActivitiesResponse
 */
func (client *Client) DescribeScalingActivitiesWithOptions(request *DescribeScalingActivitiesRequest, runtime *util.RuntimeOptions) (_result *DescribeScalingActivitiesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingActivityIds)) {
		query["ScalingActivityIds"] = request.ScalingActivityIds
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StatusCode)) {
		query["StatusCode"] = request.StatusCode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeScalingActivities"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeScalingActivitiesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can specify a scaling group ID to query all scaling activities in the scaling group.
 * You can filter query results based on the status of scaling activities.
 * You can query scaling activities that are executed in the previous 30 days.
 *
 * @param request DescribeScalingActivitiesRequest
 * @return DescribeScalingActivitiesResponse
 */
func (client *Client) DescribeScalingActivities(request *DescribeScalingActivitiesRequest) (_result *DescribeScalingActivitiesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeScalingActivitiesResponse{}
	_body, _err := client.DescribeScalingActivitiesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeScalingActivityDetailWithOptions(request *DescribeScalingActivityDetailRequest, runtime *util.RuntimeOptions) (_result *DescribeScalingActivityDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingActivityId)) {
		query["ScalingActivityId"] = request.ScalingActivityId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeScalingActivityDetail"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeScalingActivityDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeScalingActivityDetail(request *DescribeScalingActivityDetailRequest) (_result *DescribeScalingActivityDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeScalingActivityDetailResponse{}
	_body, _err := client.DescribeScalingActivityDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeScalingConfigurationsWithOptions(request *DescribeScalingConfigurationsRequest, runtime *util.RuntimeOptions) (_result *DescribeScalingConfigurationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationIds)) {
		query["ScalingConfigurationIds"] = request.ScalingConfigurationIds
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationNames)) {
		query["ScalingConfigurationNames"] = request.ScalingConfigurationNames
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeScalingConfigurations"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeScalingConfigurationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeScalingConfigurations(request *DescribeScalingConfigurationsRequest) (_result *DescribeScalingConfigurationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeScalingConfigurationsResponse{}
	_body, _err := client.DescribeScalingConfigurationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeScalingGroupsWithOptions(request *DescribeScalingGroupsRequest, runtime *util.RuntimeOptions) (_result *DescribeScalingGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupType)) {
		query["GroupType"] = request.GroupType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupIds)) {
		query["ScalingGroupIds"] = request.ScalingGroupIds
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupName)) {
		query["ScalingGroupName"] = request.ScalingGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupNames)) {
		query["ScalingGroupNames"] = request.ScalingGroupNames
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeScalingGroups"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeScalingGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeScalingGroups(request *DescribeScalingGroupsRequest) (_result *DescribeScalingGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeScalingGroupsResponse{}
	_body, _err := client.DescribeScalingGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeScalingInstancesWithOptions(request *DescribeScalingInstancesRequest, runtime *util.RuntimeOptions) (_result *DescribeScalingInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CreationType)) {
		query["CreationType"] = request.CreationType
	}

	if !tea.BoolValue(util.IsUnset(request.CreationTypes)) {
		query["CreationTypes"] = request.CreationTypes
	}

	if !tea.BoolValue(util.IsUnset(request.HealthStatus)) {
		query["HealthStatus"] = request.HealthStatus
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleState)) {
		query["LifecycleState"] = request.LifecycleState
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleStates)) {
		query["LifecycleStates"] = request.LifecycleStates
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingActivityId)) {
		query["ScalingActivityId"] = request.ScalingActivityId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationId)) {
		query["ScalingConfigurationId"] = request.ScalingConfigurationId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeScalingInstances"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeScalingInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeScalingInstances(request *DescribeScalingInstancesRequest) (_result *DescribeScalingInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeScalingInstancesResponse{}
	_body, _err := client.DescribeScalingInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can specify a scaling group ID to query all scaling rules in the scaling group. You can also specify the scaling rule ID, name, unique identifier, and type in the request parameters as filter conditions.
 *
 * @param request DescribeScalingRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeScalingRulesResponse
 */
func (client *Client) DescribeScalingRulesWithOptions(request *DescribeScalingRulesRequest, runtime *util.RuntimeOptions) (_result *DescribeScalingRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleAris)) {
		query["ScalingRuleAris"] = request.ScalingRuleAris
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleIds)) {
		query["ScalingRuleIds"] = request.ScalingRuleIds
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleNames)) {
		query["ScalingRuleNames"] = request.ScalingRuleNames
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleType)) {
		query["ScalingRuleType"] = request.ScalingRuleType
	}

	if !tea.BoolValue(util.IsUnset(request.ShowAlarmRules)) {
		query["ShowAlarmRules"] = request.ShowAlarmRules
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeScalingRules"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeScalingRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can specify a scaling group ID to query all scaling rules in the scaling group. You can also specify the scaling rule ID, name, unique identifier, and type in the request parameters as filter conditions.
 *
 * @param request DescribeScalingRulesRequest
 * @return DescribeScalingRulesResponse
 */
func (client *Client) DescribeScalingRules(request *DescribeScalingRulesRequest) (_result *DescribeScalingRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeScalingRulesResponse{}
	_body, _err := client.DescribeScalingRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeScheduledTasksWithOptions(request *DescribeScheduledTasksRequest, runtime *util.RuntimeOptions) (_result *DescribeScheduledTasksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduledActions)) {
		query["ScheduledActions"] = request.ScheduledActions
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduledTaskIds)) {
		query["ScheduledTaskIds"] = request.ScheduledTaskIds
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduledTaskNames)) {
		query["ScheduledTaskNames"] = request.ScheduledTaskNames
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeScheduledTasks"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeScheduledTasksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeScheduledTasks(request *DescribeScheduledTasksRequest) (_result *DescribeScheduledTasksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeScheduledTasksResponse{}
	_body, _err := client.DescribeScheduledTasksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DetachAlbServerGroupsWithOptions(request *DetachAlbServerGroupsRequest, runtime *util.RuntimeOptions) (_result *DetachAlbServerGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlbServerGroups)) {
		query["AlbServerGroups"] = request.AlbServerGroups
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ForceDetach)) {
		query["ForceDetach"] = request.ForceDetach
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachAlbServerGroups"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachAlbServerGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DetachAlbServerGroups(request *DetachAlbServerGroupsRequest) (_result *DetachAlbServerGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachAlbServerGroupsResponse{}
	_body, _err := client.DetachAlbServerGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DetachDBInstancesWithOptions(request *DetachDBInstancesRequest, runtime *util.RuntimeOptions) (_result *DetachDBInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstances)) {
		query["DBInstances"] = request.DBInstances
	}

	if !tea.BoolValue(util.IsUnset(request.ForceDetach)) {
		query["ForceDetach"] = request.ForceDetach
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachDBInstances"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachDBInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DetachDBInstances(request *DetachDBInstancesRequest) (_result *DetachDBInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachDBInstancesResponse{}
	_body, _err := client.DetachDBInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After ECS instances or elastic container instances are removed from a scaling group, you can call the AttachInstances operation to add the ECS instances or elastic container instances that are removed from the scaling group to other scaling groups.
 * After you remove an ECS instance or elastic container instance by calling the DetachInstances operation, the instance is not stopped or released.
 * Before you call this operation, make sure that the following conditions are met:
 * *   The specified scaling group is enabled.
 * *   No scaling activities in the specified scaling group are in progress.
 * > If no scaling activities in the specified scaling group are in progress, the operation can trigger scaling activities even before the cooldown time expires.
 * A successful call indicates only that Auto Scaling accepts the request. However, the scaling activity may still fail. You can obtain the status of a scaling activity based on the value of the ScalingActivityId parameter in the response.
 * The number of ECS instances or elastic container instances in a scaling group after you remove a specific number of instances from the scaling group must be equal to or greater than the value of the MinSize parameter. Otherwise, an error is reported when you call the DetachInstances operation.
 *
 * @param request DetachInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DetachInstancesResponse
 */
func (client *Client) DetachInstancesWithOptions(request *DetachInstancesRequest, runtime *util.RuntimeOptions) (_result *DetachInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DecreaseDesiredCapacity)) {
		query["DecreaseDesiredCapacity"] = request.DecreaseDesiredCapacity
	}

	if !tea.BoolValue(util.IsUnset(request.DetachOption)) {
		query["DetachOption"] = request.DetachOption
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleHook)) {
		query["LifecycleHook"] = request.LifecycleHook
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachInstances"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After ECS instances or elastic container instances are removed from a scaling group, you can call the AttachInstances operation to add the ECS instances or elastic container instances that are removed from the scaling group to other scaling groups.
 * After you remove an ECS instance or elastic container instance by calling the DetachInstances operation, the instance is not stopped or released.
 * Before you call this operation, make sure that the following conditions are met:
 * *   The specified scaling group is enabled.
 * *   No scaling activities in the specified scaling group are in progress.
 * > If no scaling activities in the specified scaling group are in progress, the operation can trigger scaling activities even before the cooldown time expires.
 * A successful call indicates only that Auto Scaling accepts the request. However, the scaling activity may still fail. You can obtain the status of a scaling activity based on the value of the ScalingActivityId parameter in the response.
 * The number of ECS instances or elastic container instances in a scaling group after you remove a specific number of instances from the scaling group must be equal to or greater than the value of the MinSize parameter. Otherwise, an error is reported when you call the DetachInstances operation.
 *
 * @param request DetachInstancesRequest
 * @return DetachInstancesResponse
 */
func (client *Client) DetachInstances(request *DetachInstancesRequest) (_result *DetachInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachInstancesResponse{}
	_body, _err := client.DetachInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DetachLoadBalancersWithOptions(request *DetachLoadBalancersRequest, runtime *util.RuntimeOptions) (_result *DetachLoadBalancersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Async)) {
		query["Async"] = request.Async
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ForceDetach)) {
		query["ForceDetach"] = request.ForceDetach
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancers)) {
		query["LoadBalancers"] = request.LoadBalancers
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachLoadBalancers"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachLoadBalancersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DetachLoadBalancers(request *DetachLoadBalancersRequest) (_result *DetachLoadBalancersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachLoadBalancersResponse{}
	_body, _err := client.DetachLoadBalancersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DetachServerGroupsWithOptions(request *DetachServerGroupsRequest, runtime *util.RuntimeOptions) (_result *DetachServerGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ForceDetach)) {
		query["ForceDetach"] = request.ForceDetach
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ServerGroups)) {
		query["ServerGroups"] = request.ServerGroups
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachServerGroups"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachServerGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DetachServerGroups(request *DetachServerGroupsRequest) (_result *DetachServerGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachServerGroupsResponse{}
	_body, _err := client.DetachServerGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can use the following parameters to specify the vServer groups that you want to detach from your scaling group.
 * *   LoadBalancerId: the ID of the Classic Load Balancer (CLB) instance.
 * *   VServerGroupId: the ID of the vServer group.
 * *   Port: the port number of the vServer group.
 * If the vServer group that is specified in this call matches the vServer group associated with your scaling group, the vServer group can be detached. Otherwise, the request for detaching the vServer group is ignored, and no error is reported.
 *
 * @param request DetachVServerGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DetachVServerGroupsResponse
 */
func (client *Client) DetachVServerGroupsWithOptions(request *DetachVServerGroupsRequest, runtime *util.RuntimeOptions) (_result *DetachVServerGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ForceDetach)) {
		query["ForceDetach"] = request.ForceDetach
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroups)) {
		query["VServerGroups"] = request.VServerGroups
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachVServerGroups"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachVServerGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can use the following parameters to specify the vServer groups that you want to detach from your scaling group.
 * *   LoadBalancerId: the ID of the Classic Load Balancer (CLB) instance.
 * *   VServerGroupId: the ID of the vServer group.
 * *   Port: the port number of the vServer group.
 * If the vServer group that is specified in this call matches the vServer group associated with your scaling group, the vServer group can be detached. Otherwise, the request for detaching the vServer group is ignored, and no error is reported.
 *
 * @param request DetachVServerGroupsRequest
 * @return DetachVServerGroupsResponse
 */
func (client *Client) DetachVServerGroups(request *DetachVServerGroupsRequest) (_result *DetachVServerGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachVServerGroupsResponse{}
	_body, _err := client.DetachVServerGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DisableAlarmWithOptions(request *DisableAlarmRequest, runtime *util.RuntimeOptions) (_result *DisableAlarmResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlarmTaskId)) {
		query["AlarmTaskId"] = request.AlarmTaskId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DisableAlarm"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DisableAlarmResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DisableAlarm(request *DisableAlarmRequest) (_result *DisableAlarmResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DisableAlarmResponse{}
	_body, _err := client.DisableAlarmWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DisableScalingGroupWithOptions(request *DisableScalingGroupRequest, runtime *util.RuntimeOptions) (_result *DisableScalingGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DisableScalingGroup"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DisableScalingGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DisableScalingGroup(request *DisableScalingGroupRequest) (_result *DisableScalingGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DisableScalingGroupResponse{}
	_body, _err := client.DisableScalingGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EnableAlarmWithOptions(request *EnableAlarmRequest, runtime *util.RuntimeOptions) (_result *EnableAlarmResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlarmTaskId)) {
		query["AlarmTaskId"] = request.AlarmTaskId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableAlarm"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableAlarmResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EnableAlarm(request *EnableAlarmRequest) (_result *EnableAlarmResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnableAlarmResponse{}
	_body, _err := client.EnableAlarmWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to enable a scaling group that is in the Inactive state and has an instance configuration source. The instance configuration source can be a scaling configuration, a launch template, or an Elastic Compute Service (ECS) instance that you specified when you created the scaling group. If a scaling group is not in the Inactive state or does not have an active instance configuration source, you cannot call this operation to enable the scaling group.
 * > A scaling group can have only one active instance configuration source. When you call this operation to enable a scaling group, you can specify a scaling configuration or a launch template for the scaling group. If an instance configuration source has been configured for the scaling group before you call this operation, the scaling configuration or launch template that you specify in the request overwrites the original scaling configuration or launch template.
 * If you specify a value for the InstanceIds parameter when you call the operation, Auto Scaling checks whether the total number of ECS instances is within the range allowed in the scaling group after you call the operation.
 * *   If the total number of ECS instances is less than the minimum number of instances required in the scaling group after you call the operation, Auto Scaling automatically creates the required number of pay-as-you-go ECS instances and adds the instances to the scaling group to reach the minimum number. For example, if the minimum number of instances required in your scaling group is five, and you specify the InstanceIds parameter to add two ECS instances to the scaling group, Auto Scaling automatically creates three instances in the scaling group after the two instances are added.
 * *   If the value of the TotalCapacity parameter is greater than the value of the MaxSize parameter, the call fails.
 *
 * @param request EnableScalingGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableScalingGroupResponse
 */
func (client *Client) EnableScalingGroupWithOptions(request *EnableScalingGroupRequest, runtime *util.RuntimeOptions) (_result *EnableScalingGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ActiveScalingConfigurationId)) {
		query["ActiveScalingConfigurationId"] = request.ActiveScalingConfigurationId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchTemplateId)) {
		query["LaunchTemplateId"] = request.LaunchTemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchTemplateOverrides)) {
		query["LaunchTemplateOverrides"] = request.LaunchTemplateOverrides
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchTemplateVersion)) {
		query["LaunchTemplateVersion"] = request.LaunchTemplateVersion
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerWeights)) {
		query["LoadBalancerWeights"] = request.LoadBalancerWeights
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableScalingGroup"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableScalingGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to enable a scaling group that is in the Inactive state and has an instance configuration source. The instance configuration source can be a scaling configuration, a launch template, or an Elastic Compute Service (ECS) instance that you specified when you created the scaling group. If a scaling group is not in the Inactive state or does not have an active instance configuration source, you cannot call this operation to enable the scaling group.
 * > A scaling group can have only one active instance configuration source. When you call this operation to enable a scaling group, you can specify a scaling configuration or a launch template for the scaling group. If an instance configuration source has been configured for the scaling group before you call this operation, the scaling configuration or launch template that you specify in the request overwrites the original scaling configuration or launch template.
 * If you specify a value for the InstanceIds parameter when you call the operation, Auto Scaling checks whether the total number of ECS instances is within the range allowed in the scaling group after you call the operation.
 * *   If the total number of ECS instances is less than the minimum number of instances required in the scaling group after you call the operation, Auto Scaling automatically creates the required number of pay-as-you-go ECS instances and adds the instances to the scaling group to reach the minimum number. For example, if the minimum number of instances required in your scaling group is five, and you specify the InstanceIds parameter to add two ECS instances to the scaling group, Auto Scaling automatically creates three instances in the scaling group after the two instances are added.
 * *   If the value of the TotalCapacity parameter is greater than the value of the MaxSize parameter, the call fails.
 *
 * @param request EnableScalingGroupRequest
 * @return EnableScalingGroupResponse
 */
func (client *Client) EnableScalingGroup(request *EnableScalingGroupRequest) (_result *EnableScalingGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnableScalingGroupResponse{}
	_body, _err := client.EnableScalingGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EnterStandbyWithOptions(request *EnterStandbyRequest, runtime *util.RuntimeOptions) (_result *EnterStandbyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Async)) {
		query["Async"] = request.Async
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnterStandby"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnterStandbyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EnterStandby(request *EnterStandbyRequest) (_result *EnterStandbyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnterStandbyResponse{}
	_body, _err := client.EnterStandbyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this operation, take note of the following items:
 * *   The scaling group is in the Active state.
 * *   No scaling activities in the scaling group are in progress.
 * If no scaling activities in the scaling group are in progress, the operation can trigger scaling activities even before the cooldown time expires.
 * A successful call indicates that Auto Scaling accepts the request. However, the scaling activity may still fail. You can obtain the status of a scaling activity by using the value of the ScalingActivityId parameter in the response.
 * If the addition of a specified number of Elastic Compute Service (ECS) instances to a scaling group causes the total number of ECS instances in the scaling group to exceed the maximum number of instances allowed, Auto Scaling adds only a specific number of ECS instances to ensure that the total number of instances is equal to the maximum number of instances.
 * If the removal of a specified number of ECS instances from a scaling group causes the total number of ECS instances in the scaling group to drop below the minimum number of instances allowed, Auto Scaling removes only a specific number of ECS instances to ensure that the total number of instances is equal to the minimum number of instances.
 * You can specify only a limited number of ECS instances in each adjustment. For more information, see the description of the AdjustmentValue parameter in the CreateScalingRule topic.
 *
 * @param request ExecuteScalingRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExecuteScalingRuleResponse
 */
func (client *Client) ExecuteScalingRuleWithOptions(request *ExecuteScalingRuleRequest, runtime *util.RuntimeOptions) (_result *ExecuteScalingRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BreachThreshold)) {
		query["BreachThreshold"] = request.BreachThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.MetricValue)) {
		query["MetricValue"] = request.MetricValue
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleAri)) {
		query["ScalingRuleAri"] = request.ScalingRuleAri
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ExecuteScalingRule"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ExecuteScalingRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this operation, take note of the following items:
 * *   The scaling group is in the Active state.
 * *   No scaling activities in the scaling group are in progress.
 * If no scaling activities in the scaling group are in progress, the operation can trigger scaling activities even before the cooldown time expires.
 * A successful call indicates that Auto Scaling accepts the request. However, the scaling activity may still fail. You can obtain the status of a scaling activity by using the value of the ScalingActivityId parameter in the response.
 * If the addition of a specified number of Elastic Compute Service (ECS) instances to a scaling group causes the total number of ECS instances in the scaling group to exceed the maximum number of instances allowed, Auto Scaling adds only a specific number of ECS instances to ensure that the total number of instances is equal to the maximum number of instances.
 * If the removal of a specified number of ECS instances from a scaling group causes the total number of ECS instances in the scaling group to drop below the minimum number of instances allowed, Auto Scaling removes only a specific number of ECS instances to ensure that the total number of instances is equal to the minimum number of instances.
 * You can specify only a limited number of ECS instances in each adjustment. For more information, see the description of the AdjustmentValue parameter in the CreateScalingRule topic.
 *
 * @param request ExecuteScalingRuleRequest
 * @return ExecuteScalingRuleResponse
 */
func (client *Client) ExecuteScalingRule(request *ExecuteScalingRuleRequest) (_result *ExecuteScalingRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ExecuteScalingRuleResponse{}
	_body, _err := client.ExecuteScalingRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ExitStandbyWithOptions(request *ExitStandbyRequest, runtime *util.RuntimeOptions) (_result *ExitStandbyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Async)) {
		query["Async"] = request.Async
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ExitStandby"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ExitStandbyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ExitStandby(request *ExitStandbyRequest) (_result *ExitStandbyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ExitStandbyResponse{}
	_body, _err := client.ExitStandbyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTagKeysWithOptions(request *ListTagKeysRequest, runtime *util.RuntimeOptions) (_result *ListTagKeysResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTagKeys"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTagKeysResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTagKeys(request *ListTagKeysRequest) (_result *ListTagKeysResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTagKeysResponse{}
	_body, _err := client.ListTagKeysWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTagResourcesWithOptions(request *ListTagResourcesRequest, runtime *util.RuntimeOptions) (_result *ListTagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceIds)) {
		query["ResourceIds"] = request.ResourceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTagResources"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTagResources(request *ListTagResourcesRequest) (_result *ListTagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.ListTagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTagValuesWithOptions(request *ListTagValuesRequest, runtime *util.RuntimeOptions) (_result *ListTagValuesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Key)) {
		query["Key"] = request.Key
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTagValues"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTagValuesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTagValues(request *ListTagValuesRequest) (_result *ListTagValuesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTagValuesResponse{}
	_body, _err := client.ListTagValuesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If you set MetricType to custom, you must report your custom metrics to CloudMonitor before you can create event-triggered tasks by using the custom metrics. For more information, see [Custom monitoring event-triggered tasks](~~74861~~).
 * *   When you create an event-triggered task, you must specify MetricName, DimensionKey, and DimensionValue to determine the range of statistics that you want to aggregate for the metrics of the scaling group. For example, you can specify the user_id and scaling_group dimensions for an event-triggered task to aggregate monitoring data of all Elastic Compute Service (ECS) instances in a scaling group within an Alibaba Cloud account.
 *     *   If you set MetricType to custom, the valid values are your custom metrics.
 *     *   For information about the metrics that are supported if you set MetricType to system, see [Event-triggered task for system monitoring](~~74854~~).
 * > The user_id and scaling_group dimensions are automatically populated. You need to only specify the device and state dimensions. For more information, see `DimensionKey` and `DimensionValue` in the "Request parameters" section of this topic.
 *
 * @param request ModifyAlarmRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAlarmResponse
 */
func (client *Client) ModifyAlarmWithOptions(request *ModifyAlarmRequest, runtime *util.RuntimeOptions) (_result *ModifyAlarmResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlarmActions)) {
		query["AlarmActions"] = request.AlarmActions
	}

	if !tea.BoolValue(util.IsUnset(request.AlarmTaskId)) {
		query["AlarmTaskId"] = request.AlarmTaskId
	}

	if !tea.BoolValue(util.IsUnset(request.ComparisonOperator)) {
		query["ComparisonOperator"] = request.ComparisonOperator
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Dimensions)) {
		query["Dimensions"] = request.Dimensions
	}

	if !tea.BoolValue(util.IsUnset(request.Effective)) {
		query["Effective"] = request.Effective
	}

	if !tea.BoolValue(util.IsUnset(request.EvaluationCount)) {
		query["EvaluationCount"] = request.EvaluationCount
	}

	if !tea.BoolValue(util.IsUnset(request.Expressions)) {
		query["Expressions"] = request.Expressions
	}

	if !tea.BoolValue(util.IsUnset(request.ExpressionsLogicOperator)) {
		query["ExpressionsLogicOperator"] = request.ExpressionsLogicOperator
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.MetricName)) {
		query["MetricName"] = request.MetricName
	}

	if !tea.BoolValue(util.IsUnset(request.MetricType)) {
		query["MetricType"] = request.MetricType
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.Statistics)) {
		query["Statistics"] = request.Statistics
	}

	if !tea.BoolValue(util.IsUnset(request.Threshold)) {
		query["Threshold"] = request.Threshold
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyAlarm"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyAlarmResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If you set MetricType to custom, you must report your custom metrics to CloudMonitor before you can create event-triggered tasks by using the custom metrics. For more information, see [Custom monitoring event-triggered tasks](~~74861~~).
 * *   When you create an event-triggered task, you must specify MetricName, DimensionKey, and DimensionValue to determine the range of statistics that you want to aggregate for the metrics of the scaling group. For example, you can specify the user_id and scaling_group dimensions for an event-triggered task to aggregate monitoring data of all Elastic Compute Service (ECS) instances in a scaling group within an Alibaba Cloud account.
 *     *   If you set MetricType to custom, the valid values are your custom metrics.
 *     *   For information about the metrics that are supported if you set MetricType to system, see [Event-triggered task for system monitoring](~~74854~~).
 * > The user_id and scaling_group dimensions are automatically populated. You need to only specify the device and state dimensions. For more information, see `DimensionKey` and `DimensionValue` in the "Request parameters" section of this topic.
 *
 * @param request ModifyAlarmRequest
 * @return ModifyAlarmResponse
 */
func (client *Client) ModifyAlarm(request *ModifyAlarmRequest) (_result *ModifyAlarmResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyAlarmResponse{}
	_body, _err := client.ModifyAlarmWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If you want to change the name of a scaling configuration in a scaling group, make sure that the new name is unique within the scaling group.
 *
 * @param request ModifyEciScalingConfigurationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyEciScalingConfigurationResponse
 */
func (client *Client) ModifyEciScalingConfigurationWithOptions(request *ModifyEciScalingConfigurationRequest, runtime *util.RuntimeOptions) (_result *ModifyEciScalingConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcrRegistryInfos)) {
		query["AcrRegistryInfos"] = request.AcrRegistryInfos
	}

	if !tea.BoolValue(util.IsUnset(request.ActiveDeadlineSeconds)) {
		query["ActiveDeadlineSeconds"] = request.ActiveDeadlineSeconds
	}

	if !tea.BoolValue(util.IsUnset(request.AutoCreateEip)) {
		query["AutoCreateEip"] = request.AutoCreateEip
	}

	if !tea.BoolValue(util.IsUnset(request.AutoMatchImageCache)) {
		query["AutoMatchImageCache"] = request.AutoMatchImageCache
	}

	if !tea.BoolValue(util.IsUnset(request.ContainerGroupName)) {
		query["ContainerGroupName"] = request.ContainerGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.Containers)) {
		query["Containers"] = request.Containers
	}

	if !tea.BoolValue(util.IsUnset(request.ContainersUpdateType)) {
		query["ContainersUpdateType"] = request.ContainersUpdateType
	}

	if !tea.BoolValue(util.IsUnset(request.CostOptimization)) {
		query["CostOptimization"] = request.CostOptimization
	}

	if !tea.BoolValue(util.IsUnset(request.Cpu)) {
		query["Cpu"] = request.Cpu
	}

	if !tea.BoolValue(util.IsUnset(request.CpuOptionsCore)) {
		query["CpuOptionsCore"] = request.CpuOptionsCore
	}

	if !tea.BoolValue(util.IsUnset(request.CpuOptionsThreadsPerCore)) {
		query["CpuOptionsThreadsPerCore"] = request.CpuOptionsThreadsPerCore
	}

	if !tea.BoolValue(util.IsUnset(request.DataCacheBucket)) {
		query["DataCacheBucket"] = request.DataCacheBucket
	}

	if !tea.BoolValue(util.IsUnset(request.DataCacheBurstingEnabled)) {
		query["DataCacheBurstingEnabled"] = request.DataCacheBurstingEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.DataCachePL)) {
		query["DataCachePL"] = request.DataCachePL
	}

	if !tea.BoolValue(util.IsUnset(request.DataCacheProvisionedIops)) {
		query["DataCacheProvisionedIops"] = request.DataCacheProvisionedIops
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DnsConfigNameServers)) {
		query["DnsConfigNameServers"] = request.DnsConfigNameServers
	}

	if !tea.BoolValue(util.IsUnset(request.DnsConfigOptions)) {
		query["DnsConfigOptions"] = request.DnsConfigOptions
	}

	if !tea.BoolValue(util.IsUnset(request.DnsConfigSearchs)) {
		query["DnsConfigSearchs"] = request.DnsConfigSearchs
	}

	if !tea.BoolValue(util.IsUnset(request.DnsPolicy)) {
		query["DnsPolicy"] = request.DnsPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.EgressBandwidth)) {
		query["EgressBandwidth"] = request.EgressBandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.EipBandwidth)) {
		query["EipBandwidth"] = request.EipBandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.EnableSls)) {
		query["EnableSls"] = request.EnableSls
	}

	if !tea.BoolValue(util.IsUnset(request.EphemeralStorage)) {
		query["EphemeralStorage"] = request.EphemeralStorage
	}

	if !tea.BoolValue(util.IsUnset(request.HostAliases)) {
		query["HostAliases"] = request.HostAliases
	}

	if !tea.BoolValue(util.IsUnset(request.HostName)) {
		query["HostName"] = request.HostName
	}

	if !tea.BoolValue(util.IsUnset(request.ImageRegistryCredentials)) {
		query["ImageRegistryCredentials"] = request.ImageRegistryCredentials
	}

	if !tea.BoolValue(util.IsUnset(request.ImageSnapshotId)) {
		query["ImageSnapshotId"] = request.ImageSnapshotId
	}

	if !tea.BoolValue(util.IsUnset(request.IngressBandwidth)) {
		query["IngressBandwidth"] = request.IngressBandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.InitContainers)) {
		query["InitContainers"] = request.InitContainers
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceFamilyLevel)) {
		query["InstanceFamilyLevel"] = request.InstanceFamilyLevel
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceTypes)) {
		query["InstanceTypes"] = request.InstanceTypes
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6AddressCount)) {
		query["Ipv6AddressCount"] = request.Ipv6AddressCount
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerWeight)) {
		query["LoadBalancerWeight"] = request.LoadBalancerWeight
	}

	if !tea.BoolValue(util.IsUnset(request.Memory)) {
		query["Memory"] = request.Memory
	}

	if !tea.BoolValue(util.IsUnset(request.NtpServers)) {
		query["NtpServers"] = request.NtpServers
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RamRoleName)) {
		query["RamRoleName"] = request.RamRoleName
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.RestartPolicy)) {
		query["RestartPolicy"] = request.RestartPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationId)) {
		query["ScalingConfigurationId"] = request.ScalingConfigurationId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationName)) {
		query["ScalingConfigurationName"] = request.ScalingConfigurationName
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityContextSysCtls)) {
		query["SecurityContextSysCtls"] = request.SecurityContextSysCtls
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityGroupId)) {
		query["SecurityGroupId"] = request.SecurityGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SpotPriceLimit)) {
		query["SpotPriceLimit"] = request.SpotPriceLimit
	}

	if !tea.BoolValue(util.IsUnset(request.SpotStrategy)) {
		query["SpotStrategy"] = request.SpotStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.TerminationGracePeriodSeconds)) {
		query["TerminationGracePeriodSeconds"] = request.TerminationGracePeriodSeconds
	}

	if !tea.BoolValue(util.IsUnset(request.Volumes)) {
		query["Volumes"] = request.Volumes
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyEciScalingConfiguration"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyEciScalingConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If you want to change the name of a scaling configuration in a scaling group, make sure that the new name is unique within the scaling group.
 *
 * @param request ModifyEciScalingConfigurationRequest
 * @return ModifyEciScalingConfigurationResponse
 */
func (client *Client) ModifyEciScalingConfiguration(request *ModifyEciScalingConfigurationRequest) (_result *ModifyEciScalingConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyEciScalingConfigurationResponse{}
	_body, _err := client.ModifyEciScalingConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can use one of the following methods to specify the lifecycle hook that you want to modify:
 * *   Specify the lifecycle hook ID by using the LifecycleHookId parameter. When you use this method, the ScalingGroupId and LifecycleHookName parameters are ignored.
 * *   Specify the scaling group ID by using the ScalingGroupId parameter and specify the lifecycle hook name by using the LifecycleHookName parameter.
 *
 * @param request ModifyLifecycleHookRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyLifecycleHookResponse
 */
func (client *Client) ModifyLifecycleHookWithOptions(request *ModifyLifecycleHookRequest, runtime *util.RuntimeOptions) (_result *ModifyLifecycleHookResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DefaultResult)) {
		query["DefaultResult"] = request.DefaultResult
	}

	if !tea.BoolValue(util.IsUnset(request.HeartbeatTimeout)) {
		query["HeartbeatTimeout"] = request.HeartbeatTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleHookId)) {
		query["LifecycleHookId"] = request.LifecycleHookId
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleHookName)) {
		query["LifecycleHookName"] = request.LifecycleHookName
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleHookStatus)) {
		query["LifecycleHookStatus"] = request.LifecycleHookStatus
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleTransition)) {
		query["LifecycleTransition"] = request.LifecycleTransition
	}

	if !tea.BoolValue(util.IsUnset(request.NotificationArn)) {
		query["NotificationArn"] = request.NotificationArn
	}

	if !tea.BoolValue(util.IsUnset(request.NotificationMetadata)) {
		query["NotificationMetadata"] = request.NotificationMetadata
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyLifecycleHook"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyLifecycleHookResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can use one of the following methods to specify the lifecycle hook that you want to modify:
 * *   Specify the lifecycle hook ID by using the LifecycleHookId parameter. When you use this method, the ScalingGroupId and LifecycleHookName parameters are ignored.
 * *   Specify the scaling group ID by using the ScalingGroupId parameter and specify the lifecycle hook name by using the LifecycleHookName parameter.
 *
 * @param request ModifyLifecycleHookRequest
 * @return ModifyLifecycleHookResponse
 */
func (client *Client) ModifyLifecycleHook(request *ModifyLifecycleHookRequest) (_result *ModifyLifecycleHookResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyLifecycleHookResponse{}
	_body, _err := client.ModifyLifecycleHookWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyNotificationConfigurationWithOptions(request *ModifyNotificationConfigurationRequest, runtime *util.RuntimeOptions) (_result *ModifyNotificationConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NotificationArn)) {
		query["NotificationArn"] = request.NotificationArn
	}

	if !tea.BoolValue(util.IsUnset(request.NotificationTypes)) {
		query["NotificationTypes"] = request.NotificationTypes
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyNotificationConfiguration"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyNotificationConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyNotificationConfiguration(request *ModifyNotificationConfigurationRequest) (_result *ModifyNotificationConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyNotificationConfigurationResponse{}
	_body, _err := client.ModifyNotificationConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can change the name of a scaling configuration in a scaling group. The name must be unique within the scaling group.
 *
 * @param tmpReq ModifyScalingConfigurationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyScalingConfigurationResponse
 */
func (client *Client) ModifyScalingConfigurationWithOptions(tmpReq *ModifyScalingConfigurationRequest, runtime *util.RuntimeOptions) (_result *ModifyScalingConfigurationResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ModifyScalingConfigurationShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.SchedulerOptions)) {
		request.SchedulerOptionsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.SchedulerOptions, tea.String("SchedulerOptions"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Affinity)) {
		query["Affinity"] = request.Affinity
	}

	if !tea.BoolValue(util.IsUnset(request.Cpu)) {
		query["Cpu"] = request.Cpu
	}

	if !tea.BoolValue(util.IsUnset(request.CreditSpecification)) {
		query["CreditSpecification"] = request.CreditSpecification
	}

	if !tea.BoolValue(util.IsUnset(request.DataDisks)) {
		query["DataDisks"] = request.DataDisks
	}

	if !tea.BoolValue(util.IsUnset(request.DedicatedHostId)) {
		query["DedicatedHostId"] = request.DedicatedHostId
	}

	if !tea.BoolValue(util.IsUnset(request.DeletionProtection)) {
		query["DeletionProtection"] = request.DeletionProtection
	}

	if !tea.BoolValue(util.IsUnset(request.DeploymentSetId)) {
		query["DeploymentSetId"] = request.DeploymentSetId
	}

	if !tea.BoolValue(util.IsUnset(request.HostName)) {
		query["HostName"] = request.HostName
	}

	if !tea.BoolValue(util.IsUnset(request.HpcClusterId)) {
		query["HpcClusterId"] = request.HpcClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ImageFamily)) {
		query["ImageFamily"] = request.ImageFamily
	}

	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.ImageName)) {
		query["ImageName"] = request.ImageName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceDescription)) {
		query["InstanceDescription"] = request.InstanceDescription
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceName)) {
		query["InstanceName"] = request.InstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.InstancePatternInfos)) {
		query["InstancePatternInfos"] = request.InstancePatternInfos
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceTypeOverrides)) {
		query["InstanceTypeOverrides"] = request.InstanceTypeOverrides
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceTypes)) {
		query["InstanceTypes"] = request.InstanceTypes
	}

	if !tea.BoolValue(util.IsUnset(request.InternetChargeType)) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.InternetMaxBandwidthOut)) {
		query["InternetMaxBandwidthOut"] = request.InternetMaxBandwidthOut
	}

	if !tea.BoolValue(util.IsUnset(request.IoOptimized)) {
		query["IoOptimized"] = request.IoOptimized
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6AddressCount)) {
		query["Ipv6AddressCount"] = request.Ipv6AddressCount
	}

	if !tea.BoolValue(util.IsUnset(request.KeyPairName)) {
		query["KeyPairName"] = request.KeyPairName
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerWeight)) {
		query["LoadBalancerWeight"] = request.LoadBalancerWeight
	}

	if !tea.BoolValue(util.IsUnset(request.Memory)) {
		query["Memory"] = request.Memory
	}

	if !tea.BoolValue(util.IsUnset(request.Override)) {
		query["Override"] = request.Override
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PasswordInherit)) {
		query["PasswordInherit"] = request.PasswordInherit
	}

	if !tea.BoolValue(util.IsUnset(request.RamRoleName)) {
		query["RamRoleName"] = request.RamRoleName
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationId)) {
		query["ScalingConfigurationId"] = request.ScalingConfigurationId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationName)) {
		query["ScalingConfigurationName"] = request.ScalingConfigurationName
	}

	if !tea.BoolValue(util.IsUnset(request.SchedulerOptionsShrink)) {
		query["SchedulerOptions"] = request.SchedulerOptionsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityGroupId)) {
		query["SecurityGroupId"] = request.SecurityGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityGroupIds)) {
		query["SecurityGroupIds"] = request.SecurityGroupIds
	}

	if !tea.BoolValue(util.IsUnset(request.SpotDuration)) {
		query["SpotDuration"] = request.SpotDuration
	}

	if !tea.BoolValue(util.IsUnset(request.SpotInterruptionBehavior)) {
		query["SpotInterruptionBehavior"] = request.SpotInterruptionBehavior
	}

	if !tea.BoolValue(util.IsUnset(request.SpotPriceLimits)) {
		query["SpotPriceLimits"] = request.SpotPriceLimits
	}

	if !tea.BoolValue(util.IsUnset(request.SpotStrategy)) {
		query["SpotStrategy"] = request.SpotStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.StorageSetId)) {
		query["StorageSetId"] = request.StorageSetId
	}

	if !tea.BoolValue(util.IsUnset(request.StorageSetPartitionNumber)) {
		query["StorageSetPartitionNumber"] = request.StorageSetPartitionNumber
	}

	if !tea.BoolValue(util.IsUnset(request.SystemDiskCategories)) {
		query["SystemDiskCategories"] = request.SystemDiskCategories
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.Tenancy)) {
		query["Tenancy"] = request.Tenancy
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	if !tea.BoolValue(util.IsUnset(request.ImageOptions)) {
		query["ImageOptions"] = request.ImageOptions
	}

	if !tea.BoolValue(util.IsUnset(request.PrivatePoolOptions)) {
		query["PrivatePoolOptions"] = request.PrivatePoolOptions
	}

	if !tea.BoolValue(util.IsUnset(request.SystemDisk)) {
		query["SystemDisk"] = request.SystemDisk
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyScalingConfiguration"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyScalingConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can change the name of a scaling configuration in a scaling group. The name must be unique within the scaling group.
 *
 * @param request ModifyScalingConfigurationRequest
 * @return ModifyScalingConfigurationResponse
 */
func (client *Client) ModifyScalingConfiguration(request *ModifyScalingConfigurationRequest) (_result *ModifyScalingConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyScalingConfigurationResponse{}
	_body, _err := client.ModifyScalingConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyScalingGroupWithOptions(request *ModifyScalingGroupRequest, runtime *util.RuntimeOptions) (_result *ModifyScalingGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ActiveScalingConfigurationId)) {
		query["ActiveScalingConfigurationId"] = request.ActiveScalingConfigurationId
	}

	if !tea.BoolValue(util.IsUnset(request.AllocationStrategy)) {
		query["AllocationStrategy"] = request.AllocationStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.AzBalance)) {
		query["AzBalance"] = request.AzBalance
	}

	if !tea.BoolValue(util.IsUnset(request.CompensateWithOnDemand)) {
		query["CompensateWithOnDemand"] = request.CompensateWithOnDemand
	}

	if !tea.BoolValue(util.IsUnset(request.CustomPolicyARN)) {
		query["CustomPolicyARN"] = request.CustomPolicyARN
	}

	if !tea.BoolValue(util.IsUnset(request.DefaultCooldown)) {
		query["DefaultCooldown"] = request.DefaultCooldown
	}

	if !tea.BoolValue(util.IsUnset(request.DesiredCapacity)) {
		query["DesiredCapacity"] = request.DesiredCapacity
	}

	if !tea.BoolValue(util.IsUnset(request.DisableDesiredCapacity)) {
		query["DisableDesiredCapacity"] = request.DisableDesiredCapacity
	}

	if !tea.BoolValue(util.IsUnset(request.GroupDeletionProtection)) {
		query["GroupDeletionProtection"] = request.GroupDeletionProtection
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckType)) {
		query["HealthCheckType"] = request.HealthCheckType
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchTemplateId)) {
		query["LaunchTemplateId"] = request.LaunchTemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchTemplateOverrides)) {
		query["LaunchTemplateOverrides"] = request.LaunchTemplateOverrides
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchTemplateVersion)) {
		query["LaunchTemplateVersion"] = request.LaunchTemplateVersion
	}

	if !tea.BoolValue(util.IsUnset(request.MaxInstanceLifetime)) {
		query["MaxInstanceLifetime"] = request.MaxInstanceLifetime
	}

	if !tea.BoolValue(util.IsUnset(request.MaxSize)) {
		query["MaxSize"] = request.MaxSize
	}

	if !tea.BoolValue(util.IsUnset(request.MinSize)) {
		query["MinSize"] = request.MinSize
	}

	if !tea.BoolValue(util.IsUnset(request.MultiAZPolicy)) {
		query["MultiAZPolicy"] = request.MultiAZPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.OnDemandBaseCapacity)) {
		query["OnDemandBaseCapacity"] = request.OnDemandBaseCapacity
	}

	if !tea.BoolValue(util.IsUnset(request.OnDemandPercentageAboveBaseCapacity)) {
		query["OnDemandPercentageAboveBaseCapacity"] = request.OnDemandPercentageAboveBaseCapacity
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RemovalPolicies)) {
		query["RemovalPolicies"] = request.RemovalPolicies
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupName)) {
		query["ScalingGroupName"] = request.ScalingGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.SpotAllocationStrategy)) {
		query["SpotAllocationStrategy"] = request.SpotAllocationStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.SpotInstancePools)) {
		query["SpotInstancePools"] = request.SpotInstancePools
	}

	if !tea.BoolValue(util.IsUnset(request.SpotInstanceRemedy)) {
		query["SpotInstanceRemedy"] = request.SpotInstanceRemedy
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchIds)) {
		query["VSwitchIds"] = request.VSwitchIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyScalingGroup"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyScalingGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyScalingGroup(request *ModifyScalingGroupRequest) (_result *ModifyScalingGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyScalingGroupResponse{}
	_body, _err := client.ModifyScalingGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyScalingRuleWithOptions(request *ModifyScalingRuleRequest, runtime *util.RuntimeOptions) (_result *ModifyScalingRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AdjustmentType)) {
		query["AdjustmentType"] = request.AdjustmentType
	}

	if !tea.BoolValue(util.IsUnset(request.AdjustmentValue)) {
		query["AdjustmentValue"] = request.AdjustmentValue
	}

	if !tea.BoolValue(util.IsUnset(request.AlarmDimensions)) {
		query["AlarmDimensions"] = request.AlarmDimensions
	}

	if !tea.BoolValue(util.IsUnset(request.Cooldown)) {
		query["Cooldown"] = request.Cooldown
	}

	if !tea.BoolValue(util.IsUnset(request.DisableScaleIn)) {
		query["DisableScaleIn"] = request.DisableScaleIn
	}

	if !tea.BoolValue(util.IsUnset(request.EstimatedInstanceWarmup)) {
		query["EstimatedInstanceWarmup"] = request.EstimatedInstanceWarmup
	}

	if !tea.BoolValue(util.IsUnset(request.InitialMaxSize)) {
		query["InitialMaxSize"] = request.InitialMaxSize
	}

	if !tea.BoolValue(util.IsUnset(request.MetricName)) {
		query["MetricName"] = request.MetricName
	}

	if !tea.BoolValue(util.IsUnset(request.MinAdjustmentMagnitude)) {
		query["MinAdjustmentMagnitude"] = request.MinAdjustmentMagnitude
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PredictiveScalingMode)) {
		query["PredictiveScalingMode"] = request.PredictiveScalingMode
	}

	if !tea.BoolValue(util.IsUnset(request.PredictiveTaskBufferTime)) {
		query["PredictiveTaskBufferTime"] = request.PredictiveTaskBufferTime
	}

	if !tea.BoolValue(util.IsUnset(request.PredictiveValueBehavior)) {
		query["PredictiveValueBehavior"] = request.PredictiveValueBehavior
	}

	if !tea.BoolValue(util.IsUnset(request.PredictiveValueBuffer)) {
		query["PredictiveValueBuffer"] = request.PredictiveValueBuffer
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScaleInEvaluationCount)) {
		query["ScaleInEvaluationCount"] = request.ScaleInEvaluationCount
	}

	if !tea.BoolValue(util.IsUnset(request.ScaleOutEvaluationCount)) {
		query["ScaleOutEvaluationCount"] = request.ScaleOutEvaluationCount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleId)) {
		query["ScalingRuleId"] = request.ScalingRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleName)) {
		query["ScalingRuleName"] = request.ScalingRuleName
	}

	if !tea.BoolValue(util.IsUnset(request.StepAdjustments)) {
		query["StepAdjustments"] = request.StepAdjustments
	}

	if !tea.BoolValue(util.IsUnset(request.TargetValue)) {
		query["TargetValue"] = request.TargetValue
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyScalingRule"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyScalingRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyScalingRule(request *ModifyScalingRuleRequest) (_result *ModifyScalingRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyScalingRuleResponse{}
	_body, _err := client.ModifyScalingRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can use the following parameters to specify the scaling method of a scheduled task:
 * *   If you use the `ScheduledAction` parameter, you must select an existing scaling rule for the scheduled task.
 * *   If you use the `ScalingGroupId` parameter, you must specify the minimum number, maximum number, or expected number of instances in the scheduled task.
 * > You cannot specify the `ScheduledAction` and `ScalingGroupId` parameters at the same time.
 *
 * @param request ModifyScheduledTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyScheduledTaskResponse
 */
func (client *Client) ModifyScheduledTaskWithOptions(request *ModifyScheduledTaskRequest, runtime *util.RuntimeOptions) (_result *ModifyScheduledTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DesiredCapacity)) {
		query["DesiredCapacity"] = request.DesiredCapacity
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchExpirationTime)) {
		query["LaunchExpirationTime"] = request.LaunchExpirationTime
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchTime)) {
		query["LaunchTime"] = request.LaunchTime
	}

	if !tea.BoolValue(util.IsUnset(request.MaxValue)) {
		query["MaxValue"] = request.MaxValue
	}

	if !tea.BoolValue(util.IsUnset(request.MinValue)) {
		query["MinValue"] = request.MinValue
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RecurrenceEndTime)) {
		query["RecurrenceEndTime"] = request.RecurrenceEndTime
	}

	if !tea.BoolValue(util.IsUnset(request.RecurrenceType)) {
		query["RecurrenceType"] = request.RecurrenceType
	}

	if !tea.BoolValue(util.IsUnset(request.RecurrenceValue)) {
		query["RecurrenceValue"] = request.RecurrenceValue
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduledAction)) {
		query["ScheduledAction"] = request.ScheduledAction
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduledTaskId)) {
		query["ScheduledTaskId"] = request.ScheduledTaskId
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduledTaskName)) {
		query["ScheduledTaskName"] = request.ScheduledTaskName
	}

	if !tea.BoolValue(util.IsUnset(request.TaskEnabled)) {
		query["TaskEnabled"] = request.TaskEnabled
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyScheduledTask"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyScheduledTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can use the following parameters to specify the scaling method of a scheduled task:
 * *   If you use the `ScheduledAction` parameter, you must select an existing scaling rule for the scheduled task.
 * *   If you use the `ScalingGroupId` parameter, you must specify the minimum number, maximum number, or expected number of instances in the scheduled task.
 * > You cannot specify the `ScheduledAction` and `ScalingGroupId` parameters at the same time.
 *
 * @param request ModifyScheduledTaskRequest
 * @return ModifyScheduledTaskResponse
 */
func (client *Client) ModifyScheduledTask(request *ModifyScheduledTaskRequest) (_result *ModifyScheduledTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyScheduledTaskResponse{}
	_body, _err := client.ModifyScheduledTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RebalanceInstancesWithOptions(request *RebalanceInstancesRequest, runtime *util.RuntimeOptions) (_result *RebalanceInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RebalanceInstances"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RebalanceInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RebalanceInstances(request *RebalanceInstancesRequest) (_result *RebalanceInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RebalanceInstancesResponse{}
	_body, _err := client.RebalanceInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to prolong the length of a lifecycle hook up to 20 times. Take note that the total length of a lifecycle hook cannot exceed 6 hours.
 *
 * @param request RecordLifecycleActionHeartbeatRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RecordLifecycleActionHeartbeatResponse
 */
func (client *Client) RecordLifecycleActionHeartbeatWithOptions(request *RecordLifecycleActionHeartbeatRequest, runtime *util.RuntimeOptions) (_result *RecordLifecycleActionHeartbeatResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.HeartbeatTimeout)) {
		query["heartbeatTimeout"] = request.HeartbeatTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleActionToken)) {
		query["lifecycleActionToken"] = request.LifecycleActionToken
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleHookId)) {
		query["lifecycleHookId"] = request.LifecycleHookId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RecordLifecycleActionHeartbeat"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RecordLifecycleActionHeartbeatResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to prolong the length of a lifecycle hook up to 20 times. Take note that the total length of a lifecycle hook cannot exceed 6 hours.
 *
 * @param request RecordLifecycleActionHeartbeatRequest
 * @return RecordLifecycleActionHeartbeatResponse
 */
func (client *Client) RecordLifecycleActionHeartbeat(request *RecordLifecycleActionHeartbeatRequest) (_result *RecordLifecycleActionHeartbeatResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RecordLifecycleActionHeartbeatResponse{}
	_body, _err := client.RecordLifecycleActionHeartbeatWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RemoveInstancesWithOptions(request *RemoveInstancesRequest, runtime *util.RuntimeOptions) (_result *RemoveInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DecreaseDesiredCapacity)) {
		query["DecreaseDesiredCapacity"] = request.DecreaseDesiredCapacity
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RemovePolicy)) {
		query["RemovePolicy"] = request.RemovePolicy
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveInstances"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RemoveInstances(request *RemoveInstancesRequest) (_result *RemoveInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveInstancesResponse{}
	_body, _err := client.RemoveInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ResumeProcessesWithOptions(request *ResumeProcessesRequest, runtime *util.RuntimeOptions) (_result *ResumeProcessesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Processes)) {
		query["Processes"] = request.Processes
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ResumeProcesses"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ResumeProcessesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ResumeProcesses(request *ResumeProcessesRequest) (_result *ResumeProcessesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ResumeProcessesResponse{}
	_body, _err := client.ResumeProcessesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Compared with the ExecuteScalingRule operation, the ScaleWithAdjustment operation does not require a scaling rule to be created in advance. Before you call the ScaleWithAdjustment operation, take note of the following items:
 * *   The following conditions must be met:
 *     *   The scaling group is in the Active state.
 *     *   No scaling activities in the scaling group are in progress.
 * *   If no scaling activities in the scaling group are in progress, the operation can trigger scaling activities even before the cooldown time expires.
 * *   If the addition of a specified number of Elastic Compute Service (ECS) instances to a scaling group causes the total number of ECS instances in the scaling group to exceed the maximum number of instances allowed, Auto Scaling adds only a specific number of ECS instances to ensure that the total number of instances is equal to the maximum number of instances.
 * *   If the removal of a specified number of ECS instances from a scaling group causes the total number of ECS instances in the scaling group to drop below the minimum number of instances allowed, Auto Scaling removes only a specific number of ECS instances to ensure that the total number of instances is equal to the minimum number of instances.
 * A successful call indicates that Auto Scaling accepts the request. However, the scaling activity may still fail. You can obtain the status of a scaling activity by using the value of the `ScalingActivityId` parameter in the response.
 *
 * @param request ScaleWithAdjustmentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ScaleWithAdjustmentResponse
 */
func (client *Client) ScaleWithAdjustmentWithOptions(request *ScaleWithAdjustmentRequest, runtime *util.RuntimeOptions) (_result *ScaleWithAdjustmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AdjustmentType)) {
		query["AdjustmentType"] = request.AdjustmentType
	}

	if !tea.BoolValue(util.IsUnset(request.AdjustmentValue)) {
		query["AdjustmentValue"] = request.AdjustmentValue
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.MinAdjustmentMagnitude)) {
		query["MinAdjustmentMagnitude"] = request.MinAdjustmentMagnitude
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SyncActivity)) {
		query["SyncActivity"] = request.SyncActivity
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ScaleWithAdjustment"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ScaleWithAdjustmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Compared with the ExecuteScalingRule operation, the ScaleWithAdjustment operation does not require a scaling rule to be created in advance. Before you call the ScaleWithAdjustment operation, take note of the following items:
 * *   The following conditions must be met:
 *     *   The scaling group is in the Active state.
 *     *   No scaling activities in the scaling group are in progress.
 * *   If no scaling activities in the scaling group are in progress, the operation can trigger scaling activities even before the cooldown time expires.
 * *   If the addition of a specified number of Elastic Compute Service (ECS) instances to a scaling group causes the total number of ECS instances in the scaling group to exceed the maximum number of instances allowed, Auto Scaling adds only a specific number of ECS instances to ensure that the total number of instances is equal to the maximum number of instances.
 * *   If the removal of a specified number of ECS instances from a scaling group causes the total number of ECS instances in the scaling group to drop below the minimum number of instances allowed, Auto Scaling removes only a specific number of ECS instances to ensure that the total number of instances is equal to the minimum number of instances.
 * A successful call indicates that Auto Scaling accepts the request. However, the scaling activity may still fail. You can obtain the status of a scaling activity by using the value of the `ScalingActivityId` parameter in the response.
 *
 * @param request ScaleWithAdjustmentRequest
 * @return ScaleWithAdjustmentResponse
 */
func (client *Client) ScaleWithAdjustment(request *ScaleWithAdjustmentRequest) (_result *ScaleWithAdjustmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ScaleWithAdjustmentResponse{}
	_body, _err := client.ScaleWithAdjustmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetGroupDeletionProtectionWithOptions(request *SetGroupDeletionProtectionRequest, runtime *util.RuntimeOptions) (_result *SetGroupDeletionProtectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupDeletionProtection)) {
		query["GroupDeletionProtection"] = request.GroupDeletionProtection
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetGroupDeletionProtection"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetGroupDeletionProtectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetGroupDeletionProtection(request *SetGroupDeletionProtectionRequest) (_result *SetGroupDeletionProtectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetGroupDeletionProtectionResponse{}
	_body, _err := client.SetGroupDeletionProtectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Configures the health check feature for Elastic Compute Service (ECS) instances.
 *
 * @param request SetInstanceHealthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetInstanceHealthResponse
 */
func (client *Client) SetInstanceHealthWithOptions(request *SetInstanceHealthRequest, runtime *util.RuntimeOptions) (_result *SetInstanceHealthResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.HealthStatus)) {
		query["HealthStatus"] = request.HealthStatus
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetInstanceHealth"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetInstanceHealthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Configures the health check feature for Elastic Compute Service (ECS) instances.
 *
 * @param request SetInstanceHealthRequest
 * @return SetInstanceHealthResponse
 */
func (client *Client) SetInstanceHealth(request *SetInstanceHealthRequest) (_result *SetInstanceHealthResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetInstanceHealthResponse{}
	_body, _err := client.SetInstanceHealthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Puts one or more Elastic Compute Service (ECS) instances into the Protected state.
 *
 * @param request SetInstancesProtectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetInstancesProtectionResponse
 */
func (client *Client) SetInstancesProtectionWithOptions(request *SetInstancesProtectionRequest, runtime *util.RuntimeOptions) (_result *SetInstancesProtectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProtectedFromScaleIn)) {
		query["ProtectedFromScaleIn"] = request.ProtectedFromScaleIn
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetInstancesProtection"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetInstancesProtectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Puts one or more Elastic Compute Service (ECS) instances into the Protected state.
 *
 * @param request SetInstancesProtectionRequest
 * @return SetInstancesProtectionResponse
 */
func (client *Client) SetInstancesProtection(request *SetInstancesProtectionRequest) (_result *SetInstancesProtectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetInstancesProtectionResponse{}
	_body, _err := client.SetInstancesProtectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SuspendProcessesWithOptions(request *SuspendProcessesRequest, runtime *util.RuntimeOptions) (_result *SuspendProcessesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Processes)) {
		query["Processes"] = request.Processes
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SuspendProcesses"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SuspendProcessesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SuspendProcesses(request *SuspendProcessesRequest) (_result *SuspendProcessesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SuspendProcessesResponse{}
	_body, _err := client.SuspendProcessesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) TagResourcesWithOptions(request *TagResourcesRequest, runtime *util.RuntimeOptions) (_result *TagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceIds)) {
		query["ResourceIds"] = request.ResourceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TagResources"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) TagResources(request *TagResourcesRequest) (_result *TagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TagResourcesResponse{}
	_body, _err := client.TagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UntagResourcesWithOptions(request *UntagResourcesRequest, runtime *util.RuntimeOptions) (_result *UntagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.All)) {
		query["All"] = request.All
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceIds)) {
		query["ResourceIds"] = request.ResourceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TagKeys)) {
		query["TagKeys"] = request.TagKeys
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UntagResources"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UntagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UntagResources(request *UntagResourcesRequest) (_result *UntagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UntagResourcesResponse{}
	_body, _err := client.UntagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) VerifyAuthenticationWithOptions(request *VerifyAuthenticationRequest, runtime *util.RuntimeOptions) (_result *VerifyAuthenticationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OnlyCheck)) {
		query["OnlyCheck"] = request.OnlyCheck
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Uid)) {
		query["Uid"] = request.Uid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("VerifyAuthentication"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &VerifyAuthenticationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) VerifyAuthentication(request *VerifyAuthenticationRequest) (_result *VerifyAuthenticationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &VerifyAuthenticationResponse{}
	_body, _err := client.VerifyAuthenticationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) VerifyUserWithOptions(request *VerifyUserRequest, runtime *util.RuntimeOptions) (_result *VerifyUserResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("VerifyUser"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &VerifyUserResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) VerifyUser(request *VerifyUserRequest) (_result *VerifyUserResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &VerifyUserResponse{}
	_body, _err := client.VerifyUserWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
