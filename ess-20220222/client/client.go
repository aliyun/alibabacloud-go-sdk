// This file is auto-generated, don't edit it. Thanks.
/**
 *
 */
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	endpointutil "github.com/alibabacloud-go/endpoint-util/service"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
)

type AttachAlbServerGroupsRequest struct {
	// Details of the ALB server group.
	AlbServerGroups []*AttachAlbServerGroupsRequestAlbServerGroups `json:"AlbServerGroups,omitempty" xml:"AlbServerGroups,omitempty" type:"Repeated"`
	// Specifies whether to add the ECS instances in the scaling group to the ALB server group. Valid values:
	//
	// *   true: adds the ECS instances to the ALB server group and returns the value of the `ScalingActivityId` parameter. You can check whether the ECS instances are added to the ALB server group by using the ID of the scaling activity.
	// *   false: does not add the ECS instances to the ALB server group.
	//
	// Default value: false.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Details of the ALB server group.
	ForceAttach *bool  `json:"ForceAttach,omitempty" xml:"ForceAttach,omitempty"`
	OwnerId     *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request](~~25965~~).
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s AttachAlbServerGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachAlbServerGroupsRequest) GoString() string {
	return s.String()
}

func (s *AttachAlbServerGroupsRequest) SetAlbServerGroups(v []*AttachAlbServerGroupsRequestAlbServerGroups) *AttachAlbServerGroupsRequest {
	s.AlbServerGroups = v
	return s
}

func (s *AttachAlbServerGroupsRequest) SetClientToken(v string) *AttachAlbServerGroupsRequest {
	s.ClientToken = &v
	return s
}

func (s *AttachAlbServerGroupsRequest) SetForceAttach(v bool) *AttachAlbServerGroupsRequest {
	s.ForceAttach = &v
	return s
}

func (s *AttachAlbServerGroupsRequest) SetOwnerId(v int64) *AttachAlbServerGroupsRequest {
	s.OwnerId = &v
	return s
}

func (s *AttachAlbServerGroupsRequest) SetRegionId(v string) *AttachAlbServerGroupsRequest {
	s.RegionId = &v
	return s
}

func (s *AttachAlbServerGroupsRequest) SetResourceOwnerAccount(v string) *AttachAlbServerGroupsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AttachAlbServerGroupsRequest) SetScalingGroupId(v string) *AttachAlbServerGroupsRequest {
	s.ScalingGroupId = &v
	return s
}

type AttachAlbServerGroupsRequestAlbServerGroups struct {
	// The weight of the ECS instance as a backend server after the instance is added to the ALB server group.
	//
	// If you increase the weight of an ECS instance in an ALB server group, the number of access requests that are forwarded to the ECS instance increases. If you set the Weight parameter for an ECS instance to 0, no access requests are forwarded to the ECS instance. Valid values: 0 to 100.
	AlbServerGroupId *string `json:"AlbServerGroupId,omitempty" xml:"AlbServerGroupId,omitempty"`
	// The ID of the scaling activity in which Auto Scaling associates the ALB server group with the scaling group and adds ECS instances in the scaling group to the ALB server group. This parameter is returned only if you set the `ForceAttach` parameter to `true`.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The port number used by the ECS instance after the ECS instance is added to the ALB server group. Valid values: 1 to 65535.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s AttachAlbServerGroupsRequestAlbServerGroups) String() string {
	return tea.Prettify(s)
}

func (s AttachAlbServerGroupsRequestAlbServerGroups) GoString() string {
	return s.String()
}

func (s *AttachAlbServerGroupsRequestAlbServerGroups) SetAlbServerGroupId(v string) *AttachAlbServerGroupsRequestAlbServerGroups {
	s.AlbServerGroupId = &v
	return s
}

func (s *AttachAlbServerGroupsRequestAlbServerGroups) SetPort(v int32) *AttachAlbServerGroupsRequestAlbServerGroups {
	s.Port = &v
	return s
}

func (s *AttachAlbServerGroupsRequestAlbServerGroups) SetWeight(v int32) *AttachAlbServerGroupsRequestAlbServerGroups {
	s.Weight = &v
	return s
}

type AttachAlbServerGroupsResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s AttachAlbServerGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachAlbServerGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *AttachAlbServerGroupsResponseBody) SetRequestId(v string) *AttachAlbServerGroupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *AttachAlbServerGroupsResponseBody) SetScalingActivityId(v string) *AttachAlbServerGroupsResponseBody {
	s.ScalingActivityId = &v
	return s
}

type AttachAlbServerGroupsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachAlbServerGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachAlbServerGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachAlbServerGroupsResponse) GoString() string {
	return s.String()
}

func (s *AttachAlbServerGroupsResponse) SetHeaders(v map[string]*string) *AttachAlbServerGroupsResponse {
	s.Headers = v
	return s
}

func (s *AttachAlbServerGroupsResponse) SetStatusCode(v int32) *AttachAlbServerGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachAlbServerGroupsResponse) SetBody(v *AttachAlbServerGroupsResponseBody) *AttachAlbServerGroupsResponse {
	s.Body = v
	return s
}

type AttachDBInstancesRequest struct {
	// The ID of the ApsaraDB RDS instance.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the ApsaraDB RDS instance.
	DBInstances []*string `json:"DBInstances,omitempty" xml:"DBInstances,omitempty" type:"Repeated"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.
	//
	// The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request](~~25965~~).
	ForceAttach *bool  `json:"ForceAttach,omitempty" xml:"ForceAttach,omitempty"`
	OwnerId     *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// Specifies whether to add the private IP addresses of all instances in the scaling group to the IP address whitelist of the ApsaraDB RDS instance. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s AttachDBInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachDBInstancesRequest) GoString() string {
	return s.String()
}

func (s *AttachDBInstancesRequest) SetClientToken(v string) *AttachDBInstancesRequest {
	s.ClientToken = &v
	return s
}

func (s *AttachDBInstancesRequest) SetDBInstances(v []*string) *AttachDBInstancesRequest {
	s.DBInstances = v
	return s
}

func (s *AttachDBInstancesRequest) SetForceAttach(v bool) *AttachDBInstancesRequest {
	s.ForceAttach = &v
	return s
}

func (s *AttachDBInstancesRequest) SetOwnerId(v int64) *AttachDBInstancesRequest {
	s.OwnerId = &v
	return s
}

func (s *AttachDBInstancesRequest) SetRegionId(v string) *AttachDBInstancesRequest {
	s.RegionId = &v
	return s
}

func (s *AttachDBInstancesRequest) SetResourceOwnerAccount(v string) *AttachDBInstancesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AttachDBInstancesRequest) SetScalingGroupId(v string) *AttachDBInstancesRequest {
	s.ScalingGroupId = &v
	return s
}

type AttachDBInstancesResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AttachDBInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachDBInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *AttachDBInstancesResponseBody) SetRequestId(v string) *AttachDBInstancesResponseBody {
	s.RequestId = &v
	return s
}

type AttachDBInstancesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachDBInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachDBInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachDBInstancesResponse) GoString() string {
	return s.String()
}

func (s *AttachDBInstancesResponse) SetHeaders(v map[string]*string) *AttachDBInstancesResponse {
	s.Headers = v
	return s
}

func (s *AttachDBInstancesResponse) SetStatusCode(v int32) *AttachDBInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachDBInstancesResponse) SetBody(v *AttachDBInstancesResponseBody) *AttachDBInstancesResponse {
	s.Body = v
	return s
}

type AttachInstancesRequest struct {
	// The IDs of the ECS instances or elastic container instances that you want to add.
	Entrusted *bool `json:"Entrusted,omitempty" xml:"Entrusted,omitempty"`
	// The IDs of the ECS instances or elastic container instances that you want to add. You can specify 1 to 20 instance IDs.
	//
	// Examples:
	//
	// *   The ID of the ECS instance that you want to add is `i-28wt4****`.
	// *   The ID of the elastic container instance that you want to add is `eci-bp17gw49eu09yiwm****`.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The region ID of the scaling group.
	LifecycleHook *bool `json:"LifecycleHook,omitempty" xml:"LifecycleHook,omitempty"`
	// The weights of the ECS instances or elastic container instances as the backend servers of the associated CLB instance. Valid values: 1 to 100. Default value: 50.
	LoadBalancerWeights []*int32 `json:"LoadBalancerWeights,omitempty" xml:"LoadBalancerWeights,omitempty" type:"Repeated"`
	OwnerAccount        *string  `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId             *int64   `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the scaling activity.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// Specifies whether the scaling group manages the lifecycles of instances that are manually added to the scaling group. Valid values:
	//
	// *   true: The scaling group manages the lifecycles of instances that are manually added in a similar manner in which the scaling group manages the lifecycles of automatically created instances. After Auto Scaling removes instances from the scaling group, Auto Scaling releases the instances. After you call the DetachInstances operation to remove instances from the scaling group, Auto Scaling does not release the instances.
	// *   false: The scaling group does not manage the lifecycles of instances that are manually added. After Auto Scaling removes instances from the scaling group, Auto Scaling does not release the instances.
	//
	// > You cannot specify this parameter for subscription instances.
	//
	// Default value: false.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s AttachInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachInstancesRequest) GoString() string {
	return s.String()
}

func (s *AttachInstancesRequest) SetEntrusted(v bool) *AttachInstancesRequest {
	s.Entrusted = &v
	return s
}

func (s *AttachInstancesRequest) SetInstanceIds(v []*string) *AttachInstancesRequest {
	s.InstanceIds = v
	return s
}

func (s *AttachInstancesRequest) SetLifecycleHook(v bool) *AttachInstancesRequest {
	s.LifecycleHook = &v
	return s
}

func (s *AttachInstancesRequest) SetLoadBalancerWeights(v []*int32) *AttachInstancesRequest {
	s.LoadBalancerWeights = v
	return s
}

func (s *AttachInstancesRequest) SetOwnerAccount(v string) *AttachInstancesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AttachInstancesRequest) SetOwnerId(v int64) *AttachInstancesRequest {
	s.OwnerId = &v
	return s
}

func (s *AttachInstancesRequest) SetRegionId(v string) *AttachInstancesRequest {
	s.RegionId = &v
	return s
}

func (s *AttachInstancesRequest) SetResourceOwnerAccount(v string) *AttachInstancesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AttachInstancesRequest) SetResourceOwnerId(v int64) *AttachInstancesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AttachInstancesRequest) SetScalingGroupId(v string) *AttachInstancesRequest {
	s.ScalingGroupId = &v
	return s
}

type AttachInstancesResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s AttachInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *AttachInstancesResponseBody) SetRequestId(v string) *AttachInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *AttachInstancesResponseBody) SetScalingActivityId(v string) *AttachInstancesResponseBody {
	s.ScalingActivityId = &v
	return s
}

type AttachInstancesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachInstancesResponse) GoString() string {
	return s.String()
}

func (s *AttachInstancesResponse) SetHeaders(v map[string]*string) *AttachInstancesResponse {
	s.Headers = v
	return s
}

func (s *AttachInstancesResponse) SetStatusCode(v int32) *AttachInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachInstancesResponse) SetBody(v *AttachInstancesResponseBody) *AttachInstancesResponse {
	s.Body = v
	return s
}

type AttachLoadBalancersRequest struct {
	// The IDs of the CLB instances.
	Async *bool `json:"Async,omitempty" xml:"Async,omitempty"`
	// Specifies whether to attach the CLB instance to the scaling group in an asynchronous manner. If you attach the CLB instance from the scaling group in an asynchronous manner, the call is successful only after all operations are successful. If a specific operation fails, the call fails. We recommend that you set this parameter to true. Valid values:
	//
	// *   true: attaches the CLB instance to the scaling group in an asynchronous manner. In this case, the ID of the scaling activity is returned.
	// *   false: does not attach the CLB instance to the scaling group in an asynchronous manner.
	//
	// Default value: false.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).
	ForceAttach *bool `json:"ForceAttach,omitempty" xml:"ForceAttach,omitempty"`
	// The IDs of the CLB instances.
	LoadBalancers        []*string `json:"LoadBalancers,omitempty" xml:"LoadBalancers,omitempty" type:"Repeated"`
	OwnerId              *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// Specifies whether to add all instances in the scaling group to the vServer groups of the CLB instance. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s AttachLoadBalancersRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachLoadBalancersRequest) GoString() string {
	return s.String()
}

func (s *AttachLoadBalancersRequest) SetAsync(v bool) *AttachLoadBalancersRequest {
	s.Async = &v
	return s
}

func (s *AttachLoadBalancersRequest) SetClientToken(v string) *AttachLoadBalancersRequest {
	s.ClientToken = &v
	return s
}

func (s *AttachLoadBalancersRequest) SetForceAttach(v bool) *AttachLoadBalancersRequest {
	s.ForceAttach = &v
	return s
}

func (s *AttachLoadBalancersRequest) SetLoadBalancers(v []*string) *AttachLoadBalancersRequest {
	s.LoadBalancers = v
	return s
}

func (s *AttachLoadBalancersRequest) SetOwnerId(v int64) *AttachLoadBalancersRequest {
	s.OwnerId = &v
	return s
}

func (s *AttachLoadBalancersRequest) SetResourceOwnerAccount(v string) *AttachLoadBalancersRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AttachLoadBalancersRequest) SetScalingGroupId(v string) *AttachLoadBalancersRequest {
	s.ScalingGroupId = &v
	return s
}

type AttachLoadBalancersResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s AttachLoadBalancersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachLoadBalancersResponseBody) GoString() string {
	return s.String()
}

func (s *AttachLoadBalancersResponseBody) SetRequestId(v string) *AttachLoadBalancersResponseBody {
	s.RequestId = &v
	return s
}

func (s *AttachLoadBalancersResponseBody) SetScalingActivityId(v string) *AttachLoadBalancersResponseBody {
	s.ScalingActivityId = &v
	return s
}

type AttachLoadBalancersResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachLoadBalancersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachLoadBalancersResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachLoadBalancersResponse) GoString() string {
	return s.String()
}

func (s *AttachLoadBalancersResponse) SetHeaders(v map[string]*string) *AttachLoadBalancersResponse {
	s.Headers = v
	return s
}

func (s *AttachLoadBalancersResponse) SetStatusCode(v int32) *AttachLoadBalancersResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachLoadBalancersResponse) SetBody(v *AttachLoadBalancersResponseBody) *AttachLoadBalancersResponse {
	s.Body = v
	return s
}

type AttachVServerGroupsRequest struct {
	// Specifies whether to add Elastic Compute Service (ECS) instances in the scaling group to the vServer group. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Details of the vServer groups.
	ForceAttach *bool  `json:"ForceAttach,omitempty" xml:"ForceAttach,omitempty"`
	OwnerId     *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request](~~25965~~).
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// Details of the vServer groups.
	VServerGroups []*AttachVServerGroupsRequestVServerGroups `json:"VServerGroups,omitempty" xml:"VServerGroups,omitempty" type:"Repeated"`
}

func (s AttachVServerGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachVServerGroupsRequest) GoString() string {
	return s.String()
}

func (s *AttachVServerGroupsRequest) SetClientToken(v string) *AttachVServerGroupsRequest {
	s.ClientToken = &v
	return s
}

func (s *AttachVServerGroupsRequest) SetForceAttach(v bool) *AttachVServerGroupsRequest {
	s.ForceAttach = &v
	return s
}

func (s *AttachVServerGroupsRequest) SetOwnerId(v int64) *AttachVServerGroupsRequest {
	s.OwnerId = &v
	return s
}

func (s *AttachVServerGroupsRequest) SetRegionId(v string) *AttachVServerGroupsRequest {
	s.RegionId = &v
	return s
}

func (s *AttachVServerGroupsRequest) SetResourceOwnerAccount(v string) *AttachVServerGroupsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AttachVServerGroupsRequest) SetScalingGroupId(v string) *AttachVServerGroupsRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *AttachVServerGroupsRequest) SetVServerGroups(v []*AttachVServerGroupsRequestVServerGroups) *AttachVServerGroupsRequest {
	s.VServerGroups = v
	return s
}

type AttachVServerGroupsRequestVServerGroups struct {
	// The ID of the request.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// Details of the vServer group attributes.
	VServerGroupAttributes []*AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes `json:"VServerGroupAttributes,omitempty" xml:"VServerGroupAttributes,omitempty" type:"Repeated"`
}

func (s AttachVServerGroupsRequestVServerGroups) String() string {
	return tea.Prettify(s)
}

func (s AttachVServerGroupsRequestVServerGroups) GoString() string {
	return s.String()
}

func (s *AttachVServerGroupsRequestVServerGroups) SetLoadBalancerId(v string) *AttachVServerGroupsRequestVServerGroups {
	s.LoadBalancerId = &v
	return s
}

func (s *AttachVServerGroupsRequestVServerGroups) SetVServerGroupAttributes(v []*AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes) *AttachVServerGroupsRequestVServerGroups {
	s.VServerGroupAttributes = v
	return s
}

type AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes struct {
	// The ID of the CLB instance to which the vServer group belongs.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The weight of an ECS instance as a backend server in the vServer group. Valid values: 0 to 100.
	//
	// Default value: 50.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	// The port number that is used when Auto Scaling adds ECS instances to the vServer group. Valid values: 1 to 65535.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes) String() string {
	return tea.Prettify(s)
}

func (s AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes) GoString() string {
	return s.String()
}

func (s *AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes) SetPort(v int32) *AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes {
	s.Port = &v
	return s
}

func (s *AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes) SetVServerGroupId(v string) *AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes {
	s.VServerGroupId = &v
	return s
}

func (s *AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes) SetWeight(v int32) *AttachVServerGroupsRequestVServerGroupsVServerGroupAttributes {
	s.Weight = &v
	return s
}

type AttachVServerGroupsResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AttachVServerGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachVServerGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *AttachVServerGroupsResponseBody) SetRequestId(v string) *AttachVServerGroupsResponseBody {
	s.RequestId = &v
	return s
}

type AttachVServerGroupsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachVServerGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachVServerGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachVServerGroupsResponse) GoString() string {
	return s.String()
}

func (s *AttachVServerGroupsResponse) SetHeaders(v map[string]*string) *AttachVServerGroupsResponse {
	s.Headers = v
	return s
}

func (s *AttachVServerGroupsResponse) SetStatusCode(v int32) *AttachVServerGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachVServerGroupsResponse) SetBody(v *AttachVServerGroupsResponseBody) *AttachVServerGroupsResponse {
	s.Body = v
	return s
}

type ChangeResourceGroupRequest struct {
	NewResourceGroupId   *string `json:"NewResourceGroupId,omitempty" xml:"NewResourceGroupId,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceId           *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceType         *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s ChangeResourceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceGroupRequest) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupRequest) SetNewResourceGroupId(v string) *ChangeResourceGroupRequest {
	s.NewResourceGroupId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetOwnerId(v int64) *ChangeResourceGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetRegionId(v string) *ChangeResourceGroupRequest {
	s.RegionId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetResourceId(v string) *ChangeResourceGroupRequest {
	s.ResourceId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetResourceOwnerAccount(v string) *ChangeResourceGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetResourceType(v string) *ChangeResourceGroupRequest {
	s.ResourceType = &v
	return s
}

type ChangeResourceGroupResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ChangeResourceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupResponseBody) SetRequestId(v string) *ChangeResourceGroupResponseBody {
	s.RequestId = &v
	return s
}

type ChangeResourceGroupResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ChangeResourceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ChangeResourceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceGroupResponse) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupResponse) SetHeaders(v map[string]*string) *ChangeResourceGroupResponse {
	s.Headers = v
	return s
}

func (s *ChangeResourceGroupResponse) SetStatusCode(v int32) *ChangeResourceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ChangeResourceGroupResponse) SetBody(v *ChangeResourceGroupResponseBody) *ChangeResourceGroupResponse {
	s.Body = v
	return s
}

type CompleteLifecycleActionRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The action that you want Auto Scaling to perform after the lifecycle hook ends. Valid values:
	//
	// *   CONTINUE: Auto Scaling continues to add Elastic Compute Service (ECS) instances to the scaling group, or continues to remove ECS instances from the scaling group.
	// *   ABANDON: Auto Scaling stops adding ECS instances to the scaling group and releases the ECS instances, or continues to respond to scale-in requests and remove ECS instances from the scaling group.
	//
	// Default value: CONTINUE.
	//
	// If multiple lifecycle hooks exist in a scaling group and are triggered at the same time, the following rules apply:
	//
	// *   If you set the LifecycleActionResult parameter to ABANDON for the lifecycle hook that is applied to a scale-in activity, Auto Scaling immediately removes ECS instances from the scaling group after the lifecycle hook ends, without the need to wait for the last lifecycle hook to end.
	// *   If you set the LifecycleActionResult parameter to CONTINUE for the lifecycle hook that is applied to a scale-in or scale-out activity, Auto Scaling performs the next action until the last lifecycle hook in the scaling group ends. The action that Auto Scaling performs varies based on the value that you specify for the LifecycleActionResult parameter of the last lifecycle hook.
	LifecycleActionResult *string `json:"LifecycleActionResult,omitempty" xml:"LifecycleActionResult,omitempty"`
	// The token of the lifecycle hook. You can obtain this token by using a Message Service (MNS) queue or an MNS topic that is specified for the lifecycle hook.
	LifecycleActionToken *string `json:"LifecycleActionToken,omitempty" xml:"LifecycleActionToken,omitempty"`
	// The ID of the lifecycle hook.
	LifecycleHookId *string `json:"LifecycleHookId,omitempty" xml:"LifecycleHookId,omitempty"`
	OwnerAccount    *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId         *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
}

func (s CompleteLifecycleActionRequest) String() string {
	return tea.Prettify(s)
}

func (s CompleteLifecycleActionRequest) GoString() string {
	return s.String()
}

func (s *CompleteLifecycleActionRequest) SetClientToken(v string) *CompleteLifecycleActionRequest {
	s.ClientToken = &v
	return s
}

func (s *CompleteLifecycleActionRequest) SetLifecycleActionResult(v string) *CompleteLifecycleActionRequest {
	s.LifecycleActionResult = &v
	return s
}

func (s *CompleteLifecycleActionRequest) SetLifecycleActionToken(v string) *CompleteLifecycleActionRequest {
	s.LifecycleActionToken = &v
	return s
}

func (s *CompleteLifecycleActionRequest) SetLifecycleHookId(v string) *CompleteLifecycleActionRequest {
	s.LifecycleHookId = &v
	return s
}

func (s *CompleteLifecycleActionRequest) SetOwnerAccount(v string) *CompleteLifecycleActionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CompleteLifecycleActionRequest) SetOwnerId(v int64) *CompleteLifecycleActionRequest {
	s.OwnerId = &v
	return s
}

func (s *CompleteLifecycleActionRequest) SetRegionId(v string) *CompleteLifecycleActionRequest {
	s.RegionId = &v
	return s
}

func (s *CompleteLifecycleActionRequest) SetResourceOwnerAccount(v string) *CompleteLifecycleActionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

type CompleteLifecycleActionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CompleteLifecycleActionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CompleteLifecycleActionResponseBody) GoString() string {
	return s.String()
}

func (s *CompleteLifecycleActionResponseBody) SetRequestId(v string) *CompleteLifecycleActionResponseBody {
	s.RequestId = &v
	return s
}

type CompleteLifecycleActionResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CompleteLifecycleActionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CompleteLifecycleActionResponse) String() string {
	return tea.Prettify(s)
}

func (s CompleteLifecycleActionResponse) GoString() string {
	return s.String()
}

func (s *CompleteLifecycleActionResponse) SetHeaders(v map[string]*string) *CompleteLifecycleActionResponse {
	s.Headers = v
	return s
}

func (s *CompleteLifecycleActionResponse) SetStatusCode(v int32) *CompleteLifecycleActionResponse {
	s.StatusCode = &v
	return s
}

func (s *CompleteLifecycleActionResponse) SetBody(v *CompleteLifecycleActionResponseBody) *CompleteLifecycleActionResponse {
	s.Body = v
	return s
}

type CreateAlarmRequest struct {
	// The list of unique identifiers of the scaling rules that are associated with the event-triggered task.
	AlarmActions []*string `json:"AlarmActions,omitempty" xml:"AlarmActions,omitempty" type:"Repeated"`
	// The operator that is used to compare the metric value and the threshold. Valid values:
	//
	// *   If the metric value is greater than or equal to the threshold, set the value to: >=.
	// *   If the metric value is less than or equal to the threshold, set the value to: <=.
	// *   If the metric value is greater than the threshold, set the value to: >.
	// *   If the metric value is less than the threshold, set the value to: <.
	//
	// Default value: >=.
	ComparisonOperator *string `json:"ComparisonOperator,omitempty" xml:"ComparisonOperator,omitempty"`
	// The description of the event-triggered task.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The metric dimensions.
	Dimensions []*CreateAlarmRequestDimensions `json:"Dimensions,omitempty" xml:"Dimensions,omitempty" type:"Repeated"`
	// The effective period of the event-triggered task. By default, the event-triggered task is in effect all the time.
	//
	// This parameter follows the cron expression format. The default format is `X X X X X ?`. In the format:
	//
	// *   X: a placeholder for a field, which represents seconds, minutes, hours, days, and months in sequence. X can be a definite value or a special character that has logical meaning. For information about the valid values of X, see [Cron expression](~~25907~~).
	// *   ?: No value is specified.
	//
	// > By default, this parameter value is specified in **UTC+8**. You can specify the time zone in the `TZ=+yy` format before a cron expression. y indicates the time zone. For example, `TZ=+00 * * 1-2 * * ?` specifies that the event-triggered task is in effect between 01:00 and 02:59 (UTC+0) every day.
	//
	// Sample values:
	//
	// *   ` * * * * * ?  `: The event-triggered task is in effect all the time.
	// *   ` * * 17-18 * * ?  `: The event-triggered task is in effect between 17:00 and 18:59 (UTC+8) every day.
	// *   `TZ=+00 * * 1-2 * * ?`: The event-triggered task is in effect between 01:00 and 02:59 (UTC+0) every day.
	Effective *string `json:"Effective,omitempty" xml:"Effective,omitempty"`
	// The number of times that the threshold must be reached before a scaling rule can be executed. For example, if you set this parameter to 3, the average CPU utilization must reach or exceed 80% three times in a row before a scaling rule is triggered.
	//
	// Default value: 3.
	EvaluationCount *int32 `json:"EvaluationCount,omitempty" xml:"EvaluationCount,omitempty"`
	// The expressions that are specified in the multi-metric alert rule.
	Expressions []*CreateAlarmRequestExpressions `json:"Expressions,omitempty" xml:"Expressions,omitempty" type:"Repeated"`
	// The relationship between the trigger conditions in the multi-metric alert rule. Valid values:
	//
	// *   `&&`: An alert is triggered only if all metrics in the multi-metric alert rule meet the trigger conditions. In this case, an alert is triggered only if the results of all trigger conditions that are specified in the multi-metric alert rule are `true`.
	// *   `||`: An alert is triggered if one of the metrics in the multi-metric alert rule meets the trigger conditions.
	//
	// Default value: `&&`.
	ExpressionsLogicOperator *string `json:"ExpressionsLogicOperator,omitempty" xml:"ExpressionsLogicOperator,omitempty"`
	// The ID of the application group to which the custom metric belongs. If you set the MetricType parameter to custom, you must specify this parameter.
	GroupId *int32 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the metric. The valid values vary based on the metric type.
	//
	// *   If you set the MetricType parameter to custom, the valid values are your custom metrics.
	//
	// *   If you set the MetricType parameter to system, the MetricName parameter has the following valid values:
	//
	//     *   CpuUtilization: the CPU utilization of an ECS instance. Unit: %.
	//     *   IntranetTx: the outbound traffic over the internal network from an ECS instance. Unit: KB/min.
	//     *   IntranetRx: the inbound traffic over the Internet to an ECS instance that resides in a virtual private cloud (VPC). Unit: KB/min.
	//     *   VpcInternetTx: the outbound traffic over the Internet from an ECS instance that resides in a VPC. Unit: KB/min.
	//     *   VpcInternetRx: the inbound traffic over the Internet to an ECS instance that resides in a VPC. Unit: KB/min.
	//     *   SystemDiskReadBps: the number of bytes read from the system disk used by an ECS instance per second.
	//     *   SystemDiskWriteBps: the number of bytes written to the system disk used by an ECS instance per second.
	//     *   SystemDiskReadOps: the number of read operations on the system disk used by an ECS instance per second.
	//     *   SystemDiskWriteOps: the number of write operations on the system disk used by an ECS instance per second.
	//     *   CpuUtilizationAgent: the CPU utilization of an agent. Unit: %.
	//     *   GpuUtilizationAgent: the GPU utilization of an agent. Unit: %.
	//     *   GpuMemoryFreeUtilizationAgent: the percentage of idle GPU memory of an agent.
	//     *   GpuMemoryUtilizationAgent: the GPU memory usage of an agent. Unit: %.
	//     *   MemoryUtilization: the memory usage of an agent. Unit: %.
	//     *   LoadAverage: the average system load of an agent.
	//     *   TcpConnection: the total number of TCP connections of an agent.
	//     *   TcpConnection: the number of established TCP connections of an agent.
	//     *   PackagesNetOut: the number of packets that are sent by the internal network interface controller (NIC) used by an agent.
	//     *   PackagesNetIn: the number of packets that are received by the internal NIC used by an agent.
	//     *   EciPodCpuUtilization: the CPU utilization of an elastic container instance. Unit: %.
	//     *   EciPodMemoryUtilization: the memory usage of an elastic container instance. Unit: %.
	//
	// For more information, see [Event-triggered task for system monitoring](~~74854~~).
	MetricName *string `json:"MetricName,omitempty" xml:"MetricName,omitempty"`
	// The type of the metric. Valid values:
	//
	// *   system: system metrics of CloudMonitor
	// *   custom: custom metrics that are reported to CloudMonitor
	MetricType *string `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
	// The name of the event-triggered task.
	Name    *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The period during which the statistical value of the metric is collected. Unit: seconds. Valid values:
	//
	// *   15
	// *   60
	// *   120
	// *   300
	// *   900
	//
	// > If your scaling group is of the ECS type and uses CloudMonitor metrics, you can set the Period parameter to 15. In other cases, you can set the Period parameter to 60, 120, 300, or 900. In most cases, the name of a CloudMonitor metric contains Agent.
	//
	// Default value: 300.
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The scaling group ID of the event-triggered task.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The method that is used to aggregate statistics for the metric. Valid values:
	//
	// *   Average
	// *   Minimum
	// *   Maximum
	//
	// Default value: Average.
	Statistics *string `json:"Statistics,omitempty" xml:"Statistics,omitempty"`
	// The threshold of the metric value. If the threshold is reached the specified number of times within the specified period, a scaling rule is executed.
	Threshold *float32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s CreateAlarmRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAlarmRequest) GoString() string {
	return s.String()
}

func (s *CreateAlarmRequest) SetAlarmActions(v []*string) *CreateAlarmRequest {
	s.AlarmActions = v
	return s
}

func (s *CreateAlarmRequest) SetComparisonOperator(v string) *CreateAlarmRequest {
	s.ComparisonOperator = &v
	return s
}

func (s *CreateAlarmRequest) SetDescription(v string) *CreateAlarmRequest {
	s.Description = &v
	return s
}

func (s *CreateAlarmRequest) SetDimensions(v []*CreateAlarmRequestDimensions) *CreateAlarmRequest {
	s.Dimensions = v
	return s
}

func (s *CreateAlarmRequest) SetEffective(v string) *CreateAlarmRequest {
	s.Effective = &v
	return s
}

func (s *CreateAlarmRequest) SetEvaluationCount(v int32) *CreateAlarmRequest {
	s.EvaluationCount = &v
	return s
}

func (s *CreateAlarmRequest) SetExpressions(v []*CreateAlarmRequestExpressions) *CreateAlarmRequest {
	s.Expressions = v
	return s
}

func (s *CreateAlarmRequest) SetExpressionsLogicOperator(v string) *CreateAlarmRequest {
	s.ExpressionsLogicOperator = &v
	return s
}

func (s *CreateAlarmRequest) SetGroupId(v int32) *CreateAlarmRequest {
	s.GroupId = &v
	return s
}

func (s *CreateAlarmRequest) SetMetricName(v string) *CreateAlarmRequest {
	s.MetricName = &v
	return s
}

func (s *CreateAlarmRequest) SetMetricType(v string) *CreateAlarmRequest {
	s.MetricType = &v
	return s
}

func (s *CreateAlarmRequest) SetName(v string) *CreateAlarmRequest {
	s.Name = &v
	return s
}

func (s *CreateAlarmRequest) SetOwnerId(v int64) *CreateAlarmRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateAlarmRequest) SetPeriod(v int32) *CreateAlarmRequest {
	s.Period = &v
	return s
}

func (s *CreateAlarmRequest) SetRegionId(v string) *CreateAlarmRequest {
	s.RegionId = &v
	return s
}

func (s *CreateAlarmRequest) SetResourceOwnerAccount(v string) *CreateAlarmRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateAlarmRequest) SetScalingGroupId(v string) *CreateAlarmRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *CreateAlarmRequest) SetStatistics(v string) *CreateAlarmRequest {
	s.Statistics = &v
	return s
}

func (s *CreateAlarmRequest) SetThreshold(v float32) *CreateAlarmRequest {
	s.Threshold = &v
	return s
}

type CreateAlarmRequestDimensions struct {
	// The key of the metric dimension. The valid values vary based on the metric type.
	//
	// *   If you set the MetricType parameter to custom, you can specify this parameter based on your business requirements.
	//
	// *   If you set the MetricType parameter to system, this parameter has the following valid values:
	//
	//     *   user_id: the ID of your Alibaba Cloud account
	//     *   scaling_group: the scaling group that you want to monitor
	//     *   device: the type of the NIC
	//     *   state: the status of the TCP connection
	DimensionKey *string `json:"DimensionKey,omitempty" xml:"DimensionKey,omitempty"`
	// The value of the metric dimension. The valid values vary based on the value of the DimensionKey parameter.
	//
	// *   If you set the MetricType parameter to custom, you can specify this parameter based on your business requirements.
	//
	// *   If you set the MetricType parameter to system, the following rules apply:
	//
	//     *   If you set the DimensionKey parameter to user_id, the system specifies the value of the DimensionValue parameter.
	//
	//     *   If you set the DimensionKey parameter to scaling_group, the system specifies the value of the DimensionValue parameter.
	//
	//     *   If you set the DimensionKey parameter to device, you can set the DimensionValue parameter to eth0 or eth1.
	//
	//         *   For instances that reside in the classic network, eth0 specifies the internal NIC. Only one eth0 NIC exists on each instance that resides in a VPC.
	//         *   For instances that reside in the classic network, eth1 specifies the public NIC.
	//
	//     *   If you set the DimensionKey parameter to state, you can set the DimensionValue parameter to TCP_TOTAL or ESTABLISHED.
	//
	//         *   TCP_TOTAL specifies the total number of TCP connections.
	//         *   ESTABLISHED specifies the number of established TCP connections.
	DimensionValue *string `json:"DimensionValue,omitempty" xml:"DimensionValue,omitempty"`
}

func (s CreateAlarmRequestDimensions) String() string {
	return tea.Prettify(s)
}

func (s CreateAlarmRequestDimensions) GoString() string {
	return s.String()
}

func (s *CreateAlarmRequestDimensions) SetDimensionKey(v string) *CreateAlarmRequestDimensions {
	s.DimensionKey = &v
	return s
}

func (s *CreateAlarmRequestDimensions) SetDimensionValue(v string) *CreateAlarmRequestDimensions {
	s.DimensionValue = &v
	return s
}

type CreateAlarmRequestExpressions struct {
	// The operator that is used to compare the metric value and the threshold. Valid values:
	//
	// *   If the metric value is greater than or equal to the threshold, set the value to: >=.
	// *   If the metric value is less than or equal to the threshold, set the value to: <=.
	// *   If the metric value is greater than the threshold, set the value to: >.
	// *   If the metric value is less than the threshold, set the value to: <.
	//
	// Default value: >=.
	ComparisonOperator *string `json:"ComparisonOperator,omitempty" xml:"ComparisonOperator,omitempty"`
	// The names of the metrics that are specified in the multi-metric alert rule. The valid values of this parameter vary based on the metric type.
	//
	// *   If you set the MetricType parameter to custom, the valid values are your custom metrics.
	//
	// *   If you set the MetricType parameter to system, the MetricName parameter has the following valid values:
	//
	//     *   CpuUtilization: the CPU utilization of an ECS instance. Unit: %.
	//     *   IntranetTx: the outbound traffic over the internal network from an ECS instance. Unit: KB/min.
	//     *   IntranetRx: the inbound traffic over the Internet to an ECS instance that resides in a VPC. Unit: KB/min.
	//     *   VpcInternetTx: the outbound traffic over the Internet from an ECS instance that resides in a VPC. Unit: KB/min.
	//     *   VpcInternetRx: the inbound traffic over the Internet to an ECS instance that resides in a VPC. Unit: KB/min.
	//     *   SystemDiskReadBps: the number of bytes read from the system disk used by an ECS instance per second.
	//     *   SystemDiskWriteBps: the number of bytes written to the system disk used by an ECS instance per second.
	//     *   SystemDiskReadOps: the number of read operations on the system disk used by an ECS instance per second.
	//     *   SystemDiskWriteOps: the number of write operations on the system disk used by an ECS instance per second.
	//     *   CpuUtilizationAgent: the CPU utilization of an agent. Unit: %.
	//     *   GpuUtilizationAgent: the GPU utilization of an agent. Unit: %.
	//     *   GpuMemoryFreeUtilizationAgent: the percentage of idle GPU memory of an agent.
	//     *   GpuMemoryUtilizationAgent: the GPU memory usage of an agent. Unit: %.
	//     *   MemoryUtilization: the memory usage of an agent. Unit: %.
	//     *   LoadAverage: the average system load of an agent.
	//     *   TcpConnection: the total number of TCP connections of an agent.
	//     *   TcpConnection: the number of established TCP connections of an agent.
	//     *   PackagesNetOut: the number of packets that are sent by the internal NIC used by an agent.
	//     *   PackagesNetIn: the number of packets that are received by the internal NIC used by an agent.
	//     *   EciPodCpuUtilization: the CPU utilization of an elastic container instance. Unit: %.
	//     *   EciPodMemoryUtilization: the memory usage of an elastic container instance. Unit: %.
	//
	// For more information, see [Event-triggered task for system monitoring](~~74854~~).
	MetricName *string `json:"MetricName,omitempty" xml:"MetricName,omitempty"`
	// The period during which the statistical values of the metrics that are specified in the multi-metric alert rule are collected. Unit: seconds. Valid values:
	//
	// *   15
	// *   60
	// *   120
	// *   300
	// *   900
	//
	// > If your scaling group is of the ECS type and uses CloudMonitor metrics, you can set the Period parameter to 15. In other cases, you can set the Period parameter to 60, 120, 300, or 900. In most cases, the name of a CloudMonitor metric contains Agent.
	//
	// Default value: 300.
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The method that is used to aggregate statistics about the metrics that are specified in the multi-metric alert rule. Valid values:
	//
	// *   Average
	// *   Minimum
	// *   Maximum
	//
	// Default value: Average.
	Statistics *string `json:"Statistics,omitempty" xml:"Statistics,omitempty"`
	// The thresholds of the metric values. If the thresholds are reached the specified number of times within the specified period, a scaling rule is executed.
	Threshold *float32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s CreateAlarmRequestExpressions) String() string {
	return tea.Prettify(s)
}

func (s CreateAlarmRequestExpressions) GoString() string {
	return s.String()
}

func (s *CreateAlarmRequestExpressions) SetComparisonOperator(v string) *CreateAlarmRequestExpressions {
	s.ComparisonOperator = &v
	return s
}

func (s *CreateAlarmRequestExpressions) SetMetricName(v string) *CreateAlarmRequestExpressions {
	s.MetricName = &v
	return s
}

func (s *CreateAlarmRequestExpressions) SetPeriod(v int32) *CreateAlarmRequestExpressions {
	s.Period = &v
	return s
}

func (s *CreateAlarmRequestExpressions) SetStatistics(v string) *CreateAlarmRequestExpressions {
	s.Statistics = &v
	return s
}

func (s *CreateAlarmRequestExpressions) SetThreshold(v float32) *CreateAlarmRequestExpressions {
	s.Threshold = &v
	return s
}

type CreateAlarmResponseBody struct {
	// The ID of the event-triggered task.
	AlarmTaskId *string `json:"AlarmTaskId,omitempty" xml:"AlarmTaskId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAlarmResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateAlarmResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAlarmResponseBody) SetAlarmTaskId(v string) *CreateAlarmResponseBody {
	s.AlarmTaskId = &v
	return s
}

func (s *CreateAlarmResponseBody) SetRequestId(v string) *CreateAlarmResponseBody {
	s.RequestId = &v
	return s
}

type CreateAlarmResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateAlarmResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateAlarmResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAlarmResponse) GoString() string {
	return s.String()
}

func (s *CreateAlarmResponse) SetHeaders(v map[string]*string) *CreateAlarmResponse {
	s.Headers = v
	return s
}

func (s *CreateAlarmResponse) SetStatusCode(v int32) *CreateAlarmResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAlarmResponse) SetBody(v *CreateAlarmResponseBody) *CreateAlarmResponse {
	s.Body = v
	return s
}

type CreateEciScalingConfigurationRequest struct {
	// Information about the Container Registry Enterprise Edition instance.
	AcrRegistryInfos []*CreateEciScalingConfigurationRequestAcrRegistryInfos `json:"AcrRegistryInfos,omitempty" xml:"AcrRegistryInfos,omitempty" type:"Repeated"`
	// The validity period. Unit: seconds.
	ActiveDeadlineSeconds *int64 `json:"ActiveDeadlineSeconds,omitempty" xml:"ActiveDeadlineSeconds,omitempty"`
	// Specifies whether to automatically create an elastic IP address (EIP) and bind the EIP to the elastic container instance.
	AutoCreateEip *bool `json:"AutoCreateEip,omitempty" xml:"AutoCreateEip,omitempty"`
	// Specifies whether to automatically match the image cache. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	AutoMatchImageCache *bool `json:"AutoMatchImageCache,omitempty" xml:"AutoMatchImageCache,omitempty"`
	// The name of the elastic container instance.
	ContainerGroupName *string `json:"ContainerGroupName,omitempty" xml:"ContainerGroupName,omitempty"`
	// The containers in the elastic container instance.
	Containers []*CreateEciScalingConfigurationRequestContainers `json:"Containers,omitempty" xml:"Containers,omitempty" type:"Repeated"`
	// Specifies whether to enable the cost optimization feature. Valid values:
	//
	// *   true
	// *   false
	CostOptimization *bool `json:"CostOptimization,omitempty" xml:"CostOptimization,omitempty"`
	// The number of vCPUs of the elastic container instance.
	Cpu *float32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// Number of physical CPU cores This parameter is not available for all instance types. For more information, see [Specify custom CPU options](~~197781~~).
	CpuOptionsCore *int32 `json:"CpuOptionsCore,omitempty" xml:"CpuOptionsCore,omitempty"`
	// The number of threads per core. This parameter is not available for all instance types. A value of 1 indicates that Hyper-Threading is disabled. For more information, see [Specify custom CPU options](~~197781~~).
	CpuOptionsThreadsPerCore *int32 `json:"CpuOptionsThreadsPerCore,omitempty" xml:"CpuOptionsThreadsPerCore,omitempty"`
	// > This parameter is unavailable.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The IP addresses of the DNS servers.
	DnsConfigNameServers []*string `json:"DnsConfigNameServers,omitempty" xml:"DnsConfigNameServers,omitempty" type:"Repeated"`
	// The options. Each option is in the name-value pair format. The value in the name-value pair is optional.
	DnsConfigOptions []*CreateEciScalingConfigurationRequestDnsConfigOptions `json:"DnsConfigOptions,omitempty" xml:"DnsConfigOptions,omitempty" type:"Repeated"`
	// The DNS lookup domains.
	DnsConfigSearchs []*string `json:"DnsConfigSearchs,omitempty" xml:"DnsConfigSearchs,omitempty" type:"Repeated"`
	// The Domain Name System (DNS) policy. Valid values:
	//
	// *   None: uses the DNS that is set for the DnsConfig field.
	// *   Default: use the DNS that is set for the runtime environment.
	DnsPolicy *string `json:"DnsPolicy,omitempty" xml:"DnsPolicy,omitempty"`
	// The maximum outbound bandwidth. Unit: bytes.
	EgressBandwidth *int64 `json:"EgressBandwidth,omitempty" xml:"EgressBandwidth,omitempty"`
	// The bandwidth of the EIP. Default value: 5 Mbit/s.
	EipBandwidth *int32 `json:"EipBandwidth,omitempty" xml:"EipBandwidth,omitempty"`
	// > This parameter is unavailable.
	EnableSls *bool `json:"EnableSls,omitempty" xml:"EnableSls,omitempty"`
	// The size of the temporary storage space. By default, an ESSD of the PL1 type is used. Unit: GiB.
	EphemeralStorage *int32 `json:"EphemeralStorage,omitempty" xml:"EphemeralStorage,omitempty"`
	// The hostnames and IP addresses of a container that you want to add to the hosts file of the elastic container instance.
	HostAliases []*CreateEciScalingConfigurationRequestHostAliases `json:"HostAliases,omitempty" xml:"HostAliases,omitempty" type:"Repeated"`
	// The name of the elastic container instance.
	HostName *string `json:"HostName,omitempty" xml:"HostName,omitempty"`
	// Information about the image repository.
	ImageRegistryCredentials []*CreateEciScalingConfigurationRequestImageRegistryCredentials `json:"ImageRegistryCredentials,omitempty" xml:"ImageRegistryCredentials,omitempty" type:"Repeated"`
	// The ID of the image cache.
	ImageSnapshotId *string `json:"ImageSnapshotId,omitempty" xml:"ImageSnapshotId,omitempty"`
	// The maximum inbound bandwidth. Unit: bit/s.
	IngressBandwidth *int64 `json:"IngressBandwidth,omitempty" xml:"IngressBandwidth,omitempty"`
	// The init containers.
	InitContainers []*CreateEciScalingConfigurationRequestInitContainers `json:"InitContainers,omitempty" xml:"InitContainers,omitempty" type:"Repeated"`
	// The level of the instance type, which is used to filter the instance types that meet the specified criteria. This parameter takes effect only if you set the `CostOptimization` parameter to true. Valid values:
	//
	// *   EntryLevel: shared instance type. Instances of this level are the most cost-effective but may not provide stable computing performance in a consistent manner. Instances of this level are suitable for business scenarios in which the CPU utilization is low. For more information, see [Shared instance families](~~108489~~).
	// *   EnterpriseLevel: Instances of this level provide stable performance and dedicated resources, and are suitable for business scenarios that require high stability. For more information, see [Instance family](~~25378~~).
	// *   CreditEntryLevel: This value is valid only for burstable instances. CPU credits are used to ensure computing performance. Instances of this level are suitable for scenarios in which the CPU utilization is low but may fluctuate in specific cases. For more information, see the [Overview](~~59977~~) topic of burstable instances.
	InstanceFamilyLevel *string `json:"InstanceFamilyLevel,omitempty" xml:"InstanceFamilyLevel,omitempty"`
	// The number of IPv6 addresses.
	Ipv6AddressCount *int32 `json:"Ipv6AddressCount,omitempty" xml:"Ipv6AddressCount,omitempty"`
	// The weight of the elastic container instance as a backend server. Valid values: 1 to 100.
	//
	// Default value: 50.
	LoadBalancerWeight *int32 `json:"LoadBalancerWeight,omitempty" xml:"LoadBalancerWeight,omitempty"`
	// The memory size of the elastic container instance. Unit: GiB.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The domain name of the Network Time Protocol (NTP) server.
	NtpServers []*string `json:"NtpServers,omitempty" xml:"NtpServers,omitempty" type:"Repeated"`
	OwnerId    *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The name of the RAM role for the elastic container instance. You can use an instance RAM role to access both elastic container instances and Elastic Compute Service (ECS) instances. For more information, see [Use an instance RAM role by calling API operations](~~61178~~).
	RamRoleName *string `json:"RamRoleName,omitempty" xml:"RamRoleName,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The restart policy of the elastic container instance. Valid values:
	//
	// *   Always: always restarts the elastic container instance.
	// *   Never: never restarts the elastic container instance.
	// *   OnFailure: restarts the elastic container instance upon failures.
	//
	// Default value: Always.
	RestartPolicy *string `json:"RestartPolicy,omitempty" xml:"RestartPolicy,omitempty"`
	// The name of the scaling configuration. The name must be 2 to 64 characters in length, and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). The name must start with a letter or a digit.
	//
	// The name of the scaling configuration must be unique within a scaling group in a region. If you do not specify this parameter, the value of the ScalingConfigurationId parameter is used.
	ScalingConfigurationName *string `json:"ScalingConfigurationName,omitempty" xml:"ScalingConfigurationName,omitempty"`
	// The ID of the scaling group in which you want to create the scaling configuration.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The system information of the security context in which the elastic container instance runs.
	SecurityContextSysctls []*CreateEciScalingConfigurationRequestSecurityContextSysctls `json:"SecurityContextSysctls,omitempty" xml:"SecurityContextSysctls,omitempty" type:"Repeated"`
	// The ID of the security group with which you want to associate the elastic container instance. Elastic container instances that are associated with the same security group can access each other.
	//
	// If you do not specify a security group, the system uses the default security group in the region that you selected. Make sure that the inbound rules of the security group contain the protocols and the port numbers of the containers that you want to expose. If you do not have a default security group in the region, the system creates a default security group, and then adds the declared container protocols and port numbers to the inbound rules of the security group.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// The maximum hourly price of the preemptible elastic container instance. The value can be accurate to three decimal places.
	//
	// If you set the SpotStrategy parameter to SpotWithPriceLimit, you must also specify the SpotPriceLimit parameter.
	SpotPriceLimit *float32 `json:"SpotPriceLimit,omitempty" xml:"SpotPriceLimit,omitempty"`
	// The bidding policy for the elastic container instance. Valid values:
	//
	// *   NoSpot: The instance is a pay-as-you-go instance.
	// *   SpotWithPriceLimit: The instance is a preemptible instance with a user-defined maximum hourly price.
	// *   SpotAsPriceGo: The instance is a preemptible instance for which the market price at the time of purchase is used as the bid price.
	//
	// Default value: NoSpot.
	SpotStrategy *string `json:"SpotStrategy,omitempty" xml:"SpotStrategy,omitempty"`
	// The tags of the elastic container instance. The tags must be specified in the key-value pair format. You can specify up to 20 tags. When you specify tag keys and tag values, take note of the following items:
	//
	// *   A tag key can be up to 64 characters in length. The key cannot start with acs: or aliyun and cannot contain `http://` or `https://`. You cannot specify an empty string as a tag key.
	// *   A tag value can be up to 128 characters in length. The value cannot start with acs: or aliyun and cannot contain `http://` or `https://`. You can specify an empty string as a tag value.
	Tags []*CreateEciScalingConfigurationRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The buffer time in which the program handles operations before the program is stopped. Unit: seconds.
	TerminationGracePeriodSeconds *int64 `json:"TerminationGracePeriodSeconds,omitempty" xml:"TerminationGracePeriodSeconds,omitempty"`
	// Information about the volumes.
	Volumes []*CreateEciScalingConfigurationRequestVolumes `json:"Volumes,omitempty" xml:"Volumes,omitempty" type:"Repeated"`
}

func (s CreateEciScalingConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequest) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequest) SetAcrRegistryInfos(v []*CreateEciScalingConfigurationRequestAcrRegistryInfos) *CreateEciScalingConfigurationRequest {
	s.AcrRegistryInfos = v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetActiveDeadlineSeconds(v int64) *CreateEciScalingConfigurationRequest {
	s.ActiveDeadlineSeconds = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetAutoCreateEip(v bool) *CreateEciScalingConfigurationRequest {
	s.AutoCreateEip = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetAutoMatchImageCache(v bool) *CreateEciScalingConfigurationRequest {
	s.AutoMatchImageCache = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetContainerGroupName(v string) *CreateEciScalingConfigurationRequest {
	s.ContainerGroupName = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetContainers(v []*CreateEciScalingConfigurationRequestContainers) *CreateEciScalingConfigurationRequest {
	s.Containers = v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetCostOptimization(v bool) *CreateEciScalingConfigurationRequest {
	s.CostOptimization = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetCpu(v float32) *CreateEciScalingConfigurationRequest {
	s.Cpu = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetCpuOptionsCore(v int32) *CreateEciScalingConfigurationRequest {
	s.CpuOptionsCore = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetCpuOptionsThreadsPerCore(v int32) *CreateEciScalingConfigurationRequest {
	s.CpuOptionsThreadsPerCore = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetDescription(v string) *CreateEciScalingConfigurationRequest {
	s.Description = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetDnsConfigNameServers(v []*string) *CreateEciScalingConfigurationRequest {
	s.DnsConfigNameServers = v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetDnsConfigOptions(v []*CreateEciScalingConfigurationRequestDnsConfigOptions) *CreateEciScalingConfigurationRequest {
	s.DnsConfigOptions = v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetDnsConfigSearchs(v []*string) *CreateEciScalingConfigurationRequest {
	s.DnsConfigSearchs = v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetDnsPolicy(v string) *CreateEciScalingConfigurationRequest {
	s.DnsPolicy = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetEgressBandwidth(v int64) *CreateEciScalingConfigurationRequest {
	s.EgressBandwidth = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetEipBandwidth(v int32) *CreateEciScalingConfigurationRequest {
	s.EipBandwidth = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetEnableSls(v bool) *CreateEciScalingConfigurationRequest {
	s.EnableSls = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetEphemeralStorage(v int32) *CreateEciScalingConfigurationRequest {
	s.EphemeralStorage = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetHostAliases(v []*CreateEciScalingConfigurationRequestHostAliases) *CreateEciScalingConfigurationRequest {
	s.HostAliases = v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetHostName(v string) *CreateEciScalingConfigurationRequest {
	s.HostName = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetImageRegistryCredentials(v []*CreateEciScalingConfigurationRequestImageRegistryCredentials) *CreateEciScalingConfigurationRequest {
	s.ImageRegistryCredentials = v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetImageSnapshotId(v string) *CreateEciScalingConfigurationRequest {
	s.ImageSnapshotId = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetIngressBandwidth(v int64) *CreateEciScalingConfigurationRequest {
	s.IngressBandwidth = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetInitContainers(v []*CreateEciScalingConfigurationRequestInitContainers) *CreateEciScalingConfigurationRequest {
	s.InitContainers = v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetInstanceFamilyLevel(v string) *CreateEciScalingConfigurationRequest {
	s.InstanceFamilyLevel = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetIpv6AddressCount(v int32) *CreateEciScalingConfigurationRequest {
	s.Ipv6AddressCount = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetLoadBalancerWeight(v int32) *CreateEciScalingConfigurationRequest {
	s.LoadBalancerWeight = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetMemory(v float32) *CreateEciScalingConfigurationRequest {
	s.Memory = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetNtpServers(v []*string) *CreateEciScalingConfigurationRequest {
	s.NtpServers = v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetOwnerId(v int64) *CreateEciScalingConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetRamRoleName(v string) *CreateEciScalingConfigurationRequest {
	s.RamRoleName = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetResourceGroupId(v string) *CreateEciScalingConfigurationRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetResourceOwnerAccount(v string) *CreateEciScalingConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetRestartPolicy(v string) *CreateEciScalingConfigurationRequest {
	s.RestartPolicy = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetScalingConfigurationName(v string) *CreateEciScalingConfigurationRequest {
	s.ScalingConfigurationName = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetScalingGroupId(v string) *CreateEciScalingConfigurationRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetSecurityContextSysctls(v []*CreateEciScalingConfigurationRequestSecurityContextSysctls) *CreateEciScalingConfigurationRequest {
	s.SecurityContextSysctls = v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetSecurityGroupId(v string) *CreateEciScalingConfigurationRequest {
	s.SecurityGroupId = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetSpotPriceLimit(v float32) *CreateEciScalingConfigurationRequest {
	s.SpotPriceLimit = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetSpotStrategy(v string) *CreateEciScalingConfigurationRequest {
	s.SpotStrategy = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetTags(v []*CreateEciScalingConfigurationRequestTags) *CreateEciScalingConfigurationRequest {
	s.Tags = v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetTerminationGracePeriodSeconds(v int64) *CreateEciScalingConfigurationRequest {
	s.TerminationGracePeriodSeconds = &v
	return s
}

func (s *CreateEciScalingConfigurationRequest) SetVolumes(v []*CreateEciScalingConfigurationRequestVolumes) *CreateEciScalingConfigurationRequest {
	s.Volumes = v
	return s
}

type CreateEciScalingConfigurationRequestAcrRegistryInfos struct {
	// The domain names of the Container Registry Enterprise Edition instances. By default, all domain names of the Container Registry Enterprise Edition instances are displayed. You can specify one or more domain names. Separate multiple domain names with commas (,).
	Domains []*string `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Repeated"`
	// The ID of the Container Registry Enterprise Edition instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the Container Registry Enterprise Edition instance.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The region ID of the Container Registry Enterprise Edition instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateEciScalingConfigurationRequestAcrRegistryInfos) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestAcrRegistryInfos) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestAcrRegistryInfos) SetDomains(v []*string) *CreateEciScalingConfigurationRequestAcrRegistryInfos {
	s.Domains = v
	return s
}

func (s *CreateEciScalingConfigurationRequestAcrRegistryInfos) SetInstanceId(v string) *CreateEciScalingConfigurationRequestAcrRegistryInfos {
	s.InstanceId = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestAcrRegistryInfos) SetInstanceName(v string) *CreateEciScalingConfigurationRequestAcrRegistryInfos {
	s.InstanceName = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestAcrRegistryInfos) SetRegionId(v string) *CreateEciScalingConfigurationRequestAcrRegistryInfos {
	s.RegionId = &v
	return s
}

type CreateEciScalingConfigurationRequestContainers struct {
	LivenessProbe   *CreateEciScalingConfigurationRequestContainersLivenessProbe   `json:"LivenessProbe,omitempty" xml:"LivenessProbe,omitempty" require:"true" type:"Struct"`
	ReadinessProbe  *CreateEciScalingConfigurationRequestContainersReadinessProbe  `json:"ReadinessProbe,omitempty" xml:"ReadinessProbe,omitempty" require:"true" type:"Struct"`
	SecurityContext *CreateEciScalingConfigurationRequestContainersSecurityContext `json:"SecurityContext,omitempty" xml:"SecurityContext,omitempty" require:"true" type:"Struct"`
	// The arguments that correspond to the startup commands of the container. You can specify up to 10 arguments.
	Args []*string `json:"Args,omitempty" xml:"Args,omitempty" type:"Repeated"`
	// The commands that you want to run in the container when you use the CLI to perform probes.
	Commands []*string `json:"Commands,omitempty" xml:"Commands,omitempty" type:"Repeated"`
	// The number of CPU cores in the container.
	Cpu *float32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// Information about environment variables.
	EnvironmentVars []*CreateEciScalingConfigurationRequestContainersEnvironmentVars `json:"EnvironmentVars,omitempty" xml:"EnvironmentVars,omitempty" type:"Repeated"`
	// The number of GPUs that you want to allocate to the container.
	Gpu *int32 `json:"Gpu,omitempty" xml:"Gpu,omitempty"`
	// The image of the container.
	Image *string `json:"Image,omitempty" xml:"Image,omitempty"`
	// The image pulling policy. Valid values:
	//
	// *   Always: pulls images each time.
	// *   IfNotPresent: pulls images only if no on-premises images are available. On-premises images are preferentially used. If no on-premises images are available, image pulling is performed.
	// *   Never: never pulls images. On-premises images are always used.
	ImagePullPolicy *string `json:"ImagePullPolicy,omitempty" xml:"ImagePullPolicy,omitempty"`
	// The memory size of the container. Unit: GiB.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The name of the container image.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ports.
	Ports []*CreateEciScalingConfigurationRequestContainersPorts `json:"Ports,omitempty" xml:"Ports,omitempty" type:"Repeated"`
	// Specifies whether the container allocates buffer resources to standard input streams when the container is running. If you do not specify this parameter, an end-of-file (EOF) error may occur.
	//
	// Default value: false.
	Stdin *bool `json:"Stdin,omitempty" xml:"Stdin,omitempty"`
	// Specifies whether to disconnect standard input streams after a client is disconnected.
	//
	// If you set the StdinOnce parameter to true, standard input streams are connected after the container is started, and remain idle until a client is connected to receive data. After the client is disconnected, streams are also disconnected, and remain disconnected until the container is started again.
	StdinOnce *bool `json:"StdinOnce,omitempty" xml:"StdinOnce,omitempty"`
	// Specifies whether to enable interaction. Valid values:
	//
	// *   true
	// *   false
	//
	// If the value of the Command parameter is /bin/bash, you must set this parameter to true.
	//
	// Default value: false.
	Tty *bool `json:"Tty,omitempty" xml:"Tty,omitempty"`
	// Information about the volume mount of the container.
	VolumeMounts []*CreateEciScalingConfigurationRequestContainersVolumeMounts `json:"VolumeMounts,omitempty" xml:"VolumeMounts,omitempty" type:"Repeated"`
	// The working directory of the container.
	WorkingDir *string `json:"WorkingDir,omitempty" xml:"WorkingDir,omitempty"`
}

func (s CreateEciScalingConfigurationRequestContainers) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainers) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainers) SetLivenessProbe(v *CreateEciScalingConfigurationRequestContainersLivenessProbe) *CreateEciScalingConfigurationRequestContainers {
	s.LivenessProbe = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetReadinessProbe(v *CreateEciScalingConfigurationRequestContainersReadinessProbe) *CreateEciScalingConfigurationRequestContainers {
	s.ReadinessProbe = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetSecurityContext(v *CreateEciScalingConfigurationRequestContainersSecurityContext) *CreateEciScalingConfigurationRequestContainers {
	s.SecurityContext = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetArgs(v []*string) *CreateEciScalingConfigurationRequestContainers {
	s.Args = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetCommands(v []*string) *CreateEciScalingConfigurationRequestContainers {
	s.Commands = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetCpu(v float32) *CreateEciScalingConfigurationRequestContainers {
	s.Cpu = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetEnvironmentVars(v []*CreateEciScalingConfigurationRequestContainersEnvironmentVars) *CreateEciScalingConfigurationRequestContainers {
	s.EnvironmentVars = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetGpu(v int32) *CreateEciScalingConfigurationRequestContainers {
	s.Gpu = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetImage(v string) *CreateEciScalingConfigurationRequestContainers {
	s.Image = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetImagePullPolicy(v string) *CreateEciScalingConfigurationRequestContainers {
	s.ImagePullPolicy = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetMemory(v float32) *CreateEciScalingConfigurationRequestContainers {
	s.Memory = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetName(v string) *CreateEciScalingConfigurationRequestContainers {
	s.Name = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetPorts(v []*CreateEciScalingConfigurationRequestContainersPorts) *CreateEciScalingConfigurationRequestContainers {
	s.Ports = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetStdin(v bool) *CreateEciScalingConfigurationRequestContainers {
	s.Stdin = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetStdinOnce(v bool) *CreateEciScalingConfigurationRequestContainers {
	s.StdinOnce = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetTty(v bool) *CreateEciScalingConfigurationRequestContainers {
	s.Tty = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetVolumeMounts(v []*CreateEciScalingConfigurationRequestContainersVolumeMounts) *CreateEciScalingConfigurationRequestContainers {
	s.VolumeMounts = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainers) SetWorkingDir(v string) *CreateEciScalingConfigurationRequestContainers {
	s.WorkingDir = &v
	return s
}

type CreateEciScalingConfigurationRequestContainersLivenessProbe struct {
	Exec                *CreateEciScalingConfigurationRequestContainersLivenessProbeExec      `json:"Exec,omitempty" xml:"Exec,omitempty" require:"true" type:"Struct"`
	FailureThreshold    *int32                                                                `json:"FailureThreshold,omitempty" xml:"FailureThreshold,omitempty"`
	HttpGet             *CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet   `json:"HttpGet,omitempty" xml:"HttpGet,omitempty" require:"true" type:"Struct"`
	InitialDelaySeconds *int32                                                                `json:"InitialDelaySeconds,omitempty" xml:"InitialDelaySeconds,omitempty"`
	PeriodSeconds       *int32                                                                `json:"PeriodSeconds,omitempty" xml:"PeriodSeconds,omitempty"`
	SuccessThreshold    *int32                                                                `json:"SuccessThreshold,omitempty" xml:"SuccessThreshold,omitempty"`
	TcpSocket           *CreateEciScalingConfigurationRequestContainersLivenessProbeTcpSocket `json:"TcpSocket,omitempty" xml:"TcpSocket,omitempty" require:"true" type:"Struct"`
	TimeoutSeconds      *int32                                                                `json:"TimeoutSeconds,omitempty" xml:"TimeoutSeconds,omitempty"`
}

func (s CreateEciScalingConfigurationRequestContainersLivenessProbe) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersLivenessProbe) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbe) SetExec(v *CreateEciScalingConfigurationRequestContainersLivenessProbeExec) *CreateEciScalingConfigurationRequestContainersLivenessProbe {
	s.Exec = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbe) SetFailureThreshold(v int32) *CreateEciScalingConfigurationRequestContainersLivenessProbe {
	s.FailureThreshold = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbe) SetHttpGet(v *CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet) *CreateEciScalingConfigurationRequestContainersLivenessProbe {
	s.HttpGet = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbe) SetInitialDelaySeconds(v int32) *CreateEciScalingConfigurationRequestContainersLivenessProbe {
	s.InitialDelaySeconds = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbe) SetPeriodSeconds(v int32) *CreateEciScalingConfigurationRequestContainersLivenessProbe {
	s.PeriodSeconds = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbe) SetSuccessThreshold(v int32) *CreateEciScalingConfigurationRequestContainersLivenessProbe {
	s.SuccessThreshold = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbe) SetTcpSocket(v *CreateEciScalingConfigurationRequestContainersLivenessProbeTcpSocket) *CreateEciScalingConfigurationRequestContainersLivenessProbe {
	s.TcpSocket = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbe) SetTimeoutSeconds(v int32) *CreateEciScalingConfigurationRequestContainersLivenessProbe {
	s.TimeoutSeconds = &v
	return s
}

type CreateEciScalingConfigurationRequestContainersLivenessProbeExec struct {
	Commands []*string `json:"Commands,omitempty" xml:"Commands,omitempty" type:"Repeated"`
}

func (s CreateEciScalingConfigurationRequestContainersLivenessProbeExec) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersLivenessProbeExec) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbeExec) SetCommands(v []*string) *CreateEciScalingConfigurationRequestContainersLivenessProbeExec {
	s.Commands = v
	return s
}

type CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet struct {
	Path   *string `json:"Path,omitempty" xml:"Path,omitempty"`
	Port   *int32  `json:"Port,omitempty" xml:"Port,omitempty"`
	Scheme *string `json:"Scheme,omitempty" xml:"Scheme,omitempty"`
}

func (s CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet) SetPath(v string) *CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet {
	s.Path = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet) SetPort(v int32) *CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet {
	s.Port = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet) SetScheme(v string) *CreateEciScalingConfigurationRequestContainersLivenessProbeHttpGet {
	s.Scheme = &v
	return s
}

type CreateEciScalingConfigurationRequestContainersLivenessProbeTcpSocket struct {
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
}

func (s CreateEciScalingConfigurationRequestContainersLivenessProbeTcpSocket) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersLivenessProbeTcpSocket) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersLivenessProbeTcpSocket) SetPort(v int32) *CreateEciScalingConfigurationRequestContainersLivenessProbeTcpSocket {
	s.Port = &v
	return s
}

type CreateEciScalingConfigurationRequestContainersReadinessProbe struct {
	Exec                *CreateEciScalingConfigurationRequestContainersReadinessProbeExec      `json:"Exec,omitempty" xml:"Exec,omitempty" require:"true" type:"Struct"`
	FailureThreshold    *int32                                                                 `json:"FailureThreshold,omitempty" xml:"FailureThreshold,omitempty"`
	HttpGet             *CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet   `json:"HttpGet,omitempty" xml:"HttpGet,omitempty" require:"true" type:"Struct"`
	InitialDelaySeconds *int32                                                                 `json:"InitialDelaySeconds,omitempty" xml:"InitialDelaySeconds,omitempty"`
	PeriodSeconds       *int32                                                                 `json:"PeriodSeconds,omitempty" xml:"PeriodSeconds,omitempty"`
	SuccessThreshold    *int32                                                                 `json:"SuccessThreshold,omitempty" xml:"SuccessThreshold,omitempty"`
	TcpSocket           *CreateEciScalingConfigurationRequestContainersReadinessProbeTcpSocket `json:"TcpSocket,omitempty" xml:"TcpSocket,omitempty" require:"true" type:"Struct"`
	TimeoutSeconds      *int32                                                                 `json:"TimeoutSeconds,omitempty" xml:"TimeoutSeconds,omitempty"`
}

func (s CreateEciScalingConfigurationRequestContainersReadinessProbe) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersReadinessProbe) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbe) SetExec(v *CreateEciScalingConfigurationRequestContainersReadinessProbeExec) *CreateEciScalingConfigurationRequestContainersReadinessProbe {
	s.Exec = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbe) SetFailureThreshold(v int32) *CreateEciScalingConfigurationRequestContainersReadinessProbe {
	s.FailureThreshold = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbe) SetHttpGet(v *CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet) *CreateEciScalingConfigurationRequestContainersReadinessProbe {
	s.HttpGet = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbe) SetInitialDelaySeconds(v int32) *CreateEciScalingConfigurationRequestContainersReadinessProbe {
	s.InitialDelaySeconds = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbe) SetPeriodSeconds(v int32) *CreateEciScalingConfigurationRequestContainersReadinessProbe {
	s.PeriodSeconds = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbe) SetSuccessThreshold(v int32) *CreateEciScalingConfigurationRequestContainersReadinessProbe {
	s.SuccessThreshold = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbe) SetTcpSocket(v *CreateEciScalingConfigurationRequestContainersReadinessProbeTcpSocket) *CreateEciScalingConfigurationRequestContainersReadinessProbe {
	s.TcpSocket = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbe) SetTimeoutSeconds(v int32) *CreateEciScalingConfigurationRequestContainersReadinessProbe {
	s.TimeoutSeconds = &v
	return s
}

type CreateEciScalingConfigurationRequestContainersReadinessProbeExec struct {
	Commands []*string `json:"Commands,omitempty" xml:"Commands,omitempty" type:"Repeated"`
}

func (s CreateEciScalingConfigurationRequestContainersReadinessProbeExec) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersReadinessProbeExec) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbeExec) SetCommands(v []*string) *CreateEciScalingConfigurationRequestContainersReadinessProbeExec {
	s.Commands = v
	return s
}

type CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet struct {
	Path   *string `json:"Path,omitempty" xml:"Path,omitempty"`
	Port   *int32  `json:"Port,omitempty" xml:"Port,omitempty"`
	Scheme *string `json:"Scheme,omitempty" xml:"Scheme,omitempty"`
}

func (s CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet) SetPath(v string) *CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet {
	s.Path = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet) SetPort(v int32) *CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet {
	s.Port = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet) SetScheme(v string) *CreateEciScalingConfigurationRequestContainersReadinessProbeHttpGet {
	s.Scheme = &v
	return s
}

type CreateEciScalingConfigurationRequestContainersReadinessProbeTcpSocket struct {
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
}

func (s CreateEciScalingConfigurationRequestContainersReadinessProbeTcpSocket) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersReadinessProbeTcpSocket) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersReadinessProbeTcpSocket) SetPort(v int32) *CreateEciScalingConfigurationRequestContainersReadinessProbeTcpSocket {
	s.Port = &v
	return s
}

type CreateEciScalingConfigurationRequestContainersSecurityContext struct {
	Capability             *CreateEciScalingConfigurationRequestContainersSecurityContextCapability `json:"Capability,omitempty" xml:"Capability,omitempty" require:"true" type:"Struct"`
	ReadOnlyRootFilesystem *bool                                                                    `json:"ReadOnlyRootFilesystem,omitempty" xml:"ReadOnlyRootFilesystem,omitempty"`
	RunAsUser              *int64                                                                   `json:"RunAsUser,omitempty" xml:"RunAsUser,omitempty"`
}

func (s CreateEciScalingConfigurationRequestContainersSecurityContext) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersSecurityContext) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersSecurityContext) SetCapability(v *CreateEciScalingConfigurationRequestContainersSecurityContextCapability) *CreateEciScalingConfigurationRequestContainersSecurityContext {
	s.Capability = v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersSecurityContext) SetReadOnlyRootFilesystem(v bool) *CreateEciScalingConfigurationRequestContainersSecurityContext {
	s.ReadOnlyRootFilesystem = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersSecurityContext) SetRunAsUser(v int64) *CreateEciScalingConfigurationRequestContainersSecurityContext {
	s.RunAsUser = &v
	return s
}

type CreateEciScalingConfigurationRequestContainersSecurityContextCapability struct {
	Add []*string `json:"Add,omitempty" xml:"Add,omitempty" type:"Repeated"`
}

func (s CreateEciScalingConfigurationRequestContainersSecurityContextCapability) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersSecurityContextCapability) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersSecurityContextCapability) SetAdd(v []*string) *CreateEciScalingConfigurationRequestContainersSecurityContextCapability {
	s.Add = v
	return s
}

type CreateEciScalingConfigurationRequestContainersEnvironmentVars struct {
	// > This parameter is unavailable.
	FieldRefFieldPath *string `json:"FieldRefFieldPath,omitempty" xml:"FieldRefFieldPath,omitempty"`
	// The name of the environment variable. The name must be 1 to 128 characters in length and can contain letters, digits, and underscores (\_). The name cannot start with a digit. Specify the name in the \[0-9a-zA-Z] format.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the environment variable. The value must be 0 to 256 characters in length.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateEciScalingConfigurationRequestContainersEnvironmentVars) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersEnvironmentVars) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersEnvironmentVars) SetFieldRefFieldPath(v string) *CreateEciScalingConfigurationRequestContainersEnvironmentVars {
	s.FieldRefFieldPath = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersEnvironmentVars) SetKey(v string) *CreateEciScalingConfigurationRequestContainersEnvironmentVars {
	s.Key = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersEnvironmentVars) SetValue(v string) *CreateEciScalingConfigurationRequestContainersEnvironmentVars {
	s.Value = &v
	return s
}

type CreateEciScalingConfigurationRequestContainersPorts struct {
	// The port number. Valid values: 1 to 65535.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The type of the protocol. Valid values:
	//
	// *   TCP
	// *   UDP
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s CreateEciScalingConfigurationRequestContainersPorts) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersPorts) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersPorts) SetPort(v int32) *CreateEciScalingConfigurationRequestContainersPorts {
	s.Port = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersPorts) SetProtocol(v string) *CreateEciScalingConfigurationRequestContainersPorts {
	s.Protocol = &v
	return s
}

type CreateEciScalingConfigurationRequestContainersVolumeMounts struct {
	// The directory on which the container mounts the volume.
	//
	// > Data in this directory is overwritten by the data on the volume.
	MountPath *string `json:"MountPath,omitempty" xml:"MountPath,omitempty"`
	// The mount propagation settings of the volume. Mount propagation allows volumes that are mounted on one container to be shared with other containers in the same pod, or even with other pods on the same node. Valid values:
	//
	// *   None: The volume mount does not receive subsequent mounts that are mounted to this volume or its subdirectories.
	// *   HostToCotainer: The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories.
	// *   Bidirectional: This value is similar to HostToCotainer. The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories. In addition, all volume mounts that are created by the container are propagated back to the instance and to all containers of all pods that use the same volume.
	//
	// Default value: None.
	MountPropagation *string `json:"MountPropagation,omitempty" xml:"MountPropagation,omitempty"`
	// The name of the volume. The value of this parameter is the same as the value of the VolumeName parameter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Specifies whether the volume is read-only. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	ReadOnly *bool `json:"ReadOnly,omitempty" xml:"ReadOnly,omitempty"`
	// The subdirectory of the volume.
	SubPath *string `json:"SubPath,omitempty" xml:"SubPath,omitempty"`
}

func (s CreateEciScalingConfigurationRequestContainersVolumeMounts) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestContainersVolumeMounts) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestContainersVolumeMounts) SetMountPath(v string) *CreateEciScalingConfigurationRequestContainersVolumeMounts {
	s.MountPath = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersVolumeMounts) SetMountPropagation(v string) *CreateEciScalingConfigurationRequestContainersVolumeMounts {
	s.MountPropagation = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersVolumeMounts) SetName(v string) *CreateEciScalingConfigurationRequestContainersVolumeMounts {
	s.Name = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersVolumeMounts) SetReadOnly(v bool) *CreateEciScalingConfigurationRequestContainersVolumeMounts {
	s.ReadOnly = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestContainersVolumeMounts) SetSubPath(v string) *CreateEciScalingConfigurationRequestContainersVolumeMounts {
	s.SubPath = &v
	return s
}

type CreateEciScalingConfigurationRequestDnsConfigOptions struct {
	// The variable name of the option.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The variable value of the option.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateEciScalingConfigurationRequestDnsConfigOptions) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestDnsConfigOptions) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestDnsConfigOptions) SetName(v string) *CreateEciScalingConfigurationRequestDnsConfigOptions {
	s.Name = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestDnsConfigOptions) SetValue(v string) *CreateEciScalingConfigurationRequestDnsConfigOptions {
	s.Value = &v
	return s
}

type CreateEciScalingConfigurationRequestHostAliases struct {
	// The hostname that you want to add.
	Hostnames []*string `json:"Hostnames,omitempty" xml:"Hostnames,omitempty" type:"Repeated"`
	// The IP address that you want to add.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
}

func (s CreateEciScalingConfigurationRequestHostAliases) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestHostAliases) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestHostAliases) SetHostnames(v []*string) *CreateEciScalingConfigurationRequestHostAliases {
	s.Hostnames = v
	return s
}

func (s *CreateEciScalingConfigurationRequestHostAliases) SetIp(v string) *CreateEciScalingConfigurationRequestHostAliases {
	s.Ip = &v
	return s
}

type CreateEciScalingConfigurationRequestImageRegistryCredentials struct {
	// The password that is used to access the image repository.
	Password *string `json:"Password,omitempty" xml:"Password,omitempty"`
	// The domain name of the image repository.
	Server *string `json:"Server,omitempty" xml:"Server,omitempty"`
	// The username that is used to access the image repository.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
}

func (s CreateEciScalingConfigurationRequestImageRegistryCredentials) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestImageRegistryCredentials) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestImageRegistryCredentials) SetPassword(v string) *CreateEciScalingConfigurationRequestImageRegistryCredentials {
	s.Password = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestImageRegistryCredentials) SetServer(v string) *CreateEciScalingConfigurationRequestImageRegistryCredentials {
	s.Server = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestImageRegistryCredentials) SetUserName(v string) *CreateEciScalingConfigurationRequestImageRegistryCredentials {
	s.UserName = &v
	return s
}

type CreateEciScalingConfigurationRequestInitContainers struct {
	SecurityContext *CreateEciScalingConfigurationRequestInitContainersSecurityContext `json:"SecurityContext,omitempty" xml:"SecurityContext,omitempty" require:"true" type:"Struct"`
	// The arguments that correspond to the startup commands of the container. You can specify up to 10 arguments.
	Args []*string `json:"Args,omitempty" xml:"Args,omitempty" type:"Repeated"`
	// The list of commands that you want to run to start the container.
	Commands []*string `json:"Commands,omitempty" xml:"Commands,omitempty" type:"Repeated"`
	// The number of vCPUs that you want to allocate to the container.
	Cpu *float32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The number of GPUs that you want to allocate to the container.
	Gpu *int32 `json:"Gpu,omitempty" xml:"Gpu,omitempty"`
	// The container image.
	Image *string `json:"Image,omitempty" xml:"Image,omitempty"`
	// The image pulling policy.
	ImagePullPolicy *string `json:"ImagePullPolicy,omitempty" xml:"ImagePullPolicy,omitempty"`
	// The environment variables of the init container.
	InitContainerEnvironmentVars []*CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars `json:"InitContainerEnvironmentVars,omitempty" xml:"InitContainerEnvironmentVars,omitempty" type:"Repeated"`
	// The ports of the init container.
	InitContainerPorts []*CreateEciScalingConfigurationRequestInitContainersInitContainerPorts `json:"InitContainerPorts,omitempty" xml:"InitContainerPorts,omitempty" type:"Repeated"`
	// Information about the volume mounts of the init container.
	InitContainerVolumeMounts []*CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts `json:"InitContainerVolumeMounts,omitempty" xml:"InitContainerVolumeMounts,omitempty" type:"Repeated"`
	// The size of the memory. Unit: GiB.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The name of the container.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The working directory.
	WorkingDir *string `json:"WorkingDir,omitempty" xml:"WorkingDir,omitempty"`
}

func (s CreateEciScalingConfigurationRequestInitContainers) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestInitContainers) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetSecurityContext(v *CreateEciScalingConfigurationRequestInitContainersSecurityContext) *CreateEciScalingConfigurationRequestInitContainers {
	s.SecurityContext = v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetArgs(v []*string) *CreateEciScalingConfigurationRequestInitContainers {
	s.Args = v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetCommands(v []*string) *CreateEciScalingConfigurationRequestInitContainers {
	s.Commands = v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetCpu(v float32) *CreateEciScalingConfigurationRequestInitContainers {
	s.Cpu = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetGpu(v int32) *CreateEciScalingConfigurationRequestInitContainers {
	s.Gpu = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetImage(v string) *CreateEciScalingConfigurationRequestInitContainers {
	s.Image = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetImagePullPolicy(v string) *CreateEciScalingConfigurationRequestInitContainers {
	s.ImagePullPolicy = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetInitContainerEnvironmentVars(v []*CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) *CreateEciScalingConfigurationRequestInitContainers {
	s.InitContainerEnvironmentVars = v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetInitContainerPorts(v []*CreateEciScalingConfigurationRequestInitContainersInitContainerPorts) *CreateEciScalingConfigurationRequestInitContainers {
	s.InitContainerPorts = v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetInitContainerVolumeMounts(v []*CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) *CreateEciScalingConfigurationRequestInitContainers {
	s.InitContainerVolumeMounts = v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetMemory(v float32) *CreateEciScalingConfigurationRequestInitContainers {
	s.Memory = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetName(v string) *CreateEciScalingConfigurationRequestInitContainers {
	s.Name = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainers) SetWorkingDir(v string) *CreateEciScalingConfigurationRequestInitContainers {
	s.WorkingDir = &v
	return s
}

type CreateEciScalingConfigurationRequestInitContainersSecurityContext struct {
	Capability             *CreateEciScalingConfigurationRequestInitContainersSecurityContextCapability `json:"Capability,omitempty" xml:"Capability,omitempty" require:"true" type:"Struct"`
	ReadOnlyRootFilesystem *bool                                                                        `json:"ReadOnlyRootFilesystem,omitempty" xml:"ReadOnlyRootFilesystem,omitempty"`
	RunAsUser              *int64                                                                       `json:"RunAsUser,omitempty" xml:"RunAsUser,omitempty"`
}

func (s CreateEciScalingConfigurationRequestInitContainersSecurityContext) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestInitContainersSecurityContext) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestInitContainersSecurityContext) SetCapability(v *CreateEciScalingConfigurationRequestInitContainersSecurityContextCapability) *CreateEciScalingConfigurationRequestInitContainersSecurityContext {
	s.Capability = v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainersSecurityContext) SetReadOnlyRootFilesystem(v bool) *CreateEciScalingConfigurationRequestInitContainersSecurityContext {
	s.ReadOnlyRootFilesystem = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainersSecurityContext) SetRunAsUser(v int64) *CreateEciScalingConfigurationRequestInitContainersSecurityContext {
	s.RunAsUser = &v
	return s
}

type CreateEciScalingConfigurationRequestInitContainersSecurityContextCapability struct {
	Adds []*string `json:"Adds,omitempty" xml:"Adds,omitempty" type:"Repeated"`
}

func (s CreateEciScalingConfigurationRequestInitContainersSecurityContextCapability) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestInitContainersSecurityContextCapability) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestInitContainersSecurityContextCapability) SetAdds(v []*string) *CreateEciScalingConfigurationRequestInitContainersSecurityContextCapability {
	s.Adds = v
	return s
}

type CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars struct {
	// > This parameter is unavailable.
	FieldRefFieldPath *string `json:"FieldRefFieldPath,omitempty" xml:"FieldRefFieldPath,omitempty"`
	// The key of the environment variable. Specify the key in the `[0-9a-zA-Z]` format. The key must be 1 to 128 characters in length. The key can contain underscores (\_) and cannot start with a digit.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the environment variable. The value must be 0 to 256 characters in length.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) SetFieldRefFieldPath(v string) *CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars {
	s.FieldRefFieldPath = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) SetKey(v string) *CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars {
	s.Key = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) SetValue(v string) *CreateEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars {
	s.Value = &v
	return s
}

type CreateEciScalingConfigurationRequestInitContainersInitContainerPorts struct {
	// The port number. Valid values: 1 to 65535.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The type of the protocol. Valid values:
	//
	// *   TCP
	// *   UDP
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s CreateEciScalingConfigurationRequestInitContainersInitContainerPorts) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestInitContainersInitContainerPorts) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestInitContainersInitContainerPorts) SetPort(v int32) *CreateEciScalingConfigurationRequestInitContainersInitContainerPorts {
	s.Port = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainersInitContainerPorts) SetProtocol(v string) *CreateEciScalingConfigurationRequestInitContainersInitContainerPorts {
	s.Protocol = &v
	return s
}

type CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts struct {
	// The path to which the volume is mounted. Data under this path is overwritten by the data on the volume.
	MountPath *string `json:"MountPath,omitempty" xml:"MountPath,omitempty"`
	// The mount propagation settings of the volume . Mount propagation allows volumes that are mounted on one container to be shared with other containers in the same pod, or even with other pods on the same node. Valid values:
	//
	// *   None: The volume mount does not receive subsequent mounts that are mounted to this volume or its subdirectories.
	// *   HostToCotainer: The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories.
	// *   Bidirectional: This value is similar to HostToCotainer. The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories. In addition, all volume mounts that are created by the container are propagated back to the instance and to all containers of all pods that use the same volume.
	MountPropagation *string `json:"MountPropagation,omitempty" xml:"MountPropagation,omitempty"`
	// The name of the volume.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Specifies whether the mount path is read-only.
	//
	// Default value: false.
	ReadOnly *bool `json:"ReadOnly,omitempty" xml:"ReadOnly,omitempty"`
	// The subdirectory of the volume. The elastic container instance can mount different directories of the same volume to different subdirectories of containers.
	SubPath *string `json:"SubPath,omitempty" xml:"SubPath,omitempty"`
}

func (s CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) SetMountPath(v string) *CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts {
	s.MountPath = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) SetMountPropagation(v string) *CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts {
	s.MountPropagation = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) SetName(v string) *CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts {
	s.Name = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) SetReadOnly(v bool) *CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts {
	s.ReadOnly = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) SetSubPath(v string) *CreateEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts {
	s.SubPath = &v
	return s
}

type CreateEciScalingConfigurationRequestSecurityContextSysctls struct {
	// The variable name of the security context in which the elastic container instance runs.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The variable value of the security context in which the elastic container instance runs.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateEciScalingConfigurationRequestSecurityContextSysctls) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestSecurityContextSysctls) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestSecurityContextSysctls) SetName(v string) *CreateEciScalingConfigurationRequestSecurityContextSysctls {
	s.Name = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestSecurityContextSysctls) SetValue(v string) *CreateEciScalingConfigurationRequestSecurityContextSysctls {
	s.Value = &v
	return s
}

type CreateEciScalingConfigurationRequestTags struct {
	// The tag key of the elastic container instance. You can specify 1 to 20 tags.
	//
	// You cannot specify an empty string as a tag key. The tag key can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value of the elastic container instance. You can specify 1 to 20 tags.
	//
	// You can specify an empty string as a tag value. The tag value can be up to 128 characters in length and cannot start with `acs:`. It cannot contain `http://` or `https://`.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateEciScalingConfigurationRequestTags) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestTags) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestTags) SetKey(v string) *CreateEciScalingConfigurationRequestTags {
	s.Key = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestTags) SetValue(v string) *CreateEciScalingConfigurationRequestTags {
	s.Value = &v
	return s
}

type CreateEciScalingConfigurationRequestVolumes struct {
	DiskVolume     *CreateEciScalingConfigurationRequestVolumesDiskVolume     `json:"DiskVolume,omitempty" xml:"DiskVolume,omitempty" require:"true" type:"Struct"`
	EmptyDirVolume *CreateEciScalingConfigurationRequestVolumesEmptyDirVolume `json:"EmptyDirVolume,omitempty" xml:"EmptyDirVolume,omitempty" require:"true" type:"Struct"`
	FlexVolume     *CreateEciScalingConfigurationRequestVolumesFlexVolume     `json:"FlexVolume,omitempty" xml:"FlexVolume,omitempty" require:"true" type:"Struct"`
	HostPathVolume *CreateEciScalingConfigurationRequestVolumesHostPathVolume `json:"HostPathVolume,omitempty" xml:"HostPathVolume,omitempty" require:"true" type:"Struct"`
	NFSVolume      *CreateEciScalingConfigurationRequestVolumesNFSVolume      `json:"NFSVolume,omitempty" xml:"NFSVolume,omitempty" require:"true" type:"Struct"`
	// The paths to the configuration files.
	ConfigFileVolumeConfigFileToPaths []*CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths `json:"ConfigFileVolumeConfigFileToPaths,omitempty" xml:"ConfigFileVolumeConfigFileToPaths,omitempty" type:"Repeated"`
	// The default permissions on the ConfigFile volume.
	ConfigFileVolumeDefaultMode *int32 `json:"ConfigFileVolumeDefaultMode,omitempty" xml:"ConfigFileVolumeDefaultMode,omitempty"`
	// The name of the volume.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the Host file or path. Examples: File, Directory, and Socket.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateEciScalingConfigurationRequestVolumes) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestVolumes) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestVolumes) SetDiskVolume(v *CreateEciScalingConfigurationRequestVolumesDiskVolume) *CreateEciScalingConfigurationRequestVolumes {
	s.DiskVolume = v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumes) SetEmptyDirVolume(v *CreateEciScalingConfigurationRequestVolumesEmptyDirVolume) *CreateEciScalingConfigurationRequestVolumes {
	s.EmptyDirVolume = v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumes) SetFlexVolume(v *CreateEciScalingConfigurationRequestVolumesFlexVolume) *CreateEciScalingConfigurationRequestVolumes {
	s.FlexVolume = v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumes) SetHostPathVolume(v *CreateEciScalingConfigurationRequestVolumesHostPathVolume) *CreateEciScalingConfigurationRequestVolumes {
	s.HostPathVolume = v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumes) SetNFSVolume(v *CreateEciScalingConfigurationRequestVolumesNFSVolume) *CreateEciScalingConfigurationRequestVolumes {
	s.NFSVolume = v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumes) SetConfigFileVolumeConfigFileToPaths(v []*CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths) *CreateEciScalingConfigurationRequestVolumes {
	s.ConfigFileVolumeConfigFileToPaths = v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumes) SetConfigFileVolumeDefaultMode(v int32) *CreateEciScalingConfigurationRequestVolumes {
	s.ConfigFileVolumeDefaultMode = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumes) SetName(v string) *CreateEciScalingConfigurationRequestVolumes {
	s.Name = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumes) SetType(v string) *CreateEciScalingConfigurationRequestVolumes {
	s.Type = &v
	return s
}

type CreateEciScalingConfigurationRequestVolumesDiskVolume struct {
	DiskId   *string `json:"DiskId,omitempty" xml:"DiskId,omitempty"`
	DiskSize *int32  `json:"DiskSize,omitempty" xml:"DiskSize,omitempty"`
	FsType   *string `json:"FsType,omitempty" xml:"FsType,omitempty"`
}

func (s CreateEciScalingConfigurationRequestVolumesDiskVolume) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestVolumesDiskVolume) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestVolumesDiskVolume) SetDiskId(v string) *CreateEciScalingConfigurationRequestVolumesDiskVolume {
	s.DiskId = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumesDiskVolume) SetDiskSize(v int32) *CreateEciScalingConfigurationRequestVolumesDiskVolume {
	s.DiskSize = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumesDiskVolume) SetFsType(v string) *CreateEciScalingConfigurationRequestVolumesDiskVolume {
	s.FsType = &v
	return s
}

type CreateEciScalingConfigurationRequestVolumesEmptyDirVolume struct {
	Medium *string `json:"Medium,omitempty" xml:"Medium,omitempty"`
}

func (s CreateEciScalingConfigurationRequestVolumesEmptyDirVolume) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestVolumesEmptyDirVolume) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestVolumesEmptyDirVolume) SetMedium(v string) *CreateEciScalingConfigurationRequestVolumesEmptyDirVolume {
	s.Medium = &v
	return s
}

type CreateEciScalingConfigurationRequestVolumesFlexVolume struct {
	Driver  *string `json:"Driver,omitempty" xml:"Driver,omitempty"`
	FsType  *string `json:"FsType,omitempty" xml:"FsType,omitempty"`
	Options *string `json:"Options,omitempty" xml:"Options,omitempty"`
}

func (s CreateEciScalingConfigurationRequestVolumesFlexVolume) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestVolumesFlexVolume) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestVolumesFlexVolume) SetDriver(v string) *CreateEciScalingConfigurationRequestVolumesFlexVolume {
	s.Driver = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumesFlexVolume) SetFsType(v string) *CreateEciScalingConfigurationRequestVolumesFlexVolume {
	s.FsType = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumesFlexVolume) SetOptions(v string) *CreateEciScalingConfigurationRequestVolumesFlexVolume {
	s.Options = &v
	return s
}

type CreateEciScalingConfigurationRequestVolumesHostPathVolume struct {
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateEciScalingConfigurationRequestVolumesHostPathVolume) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestVolumesHostPathVolume) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestVolumesHostPathVolume) SetPath(v string) *CreateEciScalingConfigurationRequestVolumesHostPathVolume {
	s.Path = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumesHostPathVolume) SetType(v string) *CreateEciScalingConfigurationRequestVolumesHostPathVolume {
	s.Type = &v
	return s
}

type CreateEciScalingConfigurationRequestVolumesNFSVolume struct {
	Path     *string `json:"Path,omitempty" xml:"Path,omitempty"`
	ReadOnly *bool   `json:"ReadOnly,omitempty" xml:"ReadOnly,omitempty"`
	Server   *string `json:"Server,omitempty" xml:"Server,omitempty"`
}

func (s CreateEciScalingConfigurationRequestVolumesNFSVolume) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestVolumesNFSVolume) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestVolumesNFSVolume) SetPath(v string) *CreateEciScalingConfigurationRequestVolumesNFSVolume {
	s.Path = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumesNFSVolume) SetReadOnly(v bool) *CreateEciScalingConfigurationRequestVolumesNFSVolume {
	s.ReadOnly = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumesNFSVolume) SetServer(v string) *CreateEciScalingConfigurationRequestVolumesNFSVolume {
	s.Server = &v
	return s
}

type CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths struct {
	// The content of the configuration file, which can be up to 32 KB in size.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The permissions on ConfigFileVolume.
	Mode *int32 `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The name of the environment variable. The name must be 1 to 128 characters in length. Specify the name in the `[0-9a-zA-Z]` format. The name can contain underscores and cannot start with a digit.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths) SetContent(v string) *CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths {
	s.Content = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths) SetMode(v int32) *CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths {
	s.Mode = &v
	return s
}

func (s *CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths) SetPath(v string) *CreateEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPaths {
	s.Path = &v
	return s
}

type CreateEciScalingConfigurationResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the elastic container instance.
	ScalingConfigurationId *string `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
}

func (s CreateEciScalingConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationResponseBody) SetRequestId(v string) *CreateEciScalingConfigurationResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateEciScalingConfigurationResponseBody) SetScalingConfigurationId(v string) *CreateEciScalingConfigurationResponseBody {
	s.ScalingConfigurationId = &v
	return s
}

type CreateEciScalingConfigurationResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateEciScalingConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateEciScalingConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateEciScalingConfigurationResponse) GoString() string {
	return s.String()
}

func (s *CreateEciScalingConfigurationResponse) SetHeaders(v map[string]*string) *CreateEciScalingConfigurationResponse {
	s.Headers = v
	return s
}

func (s *CreateEciScalingConfigurationResponse) SetStatusCode(v int32) *CreateEciScalingConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateEciScalingConfigurationResponse) SetBody(v *CreateEciScalingConfigurationResponseBody) *CreateEciScalingConfigurationResponse {
	s.Body = v
	return s
}

type CreateLifecycleHookRequest struct {
	// The action that you want Auto Scaling to perform after the lifecycle hook times out. Valid values:
	//
	// *   CONTINUE: Auto Scaling continues to respond to scale-in or scale-out requests.
	// *   ABANDON: Auto Scaling releases Elastic Compute Service (ECS) instances that are created during scale-out activities, or removes ECS instances from the scaling group during scale-in activities.
	//
	// If multiple lifecycle hooks in a scaling group are triggered during scale-in activities and you set the DefaultResult parameter to ABANDON for one of the lifecycle hooks, Auto Scaling immediately performs the action after the lifecycle hook whose DefaultResult is set to ABANDON times out. As a result, other lifecycle hooks time out ahead of schedule. In other cases, Auto Scaling performs the action only after all lifecycle hooks time out.
	//
	// Default value: CONTINUE.
	DefaultResult *string `json:"DefaultResult,omitempty" xml:"DefaultResult,omitempty"`
	// The period of time before the lifecycle hook times out. After the lifecycle hook times out, Auto Scaling performs the default action. Valid values: 30 to 21600. Unit: seconds.
	//
	// After you create a lifecycle hook, you can call the RecordLifecycleActionHeartbeat operation to prolong the timeout period of the lifecycle hook. You can also call the CompleteLifecycleAction operation to end the timeout period of the lifecycle hook ahead of schedule.
	//
	// Default value: 600.
	HeartbeatTimeout *int32 `json:"HeartbeatTimeout,omitempty" xml:"HeartbeatTimeout,omitempty"`
	// The name of the lifecycle hook. Each lifecycle hook name must be unique within a scaling group. The name must be 2 to 64 characters in length, and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). It must start with a letter or a digit.
	//
	// If you do not specify this parameter, the value of the LifecycleHookId parameter is used.
	LifecycleHookName *string `json:"LifecycleHookName,omitempty" xml:"LifecycleHookName,omitempty"`
	// The type of the scaling activity to which the lifecycle hook applies. Valid values:
	//
	// *   SCALE_OUT
	// *   SCALE_IN
	LifecycleTransition *string `json:"LifecycleTransition,omitempty" xml:"LifecycleTransition,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the notification method that is used by Auto Scaling to send notifications when the lifecycle hook takes effect. If you do not specify this parameter, no notification is sent when the lifecycle hook takes effect. If you specify this parameter, the following rules apply:
	//
	// *   If you use a Message Service (MNS) queue as the notification method, specify the value in the acs:mns:{region-id}:{account-id}:queue/{queuename} format.
	// *   If you use an MNS topic as the notification method, specify the value in the acs:mns:{region-id}:{account-id}:topic/{topicname} format.
	// *   If you use an OOS template as the notification method, specify the value in the acs:oos:{region-id}:{account-id}:template/{templatename} format.
	//
	// The variables in the preceding parameter formats have the following meanings:
	//
	// *   region-id: the region ID of the scaling group.
	// *   account-id: the ID of the Alibaba Cloud account. The ID of the RAM user is not supported.
	// *   queuename: the name of the MNS queue.
	// *   topicname: the name of the MNS topic.
	// *   templatename: the name of the OOS template.
	NotificationArn *string `json:"NotificationArn,omitempty" xml:"NotificationArn,omitempty"`
	// The notification metadata that is sent when the lifecycle hook takes effect. This helps you manage and categorize notifications in an efficient manner. If you specify this parameter, you must specify the NotificationArn parameter. The parameter value cannot exceed 4,096 characters in length.
	//
	// If you use the NotificationArn parameter to specify a public or customOOS template, the value of the NotificationMetadata parameter must be a JSON string that contains the OOS template parameters. For example, your OOS template includes the following parameters: `{"dbInstanceId": "dds-bp17661e0135****", "modifyMode": "Append"}`, `dbInstanceId`, and `modifyMode`. Some parameters defined in your OOS template have default values. When you specify the NotificationMetadata parameter, specify parameters that do not have default values. If you specify parameters that have default values, the default values are overwritten. However, the default values of the following parameters must be retained to obtain information about scaling activities that are in progress:
	//
	// *   `regionId`: the region ID of the scaling activity that is in progress. Default value: ${regionId}.
	// *   `instanceIds`: the IDs of ECS instances that are scaled in in the scaling activity. Default value: ${instanceIds}.
	// *   `lifecycleHookId`: the ID of the lifecycle hook. Default value: ${lifecycleHookId}.
	// *   `lifecycleActionToken`: the token of the lifecycle action. You can use the token to end the timeout period of the lifecycle hook ahead of schedule. Default value: ${lifecycleActionToken}
	// *   `scalingGroupId`: the ID of the scaling group in which the scaling activity is executed. Default value: ${scalingGroupId}.
	//
	// > You can obtain template parameter information in the [OOS console](https://oos.console.aliyun.com/).
	NotificationMetadata *string `json:"NotificationMetadata,omitempty" xml:"NotificationMetadata,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s CreateLifecycleHookRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateLifecycleHookRequest) GoString() string {
	return s.String()
}

func (s *CreateLifecycleHookRequest) SetDefaultResult(v string) *CreateLifecycleHookRequest {
	s.DefaultResult = &v
	return s
}

func (s *CreateLifecycleHookRequest) SetHeartbeatTimeout(v int32) *CreateLifecycleHookRequest {
	s.HeartbeatTimeout = &v
	return s
}

func (s *CreateLifecycleHookRequest) SetLifecycleHookName(v string) *CreateLifecycleHookRequest {
	s.LifecycleHookName = &v
	return s
}

func (s *CreateLifecycleHookRequest) SetLifecycleTransition(v string) *CreateLifecycleHookRequest {
	s.LifecycleTransition = &v
	return s
}

func (s *CreateLifecycleHookRequest) SetNotificationArn(v string) *CreateLifecycleHookRequest {
	s.NotificationArn = &v
	return s
}

func (s *CreateLifecycleHookRequest) SetNotificationMetadata(v string) *CreateLifecycleHookRequest {
	s.NotificationMetadata = &v
	return s
}

func (s *CreateLifecycleHookRequest) SetOwnerAccount(v string) *CreateLifecycleHookRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateLifecycleHookRequest) SetOwnerId(v int64) *CreateLifecycleHookRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateLifecycleHookRequest) SetResourceOwnerAccount(v string) *CreateLifecycleHookRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateLifecycleHookRequest) SetScalingGroupId(v string) *CreateLifecycleHookRequest {
	s.ScalingGroupId = &v
	return s
}

type CreateLifecycleHookResponseBody struct {
	// The ID of the lifecycle hook.
	LifecycleHookId *string `json:"LifecycleHookId,omitempty" xml:"LifecycleHookId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateLifecycleHookResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateLifecycleHookResponseBody) GoString() string {
	return s.String()
}

func (s *CreateLifecycleHookResponseBody) SetLifecycleHookId(v string) *CreateLifecycleHookResponseBody {
	s.LifecycleHookId = &v
	return s
}

func (s *CreateLifecycleHookResponseBody) SetRequestId(v string) *CreateLifecycleHookResponseBody {
	s.RequestId = &v
	return s
}

type CreateLifecycleHookResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateLifecycleHookResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateLifecycleHookResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateLifecycleHookResponse) GoString() string {
	return s.String()
}

func (s *CreateLifecycleHookResponse) SetHeaders(v map[string]*string) *CreateLifecycleHookResponse {
	s.Headers = v
	return s
}

func (s *CreateLifecycleHookResponse) SetStatusCode(v int32) *CreateLifecycleHookResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateLifecycleHookResponse) SetBody(v *CreateLifecycleHookResponseBody) *CreateLifecycleHookResponse {
	s.Body = v
	return s
}

type CreateNotificationConfigurationRequest struct {
	// The types of the notifications that you want to create. You can create one to eight notifications. Specify multiple values in the repeated list form.
	//
	// You can call the DescribeNotificationTypes operation to query the values of this parameter.
	NotificationArn *string `json:"NotificationArn,omitempty" xml:"NotificationArn,omitempty"`
	// The types of the notifications that you want to create. You can create one to eight notifications. Specify multiple values in the repeated list form.
	//
	// You can call the DescribeNotificationTypes operation to query the values of this parameter.
	NotificationTypes []*string `json:"NotificationTypes,omitempty" xml:"NotificationTypes,omitempty" type:"Repeated"`
	OwnerId           *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the notification method. The following list describes the value formats of this parameter:
	//
	// *   If you use CloudMonitor as the notification method, the value format of this parameter is acs:ess:{region-id}:{account-id}:cloudmonitor.
	// *   If you use an MNS queue as the notification method, the value format of this parameter is acs:mns:{region-id}:{account-id}:queue/{queuename}.
	// *   If you use an MNS topic as the notification method, the value format of this parameter is acs:mns:{region-id}:{account-id}:topic/{topicname}.
	//
	// The variables in the preceding formats have the following meanings:
	//
	// *   region-id: the region ID of the scaling group.
	// *   account-id: the ID of the Alibaba Cloud account.
	// *   queuename: the name of the MNS queue.
	// *   topicname: the name of the MNS topic.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s CreateNotificationConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateNotificationConfigurationRequest) GoString() string {
	return s.String()
}

func (s *CreateNotificationConfigurationRequest) SetNotificationArn(v string) *CreateNotificationConfigurationRequest {
	s.NotificationArn = &v
	return s
}

func (s *CreateNotificationConfigurationRequest) SetNotificationTypes(v []*string) *CreateNotificationConfigurationRequest {
	s.NotificationTypes = v
	return s
}

func (s *CreateNotificationConfigurationRequest) SetOwnerId(v int64) *CreateNotificationConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateNotificationConfigurationRequest) SetRegionId(v string) *CreateNotificationConfigurationRequest {
	s.RegionId = &v
	return s
}

func (s *CreateNotificationConfigurationRequest) SetResourceOwnerAccount(v string) *CreateNotificationConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateNotificationConfigurationRequest) SetScalingGroupId(v string) *CreateNotificationConfigurationRequest {
	s.ScalingGroupId = &v
	return s
}

type CreateNotificationConfigurationResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateNotificationConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateNotificationConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *CreateNotificationConfigurationResponseBody) SetRequestId(v string) *CreateNotificationConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type CreateNotificationConfigurationResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateNotificationConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateNotificationConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateNotificationConfigurationResponse) GoString() string {
	return s.String()
}

func (s *CreateNotificationConfigurationResponse) SetHeaders(v map[string]*string) *CreateNotificationConfigurationResponse {
	s.Headers = v
	return s
}

func (s *CreateNotificationConfigurationResponse) SetStatusCode(v int32) *CreateNotificationConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateNotificationConfigurationResponse) SetBody(v *CreateNotificationConfigurationResponseBody) *CreateNotificationConfigurationResponse {
	s.Body = v
	return s
}

type CreateScalingConfigurationRequest struct {
	PrivatePoolOptions *CreateScalingConfigurationRequestPrivatePoolOptions `json:"PrivatePoolOptions,omitempty" xml:"PrivatePoolOptions,omitempty" type:"Struct"`
	SystemDisk         *CreateScalingConfigurationRequestSystemDisk         `json:"SystemDisk,omitempty" xml:"SystemDisk,omitempty" type:"Struct"`
	// Specifies whether to associate the instance on a dedicated host with the dedicated host. Valid values:
	//
	// *   default: does not associate the instance with the dedicated host. If you start an instance that was stopped in economical mode and the original dedicated host of the instance has insufficient resources, the instance is automatically deployed to another dedicated host in the automatic deployment resource pool.
	// *   host: associates the instance with the dedicated host. If you start an instance that was stopped in economical mode, the instance remains on the original dedicated host. If the original dedicated host of the instance has insufficient resources, you cannot start the instance.
	//
	// Default value: default.
	Affinity *string `json:"Affinity,omitempty" xml:"Affinity,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request](~~25693~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The number of vCPUs.
	//
	// You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. If you specify the Cpu and Memory parameters, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.
	//
	// > You can specify the Cpu and Memory parameters to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The performance mode of the burstable instance. Valid values:
	//
	// *   Standard: standard mode
	// *   Unlimited: unlimited mode
	//
	// For more information, see the "Performance modes" section in the [Overview](~~59977~~) topic.
	CreditSpecification *string `json:"CreditSpecification,omitempty" xml:"CreditSpecification,omitempty"`
	// Details of the data disks.
	DataDisks []*CreateScalingConfigurationRequestDataDisks `json:"DataDisks,omitempty" xml:"DataDisks,omitempty" type:"Repeated"`
	// The ID of the dedicated host on which you want to create the ECS instance. You cannot create preemptible instances on dedicated hosts. Therefore, if you configure the DedicatedHostId parameter, the SpotStrategy and SpotPriceLimit parameters are ignored.
	//
	// You can call the DescribeDedicatedHosts operation to query dedicated host IDs.
	DedicatedHostId *string `json:"DedicatedHostId,omitempty" xml:"DedicatedHostId,omitempty"`
	// The ID of the deployment set to which the ECS instance belongs.
	DeploymentSetId *string `json:"DeploymentSetId,omitempty" xml:"DeploymentSetId,omitempty"`
	// The hostname of the ECS instance. The hostname cannot start or end with a period (.) or a hyphen (-). The hostname cannot contain consecutive periods (.) or hyphens (-). Naming conventions for different types of instances:
	//
	// *   Windows instances: The hostname must be 2 to 15 characters in length, and can contain letters, digits, and hyphens (-). The hostname cannot contain periods (.) or contain only digits.
	// *   Other instances such as Linux instances: The hostname must be 2 to 64 characters in length. You can use periods (.) to separate a hostname into multiple segments. Each segment can contain letters, digits, and hyphens (-).
	HostName *string `json:"HostName,omitempty" xml:"HostName,omitempty"`
	// The ID of the Elastic High Performance Computing (E-HPC) cluster to which the ECS instance belongs.
	HpcClusterId *string `json:"HpcClusterId,omitempty" xml:"HpcClusterId,omitempty"`
	// The name of the image family. You can specify this parameter to obtain the latest custom images that are available in the specified image family. The images are used to create ECS instances. If you specify the ImageId parameter, you cannot specify the ImageFamily parameter.
	ImageFamily *string `json:"ImageFamily,omitempty" xml:"ImageFamily,omitempty"`
	// The ID of the image that is used by Auto Scaling to automatically create instances.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The name of the image. Each image name must be unique within a region. If you specify the ImageId parameter, the ImageName parameter is ignored.
	//
	// You cannot use the ImageName parameter to specify images that are purchased from Alibaba Cloud Marketplace.
	ImageName *string `json:"ImageName,omitempty" xml:"ImageName,omitempty"`
	// The description of the ECS instance. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
	InstanceDescription *string `json:"InstanceDescription,omitempty" xml:"InstanceDescription,omitempty"`
	// The name of the ECS instance that is automatically created based on the scaling configuration.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// Information about the intelligent configuration settings, which determines the available instance types.
	InstancePatternInfos []*CreateScalingConfigurationRequestInstancePatternInfos `json:"InstancePatternInfos,omitempty" xml:"InstancePatternInfos,omitempty" type:"Repeated"`
	// The instance type of the ECS instance. For more information, see the "Instance family" topic in ECS documentation.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// Information about the instance type.
	InstanceTypeOverrides []*CreateScalingConfigurationRequestInstanceTypeOverrides `json:"InstanceTypeOverrides,omitempty" xml:"InstanceTypeOverrides,omitempty" type:"Repeated"`
	// The instance types. If you specify this parameter, the InstanceType parameter is ignored. You can specify up to 10 instance types in a scaling configuration.
	//
	// The first instance type has the highest priority. The priority decreases based on the specified order of instance types. Auto Scaling creates instances based on the priorities of the instance types. If Auto Scaling cannot create instances of the instance type that has the highest priority, Auto Scaling creates instances of the instance type that has the next highest priority.
	InstanceTypes []*string `json:"InstanceTypes,omitempty" xml:"InstanceTypes,omitempty" type:"Repeated"`
	// The billing method for network usage. Valid values:
	//
	// *   PayByBandwidth: You are charged for the maximum available bandwidth that is specified by the InternetMaxBandwidthOut parameter.
	// *   PayByTraffic: You are charged for the actual traffic that is used. The InternetMaxBandwidthOut parameter specifies only the maximum available bandwidth.
	//
	// Default value for the classic network: PayByBandwidth. Default value for VPCs: PayByTraffic.
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The maximum inbound public bandwidth. Unit: Mbit/s. Valid values: 1 to 200.
	//
	// Default value: 200. This parameter is not used for billing because inbound traffic to instances is free of charge.
	InternetMaxBandwidthIn *int32 `json:"InternetMaxBandwidthIn,omitempty" xml:"InternetMaxBandwidthIn,omitempty"`
	// The maximum outbound public bandwidth. Unit: Mbit/s.
	//
	// *   Valid values if you set the InternetChargeType parameter to PayByBandwidth: 0 to 100. If you do not specify this parameter, 0 is used as the value of this parameter.
	// *   Valid values if you set the InternetChargeType parameter to PayByTraffic: 0 to 100. If you do not specify this parameter, an error will be reported.
	InternetMaxBandwidthOut *int32 `json:"InternetMaxBandwidthOut,omitempty" xml:"InternetMaxBandwidthOut,omitempty"`
	// Specifies whether to create an I/O optimized instance. Valid values:
	//
	// none: does not create an I/O optimized instance. optimized: creates an I/O optimized instance.
	//
	// For instances of retired instance types, the default value is none. For instances of other instance types, the default value is optimized.
	IoOptimized *string `json:"IoOptimized,omitempty" xml:"IoOptimized,omitempty"`
	// The number of randomly generated IPv6 addresses that you want to allocate to the ENI.
	Ipv6AddressCount *int32 `json:"Ipv6AddressCount,omitempty" xml:"Ipv6AddressCount,omitempty"`
	// The name of the key pair that is used to log on to the ECS instance.
	//
	// *   Windows instances do not use this parameter.
	// *   By default, the username and password authentication method is disabled for Linux instances.
	KeyPairName *string `json:"KeyPairName,omitempty" xml:"KeyPairName,omitempty"`
	// The weight of the ECS instance as a backend server. Valid values: 1 to 100.
	//
	// Default value: 50.
	LoadBalancerWeight *int32 `json:"LoadBalancerWeight,omitempty" xml:"LoadBalancerWeight,omitempty"`
	// The size of the memory. Unit: GiB.
	//
	// You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. If you specify the Cpu and Memory parameters, Auto Scaling determines available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.
	//
	// > You can specify the Cpu and Memory parameters to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
	Memory       *int32  `json:"Memory,omitempty" xml:"Memory,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The password that is used to log on to the ECS instance. The password must be 8 to 30 characters in length, and contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. Special characters include:
	//
	// \`()`  ~!@#$%^&*-_+=\|{}[]:;\"<>,.?/ `
	//
	// The password of a Windows instance cannot start with a forward slash (/).
	//
	// > For security reasons, we recommend that you use HTTPS to send requests if the Password parameter is specified.
	Password *string `json:"Password,omitempty" xml:"Password,omitempty"`
	// Specifies whether to use the password that is preconfigured in the image. Before you use this parameter, make sure that a password is configured for the image. Valid values:
	//
	// *   true
	// *   false
	PasswordInherit *bool `json:"PasswordInherit,omitempty" xml:"PasswordInherit,omitempty"`
	// The name of the RAM role that is associated with the ECS instance. The name is provided and maintained by Resource Access Management (RAM). You can call the ListRoles operation to query the available RAM roles.
	RamRoleName *string `json:"RamRoleName,omitempty" xml:"RamRoleName,omitempty"`
	// The ID of the resource group to which the ECS instance belongs.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The name of the scaling configuration. The name must be 2 to 64 characters in length and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). The name must start with a letter or a digit.
	//
	// The name of the scaling configuration must be unique in a region. If you do not specify this parameter, the scaling configuration ID is used.
	ScalingConfigurationName *string `json:"ScalingConfigurationName,omitempty" xml:"ScalingConfigurationName,omitempty"`
	// The ID of the scaling group in which you want to create the scaling configuration.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The options of the scheduler.
	SchedulerOptions map[string]interface{} `json:"SchedulerOptions,omitempty" xml:"SchedulerOptions,omitempty"`
	// Specifies whether to enable security hardening. Valid values:
	//
	// *   Active: enables security hardening. This value is applicable only to public images.
	// *   Deactive: does not enable security hardening. This value is applicable to all images.
	SecurityEnhancementStrategy *string `json:"SecurityEnhancementStrategy,omitempty" xml:"SecurityEnhancementStrategy,omitempty"`
	// The ID of the security group with which the ECS instance is associated. The ECS instances that are associated with the same security group can access each other.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// The IDs of the security groups with which you want to associate the ECS instance. You can associate only a limited number of security groups with an ECS instance. For more information, see the "Security group limits" section in [Limits](~~25412~~).
	//
	// > You cannot specify the SecurityGroupId and SecurityGroupIds parameters at the same time.
	SecurityGroupIds []*string `json:"SecurityGroupIds,omitempty" xml:"SecurityGroupIds,omitempty" type:"Repeated"`
	// The retention period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.
	//
	// *   The following retention periods are available in invitational preview: 2, 3, 4, 5, and 6 hours. If you want to set this parameter to one of these values, submit a ticket.
	// *   If you set this parameter to 0, no retention period is specified for the preemptible instance.
	//
	// Default value: 1.
	SpotDuration *int32 `json:"SpotDuration,omitempty" xml:"SpotDuration,omitempty"`
	// The interruption event of the preemptible instance. Default value: Terminate. Set the value to Terminate, which specifies that the preemptible instance is to be released.
	SpotInterruptionBehavior *string `json:"SpotInterruptionBehavior,omitempty" xml:"SpotInterruptionBehavior,omitempty"`
	// The billing information about the preemptible instance.
	SpotPriceLimits []*CreateScalingConfigurationRequestSpotPriceLimits `json:"SpotPriceLimits,omitempty" xml:"SpotPriceLimits,omitempty" type:"Repeated"`
	// The preemption policy that you want to apply to pay-as-you-go instances and preemptible instances. Valid values:
	//
	// *   NoSpot: The instance is created as a pay-as-you-go instance.
	// *   SpotWithPriceLimit: The instance is a preemptible instance that has a user-defined maximum hourly price.
	// *   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.
	//
	// Default value: NoSpot.
	SpotStrategy *string `json:"SpotStrategy,omitempty" xml:"SpotStrategy,omitempty"`
	// The categories of the system disks. You can specify one to four disk categories in a scaling configuration. The first disk category that is specified in a scaling configuration has the highest priority. The priority deceases based on the specified order of disk categories. If Auto Scaling cannot create instances by using the system disk that has the highest priority, Auto Scaling creates instances by using the system disk that has the next highest priority. Valid values:
	//
	// *   cloud: basic disk
	// *   cloud_efficiency: ultra disk
	// *   cloud_ssd: standard SSD
	// *   cloud_essd: ESSD
	//
	// > You cannot specify the SystemDiskCategories and `SystemDiskCategory` parameters at the same time.
	SystemDiskCategories []*string `json:"SystemDiskCategories,omitempty" xml:"SystemDiskCategories,omitempty" type:"Repeated"`
	// The tags of the ECS instance. The tags must be specified in the key-value pair format. You can specify up to 20 tags. When you specify tag keys and tag values, take note of the following items:
	//
	// *   A tag key can be up to 64 characters in length. The key cannot start with acs: or aliyun and cannot contain `http://` or `https://`. You cannot specify an empty string as a tag key.
	// *   A tag value can be up to 128 characters in length. The value cannot start with acs: or aliyun and cannot contain `http://` or `https://`. You can specify an empty string as a tag value.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// Specifies whether to create an instance on a dedicated host. Valid values:
	//
	// *   default: does not create an instance on a dedicated host.
	// *   host: creates an instance on a dedicated host. If you do not specify the DedicatedHostId parameter, Alibaba Cloud selects a dedicated host for the instance that you want to create.
	//
	// Default value: default.
	Tenancy *string `json:"Tenancy,omitempty" xml:"Tenancy,omitempty"`
	// The user data of the ECS instance. The data must be encoded in Base64. The maximum size of the data before encoding is 16 KB.
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The ID of the zone where the ECS instance resides.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s CreateScalingConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationRequest) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationRequest) SetPrivatePoolOptions(v *CreateScalingConfigurationRequestPrivatePoolOptions) *CreateScalingConfigurationRequest {
	s.PrivatePoolOptions = v
	return s
}

func (s *CreateScalingConfigurationRequest) SetSystemDisk(v *CreateScalingConfigurationRequestSystemDisk) *CreateScalingConfigurationRequest {
	s.SystemDisk = v
	return s
}

func (s *CreateScalingConfigurationRequest) SetAffinity(v string) *CreateScalingConfigurationRequest {
	s.Affinity = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetClientToken(v string) *CreateScalingConfigurationRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetCpu(v int32) *CreateScalingConfigurationRequest {
	s.Cpu = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetCreditSpecification(v string) *CreateScalingConfigurationRequest {
	s.CreditSpecification = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetDataDisks(v []*CreateScalingConfigurationRequestDataDisks) *CreateScalingConfigurationRequest {
	s.DataDisks = v
	return s
}

func (s *CreateScalingConfigurationRequest) SetDedicatedHostId(v string) *CreateScalingConfigurationRequest {
	s.DedicatedHostId = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetDeploymentSetId(v string) *CreateScalingConfigurationRequest {
	s.DeploymentSetId = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetHostName(v string) *CreateScalingConfigurationRequest {
	s.HostName = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetHpcClusterId(v string) *CreateScalingConfigurationRequest {
	s.HpcClusterId = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetImageFamily(v string) *CreateScalingConfigurationRequest {
	s.ImageFamily = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetImageId(v string) *CreateScalingConfigurationRequest {
	s.ImageId = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetImageName(v string) *CreateScalingConfigurationRequest {
	s.ImageName = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetInstanceDescription(v string) *CreateScalingConfigurationRequest {
	s.InstanceDescription = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetInstanceName(v string) *CreateScalingConfigurationRequest {
	s.InstanceName = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetInstancePatternInfos(v []*CreateScalingConfigurationRequestInstancePatternInfos) *CreateScalingConfigurationRequest {
	s.InstancePatternInfos = v
	return s
}

func (s *CreateScalingConfigurationRequest) SetInstanceType(v string) *CreateScalingConfigurationRequest {
	s.InstanceType = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetInstanceTypeOverrides(v []*CreateScalingConfigurationRequestInstanceTypeOverrides) *CreateScalingConfigurationRequest {
	s.InstanceTypeOverrides = v
	return s
}

func (s *CreateScalingConfigurationRequest) SetInstanceTypes(v []*string) *CreateScalingConfigurationRequest {
	s.InstanceTypes = v
	return s
}

func (s *CreateScalingConfigurationRequest) SetInternetChargeType(v string) *CreateScalingConfigurationRequest {
	s.InternetChargeType = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetInternetMaxBandwidthIn(v int32) *CreateScalingConfigurationRequest {
	s.InternetMaxBandwidthIn = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetInternetMaxBandwidthOut(v int32) *CreateScalingConfigurationRequest {
	s.InternetMaxBandwidthOut = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetIoOptimized(v string) *CreateScalingConfigurationRequest {
	s.IoOptimized = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetIpv6AddressCount(v int32) *CreateScalingConfigurationRequest {
	s.Ipv6AddressCount = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetKeyPairName(v string) *CreateScalingConfigurationRequest {
	s.KeyPairName = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetLoadBalancerWeight(v int32) *CreateScalingConfigurationRequest {
	s.LoadBalancerWeight = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetMemory(v int32) *CreateScalingConfigurationRequest {
	s.Memory = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetOwnerAccount(v string) *CreateScalingConfigurationRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetOwnerId(v int64) *CreateScalingConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetPassword(v string) *CreateScalingConfigurationRequest {
	s.Password = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetPasswordInherit(v bool) *CreateScalingConfigurationRequest {
	s.PasswordInherit = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetRamRoleName(v string) *CreateScalingConfigurationRequest {
	s.RamRoleName = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetResourceGroupId(v string) *CreateScalingConfigurationRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetResourceOwnerAccount(v string) *CreateScalingConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetScalingConfigurationName(v string) *CreateScalingConfigurationRequest {
	s.ScalingConfigurationName = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetScalingGroupId(v string) *CreateScalingConfigurationRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetSchedulerOptions(v map[string]interface{}) *CreateScalingConfigurationRequest {
	s.SchedulerOptions = v
	return s
}

func (s *CreateScalingConfigurationRequest) SetSecurityEnhancementStrategy(v string) *CreateScalingConfigurationRequest {
	s.SecurityEnhancementStrategy = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetSecurityGroupId(v string) *CreateScalingConfigurationRequest {
	s.SecurityGroupId = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetSecurityGroupIds(v []*string) *CreateScalingConfigurationRequest {
	s.SecurityGroupIds = v
	return s
}

func (s *CreateScalingConfigurationRequest) SetSpotDuration(v int32) *CreateScalingConfigurationRequest {
	s.SpotDuration = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetSpotInterruptionBehavior(v string) *CreateScalingConfigurationRequest {
	s.SpotInterruptionBehavior = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetSpotPriceLimits(v []*CreateScalingConfigurationRequestSpotPriceLimits) *CreateScalingConfigurationRequest {
	s.SpotPriceLimits = v
	return s
}

func (s *CreateScalingConfigurationRequest) SetSpotStrategy(v string) *CreateScalingConfigurationRequest {
	s.SpotStrategy = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetSystemDiskCategories(v []*string) *CreateScalingConfigurationRequest {
	s.SystemDiskCategories = v
	return s
}

func (s *CreateScalingConfigurationRequest) SetTags(v string) *CreateScalingConfigurationRequest {
	s.Tags = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetTenancy(v string) *CreateScalingConfigurationRequest {
	s.Tenancy = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetUserData(v string) *CreateScalingConfigurationRequest {
	s.UserData = &v
	return s
}

func (s *CreateScalingConfigurationRequest) SetZoneId(v string) *CreateScalingConfigurationRequest {
	s.ZoneId = &v
	return s
}

type CreateScalingConfigurationRequestPrivatePoolOptions struct {
	// The ID of the private pool. The ID of a private pool is the same as the ID of the elasticity assurance or capacity reservation for which the private pool is generated.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The type of the private pool that you want to use to start instances. A private pool is generated when an elasticity assurance or a capacity reservation takes effect. You can select a private pool when you start instances. Valid values:
	//
	// *   Open: open private pool. The system selects an open private pool for instance startup. If no open private pool meets your business requirements, the resources in the public pool are used for instance startup. In this case, you do not need to specify the PrivatePoolOptions.Id parameter.
	// *   Target: specified private pool. The resources in the specified private pool are used for instance startup. If the specified private pool is unavailable, the instance startup fails. If you set this parameter to Target, you must specify the PrivatePoolOptions.Id parameter.
	// *   None: no private pool. The resources of private pools are not used for instance startup.
	MatchCriteria *string `json:"MatchCriteria,omitempty" xml:"MatchCriteria,omitempty"`
}

func (s CreateScalingConfigurationRequestPrivatePoolOptions) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationRequestPrivatePoolOptions) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationRequestPrivatePoolOptions) SetId(v string) *CreateScalingConfigurationRequestPrivatePoolOptions {
	s.Id = &v
	return s
}

func (s *CreateScalingConfigurationRequestPrivatePoolOptions) SetMatchCriteria(v string) *CreateScalingConfigurationRequestPrivatePoolOptions {
	s.MatchCriteria = &v
	return s
}

type CreateScalingConfigurationRequestSystemDisk struct {
	// The ID of the automatic snapshot policy that you want to apply to the system disk.
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// Specifies whether to enable the burst feature for the system disk. Valid values:
	//
	// *   true
	// *   false
	//
	// > This parameter is available only if you set the `SystemDisk.Category` parameter to `cloud_auto`.
	//
	// For more information, see [ESSD AutoPL disks](~~368372~~).
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The category of the system disk. Valid values:
	//
	// *   cloud: basic disk.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   ephemeral_ssd: local standard SSD.
	// *   cloud_essd: enhanced SSD (ESSD).
	// *   cloud_auto: ESSD AutoPL disk.
	//
	// You cannot specify the SystemDisk.Category and `SystemDiskCategories` parameters at the same time. If you do not specify the SystemDisk.Category and `SystemDiskCategories` parameters, the default value of the SystemDisk.Category parameter is used. For non-I/O optimized instances of Generation I instance types, the default value is cloud. For instances of other instance types, the default value is cloud_efficiency.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The description of the system disk. The description must be 2 to 256 characters in length. The description can contain letters but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the system disk. The name must be 2 to 128 characters in length. The name must start with a letter but cannot start with `http://` or `https://`. The name can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
	DiskName *string `json:"DiskName,omitempty" xml:"DiskName,omitempty"`
	// The algorithm that is used to encrypt the system disk. Valid values:
	//
	// *   AES-256
	// *   SM4-128
	//
	// Default value: AES-256.
	EncryptAlgorithm *string `json:"EncryptAlgorithm,omitempty" xml:"EncryptAlgorithm,omitempty"`
	// Specifies whether to encrypt the system disk. Valid values:
	//
	// *   true: encrypts the system disk.
	// *   false: does not encrypt the system disk.
	//
	// Default value: false.
	Encrypted *bool `json:"Encrypted,omitempty" xml:"Encrypted,omitempty"`
	// The ID of the KMS key that is used to encrypt the system disk.
	KMSKeyId *string `json:"KMSKeyId,omitempty" xml:"KMSKeyId,omitempty"`
	// The PL of the system disk of the ESSD category. Valid values:
	//
	// *   PL0: An ESSD can deliver up to 10,000 random read/write IOPS.
	// *   PL1: An ESSD can deliver up to 50,000 random read/write IOPS.
	// *   PL2: An ESSD can deliver up to 100,000 random read/write IOPS.
	// *   PL3: An ESSD can deliver up to 1,000,000 random read/write IOPS.
	//
	// Default value: PL0.
	PerformanceLevel *string `json:"PerformanceLevel,omitempty" xml:"PerformanceLevel,omitempty"`
	// The IOPS metric that is preconfigured for the system disk.
	//
	// > IOPS measures the number of read and write operations that an EBS device can process per second.
	ProvisionedIops *int64 `json:"ProvisionedIops,omitempty" xml:"ProvisionedIops,omitempty"`
	// The size of the system disk. Unit: GiB. Valid values: 20 to 500.
	//
	// The value of the SystemDisk.Size parameter must be greater than or equal to max{20, ImageSize}.
	//
	// Default value: max{40, ImageSize}.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
}

func (s CreateScalingConfigurationRequestSystemDisk) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationRequestSystemDisk) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationRequestSystemDisk) SetAutoSnapshotPolicyId(v string) *CreateScalingConfigurationRequestSystemDisk {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *CreateScalingConfigurationRequestSystemDisk) SetBurstingEnabled(v bool) *CreateScalingConfigurationRequestSystemDisk {
	s.BurstingEnabled = &v
	return s
}

func (s *CreateScalingConfigurationRequestSystemDisk) SetCategory(v string) *CreateScalingConfigurationRequestSystemDisk {
	s.Category = &v
	return s
}

func (s *CreateScalingConfigurationRequestSystemDisk) SetDescription(v string) *CreateScalingConfigurationRequestSystemDisk {
	s.Description = &v
	return s
}

func (s *CreateScalingConfigurationRequestSystemDisk) SetDiskName(v string) *CreateScalingConfigurationRequestSystemDisk {
	s.DiskName = &v
	return s
}

func (s *CreateScalingConfigurationRequestSystemDisk) SetEncryptAlgorithm(v string) *CreateScalingConfigurationRequestSystemDisk {
	s.EncryptAlgorithm = &v
	return s
}

func (s *CreateScalingConfigurationRequestSystemDisk) SetEncrypted(v bool) *CreateScalingConfigurationRequestSystemDisk {
	s.Encrypted = &v
	return s
}

func (s *CreateScalingConfigurationRequestSystemDisk) SetKMSKeyId(v string) *CreateScalingConfigurationRequestSystemDisk {
	s.KMSKeyId = &v
	return s
}

func (s *CreateScalingConfigurationRequestSystemDisk) SetPerformanceLevel(v string) *CreateScalingConfigurationRequestSystemDisk {
	s.PerformanceLevel = &v
	return s
}

func (s *CreateScalingConfigurationRequestSystemDisk) SetProvisionedIops(v int64) *CreateScalingConfigurationRequestSystemDisk {
	s.ProvisionedIops = &v
	return s
}

func (s *CreateScalingConfigurationRequestSystemDisk) SetSize(v int32) *CreateScalingConfigurationRequestSystemDisk {
	s.Size = &v
	return s
}

type CreateScalingConfigurationRequestDataDisks struct {
	// The ID of the automatic snapshot policy that you want to apply to the data disk.
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// Specifies whether to enable the burst feature for the system disk. Valid values:
	//
	// *   true
	// *   false
	//
	// > This parameter is available only if you set the `SystemDisk.Category` parameter to `cloud_auto`.
	//
	// For more information, see [ESSD AutoPL disks](~~368372~~).
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The categories of the data disks. You can specify 1 to 16 data disks. You can specify 1 to 4 disk categories in a scaling configuration. The first data disk that is specified in a scaling configuration has the highest priority. The priority deceases based on the specified order of the data disks. If Auto Scaling cannot create instances by using the data disk that has the highest priority, Auto Scaling creates instances by using the data disk that has the next highest priority. Valid values:
	//
	// *   cloud: basic disk. The DeleteWithInstance attribute of a basic disk that is created together with the instance is set to true.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   cloud_essd: ESSD.
	//
	// > You cannot specify the Categories and `Category` parameters at the same time.
	Categories []*string `json:"Categories,omitempty" xml:"Categories,omitempty" type:"Repeated"`
	// The category of the system disk. Valid values:
	//
	// *   cloud: basic disk
	// *   cloud_efficiency: ultra disk
	// *   cloud_ssd: standard SSD
	// *   cloud_essd: ESSD
	// *   ephemeral_ssd: local SSD
	// *   cloud_auto: ESSD AutoPL disk
	//
	// You cannot specify the Category and `SystemDiskCategories` parameters at the same time. If you do not specify the Category and `SystemDiskCategories` parameters, the default value of the Category parameter is used. For non-I/O optimized instances of Generation I instance types, the default value is cloud. For instances of other instance types, the default value is cloud_efficiency.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// Specifies whether to release the data disk when the instance to which the data disk is attached is released. Valid values:
	//
	// *   true: releases the data disk when the instance is released.
	// *   false: retains the data disk when the instance is released.
	//
	// This parameter is available only for independent disks whose Category parameter is set to cloud, cloud_efficiency, cloud_ssd, or cloud_essd. If you specify this parameter for disks of other categories, an error will be reported.
	//
	// Default value: true.
	DeleteWithInstance *bool `json:"DeleteWithInstance,omitempty" xml:"DeleteWithInstance,omitempty"`
	// The description of the data disk. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The mount target of the data disk. If you do not specify the Device parameter, the system automatically assigns a mount target when you create the ECS instance. The name of the mount target ranges from /dev/xvdb to /dev/xvdz.
	Device *string `json:"Device,omitempty" xml:"Device,omitempty"`
	// The name of the system disk. The name must be 2 to 128 characters in length and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). The name must start with a letter and cannot start with `http://` or `https://`.
	DiskName *string `json:"DiskName,omitempty" xml:"DiskName,omitempty"`
	// Specifies whether to encrypt the data disk. Valid values:
	//
	// *   true
	// *   false.
	//
	// Default value: false.
	Encrypted *string `json:"Encrypted,omitempty" xml:"Encrypted,omitempty"`
	// The ID of the Key Management Service (KMS) key that is used to encrypt the data disk.
	KMSKeyId *string `json:"KMSKeyId,omitempty" xml:"KMSKeyId,omitempty"`
	// The PL of the data disk of the ESSD category. If you set the Categories parameter to cloud_essd, you must also specify the PerformanceLevel parameter. Valid values:
	//
	// *   PL0: An ESSD can deliver up to 10,000 random read/write IOPS.
	// *   PL1: An ESSD can deliver up to 50,000 random read/write IOPS.
	// *   PL2: An ESSD can deliver up to 100,000 random read/write IOPS.
	// *   PL3: An ESSD can deliver up to 1,000,000 random read/write IOPS.
	//
	// > For more information about how to choose ESSD PLs, see [ESSD](~~122389~~).
	PerformanceLevel *string `json:"PerformanceLevel,omitempty" xml:"PerformanceLevel,omitempty"`
	// The input/output operations per second (IOPS) metric that is preconfigured for the data disk.
	//
	// > IOPS measures the number of read and write operations that an Elastic Block Storage (EBS) device can process per second.
	ProvisionedIops *int64 `json:"ProvisionedIops,omitempty" xml:"ProvisionedIops,omitempty"`
	// The size of the data disk. Unit: GiB.
	//
	// *   Valid values if you set the Category parameter to cloud: 5 to 2000.
	// *   Valid values if you set the Category parameter to cloud_efficiency: 20 to 32768.
	// *   Valid values if you set the Category parameter to cloud_essd: 20 to 32768.
	// *   Valid values if you set the Category parameter to ephemeral_ssd: 5 to 800.
	//
	// The value of the Size parameter must be greater than or equal to the size of the snapshot that is specified by the SnapshotId parameter.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The ID of the snapshot that is used to create the data disk. If you specify this parameter, the Size parameter is ignored. The size of the disk is the same as the size of the specified snapshot.
	//
	// If you specify a snapshot created on or before July 15, 2013, the operation fails and the system returns InvalidSnapshot.TooOld.
	SnapshotId *string `json:"SnapshotId,omitempty" xml:"SnapshotId,omitempty"`
}

func (s CreateScalingConfigurationRequestDataDisks) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationRequestDataDisks) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationRequestDataDisks) SetAutoSnapshotPolicyId(v string) *CreateScalingConfigurationRequestDataDisks {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetBurstingEnabled(v bool) *CreateScalingConfigurationRequestDataDisks {
	s.BurstingEnabled = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetCategories(v []*string) *CreateScalingConfigurationRequestDataDisks {
	s.Categories = v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetCategory(v string) *CreateScalingConfigurationRequestDataDisks {
	s.Category = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetDeleteWithInstance(v bool) *CreateScalingConfigurationRequestDataDisks {
	s.DeleteWithInstance = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetDescription(v string) *CreateScalingConfigurationRequestDataDisks {
	s.Description = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetDevice(v string) *CreateScalingConfigurationRequestDataDisks {
	s.Device = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetDiskName(v string) *CreateScalingConfigurationRequestDataDisks {
	s.DiskName = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetEncrypted(v string) *CreateScalingConfigurationRequestDataDisks {
	s.Encrypted = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetKMSKeyId(v string) *CreateScalingConfigurationRequestDataDisks {
	s.KMSKeyId = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetPerformanceLevel(v string) *CreateScalingConfigurationRequestDataDisks {
	s.PerformanceLevel = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetProvisionedIops(v int64) *CreateScalingConfigurationRequestDataDisks {
	s.ProvisionedIops = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetSize(v int32) *CreateScalingConfigurationRequestDataDisks {
	s.Size = &v
	return s
}

func (s *CreateScalingConfigurationRequestDataDisks) SetSnapshotId(v string) *CreateScalingConfigurationRequestDataDisks {
	s.SnapshotId = &v
	return s
}

type CreateScalingConfigurationRequestInstancePatternInfos struct {
	// The architectures of the instance types. Valid values:
	//
	// *   X86: x86 architecture.
	// *   Heterogeneous: heterogeneous architecture, such as GPUs and FPGAs.
	// *   BareMetal: ECS Bare Metal Instance architecture.
	// *   Arm: ARM architecture.
	// *   SuperComputeCluster: Super Computing Cluster architecture.
	//
	// By default, all values are selected.
	Architectures []*string `json:"Architectures,omitempty" xml:"Architectures,omitempty" type:"Repeated"`
	// Specifies whether to include burstable instance types. Valid values:
	//
	// *   Exclude: excludes burstable instance types.
	// *   Include: includes burstable instance types.
	// *   Required: includes only burstable instance types.
	//
	// Default value: Include.
	BurstablePerformance *string `json:"BurstablePerformance,omitempty" xml:"BurstablePerformance,omitempty"`
	// The number of vCPUs that is specified for an instance type in the intelligent configuration mode. This parameter is used to filter the available instance types that meet the specified criteria. For more information, see [Instance family](~~25378~~).
	//
	// When you specify the Cores parameter, take note of the following items:
	//
	// *   The InstancePatternInfos parameter is available only for scaling groups that reside in VPCs.
	// *   You must specify the InstancePatternInfos, Cores, and Memory parameters at the same time.
	// *   If you specify an instance type by using the InstanceType or InstanceTypes parameter, Auto Scaling preferentially uses the instance type that is specified by the InstanceType or InstanceTypes parameter for scale-out activities. If the specified instance type does not have sufficient inventory, Auto Scaling creates instances of the instance type that is specified by the InstancePatternInfos parameter based on the price in ascending order.
	Cores *int32 `json:"Cores,omitempty" xml:"Cores,omitempty"`
	// The instance types that you want to filter out. You can use wildcard characters such as an asterisk (\*) to filter out a single instance type or an instance family. Example:
	//
	// *   ecs.c6.large: The ecs.c6.large instance type is filtered out.
	// *   ecs.c6.\*: The c6 instance family is filtered out.
	ExcludedInstanceTypes []*string `json:"ExcludedInstanceTypes,omitempty" xml:"ExcludedInstanceTypes,omitempty" type:"Repeated"`
	// The level of the instance type, which is used to filter the instance types that meet the specified criteria. This parameter takes effect only if you set the `CostOptimization` parameter to true. Valid values:
	//
	// *   EntryLevel: shared instance type. Instances of this level are the most cost-effective but may not provide stable computing performance in a consistent manner. Instances of this level are suitable for business scenarios in which the CPU utilization is low. For more information, see [Shared instance families](~~108489~~).
	// *   EnterpriseLevel: Instances of this level provide stable performance and dedicated resources, and are suitable for business scenarios that require high stability. For more information, see [Instance family](~~25378~~).
	// *   CreditEntryLevel: This value is valid only for burstable instances. CPU credits are used to ensure computing performance. Instances of this level are suitable for scenarios in which the CPU utilization is low but may fluctuate in specific cases. For more information, see the [Overview](~~59977~~) topic of burstable instances.
	InstanceFamilyLevel *string `json:"InstanceFamilyLevel,omitempty" xml:"InstanceFamilyLevel,omitempty"`
	// The maximum hourly price for a pay-as-you-go instance or a preemptible instance in the intelligent configuration mode. This parameter is used to filter the available instance types that meet the specified criteria.
	//
	// > If you set the SpotStrategy parameter to SpotWithPriceLimit, you must specify the MaxPrice parameter. In other cases, you do not need to specify the MaxPrice parameter.
	MaxPrice *float32 `json:"MaxPrice,omitempty" xml:"MaxPrice,omitempty"`
	// The memory size that is specified for an instance type in the intelligent configuration mode. Unit: GiB. This parameter is used to filter the available instance types that meet the specified criteria.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
}

func (s CreateScalingConfigurationRequestInstancePatternInfos) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationRequestInstancePatternInfos) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationRequestInstancePatternInfos) SetArchitectures(v []*string) *CreateScalingConfigurationRequestInstancePatternInfos {
	s.Architectures = v
	return s
}

func (s *CreateScalingConfigurationRequestInstancePatternInfos) SetBurstablePerformance(v string) *CreateScalingConfigurationRequestInstancePatternInfos {
	s.BurstablePerformance = &v
	return s
}

func (s *CreateScalingConfigurationRequestInstancePatternInfos) SetCores(v int32) *CreateScalingConfigurationRequestInstancePatternInfos {
	s.Cores = &v
	return s
}

func (s *CreateScalingConfigurationRequestInstancePatternInfos) SetExcludedInstanceTypes(v []*string) *CreateScalingConfigurationRequestInstancePatternInfos {
	s.ExcludedInstanceTypes = v
	return s
}

func (s *CreateScalingConfigurationRequestInstancePatternInfos) SetInstanceFamilyLevel(v string) *CreateScalingConfigurationRequestInstancePatternInfos {
	s.InstanceFamilyLevel = &v
	return s
}

func (s *CreateScalingConfigurationRequestInstancePatternInfos) SetMaxPrice(v float32) *CreateScalingConfigurationRequestInstancePatternInfos {
	s.MaxPrice = &v
	return s
}

func (s *CreateScalingConfigurationRequestInstancePatternInfos) SetMemory(v float32) *CreateScalingConfigurationRequestInstancePatternInfos {
	s.Memory = &v
	return s
}

type CreateScalingConfigurationRequestInstanceTypeOverrides struct {
	// The instance type that you want to use to overwrite the instance type specified in the launch template.
	//
	// If you want Auto Scaling to scale instances based on the instance type capacity, you must specify the InstanceType parameter and the WeightedCapacity parameter. You can specify 1 to 10 instance types in the extended configurations of the launch template.
	//
	// > This parameter takes effect only if you specify the LaunchTemplateId parameter.
	//
	// You can specify an instance type that is available for purchase as the value of the InstanceType parameter.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The weight of the instance type. The weight of an instance type indicates the capacity of a single instance of the specified instance type in the scaling group. If you want to specify the capacity of a single instance of the specified instance type in the scaling group, you must specify the InstanceType parameter before you specify the WeightedCapacity parameter.
	//
	// A higher weight specifies that a smaller number of instances of the specified instance type are required to meet the expected capacity.
	//
	// Performance metrics, such as the number of vCPUs and the memory size of each instance type, may vary. You can specify different weights for different instance types based on your business requirements.
	//
	// Example:
	//
	// *   Current capacity: 0
	// *   Expected capacity: 6
	// *   Capacity of ecs.c5.xlarge: 4
	//
	// To meet the expected capacity requirement, Auto Scaling must create and add two ecs.c5.xlarge instances.
	//
	// > The capacity of the scaling group cannot exceed the sum of the maximum number of instances that is specified by the MaxSize parameter and the maximum weight of the instance types.
	//
	// Valid values of the WeightedCapacity parameter: 1 to 500.
	WeightedCapacity *int32 `json:"WeightedCapacity,omitempty" xml:"WeightedCapacity,omitempty"`
}

func (s CreateScalingConfigurationRequestInstanceTypeOverrides) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationRequestInstanceTypeOverrides) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationRequestInstanceTypeOverrides) SetInstanceType(v string) *CreateScalingConfigurationRequestInstanceTypeOverrides {
	s.InstanceType = &v
	return s
}

func (s *CreateScalingConfigurationRequestInstanceTypeOverrides) SetWeightedCapacity(v int32) *CreateScalingConfigurationRequestInstanceTypeOverrides {
	s.WeightedCapacity = &v
	return s
}

type CreateScalingConfigurationRequestSpotPriceLimits struct {
	// The instance type of the preemptible instance. This parameter is available only if you set the SpotStrategy parameter to SpotWithPriceLimit.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The price limit of the preemptible instance. This parameter is available only if you set the SpotStrategy parameter to SpotWithPriceLimit.
	PriceLimit *float32 `json:"PriceLimit,omitempty" xml:"PriceLimit,omitempty"`
}

func (s CreateScalingConfigurationRequestSpotPriceLimits) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationRequestSpotPriceLimits) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationRequestSpotPriceLimits) SetInstanceType(v string) *CreateScalingConfigurationRequestSpotPriceLimits {
	s.InstanceType = &v
	return s
}

func (s *CreateScalingConfigurationRequestSpotPriceLimits) SetPriceLimit(v float32) *CreateScalingConfigurationRequestSpotPriceLimits {
	s.PriceLimit = &v
	return s
}

type CreateScalingConfigurationShrinkRequest struct {
	PrivatePoolOptions *CreateScalingConfigurationShrinkRequestPrivatePoolOptions `json:"PrivatePoolOptions,omitempty" xml:"PrivatePoolOptions,omitempty" type:"Struct"`
	SystemDisk         *CreateScalingConfigurationShrinkRequestSystemDisk         `json:"SystemDisk,omitempty" xml:"SystemDisk,omitempty" type:"Struct"`
	// Specifies whether to associate the instance on a dedicated host with the dedicated host. Valid values:
	//
	// *   default: does not associate the instance with the dedicated host. If you start an instance that was stopped in economical mode and the original dedicated host of the instance has insufficient resources, the instance is automatically deployed to another dedicated host in the automatic deployment resource pool.
	// *   host: associates the instance with the dedicated host. If you start an instance that was stopped in economical mode, the instance remains on the original dedicated host. If the original dedicated host of the instance has insufficient resources, you cannot start the instance.
	//
	// Default value: default.
	Affinity *string `json:"Affinity,omitempty" xml:"Affinity,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request](~~25693~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The number of vCPUs.
	//
	// You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. If you specify the Cpu and Memory parameters, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.
	//
	// > You can specify the Cpu and Memory parameters to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The performance mode of the burstable instance. Valid values:
	//
	// *   Standard: standard mode
	// *   Unlimited: unlimited mode
	//
	// For more information, see the "Performance modes" section in the [Overview](~~59977~~) topic.
	CreditSpecification *string `json:"CreditSpecification,omitempty" xml:"CreditSpecification,omitempty"`
	// Details of the data disks.
	DataDisks []*CreateScalingConfigurationShrinkRequestDataDisks `json:"DataDisks,omitempty" xml:"DataDisks,omitempty" type:"Repeated"`
	// The ID of the dedicated host on which you want to create the ECS instance. You cannot create preemptible instances on dedicated hosts. Therefore, if you configure the DedicatedHostId parameter, the SpotStrategy and SpotPriceLimit parameters are ignored.
	//
	// You can call the DescribeDedicatedHosts operation to query dedicated host IDs.
	DedicatedHostId *string `json:"DedicatedHostId,omitempty" xml:"DedicatedHostId,omitempty"`
	// The ID of the deployment set to which the ECS instance belongs.
	DeploymentSetId *string `json:"DeploymentSetId,omitempty" xml:"DeploymentSetId,omitempty"`
	// The hostname of the ECS instance. The hostname cannot start or end with a period (.) or a hyphen (-). The hostname cannot contain consecutive periods (.) or hyphens (-). Naming conventions for different types of instances:
	//
	// *   Windows instances: The hostname must be 2 to 15 characters in length, and can contain letters, digits, and hyphens (-). The hostname cannot contain periods (.) or contain only digits.
	// *   Other instances such as Linux instances: The hostname must be 2 to 64 characters in length. You can use periods (.) to separate a hostname into multiple segments. Each segment can contain letters, digits, and hyphens (-).
	HostName *string `json:"HostName,omitempty" xml:"HostName,omitempty"`
	// The ID of the Elastic High Performance Computing (E-HPC) cluster to which the ECS instance belongs.
	HpcClusterId *string `json:"HpcClusterId,omitempty" xml:"HpcClusterId,omitempty"`
	// The name of the image family. You can specify this parameter to obtain the latest custom images that are available in the specified image family. The images are used to create ECS instances. If you specify the ImageId parameter, you cannot specify the ImageFamily parameter.
	ImageFamily *string `json:"ImageFamily,omitempty" xml:"ImageFamily,omitempty"`
	// The ID of the image that is used by Auto Scaling to automatically create instances.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The name of the image. Each image name must be unique within a region. If you specify the ImageId parameter, the ImageName parameter is ignored.
	//
	// You cannot use the ImageName parameter to specify images that are purchased from Alibaba Cloud Marketplace.
	ImageName *string `json:"ImageName,omitempty" xml:"ImageName,omitempty"`
	// The description of the ECS instance. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
	InstanceDescription *string `json:"InstanceDescription,omitempty" xml:"InstanceDescription,omitempty"`
	// The name of the ECS instance that is automatically created based on the scaling configuration.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// Information about the intelligent configuration settings, which determines the available instance types.
	InstancePatternInfos []*CreateScalingConfigurationShrinkRequestInstancePatternInfos `json:"InstancePatternInfos,omitempty" xml:"InstancePatternInfos,omitempty" type:"Repeated"`
	// The instance type of the ECS instance. For more information, see the "Instance family" topic in ECS documentation.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// Information about the instance type.
	InstanceTypeOverrides []*CreateScalingConfigurationShrinkRequestInstanceTypeOverrides `json:"InstanceTypeOverrides,omitempty" xml:"InstanceTypeOverrides,omitempty" type:"Repeated"`
	// The instance types. If you specify this parameter, the InstanceType parameter is ignored. You can specify up to 10 instance types in a scaling configuration.
	//
	// The first instance type has the highest priority. The priority decreases based on the specified order of instance types. Auto Scaling creates instances based on the priorities of the instance types. If Auto Scaling cannot create instances of the instance type that has the highest priority, Auto Scaling creates instances of the instance type that has the next highest priority.
	InstanceTypes []*string `json:"InstanceTypes,omitempty" xml:"InstanceTypes,omitempty" type:"Repeated"`
	// The billing method for network usage. Valid values:
	//
	// *   PayByBandwidth: You are charged for the maximum available bandwidth that is specified by the InternetMaxBandwidthOut parameter.
	// *   PayByTraffic: You are charged for the actual traffic that is used. The InternetMaxBandwidthOut parameter specifies only the maximum available bandwidth.
	//
	// Default value for the classic network: PayByBandwidth. Default value for VPCs: PayByTraffic.
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The maximum inbound public bandwidth. Unit: Mbit/s. Valid values: 1 to 200.
	//
	// Default value: 200. This parameter is not used for billing because inbound traffic to instances is free of charge.
	InternetMaxBandwidthIn *int32 `json:"InternetMaxBandwidthIn,omitempty" xml:"InternetMaxBandwidthIn,omitempty"`
	// The maximum outbound public bandwidth. Unit: Mbit/s.
	//
	// *   Valid values if you set the InternetChargeType parameter to PayByBandwidth: 0 to 100. If you do not specify this parameter, 0 is used as the value of this parameter.
	// *   Valid values if you set the InternetChargeType parameter to PayByTraffic: 0 to 100. If you do not specify this parameter, an error will be reported.
	InternetMaxBandwidthOut *int32 `json:"InternetMaxBandwidthOut,omitempty" xml:"InternetMaxBandwidthOut,omitempty"`
	// Specifies whether to create an I/O optimized instance. Valid values:
	//
	// none: does not create an I/O optimized instance. optimized: creates an I/O optimized instance.
	//
	// For instances of retired instance types, the default value is none. For instances of other instance types, the default value is optimized.
	IoOptimized *string `json:"IoOptimized,omitempty" xml:"IoOptimized,omitempty"`
	// The number of randomly generated IPv6 addresses that you want to allocate to the ENI.
	Ipv6AddressCount *int32 `json:"Ipv6AddressCount,omitempty" xml:"Ipv6AddressCount,omitempty"`
	// The name of the key pair that is used to log on to the ECS instance.
	//
	// *   Windows instances do not use this parameter.
	// *   By default, the username and password authentication method is disabled for Linux instances.
	KeyPairName *string `json:"KeyPairName,omitempty" xml:"KeyPairName,omitempty"`
	// The weight of the ECS instance as a backend server. Valid values: 1 to 100.
	//
	// Default value: 50.
	LoadBalancerWeight *int32 `json:"LoadBalancerWeight,omitempty" xml:"LoadBalancerWeight,omitempty"`
	// The size of the memory. Unit: GiB.
	//
	// You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. If you specify the Cpu and Memory parameters, Auto Scaling determines available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.
	//
	// > You can specify the Cpu and Memory parameters to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
	Memory       *int32  `json:"Memory,omitempty" xml:"Memory,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The password that is used to log on to the ECS instance. The password must be 8 to 30 characters in length, and contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. Special characters include:
	//
	// \`()`  ~!@#$%^&*-_+=\|{}[]:;\"<>,.?/ `
	//
	// The password of a Windows instance cannot start with a forward slash (/).
	//
	// > For security reasons, we recommend that you use HTTPS to send requests if the Password parameter is specified.
	Password *string `json:"Password,omitempty" xml:"Password,omitempty"`
	// Specifies whether to use the password that is preconfigured in the image. Before you use this parameter, make sure that a password is configured for the image. Valid values:
	//
	// *   true
	// *   false
	PasswordInherit *bool `json:"PasswordInherit,omitempty" xml:"PasswordInherit,omitempty"`
	// The name of the RAM role that is associated with the ECS instance. The name is provided and maintained by Resource Access Management (RAM). You can call the ListRoles operation to query the available RAM roles.
	RamRoleName *string `json:"RamRoleName,omitempty" xml:"RamRoleName,omitempty"`
	// The ID of the resource group to which the ECS instance belongs.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The name of the scaling configuration. The name must be 2 to 64 characters in length and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). The name must start with a letter or a digit.
	//
	// The name of the scaling configuration must be unique in a region. If you do not specify this parameter, the scaling configuration ID is used.
	ScalingConfigurationName *string `json:"ScalingConfigurationName,omitempty" xml:"ScalingConfigurationName,omitempty"`
	// The ID of the scaling group in which you want to create the scaling configuration.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The options of the scheduler.
	SchedulerOptionsShrink *string `json:"SchedulerOptions,omitempty" xml:"SchedulerOptions,omitempty"`
	// Specifies whether to enable security hardening. Valid values:
	//
	// *   Active: enables security hardening. This value is applicable only to public images.
	// *   Deactive: does not enable security hardening. This value is applicable to all images.
	SecurityEnhancementStrategy *string `json:"SecurityEnhancementStrategy,omitempty" xml:"SecurityEnhancementStrategy,omitempty"`
	// The ID of the security group with which the ECS instance is associated. The ECS instances that are associated with the same security group can access each other.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// The IDs of the security groups with which you want to associate the ECS instance. You can associate only a limited number of security groups with an ECS instance. For more information, see the "Security group limits" section in [Limits](~~25412~~).
	//
	// > You cannot specify the SecurityGroupId and SecurityGroupIds parameters at the same time.
	SecurityGroupIds []*string `json:"SecurityGroupIds,omitempty" xml:"SecurityGroupIds,omitempty" type:"Repeated"`
	// The retention period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.
	//
	// *   The following retention periods are available in invitational preview: 2, 3, 4, 5, and 6 hours. If you want to set this parameter to one of these values, submit a ticket.
	// *   If you set this parameter to 0, no retention period is specified for the preemptible instance.
	//
	// Default value: 1.
	SpotDuration *int32 `json:"SpotDuration,omitempty" xml:"SpotDuration,omitempty"`
	// The interruption event of the preemptible instance. Default value: Terminate. Set the value to Terminate, which specifies that the preemptible instance is to be released.
	SpotInterruptionBehavior *string `json:"SpotInterruptionBehavior,omitempty" xml:"SpotInterruptionBehavior,omitempty"`
	// The billing information about the preemptible instance.
	SpotPriceLimits []*CreateScalingConfigurationShrinkRequestSpotPriceLimits `json:"SpotPriceLimits,omitempty" xml:"SpotPriceLimits,omitempty" type:"Repeated"`
	// The preemption policy that you want to apply to pay-as-you-go instances and preemptible instances. Valid values:
	//
	// *   NoSpot: The instance is created as a pay-as-you-go instance.
	// *   SpotWithPriceLimit: The instance is a preemptible instance that has a user-defined maximum hourly price.
	// *   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.
	//
	// Default value: NoSpot.
	SpotStrategy *string `json:"SpotStrategy,omitempty" xml:"SpotStrategy,omitempty"`
	// The categories of the system disks. You can specify one to four disk categories in a scaling configuration. The first disk category that is specified in a scaling configuration has the highest priority. The priority deceases based on the specified order of disk categories. If Auto Scaling cannot create instances by using the system disk that has the highest priority, Auto Scaling creates instances by using the system disk that has the next highest priority. Valid values:
	//
	// *   cloud: basic disk
	// *   cloud_efficiency: ultra disk
	// *   cloud_ssd: standard SSD
	// *   cloud_essd: ESSD
	//
	// > You cannot specify the SystemDiskCategories and `SystemDiskCategory` parameters at the same time.
	SystemDiskCategories []*string `json:"SystemDiskCategories,omitempty" xml:"SystemDiskCategories,omitempty" type:"Repeated"`
	// The tags of the ECS instance. The tags must be specified in the key-value pair format. You can specify up to 20 tags. When you specify tag keys and tag values, take note of the following items:
	//
	// *   A tag key can be up to 64 characters in length. The key cannot start with acs: or aliyun and cannot contain `http://` or `https://`. You cannot specify an empty string as a tag key.
	// *   A tag value can be up to 128 characters in length. The value cannot start with acs: or aliyun and cannot contain `http://` or `https://`. You can specify an empty string as a tag value.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// Specifies whether to create an instance on a dedicated host. Valid values:
	//
	// *   default: does not create an instance on a dedicated host.
	// *   host: creates an instance on a dedicated host. If you do not specify the DedicatedHostId parameter, Alibaba Cloud selects a dedicated host for the instance that you want to create.
	//
	// Default value: default.
	Tenancy *string `json:"Tenancy,omitempty" xml:"Tenancy,omitempty"`
	// The user data of the ECS instance. The data must be encoded in Base64. The maximum size of the data before encoding is 16 KB.
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The ID of the zone where the ECS instance resides.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s CreateScalingConfigurationShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationShrinkRequest) SetPrivatePoolOptions(v *CreateScalingConfigurationShrinkRequestPrivatePoolOptions) *CreateScalingConfigurationShrinkRequest {
	s.PrivatePoolOptions = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetSystemDisk(v *CreateScalingConfigurationShrinkRequestSystemDisk) *CreateScalingConfigurationShrinkRequest {
	s.SystemDisk = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetAffinity(v string) *CreateScalingConfigurationShrinkRequest {
	s.Affinity = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetClientToken(v string) *CreateScalingConfigurationShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetCpu(v int32) *CreateScalingConfigurationShrinkRequest {
	s.Cpu = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetCreditSpecification(v string) *CreateScalingConfigurationShrinkRequest {
	s.CreditSpecification = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetDataDisks(v []*CreateScalingConfigurationShrinkRequestDataDisks) *CreateScalingConfigurationShrinkRequest {
	s.DataDisks = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetDedicatedHostId(v string) *CreateScalingConfigurationShrinkRequest {
	s.DedicatedHostId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetDeploymentSetId(v string) *CreateScalingConfigurationShrinkRequest {
	s.DeploymentSetId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetHostName(v string) *CreateScalingConfigurationShrinkRequest {
	s.HostName = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetHpcClusterId(v string) *CreateScalingConfigurationShrinkRequest {
	s.HpcClusterId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetImageFamily(v string) *CreateScalingConfigurationShrinkRequest {
	s.ImageFamily = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetImageId(v string) *CreateScalingConfigurationShrinkRequest {
	s.ImageId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetImageName(v string) *CreateScalingConfigurationShrinkRequest {
	s.ImageName = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetInstanceDescription(v string) *CreateScalingConfigurationShrinkRequest {
	s.InstanceDescription = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetInstanceName(v string) *CreateScalingConfigurationShrinkRequest {
	s.InstanceName = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetInstancePatternInfos(v []*CreateScalingConfigurationShrinkRequestInstancePatternInfos) *CreateScalingConfigurationShrinkRequest {
	s.InstancePatternInfos = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetInstanceType(v string) *CreateScalingConfigurationShrinkRequest {
	s.InstanceType = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetInstanceTypeOverrides(v []*CreateScalingConfigurationShrinkRequestInstanceTypeOverrides) *CreateScalingConfigurationShrinkRequest {
	s.InstanceTypeOverrides = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetInstanceTypes(v []*string) *CreateScalingConfigurationShrinkRequest {
	s.InstanceTypes = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetInternetChargeType(v string) *CreateScalingConfigurationShrinkRequest {
	s.InternetChargeType = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetInternetMaxBandwidthIn(v int32) *CreateScalingConfigurationShrinkRequest {
	s.InternetMaxBandwidthIn = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetInternetMaxBandwidthOut(v int32) *CreateScalingConfigurationShrinkRequest {
	s.InternetMaxBandwidthOut = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetIoOptimized(v string) *CreateScalingConfigurationShrinkRequest {
	s.IoOptimized = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetIpv6AddressCount(v int32) *CreateScalingConfigurationShrinkRequest {
	s.Ipv6AddressCount = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetKeyPairName(v string) *CreateScalingConfigurationShrinkRequest {
	s.KeyPairName = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetLoadBalancerWeight(v int32) *CreateScalingConfigurationShrinkRequest {
	s.LoadBalancerWeight = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetMemory(v int32) *CreateScalingConfigurationShrinkRequest {
	s.Memory = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetOwnerAccount(v string) *CreateScalingConfigurationShrinkRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetOwnerId(v int64) *CreateScalingConfigurationShrinkRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetPassword(v string) *CreateScalingConfigurationShrinkRequest {
	s.Password = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetPasswordInherit(v bool) *CreateScalingConfigurationShrinkRequest {
	s.PasswordInherit = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetRamRoleName(v string) *CreateScalingConfigurationShrinkRequest {
	s.RamRoleName = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetResourceGroupId(v string) *CreateScalingConfigurationShrinkRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetResourceOwnerAccount(v string) *CreateScalingConfigurationShrinkRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetScalingConfigurationName(v string) *CreateScalingConfigurationShrinkRequest {
	s.ScalingConfigurationName = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetScalingGroupId(v string) *CreateScalingConfigurationShrinkRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetSchedulerOptionsShrink(v string) *CreateScalingConfigurationShrinkRequest {
	s.SchedulerOptionsShrink = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetSecurityEnhancementStrategy(v string) *CreateScalingConfigurationShrinkRequest {
	s.SecurityEnhancementStrategy = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetSecurityGroupId(v string) *CreateScalingConfigurationShrinkRequest {
	s.SecurityGroupId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetSecurityGroupIds(v []*string) *CreateScalingConfigurationShrinkRequest {
	s.SecurityGroupIds = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetSpotDuration(v int32) *CreateScalingConfigurationShrinkRequest {
	s.SpotDuration = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetSpotInterruptionBehavior(v string) *CreateScalingConfigurationShrinkRequest {
	s.SpotInterruptionBehavior = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetSpotPriceLimits(v []*CreateScalingConfigurationShrinkRequestSpotPriceLimits) *CreateScalingConfigurationShrinkRequest {
	s.SpotPriceLimits = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetSpotStrategy(v string) *CreateScalingConfigurationShrinkRequest {
	s.SpotStrategy = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetSystemDiskCategories(v []*string) *CreateScalingConfigurationShrinkRequest {
	s.SystemDiskCategories = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetTags(v string) *CreateScalingConfigurationShrinkRequest {
	s.Tags = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetTenancy(v string) *CreateScalingConfigurationShrinkRequest {
	s.Tenancy = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetUserData(v string) *CreateScalingConfigurationShrinkRequest {
	s.UserData = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequest) SetZoneId(v string) *CreateScalingConfigurationShrinkRequest {
	s.ZoneId = &v
	return s
}

type CreateScalingConfigurationShrinkRequestPrivatePoolOptions struct {
	// The ID of the private pool. The ID of a private pool is the same as the ID of the elasticity assurance or capacity reservation for which the private pool is generated.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The type of the private pool that you want to use to start instances. A private pool is generated when an elasticity assurance or a capacity reservation takes effect. You can select a private pool when you start instances. Valid values:
	//
	// *   Open: open private pool. The system selects an open private pool for instance startup. If no open private pool meets your business requirements, the resources in the public pool are used for instance startup. In this case, you do not need to specify the PrivatePoolOptions.Id parameter.
	// *   Target: specified private pool. The resources in the specified private pool are used for instance startup. If the specified private pool is unavailable, the instance startup fails. If you set this parameter to Target, you must specify the PrivatePoolOptions.Id parameter.
	// *   None: no private pool. The resources of private pools are not used for instance startup.
	MatchCriteria *string `json:"MatchCriteria,omitempty" xml:"MatchCriteria,omitempty"`
}

func (s CreateScalingConfigurationShrinkRequestPrivatePoolOptions) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationShrinkRequestPrivatePoolOptions) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationShrinkRequestPrivatePoolOptions) SetId(v string) *CreateScalingConfigurationShrinkRequestPrivatePoolOptions {
	s.Id = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestPrivatePoolOptions) SetMatchCriteria(v string) *CreateScalingConfigurationShrinkRequestPrivatePoolOptions {
	s.MatchCriteria = &v
	return s
}

type CreateScalingConfigurationShrinkRequestSystemDisk struct {
	// The ID of the automatic snapshot policy that you want to apply to the system disk.
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// Specifies whether to enable the burst feature for the system disk. Valid values:
	//
	// *   true
	// *   false
	//
	// > This parameter is available only if you set the `SystemDisk.Category` parameter to `cloud_auto`.
	//
	// For more information, see [ESSD AutoPL disks](~~368372~~).
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The category of the system disk. Valid values:
	//
	// *   cloud: basic disk.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   ephemeral_ssd: local standard SSD.
	// *   cloud_essd: enhanced SSD (ESSD).
	// *   cloud_auto: ESSD AutoPL disk.
	//
	// You cannot specify the SystemDisk.Category and `SystemDiskCategories` parameters at the same time. If you do not specify the SystemDisk.Category and `SystemDiskCategories` parameters, the default value of the SystemDisk.Category parameter is used. For non-I/O optimized instances of Generation I instance types, the default value is cloud. For instances of other instance types, the default value is cloud_efficiency.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The description of the system disk. The description must be 2 to 256 characters in length. The description can contain letters but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the system disk. The name must be 2 to 128 characters in length. The name must start with a letter but cannot start with `http://` or `https://`. The name can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
	DiskName *string `json:"DiskName,omitempty" xml:"DiskName,omitempty"`
	// The algorithm that is used to encrypt the system disk. Valid values:
	//
	// *   AES-256
	// *   SM4-128
	//
	// Default value: AES-256.
	EncryptAlgorithm *string `json:"EncryptAlgorithm,omitempty" xml:"EncryptAlgorithm,omitempty"`
	// Specifies whether to encrypt the system disk. Valid values:
	//
	// *   true: encrypts the system disk.
	// *   false: does not encrypt the system disk.
	//
	// Default value: false.
	Encrypted *bool `json:"Encrypted,omitempty" xml:"Encrypted,omitempty"`
	// The ID of the KMS key that is used to encrypt the system disk.
	KMSKeyId *string `json:"KMSKeyId,omitempty" xml:"KMSKeyId,omitempty"`
	// The PL of the system disk of the ESSD category. Valid values:
	//
	// *   PL0: An ESSD can deliver up to 10,000 random read/write IOPS.
	// *   PL1: An ESSD can deliver up to 50,000 random read/write IOPS.
	// *   PL2: An ESSD can deliver up to 100,000 random read/write IOPS.
	// *   PL3: An ESSD can deliver up to 1,000,000 random read/write IOPS.
	//
	// Default value: PL0.
	PerformanceLevel *string `json:"PerformanceLevel,omitempty" xml:"PerformanceLevel,omitempty"`
	// The IOPS metric that is preconfigured for the system disk.
	//
	// > IOPS measures the number of read and write operations that an EBS device can process per second.
	ProvisionedIops *int64 `json:"ProvisionedIops,omitempty" xml:"ProvisionedIops,omitempty"`
	// The size of the system disk. Unit: GiB. Valid values: 20 to 500.
	//
	// The value of the SystemDisk.Size parameter must be greater than or equal to max{20, ImageSize}.
	//
	// Default value: max{40, ImageSize}.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
}

func (s CreateScalingConfigurationShrinkRequestSystemDisk) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationShrinkRequestSystemDisk) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationShrinkRequestSystemDisk) SetAutoSnapshotPolicyId(v string) *CreateScalingConfigurationShrinkRequestSystemDisk {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestSystemDisk) SetBurstingEnabled(v bool) *CreateScalingConfigurationShrinkRequestSystemDisk {
	s.BurstingEnabled = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestSystemDisk) SetCategory(v string) *CreateScalingConfigurationShrinkRequestSystemDisk {
	s.Category = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestSystemDisk) SetDescription(v string) *CreateScalingConfigurationShrinkRequestSystemDisk {
	s.Description = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestSystemDisk) SetDiskName(v string) *CreateScalingConfigurationShrinkRequestSystemDisk {
	s.DiskName = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestSystemDisk) SetEncryptAlgorithm(v string) *CreateScalingConfigurationShrinkRequestSystemDisk {
	s.EncryptAlgorithm = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestSystemDisk) SetEncrypted(v bool) *CreateScalingConfigurationShrinkRequestSystemDisk {
	s.Encrypted = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestSystemDisk) SetKMSKeyId(v string) *CreateScalingConfigurationShrinkRequestSystemDisk {
	s.KMSKeyId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestSystemDisk) SetPerformanceLevel(v string) *CreateScalingConfigurationShrinkRequestSystemDisk {
	s.PerformanceLevel = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestSystemDisk) SetProvisionedIops(v int64) *CreateScalingConfigurationShrinkRequestSystemDisk {
	s.ProvisionedIops = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestSystemDisk) SetSize(v int32) *CreateScalingConfigurationShrinkRequestSystemDisk {
	s.Size = &v
	return s
}

type CreateScalingConfigurationShrinkRequestDataDisks struct {
	// The ID of the automatic snapshot policy that you want to apply to the data disk.
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// Specifies whether to enable the burst feature for the system disk. Valid values:
	//
	// *   true
	// *   false
	//
	// > This parameter is available only if you set the `SystemDisk.Category` parameter to `cloud_auto`.
	//
	// For more information, see [ESSD AutoPL disks](~~368372~~).
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The categories of the data disks. You can specify 1 to 16 data disks. You can specify 1 to 4 disk categories in a scaling configuration. The first data disk that is specified in a scaling configuration has the highest priority. The priority deceases based on the specified order of the data disks. If Auto Scaling cannot create instances by using the data disk that has the highest priority, Auto Scaling creates instances by using the data disk that has the next highest priority. Valid values:
	//
	// *   cloud: basic disk. The DeleteWithInstance attribute of a basic disk that is created together with the instance is set to true.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   cloud_essd: ESSD.
	//
	// > You cannot specify the Categories and `Category` parameters at the same time.
	Categories []*string `json:"Categories,omitempty" xml:"Categories,omitempty" type:"Repeated"`
	// The category of the system disk. Valid values:
	//
	// *   cloud: basic disk
	// *   cloud_efficiency: ultra disk
	// *   cloud_ssd: standard SSD
	// *   cloud_essd: ESSD
	// *   ephemeral_ssd: local SSD
	// *   cloud_auto: ESSD AutoPL disk
	//
	// You cannot specify the Category and `SystemDiskCategories` parameters at the same time. If you do not specify the Category and `SystemDiskCategories` parameters, the default value of the Category parameter is used. For non-I/O optimized instances of Generation I instance types, the default value is cloud. For instances of other instance types, the default value is cloud_efficiency.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// Specifies whether to release the data disk when the instance to which the data disk is attached is released. Valid values:
	//
	// *   true: releases the data disk when the instance is released.
	// *   false: retains the data disk when the instance is released.
	//
	// This parameter is available only for independent disks whose Category parameter is set to cloud, cloud_efficiency, cloud_ssd, or cloud_essd. If you specify this parameter for disks of other categories, an error will be reported.
	//
	// Default value: true.
	DeleteWithInstance *bool `json:"DeleteWithInstance,omitempty" xml:"DeleteWithInstance,omitempty"`
	// The description of the data disk. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The mount target of the data disk. If you do not specify the Device parameter, the system automatically assigns a mount target when you create the ECS instance. The name of the mount target ranges from /dev/xvdb to /dev/xvdz.
	Device *string `json:"Device,omitempty" xml:"Device,omitempty"`
	// The name of the system disk. The name must be 2 to 128 characters in length and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). The name must start with a letter and cannot start with `http://` or `https://`.
	DiskName *string `json:"DiskName,omitempty" xml:"DiskName,omitempty"`
	// Specifies whether to encrypt the data disk. Valid values:
	//
	// *   true
	// *   false.
	//
	// Default value: false.
	Encrypted *string `json:"Encrypted,omitempty" xml:"Encrypted,omitempty"`
	// The ID of the Key Management Service (KMS) key that is used to encrypt the data disk.
	KMSKeyId *string `json:"KMSKeyId,omitempty" xml:"KMSKeyId,omitempty"`
	// The PL of the data disk of the ESSD category. If you set the Categories parameter to cloud_essd, you must also specify the PerformanceLevel parameter. Valid values:
	//
	// *   PL0: An ESSD can deliver up to 10,000 random read/write IOPS.
	// *   PL1: An ESSD can deliver up to 50,000 random read/write IOPS.
	// *   PL2: An ESSD can deliver up to 100,000 random read/write IOPS.
	// *   PL3: An ESSD can deliver up to 1,000,000 random read/write IOPS.
	//
	// > For more information about how to choose ESSD PLs, see [ESSD](~~122389~~).
	PerformanceLevel *string `json:"PerformanceLevel,omitempty" xml:"PerformanceLevel,omitempty"`
	// The input/output operations per second (IOPS) metric that is preconfigured for the data disk.
	//
	// > IOPS measures the number of read and write operations that an Elastic Block Storage (EBS) device can process per second.
	ProvisionedIops *int64 `json:"ProvisionedIops,omitempty" xml:"ProvisionedIops,omitempty"`
	// The size of the data disk. Unit: GiB.
	//
	// *   Valid values if you set the Category parameter to cloud: 5 to 2000.
	// *   Valid values if you set the Category parameter to cloud_efficiency: 20 to 32768.
	// *   Valid values if you set the Category parameter to cloud_essd: 20 to 32768.
	// *   Valid values if you set the Category parameter to ephemeral_ssd: 5 to 800.
	//
	// The value of the Size parameter must be greater than or equal to the size of the snapshot that is specified by the SnapshotId parameter.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The ID of the snapshot that is used to create the data disk. If you specify this parameter, the Size parameter is ignored. The size of the disk is the same as the size of the specified snapshot.
	//
	// If you specify a snapshot created on or before July 15, 2013, the operation fails and the system returns InvalidSnapshot.TooOld.
	SnapshotId *string `json:"SnapshotId,omitempty" xml:"SnapshotId,omitempty"`
}

func (s CreateScalingConfigurationShrinkRequestDataDisks) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationShrinkRequestDataDisks) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetAutoSnapshotPolicyId(v string) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetBurstingEnabled(v bool) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.BurstingEnabled = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetCategories(v []*string) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.Categories = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetCategory(v string) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.Category = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetDeleteWithInstance(v bool) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.DeleteWithInstance = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetDescription(v string) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.Description = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetDevice(v string) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.Device = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetDiskName(v string) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.DiskName = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetEncrypted(v string) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.Encrypted = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetKMSKeyId(v string) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.KMSKeyId = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetPerformanceLevel(v string) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.PerformanceLevel = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetProvisionedIops(v int64) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.ProvisionedIops = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetSize(v int32) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.Size = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestDataDisks) SetSnapshotId(v string) *CreateScalingConfigurationShrinkRequestDataDisks {
	s.SnapshotId = &v
	return s
}

type CreateScalingConfigurationShrinkRequestInstancePatternInfos struct {
	// The architectures of the instance types. Valid values:
	//
	// *   X86: x86 architecture.
	// *   Heterogeneous: heterogeneous architecture, such as GPUs and FPGAs.
	// *   BareMetal: ECS Bare Metal Instance architecture.
	// *   Arm: ARM architecture.
	// *   SuperComputeCluster: Super Computing Cluster architecture.
	//
	// By default, all values are selected.
	Architectures []*string `json:"Architectures,omitempty" xml:"Architectures,omitempty" type:"Repeated"`
	// Specifies whether to include burstable instance types. Valid values:
	//
	// *   Exclude: excludes burstable instance types.
	// *   Include: includes burstable instance types.
	// *   Required: includes only burstable instance types.
	//
	// Default value: Include.
	BurstablePerformance *string `json:"BurstablePerformance,omitempty" xml:"BurstablePerformance,omitempty"`
	// The number of vCPUs that is specified for an instance type in the intelligent configuration mode. This parameter is used to filter the available instance types that meet the specified criteria. For more information, see [Instance family](~~25378~~).
	//
	// When you specify the Cores parameter, take note of the following items:
	//
	// *   The InstancePatternInfos parameter is available only for scaling groups that reside in VPCs.
	// *   You must specify the InstancePatternInfos, Cores, and Memory parameters at the same time.
	// *   If you specify an instance type by using the InstanceType or InstanceTypes parameter, Auto Scaling preferentially uses the instance type that is specified by the InstanceType or InstanceTypes parameter for scale-out activities. If the specified instance type does not have sufficient inventory, Auto Scaling creates instances of the instance type that is specified by the InstancePatternInfos parameter based on the price in ascending order.
	Cores *int32 `json:"Cores,omitempty" xml:"Cores,omitempty"`
	// The instance types that you want to filter out. You can use wildcard characters such as an asterisk (\*) to filter out a single instance type or an instance family. Example:
	//
	// *   ecs.c6.large: The ecs.c6.large instance type is filtered out.
	// *   ecs.c6.\*: The c6 instance family is filtered out.
	ExcludedInstanceTypes []*string `json:"ExcludedInstanceTypes,omitempty" xml:"ExcludedInstanceTypes,omitempty" type:"Repeated"`
	// The level of the instance type, which is used to filter the instance types that meet the specified criteria. This parameter takes effect only if you set the `CostOptimization` parameter to true. Valid values:
	//
	// *   EntryLevel: shared instance type. Instances of this level are the most cost-effective but may not provide stable computing performance in a consistent manner. Instances of this level are suitable for business scenarios in which the CPU utilization is low. For more information, see [Shared instance families](~~108489~~).
	// *   EnterpriseLevel: Instances of this level provide stable performance and dedicated resources, and are suitable for business scenarios that require high stability. For more information, see [Instance family](~~25378~~).
	// *   CreditEntryLevel: This value is valid only for burstable instances. CPU credits are used to ensure computing performance. Instances of this level are suitable for scenarios in which the CPU utilization is low but may fluctuate in specific cases. For more information, see the [Overview](~~59977~~) topic of burstable instances.
	InstanceFamilyLevel *string `json:"InstanceFamilyLevel,omitempty" xml:"InstanceFamilyLevel,omitempty"`
	// The maximum hourly price for a pay-as-you-go instance or a preemptible instance in the intelligent configuration mode. This parameter is used to filter the available instance types that meet the specified criteria.
	//
	// > If you set the SpotStrategy parameter to SpotWithPriceLimit, you must specify the MaxPrice parameter. In other cases, you do not need to specify the MaxPrice parameter.
	MaxPrice *float32 `json:"MaxPrice,omitempty" xml:"MaxPrice,omitempty"`
	// The memory size that is specified for an instance type in the intelligent configuration mode. Unit: GiB. This parameter is used to filter the available instance types that meet the specified criteria.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
}

func (s CreateScalingConfigurationShrinkRequestInstancePatternInfos) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationShrinkRequestInstancePatternInfos) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationShrinkRequestInstancePatternInfos) SetArchitectures(v []*string) *CreateScalingConfigurationShrinkRequestInstancePatternInfos {
	s.Architectures = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestInstancePatternInfos) SetBurstablePerformance(v string) *CreateScalingConfigurationShrinkRequestInstancePatternInfos {
	s.BurstablePerformance = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestInstancePatternInfos) SetCores(v int32) *CreateScalingConfigurationShrinkRequestInstancePatternInfos {
	s.Cores = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestInstancePatternInfos) SetExcludedInstanceTypes(v []*string) *CreateScalingConfigurationShrinkRequestInstancePatternInfos {
	s.ExcludedInstanceTypes = v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestInstancePatternInfos) SetInstanceFamilyLevel(v string) *CreateScalingConfigurationShrinkRequestInstancePatternInfos {
	s.InstanceFamilyLevel = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestInstancePatternInfos) SetMaxPrice(v float32) *CreateScalingConfigurationShrinkRequestInstancePatternInfos {
	s.MaxPrice = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestInstancePatternInfos) SetMemory(v float32) *CreateScalingConfigurationShrinkRequestInstancePatternInfos {
	s.Memory = &v
	return s
}

type CreateScalingConfigurationShrinkRequestInstanceTypeOverrides struct {
	// The instance type that you want to use to overwrite the instance type specified in the launch template.
	//
	// If you want Auto Scaling to scale instances based on the instance type capacity, you must specify the InstanceType parameter and the WeightedCapacity parameter. You can specify 1 to 10 instance types in the extended configurations of the launch template.
	//
	// > This parameter takes effect only if you specify the LaunchTemplateId parameter.
	//
	// You can specify an instance type that is available for purchase as the value of the InstanceType parameter.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The weight of the instance type. The weight of an instance type indicates the capacity of a single instance of the specified instance type in the scaling group. If you want to specify the capacity of a single instance of the specified instance type in the scaling group, you must specify the InstanceType parameter before you specify the WeightedCapacity parameter.
	//
	// A higher weight specifies that a smaller number of instances of the specified instance type are required to meet the expected capacity.
	//
	// Performance metrics, such as the number of vCPUs and the memory size of each instance type, may vary. You can specify different weights for different instance types based on your business requirements.
	//
	// Example:
	//
	// *   Current capacity: 0
	// *   Expected capacity: 6
	// *   Capacity of ecs.c5.xlarge: 4
	//
	// To meet the expected capacity requirement, Auto Scaling must create and add two ecs.c5.xlarge instances.
	//
	// > The capacity of the scaling group cannot exceed the sum of the maximum number of instances that is specified by the MaxSize parameter and the maximum weight of the instance types.
	//
	// Valid values of the WeightedCapacity parameter: 1 to 500.
	WeightedCapacity *int32 `json:"WeightedCapacity,omitempty" xml:"WeightedCapacity,omitempty"`
}

func (s CreateScalingConfigurationShrinkRequestInstanceTypeOverrides) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationShrinkRequestInstanceTypeOverrides) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationShrinkRequestInstanceTypeOverrides) SetInstanceType(v string) *CreateScalingConfigurationShrinkRequestInstanceTypeOverrides {
	s.InstanceType = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestInstanceTypeOverrides) SetWeightedCapacity(v int32) *CreateScalingConfigurationShrinkRequestInstanceTypeOverrides {
	s.WeightedCapacity = &v
	return s
}

type CreateScalingConfigurationShrinkRequestSpotPriceLimits struct {
	// The instance type of the preemptible instance. This parameter is available only if you set the SpotStrategy parameter to SpotWithPriceLimit.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The price limit of the preemptible instance. This parameter is available only if you set the SpotStrategy parameter to SpotWithPriceLimit.
	PriceLimit *float32 `json:"PriceLimit,omitempty" xml:"PriceLimit,omitempty"`
}

func (s CreateScalingConfigurationShrinkRequestSpotPriceLimits) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationShrinkRequestSpotPriceLimits) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationShrinkRequestSpotPriceLimits) SetInstanceType(v string) *CreateScalingConfigurationShrinkRequestSpotPriceLimits {
	s.InstanceType = &v
	return s
}

func (s *CreateScalingConfigurationShrinkRequestSpotPriceLimits) SetPriceLimit(v float32) *CreateScalingConfigurationShrinkRequestSpotPriceLimits {
	s.PriceLimit = &v
	return s
}

type CreateScalingConfigurationResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the scaling configuration.
	ScalingConfigurationId *string `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
}

func (s CreateScalingConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationResponseBody) SetRequestId(v string) *CreateScalingConfigurationResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateScalingConfigurationResponseBody) SetScalingConfigurationId(v string) *CreateScalingConfigurationResponseBody {
	s.ScalingConfigurationId = &v
	return s
}

type CreateScalingConfigurationResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateScalingConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateScalingConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingConfigurationResponse) GoString() string {
	return s.String()
}

func (s *CreateScalingConfigurationResponse) SetHeaders(v map[string]*string) *CreateScalingConfigurationResponse {
	s.Headers = v
	return s
}

func (s *CreateScalingConfigurationResponse) SetStatusCode(v int32) *CreateScalingConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateScalingConfigurationResponse) SetBody(v *CreateScalingConfigurationResponseBody) *CreateScalingConfigurationResponse {
	s.Body = v
	return s
}

type CreateScalingGroupRequest struct {
	// Details of the ALB server groups.
	AlbServerGroups []*CreateScalingGroupRequestAlbServerGroups `json:"AlbServerGroups,omitempty" xml:"AlbServerGroups,omitempty" type:"Repeated"`
	// The allocation policy. Auto Scaling selects instance types based on the allocation policy to create the required number of instances. The policy can be applied to pay-as-you-go instances and preemptible instances at the same time. This parameter takes effect only when you set the `MultiAZPolicy` parameter to `COMPOSABLE`. Valid values:
	//
	// *   priority: Auto Scaling selects instance types based on the specified order to create the required number of instances.
	// *   lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of instances.
	//
	// Default value: priority.
	AllocationStrategy *string `json:"AllocationStrategy,omitempty" xml:"AllocationStrategy,omitempty"`
	// Specifies whether to evenly distribute instances in the scaling group across zones. This parameter takes effect only when you set the `MultiAZPolicy` parameter to `COMPOSABLE`. Valid values:
	//
	// *   true: evenly distributes instances in the scaling group across zones.
	// *   false: distributes instances in the scaling group across zones.
	//
	// Default value: false.
	AzBalance *bool `json:"AzBalance,omitempty" xml:"AzBalance,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to automatically create pay-as-you-go instances to meet the requirements on the number of ECS instances when the expected capacity of preemptible instances cannot be fulfilled due to reasons such as costs and insufficient resources. This parameter takes effect only when MultiAZPolicy is set to COST_OPTIMIZED. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: true.
	CompensateWithOnDemand *bool `json:"CompensateWithOnDemand,omitempty" xml:"CompensateWithOnDemand,omitempty"`
	// The ID of the elastic container instance.
	ContainerGroupId *string `json:"ContainerGroupId,omitempty" xml:"ContainerGroupId,omitempty"`
	// The ARN of the custom scaling policy (Function). This parameter takes effect only if you specify CustomPolicy as the first step of the instance removal policy.
	CustomPolicyARN *string `json:"CustomPolicyARN,omitempty" xml:"CustomPolicyARN,omitempty"`
	// The IDs of the ApsaraDB RDS instances. The value can be a JSON array that contains multiple ApsaraDB RDS instance IDs. Separate multiple IDs with commas (,).
	//
	// You can associate only a limited number of ApsaraDB RDS instances with a scaling group. Go to [Quota Center](https://quotas.console.aliyun.com/products/ess/quotas) to check the quota of ApsaraDB RDS instances that can be associated with a scaling group.
	DBInstanceIds *string `json:"DBInstanceIds,omitempty" xml:"DBInstanceIds,omitempty"`
	// The cooldown time of the scaling group after a scale-in or scale-out activity is executed. Valid values: 0 to 86400. Unit: seconds.
	//
	// During the cooldown time, Auto Scaling executes only scaling activities that are triggered by event-triggered tasks associated with CloudMonitor.
	//
	// Default value: 300.
	DefaultCooldown *int32 `json:"DefaultCooldown,omitempty" xml:"DefaultCooldown,omitempty"`
	// The expected number of ECS instances in the scaling group. Auto Scaling automatically maintains the expected number of ECS instances that you specify. The expected number cannot be greater than the value of the MaxSize parameter and cannot be less than the value of the MinSize parameter.
	DesiredCapacity *int32 `json:"DesiredCapacity,omitempty" xml:"DesiredCapacity,omitempty"`
	// Specifies whether to enable deletion protection for the scaling group. Valid values:
	//
	// *   true: enables deletion protection for the scaling group. This way, the scaling group cannot be deleted.
	// *   false: disables deletion protection for the scaling group.
	//
	// Default value: false.
	GroupDeletionProtection *bool `json:"GroupDeletionProtection,omitempty" xml:"GroupDeletionProtection,omitempty"`
	// The type of instances that are managed by the scaling group. Valid values:
	//
	// *   ECS: ECS instances
	// *   ECI: elastic container instances
	//
	// Default value: ECS.
	GroupType *string `json:"GroupType,omitempty" xml:"GroupType,omitempty"`
	// The health check mode of the scaling group. Valid values:
	//
	// *   NONE: Auto Scaling does not perform health checks on instances in the scaling group.
	// *   ECS: Auto Scaling performs health checks on ECS instances in the scaling group.
	//
	// Default value: ECS.
	HealthCheckType *string `json:"HealthCheckType,omitempty" xml:"HealthCheckType,omitempty"`
	// The ID of the ECS instance. Auto Scaling obtains configuration information based on the ECS instance and uses the information to create a scaling configuration.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the launch template that is used by Auto Scaling to create instances.
	LaunchTemplateId *string `json:"LaunchTemplateId,omitempty" xml:"LaunchTemplateId,omitempty"`
	// Details of the instance types that are specified in the extended configurations of the launch template.
	LaunchTemplateOverrides []*CreateScalingGroupRequestLaunchTemplateOverrides `json:"LaunchTemplateOverrides,omitempty" xml:"LaunchTemplateOverrides,omitempty" type:"Repeated"`
	// The version number of the launch template. Valid values:
	//
	// *   A fixed template version number.
	// *   Default: The default template version is always used.
	// *   Latest: The latest template version is always used.
	LaunchTemplateVersion *string `json:"LaunchTemplateVersion,omitempty" xml:"LaunchTemplateVersion,omitempty"`
	// Details of the lifecycle hooks.
	LifecycleHooks []*CreateScalingGroupRequestLifecycleHooks `json:"LifecycleHooks,omitempty" xml:"LifecycleHooks,omitempty" type:"Repeated"`
	// The IDs of CLB instances. The value can be a JSON array that contains multiple CLB instance IDs. Separate multiple IDs with commas (,).
	//
	// You can associate only a limited number of CLB instances with a scaling group. Go to [Quota Center](https://quotas.console.aliyun.com/products/ess/quotas) to check the quota of CLB instances that can be associated with a scaling group.
	LoadBalancerIds *string `json:"LoadBalancerIds,omitempty" xml:"LoadBalancerIds,omitempty"`
	// The maximum life span of the instance in the scaling group. Unit: seconds.
	//
	// Valid values: 86400 to Integer.maxValue.
	//
	// Default value: null.
	MaxInstanceLifetime *int32 `json:"MaxInstanceLifetime,omitempty" xml:"MaxInstanceLifetime,omitempty"`
	// The maximum number of ECS instances in the scaling group. When the number of existing ECS instances in the scaling group is greater than the value of the MaxSize parameter, Auto Scaling automatically removes ECS instances from the scaling group until the number of instances is equal to the value of the MaxSize parameter.
	//
	// The value range of the MaxSize parameter varies based on the instance quota. You can go to [Quota Center](https://quotas.console.aliyun.com/products/ess/quotas) to check the quota of **instances that can be included in a scaling group**.
	//
	// For example, if the quota of instances that can be included in a scaling group is 2,000, the value range of the **MaxSize** parameter is 0 to 2000.
	MaxSize *int32 `json:"MaxSize,omitempty" xml:"MaxSize,omitempty"`
	// The minimum number of ECS instances in the scaling group. When the number of existing ECS instances in the scaling group is less than the value of the MinSize parameter, Auto Scaling automatically creates ECS instances and adds the instances to the scaling group until the number of instances is equal to the value of the MinSize parameter.
	//
	// > The value of the MinSize parameter must be less than or equal to the value of the MaxSize parameter.
	MinSize *int32 `json:"MinSize,omitempty" xml:"MinSize,omitempty"`
	// The scaling policy for the multi-zone scaling group that contains ECS instances. Valid values:
	//
	// *   PRIORITY: ECS instances are scaled based on the priority of the vSwitch that is specified by the VSwitchIds.N parameter. Auto Scaling preferentially scales instances in the zone where the vSwitch that has the highest priority resides. If the scaling fails, Auto Scaling scales instances in the zone where the vSwitch that has the next highest priority resides.
	//
	// *   COST_OPTIMIZED: During a scale-out activity, Auto Scaling preferentially creates ECS instances that have vCPUs provided at the lowest price. During a scale-in activity, Auto Scaling preferentially removes ECS instances whose vCPUs are provided at the highest price. Preemptible instances are preferentially created when preemptible instance types are specified in the scaling configuration. You can specify the CompensateWithOnDemand parameter to determine whether to automatically create pay-as-you-go instances when preemptible instances cannot be created due to insufficient resources.
	//
	//     **
	//
	//     **Note**The COST_OPTIMIZED setting takes effect only when multiple instance types are specified or at least one instance type is specified for preemptible instances.
	//
	// *   BALANCE: ECS instances are evenly distributed across zones that are specified for the scaling group. If ECS instances are unevenly distributed across zones due to insufficient resources, you can call the [RebalanceInstance](~~71516~~) operation to balance the instances across zones.
	//
	// Default value: PRIORITY.
	MultiAZPolicy *string `json:"MultiAZPolicy,omitempty" xml:"MultiAZPolicy,omitempty"`
	// The minimum number of pay-as-you-go instances that must be included in the scaling group. Valid values: 0 to 1000. If the number of pay-as-you-go instances is less than the value of this parameter, Auto Scaling preferentially creates pay-as-you-go instances.
	OnDemandBaseCapacity *int32 `json:"OnDemandBaseCapacity,omitempty" xml:"OnDemandBaseCapacity,omitempty"`
	// The percentage of pay-as-you-go instances in the excess instances when the minimum number of pay-as-you-go instances reaches the requirement. Valid values: 0 to 100.
	OnDemandPercentageAboveBaseCapacity *int32  `json:"OnDemandPercentageAboveBaseCapacity,omitempty" xml:"OnDemandPercentageAboveBaseCapacity,omitempty"`
	OwnerAccount                        *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                             *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The first step of the instance removal policy. Valid values:
	//
	// *   OldestInstance: removes ECS instances that are added at the earliest point in time to the scaling group.
	// *   NewestInstance: removes ECS instances that are most recently added to the scaling group.
	// *   OldestScalingConfiguration: removes ECS instances that are created based on the earliest scaling configuration.
	// *   CustomPolicy: removes ECS instances based on the custom scaling policy (Function).
	//
	// > The scaling configuration mentioned in OldestScalingConfiguration refers to the instance configuration source of a scaling group. The instance configuration source can be a scaling configuration or a launch template. The CustomPolicy setting is available only for the RemovalPolicies parameter. If you set the RemovalPolicies parameter to CustomPolicy, you must also specify the CustomPolicyARN parameter.
	//
	// The version of a launch template does not indicate the order in which the template is added. For example, if you use the lt-foress V2 template to create a scaling group, and then replace the template with the lt-foress V1 template when you modify the scaling group, Auto Scaling considers the lt-foress V2 launch template as the earliest template.
	//
	// If you do not specify the RemovalPolicy.1 parameter and the RemovalPolicy.2 parameter, the following rules apply:
	//
	// *   OldestScalingConfiguration is used as the value of the RemovalPolicy.1 parameter.
	// *   OldestInstance is used as the value of the RemovalPolicy.2 parameter.
	//
	// > The removal of ECS instances from a scaling group is also affected by the value of the MultiAZPolicy parameter. For more information, see [Configure a combination policy for removing instances](~~254822~~) in Auto Scaling Best Practices.
	RemovalPolicies      []*string `json:"RemovalPolicies,omitempty" xml:"RemovalPolicies,omitempty" type:"Repeated"`
	ResourceGroupId      *string   `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The name of the scaling group. The name of each scaling group must be unique in a region.
	//
	// The name must be 2 to 64 characters in length, and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). The name must start with a letter or a digit.
	//
	// If you do not specify this parameter, the value of the ScalingGroupId parameter is used.
	ScalingGroupName *string `json:"ScalingGroupName,omitempty" xml:"ScalingGroupName,omitempty"`
	// The reclaim mode of the scaling group. Valid values:
	//
	// *   recycle: economical mode.
	// *   release: release mode.
	//
	// The ScalingPolicy parameter specifies the reclaim mode of the scaling group. The RemovePolicy parameter of the RemoveInstances operation specifies how to remove instances in a specific manner.
	ScalingPolicy *string `json:"ScalingPolicy,omitempty" xml:"ScalingPolicy,omitempty"`
	// The allocation policy of preemptible instances. You can use this parameter to individually specify the allocation policy of preemptible instances. This parameter takes effect only when you set the `MultiAZPolicy` parameter to `COMPOSABLE`. Valid values:
	//
	// *   priority: Auto Scaling selects instance types based on the specified order to create the required number of preemptible instances.
	// *   lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of preemptible instances.
	//
	// Default value: priority.
	SpotAllocationStrategy *string `json:"SpotAllocationStrategy,omitempty" xml:"SpotAllocationStrategy,omitempty"`
	// The number of instance types that you specified. Auto Scaling creates preemptible instances of multiple instance types that are provided at the lowest price. Valid values: 1 to 10.
	SpotInstancePools *int32 `json:"SpotInstancePools,omitempty" xml:"SpotInstancePools,omitempty"`
	// Specifies whether to supplement preemptible instances. If this parameter is set to true, Auto Scaling creates an instance to replace a preemptible instance when Auto Scaling receives the system message that the preemptible instance is to be reclaimed.
	SpotInstanceRemedy *bool `json:"SpotInstanceRemedy,omitempty" xml:"SpotInstanceRemedy,omitempty"`
	// > This parameter is unavailable.
	SyncAlarmRuleToCms *bool `json:"SyncAlarmRuleToCms,omitempty" xml:"SyncAlarmRuleToCms,omitempty"`
	// Details of the tags that are added to the scaling group.
	Tags []*CreateScalingGroupRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// Details of the vServer groups that are associated with the scaling group.
	VServerGroups []*CreateScalingGroupRequestVServerGroups `json:"VServerGroups,omitempty" xml:"VServerGroups,omitempty" type:"Repeated"`
	// The ID of the vSwitch. If you specify the VSwitchId parameter, the network type of the scaling group is VPC.
	//
	// > If you do not specify the VSwitchId or VSwitchIds parameter, the network type of the scaling group is classic network.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The IDs of vSwitches. If you specify the VSwitchIds parameter, the VSwitchId parameter is ignored. If you specify the VSwitchIds parameter, the network type of the scaling group is VPC.
	//
	// If you specify multiple vSwitches, the following rules apply:
	//
	// *   The vSwitches must belong to the same VPC.
	// *   The vSwitches can belong to different zones.
	// *   vSwitches are sorted in ascending order. 1 indicates the highest priority. If Auto Scaling fails to create ECS instances in the zone where the vSwitch that has the highest priority resides, Auto Scaling creates ECS instances in the zone where the vSwitch that has the next highest priority resides.
	//
	// > If you do not specify the VSwitchId or VSwitchIds parameter, the network type of the scaling group is classic network.
	VSwitchIds []*string `json:"VSwitchIds,omitempty" xml:"VSwitchIds,omitempty" type:"Repeated"`
}

func (s CreateScalingGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateScalingGroupRequest) SetAlbServerGroups(v []*CreateScalingGroupRequestAlbServerGroups) *CreateScalingGroupRequest {
	s.AlbServerGroups = v
	return s
}

func (s *CreateScalingGroupRequest) SetAllocationStrategy(v string) *CreateScalingGroupRequest {
	s.AllocationStrategy = &v
	return s
}

func (s *CreateScalingGroupRequest) SetAzBalance(v bool) *CreateScalingGroupRequest {
	s.AzBalance = &v
	return s
}

func (s *CreateScalingGroupRequest) SetClientToken(v string) *CreateScalingGroupRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateScalingGroupRequest) SetCompensateWithOnDemand(v bool) *CreateScalingGroupRequest {
	s.CompensateWithOnDemand = &v
	return s
}

func (s *CreateScalingGroupRequest) SetContainerGroupId(v string) *CreateScalingGroupRequest {
	s.ContainerGroupId = &v
	return s
}

func (s *CreateScalingGroupRequest) SetCustomPolicyARN(v string) *CreateScalingGroupRequest {
	s.CustomPolicyARN = &v
	return s
}

func (s *CreateScalingGroupRequest) SetDBInstanceIds(v string) *CreateScalingGroupRequest {
	s.DBInstanceIds = &v
	return s
}

func (s *CreateScalingGroupRequest) SetDefaultCooldown(v int32) *CreateScalingGroupRequest {
	s.DefaultCooldown = &v
	return s
}

func (s *CreateScalingGroupRequest) SetDesiredCapacity(v int32) *CreateScalingGroupRequest {
	s.DesiredCapacity = &v
	return s
}

func (s *CreateScalingGroupRequest) SetGroupDeletionProtection(v bool) *CreateScalingGroupRequest {
	s.GroupDeletionProtection = &v
	return s
}

func (s *CreateScalingGroupRequest) SetGroupType(v string) *CreateScalingGroupRequest {
	s.GroupType = &v
	return s
}

func (s *CreateScalingGroupRequest) SetHealthCheckType(v string) *CreateScalingGroupRequest {
	s.HealthCheckType = &v
	return s
}

func (s *CreateScalingGroupRequest) SetInstanceId(v string) *CreateScalingGroupRequest {
	s.InstanceId = &v
	return s
}

func (s *CreateScalingGroupRequest) SetLaunchTemplateId(v string) *CreateScalingGroupRequest {
	s.LaunchTemplateId = &v
	return s
}

func (s *CreateScalingGroupRequest) SetLaunchTemplateOverrides(v []*CreateScalingGroupRequestLaunchTemplateOverrides) *CreateScalingGroupRequest {
	s.LaunchTemplateOverrides = v
	return s
}

func (s *CreateScalingGroupRequest) SetLaunchTemplateVersion(v string) *CreateScalingGroupRequest {
	s.LaunchTemplateVersion = &v
	return s
}

func (s *CreateScalingGroupRequest) SetLifecycleHooks(v []*CreateScalingGroupRequestLifecycleHooks) *CreateScalingGroupRequest {
	s.LifecycleHooks = v
	return s
}

func (s *CreateScalingGroupRequest) SetLoadBalancerIds(v string) *CreateScalingGroupRequest {
	s.LoadBalancerIds = &v
	return s
}

func (s *CreateScalingGroupRequest) SetMaxInstanceLifetime(v int32) *CreateScalingGroupRequest {
	s.MaxInstanceLifetime = &v
	return s
}

func (s *CreateScalingGroupRequest) SetMaxSize(v int32) *CreateScalingGroupRequest {
	s.MaxSize = &v
	return s
}

func (s *CreateScalingGroupRequest) SetMinSize(v int32) *CreateScalingGroupRequest {
	s.MinSize = &v
	return s
}

func (s *CreateScalingGroupRequest) SetMultiAZPolicy(v string) *CreateScalingGroupRequest {
	s.MultiAZPolicy = &v
	return s
}

func (s *CreateScalingGroupRequest) SetOnDemandBaseCapacity(v int32) *CreateScalingGroupRequest {
	s.OnDemandBaseCapacity = &v
	return s
}

func (s *CreateScalingGroupRequest) SetOnDemandPercentageAboveBaseCapacity(v int32) *CreateScalingGroupRequest {
	s.OnDemandPercentageAboveBaseCapacity = &v
	return s
}

func (s *CreateScalingGroupRequest) SetOwnerAccount(v string) *CreateScalingGroupRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateScalingGroupRequest) SetOwnerId(v int64) *CreateScalingGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateScalingGroupRequest) SetRegionId(v string) *CreateScalingGroupRequest {
	s.RegionId = &v
	return s
}

func (s *CreateScalingGroupRequest) SetRemovalPolicies(v []*string) *CreateScalingGroupRequest {
	s.RemovalPolicies = v
	return s
}

func (s *CreateScalingGroupRequest) SetResourceGroupId(v string) *CreateScalingGroupRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateScalingGroupRequest) SetResourceOwnerAccount(v string) *CreateScalingGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateScalingGroupRequest) SetScalingGroupName(v string) *CreateScalingGroupRequest {
	s.ScalingGroupName = &v
	return s
}

func (s *CreateScalingGroupRequest) SetScalingPolicy(v string) *CreateScalingGroupRequest {
	s.ScalingPolicy = &v
	return s
}

func (s *CreateScalingGroupRequest) SetSpotAllocationStrategy(v string) *CreateScalingGroupRequest {
	s.SpotAllocationStrategy = &v
	return s
}

func (s *CreateScalingGroupRequest) SetSpotInstancePools(v int32) *CreateScalingGroupRequest {
	s.SpotInstancePools = &v
	return s
}

func (s *CreateScalingGroupRequest) SetSpotInstanceRemedy(v bool) *CreateScalingGroupRequest {
	s.SpotInstanceRemedy = &v
	return s
}

func (s *CreateScalingGroupRequest) SetSyncAlarmRuleToCms(v bool) *CreateScalingGroupRequest {
	s.SyncAlarmRuleToCms = &v
	return s
}

func (s *CreateScalingGroupRequest) SetTags(v []*CreateScalingGroupRequestTags) *CreateScalingGroupRequest {
	s.Tags = v
	return s
}

func (s *CreateScalingGroupRequest) SetVServerGroups(v []*CreateScalingGroupRequestVServerGroups) *CreateScalingGroupRequest {
	s.VServerGroups = v
	return s
}

func (s *CreateScalingGroupRequest) SetVSwitchId(v string) *CreateScalingGroupRequest {
	s.VSwitchId = &v
	return s
}

func (s *CreateScalingGroupRequest) SetVSwitchIds(v []*string) *CreateScalingGroupRequest {
	s.VSwitchIds = v
	return s
}

type CreateScalingGroupRequestAlbServerGroups struct {
	// The ID of the ALB server group.
	//
	// You can associate only a limited number of ALB server groups with a scaling group. To view the quota or manually request a quota increase, go to [Quota Center](https://quotas.console.aliyun.com/products/ess/quotas).
	AlbServerGroupId *string `json:"AlbServerGroupId,omitempty" xml:"AlbServerGroupId,omitempty"`
	// The port number used by the ECS instance after the instance is added to the ALB server group. Valid values: 1 to 65535.
	//
	// > If the N values are the same but the port numbers are different, Auto Scaling associates multiple ports in the scaling group with the ALB server group.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The weight of the ECS instance as a backend server after the instance is added to the ALB server group. If you increase the weight of an ECS instance in an ALB server group, the number of access requests that are forwarded to the ECS instance increases. If you set the Weight parameter for an ECS instance to 0, no access requests are forwarded to the ECS instance. Valid values: 0 to 100.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s CreateScalingGroupRequestAlbServerGroups) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingGroupRequestAlbServerGroups) GoString() string {
	return s.String()
}

func (s *CreateScalingGroupRequestAlbServerGroups) SetAlbServerGroupId(v string) *CreateScalingGroupRequestAlbServerGroups {
	s.AlbServerGroupId = &v
	return s
}

func (s *CreateScalingGroupRequestAlbServerGroups) SetPort(v int32) *CreateScalingGroupRequestAlbServerGroups {
	s.Port = &v
	return s
}

func (s *CreateScalingGroupRequestAlbServerGroups) SetWeight(v int32) *CreateScalingGroupRequestAlbServerGroups {
	s.Weight = &v
	return s
}

type CreateScalingGroupRequestLaunchTemplateOverrides struct {
	// The instance type. The instance type that you specify by using the InstanceType parameter overwrites the instance type that is specified in the launch template.
	//
	// If you want Auto Scaling to scale instances in the scaling group based on the instance type weight, you must specify both the InstanceType parameter and the WeightedCapacity parameter. You can specify 1 to 10 instance types in the extended configurations of the launch template.
	//
	// > This parameter takes effect only when you specify the LaunchTemplateId parameter.
	//
	// You can use the InstanceType parameter to specify only instance types that are available for purchase.
	InstanceType   *string  `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	SpotPriceLimit *float32 `json:"SpotPriceLimit,omitempty" xml:"SpotPriceLimit,omitempty"`
	// The weight of the instance type. The weight specifies the capacity of a single instance of the specified instance type in the scaling group. If you want Auto Scaling to scale instances in the scaling group based on the instance type weight, you must specify the WeightedCapacity parameter after you specify the InstanceType parameter.
	//
	// A higher weight specifies that a smaller number of instances of the specified instance type are required to meet the expected capacity.
	//
	// Performance metrics, such as the number of vCPUs and the memory size of each instance type, may vary. You can specify different weights for different instance types based on your business requirements.
	//
	// Example:
	//
	// *   Current capacity: 0
	// *   Expected capacity: 6
	// *   Capacity of ecs.c5.xlarge: 4
	//
	// To meet the expected capacity, Auto Scaling must create and add two ecs.c5.xlarge instances.
	//
	// > The capacity of the scaling group cannot exceed the sum of the maximum number of instances that is specified by the MaxSize parameter and the maximum weight of the instance type.
	//
	// Valid values of the WeightedCapacity parameter: 1 to 500.
	WeightedCapacity *int32 `json:"WeightedCapacity,omitempty" xml:"WeightedCapacity,omitempty"`
}

func (s CreateScalingGroupRequestLaunchTemplateOverrides) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingGroupRequestLaunchTemplateOverrides) GoString() string {
	return s.String()
}

func (s *CreateScalingGroupRequestLaunchTemplateOverrides) SetInstanceType(v string) *CreateScalingGroupRequestLaunchTemplateOverrides {
	s.InstanceType = &v
	return s
}

func (s *CreateScalingGroupRequestLaunchTemplateOverrides) SetSpotPriceLimit(v float32) *CreateScalingGroupRequestLaunchTemplateOverrides {
	s.SpotPriceLimit = &v
	return s
}

func (s *CreateScalingGroupRequestLaunchTemplateOverrides) SetWeightedCapacity(v int32) *CreateScalingGroupRequestLaunchTemplateOverrides {
	s.WeightedCapacity = &v
	return s
}

type CreateScalingGroupRequestLifecycleHooks struct {
	// The action that Auto Scaling performs in the scaling group when the lifecycle hook times out. Valid values:
	//
	// *   CONTINUE: Auto Scaling continues to respond to scaling requests.
	// *   ABANDON: Auto Scaling releases ECS instances that are created during scale-out activities, or removes ECS instances from the scaling group during scale-in activities.
	//
	// If multiple lifecycle hooks in the scaling group are triggered during a scale-in activity and you set the DefaultResult parameter to ABANDON for one of the lifecycle hooks, Auto Scaling immediately starts to perform the action after the lifecycle hook whose DefaultResult is set to ABANDON times out. In this case, other lifecycle hooks time out ahead of schedule. In other cases, Auto Scaling performs the action only after all lifecycle hooks time out.
	//
	// Default value: CONTINUE.
	DefaultResult *string `json:"DefaultResult,omitempty" xml:"DefaultResult,omitempty"`
	// The period of time before the lifecycle hook times out. When the lifecycle hook times out, Auto Scaling performs the default action. Valid values: 30 to 21600. Unit: seconds.
	//
	// After you create a lifecycle hook, you can call the RecordLifecycleActionHeartbeat operation to extend the timeout period of the lifecycle hook. You can also call the CompleteLifecycleAction operation to end the timeout period ahead of schedule.
	//
	// Default value: 600.
	HeartbeatTimeout *int32 `json:"HeartbeatTimeout,omitempty" xml:"HeartbeatTimeout,omitempty"`
	// The name of the lifecycle hook. After you specify this parameter, you cannot modify the name of the lifecycle hook. If you do not specify this parameter, the ID of the lifecycle hook is used by default.
	LifecycleHookName *string `json:"LifecycleHookName,omitempty" xml:"LifecycleHookName,omitempty"`
	// The type of scaling activities to which the lifecycle hook applies. Valid values:
	//
	// *   SCALE_OUT
	// *   SCALE_IN
	//
	// > If you create lifecycle hooks for your scaling group, you must specify the LifecycleTransition parameter.
	LifecycleTransition *string `json:"LifecycleTransition,omitempty" xml:"LifecycleTransition,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the notification method that Auto Scaling uses to send a notification when a lifecycle hook takes effect. This method can be a Message Service (MNS) queue or an MNS topic. The value of this parameter is in the following format: acs:ess:{region}:{account-id}:{resource-relative-id}.
	//
	// *   region: the region where the scaling group resides
	// *   account-id: the ID of the Alibaba Cloud account
	//
	// Example:
	//
	// *   MNS queue: acs:ess:{region}:{account-id}:queue/{queuename}
	// *   MNS topic: acs:ess:{region}:{account-id}:topic/{topicname}
	NotificationArn *string `json:"NotificationArn,omitempty" xml:"NotificationArn,omitempty"`
	// The fixed string that is included in a notification when Auto Scaling sends the notification which indicates that the scaling activity is pending. The value of this parameter cannot exceed 4,096 characters in length. Auto Scaling sends the value of the notificationmetadata parameter together with the notification. This way, you can categorize and manage your notifications in an efficient manner. The notificationmetadata parameter takes effect only after you specify the notificationarn parameter.
	NotificationMetadata *string `json:"NotificationMetadata,omitempty" xml:"NotificationMetadata,omitempty"`
}

func (s CreateScalingGroupRequestLifecycleHooks) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingGroupRequestLifecycleHooks) GoString() string {
	return s.String()
}

func (s *CreateScalingGroupRequestLifecycleHooks) SetDefaultResult(v string) *CreateScalingGroupRequestLifecycleHooks {
	s.DefaultResult = &v
	return s
}

func (s *CreateScalingGroupRequestLifecycleHooks) SetHeartbeatTimeout(v int32) *CreateScalingGroupRequestLifecycleHooks {
	s.HeartbeatTimeout = &v
	return s
}

func (s *CreateScalingGroupRequestLifecycleHooks) SetLifecycleHookName(v string) *CreateScalingGroupRequestLifecycleHooks {
	s.LifecycleHookName = &v
	return s
}

func (s *CreateScalingGroupRequestLifecycleHooks) SetLifecycleTransition(v string) *CreateScalingGroupRequestLifecycleHooks {
	s.LifecycleTransition = &v
	return s
}

func (s *CreateScalingGroupRequestLifecycleHooks) SetNotificationArn(v string) *CreateScalingGroupRequestLifecycleHooks {
	s.NotificationArn = &v
	return s
}

func (s *CreateScalingGroupRequestLifecycleHooks) SetNotificationMetadata(v string) *CreateScalingGroupRequestLifecycleHooks {
	s.NotificationMetadata = &v
	return s
}

type CreateScalingGroupRequestTags struct {
	// The tag key of the scaling group.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value of the scaling group.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateScalingGroupRequestTags) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingGroupRequestTags) GoString() string {
	return s.String()
}

func (s *CreateScalingGroupRequestTags) SetKey(v string) *CreateScalingGroupRequestTags {
	s.Key = &v
	return s
}

func (s *CreateScalingGroupRequestTags) SetValue(v string) *CreateScalingGroupRequestTags {
	s.Value = &v
	return s
}

type CreateScalingGroupRequestVServerGroups struct {
	// The ID of the CLB instance to which the vServer group belongs.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// Details of the vServer group attributes.
	VServerGroupAttributes []*CreateScalingGroupRequestVServerGroupsVServerGroupAttributes `json:"VServerGroupAttributes,omitempty" xml:"VServerGroupAttributes,omitempty" type:"Repeated"`
}

func (s CreateScalingGroupRequestVServerGroups) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingGroupRequestVServerGroups) GoString() string {
	return s.String()
}

func (s *CreateScalingGroupRequestVServerGroups) SetLoadBalancerId(v string) *CreateScalingGroupRequestVServerGroups {
	s.LoadBalancerId = &v
	return s
}

func (s *CreateScalingGroupRequestVServerGroups) SetVServerGroupAttributes(v []*CreateScalingGroupRequestVServerGroupsVServerGroupAttributes) *CreateScalingGroupRequestVServerGroups {
	s.VServerGroupAttributes = v
	return s
}

type CreateScalingGroupRequestVServerGroupsVServerGroupAttributes struct {
	// The port number used by the ECS instance after the instance is added to the vServer group. Valid values: 1 to 65535.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The ID of the vServer group.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	// The weight of the ECS instance as a backend server after the instance is added to the vServer group. If you increase the weight of an ECS instance, the number of access requests that are forwarded to the ECS instance increases. If you set the Weight parameter for an ECS instance to 0, no access requests are forwarded to the ECS instance. Valid values: 0 to 100. Default value: 50.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s CreateScalingGroupRequestVServerGroupsVServerGroupAttributes) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingGroupRequestVServerGroupsVServerGroupAttributes) GoString() string {
	return s.String()
}

func (s *CreateScalingGroupRequestVServerGroupsVServerGroupAttributes) SetPort(v int32) *CreateScalingGroupRequestVServerGroupsVServerGroupAttributes {
	s.Port = &v
	return s
}

func (s *CreateScalingGroupRequestVServerGroupsVServerGroupAttributes) SetVServerGroupId(v string) *CreateScalingGroupRequestVServerGroupsVServerGroupAttributes {
	s.VServerGroupId = &v
	return s
}

func (s *CreateScalingGroupRequestVServerGroupsVServerGroupAttributes) SetWeight(v int32) *CreateScalingGroupRequestVServerGroupsVServerGroupAttributes {
	s.Weight = &v
	return s
}

type CreateScalingGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s CreateScalingGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingGroupResponseBody) GoString() string {
	return s.String()
}

func (s *CreateScalingGroupResponseBody) SetRequestId(v string) *CreateScalingGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateScalingGroupResponseBody) SetScalingGroupId(v string) *CreateScalingGroupResponseBody {
	s.ScalingGroupId = &v
	return s
}

type CreateScalingGroupResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateScalingGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateScalingGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateScalingGroupResponse) SetHeaders(v map[string]*string) *CreateScalingGroupResponse {
	s.Headers = v
	return s
}

func (s *CreateScalingGroupResponse) SetStatusCode(v int32) *CreateScalingGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateScalingGroupResponse) SetBody(v *CreateScalingGroupResponseBody) *CreateScalingGroupResponse {
	s.Body = v
	return s
}

type CreateScalingRuleRequest struct {
	// The number of instances that must be scaled based on the scaling rule. This parameter is required only if you set the ScalingRuleType parameter to SimpleScalingRule or StepScalingRule. The number of ECS instances that are scaled in a single scaling activity cannot exceed 1,000.
	//
	// *   Valid values if you set the AdjustmentType parameter to QuantityChangeInCapacity: -1000 to 1000.
	// *   Valid values if you set the AdjustmentType parameter to PercentChangeInCapacity: -100 to 10000.
	// *   Valid values if you set the AdjustmentType parameter to TotalCapacity: 0 to 2000.
	AdjustmentType *string `json:"AdjustmentType,omitempty" xml:"AdjustmentType,omitempty"`
	// The type of the scaling rule. Valid values:
	//
	// *   SimpleScalingRule: scales the number of ECS instances based on the values that are specified for the AdjustmentType and AdjustmentValue parameters.
	// *   TargetTrackingScalingRule: calculates the number of ECS instances that must be scaled and maintains the value of a predefined metric close to the value that is specified for the TargetValue parameter.
	// *   StepScalingRule: scales ECS instances in steps based on the specified thresholds and metric values.
	// *   PredictiveScalingRule: uses machine learning to analyze historical monitoring data of the scaling group and predicts the future values of metrics. In addition, Auto Scaling automatically creates scheduled tasks to specify the boundary values for the scaling group.
	//
	// Default value: SimpleScalingRule.
	AdjustmentValue *int32 `json:"AdjustmentValue,omitempty" xml:"AdjustmentValue,omitempty"`
	// The minimum number of instances that must be scaled when the AdjustmentType parameter is set to PercentChangeInCapacity. This parameter takes effect only if you set the ScalingRuleType parameter to SimpleScalingRule or StepScalingRule.
	Cooldown *int32 `json:"Cooldown,omitempty" xml:"Cooldown,omitempty"`
	// The number of consecutive times that the event-triggered task created for scale-in activities must meet the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.
	//
	// Default value: 15.
	DisableScaleIn *bool `json:"DisableScaleIn,omitempty" xml:"DisableScaleIn,omitempty"`
	// The predefined metric that you want to monitor. This parameter is required only if you set the ScalingRuleType parameter to TargetTrackingScalingRule or PredictiveScalingRule.
	//
	// Valid values if you set the ScalingRuleType parameter to TargetTrackingScalingRule:
	//
	// *   CpuUtilization: the average CPU utilization
	// *   ClassicInternetRx: the average inbound Internet traffic over the classic network
	// *   ClassicInternetTx: the average outbound Internet traffic over the classic network
	// *   VpcInternetRx: the average inbound Internet traffic over the virtual private cloud (VPC)
	// *   VpcInternetTx: the average outbound Internet traffic over the VPC
	// *   IntranetRx: the average inbound traffic over the internal network
	// *   IntranetTx: the average outbound traffic over the internal network
	//
	// Valid values if you set the ScalingRuleType parameter to PredictiveScalingRule:
	//
	// *   CpuUtilization: the average CPU utilization
	// *   IntranetRx: the average inbound traffic over the internal network
	// *   IntranetTx: the average outbound traffic over the internal network
	EstimatedInstanceWarmup *int32 `json:"EstimatedInstanceWarmup,omitempty" xml:"EstimatedInstanceWarmup,omitempty"`
	// Details of the step adjustments.
	InitialMaxSize *int32 `json:"InitialMaxSize,omitempty" xml:"InitialMaxSize,omitempty"`
	// The target value. This parameter is required only if you set the ScalingRuleType parameter to TargetTrackingScalingRule or PredictiveScalingRule. The value must be greater than 0 and can have up to three decimal places.
	MetricName *string `json:"MetricName,omitempty" xml:"MetricName,omitempty"`
	// The scaling method of the scaling rule. This parameter is required only if you set the ScalingRuleType parameter to SimpleScalingRule or StepScalingRule. Valid values:
	//
	// *   QuantityChangeInCapacity: adds the specified number of ECS instances to or removes the specified number of ECS instances from the scaling group.
	// *   PercentChangeInCapacity: adds the specified percentage of ECS instances to or removes the specified percentage of ECS instances from the scaling group.
	// *   TotalCapacity: adjusts the number of ECS instances in the scaling group to a specified number.
	MinAdjustmentMagnitude *int32  `json:"MinAdjustmentMagnitude,omitempty" xml:"MinAdjustmentMagnitude,omitempty"`
	OwnerAccount           *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The maximum value for predication tasks. Valid values:
	//
	// *   MaxOverridePredictiveValue: uses the initial maximum capacity as the maximum value for prediction tasks if the predicted value is greater than the initial maximum capacity.
	// *   PredictiveValueOverrideMax: uses the predicted value as the maximum value for prediction tasks if the predicted value is greater than the initial maximum capacity.
	// *   PredictiveValueOverrideMaxWithBuffer: increases the predicted value by a percentage that is specified by the PredictiveValueBuffer parameter. If the predicted value that is increased by the percentage is greater than the initial maximum capacity, the increased value is used as the maximum value for prediction tasks.
	//
	// Default value: MaxOverridePredictiveValue.
	PredictiveScalingMode *string `json:"PredictiveScalingMode,omitempty" xml:"PredictiveScalingMode,omitempty"`
	// The maximum number of ECS instances in the scaling group. If you specify this parameter, you must also specify the PredictiveValueBehavior parameter.
	//
	// The default value of this parameter is the value of the MaxSize parameter.
	PredictiveTaskBufferTime *int32 `json:"PredictiveTaskBufferTime,omitempty" xml:"PredictiveTaskBufferTime,omitempty"`
	// The percentage of the increment to the predicted value when the PredictiveValueBehavior parameter is set to PredictiveValueOverrideMaxWithBuffer. If the predicted value increased by this percentage is greater than the initial maximum capacity, the increased value is used as the maximum value for prediction tasks. Valid values: 0 to 100.
	//
	// Default value: 0.
	PredictiveValueBehavior *string `json:"PredictiveValueBehavior,omitempty" xml:"PredictiveValueBehavior,omitempty"`
	// The amount of buffer time before the prediction task is executed. By default, all prediction tasks that are automatically created for a predictive scaling rule are executed on the hour. You can specify an amount of buffer time for resource preparation before the prediction tasks are executed. Valid values: 0 to 60. Unit: minutes.
	//
	// Default value: 0.
	PredictiveValueBuffer *int32 `json:"PredictiveValueBuffer,omitempty" xml:"PredictiveValueBuffer,omitempty"`
	// The unique identifier of the scaling rule.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The number of consecutive times that the event-triggered task created for scale-out activities must meet the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.
	//
	// Default value: 3.
	ScaleInEvaluationCount *int32 `json:"ScaleInEvaluationCount,omitempty" xml:"ScaleInEvaluationCount,omitempty"`
	// The mode of the predictive scaling rule. Valid values:
	//
	// *   PredictAndScale: produces predictions and creates prediction tasks.
	// *   PredictOnly: produces predictions but does not create prediction tasks.
	//
	// Default value: PredictAndScale.
	ScaleOutEvaluationCount *int32 `json:"ScaleOutEvaluationCount,omitempty" xml:"ScaleOutEvaluationCount,omitempty"`
	// The name of the scaling rule. It must be 2 to 64 characters in length, and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). It must start with a letter or a digit. The name of a scaling rule must be unique in the scaling group to which the scaling rule belongs and within an Alibaba Cloud account.
	//
	// If you do not specify this parameter, the value of the ScalingRuleId parameter is used.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The cooldown time of the scaling rule. This parameter is available only if you set the ScalingRuleType parameter to SimpleScalingRule. Valid values: 0 to 86400. Unit: seconds.
	//
	// By default, this parameter is left empty.
	ScalingRuleName *string `json:"ScalingRuleName,omitempty" xml:"ScalingRuleName,omitempty"`
	// The warmup period of an instance. This parameter is available only if you set the ScalingRuleType parameter to TargetTrackingScalingRule or PredictiveScalingRule. Auto Scaling adds ECS instances that are in the warmup state to a scaling group but does not report monitoring data to CloudMonitor during the warmup period.
	//
	// > Auto Scaling calculates the number of ECS instances that must be scaled. ECS instances in the warmup state are not counted towards the current capacity of the scaling group.
	//
	// Valid values: 0 to 86400. Unit: seconds.
	//
	// Default value: 300.
	ScalingRuleType *string `json:"ScalingRuleType,omitempty" xml:"ScalingRuleType,omitempty"`
	// Details of the step adjustments.
	StepAdjustments []*CreateScalingRuleRequestStepAdjustments `json:"StepAdjustments,omitempty" xml:"StepAdjustments,omitempty" type:"Repeated"`
	// Specifies whether to disable scale-in. This parameter is available only if you set the ScalingRuleType parameter to TargetTrackingScalingRule.
	//
	// Default value: false.
	TargetValue *float32 `json:"TargetValue,omitempty" xml:"TargetValue,omitempty"`
}

func (s CreateScalingRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingRuleRequest) GoString() string {
	return s.String()
}

func (s *CreateScalingRuleRequest) SetAdjustmentType(v string) *CreateScalingRuleRequest {
	s.AdjustmentType = &v
	return s
}

func (s *CreateScalingRuleRequest) SetAdjustmentValue(v int32) *CreateScalingRuleRequest {
	s.AdjustmentValue = &v
	return s
}

func (s *CreateScalingRuleRequest) SetCooldown(v int32) *CreateScalingRuleRequest {
	s.Cooldown = &v
	return s
}

func (s *CreateScalingRuleRequest) SetDisableScaleIn(v bool) *CreateScalingRuleRequest {
	s.DisableScaleIn = &v
	return s
}

func (s *CreateScalingRuleRequest) SetEstimatedInstanceWarmup(v int32) *CreateScalingRuleRequest {
	s.EstimatedInstanceWarmup = &v
	return s
}

func (s *CreateScalingRuleRequest) SetInitialMaxSize(v int32) *CreateScalingRuleRequest {
	s.InitialMaxSize = &v
	return s
}

func (s *CreateScalingRuleRequest) SetMetricName(v string) *CreateScalingRuleRequest {
	s.MetricName = &v
	return s
}

func (s *CreateScalingRuleRequest) SetMinAdjustmentMagnitude(v int32) *CreateScalingRuleRequest {
	s.MinAdjustmentMagnitude = &v
	return s
}

func (s *CreateScalingRuleRequest) SetOwnerAccount(v string) *CreateScalingRuleRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateScalingRuleRequest) SetOwnerId(v int64) *CreateScalingRuleRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateScalingRuleRequest) SetPredictiveScalingMode(v string) *CreateScalingRuleRequest {
	s.PredictiveScalingMode = &v
	return s
}

func (s *CreateScalingRuleRequest) SetPredictiveTaskBufferTime(v int32) *CreateScalingRuleRequest {
	s.PredictiveTaskBufferTime = &v
	return s
}

func (s *CreateScalingRuleRequest) SetPredictiveValueBehavior(v string) *CreateScalingRuleRequest {
	s.PredictiveValueBehavior = &v
	return s
}

func (s *CreateScalingRuleRequest) SetPredictiveValueBuffer(v int32) *CreateScalingRuleRequest {
	s.PredictiveValueBuffer = &v
	return s
}

func (s *CreateScalingRuleRequest) SetRegionId(v string) *CreateScalingRuleRequest {
	s.RegionId = &v
	return s
}

func (s *CreateScalingRuleRequest) SetResourceOwnerAccount(v string) *CreateScalingRuleRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateScalingRuleRequest) SetScaleInEvaluationCount(v int32) *CreateScalingRuleRequest {
	s.ScaleInEvaluationCount = &v
	return s
}

func (s *CreateScalingRuleRequest) SetScaleOutEvaluationCount(v int32) *CreateScalingRuleRequest {
	s.ScaleOutEvaluationCount = &v
	return s
}

func (s *CreateScalingRuleRequest) SetScalingGroupId(v string) *CreateScalingRuleRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *CreateScalingRuleRequest) SetScalingRuleName(v string) *CreateScalingRuleRequest {
	s.ScalingRuleName = &v
	return s
}

func (s *CreateScalingRuleRequest) SetScalingRuleType(v string) *CreateScalingRuleRequest {
	s.ScalingRuleType = &v
	return s
}

func (s *CreateScalingRuleRequest) SetStepAdjustments(v []*CreateScalingRuleRequestStepAdjustments) *CreateScalingRuleRequest {
	s.StepAdjustments = v
	return s
}

func (s *CreateScalingRuleRequest) SetTargetValue(v float32) *CreateScalingRuleRequest {
	s.TargetValue = &v
	return s
}

type CreateScalingRuleRequestStepAdjustments struct {
	// The region ID of the scaling group.
	MetricIntervalLowerBound *float32 `json:"MetricIntervalLowerBound,omitempty" xml:"MetricIntervalLowerBound,omitempty"`
	// The number of ECS instances that you want to scale in a step adjustment. This parameter is available only if you set the ScalingRuleType parameter to StepScalingRule.
	MetricIntervalUpperBound *float32 `json:"MetricIntervalUpperBound,omitempty" xml:"MetricIntervalUpperBound,omitempty"`
	// The lower limit specified in a step adjustment. This parameter is available only if you set the ScalingRuleType parameter to StepScalingRule. Valid values: -9.999999E18 to 9.999999E18.
	ScalingAdjustment *int32 `json:"ScalingAdjustment,omitempty" xml:"ScalingAdjustment,omitempty"`
}

func (s CreateScalingRuleRequestStepAdjustments) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingRuleRequestStepAdjustments) GoString() string {
	return s.String()
}

func (s *CreateScalingRuleRequestStepAdjustments) SetMetricIntervalLowerBound(v float32) *CreateScalingRuleRequestStepAdjustments {
	s.MetricIntervalLowerBound = &v
	return s
}

func (s *CreateScalingRuleRequestStepAdjustments) SetMetricIntervalUpperBound(v float32) *CreateScalingRuleRequestStepAdjustments {
	s.MetricIntervalUpperBound = &v
	return s
}

func (s *CreateScalingRuleRequestStepAdjustments) SetScalingAdjustment(v int32) *CreateScalingRuleRequestStepAdjustments {
	s.ScalingAdjustment = &v
	return s
}

type CreateScalingRuleResponseBody struct {
	// The ID of the scaling rule, which is generated by the system and is globally unique.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request.
	ScalingRuleAri *string `json:"ScalingRuleAri,omitempty" xml:"ScalingRuleAri,omitempty"`
	// auditing
	ScalingRuleId *string `json:"ScalingRuleId,omitempty" xml:"ScalingRuleId,omitempty"`
}

func (s CreateScalingRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingRuleResponseBody) GoString() string {
	return s.String()
}

func (s *CreateScalingRuleResponseBody) SetRequestId(v string) *CreateScalingRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateScalingRuleResponseBody) SetScalingRuleAri(v string) *CreateScalingRuleResponseBody {
	s.ScalingRuleAri = &v
	return s
}

func (s *CreateScalingRuleResponseBody) SetScalingRuleId(v string) *CreateScalingRuleResponseBody {
	s.ScalingRuleId = &v
	return s
}

type CreateScalingRuleResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateScalingRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateScalingRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateScalingRuleResponse) GoString() string {
	return s.String()
}

func (s *CreateScalingRuleResponse) SetHeaders(v map[string]*string) *CreateScalingRuleResponse {
	s.Headers = v
	return s
}

func (s *CreateScalingRuleResponse) SetStatusCode(v int32) *CreateScalingRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateScalingRuleResponse) SetBody(v *CreateScalingRuleResponseBody) *CreateScalingRuleResponse {
	s.Body = v
	return s
}

type CreateScheduledTaskRequest struct {
	// The scaling rule that you want to execute when the scheduled task is triggered. Specify the unique identifier of the scaling rule. If you specify the `ScheduledAction` parameter, you must select an existing scaling rule for the scheduled task.
	//
	// > You cannot specify the `ScheduledAction` and `ScalingGroupId` parameters at the same time.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the scaling group whose number of instances must be modified when the scheduled task is triggered. If you specify the `ScalingGroupId` parameter for a scheduled task, you must specify the minimum, maximum, or expected numbers of instances for a scaling group in the scheduled task. That is, you must specify at least one of the `MinValue`, `MaxValue`, and `DesiredCapacity` parameters.
	//
	// > You cannot specify the `ScheduledAction` and `ScalingGroupId` parameters at the same time.
	DesiredCapacity *int32 `json:"DesiredCapacity,omitempty" xml:"DesiredCapacity,omitempty"`
	// The minimum number of instances in the scaling group if you specify the ScalingGroupId parameter.
	LaunchExpirationTime *int32 `json:"LaunchExpirationTime,omitempty" xml:"LaunchExpirationTime,omitempty"`
	// The interval at which the scheduled task is repeated. Valid values:
	//
	// *   Daily: The scheduled task is executed once every specified number of days.
	// *   Weekly: The scheduled task is executed on each specified day of the week.
	// *   Monthly: The scheduled task is executed on each specified day of the month.
	// *   Cron: The scheduled task is executed based on the specified cron expression.
	//
	// You must specify the `RecurrenceType` and `RecurrenceValue` parameters at the same time.
	LaunchTime *string `json:"LaunchTime,omitempty" xml:"LaunchTime,omitempty"`
	// The expected number of instances in the scaling group if you specify the ScalingGroupId parameter.
	//
	// > You must specify the `DesiredCapacity` parameter when you create a scaling group.
	MaxValue *int32 `json:"MaxValue,omitempty" xml:"MaxValue,omitempty"`
	// The maximum number of instances in the scaling group if you specify the ScalingGroupId parameter.
	MinValue     *int32  `json:"MinValue,omitempty" xml:"MinValue,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The point in time at which the scheduled task is triggered. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mmZ format. The time must be in UTC. You cannot enter a point in time that is later than 90 days from the point in time at which the scheduled task is created.
	//
	// *   If you specify the `RecurrenceType` parameter, the scheduled task is repeatedly executed at the point in time that is specified by the LaunchTime parameter.
	// *   If you do not specify the `RecurrenceType` parameter, the task is executed only once at the point in time that is specified by the LaunchTime parameter.
	RecurrenceEndTime *string `json:"RecurrenceEndTime,omitempty" xml:"RecurrenceEndTime,omitempty"`
	// The number of recurrences of the scheduled task.
	//
	// *   If you set the `RecurrenceType` parameter to `Daily`, you can specify only one value for this parameter. Valid values: 1 to 31.
	// *   If you set the `RecurrenceType` parameter to `Weekly`, you can specify multiple values for this parameter. Separate the values with commas (,). The values that correspond to Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, and Saturday are 0, 1, 2, 3, 4, 5, and 6.``
	// *   If you set the `RecurrenceType` parameter to `Monthly`, you can specify two values in the `A-B` format for this parameter. Valid values of A and B: 1 to 31. B must be greater than or equal to A.
	// *   If you set the `RecurrenceType` parameter to `Cron`, you can specify a cron expression. A cron expression is written in UTC time and consists of the following fields: minute, hour, day, month, and week. The expression can contain the letters L and W and the following wildcard characters: commas (,), question marks (?), hyphens (-), asterisks (\*), number signs (#), and forward slashes (/).
	//
	// You must specify both the `RecurrenceType` parameter and the `RecurrenceValue` parameter.
	RecurrenceType *string `json:"RecurrenceType,omitempty" xml:"RecurrenceType,omitempty"`
	// Specifies whether to enable the scheduled task.
	//
	// *   true
	// *   false
	//
	// Default value: true.
	RecurrenceValue *string `json:"RecurrenceValue,omitempty" xml:"RecurrenceValue,omitempty"`
	// The name of the scheduled task. The name must be 2 to 64 characters in length, and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). The name must start with a letter or a digit. The name of the scheduled task must be unique in the region and within the Alibaba Cloud account.
	//
	// If you do not specify this parameter, the value of the `ScheduledTaskId` parameter is used.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The globally unique ID of the scheduled task. The globally unique ID is generated by the system.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The end time of the scheduled task. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mmZ format.
	//
	// The time must be in UTC. You cannot enter a point in time that is later than 365 days from the point in time at which the scheduled task is created.
	ScheduledAction *string `json:"ScheduledAction,omitempty" xml:"ScheduledAction,omitempty"`
	// The description of the scheduled task. The description must be 2 to 200 characters in length.
	ScheduledTaskName *string `json:"ScheduledTaskName,omitempty" xml:"ScheduledTaskName,omitempty"`
	// The time period during which the failed scheduled task can be retried. Unit: seconds. Valid values: 0 to 1800.
	//
	// Default value: 600.
	TaskEnabled *bool `json:"TaskEnabled,omitempty" xml:"TaskEnabled,omitempty"`
}

func (s CreateScheduledTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateScheduledTaskRequest) GoString() string {
	return s.String()
}

func (s *CreateScheduledTaskRequest) SetDescription(v string) *CreateScheduledTaskRequest {
	s.Description = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetDesiredCapacity(v int32) *CreateScheduledTaskRequest {
	s.DesiredCapacity = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetLaunchExpirationTime(v int32) *CreateScheduledTaskRequest {
	s.LaunchExpirationTime = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetLaunchTime(v string) *CreateScheduledTaskRequest {
	s.LaunchTime = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetMaxValue(v int32) *CreateScheduledTaskRequest {
	s.MaxValue = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetMinValue(v int32) *CreateScheduledTaskRequest {
	s.MinValue = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetOwnerAccount(v string) *CreateScheduledTaskRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetOwnerId(v int64) *CreateScheduledTaskRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetRecurrenceEndTime(v string) *CreateScheduledTaskRequest {
	s.RecurrenceEndTime = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetRecurrenceType(v string) *CreateScheduledTaskRequest {
	s.RecurrenceType = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetRecurrenceValue(v string) *CreateScheduledTaskRequest {
	s.RecurrenceValue = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetRegionId(v string) *CreateScheduledTaskRequest {
	s.RegionId = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetResourceOwnerAccount(v string) *CreateScheduledTaskRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetScalingGroupId(v string) *CreateScheduledTaskRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetScheduledAction(v string) *CreateScheduledTaskRequest {
	s.ScheduledAction = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetScheduledTaskName(v string) *CreateScheduledTaskRequest {
	s.ScheduledTaskName = &v
	return s
}

func (s *CreateScheduledTaskRequest) SetTaskEnabled(v bool) *CreateScheduledTaskRequest {
	s.TaskEnabled = &v
	return s
}

type CreateScheduledTaskResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request.
	ScheduledTaskId *string `json:"ScheduledTaskId,omitempty" xml:"ScheduledTaskId,omitempty"`
}

func (s CreateScheduledTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateScheduledTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CreateScheduledTaskResponseBody) SetRequestId(v string) *CreateScheduledTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateScheduledTaskResponseBody) SetScheduledTaskId(v string) *CreateScheduledTaskResponseBody {
	s.ScheduledTaskId = &v
	return s
}

type CreateScheduledTaskResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateScheduledTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateScheduledTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateScheduledTaskResponse) GoString() string {
	return s.String()
}

func (s *CreateScheduledTaskResponse) SetHeaders(v map[string]*string) *CreateScheduledTaskResponse {
	s.Headers = v
	return s
}

func (s *CreateScheduledTaskResponse) SetStatusCode(v int32) *CreateScheduledTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateScheduledTaskResponse) SetBody(v *CreateScheduledTaskResponseBody) *CreateScheduledTaskResponse {
	s.Body = v
	return s
}

type DeactivateScalingConfigurationRequest struct {
	OwnerAccount           *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount   *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ScalingConfigurationId *string `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
}

func (s DeactivateScalingConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s DeactivateScalingConfigurationRequest) GoString() string {
	return s.String()
}

func (s *DeactivateScalingConfigurationRequest) SetOwnerAccount(v string) *DeactivateScalingConfigurationRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeactivateScalingConfigurationRequest) SetOwnerId(v int64) *DeactivateScalingConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *DeactivateScalingConfigurationRequest) SetResourceOwnerAccount(v string) *DeactivateScalingConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeactivateScalingConfigurationRequest) SetScalingConfigurationId(v string) *DeactivateScalingConfigurationRequest {
	s.ScalingConfigurationId = &v
	return s
}

type DeactivateScalingConfigurationResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeactivateScalingConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeactivateScalingConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *DeactivateScalingConfigurationResponseBody) SetRequestId(v string) *DeactivateScalingConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type DeactivateScalingConfigurationResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeactivateScalingConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeactivateScalingConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s DeactivateScalingConfigurationResponse) GoString() string {
	return s.String()
}

func (s *DeactivateScalingConfigurationResponse) SetHeaders(v map[string]*string) *DeactivateScalingConfigurationResponse {
	s.Headers = v
	return s
}

func (s *DeactivateScalingConfigurationResponse) SetStatusCode(v int32) *DeactivateScalingConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *DeactivateScalingConfigurationResponse) SetBody(v *DeactivateScalingConfigurationResponseBody) *DeactivateScalingConfigurationResponse {
	s.Body = v
	return s
}

type DeleteAlarmRequest struct {
	// The ID of the event-triggered task.
	AlarmTaskId *string `json:"AlarmTaskId,omitempty" xml:"AlarmTaskId,omitempty"`
	OwnerId     *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the event-triggered task.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
}

func (s DeleteAlarmRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAlarmRequest) GoString() string {
	return s.String()
}

func (s *DeleteAlarmRequest) SetAlarmTaskId(v string) *DeleteAlarmRequest {
	s.AlarmTaskId = &v
	return s
}

func (s *DeleteAlarmRequest) SetOwnerId(v int64) *DeleteAlarmRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteAlarmRequest) SetRegionId(v string) *DeleteAlarmRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteAlarmRequest) SetResourceOwnerAccount(v string) *DeleteAlarmRequest {
	s.ResourceOwnerAccount = &v
	return s
}

type DeleteAlarmResponseBody struct {
	// The ID of the request.
	AlarmTaskId *string `json:"AlarmTaskId,omitempty" xml:"AlarmTaskId,omitempty"`
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAlarmResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAlarmResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAlarmResponseBody) SetAlarmTaskId(v string) *DeleteAlarmResponseBody {
	s.AlarmTaskId = &v
	return s
}

func (s *DeleteAlarmResponseBody) SetRequestId(v string) *DeleteAlarmResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAlarmResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAlarmResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAlarmResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAlarmResponse) GoString() string {
	return s.String()
}

func (s *DeleteAlarmResponse) SetHeaders(v map[string]*string) *DeleteAlarmResponse {
	s.Headers = v
	return s
}

func (s *DeleteAlarmResponse) SetStatusCode(v int32) *DeleteAlarmResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAlarmResponse) SetBody(v *DeleteAlarmResponseBody) *DeleteAlarmResponse {
	s.Body = v
	return s
}

type DeleteEciScalingConfigurationRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request. This request ID is returned regardless of whether the request is successful.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The region ID of the scaling group.
	ScalingConfigurationId *string `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
}

func (s DeleteEciScalingConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteEciScalingConfigurationRequest) GoString() string {
	return s.String()
}

func (s *DeleteEciScalingConfigurationRequest) SetOwnerAccount(v string) *DeleteEciScalingConfigurationRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteEciScalingConfigurationRequest) SetOwnerId(v int64) *DeleteEciScalingConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteEciScalingConfigurationRequest) SetRegionId(v string) *DeleteEciScalingConfigurationRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteEciScalingConfigurationRequest) SetResourceOwnerAccount(v string) *DeleteEciScalingConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteEciScalingConfigurationRequest) SetScalingConfigurationId(v string) *DeleteEciScalingConfigurationRequest {
	s.ScalingConfigurationId = &v
	return s
}

type DeleteEciScalingConfigurationResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteEciScalingConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteEciScalingConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteEciScalingConfigurationResponseBody) SetRequestId(v string) *DeleteEciScalingConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type DeleteEciScalingConfigurationResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteEciScalingConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteEciScalingConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteEciScalingConfigurationResponse) GoString() string {
	return s.String()
}

func (s *DeleteEciScalingConfigurationResponse) SetHeaders(v map[string]*string) *DeleteEciScalingConfigurationResponse {
	s.Headers = v
	return s
}

func (s *DeleteEciScalingConfigurationResponse) SetStatusCode(v int32) *DeleteEciScalingConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteEciScalingConfigurationResponse) SetBody(v *DeleteEciScalingConfigurationResponseBody) *DeleteEciScalingConfigurationResponse {
	s.Body = v
	return s
}

type DeleteLifecycleHookRequest struct {
	// The ID of the lifecycle hook.
	LifecycleHookId *string `json:"LifecycleHookId,omitempty" xml:"LifecycleHookId,omitempty"`
	// The name of the lifecycle hook.
	LifecycleHookName *string `json:"LifecycleHookName,omitempty" xml:"LifecycleHookName,omitempty"`
	OwnerAccount      *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId           *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DeleteLifecycleHookRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteLifecycleHookRequest) GoString() string {
	return s.String()
}

func (s *DeleteLifecycleHookRequest) SetLifecycleHookId(v string) *DeleteLifecycleHookRequest {
	s.LifecycleHookId = &v
	return s
}

func (s *DeleteLifecycleHookRequest) SetLifecycleHookName(v string) *DeleteLifecycleHookRequest {
	s.LifecycleHookName = &v
	return s
}

func (s *DeleteLifecycleHookRequest) SetOwnerAccount(v string) *DeleteLifecycleHookRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteLifecycleHookRequest) SetOwnerId(v int64) *DeleteLifecycleHookRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteLifecycleHookRequest) SetRegionId(v string) *DeleteLifecycleHookRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteLifecycleHookRequest) SetResourceOwnerAccount(v string) *DeleteLifecycleHookRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteLifecycleHookRequest) SetScalingGroupId(v string) *DeleteLifecycleHookRequest {
	s.ScalingGroupId = &v
	return s
}

type DeleteLifecycleHookResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteLifecycleHookResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteLifecycleHookResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteLifecycleHookResponseBody) SetRequestId(v string) *DeleteLifecycleHookResponseBody {
	s.RequestId = &v
	return s
}

type DeleteLifecycleHookResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteLifecycleHookResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteLifecycleHookResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteLifecycleHookResponse) GoString() string {
	return s.String()
}

func (s *DeleteLifecycleHookResponse) SetHeaders(v map[string]*string) *DeleteLifecycleHookResponse {
	s.Headers = v
	return s
}

func (s *DeleteLifecycleHookResponse) SetStatusCode(v int32) *DeleteLifecycleHookResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteLifecycleHookResponse) SetBody(v *DeleteLifecycleHookResponseBody) *DeleteLifecycleHookResponse {
	s.Body = v
	return s
}

type DeleteNotificationConfigurationRequest struct {
	// The region ID of the scaling group.
	NotificationArn *string `json:"NotificationArn,omitempty" xml:"NotificationArn,omitempty"`
	OwnerId         *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the notification method. The following list describes the value formats of this parameter:
	//
	// *   If you use CloudMonitor as the notification party, the value format of this parameter is acs:ess:{region-id}:{account-id}:cloudmonitor.
	// *   If you use an MNS queue as the notification party, the value format of this parameter is acs:mns:{region-id}:{account-id}:queue/{queuename}.
	// *   If you use an MNS topic as the notification party, the value format of this parameter is acs:mns:{region-id}:{account-id}:topic/{topicname}.
	//
	// The variables in the preceding formats have the following meanings:
	//
	// *   region-id: the region ID of the scaling group.
	// *   account-id: the ID of the Alibaba Cloud account.
	// *   queuename: the name of the MNS queue.
	// *   topicname: the name of the MNS topic.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DeleteNotificationConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteNotificationConfigurationRequest) GoString() string {
	return s.String()
}

func (s *DeleteNotificationConfigurationRequest) SetNotificationArn(v string) *DeleteNotificationConfigurationRequest {
	s.NotificationArn = &v
	return s
}

func (s *DeleteNotificationConfigurationRequest) SetOwnerId(v int64) *DeleteNotificationConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteNotificationConfigurationRequest) SetRegionId(v string) *DeleteNotificationConfigurationRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteNotificationConfigurationRequest) SetResourceOwnerAccount(v string) *DeleteNotificationConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteNotificationConfigurationRequest) SetScalingGroupId(v string) *DeleteNotificationConfigurationRequest {
	s.ScalingGroupId = &v
	return s
}

type DeleteNotificationConfigurationResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteNotificationConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteNotificationConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteNotificationConfigurationResponseBody) SetRequestId(v string) *DeleteNotificationConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type DeleteNotificationConfigurationResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteNotificationConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteNotificationConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteNotificationConfigurationResponse) GoString() string {
	return s.String()
}

func (s *DeleteNotificationConfigurationResponse) SetHeaders(v map[string]*string) *DeleteNotificationConfigurationResponse {
	s.Headers = v
	return s
}

func (s *DeleteNotificationConfigurationResponse) SetStatusCode(v int32) *DeleteNotificationConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteNotificationConfigurationResponse) SetBody(v *DeleteNotificationConfigurationResponseBody) *DeleteNotificationConfigurationResponse {
	s.Body = v
	return s
}

type DeleteScalingConfigurationRequest struct {
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the request.
	ScalingConfigurationId *string `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
}

func (s DeleteScalingConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteScalingConfigurationRequest) GoString() string {
	return s.String()
}

func (s *DeleteScalingConfigurationRequest) SetOwnerAccount(v string) *DeleteScalingConfigurationRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteScalingConfigurationRequest) SetOwnerId(v int64) *DeleteScalingConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteScalingConfigurationRequest) SetResourceOwnerAccount(v string) *DeleteScalingConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteScalingConfigurationRequest) SetScalingConfigurationId(v string) *DeleteScalingConfigurationRequest {
	s.ScalingConfigurationId = &v
	return s
}

type DeleteScalingConfigurationResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteScalingConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteScalingConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteScalingConfigurationResponseBody) SetRequestId(v string) *DeleteScalingConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type DeleteScalingConfigurationResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteScalingConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteScalingConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteScalingConfigurationResponse) GoString() string {
	return s.String()
}

func (s *DeleteScalingConfigurationResponse) SetHeaders(v map[string]*string) *DeleteScalingConfigurationResponse {
	s.Headers = v
	return s
}

func (s *DeleteScalingConfigurationResponse) SetStatusCode(v int32) *DeleteScalingConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteScalingConfigurationResponse) SetBody(v *DeleteScalingConfigurationResponseBody) *DeleteScalingConfigurationResponse {
	s.Body = v
	return s
}

type DeleteScalingGroupRequest struct {
	// The region ID of the scaling group.
	ForceDelete  *bool   `json:"ForceDelete,omitempty" xml:"ForceDelete,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// Specifies whether to forcibly delete the scaling group and release Elastic Compute Service (ECS) instances in the scaling group when ECS instances or ongoing scaling activities exist in the scaling group. Valid values:
	//
	// *   true: forcibly deletes the scaling group. The scaling group is disabled and new scaling requests are rejected. After all existing scaling requests are processed, the ECS instances are removed from the scaling group. Then, the scaling group is deleted. If the ECS instances are manually added to the scaling group, the ECS instances are only removed from the scaling group. If the ECS instances are automatically created and added to the scaling group, the ECS instances are removed from the scaling group and then released.
	//
	// *   false: does not forcibly delete the scaling group. The scaling group is disabled and then deleted if the following conditions are met:
	//
	//     *   No scaling activities are in process in the scaling group.
	//     *   The Total Capacity parameter is set to 0. A value of 0 specifies that no ECS instances exist in the scaling group.
	//
	// Default value: false.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DeleteScalingGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteScalingGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteScalingGroupRequest) SetForceDelete(v bool) *DeleteScalingGroupRequest {
	s.ForceDelete = &v
	return s
}

func (s *DeleteScalingGroupRequest) SetOwnerAccount(v string) *DeleteScalingGroupRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteScalingGroupRequest) SetOwnerId(v int64) *DeleteScalingGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteScalingGroupRequest) SetRegionId(v string) *DeleteScalingGroupRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteScalingGroupRequest) SetResourceOwnerAccount(v string) *DeleteScalingGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteScalingGroupRequest) SetScalingGroupId(v string) *DeleteScalingGroupRequest {
	s.ScalingGroupId = &v
	return s
}

type DeleteScalingGroupResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteScalingGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteScalingGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteScalingGroupResponseBody) SetRequestId(v string) *DeleteScalingGroupResponseBody {
	s.RequestId = &v
	return s
}

type DeleteScalingGroupResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteScalingGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteScalingGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteScalingGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteScalingGroupResponse) SetHeaders(v map[string]*string) *DeleteScalingGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteScalingGroupResponse) SetStatusCode(v int32) *DeleteScalingGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteScalingGroupResponse) SetBody(v *DeleteScalingGroupResponseBody) *DeleteScalingGroupResponse {
	s.Body = v
	return s
}

type DeleteScalingRuleRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The region ID of the scaling group.
	ScalingRuleId *string `json:"ScalingRuleId,omitempty" xml:"ScalingRuleId,omitempty"`
}

func (s DeleteScalingRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteScalingRuleRequest) GoString() string {
	return s.String()
}

func (s *DeleteScalingRuleRequest) SetOwnerAccount(v string) *DeleteScalingRuleRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteScalingRuleRequest) SetOwnerId(v int64) *DeleteScalingRuleRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteScalingRuleRequest) SetRegionId(v string) *DeleteScalingRuleRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteScalingRuleRequest) SetResourceOwnerAccount(v string) *DeleteScalingRuleRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteScalingRuleRequest) SetScalingRuleId(v string) *DeleteScalingRuleRequest {
	s.ScalingRuleId = &v
	return s
}

type DeleteScalingRuleResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteScalingRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteScalingRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteScalingRuleResponseBody) SetRequestId(v string) *DeleteScalingRuleResponseBody {
	s.RequestId = &v
	return s
}

type DeleteScalingRuleResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteScalingRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteScalingRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteScalingRuleResponse) GoString() string {
	return s.String()
}

func (s *DeleteScalingRuleResponse) SetHeaders(v map[string]*string) *DeleteScalingRuleResponse {
	s.Headers = v
	return s
}

func (s *DeleteScalingRuleResponse) SetStatusCode(v int32) *DeleteScalingRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteScalingRuleResponse) SetBody(v *DeleteScalingRuleResponseBody) *DeleteScalingRuleResponse {
	s.Body = v
	return s
}

type DeleteScheduledTaskRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The region ID of the scheduled task.
	ScheduledTaskId *string `json:"ScheduledTaskId,omitempty" xml:"ScheduledTaskId,omitempty"`
}

func (s DeleteScheduledTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteScheduledTaskRequest) GoString() string {
	return s.String()
}

func (s *DeleteScheduledTaskRequest) SetOwnerAccount(v string) *DeleteScheduledTaskRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteScheduledTaskRequest) SetOwnerId(v int64) *DeleteScheduledTaskRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteScheduledTaskRequest) SetRegionId(v string) *DeleteScheduledTaskRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteScheduledTaskRequest) SetResourceOwnerAccount(v string) *DeleteScheduledTaskRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteScheduledTaskRequest) SetScheduledTaskId(v string) *DeleteScheduledTaskRequest {
	s.ScheduledTaskId = &v
	return s
}

type DeleteScheduledTaskResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteScheduledTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteScheduledTaskResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteScheduledTaskResponseBody) SetRequestId(v string) *DeleteScheduledTaskResponseBody {
	s.RequestId = &v
	return s
}

type DeleteScheduledTaskResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteScheduledTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteScheduledTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteScheduledTaskResponse) GoString() string {
	return s.String()
}

func (s *DeleteScheduledTaskResponse) SetHeaders(v map[string]*string) *DeleteScheduledTaskResponse {
	s.Headers = v
	return s
}

func (s *DeleteScheduledTaskResponse) SetStatusCode(v int32) *DeleteScheduledTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteScheduledTaskResponse) SetBody(v *DeleteScheduledTaskResponseBody) *DeleteScheduledTaskResponse {
	s.Body = v
	return s
}

type DescribeAlarmsRequest struct {
	// The ID of the event-triggered task.
	AlarmTaskId *string `json:"AlarmTaskId,omitempty" xml:"AlarmTaskId,omitempty"`
	// Specifies whether to enable the event-triggered task. Valid values:
	//
	// *   true: enables the event-triggered task.
	// *   false: disables the event-triggered task.
	IsEnable *bool `json:"IsEnable,omitempty" xml:"IsEnable,omitempty"`
	// The name of the event-triggered task.
	MetricName *string `json:"MetricName,omitempty" xml:"MetricName,omitempty"`
	// The type of the metric. Valid values:
	//
	// *   system: system metrics of CloudMonitor
	// *   custom: custom metrics that are reported to CloudMonitor
	MetricType *string `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Pages start from page 1.
	//
	// Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: 50.
	//
	// Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the event-triggered task.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group with which the event-triggered task is associated.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The status of the event-triggered task. Valid values:
	//
	// *   ALARM: The alert condition is met and an alert is triggered.
	// *   OK: The alert condition is not met.
	// *   INSUFFICIENT_DATA: Auto Scaling cannot determine whether the alert condition is met due to insufficient data.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s DescribeAlarmsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAlarmsRequest) GoString() string {
	return s.String()
}

func (s *DescribeAlarmsRequest) SetAlarmTaskId(v string) *DescribeAlarmsRequest {
	s.AlarmTaskId = &v
	return s
}

func (s *DescribeAlarmsRequest) SetIsEnable(v bool) *DescribeAlarmsRequest {
	s.IsEnable = &v
	return s
}

func (s *DescribeAlarmsRequest) SetMetricName(v string) *DescribeAlarmsRequest {
	s.MetricName = &v
	return s
}

func (s *DescribeAlarmsRequest) SetMetricType(v string) *DescribeAlarmsRequest {
	s.MetricType = &v
	return s
}

func (s *DescribeAlarmsRequest) SetOwnerId(v int64) *DescribeAlarmsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeAlarmsRequest) SetPageNumber(v int32) *DescribeAlarmsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeAlarmsRequest) SetPageSize(v int32) *DescribeAlarmsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeAlarmsRequest) SetRegionId(v string) *DescribeAlarmsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeAlarmsRequest) SetResourceOwnerAccount(v string) *DescribeAlarmsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeAlarmsRequest) SetScalingGroupId(v string) *DescribeAlarmsRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeAlarmsRequest) SetState(v string) *DescribeAlarmsRequest {
	s.State = &v
	return s
}

type DescribeAlarmsResponseBody struct {
	// The list of event-triggered tasks.
	AlarmList []*DescribeAlarmsResponseBodyAlarmList `json:"AlarmList,omitempty" xml:"AlarmList,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of event-triggered tasks.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeAlarmsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAlarmsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAlarmsResponseBody) SetAlarmList(v []*DescribeAlarmsResponseBodyAlarmList) *DescribeAlarmsResponseBody {
	s.AlarmList = v
	return s
}

func (s *DescribeAlarmsResponseBody) SetPageNumber(v int32) *DescribeAlarmsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeAlarmsResponseBody) SetPageSize(v int32) *DescribeAlarmsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeAlarmsResponseBody) SetRequestId(v string) *DescribeAlarmsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeAlarmsResponseBody) SetTotalCount(v int32) *DescribeAlarmsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeAlarmsResponseBodyAlarmList struct {
	// The list of unique identifiers of the scaling rules that are associated with the event-triggered task.
	AlarmActions []*string `json:"AlarmActions,omitempty" xml:"AlarmActions,omitempty" type:"Repeated"`
	// The ID of the event-triggered task.
	AlarmTaskId *string `json:"AlarmTaskId,omitempty" xml:"AlarmTaskId,omitempty"`
	// The operator that is used to compare the metric value and the threshold.
	//
	// *   Valid value if the metric value is greater than or equal to the threshold: >=
	// *   Valid value if the metric value is less than or equal to the threshold: <=
	// *   Valid value if the metric value is greater than the threshold: >
	// *   Valid value if the metric value is less than the threshold: <
	ComparisonOperator *string `json:"ComparisonOperator,omitempty" xml:"ComparisonOperator,omitempty"`
	// The description of the event-triggered task.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Details of the dimensions.
	Dimensions []*DescribeAlarmsResponseBodyAlarmListDimensions `json:"Dimensions,omitempty" xml:"Dimensions,omitempty" type:"Repeated"`
	// > This parameter is in invitational preview and is unavailable.
	Effective *string `json:"Effective,omitempty" xml:"Effective,omitempty"`
	// Indicates whether the event-triggered task is enabled. Valid values:
	//
	// *   true: The event-triggered task is enabled.
	// *   false: The event-triggered task is disabled.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The number of times that the threshold must be reached before a scaling rule can be executed. For example, if you set this parameter to 3, the average CPU utilization must reach or exceed 80% three times in a row before a scaling rule is triggered.
	EvaluationCount *int32 `json:"EvaluationCount,omitempty" xml:"EvaluationCount,omitempty"`
	// The expressions that are specified in the multi-metric alert rule.
	Expressions []*DescribeAlarmsResponseBodyAlarmListExpressions `json:"Expressions,omitempty" xml:"Expressions,omitempty" type:"Repeated"`
	// The relationship between the trigger conditions that are specified in the multi-metric alert rule. Valid values:
	//
	// *   `&&`: An alert is triggered only if all metrics in the multi-metric alert rule meet the trigger conditions. In this case, an alert is triggered only if the results of all trigger conditions that are specified in the multi-metric alert rule are `true`.
	// *   `||`: An alert is triggered if one of the metrics in the multi-metric alert rule meets the trigger conditions.
	ExpressionsLogicOperator *string `json:"ExpressionsLogicOperator,omitempty" xml:"ExpressionsLogicOperator,omitempty"`
	// The name of the metric. Valid values:
	//
	// *   CpuUtilization: the CPU utilization of an ECS instance. Unit: %.
	// *   IntranetTx: the outbound traffic over the internal network from an ECS instance. Unit: KB/min.
	// *   IntranetRx: the inbound traffic over the Internet to an ECS instance that resides in a VPC. Unit: KB/min.
	// *   VpcInternetTx: the outbound traffic over the Internet from an ECS instance that resides in a VPC. Unit: KB/min.
	// *   VpcInternetRx: the inbound traffic over the Internet to an ECS instance that resides in a VPC. Unit: KB/min.
	// *   SystemDiskReadBps: the number of bytes read from the system disk used by an ECS instance per second.
	// *   SystemDiskWriteBps: the number of bytes written to the system disk used by an ECS instance per second.
	// *   SystemDiskReadOps: the number of read operations on the system disk used by an ECS instance per second.
	// *   SystemDiskWriteOps: the number of write operations on the system disk used by an ECS instance per second.
	// *   CpuUtilizationAgent: the CPU utilization of an agent. Unit: %.
	// *   GpuMemoryFreeUtilizationAgent: the percentage of idle GPU memory of an agent.
	// *   GpuMemoryUtilizationAgent: the GPU memory usage of an agent. Unit: %.
	// *   MemoryUtilization: the memory usage of an agent. Unit: %.
	// *   LoadAverage: the average system load of an agent.
	// *   TcpConnection: the total number of TCP connections of an agent.
	// *   TcpConnection: the number of established TCP connections of an agent.
	// *   PackagesNetOut: the number of packets that are sent by the internal NIC used by an agent.
	// *   PackagesNetIn: the number of packets that are received by the internal NIC used by an agent.
	// *   EciPodCpuUtilization: the CPU utilization of an elastic container instance. Unit: %.
	// *   EciPodMemoryUtilization: the memory usage of an elastic container instance. Unit: %.
	//
	// For more information, see [Event-triggered task for system monitoring](~~74854~~).
	MetricName *string `json:"MetricName,omitempty" xml:"MetricName,omitempty"`
	// The type of the metric. Valid values:
	//
	// *   system: system metrics of CloudMonitor
	// *   custom: custom metrics that are reported to CloudMonitor
	MetricType *string `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
	// The name of the event-triggered task.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The period of time during which statistics about the metric is collected. Unit: seconds. Valid values:
	//
	// *   15
	// *   60
	// *   120
	// *   300
	// *   900
	//
	// > If your scaling group is of the ECS type and the event-triggered task associated with your scaling group monitors CloudMonitor metrics, you can set the Period parameter to 15. In most cases, the name of a CloudMonitor metric contains Agent.
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The scaling group ID of the event-triggered task.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The status of the event-triggered task. Valid values:
	//
	// *   ALARM: The alert condition is met and an alert is triggered.
	// *   OK: The alert condition is not met.
	// *   INSUFFICIENT_DATA: Auto Scaling cannot determine whether the alert condition is met due to insufficient data.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The method that is used to aggregate statistics for the metric. Valid values:
	//
	// *   Average
	// *   Minimum
	// *   Maximum
	Statistics *string `json:"Statistics,omitempty" xml:"Statistics,omitempty"`
	// The threshold of the metric value. If the threshold is reached the specified times within the specified period, a scaling rule is executed.
	Threshold *float32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s DescribeAlarmsResponseBodyAlarmList) String() string {
	return tea.Prettify(s)
}

func (s DescribeAlarmsResponseBodyAlarmList) GoString() string {
	return s.String()
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetAlarmActions(v []*string) *DescribeAlarmsResponseBodyAlarmList {
	s.AlarmActions = v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetAlarmTaskId(v string) *DescribeAlarmsResponseBodyAlarmList {
	s.AlarmTaskId = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetComparisonOperator(v string) *DescribeAlarmsResponseBodyAlarmList {
	s.ComparisonOperator = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetDescription(v string) *DescribeAlarmsResponseBodyAlarmList {
	s.Description = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetDimensions(v []*DescribeAlarmsResponseBodyAlarmListDimensions) *DescribeAlarmsResponseBodyAlarmList {
	s.Dimensions = v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetEffective(v string) *DescribeAlarmsResponseBodyAlarmList {
	s.Effective = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetEnable(v bool) *DescribeAlarmsResponseBodyAlarmList {
	s.Enable = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetEvaluationCount(v int32) *DescribeAlarmsResponseBodyAlarmList {
	s.EvaluationCount = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetExpressions(v []*DescribeAlarmsResponseBodyAlarmListExpressions) *DescribeAlarmsResponseBodyAlarmList {
	s.Expressions = v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetExpressionsLogicOperator(v string) *DescribeAlarmsResponseBodyAlarmList {
	s.ExpressionsLogicOperator = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetMetricName(v string) *DescribeAlarmsResponseBodyAlarmList {
	s.MetricName = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetMetricType(v string) *DescribeAlarmsResponseBodyAlarmList {
	s.MetricType = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetName(v string) *DescribeAlarmsResponseBodyAlarmList {
	s.Name = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetPeriod(v int32) *DescribeAlarmsResponseBodyAlarmList {
	s.Period = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetScalingGroupId(v string) *DescribeAlarmsResponseBodyAlarmList {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetState(v string) *DescribeAlarmsResponseBodyAlarmList {
	s.State = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetStatistics(v string) *DescribeAlarmsResponseBodyAlarmList {
	s.Statistics = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmList) SetThreshold(v float32) *DescribeAlarmsResponseBodyAlarmList {
	s.Threshold = &v
	return s
}

type DescribeAlarmsResponseBodyAlarmListDimensions struct {
	// The key of the dimension. Valid values:
	//
	// *   user_id: the ID of your Alibaba Cloud account
	// *   scaling_group: the scaling group that you want to monitor
	// *   device: the type of the NIC
	// *   state: the state of the TCP connection
	DimensionKey *string `json:"DimensionKey,omitempty" xml:"DimensionKey,omitempty"`
	// The value of the dimension. The value of the DimensionValue parameter varies based on the value of the DimensionKey parameter.
	//
	// *   If you set the DimensionKey parameter to `user_id`, the system specifies the value of the DimensionValue parameter.
	//
	// *   If you set the DimensionKey parameter to `scaling_group`, the system specifies the value of the DimensionValue parameter.
	//
	// *   If you set the DimensionKey parameter to `device`, you can set the DimensionValue parameter to eth0 or eth1.
	//
	//     *   For instances that reside in the classic network type, eth0 specifies the internal NIC. Only one eth0 NIC exists on each instance that resides in a VPC.
	//     *   For instances that reside in the classic network, eth1 specifies the public NIC.
	//
	// *   If you set the DimensionKey parameter to `state`, you can set the DimensionValue parameter to TCP_TOTAL or ESTABLISHED.
	//
	//     *   TCP_TOTAL specifies the total number of TCP connections.
	//     *   ESTABLISHED specifies the number of established TCP connections.
	DimensionValue *string `json:"DimensionValue,omitempty" xml:"DimensionValue,omitempty"`
}

func (s DescribeAlarmsResponseBodyAlarmListDimensions) String() string {
	return tea.Prettify(s)
}

func (s DescribeAlarmsResponseBodyAlarmListDimensions) GoString() string {
	return s.String()
}

func (s *DescribeAlarmsResponseBodyAlarmListDimensions) SetDimensionKey(v string) *DescribeAlarmsResponseBodyAlarmListDimensions {
	s.DimensionKey = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmListDimensions) SetDimensionValue(v string) *DescribeAlarmsResponseBodyAlarmListDimensions {
	s.DimensionValue = &v
	return s
}

type DescribeAlarmsResponseBodyAlarmListExpressions struct {
	// The operator that is used to compare the metric value and the threshold.
	//
	// *   Valid value if the metric value is greater than or equal to the threshold: >=
	// *   Valid value if the metric value is less than or equal to the threshold: <=
	// *   Valid value if the metric value is greater than the threshold: >
	// *   Valid value if the metric value is less than the threshold: <
	//
	// Default value: >=.
	ComparisonOperator *string `json:"ComparisonOperator,omitempty" xml:"ComparisonOperator,omitempty"`
	// The name of the metric that is specified in the multi-metric alert rule. Valid values:
	//
	// *   CpuUtilization: the CPU utilization of an ECS instance. Unit: %.
	// *   IntranetTx: the outbound traffic over the internal network from an ECS instance. Unit: KB/min.
	// *   IntranetRx: the inbound traffic over the Internet to an ECS instance that resides in a VPC. Unit: KB/min.
	// *   VpcInternetTx: the outbound traffic over the Internet from an ECS instance that resides in a VPC. Unit: KB/min.
	// *   VpcInternetRx: the inbound traffic over the Internet to an ECS instance that resides in a VPC. Unit: KB/min.
	// *   SystemDiskReadBps: the number of bytes read from the system disk used by an ECS instance per second.
	// *   SystemDiskWriteBps: the number of bytes written to the system disk used by an ECS instance per second.
	// *   SystemDiskReadOps: the number of read operations on the system disk used by an ECS instance per second.
	// *   SystemDiskWriteOps: the number of write operations on the system disk used by an ECS instance per second.
	// *   CpuUtilizationAgent: the CPU utilization of an agent. Unit: %.
	// *   GpuUtilizationAgent: the GPU utilization of an agent. Unit: %.
	// *   GpuMemoryFreeUtilizationAgent: the percentage of idle GPU memory of an agent.
	// *   GpuMemoryUtilizationAgent: the GPU memory usage of an agent. Unit: %.
	// *   MemoryUtilization: the memory usage of an agent. Unit: %.
	// *   LoadAverage: the average system load of an agent.
	// *   TcpConnection: the total number of TCP connections of an agent.
	// *   TcpConnection: the number of established TCP connections of an agent.
	// *   PackagesNetOut: the number of packets that are sent by the internal NIC used by an agent.
	// *   PackagesNetIn: the number of packets that are received by the internal NIC used by an agent.
	// *   EciPodCpuUtilization: the CPU utilization of an elastic container instance. Unit: %.
	// *   EciPodMemoryUtilization: the memory usage of an elastic container instance. Unit: %.
	//
	// For more information, see [Event-triggered task for system monitoring](~~74854~~).
	MetricName *string `json:"MetricName,omitempty" xml:"MetricName,omitempty"`
	// The period of time during which statistics about the metrics in the multi-metric alert rule is collected. Unit: seconds. Valid values:
	//
	// *   15
	// *   60
	// *   120
	// *   300
	// *   900
	//
	// > If your scaling group is of the ECS type and the event-triggered task associated with your scaling group monitors CloudMonitor metrics, you can set the Period parameter to 15. In most cases, the name of a CloudMonitor metric contains Agent.
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The method that is used to aggregate statistics about the metrics in the multi-metric alert rule. Valid values:
	//
	// *   Average
	// *   Minimum
	// *   Maximum
	Statistics *string `json:"Statistics,omitempty" xml:"Statistics,omitempty"`
	// The thresholds of the metric values in the multi-metric alert rule. If the thresholds are reached the specified number of times within the specified period, a scaling rule is executed.
	Threshold *float32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s DescribeAlarmsResponseBodyAlarmListExpressions) String() string {
	return tea.Prettify(s)
}

func (s DescribeAlarmsResponseBodyAlarmListExpressions) GoString() string {
	return s.String()
}

func (s *DescribeAlarmsResponseBodyAlarmListExpressions) SetComparisonOperator(v string) *DescribeAlarmsResponseBodyAlarmListExpressions {
	s.ComparisonOperator = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmListExpressions) SetMetricName(v string) *DescribeAlarmsResponseBodyAlarmListExpressions {
	s.MetricName = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmListExpressions) SetPeriod(v int32) *DescribeAlarmsResponseBodyAlarmListExpressions {
	s.Period = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmListExpressions) SetStatistics(v string) *DescribeAlarmsResponseBodyAlarmListExpressions {
	s.Statistics = &v
	return s
}

func (s *DescribeAlarmsResponseBodyAlarmListExpressions) SetThreshold(v float32) *DescribeAlarmsResponseBodyAlarmListExpressions {
	s.Threshold = &v
	return s
}

type DescribeAlarmsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeAlarmsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeAlarmsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAlarmsResponse) GoString() string {
	return s.String()
}

func (s *DescribeAlarmsResponse) SetHeaders(v map[string]*string) *DescribeAlarmsResponse {
	s.Headers = v
	return s
}

func (s *DescribeAlarmsResponse) SetStatusCode(v int32) *DescribeAlarmsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAlarmsResponse) SetBody(v *DescribeAlarmsResponseBody) *DescribeAlarmsResponse {
	s.Body = v
	return s
}

type DescribeEciScalingConfigurationsRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of entries to return on each page. Maximum value: 50.
	//
	// Default value: 10.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The ID of the scaling group. You can use the ID to query all scaling configurations in the scaling group.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The number of the page to return. Pages start from page 1.
	//
	// Default value: 1.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The IDs of the scaling configurations that you want to query.
	//
	// The IDs of active and inactive scaling configurations are displayed in the query results. You can differentiate between active and inactive scaling configurations based on the value of the LifecycleState parameter.
	ScalingConfigurationIds []*string `json:"ScalingConfigurationIds,omitempty" xml:"ScalingConfigurationIds,omitempty" type:"Repeated"`
	// The names of the scaling configurations that you want to query.
	//
	// The names of inactive scaling configurations are not displayed in the query results, and no error is reported.
	ScalingConfigurationNames []*string `json:"ScalingConfigurationNames,omitempty" xml:"ScalingConfigurationNames,omitempty" type:"Repeated"`
	// The IDs of the scaling configurations that you want to query.
	//
	// The IDs of active and inactive scaling configurations are displayed in the query results. You can differentiate between active and inactive scaling configurations based on the value of the `LifecycleState` parameter.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DescribeEciScalingConfigurationsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsRequest) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsRequest) SetOwnerAccount(v string) *DescribeEciScalingConfigurationsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeEciScalingConfigurationsRequest) SetOwnerId(v int64) *DescribeEciScalingConfigurationsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsRequest) SetPageNumber(v int32) *DescribeEciScalingConfigurationsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeEciScalingConfigurationsRequest) SetPageSize(v int32) *DescribeEciScalingConfigurationsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeEciScalingConfigurationsRequest) SetRegionId(v string) *DescribeEciScalingConfigurationsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsRequest) SetResourceOwnerAccount(v string) *DescribeEciScalingConfigurationsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeEciScalingConfigurationsRequest) SetResourceOwnerId(v int64) *DescribeEciScalingConfigurationsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsRequest) SetScalingConfigurationIds(v []*string) *DescribeEciScalingConfigurationsRequest {
	s.ScalingConfigurationIds = v
	return s
}

func (s *DescribeEciScalingConfigurationsRequest) SetScalingConfigurationNames(v []*string) *DescribeEciScalingConfigurationsRequest {
	s.ScalingConfigurationNames = v
	return s
}

func (s *DescribeEciScalingConfigurationsRequest) SetScalingGroupId(v string) *DescribeEciScalingConfigurationsRequest {
	s.ScalingGroupId = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBody struct {
	// The ID of the request.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The total number of scaling configurations.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// Details of the scaling configurations.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The time when the scaling configuration was created.
	ScalingConfigurations []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurations `json:"ScalingConfigurations,omitempty" xml:"ScalingConfigurations,omitempty" type:"Repeated"`
	// Details of the scaling configurations.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBody) SetPageNumber(v int32) *DescribeEciScalingConfigurationsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBody) SetPageSize(v int32) *DescribeEciScalingConfigurationsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBody) SetRequestId(v string) *DescribeEciScalingConfigurationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBody) SetScalingConfigurations(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) *DescribeEciScalingConfigurationsResponseBody {
	s.ScalingConfigurations = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBody) SetTotalCount(v int32) *DescribeEciScalingConfigurationsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurations struct {
	// The ID of the Container Registry Enterprise Edition instance.
	AcrRegistryInfos []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos `json:"AcrRegistryInfos,omitempty" xml:"AcrRegistryInfos,omitempty" type:"Repeated"`
	// Indicates whether an elastic IP address (EIP) is automatically created, and then bound to the elastic container instance.
	ActiveDeadlineSeconds *int32 `json:"ActiveDeadlineSeconds,omitempty" xml:"ActiveDeadlineSeconds,omitempty"`
	// The size of the temporary storage space. Unit: GiB.
	AutoCreateEip *bool `json:"AutoCreateEip,omitempty" xml:"AutoCreateEip,omitempty"`
	// The name of the elastic container instance.
	AutoMatchImageCache *bool `json:"AutoMatchImageCache,omitempty" xml:"AutoMatchImageCache,omitempty"`
	// The number of physical CPU cores. This parameter can be specified for only some instance types. For more information, see [Specify custom CPU options](~~197781~~).
	ContainerGroupName *string `json:"ContainerGroupName,omitempty" xml:"ContainerGroupName,omitempty"`
	// The path to which the system sends an HTTP GET request for a probe.
	Containers []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers `json:"Containers,omitempty" xml:"Containers,omitempty" type:"Repeated"`
	// auditing
	CostOptimization *bool `json:"CostOptimization,omitempty" xml:"CostOptimization,omitempty"`
	// The ID of the resource group.
	Cpu *float32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The containers in the elastic container instance.
	CpuOptionsCore *int32 `json:"CpuOptionsCore,omitempty" xml:"CpuOptionsCore,omitempty"`
	// The weight of the elastic container instance as a backend server. Valid values: 1 to 100.
	CpuOptionsThreadsPerCore *int32 `json:"CpuOptionsThreadsPerCore,omitempty" xml:"CpuOptionsThreadsPerCore,omitempty"`
	// The ID of the security group with which the elastic container instance is associated. Elastic container instances that are associated with the same security group can access each other.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The ID of the image cache snapshot.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The DNS lookup domains.
	DnsConfigNameServers []*string `json:"DnsConfigNameServers,omitempty" xml:"DnsConfigNameServers,omitempty" type:"Repeated"`
	// The variable name of the option.
	DnsConfigOptions []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions `json:"DnsConfigOptions,omitempty" xml:"DnsConfigOptions,omitempty" type:"Repeated"`
	// The domain names of the Network Time Protocol (NTP) servers.
	DnsConfigSearches []*string `json:"DnsConfigSearches,omitempty" xml:"DnsConfigSearches,omitempty" type:"Repeated"`
	// The maximum outbound bandwidth. Unit: bytes.
	DnsPolicy *string `json:"DnsPolicy,omitempty" xml:"DnsPolicy,omitempty"`
	// The name of the instance RAM role. You can use an instance RAM role to access both elastic container instances and Elastic Compute Service (ECS) instances. For more information, see [Use the instance RAM role by calling APIs](~~61178~~).
	EgressBandwidth *int64 `json:"EgressBandwidth,omitempty" xml:"EgressBandwidth,omitempty"`
	// The size of the memory.
	//
	// You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. If you specify the Cpu and Memory parameters, Auto Scaling determines available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.
	//
	// > You can specify CPU and memory specifications to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
	EipBandwidth *int32 `json:"EipBandwidth,omitempty" xml:"EipBandwidth,omitempty"`
	// > This parameter is unavailable.
	EphemeralStorage *int32 `json:"EphemeralStorage,omitempty" xml:"EphemeralStorage,omitempty"`
	// The IP address that is added.
	HostAliases []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases `json:"HostAliases,omitempty" xml:"HostAliases,omitempty" type:"Repeated"`
	// The region ID of the elastic container instance.
	HostName *string `json:"HostName,omitempty" xml:"HostName,omitempty"`
	// The password that is used to access the image repository.
	ImageRegistryCredentials []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials `json:"ImageRegistryCredentials,omitempty" xml:"ImageRegistryCredentials,omitempty" type:"Repeated"`
	// The restart policy of the elastic container instance. Valid values:
	//
	// *   Never: never restarts the elastic container instance.
	// *   Always: always restarts the elastic container instance.
	// *   OnFailure: restarts the elastic container instance upon failures.
	ImageSnapshotId *string `json:"ImageSnapshotId,omitempty" xml:"ImageSnapshotId,omitempty"`
	// The buffer time in which the program handles operations before the program stops.
	IngressBandwidth *int64 `json:"IngressBandwidth,omitempty" xml:"IngressBandwidth,omitempty"`
	// Indicates whether the root file system is read-only. The only valid value is true.
	InitContainers []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers `json:"InitContainers,omitempty" xml:"InitContainers,omitempty" type:"Repeated"`
	// 5292
	InstanceFamilyLevel *string `json:"InstanceFamilyLevel,omitempty" xml:"InstanceFamilyLevel,omitempty"`
	// The bandwidth of the EIP. Default value: 5 Mbit/s.
	Ipv6AddressCount *int32 `json:"Ipv6AddressCount,omitempty" xml:"Ipv6AddressCount,omitempty"`
	// The instance family level, which is used to filter the range of instance types that meet the requirements. This parameter takes effect when the `CostOptimization` parameter is set to true. Valid values:
	//
	// *   EntryLevel: shared instance type. Instances of this level are the most cost-effective but may not provide stable computing performance in a consistent manner. Instances of this level are suitable for business scenarios in which the CPU utilization is low. For more information, see [Shared instance families](~~108489~~).
	// *   EnterpriseLevel: Instances of this level provide stable performance and dedicated resources, and are suitable for business scenarios that require high stability. For more information, see [Instance family](~~25378~~).
	// *   CreditEntryLevel: This value is valid only for burstable instances. CPU credits are used to ensure computing performance. Instances of this level are suitable for scenarios in which the CPU utilization is low but may fluctuate in specific cases. For more information, see [Overview](~~59977~~) of burstable instances.
	LifecycleState *string `json:"LifecycleState,omitempty" xml:"LifecycleState,omitempty"`
	// The hostname.
	LoadBalancerWeight *int32 `json:"LoadBalancerWeight,omitempty" xml:"LoadBalancerWeight,omitempty"`
	// The maximum hourly price for the preemptible instance.
	//
	// This parameter is returned only if you set the SpotStrategy parameter to SpotWithPriceLimit.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The state of the scaling configuration in the scaling group. Valid values:
	//
	// *   Active: The scaling configuration is active in the scaling group. Auto Scaling uses active scaling configurations to automatically create ECS instances.
	// *   Inactive: The scaling configuration is inactive in the scaling group. Auto Scaling does not use inactive scaling configurations to automatically create ECS instances. Inactive scaling configurations are retained in the scaling group.
	NtpServers []*string `json:"NtpServers,omitempty" xml:"NtpServers,omitempty" type:"Repeated"`
	// Indicates whether the image cache is automatically matched. Default value: false.
	RamRoleName *string `json:"RamRoleName,omitempty" xml:"RamRoleName,omitempty"`
	// The number of vCPUs of the elastic container instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the scaling configuration.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The maximum inbound bandwidth. Unit: bit/s.
	RestartPolicy *string `json:"RestartPolicy,omitempty" xml:"RestartPolicy,omitempty"`
	// > This parameter is unavailable.
	ScalingConfigurationId *string `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
	// The validity period. Unit: seconds.
	ScalingConfigurationName *string `json:"ScalingConfigurationName,omitempty" xml:"ScalingConfigurationName,omitempty"`
	// The number of IPv6 addresses.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The name of the security context in which the elastic container instance runs.
	SecurityContextSysCtls []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls `json:"SecurityContextSysCtls,omitempty" xml:"SecurityContextSysCtls,omitempty" type:"Repeated"`
	// The preemption policy of the instance. Valid values:
	//
	// *   NoSpot: The instance is created as a regular pay-as-you-go instance.
	// *   SpotWithPriceLimit: The instance is created as a preemptible instance with a user-defined maximum hourly price.
	// *   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// The containers in the elastic container instance.
	SlsEnable *bool `json:"SlsEnable,omitempty" xml:"SlsEnable,omitempty"`
	// The number of threads per core. This parameter can be specified for only some instance types. If you set this parameter to 1, Hyper-Threading is disabled. For more information, see [Specify custom CPU options](~~197781~~).
	SpotPriceLimit *float32 `json:"SpotPriceLimit,omitempty" xml:"SpotPriceLimit,omitempty"`
	// The scaling group ID of the scaling configuration.
	SpotStrategy *string `json:"SpotStrategy,omitempty" xml:"SpotStrategy,omitempty"`
	// The key of the tag.
	Tags []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The Domain Name System (DNS) policy.
	TerminationGracePeriodSeconds *int32 `json:"TerminationGracePeriodSeconds,omitempty" xml:"TerminationGracePeriodSeconds,omitempty"`
	// The type of the volume. Valid values:
	//
	// *   EmptyDirVolume
	// *   NFSVolume
	// *   ConfigFileVolume
	// *   FlexVolume
	Volumes []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes `json:"Volumes,omitempty" xml:"Volumes,omitempty" type:"Repeated"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetAcrRegistryInfos(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.AcrRegistryInfos = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetActiveDeadlineSeconds(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.ActiveDeadlineSeconds = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetAutoCreateEip(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.AutoCreateEip = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetAutoMatchImageCache(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.AutoMatchImageCache = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetContainerGroupName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.ContainerGroupName = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetContainers(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.Containers = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetCostOptimization(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.CostOptimization = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetCpu(v float32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.Cpu = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetCpuOptionsCore(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.CpuOptionsCore = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetCpuOptionsThreadsPerCore(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.CpuOptionsThreadsPerCore = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetCreationTime(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.CreationTime = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetDescription(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.Description = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetDnsConfigNameServers(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.DnsConfigNameServers = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetDnsConfigOptions(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.DnsConfigOptions = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetDnsConfigSearches(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.DnsConfigSearches = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetDnsPolicy(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.DnsPolicy = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetEgressBandwidth(v int64) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.EgressBandwidth = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetEipBandwidth(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.EipBandwidth = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetEphemeralStorage(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.EphemeralStorage = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetHostAliases(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.HostAliases = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetHostName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.HostName = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetImageRegistryCredentials(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.ImageRegistryCredentials = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetImageSnapshotId(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.ImageSnapshotId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetIngressBandwidth(v int64) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.IngressBandwidth = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetInitContainers(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.InitContainers = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetInstanceFamilyLevel(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.InstanceFamilyLevel = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetIpv6AddressCount(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.Ipv6AddressCount = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetLifecycleState(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.LifecycleState = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetLoadBalancerWeight(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.LoadBalancerWeight = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetMemory(v float32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.Memory = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetNtpServers(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.NtpServers = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetRamRoleName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.RamRoleName = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetRegionId(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.RegionId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetResourceGroupId(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetRestartPolicy(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.RestartPolicy = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetScalingConfigurationId(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.ScalingConfigurationId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetScalingConfigurationName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.ScalingConfigurationName = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetScalingGroupId(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetSecurityContextSysCtls(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.SecurityContextSysCtls = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetSecurityGroupId(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.SecurityGroupId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetSlsEnable(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.SlsEnable = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetSpotPriceLimit(v float32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.SpotPriceLimit = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetSpotStrategy(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.SpotStrategy = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetTags(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.Tags = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetTerminationGracePeriodSeconds(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.TerminationGracePeriodSeconds = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations) SetVolumes(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurations {
	s.Volumes = v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos struct {
	// The IP addresses of the DNS servers.
	Domains []*string `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Repeated"`
	// The region ID of the Container Registry Enterprise Edition instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The domain name of the Container Registry Enterprise Edition instance. By default, all domain names of the Container Registry Enterprise Edition instance are displayed. You can specify one or more domain names. Separate multiple domain names with commas (,).
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The domain name of the Container Registry Enterprise Edition instance. By default, all domain names of the Container Registry Enterprise Edition instance are displayed. You can specify one or more domain names. Separate multiple domain names with commas (,).
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos) SetDomains(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos {
	s.Domains = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos) SetInstanceId(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos {
	s.InstanceId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos) SetInstanceName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos {
	s.InstanceName = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos) SetRegionId(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsAcrRegistryInfos {
	s.RegionId = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers struct {
	// The commands that are run in the container when you use the CLI to perform probes.
	Args []*string `json:"Args,omitempty" xml:"Args,omitempty" type:"Repeated"`
	// The commands that are run in the container when you use the CLI to perform probes.
	Commands []*string `json:"Commands,omitempty" xml:"Commands,omitempty" type:"Repeated"`
	// The minimum number of consecutive failures for a probe to be considered failed after having been successful.
	//
	// Default value: 3.
	Cpu *float32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The name of the environment variable.
	EnvironmentVars []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars `json:"EnvironmentVars,omitempty" xml:"EnvironmentVars,omitempty" type:"Repeated"`
	// Indicates whether the container allocates buffer resources to standard input streams when the container runs. If you do not specify this parameter, an end-of-file (EOF) error may occur. Default value: false.
	Gpu *int32 `json:"Gpu,omitempty" xml:"Gpu,omitempty"`
	// The protocol type of HTTP GET requests when you use HTTP requests to perform probes. Valid values:
	//
	// *   HTTP
	// *   HTTPS
	Image *string `json:"Image,omitempty" xml:"Image,omitempty"`
	// The number of vCPUs that are allocated to the container.
	ImagePullPolicy *string `json:"ImagePullPolicy,omitempty" xml:"ImagePullPolicy,omitempty"`
	// The arguments that are passed to the container startup commands. You can specify up to 10 arguments.
	LivenessProbeExecCommands []*string `json:"LivenessProbeExecCommands,omitempty" xml:"LivenessProbeExecCommands,omitempty" type:"Repeated"`
	// The exposed ports and protocols of the container.
	LivenessProbeFailureThreshold *int32 `json:"LivenessProbeFailureThreshold,omitempty" xml:"LivenessProbeFailureThreshold,omitempty"`
	// The port number of TcpSocket.
	LivenessProbeHttpGetPath *string `json:"LivenessProbeHttpGetPath,omitempty" xml:"LivenessProbeHttpGetPath,omitempty"`
	// The number of seconds between the time when the startup of the container ends and the time when the probe starts.
	LivenessProbeHttpGetPort *int32 `json:"LivenessProbeHttpGetPort,omitempty" xml:"LivenessProbeHttpGetPort,omitempty"`
	// Indicates whether interaction is enabled. Valid values:
	//
	// *   true
	// *   false
	//
	// If the value of the Command parameter is /bin/bash, the value of this parameter is true.
	//
	// Default value: false.
	LivenessProbeHttpGetScheme *string `json:"LivenessProbeHttpGetScheme,omitempty" xml:"LivenessProbeHttpGetScheme,omitempty"`
	// The image pulling policy. Valid values:
	//
	// *   Always: Image pulling is performed each time.
	// *   IfNotPresent: Image pulling is performed only if on-premises images are unavailable. On-premises images are preferentially used. If no on-premises images are available, image pulling is performed.
	// *   Never: On-premises images are always used. Image pulling is not performed.
	LivenessProbeInitialDelaySeconds *int32 `json:"LivenessProbeInitialDelaySeconds,omitempty" xml:"LivenessProbeInitialDelaySeconds,omitempty"`
	// The protocol type of HTTP GET requests when you use HTTP requests to perform probes. Valid values:
	//
	// *   HTTP
	// *   HTTPS
	LivenessProbePeriodSeconds *int32 `json:"LivenessProbePeriodSeconds,omitempty" xml:"LivenessProbePeriodSeconds,omitempty"`
	// The user ID (UID) that is used to run the entry point of the container process.
	LivenessProbeSuccessThreshold *int32 `json:"LivenessProbeSuccessThreshold,omitempty" xml:"LivenessProbeSuccessThreshold,omitempty"`
	// The working directory of the container.
	LivenessProbeTcpSocketPort *int32 `json:"LivenessProbeTcpSocketPort,omitempty" xml:"LivenessProbeTcpSocketPort,omitempty"`
	// The minimum number of consecutive failures for a probe to be considered failed after having been successful.
	//
	// Default value: 3.
	LivenessProbeTimeoutSeconds *int32 `json:"LivenessProbeTimeoutSeconds,omitempty" xml:"LivenessProbeTimeoutSeconds,omitempty"`
	// Indicates whether the root file system is set to the read-only mode. The only valid value is true.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The path to which the system sends an HTTP GET request for a probe.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The port number. Valid values: 1 to 65535.
	Ports []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts `json:"Ports,omitempty" xml:"Ports,omitempty" type:"Repeated"`
	// The permissions granted to processes in the container. Valid values: NET_ADMIN and NET_RAW.
	//
	// > To use NET_RAW, you need to submit a ticket.
	ReadinessProbeExecCommands []*string `json:"ReadinessProbeExecCommands,omitempty" xml:"ReadinessProbeExecCommands,omitempty" type:"Repeated"`
	// The exposed ports and protocols of the container.
	ReadinessProbeFailureThreshold *int32 `json:"ReadinessProbeFailureThreshold,omitempty" xml:"ReadinessProbeFailureThreshold,omitempty"`
	// The interval at which probes are performed. Default value: 10. Minimum value: 1. Unit: seconds.
	ReadinessProbeHttpGetPath *string `json:"ReadinessProbeHttpGetPath,omitempty" xml:"ReadinessProbeHttpGetPath,omitempty"`
	// The timeout period of a probe. Default value: 1. Minimum value: 1. Unit: seconds.
	ReadinessProbeHttpGetPort *int32 `json:"ReadinessProbeHttpGetPort,omitempty" xml:"ReadinessProbeHttpGetPort,omitempty"`
	// The minimum number of consecutive successes for a probe to be considered successful after having failed. Default value: 1. Valid value: 1.
	ReadinessProbeHttpGetScheme *string `json:"ReadinessProbeHttpGetScheme,omitempty" xml:"ReadinessProbeHttpGetScheme,omitempty"`
	// The memory size of the container.
	ReadinessProbeInitialDelaySeconds *int32 `json:"ReadinessProbeInitialDelaySeconds,omitempty" xml:"ReadinessProbeInitialDelaySeconds,omitempty"`
	// Indicates whether standard input streams are disconnected after a client is disconnected. If Stdin is set to true, standard input streams remain connected during multiple sessions.
	//
	// If StdinOnce is set to true, standard input streams are connected after the container is started and remain idle until a client is connected to receive data. After the client is disconnected, streams are also disconnected and remain in the disconnected state until the container is started again.
	ReadinessProbePeriodSeconds *int32 `json:"ReadinessProbePeriodSeconds,omitempty" xml:"ReadinessProbePeriodSeconds,omitempty"`
	// The port number of TcpSocket.
	ReadinessProbeSuccessThreshold *int32 `json:"ReadinessProbeSuccessThreshold,omitempty" xml:"ReadinessProbeSuccessThreshold,omitempty"`
	// The path to which the system sends an HTTP GET request for a probe.
	ReadinessProbeTcpSocketPort *int32 `json:"ReadinessProbeTcpSocketPort,omitempty" xml:"ReadinessProbeTcpSocketPort,omitempty"`
	// The number of seconds between the time when the startup of the container ends and the time when the probe starts.
	ReadinessProbeTimeoutSeconds *int32 `json:"ReadinessProbeTimeoutSeconds,omitempty" xml:"ReadinessProbeTimeoutSeconds,omitempty"`
	// The init containers.
	SecurityContextCapabilityAdds []*string `json:"SecurityContextCapabilityAdds,omitempty" xml:"SecurityContextCapabilityAdds,omitempty" type:"Repeated"`
	// The image of the container.
	SecurityContextReadOnlyRootFilesystem *bool `json:"SecurityContextReadOnlyRootFilesystem,omitempty" xml:"SecurityContextReadOnlyRootFilesystem,omitempty"`
	// The interval at which probes are performed. Default value: 10. Minimum value: 1. Unit: seconds.
	SecurityContextRunAsUser *int64 `json:"SecurityContextRunAsUser,omitempty" xml:"SecurityContextRunAsUser,omitempty"`
	// The name of the container.
	Stdin *bool `json:"Stdin,omitempty" xml:"Stdin,omitempty"`
	// The timeout period of a probe. Default value: 1. Minimum value: 1. Unit: seconds.
	StdinOnce *bool `json:"StdinOnce,omitempty" xml:"StdinOnce,omitempty"`
	// The number of GPUs.
	Tty *bool `json:"Tty,omitempty" xml:"Tty,omitempty"`
	// Indicates whether the volume is read-only.
	//
	// Default value: false.
	VolumeMounts []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts `json:"VolumeMounts,omitempty" xml:"VolumeMounts,omitempty" type:"Repeated"`
	// The port to which HTTP GET requests were sent.
	WorkingDir *string `json:"WorkingDir,omitempty" xml:"WorkingDir,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetArgs(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.Args = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetCommands(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.Commands = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetCpu(v float32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.Cpu = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetEnvironmentVars(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.EnvironmentVars = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetGpu(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.Gpu = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetImage(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.Image = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetImagePullPolicy(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.ImagePullPolicy = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetLivenessProbeExecCommands(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.LivenessProbeExecCommands = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetLivenessProbeFailureThreshold(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.LivenessProbeFailureThreshold = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetLivenessProbeHttpGetPath(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.LivenessProbeHttpGetPath = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetLivenessProbeHttpGetPort(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.LivenessProbeHttpGetPort = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetLivenessProbeHttpGetScheme(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.LivenessProbeHttpGetScheme = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetLivenessProbeInitialDelaySeconds(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.LivenessProbeInitialDelaySeconds = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetLivenessProbePeriodSeconds(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.LivenessProbePeriodSeconds = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetLivenessProbeSuccessThreshold(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.LivenessProbeSuccessThreshold = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetLivenessProbeTcpSocketPort(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.LivenessProbeTcpSocketPort = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetLivenessProbeTimeoutSeconds(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.LivenessProbeTimeoutSeconds = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetMemory(v float32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.Memory = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.Name = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetPorts(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.Ports = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetReadinessProbeExecCommands(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.ReadinessProbeExecCommands = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetReadinessProbeFailureThreshold(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.ReadinessProbeFailureThreshold = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetReadinessProbeHttpGetPath(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.ReadinessProbeHttpGetPath = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetReadinessProbeHttpGetPort(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.ReadinessProbeHttpGetPort = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetReadinessProbeHttpGetScheme(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.ReadinessProbeHttpGetScheme = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetReadinessProbeInitialDelaySeconds(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.ReadinessProbeInitialDelaySeconds = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetReadinessProbePeriodSeconds(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.ReadinessProbePeriodSeconds = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetReadinessProbeSuccessThreshold(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.ReadinessProbeSuccessThreshold = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetReadinessProbeTcpSocketPort(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.ReadinessProbeTcpSocketPort = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetReadinessProbeTimeoutSeconds(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.ReadinessProbeTimeoutSeconds = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetSecurityContextCapabilityAdds(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.SecurityContextCapabilityAdds = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetSecurityContextReadOnlyRootFilesystem(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.SecurityContextReadOnlyRootFilesystem = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetSecurityContextRunAsUser(v int64) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.SecurityContextRunAsUser = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetStdin(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.Stdin = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetStdinOnce(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.StdinOnce = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetTty(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.Tty = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetVolumeMounts(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.VolumeMounts = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers) SetWorkingDir(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainers {
	s.WorkingDir = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars struct {
	// The container startup commands. You can specify up to 20 commands. Each command can contain up to 256 characters.
	FieldRefFieldPath *string `json:"FieldRefFieldPath,omitempty" xml:"FieldRefFieldPath,omitempty"`
	// > This parameter is unavailable.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The container startup commands. You can specify up to 20 commands. Each command can contain up to 256 characters.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars) SetFieldRefFieldPath(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars {
	s.FieldRefFieldPath = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars) SetKey(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars {
	s.Key = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars) SetValue(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersEnvironmentVars {
	s.Value = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts struct {
	// The volumes that are mounted on the container.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The volumes that are mounted on the container.
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts) SetPort(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts {
	s.Port = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts) SetProtocol(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersPorts {
	s.Protocol = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts struct {
	// Details of the environment variables.
	MountPath *string `json:"MountPath,omitempty" xml:"MountPath,omitempty"`
	// Details of the environment variables.
	MountPropagation *string `json:"MountPropagation,omitempty" xml:"MountPropagation,omitempty"`
	// The directory in which the container mounts the volume.
	//
	// > Data in this directory is overwritten by the data on the volume.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The name of the volume. The value of this parameter is the same as the value of the Volumes.Name parameter.
	ReadOnly *bool `json:"ReadOnly,omitempty" xml:"ReadOnly,omitempty"`
	// The mount propagation setting of the volume. Mount propagation allows the sharing of volumes that are mounted on one container with other containers in the same pod, or even with other pods on the same node. Valid values:
	//
	// *   None: The volume mount does not receive subsequent mounts that are mounted to this volume or its subdirectories.
	// *   HostToCotainer: The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories.
	// *   Bidirectional: This value is similar to HostToCotainer. The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories. In addition, all volume mounts that are created by the container are propagated back to the instance and to all containers of all pods that use the same volume.
	//
	// Default value: None.
	SubPath *string `json:"SubPath,omitempty" xml:"SubPath,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts) SetMountPath(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts {
	s.MountPath = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts) SetMountPropagation(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts {
	s.MountPropagation = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts) SetName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts {
	s.Name = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts) SetReadOnly(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts {
	s.ReadOnly = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts) SetSubPath(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsContainersVolumeMounts {
	s.SubPath = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions struct {
	// The hostname aliases of a container.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The hostname aliases of a container.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions) SetName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions {
	s.Name = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions) SetValue(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsDnsConfigOptions {
	s.Value = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases struct {
	// The system information of the security context in which the elastic container instance runs.
	Hostnames []*string `json:"Hostnames,omitempty" xml:"Hostnames,omitempty" type:"Repeated"`
	// The hostnames that are added.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases) SetHostnames(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases {
	s.Hostnames = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases) SetIp(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsHostAliases {
	s.Ip = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials struct {
	// The username that is used to access the image repository.
	Password *string `json:"Password,omitempty" xml:"Password,omitempty"`
	// The options. Each option is a name-value pair. The value in the name-value pair is optional.
	Server *string `json:"Server,omitempty" xml:"Server,omitempty"`
	// The options. Each option is a name-value pair. The value in the name-value pair is optional.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials) SetPassword(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials {
	s.Password = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials) SetServer(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials {
	s.Server = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials) SetUserName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsImageRegistryCredentials {
	s.UserName = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers struct {
	// The number of GPUs that are allocated to the container.
	Cpu *float32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The size of the memory.
	Gpu *int32 `json:"Gpu,omitempty" xml:"Gpu,omitempty"`
	// The ID of the user that runs the container.
	Image *string `json:"Image,omitempty" xml:"Image,omitempty"`
	// The number of vCPUs.
	ImagePullPolicy *string `json:"ImagePullPolicy,omitempty" xml:"ImagePullPolicy,omitempty"`
	// The tags of the elastic container instance. The tags are specified in the key-value pair format.
	InitContainerArgs []*string `json:"InitContainerArgs,omitempty" xml:"InitContainerArgs,omitempty" type:"Repeated"`
	// The container startup arguments.
	InitContainerCommands []*string `json:"InitContainerCommands,omitempty" xml:"InitContainerCommands,omitempty" type:"Repeated"`
	// The name of the environment variable.
	InitContainerEnvironmentVars []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars `json:"InitContainerEnvironmentVars,omitempty" xml:"InitContainerEnvironmentVars,omitempty" type:"Repeated"`
	// The port number. Valid values: 1 to 65535.
	InitContainerPorts []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts `json:"InitContainerPorts,omitempty" xml:"InitContainerPorts,omitempty" type:"Repeated"`
	// Indicates whether the mount path is read-only.
	//
	// Default value: false.
	InitContainerVolumeMounts []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts `json:"InitContainerVolumeMounts,omitempty" xml:"InitContainerVolumeMounts,omitempty" type:"Repeated"`
	// Details of the environment variables.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// Details of the environment variables.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The container startup commands.
	SecurityContextCapabilityAdds []*string `json:"SecurityContextCapabilityAdds,omitempty" xml:"SecurityContextCapabilityAdds,omitempty" type:"Repeated"`
	// The working directory.
	SecurityContextReadOnlyRootFilesystem *bool `json:"SecurityContextReadOnlyRootFilesystem,omitempty" xml:"SecurityContextReadOnlyRootFilesystem,omitempty"`
	// The name of the container.
	SecurityContextRunAsUser *string `json:"SecurityContextRunAsUser,omitempty" xml:"SecurityContextRunAsUser,omitempty"`
	// The container image.
	WorkingDir *string `json:"WorkingDir,omitempty" xml:"WorkingDir,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetCpu(v float32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.Cpu = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetGpu(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.Gpu = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetImage(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.Image = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetImagePullPolicy(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.ImagePullPolicy = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetInitContainerArgs(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.InitContainerArgs = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetInitContainerCommands(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.InitContainerCommands = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetInitContainerEnvironmentVars(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.InitContainerEnvironmentVars = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetInitContainerPorts(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.InitContainerPorts = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetInitContainerVolumeMounts(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.InitContainerVolumeMounts = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetMemory(v float32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.Memory = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.Name = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetSecurityContextCapabilityAdds(v []*string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.SecurityContextCapabilityAdds = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetSecurityContextReadOnlyRootFilesystem(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.SecurityContextReadOnlyRootFilesystem = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetSecurityContextRunAsUser(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.SecurityContextRunAsUser = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers) SetWorkingDir(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainers {
	s.WorkingDir = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars struct {
	// Details of the init container ports.
	FieldRefFieldPath *string `json:"FieldRefFieldPath,omitempty" xml:"FieldRefFieldPath,omitempty"`
	// > This parameter is unavailable.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// Details of the init container ports.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars) SetFieldRefFieldPath(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars {
	s.FieldRefFieldPath = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars) SetKey(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars {
	s.Key = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars) SetValue(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerEnvironmentVars {
	s.Value = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts struct {
	// The volumes that are mounted on the container.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The volumes that are mounted on the container.
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts) SetPort(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts {
	s.Port = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts) SetProtocol(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerPorts {
	s.Protocol = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts struct {
	// The permissions that are granted to the processes in the container. Valid values: NET_ADMIN and NET_RAW.
	//
	// > To use NET_RAW, you need to submit a ticket.
	MountPath *string `json:"MountPath,omitempty" xml:"MountPath,omitempty"`
	// The permissions that are granted to the processes in the container. Valid values: NET_ADMIN and NET_RAW.
	//
	// > To use NET_RAW, you need to submit a ticket.
	MountPropagation *string `json:"MountPropagation,omitempty" xml:"MountPropagation,omitempty"`
	// The directory to which the volume is mounted. Data under this directory is overwritten by the data on the volume.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The name of the volume.
	ReadOnly *bool `json:"ReadOnly,omitempty" xml:"ReadOnly,omitempty"`
	// The mount propagation setting of the volume. Mount propagation allows the sharing of volumes that are mounted on one container with other containers in the same pod, or even with other pods on the same node. Valid values:
	//
	// *   None: The volume mount does not receive subsequent mounts that are mounted to this volume or its subdirectories.
	// *   HostToCotainer: The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories.
	// *   Bidirectional: This value is similar to HostToCotainer. The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories. In addition, all volume mounts that are created by the container are propagated back to the instance and to all containers of all pods that use the same volume.
	//
	// Default value: None.
	SubPath *string `json:"SubPath,omitempty" xml:"SubPath,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts) SetMountPath(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts {
	s.MountPath = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts) SetMountPropagation(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts {
	s.MountPropagation = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts) SetName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts {
	s.Name = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts) SetReadOnly(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts {
	s.ReadOnly = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts) SetSubPath(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsInitContainersInitContainerVolumeMounts {
	s.SubPath = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls struct {
	// Details of the Container Registry Enterprise Edition instances.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Details of the Container Registry Enterprise Edition instances.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls) SetName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls {
	s.Name = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls) SetValue(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsSecurityContextSysCtls {
	s.Value = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags struct {
	// Details of the volumes.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// Details of the volumes.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags) SetKey(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags {
	s.Key = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags) SetValue(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsTags {
	s.Value = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes struct {
	// The relative path to the configuration file.
	ConfigFileVolumeConfigFileToPaths []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths `json:"ConfigFileVolumeConfigFileToPaths,omitempty" xml:"ConfigFileVolumeConfigFileToPaths,omitempty" type:"Repeated"`
	// The FlexVolume options. Each option is a key-value pair in a JSON string.
	//
	// For example, when you use FlexVolume to mount a disk, the format of options is `{"volumeId":"d-2zehdahrwoa7srg****","performanceLevel": "PL2"}`.
	ConfigFileVolumeDefaultMode *int32 `json:"ConfigFileVolumeDefaultMode,omitempty" xml:"ConfigFileVolumeDefaultMode,omitempty"`
	// The storage medium of EmptyDirVolume. If this parameter is left empty, the file system that backs the node is used as the storage medium. If this parameter is set to memory, the memory is used as the storage medium.
	DiskVolumeDiskId *string `json:"DiskVolumeDiskId,omitempty" xml:"DiskVolumeDiskId,omitempty"`
	// The file system type of the volume. The default value is determined by the script of FlexVolume.
	DiskVolumeDiskSize *int32 `json:"DiskVolumeDiskSize,omitempty" xml:"DiskVolumeDiskSize,omitempty"`
	// The path to the Network File System (NFS) volume.
	DiskVolumeFsType *string `json:"DiskVolumeFsType,omitempty" xml:"DiskVolumeFsType,omitempty"`
	// The storage size of a disk volume. Unit: GiB.
	EmptyDirVolumeMedium *string `json:"EmptyDirVolumeMedium,omitempty" xml:"EmptyDirVolumeMedium,omitempty"`
	// The endpoint of the NFS server.
	FlexVolumeDriver *string `json:"FlexVolumeDriver,omitempty" xml:"FlexVolumeDriver,omitempty"`
	// The FlexVolume driver name of the volume.
	FlexVolumeFsType *string `json:"FlexVolumeFsType,omitempty" xml:"FlexVolumeFsType,omitempty"`
	// The name of the volume.
	FlexVolumeOptions *string `json:"FlexVolumeOptions,omitempty" xml:"FlexVolumeOptions,omitempty"`
	// Indicates whether the NFS volume is read-only.
	//
	// Default value: false.
	NFSVolumePath *string `json:"NFSVolumePath,omitempty" xml:"NFSVolumePath,omitempty"`
	// The default permissions on the ConfigFile volume.
	NFSVolumeReadOnly *bool `json:"NFSVolumeReadOnly,omitempty" xml:"NFSVolumeReadOnly,omitempty"`
	// The paths to configuration files.
	NFSVolumeServer *string `json:"NFSVolumeServer,omitempty" xml:"NFSVolumeServer,omitempty"`
	// The paths to configuration files.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The file system type of a disk volume.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetConfigFileVolumeConfigFileToPaths(v []*DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.ConfigFileVolumeConfigFileToPaths = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetConfigFileVolumeDefaultMode(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.ConfigFileVolumeDefaultMode = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetDiskVolumeDiskId(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.DiskVolumeDiskId = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetDiskVolumeDiskSize(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.DiskVolumeDiskSize = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetDiskVolumeFsType(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.DiskVolumeFsType = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetEmptyDirVolumeMedium(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.EmptyDirVolumeMedium = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetFlexVolumeDriver(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.FlexVolumeDriver = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetFlexVolumeFsType(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.FlexVolumeFsType = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetFlexVolumeOptions(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.FlexVolumeOptions = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetNFSVolumePath(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.NFSVolumePath = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetNFSVolumeReadOnly(v bool) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.NFSVolumeReadOnly = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetNFSVolumeServer(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.NFSVolumeServer = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetName(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.Name = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes) SetType(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumes {
	s.Type = &v
	return s
}

type DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths struct {
	// The information about the image repository.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The information about the image repository.
	Mode *int32 `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The content of the configuration file (32 KB).
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths) SetContent(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths {
	s.Content = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths) SetMode(v int32) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths {
	s.Mode = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths) SetPath(v string) *DescribeEciScalingConfigurationsResponseBodyScalingConfigurationsVolumesConfigFileVolumeConfigFileToPaths {
	s.Path = &v
	return s
}

type DescribeEciScalingConfigurationsResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeEciScalingConfigurationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeEciScalingConfigurationsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeEciScalingConfigurationsResponse) GoString() string {
	return s.String()
}

func (s *DescribeEciScalingConfigurationsResponse) SetHeaders(v map[string]*string) *DescribeEciScalingConfigurationsResponse {
	s.Headers = v
	return s
}

func (s *DescribeEciScalingConfigurationsResponse) SetStatusCode(v int32) *DescribeEciScalingConfigurationsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeEciScalingConfigurationsResponse) SetBody(v *DescribeEciScalingConfigurationsResponseBody) *DescribeEciScalingConfigurationsResponse {
	s.Body = v
	return s
}

type DescribeLifecycleActionsRequest struct {
	// The token that is used to specify the lifecycle action from which the query starts.
	//
	// For example, after the first 10 lifecycle actions are queried, the query starts from the 11th lifecycle action. Set this parameter to the NextToken value that is returned in the previous API call. If you do not specify this parameter, the query starts from the beginning.
	LifecycleActionStatus *string `json:"LifecycleActionStatus,omitempty" xml:"LifecycleActionStatus,omitempty"`
	// The region ID of the scaling group.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The maximum number of entries to return on each page. Valid values: 1 to 50.
	//
	// Default value: 10.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerId   *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The query token returned in this call.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The status of the lifecycle action. Valid values:
	//
	// *   If a lifecycle action is in the Pending state, Elastic Compute Service (ECS) instances are waiting to be added to a scaling group or waiting to be removed from a scaling group.
	// *   If a lifecycle action is in the Timeout state, the lifecycle hook that triggers the lifecycle action ends, and ECS instances are added to or removed from the scaling group.
	// *   If a lifecycle action is in the Completed state, you manually end the lifecycle hook that triggers the lifecycle action ahead of schedule.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s DescribeLifecycleActionsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeLifecycleActionsRequest) GoString() string {
	return s.String()
}

func (s *DescribeLifecycleActionsRequest) SetLifecycleActionStatus(v string) *DescribeLifecycleActionsRequest {
	s.LifecycleActionStatus = &v
	return s
}

func (s *DescribeLifecycleActionsRequest) SetMaxResults(v int32) *DescribeLifecycleActionsRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeLifecycleActionsRequest) SetNextToken(v string) *DescribeLifecycleActionsRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeLifecycleActionsRequest) SetOwnerId(v int64) *DescribeLifecycleActionsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeLifecycleActionsRequest) SetRegionId(v string) *DescribeLifecycleActionsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeLifecycleActionsRequest) SetResourceOwnerAccount(v string) *DescribeLifecycleActionsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeLifecycleActionsRequest) SetScalingActivityId(v string) *DescribeLifecycleActionsRequest {
	s.ScalingActivityId = &v
	return s
}

type DescribeLifecycleActionsResponseBody struct {
	// The lifecycle actions.
	LifecycleActions []*DescribeLifecycleActionsResponseBodyLifecycleActions `json:"LifecycleActions,omitempty" xml:"LifecycleActions,omitempty" type:"Repeated"`
	// The lifecycle actions.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The ID of the request.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The total number of the queried lifecycle actions.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The maximum number of entries returned per page.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeLifecycleActionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeLifecycleActionsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeLifecycleActionsResponseBody) SetLifecycleActions(v []*DescribeLifecycleActionsResponseBodyLifecycleActions) *DescribeLifecycleActionsResponseBody {
	s.LifecycleActions = v
	return s
}

func (s *DescribeLifecycleActionsResponseBody) SetMaxResults(v int32) *DescribeLifecycleActionsResponseBody {
	s.MaxResults = &v
	return s
}

func (s *DescribeLifecycleActionsResponseBody) SetNextToken(v string) *DescribeLifecycleActionsResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeLifecycleActionsResponseBody) SetRequestId(v string) *DescribeLifecycleActionsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeLifecycleActionsResponseBody) SetTotalCount(v int32) *DescribeLifecycleActionsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeLifecycleActionsResponseBodyLifecycleActions struct {
	// The IDs of the ECS instances to which the lifecycle hook applies.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The IDs of the ECS instances to which the lifecycle hook applies.
	LifecycleActionResult *string `json:"LifecycleActionResult,omitempty" xml:"LifecycleActionResult,omitempty"`
	// The action that is performed after the lifecycle action triggered by the lifecycle hook is complete. Valid values:
	//
	// *   CONTINUE: Auto Scaling continues to add ECS instances to the scaling group, or continues to remove ECS instances from the scaling group.
	// *   ABANDON: Auto Scaling stops adding ECS instances to the scaling group and releases the ECS instances, or continues to respond to scale-in requests and remove ECS instances from the scaling group.
	LifecycleActionStatus *string `json:"LifecycleActionStatus,omitempty" xml:"LifecycleActionStatus,omitempty"`
	// The status of the lifecycle action.
	LifecycleActionToken *string `json:"LifecycleActionToken,omitempty" xml:"LifecycleActionToken,omitempty"`
	// The token of the lifecycle action.
	LifecycleHookId *string `json:"LifecycleHookId,omitempty" xml:"LifecycleHookId,omitempty"`
}

func (s DescribeLifecycleActionsResponseBodyLifecycleActions) String() string {
	return tea.Prettify(s)
}

func (s DescribeLifecycleActionsResponseBodyLifecycleActions) GoString() string {
	return s.String()
}

func (s *DescribeLifecycleActionsResponseBodyLifecycleActions) SetInstanceIds(v []*string) *DescribeLifecycleActionsResponseBodyLifecycleActions {
	s.InstanceIds = v
	return s
}

func (s *DescribeLifecycleActionsResponseBodyLifecycleActions) SetLifecycleActionResult(v string) *DescribeLifecycleActionsResponseBodyLifecycleActions {
	s.LifecycleActionResult = &v
	return s
}

func (s *DescribeLifecycleActionsResponseBodyLifecycleActions) SetLifecycleActionStatus(v string) *DescribeLifecycleActionsResponseBodyLifecycleActions {
	s.LifecycleActionStatus = &v
	return s
}

func (s *DescribeLifecycleActionsResponseBodyLifecycleActions) SetLifecycleActionToken(v string) *DescribeLifecycleActionsResponseBodyLifecycleActions {
	s.LifecycleActionToken = &v
	return s
}

func (s *DescribeLifecycleActionsResponseBodyLifecycleActions) SetLifecycleHookId(v string) *DescribeLifecycleActionsResponseBodyLifecycleActions {
	s.LifecycleHookId = &v
	return s
}

type DescribeLifecycleActionsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeLifecycleActionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeLifecycleActionsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeLifecycleActionsResponse) GoString() string {
	return s.String()
}

func (s *DescribeLifecycleActionsResponse) SetHeaders(v map[string]*string) *DescribeLifecycleActionsResponse {
	s.Headers = v
	return s
}

func (s *DescribeLifecycleActionsResponse) SetStatusCode(v int32) *DescribeLifecycleActionsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeLifecycleActionsResponse) SetBody(v *DescribeLifecycleActionsResponseBody) *DescribeLifecycleActionsResponse {
	s.Body = v
	return s
}

type DescribeLifecycleHooksRequest struct {
	// The ID of the lifecycle hook.
	LifecycleHookIds []*string `json:"LifecycleHookIds,omitempty" xml:"LifecycleHookIds,omitempty" type:"Repeated"`
	// The name of the lifecycle hook.
	LifecycleHookName *string `json:"LifecycleHookName,omitempty" xml:"LifecycleHookName,omitempty"`
	OwnerAccount      *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId           *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Pages start from page 1.
	//
	// Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: 50.
	//
	// Default value: 50.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DescribeLifecycleHooksRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeLifecycleHooksRequest) GoString() string {
	return s.String()
}

func (s *DescribeLifecycleHooksRequest) SetLifecycleHookIds(v []*string) *DescribeLifecycleHooksRequest {
	s.LifecycleHookIds = v
	return s
}

func (s *DescribeLifecycleHooksRequest) SetLifecycleHookName(v string) *DescribeLifecycleHooksRequest {
	s.LifecycleHookName = &v
	return s
}

func (s *DescribeLifecycleHooksRequest) SetOwnerAccount(v string) *DescribeLifecycleHooksRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeLifecycleHooksRequest) SetOwnerId(v int64) *DescribeLifecycleHooksRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeLifecycleHooksRequest) SetPageNumber(v int32) *DescribeLifecycleHooksRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeLifecycleHooksRequest) SetPageSize(v int32) *DescribeLifecycleHooksRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeLifecycleHooksRequest) SetRegionId(v string) *DescribeLifecycleHooksRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeLifecycleHooksRequest) SetResourceOwnerAccount(v string) *DescribeLifecycleHooksRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeLifecycleHooksRequest) SetScalingGroupId(v string) *DescribeLifecycleHooksRequest {
	s.ScalingGroupId = &v
	return s
}

type DescribeLifecycleHooksResponseBody struct {
	// Details of the lifecycle hooks.
	LifecycleHooks []*DescribeLifecycleHooksResponseBodyLifecycleHooks `json:"LifecycleHooks,omitempty" xml:"LifecycleHooks,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of lifecycle hooks.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeLifecycleHooksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeLifecycleHooksResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeLifecycleHooksResponseBody) SetLifecycleHooks(v []*DescribeLifecycleHooksResponseBodyLifecycleHooks) *DescribeLifecycleHooksResponseBody {
	s.LifecycleHooks = v
	return s
}

func (s *DescribeLifecycleHooksResponseBody) SetPageNumber(v int32) *DescribeLifecycleHooksResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeLifecycleHooksResponseBody) SetPageSize(v int32) *DescribeLifecycleHooksResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeLifecycleHooksResponseBody) SetRequestId(v string) *DescribeLifecycleHooksResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeLifecycleHooksResponseBody) SetTotalCount(v int32) *DescribeLifecycleHooksResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeLifecycleHooksResponseBodyLifecycleHooks struct {
	// The action that Auto Scaling performs after the lifecycle hook ends.
	DefaultResult *string `json:"DefaultResult,omitempty" xml:"DefaultResult,omitempty"`
	// The period of time before the lifecycle hook ends. Auto Scaling performs the specified action after the lifecycle hook ends.
	HeartbeatTimeout *int32 `json:"HeartbeatTimeout,omitempty" xml:"HeartbeatTimeout,omitempty"`
	// The ID of the lifecycle hook.
	LifecycleHookId *string `json:"LifecycleHookId,omitempty" xml:"LifecycleHookId,omitempty"`
	// The name of the lifecycle hook.
	LifecycleHookName *string `json:"LifecycleHookName,omitempty" xml:"LifecycleHookName,omitempty"`
	// The status of the lifecycle hook. Valid values:
	//
	// *   Active
	// *   InActive
	LifecycleHookStatus *string `json:"LifecycleHookStatus,omitempty" xml:"LifecycleHookStatus,omitempty"`
	// The type of the scaling activity to which the lifecycle hook applies.
	LifecycleTransition *string `json:"LifecycleTransition,omitempty" xml:"LifecycleTransition,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the method that is used by Auto Scaling to send notifications when the lifecycle hook takes effect. Specify the value in one of the following formats:
	//
	// *   If you do not create a notification rule, specify the value in the `acs:ess:{region-id}:{account-id}:null/null` format.
	// *   If you specify a Message Service (MNS) queue as the notification method, specify the value in the `acs:mns:{region-id}:{account-id}:queue/{queuename}` format.
	// *   If you specify an MNS topic as the notification method, specify the value in the `acs:mns:{region-id}:{account-id}:topic/{topicname}` format.
	// *   If you specify an Operation Orchestration Service (OOS) template as the notification method, specify the value in the `acs:oos:{region-id}:{account-id}:template/{templatename}` format.
	//
	// The variables in the preceding parameter formats have the following meanings:
	//
	// *   region-id: the region ID of the scaling group.
	// *   account-id: the ID of the Alibaba Cloud account.
	// *   queuename: the name of the MNS queue.
	// *   topicname: the name of the MNS topic.
	// *   templatename: the name of the OOS template.
	NotificationArn *string `json:"NotificationArn,omitempty" xml:"NotificationArn,omitempty"`
	// The fixed string that is included in a notification. Auto Scaling sends the notification when the lifecycle hook takes effect.
	NotificationMetadata *string `json:"NotificationMetadata,omitempty" xml:"NotificationMetadata,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DescribeLifecycleHooksResponseBodyLifecycleHooks) String() string {
	return tea.Prettify(s)
}

func (s DescribeLifecycleHooksResponseBodyLifecycleHooks) GoString() string {
	return s.String()
}

func (s *DescribeLifecycleHooksResponseBodyLifecycleHooks) SetDefaultResult(v string) *DescribeLifecycleHooksResponseBodyLifecycleHooks {
	s.DefaultResult = &v
	return s
}

func (s *DescribeLifecycleHooksResponseBodyLifecycleHooks) SetHeartbeatTimeout(v int32) *DescribeLifecycleHooksResponseBodyLifecycleHooks {
	s.HeartbeatTimeout = &v
	return s
}

func (s *DescribeLifecycleHooksResponseBodyLifecycleHooks) SetLifecycleHookId(v string) *DescribeLifecycleHooksResponseBodyLifecycleHooks {
	s.LifecycleHookId = &v
	return s
}

func (s *DescribeLifecycleHooksResponseBodyLifecycleHooks) SetLifecycleHookName(v string) *DescribeLifecycleHooksResponseBodyLifecycleHooks {
	s.LifecycleHookName = &v
	return s
}

func (s *DescribeLifecycleHooksResponseBodyLifecycleHooks) SetLifecycleHookStatus(v string) *DescribeLifecycleHooksResponseBodyLifecycleHooks {
	s.LifecycleHookStatus = &v
	return s
}

func (s *DescribeLifecycleHooksResponseBodyLifecycleHooks) SetLifecycleTransition(v string) *DescribeLifecycleHooksResponseBodyLifecycleHooks {
	s.LifecycleTransition = &v
	return s
}

func (s *DescribeLifecycleHooksResponseBodyLifecycleHooks) SetNotificationArn(v string) *DescribeLifecycleHooksResponseBodyLifecycleHooks {
	s.NotificationArn = &v
	return s
}

func (s *DescribeLifecycleHooksResponseBodyLifecycleHooks) SetNotificationMetadata(v string) *DescribeLifecycleHooksResponseBodyLifecycleHooks {
	s.NotificationMetadata = &v
	return s
}

func (s *DescribeLifecycleHooksResponseBodyLifecycleHooks) SetScalingGroupId(v string) *DescribeLifecycleHooksResponseBodyLifecycleHooks {
	s.ScalingGroupId = &v
	return s
}

type DescribeLifecycleHooksResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeLifecycleHooksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeLifecycleHooksResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeLifecycleHooksResponse) GoString() string {
	return s.String()
}

func (s *DescribeLifecycleHooksResponse) SetHeaders(v map[string]*string) *DescribeLifecycleHooksResponse {
	s.Headers = v
	return s
}

func (s *DescribeLifecycleHooksResponse) SetStatusCode(v int32) *DescribeLifecycleHooksResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeLifecycleHooksResponse) SetBody(v *DescribeLifecycleHooksResponseBody) *DescribeLifecycleHooksResponse {
	s.Body = v
	return s
}

type DescribeLimitationRequest struct {
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
}

func (s DescribeLimitationRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeLimitationRequest) GoString() string {
	return s.String()
}

func (s *DescribeLimitationRequest) SetOwnerId(v int64) *DescribeLimitationRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeLimitationRequest) SetResourceOwnerAccount(v string) *DescribeLimitationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

type DescribeLimitationResponseBody struct {
	MaxNumberOfAlbServerGroup             *int32  `json:"MaxNumberOfAlbServerGroup,omitempty" xml:"MaxNumberOfAlbServerGroup,omitempty"`
	MaxNumberOfDBInstances                *int32  `json:"MaxNumberOfDBInstances,omitempty" xml:"MaxNumberOfDBInstances,omitempty"`
	MaxNumberOfLifecycleHooks             *int32  `json:"MaxNumberOfLifecycleHooks,omitempty" xml:"MaxNumberOfLifecycleHooks,omitempty"`
	MaxNumberOfLoadBalancers              *int32  `json:"MaxNumberOfLoadBalancers,omitempty" xml:"MaxNumberOfLoadBalancers,omitempty"`
	MaxNumberOfMaxSize                    *int32  `json:"MaxNumberOfMaxSize,omitempty" xml:"MaxNumberOfMaxSize,omitempty"`
	MaxNumberOfMinSize                    *int32  `json:"MaxNumberOfMinSize,omitempty" xml:"MaxNumberOfMinSize,omitempty"`
	MaxNumberOfNotificationConfigurations *int32  `json:"MaxNumberOfNotificationConfigurations,omitempty" xml:"MaxNumberOfNotificationConfigurations,omitempty"`
	MaxNumberOfScalingConfigurations      *int32  `json:"MaxNumberOfScalingConfigurations,omitempty" xml:"MaxNumberOfScalingConfigurations,omitempty"`
	MaxNumberOfScalingGroups              *int32  `json:"MaxNumberOfScalingGroups,omitempty" xml:"MaxNumberOfScalingGroups,omitempty"`
	MaxNumberOfScalingInstances           *int32  `json:"MaxNumberOfScalingInstances,omitempty" xml:"MaxNumberOfScalingInstances,omitempty"`
	MaxNumberOfScalingRules               *int32  `json:"MaxNumberOfScalingRules,omitempty" xml:"MaxNumberOfScalingRules,omitempty"`
	MaxNumberOfScheduledTasks             *int32  `json:"MaxNumberOfScheduledTasks,omitempty" xml:"MaxNumberOfScheduledTasks,omitempty"`
	MaxNumberOfVServerGroups              *int32  `json:"MaxNumberOfVServerGroups,omitempty" xml:"MaxNumberOfVServerGroups,omitempty"`
	RequestId                             *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeLimitationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeLimitationResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfAlbServerGroup(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfAlbServerGroup = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfDBInstances(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfDBInstances = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfLifecycleHooks(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfLifecycleHooks = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfLoadBalancers(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfLoadBalancers = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfMaxSize(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfMaxSize = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfMinSize(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfMinSize = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfNotificationConfigurations(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfNotificationConfigurations = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfScalingConfigurations(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfScalingConfigurations = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfScalingGroups(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfScalingGroups = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfScalingInstances(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfScalingInstances = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfScalingRules(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfScalingRules = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfScheduledTasks(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfScheduledTasks = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetMaxNumberOfVServerGroups(v int32) *DescribeLimitationResponseBody {
	s.MaxNumberOfVServerGroups = &v
	return s
}

func (s *DescribeLimitationResponseBody) SetRequestId(v string) *DescribeLimitationResponseBody {
	s.RequestId = &v
	return s
}

type DescribeLimitationResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeLimitationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeLimitationResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeLimitationResponse) GoString() string {
	return s.String()
}

func (s *DescribeLimitationResponse) SetHeaders(v map[string]*string) *DescribeLimitationResponse {
	s.Headers = v
	return s
}

func (s *DescribeLimitationResponse) SetStatusCode(v int32) *DescribeLimitationResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeLimitationResponse) SetBody(v *DescribeLimitationResponseBody) *DescribeLimitationResponse {
	s.Body = v
	return s
}

type DescribeNotificationConfigurationsRequest struct {
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The region ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DescribeNotificationConfigurationsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeNotificationConfigurationsRequest) GoString() string {
	return s.String()
}

func (s *DescribeNotificationConfigurationsRequest) SetOwnerId(v int64) *DescribeNotificationConfigurationsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeNotificationConfigurationsRequest) SetRegionId(v string) *DescribeNotificationConfigurationsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeNotificationConfigurationsRequest) SetResourceOwnerAccount(v string) *DescribeNotificationConfigurationsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeNotificationConfigurationsRequest) SetScalingGroupId(v string) *DescribeNotificationConfigurationsRequest {
	s.ScalingGroupId = &v
	return s
}

type DescribeNotificationConfigurationsResponseBody struct {
	// Details of the notifications.
	NotificationConfigurationModels []*DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels `json:"NotificationConfigurationModels,omitempty" xml:"NotificationConfigurationModels,omitempty" type:"Repeated"`
	// Details of the notifications.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeNotificationConfigurationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeNotificationConfigurationsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeNotificationConfigurationsResponseBody) SetNotificationConfigurationModels(v []*DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels) *DescribeNotificationConfigurationsResponseBody {
	s.NotificationConfigurationModels = v
	return s
}

func (s *DescribeNotificationConfigurationsResponseBody) SetRequestId(v string) *DescribeNotificationConfigurationsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels struct {
	// The ID of the scaling group.
	NotificationArn *string `json:"NotificationArn,omitempty" xml:"NotificationArn,omitempty"`
	// The types of the notifications.
	NotificationTypes []*string `json:"NotificationTypes,omitempty" xml:"NotificationTypes,omitempty" type:"Repeated"`
	// The types of the notifications.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels) String() string {
	return tea.Prettify(s)
}

func (s DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels) GoString() string {
	return s.String()
}

func (s *DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels) SetNotificationArn(v string) *DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels {
	s.NotificationArn = &v
	return s
}

func (s *DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels) SetNotificationTypes(v []*string) *DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels {
	s.NotificationTypes = v
	return s
}

func (s *DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels) SetScalingGroupId(v string) *DescribeNotificationConfigurationsResponseBodyNotificationConfigurationModels {
	s.ScalingGroupId = &v
	return s
}

type DescribeNotificationConfigurationsResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeNotificationConfigurationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeNotificationConfigurationsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeNotificationConfigurationsResponse) GoString() string {
	return s.String()
}

func (s *DescribeNotificationConfigurationsResponse) SetHeaders(v map[string]*string) *DescribeNotificationConfigurationsResponse {
	s.Headers = v
	return s
}

func (s *DescribeNotificationConfigurationsResponse) SetStatusCode(v int32) *DescribeNotificationConfigurationsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeNotificationConfigurationsResponse) SetBody(v *DescribeNotificationConfigurationsResponseBody) *DescribeNotificationConfigurationsResponse {
	s.Body = v
	return s
}

type DescribeNotificationTypesRequest struct {
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
}

func (s DescribeNotificationTypesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeNotificationTypesRequest) GoString() string {
	return s.String()
}

func (s *DescribeNotificationTypesRequest) SetOwnerId(v int64) *DescribeNotificationTypesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeNotificationTypesRequest) SetResourceOwnerAccount(v string) *DescribeNotificationTypesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

type DescribeNotificationTypesResponseBody struct {
	// The types of the notifications.
	//
	// *   AUTOSCALING:SCALE_OUT_SUCCESS: The scale-out activity succeeds.
	// *   AUTOSCALING:SCALE_IN_SUCCESS: The scale-in activity succeeds.
	// *   AUTOSCALING:SCALE_OUT_ERROR: The scale-out activity fails.
	// *   AUTOSCALING:SCALE_IN_ERROR: The scale-in activity fails.
	// *   AUTOSCALING:SCALE_REJECT: The request for scaling activities is rejected.
	// *   AUTOSCALING:SCALE_OUT_START: The scale-out activity starts.
	// *   AUTOSCALING:SCALE_IN_START: The scale-in activity starts.
	// *   AUTOSCALING:SCHEDULE_TASK_EXPIRING: Auto Scaling sends a notification when a scheduled task is about to expire.
	NotificationTypes []*string `json:"NotificationTypes,omitempty" xml:"NotificationTypes,omitempty" type:"Repeated"`
	// The types of the notifications.
	//
	// *   AUTOSCALING:SCALE_OUT_SUCCESS: The scale-out activity succeeds.
	// *   AUTOSCALING:SCALE_IN_SUCCESS: The scale-in activity succeeds.
	// *   AUTOSCALING:SCALE_OUT_ERROR: The scale-out activity fails.
	// *   AUTOSCALING:SCALE_IN_ERROR: The scale-in activity fails.
	// *   AUTOSCALING:SCALE_REJECT: The request for scaling activities is rejected.
	// *   AUTOSCALING:SCALE_OUT_START: The scale-out activity starts.
	// *   AUTOSCALING:SCALE_IN_START: The scale-in activity starts.
	// *   AUTOSCALING:SCHEDULE_TASK_EXPIRING: Auto Scaling sends a notification when a scheduled task is about to expire.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeNotificationTypesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeNotificationTypesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeNotificationTypesResponseBody) SetNotificationTypes(v []*string) *DescribeNotificationTypesResponseBody {
	s.NotificationTypes = v
	return s
}

func (s *DescribeNotificationTypesResponseBody) SetRequestId(v string) *DescribeNotificationTypesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeNotificationTypesResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeNotificationTypesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeNotificationTypesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeNotificationTypesResponse) GoString() string {
	return s.String()
}

func (s *DescribeNotificationTypesResponse) SetHeaders(v map[string]*string) *DescribeNotificationTypesResponse {
	s.Headers = v
	return s
}

func (s *DescribeNotificationTypesResponse) SetStatusCode(v int32) *DescribeNotificationTypesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeNotificationTypesResponse) SetBody(v *DescribeNotificationTypesResponseBody) *DescribeNotificationTypesResponse {
	s.Body = v
	return s
}

type DescribeRegionsRequest struct {
	// The ID of the request.
	AcceptLanguage       *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeRegionsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsRequest) GoString() string {
	return s.String()
}

func (s *DescribeRegionsRequest) SetAcceptLanguage(v string) *DescribeRegionsRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DescribeRegionsRequest) SetOwnerId(v int64) *DescribeRegionsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeRegionsRequest) SetResourceOwnerAccount(v string) *DescribeRegionsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeRegionsRequest) SetResourceOwnerId(v int64) *DescribeRegionsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeRegionsResponseBody struct {
	// Details of the regions.
	Regions []*DescribeRegionsResponseBodyRegions `json:"Regions,omitempty" xml:"Regions,omitempty" type:"Repeated"`
	// Details of the regions.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeRegionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBody) SetRegions(v []*DescribeRegionsResponseBodyRegions) *DescribeRegionsResponseBody {
	s.Regions = v
	return s
}

func (s *DescribeRegionsResponseBody) SetRequestId(v string) *DescribeRegionsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeRegionsResponseBodyRegions struct {
	// The endpoint of the region.
	ClassicUnavailable *bool `json:"ClassicUnavailable,omitempty" xml:"ClassicUnavailable,omitempty"`
	// China (Beijing)
	LocalName *string `json:"LocalName,omitempty" xml:"LocalName,omitempty"`
	// The name of the region.
	RegionEndpoint *string `json:"RegionEndpoint,omitempty" xml:"RegionEndpoint,omitempty"`
	// auditing
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the region.
	VpcUnavailable *bool `json:"VpcUnavailable,omitempty" xml:"VpcUnavailable,omitempty"`
}

func (s DescribeRegionsResponseBodyRegions) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponseBodyRegions) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBodyRegions) SetClassicUnavailable(v bool) *DescribeRegionsResponseBodyRegions {
	s.ClassicUnavailable = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegions) SetLocalName(v string) *DescribeRegionsResponseBodyRegions {
	s.LocalName = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegions) SetRegionEndpoint(v string) *DescribeRegionsResponseBodyRegions {
	s.RegionEndpoint = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegions) SetRegionId(v string) *DescribeRegionsResponseBodyRegions {
	s.RegionId = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegions) SetVpcUnavailable(v bool) *DescribeRegionsResponseBodyRegions {
	s.VpcUnavailable = &v
	return s
}

type DescribeRegionsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRegionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRegionsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponse) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponse) SetHeaders(v map[string]*string) *DescribeRegionsResponse {
	s.Headers = v
	return s
}

func (s *DescribeRegionsResponse) SetStatusCode(v int32) *DescribeRegionsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRegionsResponse) SetBody(v *DescribeRegionsResponseBody) *DescribeRegionsResponse {
	s.Body = v
	return s
}

type DescribeScalingActivitiesRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Pages start from page 1.
	//
	// Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: 50.
	//
	// Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the scaling group to which the scaling activity that you want to query belongs.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The IDs of the scaling activities that you want to query.
	//
	// > When you call this operation, you must specify a value for the ScalingGroupId or ScalingActivityIds parameter.
	ScalingActivityIds []*string `json:"ScalingActivityIds,omitempty" xml:"ScalingActivityIds,omitempty" type:"Repeated"`
	// The ID of the scaling group.
	//
	// > When you call this operation, you must specify a value for the ScalingGroupId or ScalingActivityIds parameter.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The status of the scaling activity. Valid values:
	//
	// *   Successful: The scaling activity is successful.
	// *   Warning: The scaling activity is partially successful.
	// *   Failed: The scaling activity failed.
	// *   InProgress: The scaling activity is in progress.
	// *   Rejected: The request to trigger the scaling activity is rejected.
	StatusCode *string `json:"StatusCode,omitempty" xml:"StatusCode,omitempty"`
}

func (s DescribeScalingActivitiesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingActivitiesRequest) GoString() string {
	return s.String()
}

func (s *DescribeScalingActivitiesRequest) SetOwnerAccount(v string) *DescribeScalingActivitiesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeScalingActivitiesRequest) SetOwnerId(v int64) *DescribeScalingActivitiesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeScalingActivitiesRequest) SetPageNumber(v int32) *DescribeScalingActivitiesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeScalingActivitiesRequest) SetPageSize(v int32) *DescribeScalingActivitiesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeScalingActivitiesRequest) SetRegionId(v string) *DescribeScalingActivitiesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeScalingActivitiesRequest) SetResourceOwnerAccount(v string) *DescribeScalingActivitiesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeScalingActivitiesRequest) SetResourceOwnerId(v int64) *DescribeScalingActivitiesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeScalingActivitiesRequest) SetScalingActivityIds(v []*string) *DescribeScalingActivitiesRequest {
	s.ScalingActivityIds = v
	return s
}

func (s *DescribeScalingActivitiesRequest) SetScalingGroupId(v string) *DescribeScalingActivitiesRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeScalingActivitiesRequest) SetStatusCode(v string) *DescribeScalingActivitiesRequest {
	s.StatusCode = &v
	return s
}

type DescribeScalingActivitiesResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Details of the scaling activities.
	ScalingActivities []*DescribeScalingActivitiesResponseBodyScalingActivities `json:"ScalingActivities,omitempty" xml:"ScalingActivities,omitempty" type:"Repeated"`
	// The total number of scaling activities.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeScalingActivitiesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingActivitiesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeScalingActivitiesResponseBody) SetPageNumber(v int32) *DescribeScalingActivitiesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBody) SetPageSize(v int32) *DescribeScalingActivitiesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBody) SetRequestId(v string) *DescribeScalingActivitiesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBody) SetScalingActivities(v []*DescribeScalingActivitiesResponseBodyScalingActivities) *DescribeScalingActivitiesResponseBody {
	s.ScalingActivities = v
	return s
}

func (s *DescribeScalingActivitiesResponseBody) SetTotalCount(v int32) *DescribeScalingActivitiesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeScalingActivitiesResponseBodyScalingActivities struct {
	// The total number of instances that were manually added to the scaling group after the scaling activity was complete.
	AttachedCapacity *string `json:"AttachedCapacity,omitempty" xml:"AttachedCapacity,omitempty"`
	// The total number of instances that were created by Auto Scaling after the scaling activity was complete.
	AutoCreatedCapacity *string `json:"AutoCreatedCapacity,omitempty" xml:"AutoCreatedCapacity,omitempty"`
	// The cause that triggered the scaling activity.
	Cause            *string   `json:"Cause,omitempty" xml:"Cause,omitempty"`
	CreatedCapacity  *int32    `json:"CreatedCapacity,omitempty" xml:"CreatedCapacity,omitempty"`
	CreatedInstances []*string `json:"CreatedInstances,omitempty" xml:"CreatedInstances,omitempty" type:"Repeated"`
	// The description of the scaling activity.
	Description        *string   `json:"Description,omitempty" xml:"Description,omitempty"`
	DestroyedCapacity  *int32    `json:"DestroyedCapacity,omitempty" xml:"DestroyedCapacity,omitempty"`
	DestroyedInstances []*string `json:"DestroyedInstances,omitempty" xml:"DestroyedInstances,omitempty" type:"Repeated"`
	Detail             *string   `json:"Detail,omitempty" xml:"Detail,omitempty"`
	// The time when the scaling activity was complete.
	EndTime      *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	ErrorCode    *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The execution progress of the scaling activity.
	Progress *int32 `json:"Progress,omitempty" xml:"Progress,omitempty"`
	// The ID of the scaling activity.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The number of instances that were created or restarted from the economical mode during the scale-out activity.
	//
	// The number of instances that were deleted or put into the economical mode during the scale-in activity.
	ScalingInstanceNumber *int32 `json:"ScalingInstanceNumber,omitempty" xml:"ScalingInstanceNumber,omitempty"`
	// The time when the scaling activity started.
	StartTime        *string   `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	StartedCapacity  *int32    `json:"StartedCapacity,omitempty" xml:"StartedCapacity,omitempty"`
	StartedInstances []*string `json:"StartedInstances,omitempty" xml:"StartedInstances,omitempty" type:"Repeated"`
	// The status of the scaling activity. Valid values:
	//
	// *   Successful: The scaling activity is successful.
	// *   Warning: The scaling activity is partially successful.
	// *   Failed: The scaling activity failed.
	// *   InProgress: The scaling activity is in progress.
	// *   Rejected: The request to trigger the scaling activity is rejected.
	StatusCode *string `json:"StatusCode,omitempty" xml:"StatusCode,omitempty"`
	// The status message of the scaling activity.
	StatusMessage    *string   `json:"StatusMessage,omitempty" xml:"StatusMessage,omitempty"`
	StoppedCapacity  *int32    `json:"StoppedCapacity,omitempty" xml:"StoppedCapacity,omitempty"`
	StoppedInstances []*string `json:"StoppedInstances,omitempty" xml:"StoppedInstances,omitempty" type:"Repeated"`
	// The total number of instances in the scaling group after the scaling activity was complete.
	TotalCapacity *string `json:"TotalCapacity,omitempty" xml:"TotalCapacity,omitempty"`
}

func (s DescribeScalingActivitiesResponseBodyScalingActivities) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingActivitiesResponseBodyScalingActivities) GoString() string {
	return s.String()
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetAttachedCapacity(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.AttachedCapacity = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetAutoCreatedCapacity(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.AutoCreatedCapacity = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetCause(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.Cause = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetCreatedCapacity(v int32) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.CreatedCapacity = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetCreatedInstances(v []*string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.CreatedInstances = v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetDescription(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.Description = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetDestroyedCapacity(v int32) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.DestroyedCapacity = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetDestroyedInstances(v []*string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.DestroyedInstances = v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetDetail(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.Detail = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetEndTime(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.EndTime = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetErrorCode(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.ErrorCode = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetErrorMessage(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.ErrorMessage = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetProgress(v int32) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.Progress = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetScalingActivityId(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.ScalingActivityId = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetScalingGroupId(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetScalingInstanceNumber(v int32) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.ScalingInstanceNumber = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetStartTime(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.StartTime = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetStartedCapacity(v int32) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.StartedCapacity = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetStartedInstances(v []*string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.StartedInstances = v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetStatusCode(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.StatusCode = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetStatusMessage(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.StatusMessage = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetStoppedCapacity(v int32) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.StoppedCapacity = &v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetStoppedInstances(v []*string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.StoppedInstances = v
	return s
}

func (s *DescribeScalingActivitiesResponseBodyScalingActivities) SetTotalCapacity(v string) *DescribeScalingActivitiesResponseBodyScalingActivities {
	s.TotalCapacity = &v
	return s
}

type DescribeScalingActivitiesResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeScalingActivitiesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeScalingActivitiesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingActivitiesResponse) GoString() string {
	return s.String()
}

func (s *DescribeScalingActivitiesResponse) SetHeaders(v map[string]*string) *DescribeScalingActivitiesResponse {
	s.Headers = v
	return s
}

func (s *DescribeScalingActivitiesResponse) SetStatusCode(v int32) *DescribeScalingActivitiesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeScalingActivitiesResponse) SetBody(v *DescribeScalingActivitiesResponseBody) *DescribeScalingActivitiesResponse {
	s.Body = v
	return s
}

type DescribeScalingActivityDetailRequest struct {
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the request.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s DescribeScalingActivityDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingActivityDetailRequest) GoString() string {
	return s.String()
}

func (s *DescribeScalingActivityDetailRequest) SetOwnerId(v int64) *DescribeScalingActivityDetailRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeScalingActivityDetailRequest) SetResourceOwnerAccount(v string) *DescribeScalingActivityDetailRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeScalingActivityDetailRequest) SetResourceOwnerId(v int64) *DescribeScalingActivityDetailRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeScalingActivityDetailRequest) SetScalingActivityId(v string) *DescribeScalingActivityDetailRequest {
	s.ScalingActivityId = &v
	return s
}

type DescribeScalingActivityDetailResponseBody struct {
	// auditing
	Detail *string `json:"Detail,omitempty" xml:"Detail,omitempty"`
	// The ID of the scaling activity.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Details of the scaling activity.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s DescribeScalingActivityDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingActivityDetailResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeScalingActivityDetailResponseBody) SetDetail(v string) *DescribeScalingActivityDetailResponseBody {
	s.Detail = &v
	return s
}

func (s *DescribeScalingActivityDetailResponseBody) SetRequestId(v string) *DescribeScalingActivityDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeScalingActivityDetailResponseBody) SetScalingActivityId(v string) *DescribeScalingActivityDetailResponseBody {
	s.ScalingActivityId = &v
	return s
}

type DescribeScalingActivityDetailResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeScalingActivityDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeScalingActivityDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingActivityDetailResponse) GoString() string {
	return s.String()
}

func (s *DescribeScalingActivityDetailResponse) SetHeaders(v map[string]*string) *DescribeScalingActivityDetailResponse {
	s.Headers = v
	return s
}

func (s *DescribeScalingActivityDetailResponse) SetStatusCode(v int32) *DescribeScalingActivityDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeScalingActivityDetailResponse) SetBody(v *DescribeScalingActivityDetailResponseBody) *DescribeScalingActivityDetailResponse {
	s.Body = v
	return s
}

type DescribeScalingConfigurationsRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of entries to return on each page. Maximum value: 50.
	//
	// Default value: 10.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The ID of the scaling group. You can use the ID to query all scaling configurations in the scaling group.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The number of the page to return. Pages start from page 1.
	//
	// Default value: 1.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The IDs of the scaling configurations that you want to query.
	//
	// The IDs of active and inactive scaling configurations are displayed in the query results. You can differentiate between active and inactive scaling configurations based on the value of the `LifecycleState` parameter.
	ScalingConfigurationIds []*string `json:"ScalingConfigurationIds,omitempty" xml:"ScalingConfigurationIds,omitempty" type:"Repeated"`
	// The names of the scaling configurations that you want to query.
	//
	// The names of inactive scaling configurations are not displayed in the query results, and no error is reported.
	ScalingConfigurationNames []*string `json:"ScalingConfigurationNames,omitempty" xml:"ScalingConfigurationNames,omitempty" type:"Repeated"`
	// The IDs of the scaling configurations that you want to query.
	//
	// The IDs of active and inactive scaling configurations are displayed in the query results. You can differentiate between active and inactive scaling configurations based on the value of the `LifecycleState` parameter.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DescribeScalingConfigurationsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingConfigurationsRequest) GoString() string {
	return s.String()
}

func (s *DescribeScalingConfigurationsRequest) SetOwnerAccount(v string) *DescribeScalingConfigurationsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeScalingConfigurationsRequest) SetOwnerId(v int64) *DescribeScalingConfigurationsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeScalingConfigurationsRequest) SetPageNumber(v int32) *DescribeScalingConfigurationsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeScalingConfigurationsRequest) SetPageSize(v int32) *DescribeScalingConfigurationsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeScalingConfigurationsRequest) SetRegionId(v string) *DescribeScalingConfigurationsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeScalingConfigurationsRequest) SetResourceOwnerAccount(v string) *DescribeScalingConfigurationsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeScalingConfigurationsRequest) SetResourceOwnerId(v int64) *DescribeScalingConfigurationsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeScalingConfigurationsRequest) SetScalingConfigurationIds(v []*string) *DescribeScalingConfigurationsRequest {
	s.ScalingConfigurationIds = v
	return s
}

func (s *DescribeScalingConfigurationsRequest) SetScalingConfigurationNames(v []*string) *DescribeScalingConfigurationsRequest {
	s.ScalingConfigurationNames = v
	return s
}

func (s *DescribeScalingConfigurationsRequest) SetScalingGroupId(v string) *DescribeScalingConfigurationsRequest {
	s.ScalingGroupId = &v
	return s
}

type DescribeScalingConfigurationsResponseBody struct {
	// The number of entries returned per page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The total number of scaling configurations.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The page number of the returned page.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Details of the scaling configurations.
	ScalingConfigurations []*DescribeScalingConfigurationsResponseBodyScalingConfigurations `json:"ScalingConfigurations,omitempty" xml:"ScalingConfigurations,omitempty" type:"Repeated"`
	// Details of the scaling configurations.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeScalingConfigurationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingConfigurationsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeScalingConfigurationsResponseBody) SetPageNumber(v int32) *DescribeScalingConfigurationsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBody) SetPageSize(v int32) *DescribeScalingConfigurationsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBody) SetRequestId(v string) *DescribeScalingConfigurationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBody) SetScalingConfigurations(v []*DescribeScalingConfigurationsResponseBodyScalingConfigurations) *DescribeScalingConfigurationsResponseBody {
	s.ScalingConfigurations = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBody) SetTotalCount(v int32) *DescribeScalingConfigurationsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeScalingConfigurationsResponseBodyScalingConfigurations struct {
	PrivatePoolOptions *DescribeScalingConfigurationsResponseBodyScalingConfigurationsPrivatePoolOptions `json:"PrivatePoolOptions,omitempty" xml:"PrivatePoolOptions,omitempty" require:"true" type:"Struct"`
	// The size of the system disk. Unit: GiB.
	Affinity *string `json:"Affinity,omitempty" xml:"Affinity,omitempty"`
	// The billing method for network usage. Valid values:
	//
	// *   PayByBandwidth: You are charged for the maximum available bandwidth that is specified by the InternetMaxBandwidthOut parameter.
	// *   PayByTraffic: You are charged for the actual traffic that you used. The InternetMaxBandwidthOut parameter specifies only the maximum available bandwidth.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The name of the scaling configuration.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// Details of the data disks.
	CreditSpecification *string `json:"CreditSpecification,omitempty" xml:"CreditSpecification,omitempty"`
	// The description of the data disk.
	DataDisks []*DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks `json:"DataDisks,omitempty" xml:"DataDisks,omitempty" type:"Repeated"`
	// Indicates whether the password preconfigured in the image is used.
	DedicatedHostId *string `json:"DedicatedHostId,omitempty" xml:"DedicatedHostId,omitempty"`
	// The time when the scaling configuration was created.
	DeploymentSetId *string `json:"DeploymentSetId,omitempty" xml:"DeploymentSetId,omitempty"`
	// The maximum inbound public bandwidth. Unit: Mbit/s. Valid values: 1 to 100.
	HostName *string `json:"HostName,omitempty" xml:"HostName,omitempty"`
	// The ID of the image that is used by Auto Scaling to create instances.
	HpcClusterId *string `json:"HpcClusterId,omitempty" xml:"HpcClusterId,omitempty"`
	// The hostname of the ECS instance.
	ImageFamily *string `json:"ImageFamily,omitempty" xml:"ImageFamily,omitempty"`
	// The category of the system disk. Valid values:
	//
	// *   cloud: basic disk
	// *   cloud_efficiency: ultra disk
	// *   cloud_ssd: standard SSD
	// *   ephemeral_ssd: local standard SSD
	// *   cloud_essd: ESSD
	// *   cloud_auto: ESSD AutoPL disk
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The interruption mode of the preemptible instance.
	ImageName       *string `json:"ImageName,omitempty" xml:"ImageName,omitempty"`
	ImageOwnerAlias *string `json:"ImageOwnerAlias,omitempty" xml:"ImageOwnerAlias,omitempty"`
	// The performance level (PL) of the system disk of the ESSD category.
	InstanceDescription *string `json:"InstanceDescription,omitempty" xml:"InstanceDescription,omitempty"`
	// The memory size. Unit: GiB.
	//
	// You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. If you specify the Cpu and Memory parameters, Auto Scaling determines available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.
	//
	// > You can specify CPU and memory specifications to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
	InstanceGeneration *string `json:"InstanceGeneration,omitempty" xml:"InstanceGeneration,omitempty"`
	// The user data of the ECS instance.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The number of vCPUs that is allocated to the instance type.
	InstancePatternInfos []*DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos `json:"InstancePatternInfos,omitempty" xml:"InstancePatternInfos,omitempty" type:"Repeated"`
	// The name of the RAM role that is associated with the ECS instance. The name is provided and maintained by Resource Access Management (RAM). You can call the ListRoles operation to query the available RAM roles.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The IDs of the security groups with which the ECS instance is associated. ECS instances that are associated with the same security group can access each other.
	InstanceTypes []*string `json:"InstanceTypes,omitempty" xml:"InstanceTypes,omitempty" type:"Repeated"`
	// The performance mode of the burstable instance. Valid values:
	//
	// *   Standard: standard mode. For more information, see the "Standard mode" section of [Burstable instances](~~59977~~).
	// *   Unlimited: unlimited mode. For more information, see the "Unlimited mode" section of [Burstable instances](~~59977~~).
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// Indicates whether the instance is an I/O optimized instance. Valid values:
	//
	// *   none: The instance is not I/O optimized.
	// *   optimized: The instance is I/O optimized.
	InternetMaxBandwidthIn *int32 `json:"InternetMaxBandwidthIn,omitempty" xml:"InternetMaxBandwidthIn,omitempty"`
	// The description of the ECS instance.
	InternetMaxBandwidthOut *int32 `json:"InternetMaxBandwidthOut,omitempty" xml:"InternetMaxBandwidthOut,omitempty"`
	// The number of vCPUs.
	//
	// You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. If you specify the Cpu and Memory parameters, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.
	//
	// > You can specify CPU and memory specifications to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
	IoOptimized *string `json:"IoOptimized,omitempty" xml:"IoOptimized,omitempty"`
	// The state of the scaling configuration in the scaling group. Valid values:
	//
	// *   Active: The scaling configuration is active in the scaling group. Auto Scaling uses active scaling configurations to automatically create ECS instances.
	// *   Inactive: The scaling configuration is inactive in the scaling group. Auto Scaling does not use inactive scaling configurations to automatically create ECS instances. Inactive scaling configurations are retained in the scaling group.
	Ipv6AddressCount *int32 `json:"Ipv6AddressCount,omitempty" xml:"Ipv6AddressCount,omitempty"`
	// The ID of the security group with which the ECS instance is associated. ECS instances that are associated with the same security group can access each other.
	KeyPairName *string `json:"KeyPairName,omitempty" xml:"KeyPairName,omitempty"`
	// Indicates whether security hardening is enabled. Valid values:
	//
	// *   Active: Security hardening is enabled. This value is available only for public images.
	// *   Deactive: Security hardening is disabled. This value is available for all types of images.
	LifecycleState *string `json:"LifecycleState,omitempty" xml:"LifecycleState,omitempty"`
	// The name of the system disk.
	LoadBalancerWeight *int32 `json:"LoadBalancerWeight,omitempty" xml:"LoadBalancerWeight,omitempty"`
	// The weight of the ECS instance as a backend server. Valid values: 1 to 100.
	Memory *int32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The name of the image family. If you specify this parameter, the latest custom images that are available in the specified image family are returned. You can use the images to create instances. If you specify the ImageId parameter, you cannot specify the ImageFamily parameter.
	PasswordInherit *bool `json:"PasswordInherit,omitempty" xml:"PasswordInherit,omitempty"`
	// The ID of the resource group to which the ECS instance belongs.
	RamRoleName *string `json:"RamRoleName,omitempty" xml:"RamRoleName,omitempty"`
	// The name of the image file.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Details of the data disks.
	ScalingConfigurationId *string `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
	// The description of the system disk.
	ScalingConfigurationName *string `json:"ScalingConfigurationName,omitempty" xml:"ScalingConfigurationName,omitempty"`
	// Indicates whether the instance is created on a dedicated host. Valid values:
	//
	// *   default: does not create the instance on a dedicated host.
	// *   host: creates the instance on a dedicated host. If you do not specify the DedicatedHostId parameter, the system selects a dedicated host for the instance that is created.
	//
	// Default value: default.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The ID of the KMS key that is used to encrypt the system disk.
	SchedulerOptions *DescribeScalingConfigurationsResponseBodyScalingConfigurationsSchedulerOptions `json:"SchedulerOptions,omitempty" xml:"SchedulerOptions,omitempty" type:"Struct"`
	// The ID of the dedicated host on which the ECS instance runs. You cannot create preemptible instances on dedicated hosts. If you specify the DedicatedHostId parameter, the SpotStrategy and SpotPriceLimit parameters are ignored.
	//
	// You can call the DescribeDedicatedHosts operation to query dedicated host IDs.
	SecurityEnhancementStrategy *string `json:"SecurityEnhancementStrategy,omitempty" xml:"SecurityEnhancementStrategy,omitempty"`
	// The ID of the automatic snapshot policy that you want to apply to the system disk.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// > This parameter is in invitational preview and is unavailable.
	SecurityGroupIds []*string `json:"SecurityGroupIds,omitempty" xml:"SecurityGroupIds,omitempty" type:"Repeated"`
	// The name of the ECS instance.
	SpotDuration *int32 `json:"SpotDuration,omitempty" xml:"SpotDuration,omitempty"`
	// The PL of the data disk of the ESSD category.
	SpotInterruptionBehavior *string `json:"SpotInterruptionBehavior,omitempty" xml:"SpotInterruptionBehavior,omitempty"`
	// The price limit of the preemptible instance.
	SpotPriceLimits []*DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits `json:"SpotPriceLimits,omitempty" xml:"SpotPriceLimits,omitempty" type:"Repeated"`
	// Indicates whether the instance on the dedicated host is associated with the dedicated host. Valid values:
	//
	// *   default: The instance is not associated with the dedicated host. If you start an instance that was stopped in economical mode and the original dedicated host of the instance has insufficient resources, the instance is automatically deployed to another dedicated host in the automatic deployment resource pool.
	// *   host: The instance is associated with the dedicated host. If you start an instance that was stopped in economical mode, the instance remains on the original dedicated host. If the original dedicated host has insufficient resources, the instance fails to start.
	SpotStrategy *string `json:"SpotStrategy,omitempty" xml:"SpotStrategy,omitempty"`
	// The ID of the scaling group in which the scaling configuration is created.
	SystemDiskAutoSnapshotPolicyId *string `json:"SystemDiskAutoSnapshotPolicyId,omitempty" xml:"SystemDiskAutoSnapshotPolicyId,omitempty"`
	// Specifies whether to enable the burst feature for the system disk. Valid values:
	//
	// *   true
	// *   false
	//
	// > This parameter is available only if you set the `SystemDisk.Category` parameter to `cloud_auto`.
	//
	// For more information, see [ESSD AutoPL disks](~~368372~~).
	SystemDiskBurstingEnabled *bool `json:"SystemDiskBurstingEnabled,omitempty" xml:"SystemDiskBurstingEnabled,omitempty"`
	// The weight of the instance type. The weight of an instance type indicates the capacity of a single instance of the specified instance type in the scaling group. A higher weight indicates that a smaller number of instances of the specified instance type are required to meet the expected capacity.
	SystemDiskCategories []*string `json:"SystemDiskCategories,omitempty" xml:"SystemDiskCategories,omitempty" type:"Repeated"`
	// The maximum outbound public bandwidth. Unit: Mbit/s.
	//
	// *   Valid values if you set the InternetChargeType parameter to PayByBandwidth: 0 to 100. If this parameter is not specified, 0 is used as the value of this parameter.
	// *   Valid values if you set the InternetChargeType parameter to PayByTraffic: 0 to 100. If this parameter is not specified, an error is reported.
	SystemDiskCategory *string `json:"SystemDiskCategory,omitempty" xml:"SystemDiskCategory,omitempty"`
	// The name of the key pair that is used to log on to the ECS instance.
	SystemDiskDescription *string `json:"SystemDiskDescription,omitempty" xml:"SystemDiskDescription,omitempty"`
	// auditing
	SystemDiskEncryptAlgorithm *string `json:"SystemDiskEncryptAlgorithm,omitempty" xml:"SystemDiskEncryptAlgorithm,omitempty"`
	// The IOPS metric that is preconfigured for the system disk.
	//
	// > IOPS measures the number of read and write operations that an EBS device can process per second.
	SystemDiskEncrypted *bool `json:"SystemDiskEncrypted,omitempty" xml:"SystemDiskEncrypted,omitempty"`
	// Indicates whether the burst feature is enabled for the system disk. Valid values:
	//
	// *   true
	// *   false
	//
	// > This parameter is available only if you set the SystemDisk.Category parameter to cloud_auto.
	SystemDiskKMSKeyId *string `json:"SystemDiskKMSKeyId,omitempty" xml:"SystemDiskKMSKeyId,omitempty"`
	// The instance type of the ECS instance.
	SystemDiskName *string `json:"SystemDiskName,omitempty" xml:"SystemDiskName,omitempty"`
	// The zone ID of the ECS instance. You can call the DescribeZones operation to query the most recent zone list.
	SystemDiskPerformanceLevel *string `json:"SystemDiskPerformanceLevel,omitempty" xml:"SystemDiskPerformanceLevel,omitempty"`
	// Queries scaling configurations.
	SystemDiskProvisionedIops *int64 `json:"SystemDiskProvisionedIops,omitempty" xml:"SystemDiskProvisionedIops,omitempty"`
	// The retention period of the preemptible instance. Unit: hours.
	SystemDiskSize *int32 `json:"SystemDiskSize,omitempty" xml:"SystemDiskSize,omitempty"`
	// The tag value of the instance. Up to 20 tags are supported.
	//
	// The tag value can be an empty string. The tag value must be 0 to 128 characters in length, and cannot start with `acs:`. It cannot contain `http://` or `https://`.
	Tags []*DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The number of randomly generated IPv6 addresses that are allocated to the elastic network interface (ENI).
	Tenancy *string `json:"Tenancy,omitempty" xml:"Tenancy,omitempty"`
	// The generation of the ECS instance.
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// Details of the ECS instance types.
	WeightedCapacities []*int32 `json:"WeightedCapacities,omitempty" xml:"WeightedCapacities,omitempty" type:"Repeated"`
	// The ID of the scaling configuration.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurations) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurations) GoString() string {
	return s.String()
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetPrivatePoolOptions(v *DescribeScalingConfigurationsResponseBodyScalingConfigurationsPrivatePoolOptions) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.PrivatePoolOptions = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetAffinity(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.Affinity = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetCpu(v int32) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.Cpu = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetCreationTime(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.CreationTime = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetCreditSpecification(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.CreditSpecification = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetDataDisks(v []*DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.DataDisks = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetDedicatedHostId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.DedicatedHostId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetDeploymentSetId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.DeploymentSetId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetHostName(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.HostName = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetHpcClusterId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.HpcClusterId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetImageFamily(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.ImageFamily = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetImageId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.ImageId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetImageName(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.ImageName = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetImageOwnerAlias(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.ImageOwnerAlias = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetInstanceDescription(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.InstanceDescription = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetInstanceGeneration(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.InstanceGeneration = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetInstanceName(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.InstanceName = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetInstancePatternInfos(v []*DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.InstancePatternInfos = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetInstanceType(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.InstanceType = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetInstanceTypes(v []*string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.InstanceTypes = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetInternetChargeType(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.InternetChargeType = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetInternetMaxBandwidthIn(v int32) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.InternetMaxBandwidthIn = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetInternetMaxBandwidthOut(v int32) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.InternetMaxBandwidthOut = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetIoOptimized(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.IoOptimized = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetIpv6AddressCount(v int32) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.Ipv6AddressCount = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetKeyPairName(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.KeyPairName = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetLifecycleState(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.LifecycleState = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetLoadBalancerWeight(v int32) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.LoadBalancerWeight = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetMemory(v int32) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.Memory = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetPasswordInherit(v bool) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.PasswordInherit = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetRamRoleName(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.RamRoleName = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetResourceGroupId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetScalingConfigurationId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.ScalingConfigurationId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetScalingConfigurationName(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.ScalingConfigurationName = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetScalingGroupId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSchedulerOptions(v *DescribeScalingConfigurationsResponseBodyScalingConfigurationsSchedulerOptions) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SchedulerOptions = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSecurityEnhancementStrategy(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SecurityEnhancementStrategy = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSecurityGroupId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SecurityGroupId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSecurityGroupIds(v []*string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SecurityGroupIds = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSpotDuration(v int32) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SpotDuration = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSpotInterruptionBehavior(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SpotInterruptionBehavior = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSpotPriceLimits(v []*DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SpotPriceLimits = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSpotStrategy(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SpotStrategy = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskAutoSnapshotPolicyId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskAutoSnapshotPolicyId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskBurstingEnabled(v bool) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskBurstingEnabled = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskCategories(v []*string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskCategories = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskCategory(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskCategory = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskDescription(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskDescription = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskEncryptAlgorithm(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskEncryptAlgorithm = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskEncrypted(v bool) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskEncrypted = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskKMSKeyId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskKMSKeyId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskName(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskName = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskPerformanceLevel(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskPerformanceLevel = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskProvisionedIops(v int64) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskProvisionedIops = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetSystemDiskSize(v int32) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.SystemDiskSize = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetTags(v []*DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.Tags = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetTenancy(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.Tenancy = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetUserData(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.UserData = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetWeightedCapacities(v []*int32) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.WeightedCapacities = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurations) SetZoneId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurations {
	s.ZoneId = &v
	return s
}

type DescribeScalingConfigurationsResponseBodyScalingConfigurationsPrivatePoolOptions struct {
	Id            *string `json:"Id,omitempty" xml:"Id,omitempty"`
	MatchCriteria *string `json:"MatchCriteria,omitempty" xml:"MatchCriteria,omitempty"`
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurationsPrivatePoolOptions) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurationsPrivatePoolOptions) GoString() string {
	return s.String()
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsPrivatePoolOptions) SetId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsPrivatePoolOptions {
	s.Id = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsPrivatePoolOptions) SetMatchCriteria(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsPrivatePoolOptions {
	s.MatchCriteria = &v
	return s
}

type DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks struct {
	// Indicates whether the data disk is released when the instance to which the data disk is attached is released. Valid values:
	//
	// *   true: The data disk is released when the instance is released.
	// *   false: The data disk is retained when the instance is released.
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// The tag key of the instance. Up to 20 tags are supported.
	//
	// The tag key cannot be an empty string. The tag key must be 0 to 128 characters in length, and cannot start with `acs:` or `aliyun`. The tag key cannot contain `http://` or `https://`.
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// Indicates whether the burst feature is enabled for the data disk. Valid values:
	//
	// *   true
	// *   false
	//
	// > This parameter is available only if you set the `DataDisk.Category` parameter to `cloud_auto`.
	//
	// For more information, see [ESSD AutoPL disks](~~368372~~).
	Categories []*string `json:"Categories,omitempty" xml:"Categories,omitempty" type:"Repeated"`
	// Indicates whether the data disk is encrypted. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The categories of the data disks. The values are sorted based on their priorities. The first value has the highest priority. If Auto Scaling cannot create instances by using the disk category of the highest priority, Auto Scaling creates instances by using the disk category of the next highest priority. Valid values:
	//
	// *   cloud: basic disk. The DeleteWithInstance attribute of a basic disk that is created together with the instance is set to true.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   cloud_essd: ESSD.
	DeleteWithInstance *bool `json:"DeleteWithInstance,omitempty" xml:"DeleteWithInstance,omitempty"`
	// The size of the data disk. Unit: GiB.
	//
	// *   Valid values if you set the Category parameter to cloud: 5 to 2000.
	// *   Valid values if you set the Category parameter to cloud_efficiency: 20 to 32768.
	// *   Valid values if you set the Category parameter to cloud_ssd: 20 to 32768.
	// *   Valid values if you set the Category parameter to cloud_essd: 20 to 32768.
	// *   Valid values if you set the Category parameter to ephemeral_ssd: 5 to 800.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the automatic snapshot policy that is applied to the data disk.
	Device *string `json:"Device,omitempty" xml:"Device,omitempty"`
	// The ID of the Key Management Service (KMS) key that is used to encrypt the data disk.
	DiskName *string `json:"DiskName,omitempty" xml:"DiskName,omitempty"`
	// The input/output operations per second (IOPS) metric that is preconfigured for the data disk.
	//
	// > IOPS measures the number of read and write operations that an Elastic Block Storage (EBS) device can process per second.
	Encrypted *string `json:"Encrypted,omitempty" xml:"Encrypted,omitempty"`
	// The categories of the data disks. The values are sorted based on their priorities. The first value has the highest priority. If Auto Scaling cannot create instances by using the disk category of the highest priority, Auto Scaling creates instances by using the disk category of the next highest priority. Valid values:
	//
	// *   cloud: basic disk. The DeleteWithInstance attribute of a basic disk that is created together with the instance is set to true.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   cloud_essd: ESSD.
	KMSKeyId *string `json:"KMSKeyId,omitempty" xml:"KMSKeyId,omitempty"`
	// The mount target of the data disk.
	PerformanceLevel *string `json:"PerformanceLevel,omitempty" xml:"PerformanceLevel,omitempty"`
	// Details of the tags.
	ProvisionedIops *int64 `json:"ProvisionedIops,omitempty" xml:"ProvisionedIops,omitempty"`
	// The category of the data disk. Valid values:
	//
	// *   cloud: basic disk. The DeleteWithInstance attribute of a basic disk that is created together with the instance is set to true.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   ephemeral_ssd: local standard SSD.
	// *   cloud_essd: ESSD.
	// *   cloud_auto: ESSD AutoPL disk.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The name of the data disk.
	SnapshotId *string `json:"SnapshotId,omitempty" xml:"SnapshotId,omitempty"`
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) GoString() string {
	return s.String()
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetAutoSnapshotPolicyId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetBurstingEnabled(v bool) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.BurstingEnabled = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetCategories(v []*string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.Categories = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetCategory(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.Category = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetDeleteWithInstance(v bool) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.DeleteWithInstance = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetDescription(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.Description = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetDevice(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.Device = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetDiskName(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.DiskName = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetEncrypted(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.Encrypted = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetKMSKeyId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.KMSKeyId = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetPerformanceLevel(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.PerformanceLevel = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetProvisionedIops(v int64) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.ProvisionedIops = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetSize(v int32) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.Size = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks) SetSnapshotId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsDataDisks {
	s.SnapshotId = &v
	return s
}

type DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos struct {
	// Instance types that are excluded. You can use wildcard characters such as an asterisk (\*) to exclude a single instance type or an instance family. Example:
	//
	// *   ecs.c6.large: The ecs.c6.large instance type is excluded.
	// *   ecs.c6.\*: The c6 instance family is excluded.
	Architectures []*string `json:"Architectures,omitempty" xml:"Architectures,omitempty" type:"Repeated"`
	// The categories of the system disks. The values are sorted based on their priorities. The first value has the highest priority. If Auto Scaling cannot create instances by using the disk category that has the highest priority, Auto Scaling creates instances by using the disk category that has the next highest priority. Valid values:
	//
	// *   cloud: basic disk.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   cloud_essd: ESSD.
	BurstablePerformance *string `json:"BurstablePerformance,omitempty" xml:"BurstablePerformance,omitempty"`
	// The architecture type to which the instance type belongs. Valid values:
	//
	// *   X86: x86 architecture.
	// *   Heterogeneous: heterogeneous architecture, such as GPUs and FPGAs.
	// *   BareMetal: ECS Bare Metal Instance architecture.
	// *   Arm: ARM architecture.
	// *   SuperComputeCluster: Super Computing Cluster architecture.
	Cores *int32 `json:"Cores,omitempty" xml:"Cores,omitempty"`
	// The categories of the system disks. The values are sorted based on their priorities. The first value has the highest priority. If Auto Scaling cannot create instances by using the disk category of the highest priority, Auto Scaling creates instances by using the disk category of the next highest priority. Valid values:
	//
	// *   cloud: basic disk.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   cloud_essd: ESSD.
	ExcludedInstanceTypes []*string `json:"ExcludedInstanceTypes,omitempty" xml:"ExcludedInstanceTypes,omitempty" type:"Repeated"`
	// Indicates whether burstable instance types are included. Valid values:
	//
	// *   Exclude: Burstable instance types are not included.
	// *   Include: Burstable instance types are included.
	// *   Required: Only burstable instance types are included.
	InstanceFamilyLevel *string `json:"InstanceFamilyLevel,omitempty" xml:"InstanceFamilyLevel,omitempty"`
	// The level of the instance family.
	//
	// *   EntryLevel: shared instance type. Instances of this level are the most cost-effective but may not provide stable computing performance in a consistent manner. Instances of this level are suitable for business scenarios in which the CPU utilization is low. For more information, see [Shared instance families](~~108489~~).
	// *   EnterpriseLevel: Instances of this level provide stable performance and dedicated resources, and are suitable for business scenarios that require high stability. For more information, see [Instance family](~~25378~~).
	// *   CreditEntryLevel: This value is valid only for burstable instances. CPU credits are used to ensure computing performance. Instances of this level are suitable for scenarios in which the CPU utilization is low but may fluctuate in specific cases. For more information, see [What are burstable instances?](~~59977~~)
	MaxPrice *float32 `json:"MaxPrice,omitempty" xml:"MaxPrice,omitempty"`
	// The architecture type to which the instance type belongs. Valid values:
	//
	// *   X86: x86 architecture.
	// *   Heterogeneous: heterogeneous architecture, such as GPUs and FPGAs.
	// *   BareMetal: ECS Bare Metal Instance architecture.
	// *   Arm: ARM architecture.
	// *   SuperComputeCluster: Super Computing Cluster architecture.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos) GoString() string {
	return s.String()
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos) SetArchitectures(v []*string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos {
	s.Architectures = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos) SetBurstablePerformance(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos {
	s.BurstablePerformance = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos) SetCores(v int32) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos {
	s.Cores = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos) SetExcludedInstanceTypes(v []*string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos {
	s.ExcludedInstanceTypes = v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos) SetInstanceFamilyLevel(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos {
	s.InstanceFamilyLevel = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos) SetMaxPrice(v float32) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos {
	s.MaxPrice = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos) SetMemory(v float32) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsInstancePatternInfos {
	s.Memory = &v
	return s
}

type DescribeScalingConfigurationsResponseBodyScalingConfigurationsSchedulerOptions struct {
	// The algorithm that is used to encrypt the system disk. Valid values:
	//
	// *   AES-256
	// *   SM4-128
	ManagedPrivateSpaceId *string `json:"ManagedPrivateSpaceId,omitempty" xml:"ManagedPrivateSpaceId,omitempty"`
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurationsSchedulerOptions) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurationsSchedulerOptions) GoString() string {
	return s.String()
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsSchedulerOptions) SetManagedPrivateSpaceId(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsSchedulerOptions {
	s.ManagedPrivateSpaceId = &v
	return s
}

type DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits struct {
	// Details of the intelligent configuration settings, which determines the available instance types.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The maximum hourly price for pay-as-you-go instances or preemptible instances.
	PriceLimit *float32 `json:"PriceLimit,omitempty" xml:"PriceLimit,omitempty"`
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits) GoString() string {
	return s.String()
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits) SetInstanceType(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits {
	s.InstanceType = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits) SetPriceLimit(v float32) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsSpotPriceLimits {
	s.PriceLimit = &v
	return s
}

type DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags struct {
	// Details of the preemptible instances.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The instance type of the preemptible instance.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags) GoString() string {
	return s.String()
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags) SetKey(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags {
	s.Key = &v
	return s
}

func (s *DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags) SetValue(v string) *DescribeScalingConfigurationsResponseBodyScalingConfigurationsTags {
	s.Value = &v
	return s
}

type DescribeScalingConfigurationsResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeScalingConfigurationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeScalingConfigurationsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingConfigurationsResponse) GoString() string {
	return s.String()
}

func (s *DescribeScalingConfigurationsResponse) SetHeaders(v map[string]*string) *DescribeScalingConfigurationsResponse {
	s.Headers = v
	return s
}

func (s *DescribeScalingConfigurationsResponse) SetStatusCode(v int32) *DescribeScalingConfigurationsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeScalingConfigurationsResponse) SetBody(v *DescribeScalingConfigurationsResponseBody) *DescribeScalingConfigurationsResponse {
	s.Body = v
	return s
}

type DescribeScalingGroupsRequest struct {
	// The type of instances that are managed by the scaling group. Valid values:
	//
	// *   ECS: ECS instances
	// *   ECI: elastic container instances
	//
	// Default value: ECS.
	GroupType    *string `json:"GroupType,omitempty" xml:"GroupType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Pages start from page 1.
	//
	// Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: 50.
	//
	// Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The IDs of the scaling groups that you want to query.
	//
	// The IDs of inactive scaling groups are not displayed in the query results, and no error is reported.
	ScalingGroupIds []*string `json:"ScalingGroupIds,omitempty" xml:"ScalingGroupIds,omitempty" type:"Repeated"`
	// The name of the scaling group.
	ScalingGroupName *string `json:"ScalingGroupName,omitempty" xml:"ScalingGroupName,omitempty"`
	// The names of the scaling groups that you want to query.
	//
	// The names of inactive scaling groups are not displayed in the query results, and no error is reported.
	ScalingGroupNames []*string `json:"ScalingGroupNames,omitempty" xml:"ScalingGroupNames,omitempty" type:"Repeated"`
}

func (s DescribeScalingGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingGroupsRequest) GoString() string {
	return s.String()
}

func (s *DescribeScalingGroupsRequest) SetGroupType(v string) *DescribeScalingGroupsRequest {
	s.GroupType = &v
	return s
}

func (s *DescribeScalingGroupsRequest) SetOwnerAccount(v string) *DescribeScalingGroupsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeScalingGroupsRequest) SetOwnerId(v int64) *DescribeScalingGroupsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeScalingGroupsRequest) SetPageNumber(v int32) *DescribeScalingGroupsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeScalingGroupsRequest) SetPageSize(v int32) *DescribeScalingGroupsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeScalingGroupsRequest) SetRegionId(v string) *DescribeScalingGroupsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeScalingGroupsRequest) SetResourceGroupId(v string) *DescribeScalingGroupsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeScalingGroupsRequest) SetResourceOwnerAccount(v string) *DescribeScalingGroupsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeScalingGroupsRequest) SetResourceOwnerId(v int64) *DescribeScalingGroupsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeScalingGroupsRequest) SetScalingGroupIds(v []*string) *DescribeScalingGroupsRequest {
	s.ScalingGroupIds = v
	return s
}

func (s *DescribeScalingGroupsRequest) SetScalingGroupName(v string) *DescribeScalingGroupsRequest {
	s.ScalingGroupName = &v
	return s
}

func (s *DescribeScalingGroupsRequest) SetScalingGroupNames(v []*string) *DescribeScalingGroupsRequest {
	s.ScalingGroupNames = v
	return s
}

type DescribeScalingGroupsResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Information about the scaling groups.
	ScalingGroups []*DescribeScalingGroupsResponseBodyScalingGroups `json:"ScalingGroups,omitempty" xml:"ScalingGroups,omitempty" type:"Repeated"`
	// The total number of scaling groups.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeScalingGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeScalingGroupsResponseBody) SetPageNumber(v int32) *DescribeScalingGroupsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeScalingGroupsResponseBody) SetPageSize(v int32) *DescribeScalingGroupsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeScalingGroupsResponseBody) SetRequestId(v string) *DescribeScalingGroupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBody) SetScalingGroups(v []*DescribeScalingGroupsResponseBodyScalingGroups) *DescribeScalingGroupsResponseBody {
	s.ScalingGroups = v
	return s
}

func (s *DescribeScalingGroupsResponseBody) SetTotalCount(v int32) *DescribeScalingGroupsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeScalingGroupsResponseBodyScalingGroups struct {
	// The number of ECS instances that are added to the scaling group and provide services as expected.
	ActiveCapacity *int32 `json:"ActiveCapacity,omitempty" xml:"ActiveCapacity,omitempty"`
	// The ID of the active scaling configuration in the scaling group.
	ActiveScalingConfigurationId *string `json:"ActiveScalingConfigurationId,omitempty" xml:"ActiveScalingConfigurationId,omitempty"`
	// Details of the ALB server groups.
	AlbServerGroups []*DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups `json:"AlbServerGroups,omitempty" xml:"AlbServerGroups,omitempty" type:"Repeated"`
	// The allocation policy. Auto Scaling selects instance types based on the allocation policy to create the required number of instances. The policy can be applied to pay-as-you-go instances and preemptible instances at the same time. This parameter takes effect only when `MultiAZPolicy` parameter is set to `COMPOSABLE`. Valid values:
	//
	// *   priority: Auto Scaling selects instance types based on the specified order to create the required number of instances.
	// *   lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of instances.
	AllocationStrategy *string `json:"AllocationStrategy,omitempty" xml:"AllocationStrategy,omitempty"`
	// Indicates whether instances in the scaling group are evenly distributed across zones. This parameter takes effect only when `MultiAZPolicy` is set to `COMPOSABLE`. Valid values:
	//
	// *   true: Instances in the scaling group are evenly distributed across zones.
	// *   false: Instances in the scaling group are unevenly distributed across zones.
	AzBalance *bool `json:"AzBalance,omitempty" xml:"AzBalance,omitempty"`
	// Indicates whether pay-as-you-go instances are automatically created to meet the requirements on the number of ECS instances when the expected capacity of preemptible instances cannot be provided due to reasons such as costs and insufficient resources. This parameter takes effect only when MultiAZPolicy is set to COST_OPTIMIZED. Valid values:
	//
	// *   true
	// *   false
	CompensateWithOnDemand *bool `json:"CompensateWithOnDemand,omitempty" xml:"CompensateWithOnDemand,omitempty"`
	// The time when the scaling group was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// > This parameter is unavailable.
	CurrentHostName *string `json:"CurrentHostName,omitempty" xml:"CurrentHostName,omitempty"`
	// The ARN of the custom scaling policy (Function). This parameter takes effect only if you specify CustomPolicy as the first step of the instance removal policy.
	CustomPolicyARN *string `json:"CustomPolicyARN,omitempty" xml:"CustomPolicyARN,omitempty"`
	// The IDs of the ApsaraDB RDS instances that are associated with the scaling group.
	DBInstanceIds []*string `json:"DBInstanceIds,omitempty" xml:"DBInstanceIds,omitempty" type:"Repeated"`
	// The default cooldown time of the scaling group. During the default cooldown time, Auto Scaling executes only the scaling activities that are triggered by event-triggered tasks associated with [CloudMonitor](~~35170~~).
	DefaultCooldown *int32 `json:"DefaultCooldown,omitempty" xml:"DefaultCooldown,omitempty"`
	// The expected number of ECS instances in the scaling group. Auto Scaling automatically maintains the expected number of ECS instances that you specified.
	DesiredCapacity *int32 `json:"DesiredCapacity,omitempty" xml:"DesiredCapacity,omitempty"`
	// Indicates whether deletion protection is enabled for the scaling group. Valid values:
	//
	// *   true: Deletion protection is enabled for the scaling group. The scaling group cannot be deleted.
	// *   false: Deletion protection is disabled for the scaling group.
	GroupDeletionProtection *bool `json:"GroupDeletionProtection,omitempty" xml:"GroupDeletionProtection,omitempty"`
	// The type of instances that are managed by the scaling group.
	GroupType *string `json:"GroupType,omitempty" xml:"GroupType,omitempty"`
	// The health check mode of the scaling group. Valid values:
	//
	// *   NONE: Auto Scaling does not perform health checks on instances in the scaling group.
	// *   ECS: Auto Scaling performs health checks on ECS instances in the scaling group.
	HealthCheckType *string `json:"HealthCheckType,omitempty" xml:"HealthCheckType,omitempty"`
	InitCapacity    *int32  `json:"InitCapacity,omitempty" xml:"InitCapacity,omitempty"`
	// > This parameter is unavailable.
	IsElasticStrengthInAlarm *bool `json:"IsElasticStrengthInAlarm,omitempty" xml:"IsElasticStrengthInAlarm,omitempty"`
	// The ID of the launch template used by the scaling group.
	LaunchTemplateId *string `json:"LaunchTemplateId,omitempty" xml:"LaunchTemplateId,omitempty"`
	// Details of the instance types that are specified in the extended configurations of the launch template.
	LaunchTemplateOverrides []*DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides `json:"LaunchTemplateOverrides,omitempty" xml:"LaunchTemplateOverrides,omitempty" type:"Repeated"`
	// The version of the launch template used by the scaling group.
	LaunchTemplateVersion *string `json:"LaunchTemplateVersion,omitempty" xml:"LaunchTemplateVersion,omitempty"`
	// The status of the scaling group. Valid values:
	//
	// *   Active: The scaling group is active. Active scaling groups can receive requests to execute scaling rules and trigger scaling activities.
	// *   Inactive: The scaling group is inactive. Inactive scaling groups cannot receive requests to execute scaling rules.
	// *   Deleting: The scaling group is being deleted. Scaling groups that are being deleted cannot receive requests to execute scaling rules, and the parameter settings of the scaling groups cannot be modified.
	LifecycleState *string `json:"LifecycleState,omitempty" xml:"LifecycleState,omitempty"`
	// The IDs of the CLB instances that are associated with the scaling group.
	LoadBalancerIds []*string `json:"LoadBalancerIds,omitempty" xml:"LoadBalancerIds,omitempty" type:"Repeated"`
	// The maximum life span of the instance in the scaling group. Unit: seconds.
	//
	// Valid values: 86400 to Integer.maxValue. You can also set this parameter to 0.`` A value of 0 indicates that the instance has unlimited life span in the scaling group.
	//
	// Default value: null.
	//
	// > You cannot specify this parameter for scaling groups that manage elastic container instances or scaling groups whose ScalingPolicy is set to recycle.
	MaxInstanceLifetime *int32 `json:"MaxInstanceLifetime,omitempty" xml:"MaxInstanceLifetime,omitempty"`
	// The maximum number of ECS instances in the scaling group.
	MaxSize *int32 `json:"MaxSize,omitempty" xml:"MaxSize,omitempty"`
	// The minimum number of ECS instances in the scaling group.
	MinSize *int32 `json:"MinSize,omitempty" xml:"MinSize,omitempty"`
	// The time when the scaling group was modified.
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The ID of the CloudMonitor application group that is associated with the scaling group.
	MonitorGroupId *string `json:"MonitorGroupId,omitempty" xml:"MonitorGroupId,omitempty"`
	// The scaling policy for the multi-zone scaling group that contains ECS instances. Valid values:
	//
	// *   PRIORITY: ECS instances are created based on the VSwitchIds.N parameter. If Auto Scaling fails to create ECS instances in the zone where the vSwitch that has the highest priority resides, Auto Scaling creates ECS instances in the zone where the vSwitch that has the next highest priority resides.
	//
	// *   COST_OPTIMIZED: ECS instances are created based on the unit price of their vCPUs. Auto Scaling preferentially creates ECS instances that have vCPUs provided at the lowest price. Auto Scaling preferentially creates preemptible instances when preemptible instance types are specified in the scaling configuration. You can use the CompensateWithOnDemand parameter to specify whether to automatically create pay-as-you-go instances when preemptible instances cannot be created due to insufficient resources.
	//
	//     **
	//
	//     **Note**The COST_OPTIMIZED setting takes effect only when multiple instance types are specified or at least one instance type is specified for preemptible instances.
	//
	// *   BALANCE: ECS instances are evenly distributed across zones that are specified in the scaling group. If ECS instances are unevenly distributed across the specified zones due to insufficient resources, you can call the RebalanceInstance operation to evenly distribute the instances across the zones.
	MultiAZPolicy *string `json:"MultiAZPolicy,omitempty" xml:"MultiAZPolicy,omitempty"`
	// The minimum number of pay-as-you-go instances that must be included in the scaling group. Valid values: 0 to 1000. If the number of pay-as-you-go instances is less than the value of this parameter, Auto Scaling preferentially creates pay-as-you-go instances.
	OnDemandBaseCapacity *int32 `json:"OnDemandBaseCapacity,omitempty" xml:"OnDemandBaseCapacity,omitempty"`
	// The expected percentage of pay-as-you-go instances in the excess instances when the minimum number of pay-as-you-go instances reaches the requirement. Valid values: 0 to 100.
	OnDemandPercentageAboveBaseCapacity *int32 `json:"OnDemandPercentageAboveBaseCapacity,omitempty" xml:"OnDemandPercentageAboveBaseCapacity,omitempty"`
	// The number of ECS instances that are being added to the scaling group and still being configured.
	PendingCapacity *int32 `json:"PendingCapacity,omitempty" xml:"PendingCapacity,omitempty"`
	// The number of ECS instances that are in the Pending Add state in the scaling group.
	PendingWaitCapacity *int32 `json:"PendingWaitCapacity,omitempty" xml:"PendingWaitCapacity,omitempty"`
	// The number of ECS instances that are in the Protected state in the scaling group.
	ProtectedCapacity *int32 `json:"ProtectedCapacity,omitempty" xml:"ProtectedCapacity,omitempty"`
	// The region ID of the scaling group.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Details of the policies used to remove ECS instances from the scaling group. Valid values:
	//
	// *   OldestInstance: Auto Scaling removes ECS instances that are added to the scaling group at the earliest point in time.
	// *   NewestInstance: Auto Scaling removes ECS instances that are most recently added to the scaling group.
	// *   OldestScalingConfiguration: Auto Scaling removes ECS instances that are created based on the earliest scaling configuration.
	RemovalPolicies []*string `json:"RemovalPolicies,omitempty" xml:"RemovalPolicies,omitempty" type:"Repeated"`
	// The number of ECS instances that are being removed from the scaling group.
	RemovingCapacity *int32 `json:"RemovingCapacity,omitempty" xml:"RemovingCapacity,omitempty"`
	// The number of ECS instances that are in the Pending Remove state in the scaling group.
	RemovingWaitCapacity *int32  `json:"RemovingWaitCapacity,omitempty" xml:"RemovingWaitCapacity,omitempty"`
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The name of the scaling group.
	ScalingGroupName *string `json:"ScalingGroupName,omitempty" xml:"ScalingGroupName,omitempty"`
	// The reclaim mode of the scaling group. Valid values:
	//
	// *   recycle: economical mode.
	// *   release: release mode.
	ScalingPolicy *string `json:"ScalingPolicy,omitempty" xml:"ScalingPolicy,omitempty"`
	// The allocation policy of preemptible instances. You can use this parameter to individually specify the allocation policy of preemptible instances. This parameter takes effect only when `MultiAZPolicy` is set to `COMPOSABLE`. Valid values:
	//
	// *   priority: Auto Scaling selects instance types based on the specified order to create the required number of preemptible instances.
	// *   lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of preemptible instances.
	//
	// Default value: priority.
	SpotAllocationStrategy *string `json:"SpotAllocationStrategy,omitempty" xml:"SpotAllocationStrategy,omitempty"`
	// The number of instance types that you specified. Auto Scaling creates preemptible instances of multiple instance types that are provided at the lowest price. Valid values: 0 to 10.
	SpotInstancePools *int32 `json:"SpotInstancePools,omitempty" xml:"SpotInstancePools,omitempty"`
	// Indicates whether preemptible instances can be supplemented. If this parameter is set to true, Auto Scaling creates an instance to replace a preemptible instance when Auto Scaling receives the system message that the preemptible instance is to be reclaimed.
	SpotInstanceRemedy *bool `json:"SpotInstanceRemedy,omitempty" xml:"SpotInstanceRemedy,omitempty"`
	// The number of instances that are in the Standby state in the scaling group.
	StandbyCapacity *int32 `json:"StandbyCapacity,omitempty" xml:"StandbyCapacity,omitempty"`
	// The number of instances that are in economical mode in the scaling group.
	StoppedCapacity *int32 `json:"StoppedCapacity,omitempty" xml:"StoppedCapacity,omitempty"`
	// The process that is suspended. If no process is suspended, null is returned. Valid values:
	//
	// *   ScaleIn
	// *   ScaleOut
	// *   HealthCheck
	// *   AlarmNotification
	// *   ScheduledAction
	SuspendedProcesses []*string `json:"SuspendedProcesses,omitempty" xml:"SuspendedProcesses,omitempty" type:"Repeated"`
	// Indicates whether Auto Scaling stops executing scaling activities in the scaling group. Valid values:
	//
	// *   true: Auto Scaling stops executing scaling activities in the scaling group if the scaling activities failed for more than seven consecutive days. You must modify the scaling group or scaling configuration to resume the execution of scaling activities.
	// *   false: Auto Scaling does not stop executing scaling activities in the scaling group.
	SystemSuspended *bool `json:"SystemSuspended,omitempty" xml:"SystemSuspended,omitempty"`
	// The total weighted capacity of all ECS instances in the scaling group if the WeightedCapacity parameter is specified. In other cases, this parameter specifies the total number of ECS instances in the scaling group.
	TotalCapacity *int32 `json:"TotalCapacity,omitempty" xml:"TotalCapacity,omitempty"`
	// The total number of ECS instances in the scaling group.
	TotalInstanceCount *int32 `json:"TotalInstanceCount,omitempty" xml:"TotalInstanceCount,omitempty"`
	// The vServer groups.
	VServerGroups []*DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups `json:"VServerGroups,omitempty" xml:"VServerGroups,omitempty" type:"Repeated"`
	// The ID of the vSwitch that is associated with the scaling group.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The IDs of the vSwitches that are associated with the scaling group. If you specify the VSwitchIds parameter, the VSwitchId parameter is ignored.
	VSwitchIds []*string `json:"VSwitchIds,omitempty" xml:"VSwitchIds,omitempty" type:"Repeated"`
	// The ID of the virtual private cloud (VPC) in which the scaling group resides.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeScalingGroupsResponseBodyScalingGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingGroupsResponseBodyScalingGroups) GoString() string {
	return s.String()
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetActiveCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.ActiveCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetActiveScalingConfigurationId(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.ActiveScalingConfigurationId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetAlbServerGroups(v []*DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.AlbServerGroups = v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetAllocationStrategy(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.AllocationStrategy = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetAzBalance(v bool) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.AzBalance = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetCompensateWithOnDemand(v bool) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.CompensateWithOnDemand = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetCreationTime(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.CreationTime = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetCurrentHostName(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.CurrentHostName = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetCustomPolicyARN(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.CustomPolicyARN = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetDBInstanceIds(v []*string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.DBInstanceIds = v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetDefaultCooldown(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.DefaultCooldown = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetDesiredCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.DesiredCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetGroupDeletionProtection(v bool) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.GroupDeletionProtection = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetGroupType(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.GroupType = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetHealthCheckType(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.HealthCheckType = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetInitCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.InitCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetIsElasticStrengthInAlarm(v bool) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.IsElasticStrengthInAlarm = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetLaunchTemplateId(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.LaunchTemplateId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetLaunchTemplateOverrides(v []*DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.LaunchTemplateOverrides = v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetLaunchTemplateVersion(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.LaunchTemplateVersion = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetLifecycleState(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.LifecycleState = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetLoadBalancerIds(v []*string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.LoadBalancerIds = v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetMaxInstanceLifetime(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.MaxInstanceLifetime = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetMaxSize(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.MaxSize = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetMinSize(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.MinSize = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetModificationTime(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.ModificationTime = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetMonitorGroupId(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.MonitorGroupId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetMultiAZPolicy(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.MultiAZPolicy = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetOnDemandBaseCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.OnDemandBaseCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetOnDemandPercentageAboveBaseCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.OnDemandPercentageAboveBaseCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetPendingCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.PendingCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetPendingWaitCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.PendingWaitCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetProtectedCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.ProtectedCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetRegionId(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.RegionId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetRemovalPolicies(v []*string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.RemovalPolicies = v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetRemovingCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.RemovingCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetRemovingWaitCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.RemovingWaitCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetResourceGroupId(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetScalingGroupId(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetScalingGroupName(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.ScalingGroupName = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetScalingPolicy(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.ScalingPolicy = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetSpotAllocationStrategy(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.SpotAllocationStrategy = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetSpotInstancePools(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.SpotInstancePools = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetSpotInstanceRemedy(v bool) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.SpotInstanceRemedy = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetStandbyCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.StandbyCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetStoppedCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.StoppedCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetSuspendedProcesses(v []*string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.SuspendedProcesses = v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetSystemSuspended(v bool) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.SystemSuspended = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetTotalCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.TotalCapacity = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetTotalInstanceCount(v int32) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.TotalInstanceCount = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetVServerGroups(v []*DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.VServerGroups = v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetVSwitchId(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.VSwitchId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetVSwitchIds(v []*string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.VSwitchIds = v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroups) SetVpcId(v string) *DescribeScalingGroupsResponseBodyScalingGroups {
	s.VpcId = &v
	return s
}

type DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups struct {
	// The ID of the ALB server group.
	AlbServerGroupId *string `json:"AlbServerGroupId,omitempty" xml:"AlbServerGroupId,omitempty"`
	// The port number used by the ECS instance after the instance is added to the ALB server group.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The weight of the ECS instance as a backend server after the instance is added to the ALB server group.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups) GoString() string {
	return s.String()
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups) SetAlbServerGroupId(v string) *DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups {
	s.AlbServerGroupId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups) SetPort(v int32) *DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups {
	s.Port = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups) SetWeight(v int32) *DescribeScalingGroupsResponseBodyScalingGroupsAlbServerGroups {
	s.Weight = &v
	return s
}

type DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides struct {
	// The instance type. The instance type that is specified by using the InstanceType parameter overwrites the instance type specified in the launch template.
	InstanceType   *string  `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	SpotPriceLimit *float32 `json:"SpotPriceLimit,omitempty" xml:"SpotPriceLimit,omitempty"`
	// The weight of the instance type. The value of this parameter indicates the capacity of a single instance of this instance type in the scaling group. A higher weight specifies that a smaller number of instances of the specified instance type are required to meet the expected capacity.
	WeightedCapacity *int32 `json:"WeightedCapacity,omitempty" xml:"WeightedCapacity,omitempty"`
}

func (s DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides) GoString() string {
	return s.String()
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides) SetInstanceType(v string) *DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides {
	s.InstanceType = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides) SetSpotPriceLimit(v float32) *DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides {
	s.SpotPriceLimit = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides) SetWeightedCapacity(v int32) *DescribeScalingGroupsResponseBodyScalingGroupsLaunchTemplateOverrides {
	s.WeightedCapacity = &v
	return s
}

type DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups struct {
	// The ID of the CLB instance to which the vServer group belongs.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// Details of the vServer group attributes.
	VServerGroupAttributes []*DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes `json:"VServerGroupAttributes,omitempty" xml:"VServerGroupAttributes,omitempty" type:"Repeated"`
}

func (s DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups) GoString() string {
	return s.String()
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups) SetLoadBalancerId(v string) *DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups) SetVServerGroupAttributes(v []*DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes) *DescribeScalingGroupsResponseBodyScalingGroupsVServerGroups {
	s.VServerGroupAttributes = v
	return s
}

type DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes struct {
	// The port number used by the CLB instance to provide external services.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The ID of the vServer group.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	// The weight of the vServer group.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes) GoString() string {
	return s.String()
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes) SetPort(v int32) *DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes {
	s.Port = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes) SetVServerGroupId(v string) *DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes {
	s.VServerGroupId = &v
	return s
}

func (s *DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes) SetWeight(v int32) *DescribeScalingGroupsResponseBodyScalingGroupsVServerGroupsVServerGroupAttributes {
	s.Weight = &v
	return s
}

type DescribeScalingGroupsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeScalingGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeScalingGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingGroupsResponse) GoString() string {
	return s.String()
}

func (s *DescribeScalingGroupsResponse) SetHeaders(v map[string]*string) *DescribeScalingGroupsResponse {
	s.Headers = v
	return s
}

func (s *DescribeScalingGroupsResponse) SetStatusCode(v int32) *DescribeScalingGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeScalingGroupsResponse) SetBody(v *DescribeScalingGroupsResponseBody) *DescribeScalingGroupsResponse {
	s.Body = v
	return s
}

type DescribeScalingInstancesRequest struct {
	// The method that is used to create the ECS instance. Valid values:
	//
	// *   AutoCreated: The ECS instance is automatically created by Auto Scaling based on the instance configuration source of the scaling group.
	// *   Attached: The ECS instance is manually added to the scaling group.
	CreationType *string `json:"CreationType,omitempty" xml:"CreationType,omitempty"`
	// The health status of the ECS instance in the scaling group. If ECS instances do not run as expected, Auto Scaling considers the ECS instances unhealthy. Valid values:
	//
	// *   Healthy
	// *   Unhealthy
	//
	// Auto Scaling automatically removes unhealthy ECS instances from the scaling group and then releases the automatically created instances among the unhealthy instances.
	//
	// Unhealthy ECS instances that are manually added to the scaling group are released based on the management mode of the instance lifecycles. If the lifecycles of the ECS instances are not managed by the scaling group, Auto Scaling removes the instances from the scaling group but does not release the instances. If the lifecycles of the ECS instances are managed by the scaling group, Auto Scaling removes the instances from the scaling group and releases the instances.
	//
	// >  Make sure that you have sufficient balance within your Alibaba Cloud account. If you have overdue payments within your Alibaba Cloud account, pay-as-you-go and preemptible instances are stopped or released. For information about how the states of ECS instances change when you have overdue payments within your Alibaba Cloud account, see [Overdue payments](~~170589~~).
	HealthStatus *string `json:"HealthStatus,omitempty" xml:"HealthStatus,omitempty"`
	// The IDs of the ECS instances.
	//
	// Invalid instance IDs are not displayed in the query result, and no error is reported.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The lifecycle state of the ECS instance in the scaling group. Valid values:
	//
	// *   InService: The ECS instance is added to the scaling group and provides services as expected.
	// *   Pending: The ECS instance is being added to the scaling group. During this process, Auto Scaling adds the ECS instance to the backend server groups of the associated CLB instance and adds the private IP address of the ECS instance to the IP address whitelist of the associated ApsaraDB RDS instance.
	// *   Pending:Wait: The ECS instance is pending to be added to the scaling group. If a lifecycle hook that applies to scale-out activities is created for the scaling group, the ECS instance enters the Pending:Wait state. The ECS instance is added to the scaling group only after the lifecycle hook times out.
	// *   Protected: The ECS instance is being protected. The ECS instance can provide services as expected. However, Auto Scaling does not manage the lifecycle of the ECS instance. You must manually manage the lifecycle of the ECS instance.
	// *   Standby: The ECS instance is on standby. The ECS instance is out of service and the weight of the ECS instance as a backend server is set to zero. Auto Scaling does not manage the lifecycle of the ECS instance. You must manually manage the lifecycle of the ECS instance.
	// *   Stopped: The ECS instance is stopped. The ECS instance is stopped and cannot provide services.
	// *   Removing: The ECS instance is being removed from the scaling group. During this process, Auto Scaling removes the ECS instance from the backend server groups of the associated CLB instance and removes the IP address of the ECS instance from the IP address whitelist of the associated ApsaraDB RDS instance.
	// *   Removing:Wait: The ECS instance is being removed from the scaling group and enters the Removing:Wait state. If a lifecycle hook that applies to scale-in activities is created for the scaling group, the ECS instance enters the Removing:Wait state. The ECS instance is removed from the scaling group only after the lifecycle hook times out.
	LifecycleState *string `json:"LifecycleState,omitempty" xml:"LifecycleState,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Pages start from page 1.
	//
	// Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: 100.
	//
	// Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the scaling activity.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
	// The ID of the associated scaling configuration.
	ScalingConfigurationId *string `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DescribeScalingInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingInstancesRequest) GoString() string {
	return s.String()
}

func (s *DescribeScalingInstancesRequest) SetCreationType(v string) *DescribeScalingInstancesRequest {
	s.CreationType = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetHealthStatus(v string) *DescribeScalingInstancesRequest {
	s.HealthStatus = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetInstanceIds(v []*string) *DescribeScalingInstancesRequest {
	s.InstanceIds = v
	return s
}

func (s *DescribeScalingInstancesRequest) SetLifecycleState(v string) *DescribeScalingInstancesRequest {
	s.LifecycleState = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetOwnerAccount(v string) *DescribeScalingInstancesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetOwnerId(v int64) *DescribeScalingInstancesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetPageNumber(v int32) *DescribeScalingInstancesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetPageSize(v int32) *DescribeScalingInstancesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetRegionId(v string) *DescribeScalingInstancesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetResourceOwnerAccount(v string) *DescribeScalingInstancesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetResourceOwnerId(v int64) *DescribeScalingInstancesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetScalingActivityId(v string) *DescribeScalingInstancesRequest {
	s.ScalingActivityId = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetScalingConfigurationId(v string) *DescribeScalingInstancesRequest {
	s.ScalingConfigurationId = &v
	return s
}

func (s *DescribeScalingInstancesRequest) SetScalingGroupId(v string) *DescribeScalingInstancesRequest {
	s.ScalingGroupId = &v
	return s
}

type DescribeScalingInstancesResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Details of the ECS instances.
	ScalingInstances []*DescribeScalingInstancesResponseBodyScalingInstances `json:"ScalingInstances,omitempty" xml:"ScalingInstances,omitempty" type:"Repeated"`
	// The total number of the ECS instances in the scaling group.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The total number of preemptible instances that run as expected in the scaling group.
	TotalSpotCount *int32 `json:"TotalSpotCount,omitempty" xml:"TotalSpotCount,omitempty"`
}

func (s DescribeScalingInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeScalingInstancesResponseBody) SetPageNumber(v int32) *DescribeScalingInstancesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeScalingInstancesResponseBody) SetPageSize(v int32) *DescribeScalingInstancesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeScalingInstancesResponseBody) SetRequestId(v string) *DescribeScalingInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeScalingInstancesResponseBody) SetScalingInstances(v []*DescribeScalingInstancesResponseBodyScalingInstances) *DescribeScalingInstancesResponseBody {
	s.ScalingInstances = v
	return s
}

func (s *DescribeScalingInstancesResponseBody) SetTotalCount(v int32) *DescribeScalingInstancesResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeScalingInstancesResponseBody) SetTotalSpotCount(v int32) *DescribeScalingInstancesResponseBody {
	s.TotalSpotCount = &v
	return s
}

type DescribeScalingInstancesResponseBodyScalingInstances struct {
	// The time when the ECS instance was added to the scaling group. The value is accurate to seconds.
	CreatedTime *string `json:"CreatedTime,omitempty" xml:"CreatedTime,omitempty"`
	// The time when the ECS instance was added to the scaling group. The value is accurate to minutes.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The method that is used to create the ECS instance. Valid values:
	//
	// *   AutoCreated: The ECS instance is automatically created by Auto Scaling based on the instance configuration source of the scaling group.
	// *   Attached: The ECS instance is manually added to the scaling group.
	CreationType *string `json:"CreationType,omitempty" xml:"CreationType,omitempty"`
	// Indicates whether the lifecycles of the ECS instances that are manually added to the scaling group are managed by the scaling group. If the scaling group manages the lifecycles of the ECS instances that are manually added, Auto Scaling releases the ECS instances after Auto Scaling removes the ECS instances from the scaling group. The release rule does not apply to ECS instances that are manually removed from the scaling group. Valid values:
	//
	// *   true
	// *   false
	Entrusted *bool `json:"Entrusted,omitempty" xml:"Entrusted,omitempty"`
	// The health status of the ECS instance in the scaling group. If the ECS instance does not run as expected, Auto Scaling considers the ECS instance unhealthy. Valid values:
	//
	// *   Healthy
	// *   Unhealthy
	//
	// Auto Scaling automatically removes unhealthy ECS instances from the scaling group and then releases the automatically created instances among the unhealthy instances.
	//
	// Unhealthy ECS instances that are manually added to the scaling group are released based on the management mode of the instance lifecycles. If the lifecycles of the ECS instances are not managed by the scaling group, Auto Scaling removes the instances from the scaling group but does not release the instances. If the lifecycles of the ECS instances are managed by the scaling group, Auto Scaling removes the instances from the scaling group and releases the instances.
	//
	// >  Make sure that you have sufficient balance within your Alibaba Cloud account. If you have overdue payments within your Alibaba Cloud account, pay-as-you-go and preemptible instances are stopped or released. For information about how the states of ECS instances change when you have overdue payments within your Alibaba Cloud account, see [Overdue payments](~~170589~~).
	HealthStatus *string `json:"HealthStatus,omitempty" xml:"HealthStatus,omitempty"`
	// The ID of the ECS instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the launch template.
	LaunchTemplateId *string `json:"LaunchTemplateId,omitempty" xml:"LaunchTemplateId,omitempty"`
	// The version number of the launch template.
	LaunchTemplateVersion *string `json:"LaunchTemplateVersion,omitempty" xml:"LaunchTemplateVersion,omitempty"`
	// The lifecycle state of the ECS instance in the scaling group. Valid values:
	//
	// *   InService: The ECS instance is added to the scaling group and provides services as expected.
	// *   Pending: The ECS instance is being added to the scaling group. During this process, Auto Scaling adds the ECS instance to the backend server groups of the associated CLB instance and adds the private IP address of the ECS instance to the IP address whitelist of the associated ApsaraDB RDS instance.
	// *   Pending:Wait: The ECS instance is pending to be added to the scaling group. If a lifecycle hook that applies to scale-out activities is created for the scaling group, the ECS instance enters the Pending:Wait state. The ECS instance is added to the scaling group only after the lifecycle hook times out.
	// *   Protected: The ECS instance is being protected. The ECS instance can provide services as expected. However, Auto Scaling does not manage the lifecycle of the ECS instance. You must manually manage the lifecycle of the ECS instance.
	// *   Standby: The ECS instance is on standby. The ECS instance is out of service and the weight of the ECS instance as a backend server is set to zero. Auto Scaling does not manage the lifecycle of the ECS instance. You must manually manage the lifecycle of the ECS instance.
	// *   Stopped: The ECS instance is stopped. The ECS instance is stopped and cannot provide services.
	// *   Removing: The ECS instance is being removed from the scaling group. During this process, Auto Scaling removes the ECS instance from the backend server groups of the associated CLB instance and removes the IP address of the ECS instance from the IP address whitelist of the associated ApsaraDB RDS instance.
	// *   Removing:Wait: The ECS instance is being removed from the scaling group and enters the Removing:Wait state. If a lifecycle hook that applies to scale-in activities is created for the scaling group, the ECS instance enters the Removing:Wait state. The ECS instance is removed from the scaling group only after the lifecycle hook times out.
	LifecycleState *string `json:"LifecycleState,omitempty" xml:"LifecycleState,omitempty"`
	// The weight of the ECS instance as a backend server.
	LoadBalancerWeight *int32 `json:"LoadBalancerWeight,omitempty" xml:"LoadBalancerWeight,omitempty"`
	// The ID of the scaling activity during which the ECS instance is added to the scaling group.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
	// The ID of the associated scaling configuration.
	ScalingConfigurationId *string `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
	// The ID of the scaling group to which the ECS instance belongs.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The bidding policy for the preemptible instance. Valid values:
	//
	// *   SpotWithPriceLimit: The instance is created as a preemptible instance with a user-defined maximum hourly price.
	// *   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.
	SpotStrategy *string `json:"SpotStrategy,omitempty" xml:"SpotStrategy,omitempty"`
	// The warmup state of the ECS instance. Valid values:
	//
	// *   NoNeedWarmup: The instance does not need to be warmed up.
	// *   WaitingForInstanceWarmup: The instance is being warmed up.
	// *   InstanceWarmupFinish: The instance is warmed up.
	WarmupState *string `json:"WarmupState,omitempty" xml:"WarmupState,omitempty"`
	// The weight of the instance type. The weight indicates the capacity of a single instance of the specified instance type in the scaling group. A higher weight indicates that a smaller number of instances of the specified instance type are required to meet the expected capacity requirement.
	WeightedCapacity *int32 `json:"WeightedCapacity,omitempty" xml:"WeightedCapacity,omitempty"`
	// The zone ID of the ECS instance.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeScalingInstancesResponseBodyScalingInstances) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingInstancesResponseBodyScalingInstances) GoString() string {
	return s.String()
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetCreatedTime(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.CreatedTime = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetCreationTime(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.CreationTime = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetCreationType(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.CreationType = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetEntrusted(v bool) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.Entrusted = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetHealthStatus(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.HealthStatus = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetInstanceId(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.InstanceId = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetLaunchTemplateId(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.LaunchTemplateId = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetLaunchTemplateVersion(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.LaunchTemplateVersion = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetLifecycleState(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.LifecycleState = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetLoadBalancerWeight(v int32) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.LoadBalancerWeight = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetScalingActivityId(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.ScalingActivityId = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetScalingConfigurationId(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.ScalingConfigurationId = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetScalingGroupId(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetSpotStrategy(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.SpotStrategy = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetWarmupState(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.WarmupState = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetWeightedCapacity(v int32) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.WeightedCapacity = &v
	return s
}

func (s *DescribeScalingInstancesResponseBodyScalingInstances) SetZoneId(v string) *DescribeScalingInstancesResponseBodyScalingInstances {
	s.ZoneId = &v
	return s
}

type DescribeScalingInstancesResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeScalingInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeScalingInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingInstancesResponse) GoString() string {
	return s.String()
}

func (s *DescribeScalingInstancesResponse) SetHeaders(v map[string]*string) *DescribeScalingInstancesResponse {
	s.Headers = v
	return s
}

func (s *DescribeScalingInstancesResponse) SetStatusCode(v int32) *DescribeScalingInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeScalingInstancesResponse) SetBody(v *DescribeScalingInstancesResponseBody) *DescribeScalingInstancesResponse {
	s.Body = v
	return s
}

type DescribeScalingRulesRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of entries to return on each page. Maximum value: 50.
	//
	// Default value: 10.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The ID of the scaling group.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The number of the page to return. Pages start from page 1.
	//
	// Default value: 1.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the scaling rule. Valid values:
	//
	// *   SimpleScalingRule: adjusts the number of ECS instances based on the values of the AdjustmentType and AdjustmentValue parameters.
	// *   TargetTrackingScalingRule: calculates the number of ECS instances that need to be scaled in a dynamic manner and maintains the value of a predefined metric close to the value of the TargetValue parameter.
	// *   StepScalingRule: scales ECS instances in steps based on the specified thresholds and metric values.
	// *   PredictiveScalingRule: uses machine learning to analyze historical monitoring data of the scaling group and predicts the future values of metrics. In addition, Auto Scaling automatically creates scheduled tasks to adjust the boundary values for the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The unique identifiers of the scaling rules that you want to query.
	ScalingRuleAris []*string `json:"ScalingRuleAris,omitempty" xml:"ScalingRuleAris,omitempty" type:"Repeated"`
	// The IDs of the scaling rules that you want to query.
	ScalingRuleIds []*string `json:"ScalingRuleIds,omitempty" xml:"ScalingRuleIds,omitempty" type:"Repeated"`
	// The names of the scaling rules that you want to query.
	ScalingRuleNames []*string `json:"ScalingRuleNames,omitempty" xml:"ScalingRuleNames,omitempty" type:"Repeated"`
	// Specifies whether to return CloudMonitor event-triggered tasks associated with scaling rules. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	ScalingRuleType *string `json:"ScalingRuleType,omitempty" xml:"ScalingRuleType,omitempty"`
	// The IDs of the scaling rules that you want to query.
	ShowAlarmRules *bool `json:"ShowAlarmRules,omitempty" xml:"ShowAlarmRules,omitempty"`
}

func (s DescribeScalingRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingRulesRequest) GoString() string {
	return s.String()
}

func (s *DescribeScalingRulesRequest) SetOwnerAccount(v string) *DescribeScalingRulesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeScalingRulesRequest) SetOwnerId(v int64) *DescribeScalingRulesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeScalingRulesRequest) SetPageNumber(v int32) *DescribeScalingRulesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeScalingRulesRequest) SetPageSize(v int32) *DescribeScalingRulesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeScalingRulesRequest) SetRegionId(v string) *DescribeScalingRulesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeScalingRulesRequest) SetResourceOwnerAccount(v string) *DescribeScalingRulesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeScalingRulesRequest) SetResourceOwnerId(v int64) *DescribeScalingRulesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeScalingRulesRequest) SetScalingGroupId(v string) *DescribeScalingRulesRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeScalingRulesRequest) SetScalingRuleAris(v []*string) *DescribeScalingRulesRequest {
	s.ScalingRuleAris = v
	return s
}

func (s *DescribeScalingRulesRequest) SetScalingRuleIds(v []*string) *DescribeScalingRulesRequest {
	s.ScalingRuleIds = v
	return s
}

func (s *DescribeScalingRulesRequest) SetScalingRuleNames(v []*string) *DescribeScalingRulesRequest {
	s.ScalingRuleNames = v
	return s
}

func (s *DescribeScalingRulesRequest) SetScalingRuleType(v string) *DescribeScalingRulesRequest {
	s.ScalingRuleType = &v
	return s
}

func (s *DescribeScalingRulesRequest) SetShowAlarmRules(v bool) *DescribeScalingRulesRequest {
	s.ShowAlarmRules = &v
	return s
}

type DescribeScalingRulesResponseBody struct {
	// The number of entries returned per page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The total number of scaling rules.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The page number of the returned page.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Details of the scaling rules.
	ScalingRules []*DescribeScalingRulesResponseBodyScalingRules `json:"ScalingRules,omitempty" xml:"ScalingRules,omitempty" type:"Repeated"`
	// Details of the scaling rules.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeScalingRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingRulesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeScalingRulesResponseBody) SetPageNumber(v int32) *DescribeScalingRulesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeScalingRulesResponseBody) SetPageSize(v int32) *DescribeScalingRulesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeScalingRulesResponseBody) SetRequestId(v string) *DescribeScalingRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeScalingRulesResponseBody) SetScalingRules(v []*DescribeScalingRulesResponseBodyScalingRules) *DescribeScalingRulesResponseBody {
	s.ScalingRules = v
	return s
}

func (s *DescribeScalingRulesResponseBody) SetTotalCount(v int32) *DescribeScalingRulesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeScalingRulesResponseBodyScalingRules struct {
	// The maximum number of ECS instances in the scaling group. You must specify the InitialMaxSize and PredictiveValueBehavior parameters.
	AdjustmentType *string `json:"AdjustmentType,omitempty" xml:"AdjustmentType,omitempty"`
	// The number of consecutive times that the event-triggered task created for scale-out activities must meet the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.
	AdjustmentValue *int32 `json:"AdjustmentValue,omitempty" xml:"AdjustmentValue,omitempty"`
	// The event-triggered tasks that are associated with the scaling rule. Event-triggered tasks that are associated with the scaling rule are returned only if you set the ShowAlarmRules parameter to true. Otherwise, an empty list is returned.
	Alarms []*DescribeScalingRulesResponseBodyScalingRulesAlarms `json:"Alarms,omitempty" xml:"Alarms,omitempty" type:"Repeated"`
	// The maximum number of ECS instances in the scaling group.
	Cooldown *int32 `json:"Cooldown,omitempty" xml:"Cooldown,omitempty"`
	// The name of the scaling rule.
	DisableScaleIn *bool `json:"DisableScaleIn,omitempty" xml:"DisableScaleIn,omitempty"`
	// The number of consecutive times that the event-triggered task created for scale-in activities must meet the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.
	EstimatedInstanceWarmup *int32 `json:"EstimatedInstanceWarmup,omitempty" xml:"EstimatedInstanceWarmup,omitempty"`
	// The warmup period of the ECS instance.
	InitialMaxSize *int32 `json:"InitialMaxSize,omitempty" xml:"InitialMaxSize,omitempty"`
	// The percentage of the increment to the predicted value when the PredictiveValueBehavior parameter is set to PredictiveValueOverrideMaxWithBuffer. If the predicted value increased by this percentage is greater than the initial maximum capacity, the increased value is used as the maximum value for prediction tasks. Valid values: 0 to 100.
	MaxSize *int32 `json:"MaxSize,omitempty" xml:"MaxSize,omitempty"`
	// The scaling mode of the scaling rule. Valid values:
	//
	// *   QuantityChangeInCapacity: adds the specified number of ECS instances to or removes the specified number of ECS instances from the scaling group.
	// *   PercentChangeInCapacity: adds the specified percentage of ECS instances to or removes the specified percentage of ECS instances from the scaling group.
	// *   TotalCapacity: adjusts the number of ECS instances in the scaling group to the specified number.
	MetricName *string `json:"MetricName,omitempty" xml:"MetricName,omitempty"`
	// The unique identifier of the scaling rule.
	MinAdjustmentMagnitude *int32 `json:"MinAdjustmentMagnitude,omitempty" xml:"MinAdjustmentMagnitude,omitempty"`
	// The ID of the scaling group.
	MinSize *int32 `json:"MinSize,omitempty" xml:"MinSize,omitempty"`
	// The minimum number of instances that must be scaled when the AdjustmentType parameter is set to PercentChangeInCapacity. This parameter takes effect only if you set the ScalingRuleType parameter to SimpleScalingRule or StepScalingRule.
	PredictiveScalingMode *string `json:"PredictiveScalingMode,omitempty" xml:"PredictiveScalingMode,omitempty"`
	// The minimum number of ECS instances in the scaling group.
	PredictiveTaskBufferTime *int32 `json:"PredictiveTaskBufferTime,omitempty" xml:"PredictiveTaskBufferTime,omitempty"`
	// The target value of the metric.
	PredictiveValueBehavior *string `json:"PredictiveValueBehavior,omitempty" xml:"PredictiveValueBehavior,omitempty"`
	// The type of the scaling rule. Valid values:
	//
	// *   SimpleScalingRule: adjusts the number of ECS instances based on the values of the AdjustmentType and AdjustmentValue parameters.
	// *   TargetTrackingScalingRule: calculates the number of ECS instances that need to be scaled in a dynamic manner and maintains the value of a predefined metric close to the value of the TargetValue parameter.
	// *   StepScalingRule: scales ECS instances in steps based on specified thresholds and metric values.
	// *   PredictiveScalingRule: uses machine learning to analyze historical monitoring data of the scaling group and predicts the future values of metrics. In addition, Auto Scaling automatically creates scheduled tasks to adjust the boundary values for the scaling group.
	PredictiveValueBuffer *int32 `json:"PredictiveValueBuffer,omitempty" xml:"PredictiveValueBuffer,omitempty"`
	// Specifies whether to disable scale-in. This parameter is available only if you set the ScalingRuleType parameter to TargetTrackingScalingRule. Valid values:
	//
	// *   true
	// *   false
	ScaleInEvaluationCount *int32 `json:"ScaleInEvaluationCount,omitempty" xml:"ScaleInEvaluationCount,omitempty"`
	// The mode of the predictive scaling rule. Valid values:
	//
	// *   PredictAndScale: produces predictions and creates prediction tasks.
	// *   PredictOnly: produces predictions but does not create prediction tasks.
	ScaleOutEvaluationCount *int32 `json:"ScaleOutEvaluationCount,omitempty" xml:"ScaleOutEvaluationCount,omitempty"`
	// Specifies which one of the initial maximum capacity and the predicted value can be used as the maximum value for prediction tasks. Valid values:
	//
	// *   MaxOverridePredictiveValue: uses the initial maximum capacity as the maximum value for prediction tasks if the predicted value is greater than the initial maximum capacity.
	// *   PredictiveValueOverrideMax: uses the predicted value as the maximum value for prediction tasks when the predicted value is greater than the initial maximum capacity.
	// *   PredictiveValueOverrideMaxWithBuffer: increases the predicted value by a percentage that is specified by the PredictiveValueBuffer parameter. If the predicted value that is increased by the percentage is greater than the initial maximum capacity, the increased value is used as the maximum value for prediction tasks.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The amount of buffer time before the prediction task is executed. By default, all scheduled tasks that are automatically created for a predictive scaling rule are executed on the hour. You can specify a buffer time for resource preparation before prediction tasks are executed. Valid values: 0 to 60. Unit: minutes.
	ScalingRuleAri *string `json:"ScalingRuleAri,omitempty" xml:"ScalingRuleAri,omitempty"`
	// The event-triggered tasks that are associated with the scaling rule. Event-triggered tasks that are associated with the scaling rule are returned only if you set the ShowAlarmRules parameter to true. Otherwise, an empty list is returned.
	ScalingRuleId *string `json:"ScalingRuleId,omitempty" xml:"ScalingRuleId,omitempty"`
	// The ID of the scaling rule.
	ScalingRuleName *string `json:"ScalingRuleName,omitempty" xml:"ScalingRuleName,omitempty"`
	// The adjustment value that is specified in the scaling rule.
	ScalingRuleType *string `json:"ScalingRuleType,omitempty" xml:"ScalingRuleType,omitempty"`
	// The step adjustments of the step scaling rule.
	StepAdjustments []*DescribeScalingRulesResponseBodyScalingRulesStepAdjustments `json:"StepAdjustments,omitempty" xml:"StepAdjustments,omitempty" type:"Repeated"`
	// The cooldown time of the scaling rule. This parameter is available only if you set the ScalingRuleType parameter to SimpleScalingRule. Valid values: 0 to 86400. Unit: seconds.
	TargetValue *float32 `json:"TargetValue,omitempty" xml:"TargetValue,omitempty"`
}

func (s DescribeScalingRulesResponseBodyScalingRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingRulesResponseBodyScalingRules) GoString() string {
	return s.String()
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetAdjustmentType(v string) *DescribeScalingRulesResponseBodyScalingRules {
	s.AdjustmentType = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetAdjustmentValue(v int32) *DescribeScalingRulesResponseBodyScalingRules {
	s.AdjustmentValue = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetAlarms(v []*DescribeScalingRulesResponseBodyScalingRulesAlarms) *DescribeScalingRulesResponseBodyScalingRules {
	s.Alarms = v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetCooldown(v int32) *DescribeScalingRulesResponseBodyScalingRules {
	s.Cooldown = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetDisableScaleIn(v bool) *DescribeScalingRulesResponseBodyScalingRules {
	s.DisableScaleIn = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetEstimatedInstanceWarmup(v int32) *DescribeScalingRulesResponseBodyScalingRules {
	s.EstimatedInstanceWarmup = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetInitialMaxSize(v int32) *DescribeScalingRulesResponseBodyScalingRules {
	s.InitialMaxSize = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetMaxSize(v int32) *DescribeScalingRulesResponseBodyScalingRules {
	s.MaxSize = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetMetricName(v string) *DescribeScalingRulesResponseBodyScalingRules {
	s.MetricName = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetMinAdjustmentMagnitude(v int32) *DescribeScalingRulesResponseBodyScalingRules {
	s.MinAdjustmentMagnitude = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetMinSize(v int32) *DescribeScalingRulesResponseBodyScalingRules {
	s.MinSize = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetPredictiveScalingMode(v string) *DescribeScalingRulesResponseBodyScalingRules {
	s.PredictiveScalingMode = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetPredictiveTaskBufferTime(v int32) *DescribeScalingRulesResponseBodyScalingRules {
	s.PredictiveTaskBufferTime = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetPredictiveValueBehavior(v string) *DescribeScalingRulesResponseBodyScalingRules {
	s.PredictiveValueBehavior = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetPredictiveValueBuffer(v int32) *DescribeScalingRulesResponseBodyScalingRules {
	s.PredictiveValueBuffer = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetScaleInEvaluationCount(v int32) *DescribeScalingRulesResponseBodyScalingRules {
	s.ScaleInEvaluationCount = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetScaleOutEvaluationCount(v int32) *DescribeScalingRulesResponseBodyScalingRules {
	s.ScaleOutEvaluationCount = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetScalingGroupId(v string) *DescribeScalingRulesResponseBodyScalingRules {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetScalingRuleAri(v string) *DescribeScalingRulesResponseBodyScalingRules {
	s.ScalingRuleAri = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetScalingRuleId(v string) *DescribeScalingRulesResponseBodyScalingRules {
	s.ScalingRuleId = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetScalingRuleName(v string) *DescribeScalingRulesResponseBodyScalingRules {
	s.ScalingRuleName = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetScalingRuleType(v string) *DescribeScalingRulesResponseBodyScalingRules {
	s.ScalingRuleType = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetStepAdjustments(v []*DescribeScalingRulesResponseBodyScalingRulesStepAdjustments) *DescribeScalingRulesResponseBodyScalingRules {
	s.StepAdjustments = v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRules) SetTargetValue(v float32) *DescribeScalingRulesResponseBodyScalingRules {
	s.TargetValue = &v
	return s
}

type DescribeScalingRulesResponseBodyScalingRulesAlarms struct {
	// The comparison operator between the metric value and the threshold for the event-triggered task that is associated with the scaling rule. The comparison operator indicates the relationship between the metric value and the threshold that is required to meet the condition.
	//
	// *   Valid value if the metric value is greater than or equal to the threshold: >=.
	// *   Valid value if the metric value is less than or equal to the threshold: <=.
	// *   Valid value if the metric value is greater than the threshold: >.
	// *   Valid value if the metric value is less than the threshold: <.
	AlarmTaskId *string `json:"AlarmTaskId,omitempty" xml:"AlarmTaskId,omitempty"`
	// The type of the event-triggered task that is associated with the scaling rule. Valid values:
	//
	// *   system: system monitoring event-triggered tasks
	// *   custom: custom monitoring event-triggered tasks
	AlarmTaskName *string `json:"AlarmTaskName,omitempty" xml:"AlarmTaskName,omitempty"`
	// The name of the metric of the event-triggered task that is associated with the scaling rule.
	ComparisonOperator *string `json:"ComparisonOperator,omitempty" xml:"ComparisonOperator,omitempty"`
	// The dimensions of the event-triggered task that is associated with the scaling rule.
	Dimensions []*DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions `json:"Dimensions,omitempty" xml:"Dimensions,omitempty" type:"Repeated"`
	// The name of the event-triggered task that is associated with the scaling rule.
	EvaluationCount *int32 `json:"EvaluationCount,omitempty" xml:"EvaluationCount,omitempty"`
	// The number of consecutive times for which the event-triggered task that is associated with the scaling rule meets the threshold expressions before an alert is triggered.
	MetricName *string `json:"MetricName,omitempty" xml:"MetricName,omitempty"`
	// The alert threshold of the event-triggered task that is associated with the scaling rule.
	MetricType *string `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
	// The dimensions of the event-triggered task that is associated with the scaling rule.
	Statistics *string `json:"Statistics,omitempty" xml:"Statistics,omitempty"`
	// The statistical method of the event-triggered task that is associated with the scaling rule. Valid values:
	//
	// *   Average
	// *   Maximum
	// *   Minimum
	Threshold *float32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s DescribeScalingRulesResponseBodyScalingRulesAlarms) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingRulesResponseBodyScalingRulesAlarms) GoString() string {
	return s.String()
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarms) SetAlarmTaskId(v string) *DescribeScalingRulesResponseBodyScalingRulesAlarms {
	s.AlarmTaskId = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarms) SetAlarmTaskName(v string) *DescribeScalingRulesResponseBodyScalingRulesAlarms {
	s.AlarmTaskName = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarms) SetComparisonOperator(v string) *DescribeScalingRulesResponseBodyScalingRulesAlarms {
	s.ComparisonOperator = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarms) SetDimensions(v []*DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions) *DescribeScalingRulesResponseBodyScalingRulesAlarms {
	s.Dimensions = v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarms) SetEvaluationCount(v int32) *DescribeScalingRulesResponseBodyScalingRulesAlarms {
	s.EvaluationCount = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarms) SetMetricName(v string) *DescribeScalingRulesResponseBodyScalingRulesAlarms {
	s.MetricName = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarms) SetMetricType(v string) *DescribeScalingRulesResponseBodyScalingRulesAlarms {
	s.MetricType = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarms) SetStatistics(v string) *DescribeScalingRulesResponseBodyScalingRulesAlarms {
	s.Statistics = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarms) SetThreshold(v float32) *DescribeScalingRulesResponseBodyScalingRulesAlarms {
	s.Threshold = &v
	return s
}

type DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions struct {
	// The value of the dimension that is associated with the metric.
	DimensionKey *string `json:"DimensionKey,omitempty" xml:"DimensionKey,omitempty"`
	// The step adjustments of the step scaling rule.
	DimensionValue *string `json:"DimensionValue,omitempty" xml:"DimensionValue,omitempty"`
}

func (s DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions) GoString() string {
	return s.String()
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions) SetDimensionKey(v string) *DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions {
	s.DimensionKey = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions) SetDimensionValue(v string) *DescribeScalingRulesResponseBodyScalingRulesAlarmsDimensions {
	s.DimensionValue = &v
	return s
}

type DescribeScalingRulesResponseBodyScalingRulesStepAdjustments struct {
	// auditing
	MetricIntervalLowerBound *float32 `json:"MetricIntervalLowerBound,omitempty" xml:"MetricIntervalLowerBound,omitempty"`
	// The number of ECS instances that are scaled in a step adjustment.
	MetricIntervalUpperBound *float32 `json:"MetricIntervalUpperBound,omitempty" xml:"MetricIntervalUpperBound,omitempty"`
	// The lower limit that is specified in a step adjustment. Valid values: -9.999999E18 to 9.999999E18.
	ScalingAdjustment *int32 `json:"ScalingAdjustment,omitempty" xml:"ScalingAdjustment,omitempty"`
}

func (s DescribeScalingRulesResponseBodyScalingRulesStepAdjustments) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingRulesResponseBodyScalingRulesStepAdjustments) GoString() string {
	return s.String()
}

func (s *DescribeScalingRulesResponseBodyScalingRulesStepAdjustments) SetMetricIntervalLowerBound(v float32) *DescribeScalingRulesResponseBodyScalingRulesStepAdjustments {
	s.MetricIntervalLowerBound = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRulesStepAdjustments) SetMetricIntervalUpperBound(v float32) *DescribeScalingRulesResponseBodyScalingRulesStepAdjustments {
	s.MetricIntervalUpperBound = &v
	return s
}

func (s *DescribeScalingRulesResponseBodyScalingRulesStepAdjustments) SetScalingAdjustment(v int32) *DescribeScalingRulesResponseBodyScalingRulesStepAdjustments {
	s.ScalingAdjustment = &v
	return s
}

type DescribeScalingRulesResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeScalingRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeScalingRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeScalingRulesResponse) GoString() string {
	return s.String()
}

func (s *DescribeScalingRulesResponse) SetHeaders(v map[string]*string) *DescribeScalingRulesResponse {
	s.Headers = v
	return s
}

func (s *DescribeScalingRulesResponse) SetStatusCode(v int32) *DescribeScalingRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeScalingRulesResponse) SetBody(v *DescribeScalingRulesResponseBody) *DescribeScalingRulesResponse {
	s.Body = v
	return s
}

type DescribeScheduledTasksRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Pages start from page 1.
	//
	// Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values: 1 to 50.
	//
	// Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the scaling group to which the scheduled task belongs.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the scaling group to which the scheduled task belongs.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The actions that you want Auto Scaling to perform when the scheduled task is triggered.
	ScheduledActions []*string `json:"ScheduledActions,omitempty" xml:"ScheduledActions,omitempty" type:"Repeated"`
	// The ID of the scheduled task that you want to query.
	ScheduledTaskIds []*string `json:"ScheduledTaskIds,omitempty" xml:"ScheduledTaskIds,omitempty" type:"Repeated"`
	// The names of the scheduled tasks that you want to query.
	ScheduledTaskNames []*string `json:"ScheduledTaskNames,omitempty" xml:"ScheduledTaskNames,omitempty" type:"Repeated"`
}

func (s DescribeScheduledTasksRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeScheduledTasksRequest) GoString() string {
	return s.String()
}

func (s *DescribeScheduledTasksRequest) SetOwnerAccount(v string) *DescribeScheduledTasksRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeScheduledTasksRequest) SetOwnerId(v int64) *DescribeScheduledTasksRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeScheduledTasksRequest) SetPageNumber(v int32) *DescribeScheduledTasksRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeScheduledTasksRequest) SetPageSize(v int32) *DescribeScheduledTasksRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeScheduledTasksRequest) SetRegionId(v string) *DescribeScheduledTasksRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeScheduledTasksRequest) SetResourceOwnerAccount(v string) *DescribeScheduledTasksRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeScheduledTasksRequest) SetResourceOwnerId(v int64) *DescribeScheduledTasksRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeScheduledTasksRequest) SetScalingGroupId(v string) *DescribeScheduledTasksRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeScheduledTasksRequest) SetScheduledActions(v []*string) *DescribeScheduledTasksRequest {
	s.ScheduledActions = v
	return s
}

func (s *DescribeScheduledTasksRequest) SetScheduledTaskIds(v []*string) *DescribeScheduledTasksRequest {
	s.ScheduledTaskIds = v
	return s
}

func (s *DescribeScheduledTasksRequest) SetScheduledTaskNames(v []*string) *DescribeScheduledTasksRequest {
	s.ScheduledTaskNames = v
	return s
}

type DescribeScheduledTasksResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Details of the scheduled tasks.
	ScheduledTasks []*DescribeScheduledTasksResponseBodyScheduledTasks `json:"ScheduledTasks,omitempty" xml:"ScheduledTasks,omitempty" type:"Repeated"`
	// The total number of scheduled tasks.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeScheduledTasksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeScheduledTasksResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeScheduledTasksResponseBody) SetPageNumber(v int32) *DescribeScheduledTasksResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeScheduledTasksResponseBody) SetPageSize(v int32) *DescribeScheduledTasksResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeScheduledTasksResponseBody) SetRequestId(v string) *DescribeScheduledTasksResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeScheduledTasksResponseBody) SetScheduledTasks(v []*DescribeScheduledTasksResponseBodyScheduledTasks) *DescribeScheduledTasksResponseBody {
	s.ScheduledTasks = v
	return s
}

func (s *DescribeScheduledTasksResponseBody) SetTotalCount(v int32) *DescribeScheduledTasksResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeScheduledTasksResponseBodyScheduledTasks struct {
	// The description of the scheduled task.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The expected number of instances in the scaling group if you specify the ScalingGroupId parameter.
	DesiredCapacity *int32 `json:"DesiredCapacity,omitempty" xml:"DesiredCapacity,omitempty"`
	// The time period during which the failed scheduled task is retried. Unit: seconds. Valid values: 0 to 21600.
	LaunchExpirationTime *int32 `json:"LaunchExpirationTime,omitempty" xml:"LaunchExpirationTime,omitempty"`
	// The point in time at which the scheduled task is triggered.
	LaunchTime *string `json:"LaunchTime,omitempty" xml:"LaunchTime,omitempty"`
	// The maximum number of instances in the scaling group if you specify the ScalingGroupId parameter.
	MaxValue *int32 `json:"MaxValue,omitempty" xml:"MaxValue,omitempty"`
	// The minimum number of instances in the scaling group if you specify the ScalingGroupId parameter.
	MinValue *int32 `json:"MinValue,omitempty" xml:"MinValue,omitempty"`
	// The end time of the recurrence of the scheduled task.
	RecurrenceEndTime *string `json:"RecurrenceEndTime,omitempty" xml:"RecurrenceEndTime,omitempty"`
	// The interval at which the scheduled task is repeated.
	RecurrenceType *string `json:"RecurrenceType,omitempty" xml:"RecurrenceType,omitempty"`
	// The number of recurrences of the scheduled task.
	RecurrenceValue *string `json:"RecurrenceValue,omitempty" xml:"RecurrenceValue,omitempty"`
	// The ID of the scaling group to which the scheduled task belongs.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The scaling rule that is executed when the scheduled task is triggered. This parameter is returned only after a scaling rule is specified for the scheduled task.
	ScheduledAction *string `json:"ScheduledAction,omitempty" xml:"ScheduledAction,omitempty"`
	// The ID of the scheduled task.
	ScheduledTaskId *string `json:"ScheduledTaskId,omitempty" xml:"ScheduledTaskId,omitempty"`
	// The name of the scheduled task.
	ScheduledTaskName *string `json:"ScheduledTaskName,omitempty" xml:"ScheduledTaskName,omitempty"`
	// Indicates whether the scheduled task is enabled.
	//
	// *   true
	// *   false
	//
	// Default value: true.
	TaskEnabled *bool `json:"TaskEnabled,omitempty" xml:"TaskEnabled,omitempty"`
}

func (s DescribeScheduledTasksResponseBodyScheduledTasks) String() string {
	return tea.Prettify(s)
}

func (s DescribeScheduledTasksResponseBodyScheduledTasks) GoString() string {
	return s.String()
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetDescription(v string) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.Description = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetDesiredCapacity(v int32) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.DesiredCapacity = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetLaunchExpirationTime(v int32) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.LaunchExpirationTime = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetLaunchTime(v string) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.LaunchTime = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetMaxValue(v int32) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.MaxValue = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetMinValue(v int32) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.MinValue = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetRecurrenceEndTime(v string) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.RecurrenceEndTime = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetRecurrenceType(v string) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.RecurrenceType = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetRecurrenceValue(v string) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.RecurrenceValue = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetScalingGroupId(v string) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.ScalingGroupId = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetScheduledAction(v string) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.ScheduledAction = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetScheduledTaskId(v string) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.ScheduledTaskId = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetScheduledTaskName(v string) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.ScheduledTaskName = &v
	return s
}

func (s *DescribeScheduledTasksResponseBodyScheduledTasks) SetTaskEnabled(v bool) *DescribeScheduledTasksResponseBodyScheduledTasks {
	s.TaskEnabled = &v
	return s
}

type DescribeScheduledTasksResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeScheduledTasksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeScheduledTasksResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeScheduledTasksResponse) GoString() string {
	return s.String()
}

func (s *DescribeScheduledTasksResponse) SetHeaders(v map[string]*string) *DescribeScheduledTasksResponse {
	s.Headers = v
	return s
}

func (s *DescribeScheduledTasksResponse) SetStatusCode(v int32) *DescribeScheduledTasksResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeScheduledTasksResponse) SetBody(v *DescribeScheduledTasksResponseBody) *DescribeScheduledTasksResponse {
	s.Body = v
	return s
}

type DetachAlbServerGroupsRequest struct {
	// Details of the ALB server groups.
	AlbServerGroups []*DetachAlbServerGroupsRequestAlbServerGroups `json:"AlbServerGroups,omitempty" xml:"AlbServerGroups,omitempty" type:"Repeated"`
	// Specifies whether to remove existing Elastic Compute Service (ECS) instances from the ALB server group that you want to disassociate from the scaling group. Valid values:
	//
	// *   true: removes existing ECS instances and returns the value of the `ScalingActivityId` parameter. You can use the scaling activity ID to check whether the ECS instances are removed.
	// *   false: does not remove existing ECS instances.
	//
	// Default value: false.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Details of the ALB server groups.
	ForceDetach *bool  `json:"ForceDetach,omitempty" xml:"ForceDetach,omitempty"`
	OwnerId     *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request](~~25965~~).
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DetachAlbServerGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachAlbServerGroupsRequest) GoString() string {
	return s.String()
}

func (s *DetachAlbServerGroupsRequest) SetAlbServerGroups(v []*DetachAlbServerGroupsRequestAlbServerGroups) *DetachAlbServerGroupsRequest {
	s.AlbServerGroups = v
	return s
}

func (s *DetachAlbServerGroupsRequest) SetClientToken(v string) *DetachAlbServerGroupsRequest {
	s.ClientToken = &v
	return s
}

func (s *DetachAlbServerGroupsRequest) SetForceDetach(v bool) *DetachAlbServerGroupsRequest {
	s.ForceDetach = &v
	return s
}

func (s *DetachAlbServerGroupsRequest) SetOwnerId(v int64) *DetachAlbServerGroupsRequest {
	s.OwnerId = &v
	return s
}

func (s *DetachAlbServerGroupsRequest) SetRegionId(v string) *DetachAlbServerGroupsRequest {
	s.RegionId = &v
	return s
}

func (s *DetachAlbServerGroupsRequest) SetResourceOwnerAccount(v string) *DetachAlbServerGroupsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DetachAlbServerGroupsRequest) SetScalingGroupId(v string) *DetachAlbServerGroupsRequest {
	s.ScalingGroupId = &v
	return s
}

type DetachAlbServerGroupsRequestAlbServerGroups struct {
	// The port number used by the ECS instances in the ALB server group.
	AlbServerGroupId *string `json:"AlbServerGroupId,omitempty" xml:"AlbServerGroupId,omitempty"`
	// The ID of the scaling activity in which the ALB server group is disassociated from the scaling group and the ECS instances in the ALB server group are removed from the ALB server group. This parameter is returned only after you set the `ForceDetach` parameter to `true`.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
}

func (s DetachAlbServerGroupsRequestAlbServerGroups) String() string {
	return tea.Prettify(s)
}

func (s DetachAlbServerGroupsRequestAlbServerGroups) GoString() string {
	return s.String()
}

func (s *DetachAlbServerGroupsRequestAlbServerGroups) SetAlbServerGroupId(v string) *DetachAlbServerGroupsRequestAlbServerGroups {
	s.AlbServerGroupId = &v
	return s
}

func (s *DetachAlbServerGroupsRequestAlbServerGroups) SetPort(v int32) *DetachAlbServerGroupsRequestAlbServerGroups {
	s.Port = &v
	return s
}

type DetachAlbServerGroupsResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s DetachAlbServerGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachAlbServerGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *DetachAlbServerGroupsResponseBody) SetRequestId(v string) *DetachAlbServerGroupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DetachAlbServerGroupsResponseBody) SetScalingActivityId(v string) *DetachAlbServerGroupsResponseBody {
	s.ScalingActivityId = &v
	return s
}

type DetachAlbServerGroupsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachAlbServerGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachAlbServerGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachAlbServerGroupsResponse) GoString() string {
	return s.String()
}

func (s *DetachAlbServerGroupsResponse) SetHeaders(v map[string]*string) *DetachAlbServerGroupsResponse {
	s.Headers = v
	return s
}

func (s *DetachAlbServerGroupsResponse) SetStatusCode(v int32) *DetachAlbServerGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachAlbServerGroupsResponse) SetBody(v *DetachAlbServerGroupsResponseBody) *DetachAlbServerGroupsResponse {
	s.Body = v
	return s
}

type DetachDBInstancesRequest struct {
	// The IDs of the ApsaraDB RDS instances. You can specify up to five ApsaraDB RDS instances.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The IDs of the ApsaraDB RDS instances. You can specify up to five ApsaraDB RDS instances.
	DBInstances []*string `json:"DBInstances,omitempty" xml:"DBInstances,omitempty" type:"Repeated"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).
	ForceDetach *bool  `json:"ForceDetach,omitempty" xml:"ForceDetach,omitempty"`
	OwnerId     *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// Specifies whether to remove the private IP addresses of instances in the scaling group from the whitelist that manages access to the ApsaraDB RDS instance with which the scaling group is associated. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DetachDBInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachDBInstancesRequest) GoString() string {
	return s.String()
}

func (s *DetachDBInstancesRequest) SetClientToken(v string) *DetachDBInstancesRequest {
	s.ClientToken = &v
	return s
}

func (s *DetachDBInstancesRequest) SetDBInstances(v []*string) *DetachDBInstancesRequest {
	s.DBInstances = v
	return s
}

func (s *DetachDBInstancesRequest) SetForceDetach(v bool) *DetachDBInstancesRequest {
	s.ForceDetach = &v
	return s
}

func (s *DetachDBInstancesRequest) SetOwnerId(v int64) *DetachDBInstancesRequest {
	s.OwnerId = &v
	return s
}

func (s *DetachDBInstancesRequest) SetRegionId(v string) *DetachDBInstancesRequest {
	s.RegionId = &v
	return s
}

func (s *DetachDBInstancesRequest) SetResourceOwnerAccount(v string) *DetachDBInstancesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DetachDBInstancesRequest) SetScalingGroupId(v string) *DetachDBInstancesRequest {
	s.ScalingGroupId = &v
	return s
}

type DetachDBInstancesResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DetachDBInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachDBInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *DetachDBInstancesResponseBody) SetRequestId(v string) *DetachDBInstancesResponseBody {
	s.RequestId = &v
	return s
}

type DetachDBInstancesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachDBInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachDBInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachDBInstancesResponse) GoString() string {
	return s.String()
}

func (s *DetachDBInstancesResponse) SetHeaders(v map[string]*string) *DetachDBInstancesResponse {
	s.Headers = v
	return s
}

func (s *DetachDBInstancesResponse) SetStatusCode(v int32) *DetachDBInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachDBInstancesResponse) SetBody(v *DetachDBInstancesResponseBody) *DetachDBInstancesResponse {
	s.Body = v
	return s
}

type DetachInstancesRequest struct {
	// Specifies whether to remove the instances from the default server group and vServer groups of the Classic Load Balancer (CLB) instance that is associated with the scaling group, and whether to remove the IP addresses of the instances from the whitelist that manages access to the ApsaraDB RDS instance that is associated with the scaling group.
	//
	// If you set this parameter to both, the instances are removed from the default sever group and vServer groups of the associated CLB instance, and the IP addresses of the instances are removed from the whitelist that manages access to the associated ApsaraDB RDS instance.
	DecreaseDesiredCapacity *bool `json:"DecreaseDesiredCapacity,omitempty" xml:"DecreaseDesiredCapacity,omitempty"`
	// The IDs of the ECS instances or elastic container instances that you want to remove from the scaling group.
	DetachOption *string `json:"DetachOption,omitempty" xml:"DetachOption,omitempty"`
	// The IDs of the ECS instances or elastic container instances that you want to remove from the scaling group. You can specify 1 to 20 instance IDs.
	//
	// Examples:
	//
	// *   The ID of the ECS instance that you want to remove is `i-bp109k5j3dum1ce6****`.
	// *   The ID of the elastic container instance that you want to remove is `eci-bp17gw49eu09yiwm****`.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The ID of the scaling activity.
	LifecycleHook        *bool   `json:"LifecycleHook,omitempty" xml:"LifecycleHook,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// Specifies whether to adjust the expected number of instances in the scaling group. Valid values:
	//
	// *   true: After a specific number of instances are removed from the scaling group, the expected number of instances in the scaling group decreases.
	// *   false: After a specific number of instances are removed from the scaling group, the expected number of instances in the scaling group remains unchanged.
	//
	// Default value: true.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DetachInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachInstancesRequest) GoString() string {
	return s.String()
}

func (s *DetachInstancesRequest) SetDecreaseDesiredCapacity(v bool) *DetachInstancesRequest {
	s.DecreaseDesiredCapacity = &v
	return s
}

func (s *DetachInstancesRequest) SetDetachOption(v string) *DetachInstancesRequest {
	s.DetachOption = &v
	return s
}

func (s *DetachInstancesRequest) SetInstanceIds(v []*string) *DetachInstancesRequest {
	s.InstanceIds = v
	return s
}

func (s *DetachInstancesRequest) SetLifecycleHook(v bool) *DetachInstancesRequest {
	s.LifecycleHook = &v
	return s
}

func (s *DetachInstancesRequest) SetOwnerAccount(v string) *DetachInstancesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DetachInstancesRequest) SetOwnerId(v int64) *DetachInstancesRequest {
	s.OwnerId = &v
	return s
}

func (s *DetachInstancesRequest) SetResourceOwnerAccount(v string) *DetachInstancesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DetachInstancesRequest) SetResourceOwnerId(v int64) *DetachInstancesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DetachInstancesRequest) SetScalingGroupId(v string) *DetachInstancesRequest {
	s.ScalingGroupId = &v
	return s
}

type DetachInstancesResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s DetachInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *DetachInstancesResponseBody) SetRequestId(v string) *DetachInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DetachInstancesResponseBody) SetScalingActivityId(v string) *DetachInstancesResponseBody {
	s.ScalingActivityId = &v
	return s
}

type DetachInstancesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachInstancesResponse) GoString() string {
	return s.String()
}

func (s *DetachInstancesResponse) SetHeaders(v map[string]*string) *DetachInstancesResponse {
	s.Headers = v
	return s
}

func (s *DetachInstancesResponse) SetStatusCode(v int32) *DetachInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachInstancesResponse) SetBody(v *DetachInstancesResponseBody) *DetachInstancesResponse {
	s.Body = v
	return s
}

type DetachLoadBalancersRequest struct {
	// Specifies whether to detach the CLB instance from the scaling group in an asynchronous manner. If you detach the CLB instance from the scaling group in an asynchronous manner, the call is successful only after all operations are successful. If a specific operation fails, the call fails. We recommend that you set this parameter to true.
	//
	// Valid values:
	//
	// *   true: detaches the CLB instance from the scaling group in an asynchronous manner. In this case, the ID of the scaling activity is returned.
	// *   false: does not detach the CLB instance from the scaling group in an asynchronous manner.
	//
	// Default value: false.
	Async *bool `json:"Async,omitempty" xml:"Async,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to remove Elastic Compute Service (ECS) instances in the scaling group from the backend server groups of the CLB instance. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	ForceDetach *bool `json:"ForceDetach,omitempty" xml:"ForceDetach,omitempty"`
	// The IDs of the CLB instances. You can specify up to five instance IDs.
	LoadBalancers []*string `json:"LoadBalancers,omitempty" xml:"LoadBalancers,omitempty" type:"Repeated"`
	OwnerId       *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DetachLoadBalancersRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachLoadBalancersRequest) GoString() string {
	return s.String()
}

func (s *DetachLoadBalancersRequest) SetAsync(v bool) *DetachLoadBalancersRequest {
	s.Async = &v
	return s
}

func (s *DetachLoadBalancersRequest) SetClientToken(v string) *DetachLoadBalancersRequest {
	s.ClientToken = &v
	return s
}

func (s *DetachLoadBalancersRequest) SetForceDetach(v bool) *DetachLoadBalancersRequest {
	s.ForceDetach = &v
	return s
}

func (s *DetachLoadBalancersRequest) SetLoadBalancers(v []*string) *DetachLoadBalancersRequest {
	s.LoadBalancers = v
	return s
}

func (s *DetachLoadBalancersRequest) SetOwnerId(v int64) *DetachLoadBalancersRequest {
	s.OwnerId = &v
	return s
}

func (s *DetachLoadBalancersRequest) SetRegionId(v string) *DetachLoadBalancersRequest {
	s.RegionId = &v
	return s
}

func (s *DetachLoadBalancersRequest) SetResourceOwnerAccount(v string) *DetachLoadBalancersRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DetachLoadBalancersRequest) SetScalingGroupId(v string) *DetachLoadBalancersRequest {
	s.ScalingGroupId = &v
	return s
}

type DetachLoadBalancersResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the scaling activity. The value of this parameter is returned only if you set the Async parameter to true. You can call the describescalingactivities operation to query all scaling activity IDs and use the scaling activity IDs to check the status of the scaling activities.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s DetachLoadBalancersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachLoadBalancersResponseBody) GoString() string {
	return s.String()
}

func (s *DetachLoadBalancersResponseBody) SetRequestId(v string) *DetachLoadBalancersResponseBody {
	s.RequestId = &v
	return s
}

func (s *DetachLoadBalancersResponseBody) SetScalingActivityId(v string) *DetachLoadBalancersResponseBody {
	s.ScalingActivityId = &v
	return s
}

type DetachLoadBalancersResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachLoadBalancersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachLoadBalancersResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachLoadBalancersResponse) GoString() string {
	return s.String()
}

func (s *DetachLoadBalancersResponse) SetHeaders(v map[string]*string) *DetachLoadBalancersResponse {
	s.Headers = v
	return s
}

func (s *DetachLoadBalancersResponse) SetStatusCode(v int32) *DetachLoadBalancersResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachLoadBalancersResponse) SetBody(v *DetachLoadBalancersResponseBody) *DetachLoadBalancersResponse {
	s.Body = v
	return s
}

type DetachVServerGroupsRequest struct {
	// Specifies whether to remove ECS instances in your scaling group from the vServer group.
	//
	// *   true
	// *   false
	//
	// Default value: false.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Details of the vServer groups.
	ForceDetach *bool  `json:"ForceDetach,omitempty" xml:"ForceDetach,omitempty"`
	OwnerId     *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// Details of the vServer groups.
	VServerGroups []*DetachVServerGroupsRequestVServerGroups `json:"VServerGroups,omitempty" xml:"VServerGroups,omitempty" type:"Repeated"`
}

func (s DetachVServerGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachVServerGroupsRequest) GoString() string {
	return s.String()
}

func (s *DetachVServerGroupsRequest) SetClientToken(v string) *DetachVServerGroupsRequest {
	s.ClientToken = &v
	return s
}

func (s *DetachVServerGroupsRequest) SetForceDetach(v bool) *DetachVServerGroupsRequest {
	s.ForceDetach = &v
	return s
}

func (s *DetachVServerGroupsRequest) SetOwnerId(v int64) *DetachVServerGroupsRequest {
	s.OwnerId = &v
	return s
}

func (s *DetachVServerGroupsRequest) SetRegionId(v string) *DetachVServerGroupsRequest {
	s.RegionId = &v
	return s
}

func (s *DetachVServerGroupsRequest) SetResourceOwnerAccount(v string) *DetachVServerGroupsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DetachVServerGroupsRequest) SetScalingGroupId(v string) *DetachVServerGroupsRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *DetachVServerGroupsRequest) SetVServerGroups(v []*DetachVServerGroupsRequestVServerGroups) *DetachVServerGroupsRequest {
	s.VServerGroups = v
	return s
}

type DetachVServerGroupsRequestVServerGroups struct {
	// The ID of the request.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// Details of the vServer group attributes.
	VServerGroupAttributes []*DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes `json:"VServerGroupAttributes,omitempty" xml:"VServerGroupAttributes,omitempty" type:"Repeated"`
}

func (s DetachVServerGroupsRequestVServerGroups) String() string {
	return tea.Prettify(s)
}

func (s DetachVServerGroupsRequestVServerGroups) GoString() string {
	return s.String()
}

func (s *DetachVServerGroupsRequestVServerGroups) SetLoadBalancerId(v string) *DetachVServerGroupsRequestVServerGroups {
	s.LoadBalancerId = &v
	return s
}

func (s *DetachVServerGroupsRequestVServerGroups) SetVServerGroupAttributes(v []*DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes) *DetachVServerGroupsRequestVServerGroups {
	s.VServerGroupAttributes = v
	return s
}

type DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes struct {
	// The ID of the Classic Load Balancer (CLB) instance to which the vServer group belongs.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The port number that is used when Auto Scaling adds ECS instances to the vServer group. Valid values: 1 to 65535.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes) String() string {
	return tea.Prettify(s)
}

func (s DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes) GoString() string {
	return s.String()
}

func (s *DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes) SetPort(v int32) *DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes {
	s.Port = &v
	return s
}

func (s *DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes) SetVServerGroupId(v string) *DetachVServerGroupsRequestVServerGroupsVServerGroupAttributes {
	s.VServerGroupId = &v
	return s
}

type DetachVServerGroupsResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DetachVServerGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachVServerGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *DetachVServerGroupsResponseBody) SetRequestId(v string) *DetachVServerGroupsResponseBody {
	s.RequestId = &v
	return s
}

type DetachVServerGroupsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachVServerGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachVServerGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachVServerGroupsResponse) GoString() string {
	return s.String()
}

func (s *DetachVServerGroupsResponse) SetHeaders(v map[string]*string) *DetachVServerGroupsResponse {
	s.Headers = v
	return s
}

func (s *DetachVServerGroupsResponse) SetStatusCode(v int32) *DetachVServerGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachVServerGroupsResponse) SetBody(v *DetachVServerGroupsResponseBody) *DetachVServerGroupsResponse {
	s.Body = v
	return s
}

type DisableAlarmRequest struct {
	// The ID of the request.
	AlarmTaskId *string `json:"AlarmTaskId,omitempty" xml:"AlarmTaskId,omitempty"`
	OwnerId     *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the event-triggered task.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
}

func (s DisableAlarmRequest) String() string {
	return tea.Prettify(s)
}

func (s DisableAlarmRequest) GoString() string {
	return s.String()
}

func (s *DisableAlarmRequest) SetAlarmTaskId(v string) *DisableAlarmRequest {
	s.AlarmTaskId = &v
	return s
}

func (s *DisableAlarmRequest) SetOwnerId(v int64) *DisableAlarmRequest {
	s.OwnerId = &v
	return s
}

func (s *DisableAlarmRequest) SetRegionId(v string) *DisableAlarmRequest {
	s.RegionId = &v
	return s
}

func (s *DisableAlarmRequest) SetResourceOwnerAccount(v string) *DisableAlarmRequest {
	s.ResourceOwnerAccount = &v
	return s
}

type DisableAlarmResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DisableAlarmResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DisableAlarmResponseBody) GoString() string {
	return s.String()
}

func (s *DisableAlarmResponseBody) SetRequestId(v string) *DisableAlarmResponseBody {
	s.RequestId = &v
	return s
}

type DisableAlarmResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DisableAlarmResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DisableAlarmResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableAlarmResponse) GoString() string {
	return s.String()
}

func (s *DisableAlarmResponse) SetHeaders(v map[string]*string) *DisableAlarmResponse {
	s.Headers = v
	return s
}

func (s *DisableAlarmResponse) SetStatusCode(v int32) *DisableAlarmResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableAlarmResponse) SetBody(v *DisableAlarmResponseBody) *DisableAlarmResponse {
	s.Body = v
	return s
}

type DisableScalingGroupRequest struct {
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the request.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s DisableScalingGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DisableScalingGroupRequest) GoString() string {
	return s.String()
}

func (s *DisableScalingGroupRequest) SetOwnerAccount(v string) *DisableScalingGroupRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DisableScalingGroupRequest) SetOwnerId(v int64) *DisableScalingGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *DisableScalingGroupRequest) SetResourceOwnerAccount(v string) *DisableScalingGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DisableScalingGroupRequest) SetResourceOwnerId(v int64) *DisableScalingGroupRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DisableScalingGroupRequest) SetScalingGroupId(v string) *DisableScalingGroupRequest {
	s.ScalingGroupId = &v
	return s
}

type DisableScalingGroupResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DisableScalingGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DisableScalingGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DisableScalingGroupResponseBody) SetRequestId(v string) *DisableScalingGroupResponseBody {
	s.RequestId = &v
	return s
}

type DisableScalingGroupResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DisableScalingGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DisableScalingGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableScalingGroupResponse) GoString() string {
	return s.String()
}

func (s *DisableScalingGroupResponse) SetHeaders(v map[string]*string) *DisableScalingGroupResponse {
	s.Headers = v
	return s
}

func (s *DisableScalingGroupResponse) SetStatusCode(v int32) *DisableScalingGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableScalingGroupResponse) SetBody(v *DisableScalingGroupResponseBody) *DisableScalingGroupResponse {
	s.Body = v
	return s
}

type EnableAlarmRequest struct {
	// The ID of the request.
	AlarmTaskId *string `json:"AlarmTaskId,omitempty" xml:"AlarmTaskId,omitempty"`
	OwnerId     *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the event-triggered task.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
}

func (s EnableAlarmRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableAlarmRequest) GoString() string {
	return s.String()
}

func (s *EnableAlarmRequest) SetAlarmTaskId(v string) *EnableAlarmRequest {
	s.AlarmTaskId = &v
	return s
}

func (s *EnableAlarmRequest) SetOwnerId(v int64) *EnableAlarmRequest {
	s.OwnerId = &v
	return s
}

func (s *EnableAlarmRequest) SetRegionId(v string) *EnableAlarmRequest {
	s.RegionId = &v
	return s
}

func (s *EnableAlarmRequest) SetResourceOwnerAccount(v string) *EnableAlarmRequest {
	s.ResourceOwnerAccount = &v
	return s
}

type EnableAlarmResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EnableAlarmResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableAlarmResponseBody) GoString() string {
	return s.String()
}

func (s *EnableAlarmResponseBody) SetRequestId(v string) *EnableAlarmResponseBody {
	s.RequestId = &v
	return s
}

type EnableAlarmResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EnableAlarmResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EnableAlarmResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableAlarmResponse) GoString() string {
	return s.String()
}

func (s *EnableAlarmResponse) SetHeaders(v map[string]*string) *EnableAlarmResponse {
	s.Headers = v
	return s
}

func (s *EnableAlarmResponse) SetStatusCode(v int32) *EnableAlarmResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableAlarmResponse) SetBody(v *EnableAlarmResponseBody) *EnableAlarmResponse {
	s.Body = v
	return s
}

type EnableScalingGroupRequest struct {
	// The ID of the scaling configuration that you want to put into the Active state.
	ActiveScalingConfigurationId *string `json:"ActiveScalingConfigurationId,omitempty" xml:"ActiveScalingConfigurationId,omitempty"`
	// The IDs of ECS instances that you want to add to the scaling group after you enable the scaling group.
	//
	// The ECS instances must meet the following requirements:
	//
	// *   The instances and the scaling group must reside in the same region.
	// *   The instances must be in the Running state.
	// *   The instances are not added to other scaling groups.
	// *   The instances must use the subscription or pay-as-you-go billing method or be preemptible instances.
	// *   If you specify the VswitchID parameter for the scaling group, the instances must reside in the same virtual private cloud (VPC) as the specified vSwitch. You cannot add instances that reside in the classic network or other VPCs to the scaling group.
	// *   If you do not specify the VswitchID parameter for the scaling group, you cannot add instances that reside in VPCs to the scaling group.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The ID of the launch template that is used by Auto Scaling to create ECS instances.
	LaunchTemplateId *string `json:"LaunchTemplateId,omitempty" xml:"LaunchTemplateId,omitempty"`
	// Details of the instance types that are specified in the extended configurations of the launch template.
	LaunchTemplateOverrides []*EnableScalingGroupRequestLaunchTemplateOverrides `json:"LaunchTemplateOverrides,omitempty" xml:"LaunchTemplateOverrides,omitempty" type:"Repeated"`
	// The version number of the launch template. Valid values:
	//
	// *   A fixed template version number.
	// *   Default: The default template version is always used.
	// *   Latest: The latest template version is always used.
	LaunchTemplateVersion *string `json:"LaunchTemplateVersion,omitempty" xml:"LaunchTemplateVersion,omitempty"`
	// The weight of an ECS instance as a backend server in the associated vServer group.
	//
	// Default value: 50.
	LoadBalancerWeights []*int32 `json:"LoadBalancerWeights,omitempty" xml:"LoadBalancerWeights,omitempty" type:"Repeated"`
	OwnerAccount        *string  `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId             *int64   `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s EnableScalingGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableScalingGroupRequest) GoString() string {
	return s.String()
}

func (s *EnableScalingGroupRequest) SetActiveScalingConfigurationId(v string) *EnableScalingGroupRequest {
	s.ActiveScalingConfigurationId = &v
	return s
}

func (s *EnableScalingGroupRequest) SetInstanceIds(v []*string) *EnableScalingGroupRequest {
	s.InstanceIds = v
	return s
}

func (s *EnableScalingGroupRequest) SetLaunchTemplateId(v string) *EnableScalingGroupRequest {
	s.LaunchTemplateId = &v
	return s
}

func (s *EnableScalingGroupRequest) SetLaunchTemplateOverrides(v []*EnableScalingGroupRequestLaunchTemplateOverrides) *EnableScalingGroupRequest {
	s.LaunchTemplateOverrides = v
	return s
}

func (s *EnableScalingGroupRequest) SetLaunchTemplateVersion(v string) *EnableScalingGroupRequest {
	s.LaunchTemplateVersion = &v
	return s
}

func (s *EnableScalingGroupRequest) SetLoadBalancerWeights(v []*int32) *EnableScalingGroupRequest {
	s.LoadBalancerWeights = v
	return s
}

func (s *EnableScalingGroupRequest) SetOwnerAccount(v string) *EnableScalingGroupRequest {
	s.OwnerAccount = &v
	return s
}

func (s *EnableScalingGroupRequest) SetOwnerId(v int64) *EnableScalingGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *EnableScalingGroupRequest) SetRegionId(v string) *EnableScalingGroupRequest {
	s.RegionId = &v
	return s
}

func (s *EnableScalingGroupRequest) SetResourceOwnerAccount(v string) *EnableScalingGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *EnableScalingGroupRequest) SetResourceOwnerId(v int64) *EnableScalingGroupRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *EnableScalingGroupRequest) SetScalingGroupId(v string) *EnableScalingGroupRequest {
	s.ScalingGroupId = &v
	return s
}

type EnableScalingGroupRequestLaunchTemplateOverrides struct {
	// The instance type. The instance type that you specify by using the InstanceType parameter overwrites the instance type that is specified in the launch template.
	//
	// If you want Auto Scaling to scale instances in the scaling group based on the instance type weight, you must specify both the InstanceType parameter and the WeightedCapacity parameter.
	//
	// > This parameter takes effect only after you specify the LaunchTemplateId parameter.
	//
	// You can use the InstanceType parameter to specify only instance types that are available for purchase.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The weight of the instance type. The weight specifies the capacity of a single instance of the specified instance type in the scaling group. If you want Auto Scaling to scale instances in the scaling group based on the weighted capacity of instances, you must specify the WeightedCapacity parameter after you specify the InstanceType parameter.
	//
	// A higher weight specifies that a smaller number of instances of the specified instance type are required to meet the expected capacity requirement.
	//
	// Performance metrics, such as the number of vCPUs and the memory size of each instance type, may vary. You can specify different weights for different instance types based on your business requirements.
	//
	// Example:
	//
	// *   Current capacity: 0
	// *   Expected capacity: 6
	// *   Capacity of ecs.c5.xlarge: 4
	//
	// To meet the expected capacity requirement, Auto Scaling must create and add two ecs.c5.xlarge instances.
	//
	// > The capacity of the scaling group cannot exceed the sum of the maximum number of instances that is specified by the MaxSize parameter and the maximum weight of the instance types.
	//
	// Valid values of the WeightedCapacity parameter: 1 to 500.
	WeightedCapacity *int32 `json:"WeightedCapacity,omitempty" xml:"WeightedCapacity,omitempty"`
}

func (s EnableScalingGroupRequestLaunchTemplateOverrides) String() string {
	return tea.Prettify(s)
}

func (s EnableScalingGroupRequestLaunchTemplateOverrides) GoString() string {
	return s.String()
}

func (s *EnableScalingGroupRequestLaunchTemplateOverrides) SetInstanceType(v string) *EnableScalingGroupRequestLaunchTemplateOverrides {
	s.InstanceType = &v
	return s
}

func (s *EnableScalingGroupRequestLaunchTemplateOverrides) SetWeightedCapacity(v int32) *EnableScalingGroupRequestLaunchTemplateOverrides {
	s.WeightedCapacity = &v
	return s
}

type EnableScalingGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EnableScalingGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableScalingGroupResponseBody) GoString() string {
	return s.String()
}

func (s *EnableScalingGroupResponseBody) SetRequestId(v string) *EnableScalingGroupResponseBody {
	s.RequestId = &v
	return s
}

type EnableScalingGroupResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EnableScalingGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EnableScalingGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableScalingGroupResponse) GoString() string {
	return s.String()
}

func (s *EnableScalingGroupResponse) SetHeaders(v map[string]*string) *EnableScalingGroupResponse {
	s.Headers = v
	return s
}

func (s *EnableScalingGroupResponse) SetStatusCode(v int32) *EnableScalingGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableScalingGroupResponse) SetBody(v *EnableScalingGroupResponseBody) *EnableScalingGroupResponse {
	s.Body = v
	return s
}

type EnterStandbyRequest struct {
	// Specifies whether to asynchronously set the ECS instances to the Standby state. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	Async *bool `json:"Async,omitempty" xml:"Async,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that the value is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The IDs of the ECS instances.
	InstanceIds          []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	OwnerId              *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s EnterStandbyRequest) String() string {
	return tea.Prettify(s)
}

func (s EnterStandbyRequest) GoString() string {
	return s.String()
}

func (s *EnterStandbyRequest) SetAsync(v bool) *EnterStandbyRequest {
	s.Async = &v
	return s
}

func (s *EnterStandbyRequest) SetClientToken(v string) *EnterStandbyRequest {
	s.ClientToken = &v
	return s
}

func (s *EnterStandbyRequest) SetInstanceIds(v []*string) *EnterStandbyRequest {
	s.InstanceIds = v
	return s
}

func (s *EnterStandbyRequest) SetOwnerId(v int64) *EnterStandbyRequest {
	s.OwnerId = &v
	return s
}

func (s *EnterStandbyRequest) SetResourceOwnerAccount(v string) *EnterStandbyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *EnterStandbyRequest) SetScalingGroupId(v string) *EnterStandbyRequest {
	s.ScalingGroupId = &v
	return s
}

type EnterStandbyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the scaling activity.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s EnterStandbyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnterStandbyResponseBody) GoString() string {
	return s.String()
}

func (s *EnterStandbyResponseBody) SetRequestId(v string) *EnterStandbyResponseBody {
	s.RequestId = &v
	return s
}

func (s *EnterStandbyResponseBody) SetScalingActivityId(v string) *EnterStandbyResponseBody {
	s.ScalingActivityId = &v
	return s
}

type EnterStandbyResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EnterStandbyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EnterStandbyResponse) String() string {
	return tea.Prettify(s)
}

func (s EnterStandbyResponse) GoString() string {
	return s.String()
}

func (s *EnterStandbyResponse) SetHeaders(v map[string]*string) *EnterStandbyResponse {
	s.Headers = v
	return s
}

func (s *EnterStandbyResponse) SetStatusCode(v int32) *EnterStandbyResponse {
	s.StatusCode = &v
	return s
}

func (s *EnterStandbyResponse) SetBody(v *EnterStandbyResponseBody) *EnterStandbyResponse {
	s.Body = v
	return s
}

type ExecuteScalingRuleRequest struct {
	// The metric value specified when the step scaling rule is executed. Valid values: -9.999999E18 to 9.999999E18.
	BreachThreshold *float32 `json:"BreachThreshold,omitempty" xml:"BreachThreshold,omitempty"`
	// The threshold specified when the step scaling rule is executed. Valid values: -9.999999E18 to 9.999999E18.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The region ID of the scaling group.
	MetricValue  *float32 `json:"MetricValue,omitempty" xml:"MetricValue,omitempty"`
	OwnerAccount *string  `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64   `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the scaling activity.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).
	ScalingRuleAri *string `json:"ScalingRuleAri,omitempty" xml:"ScalingRuleAri,omitempty"`
}

func (s ExecuteScalingRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s ExecuteScalingRuleRequest) GoString() string {
	return s.String()
}

func (s *ExecuteScalingRuleRequest) SetBreachThreshold(v float32) *ExecuteScalingRuleRequest {
	s.BreachThreshold = &v
	return s
}

func (s *ExecuteScalingRuleRequest) SetClientToken(v string) *ExecuteScalingRuleRequest {
	s.ClientToken = &v
	return s
}

func (s *ExecuteScalingRuleRequest) SetMetricValue(v float32) *ExecuteScalingRuleRequest {
	s.MetricValue = &v
	return s
}

func (s *ExecuteScalingRuleRequest) SetOwnerAccount(v string) *ExecuteScalingRuleRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ExecuteScalingRuleRequest) SetOwnerId(v int64) *ExecuteScalingRuleRequest {
	s.OwnerId = &v
	return s
}

func (s *ExecuteScalingRuleRequest) SetRegionId(v string) *ExecuteScalingRuleRequest {
	s.RegionId = &v
	return s
}

func (s *ExecuteScalingRuleRequest) SetResourceOwnerAccount(v string) *ExecuteScalingRuleRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ExecuteScalingRuleRequest) SetResourceOwnerId(v int64) *ExecuteScalingRuleRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ExecuteScalingRuleRequest) SetScalingRuleAri(v string) *ExecuteScalingRuleRequest {
	s.ScalingRuleAri = &v
	return s
}

type ExecuteScalingRuleResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s ExecuteScalingRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ExecuteScalingRuleResponseBody) GoString() string {
	return s.String()
}

func (s *ExecuteScalingRuleResponseBody) SetRequestId(v string) *ExecuteScalingRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *ExecuteScalingRuleResponseBody) SetScalingActivityId(v string) *ExecuteScalingRuleResponseBody {
	s.ScalingActivityId = &v
	return s
}

type ExecuteScalingRuleResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ExecuteScalingRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ExecuteScalingRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s ExecuteScalingRuleResponse) GoString() string {
	return s.String()
}

func (s *ExecuteScalingRuleResponse) SetHeaders(v map[string]*string) *ExecuteScalingRuleResponse {
	s.Headers = v
	return s
}

func (s *ExecuteScalingRuleResponse) SetStatusCode(v int32) *ExecuteScalingRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *ExecuteScalingRuleResponse) SetBody(v *ExecuteScalingRuleResponseBody) *ExecuteScalingRuleResponse {
	s.Body = v
	return s
}

type ExitStandbyRequest struct {
	// The region ID of the scaling group.
	Async *bool `json:"Async,omitempty" xml:"Async,omitempty"`
	// The IDs of the ECS instances. The value of this parameter can be a JSON array that consists of up to 20 instance IDs. Separate multiple instance IDs with commas (,).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The IDs of the ECS instances. The value of this parameter can be a JSON array that consists of up to 20 instance IDs. Separate multiple instance IDs with commas (,).
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	OwnerId     *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s ExitStandbyRequest) String() string {
	return tea.Prettify(s)
}

func (s ExitStandbyRequest) GoString() string {
	return s.String()
}

func (s *ExitStandbyRequest) SetAsync(v bool) *ExitStandbyRequest {
	s.Async = &v
	return s
}

func (s *ExitStandbyRequest) SetClientToken(v string) *ExitStandbyRequest {
	s.ClientToken = &v
	return s
}

func (s *ExitStandbyRequest) SetInstanceIds(v []*string) *ExitStandbyRequest {
	s.InstanceIds = v
	return s
}

func (s *ExitStandbyRequest) SetOwnerId(v int64) *ExitStandbyRequest {
	s.OwnerId = &v
	return s
}

func (s *ExitStandbyRequest) SetRegionId(v string) *ExitStandbyRequest {
	s.RegionId = &v
	return s
}

func (s *ExitStandbyRequest) SetResourceOwnerAccount(v string) *ExitStandbyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ExitStandbyRequest) SetScalingGroupId(v string) *ExitStandbyRequest {
	s.ScalingGroupId = &v
	return s
}

type ExitStandbyResponseBody struct {
	// The ID of the scaling activity.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// auditing
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s ExitStandbyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ExitStandbyResponseBody) GoString() string {
	return s.String()
}

func (s *ExitStandbyResponseBody) SetRequestId(v string) *ExitStandbyResponseBody {
	s.RequestId = &v
	return s
}

func (s *ExitStandbyResponseBody) SetScalingActivityId(v string) *ExitStandbyResponseBody {
	s.ScalingActivityId = &v
	return s
}

type ExitStandbyResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ExitStandbyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ExitStandbyResponse) String() string {
	return tea.Prettify(s)
}

func (s ExitStandbyResponse) GoString() string {
	return s.String()
}

func (s *ExitStandbyResponse) SetHeaders(v map[string]*string) *ExitStandbyResponse {
	s.Headers = v
	return s
}

func (s *ExitStandbyResponse) SetStatusCode(v int32) *ExitStandbyResponse {
	s.StatusCode = &v
	return s
}

func (s *ExitStandbyResponse) SetBody(v *ExitStandbyResponseBody) *ExitStandbyResponse {
	s.Body = v
	return s
}

type ListTagKeysRequest struct {
	// The number of entries to return on each page. Maximum value: 50.
	//
	// Default value: 10.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerId   *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The token that determines the start point of the next query. If this parameter is empty, all results are returned.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The type of the Auto Scaling resource. Set the value to scalinggroup. This indicates that the tags are added to scaling groups.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The token that determines the start point of the next query. If this parameter is empty, all results are returned.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s ListTagKeysRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTagKeysRequest) GoString() string {
	return s.String()
}

func (s *ListTagKeysRequest) SetNextToken(v string) *ListTagKeysRequest {
	s.NextToken = &v
	return s
}

func (s *ListTagKeysRequest) SetOwnerId(v int64) *ListTagKeysRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTagKeysRequest) SetPageSize(v int32) *ListTagKeysRequest {
	s.PageSize = &v
	return s
}

func (s *ListTagKeysRequest) SetRegionId(v string) *ListTagKeysRequest {
	s.RegionId = &v
	return s
}

func (s *ListTagKeysRequest) SetResourceOwnerAccount(v string) *ListTagKeysRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTagKeysRequest) SetResourceType(v string) *ListTagKeysRequest {
	s.ResourceType = &v
	return s
}

type ListTagKeysResponseBody struct {
	// Details of the tag keys.
	Keys []*string `json:"Keys,omitempty" xml:"Keys,omitempty" type:"Repeated"`
	// The ID of the request.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// Details of the tag keys.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The number of entries returned per page.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListTagKeysResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTagKeysResponseBody) GoString() string {
	return s.String()
}

func (s *ListTagKeysResponseBody) SetKeys(v []*string) *ListTagKeysResponseBody {
	s.Keys = v
	return s
}

func (s *ListTagKeysResponseBody) SetNextToken(v string) *ListTagKeysResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTagKeysResponseBody) SetPageSize(v int32) *ListTagKeysResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListTagKeysResponseBody) SetRequestId(v string) *ListTagKeysResponseBody {
	s.RequestId = &v
	return s
}

type ListTagKeysResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTagKeysResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTagKeysResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTagKeysResponse) GoString() string {
	return s.String()
}

func (s *ListTagKeysResponse) SetHeaders(v map[string]*string) *ListTagKeysResponse {
	s.Headers = v
	return s
}

func (s *ListTagKeysResponse) SetStatusCode(v int32) *ListTagKeysResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTagKeysResponse) SetBody(v *ListTagKeysResponseBody) *ListTagKeysResponse {
	s.Body = v
	return s
}

type ListTagResourcesRequest struct {
	// The token that determines the start point of the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerId   *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the Auto Scaling resource. You can call the DescribeRegions operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The IDs of the Auto Scaling resources. You can specify 1 to 50 resource IDs.
	ResourceIds          []*string `json:"ResourceIds,omitempty" xml:"ResourceIds,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The type of the Auto Scaling resource. Only scaling groups are supported. Set the value to scalinggroup.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// Details of the tags.
	Tags []*ListTagResourcesRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s ListTagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequest) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequest) SetNextToken(v string) *ListTagResourcesRequest {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesRequest) SetOwnerId(v int64) *ListTagResourcesRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTagResourcesRequest) SetRegionId(v string) *ListTagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceIds(v []*string) *ListTagResourcesRequest {
	s.ResourceIds = v
	return s
}

func (s *ListTagResourcesRequest) SetResourceOwnerAccount(v string) *ListTagResourcesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceType(v string) *ListTagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesRequest) SetTags(v []*ListTagResourcesRequestTags) *ListTagResourcesRequest {
	s.Tags = v
	return s
}

type ListTagResourcesRequestTags struct {
	// The key of the tag. The key is used to perform an exact match of Auto Scaling resources. The key must be 1 to 128 characters in length.
	//
	// `Tags` is used to perform an exact match of Auto Scaling resources to which the specified tags are added. Specify a tag in the key-value pair format.
	//
	// *   If you specify only `Tags.Key`, all resources whose tags contain the specified tag key are returned.
	// *   If you specify only `Tags.Value`, the `MissingParameter.TagKey` error is reported.
	// *   If you specify multiple key-value pairs at the same time, only Auto Scaling resources that match all the tag keys and tag values are returned.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag. The value is used to perform an exact match of Auto Scaling resources. The value can be up to 128 characters in length.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTagResourcesRequestTags) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequestTags) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequestTags) SetKey(v string) *ListTagResourcesRequestTags {
	s.Key = &v
	return s
}

func (s *ListTagResourcesRequestTags) SetValue(v string) *ListTagResourcesRequestTags {
	s.Value = &v
	return s
}

type ListTagResourcesResponseBody struct {
	// The token that determines the start point of the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Details of the resource and tags, such as the resource ID, the resource type, tag keys, and tag values.
	TagResources []*ListTagResourcesResponseBodyTagResources `json:"TagResources,omitempty" xml:"TagResources,omitempty" type:"Repeated"`
}

func (s ListTagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBody) SetNextToken(v string) *ListTagResourcesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetRequestId(v string) *ListTagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetTagResources(v []*ListTagResourcesResponseBodyTagResources) *ListTagResourcesResponseBody {
	s.TagResources = v
	return s
}

type ListTagResourcesResponseBodyTagResources struct {
	// Indicates whether the tag can be propagated.
	//
	// *   true: The tag can be propagated only to instances that are to be added to the scaling group. The tag cannot be propagated to instances that are already running in the scaling group.
	// *   false: The tag cannot be propagated to an instance.
	Propagate *bool `json:"Propagate,omitempty" xml:"Propagate,omitempty"`
	// The ID of the resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The key of the tag.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The value of the tag.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s ListTagResourcesResponseBodyTagResources) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResources) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResources) SetPropagate(v bool) *ListTagResourcesResponseBodyTagResources {
	s.Propagate = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResources) SetResourceId(v string) *ListTagResourcesResponseBodyTagResources {
	s.ResourceId = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResources) SetResourceType(v string) *ListTagResourcesResponseBodyTagResources {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResources) SetTagKey(v string) *ListTagResourcesResponseBodyTagResources {
	s.TagKey = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResources) SetTagValue(v string) *ListTagResourcesResponseBodyTagResources {
	s.TagValue = &v
	return s
}

type ListTagResourcesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponse) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponse) SetHeaders(v map[string]*string) *ListTagResourcesResponse {
	s.Headers = v
	return s
}

func (s *ListTagResourcesResponse) SetStatusCode(v int32) *ListTagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTagResourcesResponse) SetBody(v *ListTagResourcesResponseBody) *ListTagResourcesResponse {
	s.Body = v
	return s
}

type ListTagValuesRequest struct {
	// The token that determines the start point of the next query. If this parameter is empty, all results are returned.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The number of entries to return on each page. Maximum value: 50.
	//
	// Default value: 10.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerId   *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The key of the tag.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The type of the Auto Scaling resource. Set the value to scalinggroup. This indicates that the tag is added to a scaling group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The token that determines the start point of the next query. If this parameter is empty, all results are returned.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s ListTagValuesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTagValuesRequest) GoString() string {
	return s.String()
}

func (s *ListTagValuesRequest) SetKey(v string) *ListTagValuesRequest {
	s.Key = &v
	return s
}

func (s *ListTagValuesRequest) SetNextToken(v string) *ListTagValuesRequest {
	s.NextToken = &v
	return s
}

func (s *ListTagValuesRequest) SetOwnerId(v int64) *ListTagValuesRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTagValuesRequest) SetPageSize(v int32) *ListTagValuesRequest {
	s.PageSize = &v
	return s
}

func (s *ListTagValuesRequest) SetRegionId(v string) *ListTagValuesRequest {
	s.RegionId = &v
	return s
}

func (s *ListTagValuesRequest) SetResourceOwnerAccount(v string) *ListTagValuesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTagValuesRequest) SetResourceType(v string) *ListTagValuesRequest {
	s.ResourceType = &v
	return s
}

type ListTagValuesResponseBody struct {
	// The ID of the request.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// Details of the tag values.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The number of entries returned per page.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Details of the tag values.
	Values []*string `json:"Values,omitempty" xml:"Values,omitempty" type:"Repeated"`
}

func (s ListTagValuesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTagValuesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTagValuesResponseBody) SetNextToken(v string) *ListTagValuesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTagValuesResponseBody) SetPageSize(v int32) *ListTagValuesResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListTagValuesResponseBody) SetRequestId(v string) *ListTagValuesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTagValuesResponseBody) SetValues(v []*string) *ListTagValuesResponseBody {
	s.Values = v
	return s
}

type ListTagValuesResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTagValuesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTagValuesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTagValuesResponse) GoString() string {
	return s.String()
}

func (s *ListTagValuesResponse) SetHeaders(v map[string]*string) *ListTagValuesResponse {
	s.Headers = v
	return s
}

func (s *ListTagValuesResponse) SetStatusCode(v int32) *ListTagValuesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTagValuesResponse) SetBody(v *ListTagValuesResponseBody) *ListTagValuesResponse {
	s.Body = v
	return s
}

type ModifyAlarmRequest struct {
	// The list of unique identifiers of the scaling rules that are associated with the event-triggered task.
	AlarmActions []*string `json:"AlarmActions,omitempty" xml:"AlarmActions,omitempty" type:"Repeated"`
	// The name of the event-triggered task.
	AlarmTaskId *string `json:"AlarmTaskId,omitempty" xml:"AlarmTaskId,omitempty"`
	// The number of times that the threshold must be reached before a scaling rule can be executed. For example, if you set this parameter to 3, the average CPU utilization must reach or exceed 80% three times in a row before a scaling rule is triggered.
	ComparisonOperator *string `json:"ComparisonOperator,omitempty" xml:"ComparisonOperator,omitempty"`
	// The name of the metric. The valid values vary based on the metric type.
	//
	// *   If you set the MetricType parameter to custom, the valid values are your custom metrics.
	//
	// *   If you set the MetricType parameter to system, the MetricName parameter has the following valid values:
	//
	//     *   CpuUtilization: the CPU utilization of an ECS instance. Unit: %.
	//     *   IntranetTx: the outbound traffic over the internal network from an ECS instance. Unit: KB/min.
	//     *   IntranetRx: the inbound traffic over the Internet to an ECS instance that resides in a virtual private cloud (VPC). Unit: KB/min.
	//     *   VpcInternetTx: the outbound traffic over the Internet from an ECS instance that resides in a VPC. Unit: KB/min.
	//     *   VpcInternetRx: the inbound traffic over the Internet to an ECS instance that resides in a VPC. Unit: KB/min.
	//     *   SystemDiskReadBps: the number of bytes read from the system disk used by an ECS instance per second.
	//     *   SystemDiskWriteBps: the number of bytes written to the system disk used by an ECS instance per second.
	//     *   SystemDiskReadOps: the number of read operations on the system disk used by an ECS instance per second.
	//     *   SystemDiskWriteOps: the number of write operations on the system disk used by an ECS instance per second.
	//     *   CpuUtilizationAgent: the CPU utilization of an agent. Unit: %.
	//     *   GpuMemoryFreeUtilizationAgent: the percentage of idle GPU memory of an agent.
	//     *   GpuMemoryUtilizationAgent: the GPU memory usage of an agent. Unit: %.
	//     *   MemoryUtilization: the memory usage of an agent. Unit: %.
	//     *   LoadAverage: the average system load of an agent.
	//     *   TcpConnection: the total number of TCP connections of an agent.
	//     *   TcpConnection: the number of established TCP connections of an agent.
	//     *   PackagesNetOut: the number of packets that are sent by the internal network interface controller (NIC) used by an agent.
	//     *   PackagesNetIn: the number of packets that are received by the internal NIC used by an agent.
	//     *   EciPodCpuUtilization: the CPU utilization of an elastic container instance. Unit: %.
	//     *   EciPodMemoryUtilization: the memory usage of an elastic container instance. Unit: %.
	//
	// For more information, see [Event-triggered task for system monitoring](~~74854~~).
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Details of the dimensions.
	Dimensions []*ModifyAlarmRequestDimensions `json:"Dimensions,omitempty" xml:"Dimensions,omitempty" type:"Repeated"`
	// The list of unique identifiers of the scaling rules that are associated with the event-triggered task.
	Effective *string `json:"Effective,omitempty" xml:"Effective,omitempty"`
	// The ID of the application group to which the custom metric belongs. If you set the MetricType parameter to custom, you must specify this parameter.
	EvaluationCount *int32 `json:"EvaluationCount,omitempty" xml:"EvaluationCount,omitempty"`
	// The expressions that are specified in the multi-metric alert rule.
	Expressions []*ModifyAlarmRequestExpressions `json:"Expressions,omitempty" xml:"Expressions,omitempty" type:"Repeated"`
	// The ID of the event-triggered task.
	ExpressionsLogicOperator *string `json:"ExpressionsLogicOperator,omitempty" xml:"ExpressionsLogicOperator,omitempty"`
	// The effective period of the event-triggered task.
	//
	// This parameter follows the cron expression format. The default format is `X X X X X ?`, in which:
	//
	// *   X: a placeholder for a field, which represents seconds, minutes, hours, days, and months in sequence. X can be a definite value or a special character that has logical meaning. For information about the valid values of X, see [Cron expression](~~25907~~).
	// *   ?: No value is specified.
	//
	// > By default, the value of this parameter is specified in **UTC+8**. You can specify the time zone in the `TZ=+yy` format before a cron expression. y indicates the time zone. For example, `TZ=+00 * * 1-2 * * ?` specifies that the event-triggered task is in effect between 01:00 and 02:59 (UTC+0) every day.
	//
	// Examples:
	//
	// *   ` * * * * * ?  `: The event-triggered task is in effect all the time.
	// *   ` * * 17-18 * * ?  `: The event-triggered task is in effect between 17:00 and 18:59 (UTC+8) every day.
	// *   `TZ=+00 * * 1-2 * * ?`: The event-triggered task is in effect between 01:00 and 02:59 (UTC+0) every day.
	GroupId *int32 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The type of the metric. Valid values:
	//
	// *   system: system metrics of CloudMonitor
	// *   custom: custom metrics that are reported to CloudMonitor
	MetricName *string `json:"MetricName,omitempty" xml:"MetricName,omitempty"`
	// The period of time during which statistics about the metric is collected. Unit: seconds. Valid values:
	//
	// *   15
	// *   60
	// *   120
	// *   300
	// *   900
	//
	// > If your scaling group is of the ECS type and uses CloudMonitor metrics, you can set the Period parameter to 15. In other cases, you can set the Period parameter to 60, 120, 300, or 900. In most cases, the name of a CloudMonitor metric contains Agent.
	MetricType *string `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
	// The description of the event-triggered task.
	Name    *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The method that is used to aggregate statistics for the metric. Valid values:
	//
	// *   Average
	// *   Minimum
	// *   Maximum
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The ID of the event-triggered task.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The thresholds of the metric values in the multi-metric alert rule. If the thresholds are reached the specified number of times within the specified period, a scaling rule is executed.
	Statistics *string `json:"Statistics,omitempty" xml:"Statistics,omitempty"`
	// The operator that is used to compare the metric value and the threshold. Valid values:
	//
	// *   If the metric value is greater than or equal to the threshold, set the value to `>=`.
	// *   If the metric value is less than or equal to the threshold, set the value to `<=`.
	// *   If the metric value is greater than the threshold, set the value to `>`.
	// *   If the metric value is less than the threshold, set the value to `<`.
	Threshold *float32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s ModifyAlarmRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyAlarmRequest) GoString() string {
	return s.String()
}

func (s *ModifyAlarmRequest) SetAlarmActions(v []*string) *ModifyAlarmRequest {
	s.AlarmActions = v
	return s
}

func (s *ModifyAlarmRequest) SetAlarmTaskId(v string) *ModifyAlarmRequest {
	s.AlarmTaskId = &v
	return s
}

func (s *ModifyAlarmRequest) SetComparisonOperator(v string) *ModifyAlarmRequest {
	s.ComparisonOperator = &v
	return s
}

func (s *ModifyAlarmRequest) SetDescription(v string) *ModifyAlarmRequest {
	s.Description = &v
	return s
}

func (s *ModifyAlarmRequest) SetDimensions(v []*ModifyAlarmRequestDimensions) *ModifyAlarmRequest {
	s.Dimensions = v
	return s
}

func (s *ModifyAlarmRequest) SetEffective(v string) *ModifyAlarmRequest {
	s.Effective = &v
	return s
}

func (s *ModifyAlarmRequest) SetEvaluationCount(v int32) *ModifyAlarmRequest {
	s.EvaluationCount = &v
	return s
}

func (s *ModifyAlarmRequest) SetExpressions(v []*ModifyAlarmRequestExpressions) *ModifyAlarmRequest {
	s.Expressions = v
	return s
}

func (s *ModifyAlarmRequest) SetExpressionsLogicOperator(v string) *ModifyAlarmRequest {
	s.ExpressionsLogicOperator = &v
	return s
}

func (s *ModifyAlarmRequest) SetGroupId(v int32) *ModifyAlarmRequest {
	s.GroupId = &v
	return s
}

func (s *ModifyAlarmRequest) SetMetricName(v string) *ModifyAlarmRequest {
	s.MetricName = &v
	return s
}

func (s *ModifyAlarmRequest) SetMetricType(v string) *ModifyAlarmRequest {
	s.MetricType = &v
	return s
}

func (s *ModifyAlarmRequest) SetName(v string) *ModifyAlarmRequest {
	s.Name = &v
	return s
}

func (s *ModifyAlarmRequest) SetOwnerId(v int64) *ModifyAlarmRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyAlarmRequest) SetPeriod(v int32) *ModifyAlarmRequest {
	s.Period = &v
	return s
}

func (s *ModifyAlarmRequest) SetRegionId(v string) *ModifyAlarmRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyAlarmRequest) SetResourceOwnerAccount(v string) *ModifyAlarmRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyAlarmRequest) SetStatistics(v string) *ModifyAlarmRequest {
	s.Statistics = &v
	return s
}

func (s *ModifyAlarmRequest) SetThreshold(v float32) *ModifyAlarmRequest {
	s.Threshold = &v
	return s
}

type ModifyAlarmRequestDimensions struct {
	// The value of the dimension. The valid values vary based on the value of the DimensionKey parameter.
	//
	// *   If you set the MetricType parameter to custom, you can specify this parameter based on your business requirements.
	//
	// *   If you set the MetricType parameter to system, this parameter has the following valid values:
	//
	//     *   If you set the DimensionKey parameter to user_id, the system specifies the value
	//
	//     *   scaling_group: The system specifies the value of the DimensionValue parameter.
	//
	//     *   If you set the DimensionKey parameter to device, you can set the DimensionValue parameter to eth0 or eth1.
	//
	//         *   For instances that reside in the classic network type, eth0 specifies the internal NIC. Only one eth0 NIC exists on each instance that resides in a VPC.
	//         *   For instances that reside in the classic network, eth1 specifies the public NIC.
	//
	//     *   If you set the DimensionKey parameter to state, you can set the DimensionValue parameter to TCP_TOTAL or ESTABLISHED.
	//
	//         *   TCP_TOTAL specifies the total number of TCP connections.
	//         *   ESTABLISHED specifies the number of established TCP connections.
	DimensionKey *string `json:"DimensionKey,omitempty" xml:"DimensionKey,omitempty"`
	// The expressions that are specified in the multi-metric alert rule.
	DimensionValue *string `json:"DimensionValue,omitempty" xml:"DimensionValue,omitempty"`
}

func (s ModifyAlarmRequestDimensions) String() string {
	return tea.Prettify(s)
}

func (s ModifyAlarmRequestDimensions) GoString() string {
	return s.String()
}

func (s *ModifyAlarmRequestDimensions) SetDimensionKey(v string) *ModifyAlarmRequestDimensions {
	s.DimensionKey = &v
	return s
}

func (s *ModifyAlarmRequestDimensions) SetDimensionValue(v string) *ModifyAlarmRequestDimensions {
	s.DimensionValue = &v
	return s
}

type ModifyAlarmRequestExpressions struct {
	// The period of time during which statistics about the metrics in the multi-metric alert rule is collected. Unit: seconds. Valid values:
	//
	// *   15
	// *   60
	// *   120
	// *   300
	// *   900
	//
	// > If your scaling group is of the ECS type and the event-triggered task associated with your scaling group monitors CloudMonitor metrics, you can set the Period parameter to 15. In other cases, you can set the Period parameter to 60, 120, 300, or 900. In most cases, the name of a CloudMonitor metric contains Agent.
	//
	// Default value: 300.
	ComparisonOperator *string `json:"ComparisonOperator,omitempty" xml:"ComparisonOperator,omitempty"`
	// The operator that is used to compare the metric value and the threshold. Valid values:
	//
	// *   If the metric value is greater than or equal to the threshold, set the value to `>=`.
	// *   If the metric value is less than or equal to the threshold, set the value to `<=`.
	// *   If the metric value is greater than the threshold, set the value to `>`.
	// *   If the metric value is less than the threshold, set the value to `<`.
	//
	// Default value: >=.
	MetricName *string `json:"MetricName,omitempty" xml:"MetricName,omitempty"`
	// The method that is used to aggregate statistics about the metrics that are specified in the multi-metric alert rule. Valid values:
	//
	// *   Average
	// *   Minimum
	// *   Maximum
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The thresholds of the metric values in the multi-metric alert rule. If the thresholds are reached the specified number of times within the specified period, a scaling rule is executed.
	Statistics *string `json:"Statistics,omitempty" xml:"Statistics,omitempty"`
	// The relationship between the trigger conditions in the multi-metric alert rule. Valid values:
	//
	// *   `&&`: An alert is triggered only if all metrics in the multi-metric alert rule meet the trigger conditions. In this case, an alert is triggered only if the results of all trigger conditions that are specified in the multi-metric alert rule are `true`.
	// *   \`\`: An alert is triggered if one of the metrics in the multi-metric alert rule meets the trigger condition.
	//
	// Default value: `&&`.
	Threshold *float32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s ModifyAlarmRequestExpressions) String() string {
	return tea.Prettify(s)
}

func (s ModifyAlarmRequestExpressions) GoString() string {
	return s.String()
}

func (s *ModifyAlarmRequestExpressions) SetComparisonOperator(v string) *ModifyAlarmRequestExpressions {
	s.ComparisonOperator = &v
	return s
}

func (s *ModifyAlarmRequestExpressions) SetMetricName(v string) *ModifyAlarmRequestExpressions {
	s.MetricName = &v
	return s
}

func (s *ModifyAlarmRequestExpressions) SetPeriod(v int32) *ModifyAlarmRequestExpressions {
	s.Period = &v
	return s
}

func (s *ModifyAlarmRequestExpressions) SetStatistics(v string) *ModifyAlarmRequestExpressions {
	s.Statistics = &v
	return s
}

func (s *ModifyAlarmRequestExpressions) SetThreshold(v float32) *ModifyAlarmRequestExpressions {
	s.Threshold = &v
	return s
}

type ModifyAlarmResponseBody struct {
	// The ID of the request.
	AlarmTaskId *string `json:"AlarmTaskId,omitempty" xml:"AlarmTaskId,omitempty"`
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyAlarmResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyAlarmResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyAlarmResponseBody) SetAlarmTaskId(v string) *ModifyAlarmResponseBody {
	s.AlarmTaskId = &v
	return s
}

func (s *ModifyAlarmResponseBody) SetRequestId(v string) *ModifyAlarmResponseBody {
	s.RequestId = &v
	return s
}

type ModifyAlarmResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyAlarmResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyAlarmResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyAlarmResponse) GoString() string {
	return s.String()
}

func (s *ModifyAlarmResponse) SetHeaders(v map[string]*string) *ModifyAlarmResponse {
	s.Headers = v
	return s
}

func (s *ModifyAlarmResponse) SetStatusCode(v int32) *ModifyAlarmResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyAlarmResponse) SetBody(v *ModifyAlarmResponseBody) *ModifyAlarmResponse {
	s.Body = v
	return s
}

type ModifyEciScalingConfigurationRequest struct {
	// Information about the Container Registry Enterprise Edition instance.
	AcrRegistryInfos []*ModifyEciScalingConfigurationRequestAcrRegistryInfos `json:"AcrRegistryInfos,omitempty" xml:"AcrRegistryInfos,omitempty" type:"Repeated"`
	// The validity period. Unit: seconds.
	ActiveDeadlineSeconds *int64 `json:"ActiveDeadlineSeconds,omitempty" xml:"ActiveDeadlineSeconds,omitempty"`
	// Specifies whether to automatically create an elastic IP address (EIP) and bind the EIP to the elastic container instance.
	AutoCreateEip *bool `json:"AutoCreateEip,omitempty" xml:"AutoCreateEip,omitempty"`
	// Specifies whether to automatically match the image cache.
	//
	// Default value: false.
	AutoMatchImageCache *bool `json:"AutoMatchImageCache,omitempty" xml:"AutoMatchImageCache,omitempty"`
	// The name of the elastic container instance. The name must meet the following requirements:
	//
	// *   The name must be 2 to 128 characters in length
	// *   The name can contain only lowercase letters, digits, and hyphens (-). It cannot start or end with a hyphen (-).
	ContainerGroupName *string `json:"ContainerGroupName,omitempty" xml:"ContainerGroupName,omitempty"`
	// The containers.
	Containers           []*ModifyEciScalingConfigurationRequestContainers `json:"Containers,omitempty" xml:"Containers,omitempty" type:"Repeated"`
	ContainersUpdateType *string                                           `json:"ContainersUpdateType,omitempty" xml:"ContainersUpdateType,omitempty"`
	// Specifies whether to enable the cost optimization feature. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	CostOptimization *bool `json:"CostOptimization,omitempty" xml:"CostOptimization,omitempty"`
	// The number of vCPUs of the elastic container instance.
	Cpu *float32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The number of physical CPU cores. This parameter is not available for all instance types. For more information, see [Specify custom CPU options](~~197781~~).
	CpuOptionsCore *int32 `json:"CpuOptionsCore,omitempty" xml:"CpuOptionsCore,omitempty"`
	// The number of threads per core. This parameter is not available for all instance types. A value of 1 indicates that Hyper-Threading is disabled. For more information, see [Specify custom CPU options](~~197781~~).
	CpuOptionsThreadsPerCore *int32 `json:"CpuOptionsThreadsPerCore,omitempty" xml:"CpuOptionsThreadsPerCore,omitempty"`
	// > This parameter is unavailable.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The IP addresses of the DNS servers.
	DnsConfigNameServers []*string `json:"DnsConfigNameServers,omitempty" xml:"DnsConfigNameServers,omitempty" type:"Repeated"`
	// The options. Each option is a name-value pair. The value in the name-value pair is optional.
	DnsConfigOptions []*ModifyEciScalingConfigurationRequestDnsConfigOptions `json:"DnsConfigOptions,omitempty" xml:"DnsConfigOptions,omitempty" type:"Repeated"`
	// The DNS lookup domains.
	DnsConfigSearchs []*string `json:"DnsConfigSearchs,omitempty" xml:"DnsConfigSearchs,omitempty" type:"Repeated"`
	// The Domain Name System (DNS) policy. Valid values:
	//
	// *   None: uses the DNS that is set for the DnsConfig field.
	// *   Default: use the DNS that is set for the runtime environment.
	DnsPolicy *string `json:"DnsPolicy,omitempty" xml:"DnsPolicy,omitempty"`
	// The maximum outbound bandwidth. Unit: bit/s.
	EgressBandwidth *int64 `json:"EgressBandwidth,omitempty" xml:"EgressBandwidth,omitempty"`
	// The bandwidth of the EIP.
	//
	// Default value: 5. Unit: Mbit/s.
	EipBandwidth *int32 `json:"EipBandwidth,omitempty" xml:"EipBandwidth,omitempty"`
	// > This parameter is unavailable.
	EnableSls *bool `json:"EnableSls,omitempty" xml:"EnableSls,omitempty"`
	// The size of the temporary storage space. By default, an enhanced SSD (ESSD) of the PL1 level is used. Unit: GiB.
	EphemeralStorage *int32 `json:"EphemeralStorage,omitempty" xml:"EphemeralStorage,omitempty"`
	// Information about the hosts.
	HostAliases []*ModifyEciScalingConfigurationRequestHostAliases `json:"HostAliases,omitempty" xml:"HostAliases,omitempty" type:"Repeated"`
	// The name of the elastic container instance.
	HostName *string `json:"HostName,omitempty" xml:"HostName,omitempty"`
	// Information about the image repository.
	ImageRegistryCredentials []*ModifyEciScalingConfigurationRequestImageRegistryCredentials `json:"ImageRegistryCredentials,omitempty" xml:"ImageRegistryCredentials,omitempty" type:"Repeated"`
	// The ID of the image cache.
	ImageSnapshotId *string `json:"ImageSnapshotId,omitempty" xml:"ImageSnapshotId,omitempty"`
	// The maximum inbound bandwidth. Unit: bit/s.
	IngressBandwidth *int64 `json:"IngressBandwidth,omitempty" xml:"IngressBandwidth,omitempty"`
	// The init containers.
	InitContainers []*ModifyEciScalingConfigurationRequestInitContainers `json:"InitContainers,omitempty" xml:"InitContainers,omitempty" type:"Repeated"`
	// The level of the instance type, which is used to filter the instance types that meet the specified criteria. This parameter takes effect only if you set the `CostOptimization` parameter to true. Valid values:
	//
	// *   EntryLevel: shared instance type. Instances of this level are the most cost-effective but may not provide stable computing performance in a consistent manner. Instances of this level are suitable for business scenarios in which the CPU utilization is low. For more information, see [Shared instance families](~~108489~~).
	// *   EnterpriseLevel: Instances of this level provide stable performance and dedicated resources, and are suitable for business scenarios that require high stability. For more information, see [Instance family](~~25378~~).
	// *   CreditEntryLevel: This value is valid only for burstable instances. CPU credits are used to ensure computing performance. Instances of this level are suitable for scenarios in which the CPU utilization is low but may fluctuate in specific cases. For more information, see the [Overview](~~59977~~) topic of burstable instances.
	InstanceFamilyLevel *string `json:"InstanceFamilyLevel,omitempty" xml:"InstanceFamilyLevel,omitempty"`
	// The number of IPv6 addresses.
	Ipv6AddressCount *int32 `json:"Ipv6AddressCount,omitempty" xml:"Ipv6AddressCount,omitempty"`
	// The weight of the elastic container instance as a backend server. Valid values: 1 to 100.
	LoadBalancerWeight *int32 `json:"LoadBalancerWeight,omitempty" xml:"LoadBalancerWeight,omitempty"`
	// The memory size of the elastic container instance. Unit: GiB.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The domain names of the NTP server.
	NtpServers []*string `json:"NtpServers,omitempty" xml:"NtpServers,omitempty" type:"Repeated"`
	OwnerId    *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The name of the RAM role for the instance. You can use an instance RAM role to access both elastic container instances and Elastic Compute Service (ECS) instances. For more information, see [Use an instance RAM role by calling API operations](~~61178~~).
	RamRoleName *string `json:"RamRoleName,omitempty" xml:"RamRoleName,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The instance restart policy. Valid values:
	//
	// *   Always: always restarts the elastic container instance.
	// *   Never: never restarts the elastic container instance.
	// *   OnFailure: restarts the elastic container instance upon failures.
	//
	// Default value: Always.
	RestartPolicy *string `json:"RestartPolicy,omitempty" xml:"RestartPolicy,omitempty"`
	// The ID of the scaling configuration that you want to modify.
	ScalingConfigurationId *string `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
	// The name of the scaling configuration. The name must be 2 to 64 characters in length and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). The name must start with a letter or a digit.
	//
	// The name of the scaling configuration must be unique within a scaling group in a region. If you do not specify this parameter, the value of the ScalingConfigurationId parameter is used.
	ScalingConfigurationName *string `json:"ScalingConfigurationName,omitempty" xml:"ScalingConfigurationName,omitempty"`
	// The system information of the security context in which the elastic container instance runs.
	SecurityContextSysCtls []*ModifyEciScalingConfigurationRequestSecurityContextSysCtls `json:"SecurityContextSysCtls,omitempty" xml:"SecurityContextSysCtls,omitempty" type:"Repeated"`
	// The ID of the security group with which you want to associate the elastic container instance. Elastic container instances that are associated with the same security group can access each other.
	//
	// If you do not specify a security group, the system uses the default security group in the region that you selected. Make sure that the inbound rules of the security group contain the protocols and the port numbers of the containers that you want to expose. If you do not have a default security group in the region, the system creates a default security group, and then adds the declared container protocols and port numbers to the inbound rules of the security group.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// The maximum hourly price of the preemptible elastic container instance. The value can be accurate to three decimal places.
	//
	// If you set the SpotStrategy parameter to SpotWithPriceLimit, you must also specify the SpotPriceLimit parameter.
	SpotPriceLimit *float32 `json:"SpotPriceLimit,omitempty" xml:"SpotPriceLimit,omitempty"`
	// The bidding policy for the elastic container instance. Valid values:
	//
	// *   NoSpot: The instance is a pay-as-you-go instance.
	// *   SpotWithPriceLimit: The instance is a preemptible instance with a user-defined maximum hourly price.
	// *   SpotAsPriceGo: The instance is a preemptible instance for which the market price at the time of purchase is used as the bid price.
	//
	// Default value: NoSpot.
	SpotStrategy *string `json:"SpotStrategy,omitempty" xml:"SpotStrategy,omitempty"`
	// Information about the tags.
	Tags []*ModifyEciScalingConfigurationRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The buffer time in which the program handles operations before the program is stopped. Unit: seconds.
	TerminationGracePeriodSeconds *int64 `json:"TerminationGracePeriodSeconds,omitempty" xml:"TerminationGracePeriodSeconds,omitempty"`
	// Information about the volumes.
	Volumes []*ModifyEciScalingConfigurationRequestVolumes `json:"Volumes,omitempty" xml:"Volumes,omitempty" type:"Repeated"`
}

func (s ModifyEciScalingConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequest) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequest) SetAcrRegistryInfos(v []*ModifyEciScalingConfigurationRequestAcrRegistryInfos) *ModifyEciScalingConfigurationRequest {
	s.AcrRegistryInfos = v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetActiveDeadlineSeconds(v int64) *ModifyEciScalingConfigurationRequest {
	s.ActiveDeadlineSeconds = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetAutoCreateEip(v bool) *ModifyEciScalingConfigurationRequest {
	s.AutoCreateEip = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetAutoMatchImageCache(v bool) *ModifyEciScalingConfigurationRequest {
	s.AutoMatchImageCache = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetContainerGroupName(v string) *ModifyEciScalingConfigurationRequest {
	s.ContainerGroupName = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetContainers(v []*ModifyEciScalingConfigurationRequestContainers) *ModifyEciScalingConfigurationRequest {
	s.Containers = v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetContainersUpdateType(v string) *ModifyEciScalingConfigurationRequest {
	s.ContainersUpdateType = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetCostOptimization(v bool) *ModifyEciScalingConfigurationRequest {
	s.CostOptimization = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetCpu(v float32) *ModifyEciScalingConfigurationRequest {
	s.Cpu = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetCpuOptionsCore(v int32) *ModifyEciScalingConfigurationRequest {
	s.CpuOptionsCore = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetCpuOptionsThreadsPerCore(v int32) *ModifyEciScalingConfigurationRequest {
	s.CpuOptionsThreadsPerCore = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetDescription(v string) *ModifyEciScalingConfigurationRequest {
	s.Description = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetDnsConfigNameServers(v []*string) *ModifyEciScalingConfigurationRequest {
	s.DnsConfigNameServers = v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetDnsConfigOptions(v []*ModifyEciScalingConfigurationRequestDnsConfigOptions) *ModifyEciScalingConfigurationRequest {
	s.DnsConfigOptions = v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetDnsConfigSearchs(v []*string) *ModifyEciScalingConfigurationRequest {
	s.DnsConfigSearchs = v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetDnsPolicy(v string) *ModifyEciScalingConfigurationRequest {
	s.DnsPolicy = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetEgressBandwidth(v int64) *ModifyEciScalingConfigurationRequest {
	s.EgressBandwidth = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetEipBandwidth(v int32) *ModifyEciScalingConfigurationRequest {
	s.EipBandwidth = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetEnableSls(v bool) *ModifyEciScalingConfigurationRequest {
	s.EnableSls = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetEphemeralStorage(v int32) *ModifyEciScalingConfigurationRequest {
	s.EphemeralStorage = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetHostAliases(v []*ModifyEciScalingConfigurationRequestHostAliases) *ModifyEciScalingConfigurationRequest {
	s.HostAliases = v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetHostName(v string) *ModifyEciScalingConfigurationRequest {
	s.HostName = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetImageRegistryCredentials(v []*ModifyEciScalingConfigurationRequestImageRegistryCredentials) *ModifyEciScalingConfigurationRequest {
	s.ImageRegistryCredentials = v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetImageSnapshotId(v string) *ModifyEciScalingConfigurationRequest {
	s.ImageSnapshotId = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetIngressBandwidth(v int64) *ModifyEciScalingConfigurationRequest {
	s.IngressBandwidth = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetInitContainers(v []*ModifyEciScalingConfigurationRequestInitContainers) *ModifyEciScalingConfigurationRequest {
	s.InitContainers = v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetInstanceFamilyLevel(v string) *ModifyEciScalingConfigurationRequest {
	s.InstanceFamilyLevel = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetIpv6AddressCount(v int32) *ModifyEciScalingConfigurationRequest {
	s.Ipv6AddressCount = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetLoadBalancerWeight(v int32) *ModifyEciScalingConfigurationRequest {
	s.LoadBalancerWeight = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetMemory(v float32) *ModifyEciScalingConfigurationRequest {
	s.Memory = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetNtpServers(v []*string) *ModifyEciScalingConfigurationRequest {
	s.NtpServers = v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetOwnerId(v int64) *ModifyEciScalingConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetRamRoleName(v string) *ModifyEciScalingConfigurationRequest {
	s.RamRoleName = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetResourceGroupId(v string) *ModifyEciScalingConfigurationRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetResourceOwnerAccount(v string) *ModifyEciScalingConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetRestartPolicy(v string) *ModifyEciScalingConfigurationRequest {
	s.RestartPolicy = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetScalingConfigurationId(v string) *ModifyEciScalingConfigurationRequest {
	s.ScalingConfigurationId = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetScalingConfigurationName(v string) *ModifyEciScalingConfigurationRequest {
	s.ScalingConfigurationName = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetSecurityContextSysCtls(v []*ModifyEciScalingConfigurationRequestSecurityContextSysCtls) *ModifyEciScalingConfigurationRequest {
	s.SecurityContextSysCtls = v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetSecurityGroupId(v string) *ModifyEciScalingConfigurationRequest {
	s.SecurityGroupId = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetSpotPriceLimit(v float32) *ModifyEciScalingConfigurationRequest {
	s.SpotPriceLimit = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetSpotStrategy(v string) *ModifyEciScalingConfigurationRequest {
	s.SpotStrategy = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetTags(v []*ModifyEciScalingConfigurationRequestTags) *ModifyEciScalingConfigurationRequest {
	s.Tags = v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetTerminationGracePeriodSeconds(v int64) *ModifyEciScalingConfigurationRequest {
	s.TerminationGracePeriodSeconds = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequest) SetVolumes(v []*ModifyEciScalingConfigurationRequestVolumes) *ModifyEciScalingConfigurationRequest {
	s.Volumes = v
	return s
}

type ModifyEciScalingConfigurationRequestAcrRegistryInfos struct {
	// The domain names of the Container Registry Enterprise Edition instances. By default, all domain names of the Container Registry Enterprise Edition instances are displayed. You can specify one or more domain names. Separate multiple domain names with commas (,).
	Domains []*string `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Repeated"`
	// The ID of the Container Registry Enterprise Edition instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the Container Registry Enterprise Edition instance.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The region ID of the Container Registry Enterprise Edition instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestAcrRegistryInfos) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestAcrRegistryInfos) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestAcrRegistryInfos) SetDomains(v []*string) *ModifyEciScalingConfigurationRequestAcrRegistryInfos {
	s.Domains = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestAcrRegistryInfos) SetInstanceId(v string) *ModifyEciScalingConfigurationRequestAcrRegistryInfos {
	s.InstanceId = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestAcrRegistryInfos) SetInstanceName(v string) *ModifyEciScalingConfigurationRequestAcrRegistryInfos {
	s.InstanceName = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestAcrRegistryInfos) SetRegionId(v string) *ModifyEciScalingConfigurationRequestAcrRegistryInfos {
	s.RegionId = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainers struct {
	LivenessProbe   *ModifyEciScalingConfigurationRequestContainersLivenessProbe   `json:"LivenessProbe,omitempty" xml:"LivenessProbe,omitempty" require:"true" type:"Struct"`
	ReadinessProbe  *ModifyEciScalingConfigurationRequestContainersReadinessProbe  `json:"ReadinessProbe,omitempty" xml:"ReadinessProbe,omitempty" require:"true" type:"Struct"`
	SecurityContext *ModifyEciScalingConfigurationRequestContainersSecurityContext `json:"SecurityContext,omitempty" xml:"SecurityContext,omitempty" require:"true" type:"Struct"`
	// The arguments that correspond to the startup commands of the container. You can specify up to 10 arguments.
	Args []*string `json:"Args,omitempty" xml:"Args,omitempty" type:"Repeated"`
	// The commands that you want to execute in the container when you use the command line interface (CLI) to perform probes.
	Commands []*string `json:"Commands,omitempty" xml:"Commands,omitempty" type:"Repeated"`
	// The number of vCPUs that you want to allocate to the container.
	Cpu *float32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// Information about the environment variables.
	EnvironmentVars []*ModifyEciScalingConfigurationRequestContainersEnvironmentVars `json:"EnvironmentVars,omitempty" xml:"EnvironmentVars,omitempty" type:"Repeated"`
	// The number of GPUs that you want to allocate to the container.
	Gpu *int32 `json:"Gpu,omitempty" xml:"Gpu,omitempty"`
	// The image of the container.
	Image *string `json:"Image,omitempty" xml:"Image,omitempty"`
	// The image pulling policy. Valid values:
	//
	// *   Always: pulls images each time.
	// *   IfNotPresent: pulls images only if no on-premises images are available. On-premises images are preferentially used. If no on-premises images are available, image pulling is performed.
	// *   Never: never pulls images. On-premises images are always used.
	ImagePullPolicy *string `json:"ImagePullPolicy,omitempty" xml:"ImagePullPolicy,omitempty"`
	// The memory size of the container. Unit: GiB.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The name of the container image.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Information about the ports.
	Ports []*ModifyEciScalingConfigurationRequestContainersPorts `json:"Ports,omitempty" xml:"Ports,omitempty" type:"Repeated"`
	// Specifies whether the container allocates buffer resources to standard input streams when the container is running. If you do not specify this parameter, an end-of-file (EOF) error may occur.
	//
	// Default value: false.
	Stdin *bool `json:"Stdin,omitempty" xml:"Stdin,omitempty"`
	// Specifies whether standard input streams are disconnected after a client is disconnected.
	//
	// If you set the StdinOnce parameter to true, standard input streams are connected after the container is started, and remain idle until a client is connected to receive data. After the client is disconnected, streams are also disconnected, and remain disconnected until the container is started again.
	StdinOnce *bool `json:"StdinOnce,omitempty" xml:"StdinOnce,omitempty"`
	// Specifies whether to enable interaction. Default value: false.
	//
	// If the command is a /bin/bash command, set the value to true.
	Tty *bool `json:"Tty,omitempty" xml:"Tty,omitempty"`
	// Information about the volume mount of the container.
	VolumeMounts []*ModifyEciScalingConfigurationRequestContainersVolumeMounts `json:"VolumeMounts,omitempty" xml:"VolumeMounts,omitempty" type:"Repeated"`
	// The working directory of the container.
	WorkingDir *string `json:"WorkingDir,omitempty" xml:"WorkingDir,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainers) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainers) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetLivenessProbe(v *ModifyEciScalingConfigurationRequestContainersLivenessProbe) *ModifyEciScalingConfigurationRequestContainers {
	s.LivenessProbe = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetReadinessProbe(v *ModifyEciScalingConfigurationRequestContainersReadinessProbe) *ModifyEciScalingConfigurationRequestContainers {
	s.ReadinessProbe = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetSecurityContext(v *ModifyEciScalingConfigurationRequestContainersSecurityContext) *ModifyEciScalingConfigurationRequestContainers {
	s.SecurityContext = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetArgs(v []*string) *ModifyEciScalingConfigurationRequestContainers {
	s.Args = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetCommands(v []*string) *ModifyEciScalingConfigurationRequestContainers {
	s.Commands = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetCpu(v float32) *ModifyEciScalingConfigurationRequestContainers {
	s.Cpu = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetEnvironmentVars(v []*ModifyEciScalingConfigurationRequestContainersEnvironmentVars) *ModifyEciScalingConfigurationRequestContainers {
	s.EnvironmentVars = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetGpu(v int32) *ModifyEciScalingConfigurationRequestContainers {
	s.Gpu = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetImage(v string) *ModifyEciScalingConfigurationRequestContainers {
	s.Image = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetImagePullPolicy(v string) *ModifyEciScalingConfigurationRequestContainers {
	s.ImagePullPolicy = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetMemory(v float32) *ModifyEciScalingConfigurationRequestContainers {
	s.Memory = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetName(v string) *ModifyEciScalingConfigurationRequestContainers {
	s.Name = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetPorts(v []*ModifyEciScalingConfigurationRequestContainersPorts) *ModifyEciScalingConfigurationRequestContainers {
	s.Ports = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetStdin(v bool) *ModifyEciScalingConfigurationRequestContainers {
	s.Stdin = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetStdinOnce(v bool) *ModifyEciScalingConfigurationRequestContainers {
	s.StdinOnce = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetTty(v bool) *ModifyEciScalingConfigurationRequestContainers {
	s.Tty = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetVolumeMounts(v []*ModifyEciScalingConfigurationRequestContainersVolumeMounts) *ModifyEciScalingConfigurationRequestContainers {
	s.VolumeMounts = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainers) SetWorkingDir(v string) *ModifyEciScalingConfigurationRequestContainers {
	s.WorkingDir = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainersLivenessProbe struct {
	Exec                *ModifyEciScalingConfigurationRequestContainersLivenessProbeExec      `json:"Exec,omitempty" xml:"Exec,omitempty" require:"true" type:"Struct"`
	FailureThreshold    *int32                                                                `json:"FailureThreshold,omitempty" xml:"FailureThreshold,omitempty"`
	HttpGet             *ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet   `json:"HttpGet,omitempty" xml:"HttpGet,omitempty" require:"true" type:"Struct"`
	InitialDelaySeconds *int32                                                                `json:"InitialDelaySeconds,omitempty" xml:"InitialDelaySeconds,omitempty"`
	PeriodSeconds       *int32                                                                `json:"PeriodSeconds,omitempty" xml:"PeriodSeconds,omitempty"`
	SuccessThreshold    *int32                                                                `json:"SuccessThreshold,omitempty" xml:"SuccessThreshold,omitempty"`
	TcpSocket           *ModifyEciScalingConfigurationRequestContainersLivenessProbeTcpSocket `json:"TcpSocket,omitempty" xml:"TcpSocket,omitempty" require:"true" type:"Struct"`
	TimeoutSeconds      *int32                                                                `json:"TimeoutSeconds,omitempty" xml:"TimeoutSeconds,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainersLivenessProbe) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersLivenessProbe) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbe) SetExec(v *ModifyEciScalingConfigurationRequestContainersLivenessProbeExec) *ModifyEciScalingConfigurationRequestContainersLivenessProbe {
	s.Exec = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbe) SetFailureThreshold(v int32) *ModifyEciScalingConfigurationRequestContainersLivenessProbe {
	s.FailureThreshold = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbe) SetHttpGet(v *ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet) *ModifyEciScalingConfigurationRequestContainersLivenessProbe {
	s.HttpGet = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbe) SetInitialDelaySeconds(v int32) *ModifyEciScalingConfigurationRequestContainersLivenessProbe {
	s.InitialDelaySeconds = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbe) SetPeriodSeconds(v int32) *ModifyEciScalingConfigurationRequestContainersLivenessProbe {
	s.PeriodSeconds = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbe) SetSuccessThreshold(v int32) *ModifyEciScalingConfigurationRequestContainersLivenessProbe {
	s.SuccessThreshold = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbe) SetTcpSocket(v *ModifyEciScalingConfigurationRequestContainersLivenessProbeTcpSocket) *ModifyEciScalingConfigurationRequestContainersLivenessProbe {
	s.TcpSocket = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbe) SetTimeoutSeconds(v int32) *ModifyEciScalingConfigurationRequestContainersLivenessProbe {
	s.TimeoutSeconds = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainersLivenessProbeExec struct {
	Commands []*string `json:"Commands,omitempty" xml:"Commands,omitempty" type:"Repeated"`
}

func (s ModifyEciScalingConfigurationRequestContainersLivenessProbeExec) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersLivenessProbeExec) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbeExec) SetCommands(v []*string) *ModifyEciScalingConfigurationRequestContainersLivenessProbeExec {
	s.Commands = v
	return s
}

type ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet struct {
	Path   *string `json:"Path,omitempty" xml:"Path,omitempty"`
	Port   *int32  `json:"Port,omitempty" xml:"Port,omitempty"`
	Scheme *string `json:"Scheme,omitempty" xml:"Scheme,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet) SetPath(v string) *ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet {
	s.Path = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet) SetPort(v int32) *ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet {
	s.Port = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet) SetScheme(v string) *ModifyEciScalingConfigurationRequestContainersLivenessProbeHttpGet {
	s.Scheme = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainersLivenessProbeTcpSocket struct {
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainersLivenessProbeTcpSocket) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersLivenessProbeTcpSocket) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersLivenessProbeTcpSocket) SetPort(v int32) *ModifyEciScalingConfigurationRequestContainersLivenessProbeTcpSocket {
	s.Port = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainersReadinessProbe struct {
	Exec                *ModifyEciScalingConfigurationRequestContainersReadinessProbeExec      `json:"Exec,omitempty" xml:"Exec,omitempty" require:"true" type:"Struct"`
	FailureThreshold    *int32                                                                 `json:"FailureThreshold,omitempty" xml:"FailureThreshold,omitempty"`
	HttpGet             *ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet   `json:"HttpGet,omitempty" xml:"HttpGet,omitempty" require:"true" type:"Struct"`
	InitialDelaySeconds *int32                                                                 `json:"InitialDelaySeconds,omitempty" xml:"InitialDelaySeconds,omitempty"`
	PeriodSeconds       *int32                                                                 `json:"PeriodSeconds,omitempty" xml:"PeriodSeconds,omitempty"`
	SuccessThreshold    *int32                                                                 `json:"SuccessThreshold,omitempty" xml:"SuccessThreshold,omitempty"`
	TcpSocket           *ModifyEciScalingConfigurationRequestContainersReadinessProbeTcpSocket `json:"TcpSocket,omitempty" xml:"TcpSocket,omitempty" require:"true" type:"Struct"`
	TimeoutSeconds      *int32                                                                 `json:"TimeoutSeconds,omitempty" xml:"TimeoutSeconds,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainersReadinessProbe) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersReadinessProbe) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbe) SetExec(v *ModifyEciScalingConfigurationRequestContainersReadinessProbeExec) *ModifyEciScalingConfigurationRequestContainersReadinessProbe {
	s.Exec = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbe) SetFailureThreshold(v int32) *ModifyEciScalingConfigurationRequestContainersReadinessProbe {
	s.FailureThreshold = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbe) SetHttpGet(v *ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet) *ModifyEciScalingConfigurationRequestContainersReadinessProbe {
	s.HttpGet = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbe) SetInitialDelaySeconds(v int32) *ModifyEciScalingConfigurationRequestContainersReadinessProbe {
	s.InitialDelaySeconds = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbe) SetPeriodSeconds(v int32) *ModifyEciScalingConfigurationRequestContainersReadinessProbe {
	s.PeriodSeconds = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbe) SetSuccessThreshold(v int32) *ModifyEciScalingConfigurationRequestContainersReadinessProbe {
	s.SuccessThreshold = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbe) SetTcpSocket(v *ModifyEciScalingConfigurationRequestContainersReadinessProbeTcpSocket) *ModifyEciScalingConfigurationRequestContainersReadinessProbe {
	s.TcpSocket = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbe) SetTimeoutSeconds(v int32) *ModifyEciScalingConfigurationRequestContainersReadinessProbe {
	s.TimeoutSeconds = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainersReadinessProbeExec struct {
	Commands []*string `json:"Commands,omitempty" xml:"Commands,omitempty" type:"Repeated"`
}

func (s ModifyEciScalingConfigurationRequestContainersReadinessProbeExec) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersReadinessProbeExec) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbeExec) SetCommands(v []*string) *ModifyEciScalingConfigurationRequestContainersReadinessProbeExec {
	s.Commands = v
	return s
}

type ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet struct {
	Path   *string `json:"Path,omitempty" xml:"Path,omitempty"`
	Port   *int32  `json:"Port,omitempty" xml:"Port,omitempty"`
	Scheme *string `json:"Scheme,omitempty" xml:"Scheme,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet) SetPath(v string) *ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet {
	s.Path = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet) SetPort(v int32) *ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet {
	s.Port = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet) SetScheme(v string) *ModifyEciScalingConfigurationRequestContainersReadinessProbeHttpGet {
	s.Scheme = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainersReadinessProbeTcpSocket struct {
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainersReadinessProbeTcpSocket) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersReadinessProbeTcpSocket) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersReadinessProbeTcpSocket) SetPort(v int32) *ModifyEciScalingConfigurationRequestContainersReadinessProbeTcpSocket {
	s.Port = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainersSecurityContext struct {
	Capability             *ModifyEciScalingConfigurationRequestContainersSecurityContextCapability `json:"Capability,omitempty" xml:"Capability,omitempty" require:"true" type:"Struct"`
	ReadOnlyRootFilesystem *bool                                                                    `json:"ReadOnlyRootFilesystem,omitempty" xml:"ReadOnlyRootFilesystem,omitempty"`
	RunAsUser              *int64                                                                   `json:"RunAsUser,omitempty" xml:"RunAsUser,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainersSecurityContext) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersSecurityContext) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersSecurityContext) SetCapability(v *ModifyEciScalingConfigurationRequestContainersSecurityContextCapability) *ModifyEciScalingConfigurationRequestContainersSecurityContext {
	s.Capability = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersSecurityContext) SetReadOnlyRootFilesystem(v bool) *ModifyEciScalingConfigurationRequestContainersSecurityContext {
	s.ReadOnlyRootFilesystem = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersSecurityContext) SetRunAsUser(v int64) *ModifyEciScalingConfigurationRequestContainersSecurityContext {
	s.RunAsUser = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainersSecurityContextCapability struct {
	Adds []*string `json:"Adds,omitempty" xml:"Adds,omitempty" type:"Repeated"`
}

func (s ModifyEciScalingConfigurationRequestContainersSecurityContextCapability) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersSecurityContextCapability) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersSecurityContextCapability) SetAdds(v []*string) *ModifyEciScalingConfigurationRequestContainersSecurityContextCapability {
	s.Adds = v
	return s
}

type ModifyEciScalingConfigurationRequestContainersEnvironmentVars struct {
	FieldRef *ModifyEciScalingConfigurationRequestContainersEnvironmentVarsFieldRef `json:"FieldRef,omitempty" xml:"FieldRef,omitempty" require:"true" type:"Struct"`
	// The key of the environment variable. Specify the name in the `[0-9a-zA-Z]` format. The name must be 1 to 128 characters in length, and can contain underscores (\_). It cannot start with a digit.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the environment variable. The value must be 0 to 256 characters in length.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainersEnvironmentVars) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersEnvironmentVars) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersEnvironmentVars) SetFieldRef(v *ModifyEciScalingConfigurationRequestContainersEnvironmentVarsFieldRef) *ModifyEciScalingConfigurationRequestContainersEnvironmentVars {
	s.FieldRef = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersEnvironmentVars) SetKey(v string) *ModifyEciScalingConfigurationRequestContainersEnvironmentVars {
	s.Key = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersEnvironmentVars) SetValue(v string) *ModifyEciScalingConfigurationRequestContainersEnvironmentVars {
	s.Value = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainersEnvironmentVarsFieldRef struct {
	FieldPath *string `json:"FieldPath,omitempty" xml:"FieldPath,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainersEnvironmentVarsFieldRef) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersEnvironmentVarsFieldRef) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersEnvironmentVarsFieldRef) SetFieldPath(v string) *ModifyEciScalingConfigurationRequestContainersEnvironmentVarsFieldRef {
	s.FieldPath = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainersPorts struct {
	// The port number. Valid values: 1 to 65535.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The type of the protocol. Valid values:
	//
	// *   TCP
	// *   UDP
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainersPorts) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersPorts) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersPorts) SetPort(v int32) *ModifyEciScalingConfigurationRequestContainersPorts {
	s.Port = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersPorts) SetProtocol(v string) *ModifyEciScalingConfigurationRequestContainersPorts {
	s.Protocol = &v
	return s
}

type ModifyEciScalingConfigurationRequestContainersVolumeMounts struct {
	// The path where the container mounts the volume.
	//
	// >  Data stored in the path of the container is directly overwritten by the content of the volume.
	MountPath *string `json:"MountPath,omitempty" xml:"MountPath,omitempty"`
	// The mount propagation setting of the volume. Mount propagation allows the sharing of volumes that are mounted on one container with other containers in the same pod, or even with other pods on the same node. Valid values:
	//
	// *   None: The volume mount does not receive subsequent mounts that are mounted to this volume or its subdirectories.
	// *   HostToCotainer: The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories.
	// *   Bidirectional: This value is similar to HostToCotainer. The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories. In addition, all volume mounts that are created by the container are propagated back to the instance and to all containers of all pods that use the same volume.
	MountPropagation *string `json:"MountPropagation,omitempty" xml:"MountPropagation,omitempty"`
	// The name of the volume. The value of this parameter is the same as the value of the Volumes.Name parameter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Specifies whether the volume is read-only.
	//
	// Default value: false.
	ReadOnly *bool `json:"ReadOnly,omitempty" xml:"ReadOnly,omitempty"`
	// The subdirectory of the volume.
	SubPath *string `json:"SubPath,omitempty" xml:"SubPath,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestContainersVolumeMounts) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestContainersVolumeMounts) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestContainersVolumeMounts) SetMountPath(v string) *ModifyEciScalingConfigurationRequestContainersVolumeMounts {
	s.MountPath = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersVolumeMounts) SetMountPropagation(v string) *ModifyEciScalingConfigurationRequestContainersVolumeMounts {
	s.MountPropagation = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersVolumeMounts) SetName(v string) *ModifyEciScalingConfigurationRequestContainersVolumeMounts {
	s.Name = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersVolumeMounts) SetReadOnly(v bool) *ModifyEciScalingConfigurationRequestContainersVolumeMounts {
	s.ReadOnly = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestContainersVolumeMounts) SetSubPath(v string) *ModifyEciScalingConfigurationRequestContainersVolumeMounts {
	s.SubPath = &v
	return s
}

type ModifyEciScalingConfigurationRequestDnsConfigOptions struct {
	// The variable name of the option.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The variable value of the option.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestDnsConfigOptions) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestDnsConfigOptions) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestDnsConfigOptions) SetName(v string) *ModifyEciScalingConfigurationRequestDnsConfigOptions {
	s.Name = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestDnsConfigOptions) SetValue(v string) *ModifyEciScalingConfigurationRequestDnsConfigOptions {
	s.Value = &v
	return s
}

type ModifyEciScalingConfigurationRequestHostAliases struct {
	// The hostnames that you want to add.
	Hostnames []*string `json:"Hostnames,omitempty" xml:"Hostnames,omitempty" type:"Repeated"`
	// The IP address that you want to add.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestHostAliases) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestHostAliases) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestHostAliases) SetHostnames(v []*string) *ModifyEciScalingConfigurationRequestHostAliases {
	s.Hostnames = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestHostAliases) SetIp(v string) *ModifyEciScalingConfigurationRequestHostAliases {
	s.Ip = &v
	return s
}

type ModifyEciScalingConfigurationRequestImageRegistryCredentials struct {
	// The password that is used to access the image repository.
	Password *string `json:"Password,omitempty" xml:"Password,omitempty"`
	// The domain name of the image repository.
	Server *string `json:"Server,omitempty" xml:"Server,omitempty"`
	// The username that is used to access the image repository.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestImageRegistryCredentials) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestImageRegistryCredentials) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestImageRegistryCredentials) SetPassword(v string) *ModifyEciScalingConfigurationRequestImageRegistryCredentials {
	s.Password = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestImageRegistryCredentials) SetServer(v string) *ModifyEciScalingConfigurationRequestImageRegistryCredentials {
	s.Server = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestImageRegistryCredentials) SetUserName(v string) *ModifyEciScalingConfigurationRequestImageRegistryCredentials {
	s.UserName = &v
	return s
}

type ModifyEciScalingConfigurationRequestInitContainers struct {
	SecurityContext *ModifyEciScalingConfigurationRequestInitContainersSecurityContext `json:"SecurityContext,omitempty" xml:"SecurityContext,omitempty" require:"true" type:"Struct"`
	// The startup parameter of the container.
	Args []*string `json:"Args,omitempty" xml:"Args,omitempty" type:"Repeated"`
	// The commands that you want to run to start the container.
	Commands []*string `json:"Commands,omitempty" xml:"Commands,omitempty" type:"Repeated"`
	// The number of vCPUs that you want to allocate to the container.
	Cpu *float32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The number of GPUs that you want to allocate to the container.
	Gpu *int32 `json:"Gpu,omitempty" xml:"Gpu,omitempty"`
	// The container image.
	Image *string `json:"Image,omitempty" xml:"Image,omitempty"`
	// The image pulling policy. Valid values:
	//
	// *   Always: pulls images each time.
	// *   IfNotPresent: pulls images only if no on-premises images are available. On-premises images are preferentially used. If no on-premises images are available, image pulling is performed.
	// *   Never: never pulls images. On-premises images are always used. Image pulling is not performed.
	ImagePullPolicy *string `json:"ImagePullPolicy,omitempty" xml:"ImagePullPolicy,omitempty"`
	// The environment variables of the init container.
	InitContainerEnvironmentVars []*ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars `json:"InitContainerEnvironmentVars,omitempty" xml:"InitContainerEnvironmentVars,omitempty" type:"Repeated"`
	// The ports of the init container.
	InitContainerPorts []*ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts `json:"InitContainerPorts,omitempty" xml:"InitContainerPorts,omitempty" type:"Repeated"`
	// Information about the volume mounts of the init container.
	InitContainerVolumeMounts []*ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts `json:"InitContainerVolumeMounts,omitempty" xml:"InitContainerVolumeMounts,omitempty" type:"Repeated"`
	// The size of the memory. Unit: GiB.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The name of the container.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The working directory.
	WorkingDir *string `json:"WorkingDir,omitempty" xml:"WorkingDir,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestInitContainers) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestInitContainers) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetSecurityContext(v *ModifyEciScalingConfigurationRequestInitContainersSecurityContext) *ModifyEciScalingConfigurationRequestInitContainers {
	s.SecurityContext = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetArgs(v []*string) *ModifyEciScalingConfigurationRequestInitContainers {
	s.Args = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetCommands(v []*string) *ModifyEciScalingConfigurationRequestInitContainers {
	s.Commands = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetCpu(v float32) *ModifyEciScalingConfigurationRequestInitContainers {
	s.Cpu = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetGpu(v int32) *ModifyEciScalingConfigurationRequestInitContainers {
	s.Gpu = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetImage(v string) *ModifyEciScalingConfigurationRequestInitContainers {
	s.Image = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetImagePullPolicy(v string) *ModifyEciScalingConfigurationRequestInitContainers {
	s.ImagePullPolicy = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetInitContainerEnvironmentVars(v []*ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) *ModifyEciScalingConfigurationRequestInitContainers {
	s.InitContainerEnvironmentVars = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetInitContainerPorts(v []*ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts) *ModifyEciScalingConfigurationRequestInitContainers {
	s.InitContainerPorts = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetInitContainerVolumeMounts(v []*ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) *ModifyEciScalingConfigurationRequestInitContainers {
	s.InitContainerVolumeMounts = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetMemory(v float32) *ModifyEciScalingConfigurationRequestInitContainers {
	s.Memory = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetName(v string) *ModifyEciScalingConfigurationRequestInitContainers {
	s.Name = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainers) SetWorkingDir(v string) *ModifyEciScalingConfigurationRequestInitContainers {
	s.WorkingDir = &v
	return s
}

type ModifyEciScalingConfigurationRequestInitContainersSecurityContext struct {
	Capability             *ModifyEciScalingConfigurationRequestInitContainersSecurityContextCapability `json:"Capability,omitempty" xml:"Capability,omitempty" require:"true" type:"Struct"`
	ReadOnlyRootFilesystem *bool                                                                        `json:"ReadOnlyRootFilesystem,omitempty" xml:"ReadOnlyRootFilesystem,omitempty"`
	RunAsUser              *int64                                                                       `json:"RunAsUser,omitempty" xml:"RunAsUser,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestInitContainersSecurityContext) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestInitContainersSecurityContext) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestInitContainersSecurityContext) SetCapability(v *ModifyEciScalingConfigurationRequestInitContainersSecurityContextCapability) *ModifyEciScalingConfigurationRequestInitContainersSecurityContext {
	s.Capability = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainersSecurityContext) SetReadOnlyRootFilesystem(v bool) *ModifyEciScalingConfigurationRequestInitContainersSecurityContext {
	s.ReadOnlyRootFilesystem = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainersSecurityContext) SetRunAsUser(v int64) *ModifyEciScalingConfigurationRequestInitContainersSecurityContext {
	s.RunAsUser = &v
	return s
}

type ModifyEciScalingConfigurationRequestInitContainersSecurityContextCapability struct {
	Adds []*string `json:"Adds,omitempty" xml:"Adds,omitempty" type:"Repeated"`
}

func (s ModifyEciScalingConfigurationRequestInitContainersSecurityContextCapability) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestInitContainersSecurityContextCapability) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestInitContainersSecurityContextCapability) SetAdds(v []*string) *ModifyEciScalingConfigurationRequestInitContainersSecurityContextCapability {
	s.Adds = v
	return s
}

type ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars struct {
	FieldRef *ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVarsFieldRef `json:"FieldRef,omitempty" xml:"FieldRef,omitempty" require:"true" type:"Struct"`
	// The key of the environment variable. The key must be 1 to 128 characters in length. Specify the name in the `[0-9a-zA-Z]` format. The name can contain underscores and cannot start with a digit.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the environment variable. The value must be 0 to 256 characters in length.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) SetFieldRef(v *ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVarsFieldRef) *ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars {
	s.FieldRef = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) SetKey(v string) *ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars {
	s.Key = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars) SetValue(v string) *ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVars {
	s.Value = &v
	return s
}

type ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVarsFieldRef struct {
	FieldPath *string `json:"FieldPath,omitempty" xml:"FieldPath,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVarsFieldRef) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVarsFieldRef) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVarsFieldRef) SetFieldPath(v string) *ModifyEciScalingConfigurationRequestInitContainersInitContainerEnvironmentVarsFieldRef {
	s.FieldPath = &v
	return s
}

type ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts struct {
	// The port number. Valid values: 1 to 65535.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The type of the protocol. Valid values:
	//
	// *   TCP
	// *   UDP
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts) SetPort(v int32) *ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts {
	s.Port = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts) SetProtocol(v string) *ModifyEciScalingConfigurationRequestInitContainersInitContainerPorts {
	s.Protocol = &v
	return s
}

type ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts struct {
	// The path where the container mounts the volume.
	//
	// >  Data stored in the path of the container is overwritten by the content of the volume.
	MountPath *string `json:"MountPath,omitempty" xml:"MountPath,omitempty"`
	// The mount propagation setting of the volume. Mount propagation allows the sharing of volumes that are mounted on one container with other containers in the same pod, or even with other pods on the same node. Valid values:
	//
	// *   None: The volume mount does not receive subsequent mounts that are mounted to this volume or its subdirectories.
	// *   HostToCotainer: The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories.
	// *   Bidirectional: This value is similar to HostToCotainer. The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories. In addition, all volume mounts that are created by the container are propagated back to the instance and to all containers of all pods that use the same volume.
	//
	// Default value: None.
	MountPropagation *string `json:"MountPropagation,omitempty" xml:"MountPropagation,omitempty"`
	// The name of the volume.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Specifies whether the mount path is read-only.
	//
	// Default value: false.
	ReadOnly *bool `json:"ReadOnly,omitempty" xml:"ReadOnly,omitempty"`
	// The subdirectory of the volume. The elastic container instance can mount different directories of the same volume to different subdirectories of containers.
	SubPath *string `json:"SubPath,omitempty" xml:"SubPath,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) SetMountPath(v string) *ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts {
	s.MountPath = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) SetMountPropagation(v string) *ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts {
	s.MountPropagation = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) SetName(v string) *ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts {
	s.Name = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) SetReadOnly(v bool) *ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts {
	s.ReadOnly = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts) SetSubPath(v string) *ModifyEciScalingConfigurationRequestInitContainersInitContainerVolumeMounts {
	s.SubPath = &v
	return s
}

type ModifyEciScalingConfigurationRequestSecurityContextSysCtls struct {
	// The name of the security context in which the elastic container instance runs.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The variable value of the security context in which the elastic container instance runs.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestSecurityContextSysCtls) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestSecurityContextSysCtls) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestSecurityContextSysCtls) SetName(v string) *ModifyEciScalingConfigurationRequestSecurityContextSysCtls {
	s.Name = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestSecurityContextSysCtls) SetValue(v string) *ModifyEciScalingConfigurationRequestSecurityContextSysCtls {
	s.Value = &v
	return s
}

type ModifyEciScalingConfigurationRequestTags struct {
	// The key of the tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestTags) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestTags) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestTags) SetKey(v string) *ModifyEciScalingConfigurationRequestTags {
	s.Key = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestTags) SetValue(v string) *ModifyEciScalingConfigurationRequestTags {
	s.Value = &v
	return s
}

type ModifyEciScalingConfigurationRequestVolumes struct {
	DiskVolume     *ModifyEciScalingConfigurationRequestVolumesDiskVolume     `json:"DiskVolume,omitempty" xml:"DiskVolume,omitempty" require:"true" type:"Struct"`
	EmptyDirVolume *ModifyEciScalingConfigurationRequestVolumesEmptyDirVolume `json:"EmptyDirVolume,omitempty" xml:"EmptyDirVolume,omitempty" require:"true" type:"Struct"`
	FlexVolume     *ModifyEciScalingConfigurationRequestVolumesFlexVolume     `json:"FlexVolume,omitempty" xml:"FlexVolume,omitempty" require:"true" type:"Struct"`
	HostPathVolume *ModifyEciScalingConfigurationRequestVolumesHostPathVolume `json:"HostPathVolume,omitempty" xml:"HostPathVolume,omitempty" require:"true" type:"Struct"`
	NFSVolume      *ModifyEciScalingConfigurationRequestVolumesNFSVolume      `json:"NFSVolume,omitempty" xml:"NFSVolume,omitempty" require:"true" type:"Struct"`
	// The paths to the configuration files.
	ConfigFileVolumeConfigFileToPath []*ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath `json:"ConfigFileVolumeConfigFileToPath,omitempty" xml:"ConfigFileVolumeConfigFileToPath,omitempty" type:"Repeated"`
	// The default permissions on ConfigFileVolume.
	ConfigFileVolumeDefaultMode *int32 `json:"ConfigFileVolumeDefaultMode,omitempty" xml:"ConfigFileVolumeDefaultMode,omitempty"`
	// The name of the volume.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of HostPathVolume. Examples: File, Directory, and Socket.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestVolumes) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestVolumes) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestVolumes) SetDiskVolume(v *ModifyEciScalingConfigurationRequestVolumesDiskVolume) *ModifyEciScalingConfigurationRequestVolumes {
	s.DiskVolume = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumes) SetEmptyDirVolume(v *ModifyEciScalingConfigurationRequestVolumesEmptyDirVolume) *ModifyEciScalingConfigurationRequestVolumes {
	s.EmptyDirVolume = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumes) SetFlexVolume(v *ModifyEciScalingConfigurationRequestVolumesFlexVolume) *ModifyEciScalingConfigurationRequestVolumes {
	s.FlexVolume = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumes) SetHostPathVolume(v *ModifyEciScalingConfigurationRequestVolumesHostPathVolume) *ModifyEciScalingConfigurationRequestVolumes {
	s.HostPathVolume = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumes) SetNFSVolume(v *ModifyEciScalingConfigurationRequestVolumesNFSVolume) *ModifyEciScalingConfigurationRequestVolumes {
	s.NFSVolume = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumes) SetConfigFileVolumeConfigFileToPath(v []*ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath) *ModifyEciScalingConfigurationRequestVolumes {
	s.ConfigFileVolumeConfigFileToPath = v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumes) SetConfigFileVolumeDefaultMode(v int32) *ModifyEciScalingConfigurationRequestVolumes {
	s.ConfigFileVolumeDefaultMode = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumes) SetName(v string) *ModifyEciScalingConfigurationRequestVolumes {
	s.Name = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumes) SetType(v string) *ModifyEciScalingConfigurationRequestVolumes {
	s.Type = &v
	return s
}

type ModifyEciScalingConfigurationRequestVolumesDiskVolume struct {
	DiskId   *string `json:"DiskId,omitempty" xml:"DiskId,omitempty"`
	DiskSize *int32  `json:"DiskSize,omitempty" xml:"DiskSize,omitempty"`
	FsType   *string `json:"FsType,omitempty" xml:"FsType,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestVolumesDiskVolume) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestVolumesDiskVolume) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestVolumesDiskVolume) SetDiskId(v string) *ModifyEciScalingConfigurationRequestVolumesDiskVolume {
	s.DiskId = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumesDiskVolume) SetDiskSize(v int32) *ModifyEciScalingConfigurationRequestVolumesDiskVolume {
	s.DiskSize = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumesDiskVolume) SetFsType(v string) *ModifyEciScalingConfigurationRequestVolumesDiskVolume {
	s.FsType = &v
	return s
}

type ModifyEciScalingConfigurationRequestVolumesEmptyDirVolume struct {
	Medium *string `json:"Medium,omitempty" xml:"Medium,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestVolumesEmptyDirVolume) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestVolumesEmptyDirVolume) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestVolumesEmptyDirVolume) SetMedium(v string) *ModifyEciScalingConfigurationRequestVolumesEmptyDirVolume {
	s.Medium = &v
	return s
}

type ModifyEciScalingConfigurationRequestVolumesFlexVolume struct {
	Driver  *string `json:"Driver,omitempty" xml:"Driver,omitempty"`
	FsType  *string `json:"FsType,omitempty" xml:"FsType,omitempty"`
	Options *string `json:"Options,omitempty" xml:"Options,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestVolumesFlexVolume) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestVolumesFlexVolume) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestVolumesFlexVolume) SetDriver(v string) *ModifyEciScalingConfigurationRequestVolumesFlexVolume {
	s.Driver = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumesFlexVolume) SetFsType(v string) *ModifyEciScalingConfigurationRequestVolumesFlexVolume {
	s.FsType = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumesFlexVolume) SetOptions(v string) *ModifyEciScalingConfigurationRequestVolumesFlexVolume {
	s.Options = &v
	return s
}

type ModifyEciScalingConfigurationRequestVolumesHostPathVolume struct {
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestVolumesHostPathVolume) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestVolumesHostPathVolume) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestVolumesHostPathVolume) SetPath(v string) *ModifyEciScalingConfigurationRequestVolumesHostPathVolume {
	s.Path = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumesHostPathVolume) SetType(v string) *ModifyEciScalingConfigurationRequestVolumesHostPathVolume {
	s.Type = &v
	return s
}

type ModifyEciScalingConfigurationRequestVolumesNFSVolume struct {
	Path     *string `json:"Path,omitempty" xml:"Path,omitempty"`
	ReadOnly *bool   `json:"ReadOnly,omitempty" xml:"ReadOnly,omitempty"`
	Server   *string `json:"Server,omitempty" xml:"Server,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestVolumesNFSVolume) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestVolumesNFSVolume) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestVolumesNFSVolume) SetPath(v string) *ModifyEciScalingConfigurationRequestVolumesNFSVolume {
	s.Path = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumesNFSVolume) SetReadOnly(v bool) *ModifyEciScalingConfigurationRequestVolumesNFSVolume {
	s.ReadOnly = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumesNFSVolume) SetServer(v string) *ModifyEciScalingConfigurationRequestVolumesNFSVolume {
	s.Server = &v
	return s
}

type ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath struct {
	// The content of the configuration file, which can be up to 32 KB in size.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The permissions on ConfigFileVolume.
	Mode *int32 `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The relative path to the configuration file.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath) SetContent(v string) *ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath {
	s.Content = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath) SetMode(v int32) *ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath {
	s.Mode = &v
	return s
}

func (s *ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath) SetPath(v string) *ModifyEciScalingConfigurationRequestVolumesConfigFileVolumeConfigFileToPath {
	s.Path = &v
	return s
}

type ModifyEciScalingConfigurationResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyEciScalingConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationResponseBody) SetRequestId(v string) *ModifyEciScalingConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type ModifyEciScalingConfigurationResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyEciScalingConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyEciScalingConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyEciScalingConfigurationResponse) GoString() string {
	return s.String()
}

func (s *ModifyEciScalingConfigurationResponse) SetHeaders(v map[string]*string) *ModifyEciScalingConfigurationResponse {
	s.Headers = v
	return s
}

func (s *ModifyEciScalingConfigurationResponse) SetStatusCode(v int32) *ModifyEciScalingConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyEciScalingConfigurationResponse) SetBody(v *ModifyEciScalingConfigurationResponseBody) *ModifyEciScalingConfigurationResponse {
	s.Body = v
	return s
}

type ModifyLifecycleHookRequest struct {
	// The period of time before the lifecycle hook ends. Auto Scaling performs the specified action after the lifecycle hook ends. Valid values: 30 to 21600. Unit: seconds.
	//
	// You can call the RecordLifecycleActionHeartbeat operation to prolong the length of a lifecycle hook. You can also call the CompleteLifecycleAction operation to end a lifecycle hook ahead of schedule.
	DefaultResult *string `json:"DefaultResult,omitempty" xml:"DefaultResult,omitempty"`
	// The type of scaling activity to which the lifecycle hook applies. Valid values:
	//
	// *   SCALE_OUT
	// *   SCALE_IN
	HeartbeatTimeout *int32 `json:"HeartbeatTimeout,omitempty" xml:"HeartbeatTimeout,omitempty"`
	// The ID of the scaling group to which the lifecycle hook belongs.
	LifecycleHookId *string `json:"LifecycleHookId,omitempty" xml:"LifecycleHookId,omitempty"`
	// The action that you want Auto Scaling to perform after the lifecycle hook ends. Valid values:
	//
	// *   CONTINUE: Auto Scaling continues to respond to scaling requests.
	// *   ABANDON: Auto Scaling releases Elastic Compute Service (ECS) instances that are created during scale-out activities, or removes ECS instances from the scaling group during scale-in activities.
	//
	// If multiple lifecycle hooks in a scaling group are triggered during scale-in activities and you set the DefaultResult parameter to ABANDON for the lifecycle hook that you want to modify, Auto Scaling immediately performs the action after the lifecycle hook that you want to modify ends. As a result, other lifecycle hooks end ahead of schedule. In other cases, Auto Scaling performs the action only after all lifecycle hooks end.
	LifecycleHookName *string `json:"LifecycleHookName,omitempty" xml:"LifecycleHookName,omitempty"`
	// The ID of the request.
	LifecycleHookStatus *string `json:"LifecycleHookStatus,omitempty" xml:"LifecycleHookStatus,omitempty"`
	// The fixed string that is included in a notification. Auto Scaling sends the notification when the lifecycle hook takes effect. The value of this parameter cannot exceed 4,096 characters in length.
	//
	// Auto Scaling sends the value specified for the NotificationMetadata parameter together with the notification. This helps you categorize your notifications. The NotificationMetadata parameter takes effect only after you specify the NotificationArn parameter.
	LifecycleTransition *string `json:"LifecycleTransition,omitempty" xml:"LifecycleTransition,omitempty"`
	// The region ID of the scaling group.
	NotificationArn *string `json:"NotificationArn,omitempty" xml:"NotificationArn,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the notification method. Specify the value in one of the following formats:
	//
	// *   If the notification method is a Message Service (MNS) queue, specify the value in the acs:mns:{region-id}:{account-id}:queue/{queuename} format.
	// *   If the notification method is an MNS topic, specify the value in the acs:mns:{region-id}:{account-id}:topic/{topicname} format.
	// *   If the notification method is an Operation Orchestration Service (OOS) template, specify the value in the acs:oos:{region-id}:{account-id}:template/{templatename} format.
	//
	// The variables in the preceding parameter formats have the following meanings:
	//
	// *   region-id: the region ID of the scaling group.
	// *   account-id: the ID of the Alibaba Cloud account.
	// *   queuename: the name of the MNS queue.
	// *   topicname: the name of the MNS topic.
	// *   templatename: the name of the OOS template.
	NotificationMetadata *string `json:"NotificationMetadata,omitempty" xml:"NotificationMetadata,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The status into which you want to put the lifecycle hook. Valid values:
	//
	// *   Active
	// *   InActive
	//
	// If you do not specify this parameter, the status of the lifecycle hook remains unchanged after you call this operation.
	//
	// > By default, a lifecycle hook is in the Active state after you create it.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The name of the lifecycle hook that you want to modify.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s ModifyLifecycleHookRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyLifecycleHookRequest) GoString() string {
	return s.String()
}

func (s *ModifyLifecycleHookRequest) SetDefaultResult(v string) *ModifyLifecycleHookRequest {
	s.DefaultResult = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetHeartbeatTimeout(v int32) *ModifyLifecycleHookRequest {
	s.HeartbeatTimeout = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetLifecycleHookId(v string) *ModifyLifecycleHookRequest {
	s.LifecycleHookId = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetLifecycleHookName(v string) *ModifyLifecycleHookRequest {
	s.LifecycleHookName = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetLifecycleHookStatus(v string) *ModifyLifecycleHookRequest {
	s.LifecycleHookStatus = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetLifecycleTransition(v string) *ModifyLifecycleHookRequest {
	s.LifecycleTransition = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetNotificationArn(v string) *ModifyLifecycleHookRequest {
	s.NotificationArn = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetNotificationMetadata(v string) *ModifyLifecycleHookRequest {
	s.NotificationMetadata = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetOwnerAccount(v string) *ModifyLifecycleHookRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetOwnerId(v int64) *ModifyLifecycleHookRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetRegionId(v string) *ModifyLifecycleHookRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetResourceOwnerAccount(v string) *ModifyLifecycleHookRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyLifecycleHookRequest) SetScalingGroupId(v string) *ModifyLifecycleHookRequest {
	s.ScalingGroupId = &v
	return s
}

type ModifyLifecycleHookResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyLifecycleHookResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyLifecycleHookResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyLifecycleHookResponseBody) SetRequestId(v string) *ModifyLifecycleHookResponseBody {
	s.RequestId = &v
	return s
}

type ModifyLifecycleHookResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyLifecycleHookResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyLifecycleHookResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyLifecycleHookResponse) GoString() string {
	return s.String()
}

func (s *ModifyLifecycleHookResponse) SetHeaders(v map[string]*string) *ModifyLifecycleHookResponse {
	s.Headers = v
	return s
}

func (s *ModifyLifecycleHookResponse) SetStatusCode(v int32) *ModifyLifecycleHookResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyLifecycleHookResponse) SetBody(v *ModifyLifecycleHookResponseBody) *ModifyLifecycleHookResponse {
	s.Body = v
	return s
}

type ModifyNotificationConfigurationRequest struct {
	// The types of the notifications that you want to modify. You can modify one to eight notifications. Specify multiple values in the repeated list form.
	//
	// You can call the DescribeNotificationTypes operation to query the values of this parameter.
	NotificationArn *string `json:"NotificationArn,omitempty" xml:"NotificationArn,omitempty"`
	// The types of the notifications that you want to modify. You can modify one to eight notifications. Specify multiple values in the repeated list form.
	//
	// You can call the DescribeNotificationTypes operation to query the values of this parameter.
	NotificationTypes []*string `json:"NotificationTypes,omitempty" xml:"NotificationTypes,omitempty" type:"Repeated"`
	OwnerId           *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the notification method. The following list describes the value formats of this parameter:
	//
	// *   If you use CloudMonitor as the notification method, the value format of this parameter is acs:ess:{region-id}:{account-id}:cloudmonitor.
	// *   If you use an MNS queue as the notification method, the value format of this parameter is acs:mns:{region-id}:{account-id}:queue/{queuename}.
	// *   If you use an MNS topic as the notification method, the value format of this parameter is acs:mns:{region-id}:{account-id}:topic/{topicname}.
	//
	// The variables in the preceding formats have the following meanings:
	//
	// *   region-id: the region ID of the scaling group.
	// *   account-id: the ID of the Alibaba Cloud account.
	// *   queuename: the name of the MNS queue.
	// *   topicname: the name of the MNS topic.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s ModifyNotificationConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyNotificationConfigurationRequest) GoString() string {
	return s.String()
}

func (s *ModifyNotificationConfigurationRequest) SetNotificationArn(v string) *ModifyNotificationConfigurationRequest {
	s.NotificationArn = &v
	return s
}

func (s *ModifyNotificationConfigurationRequest) SetNotificationTypes(v []*string) *ModifyNotificationConfigurationRequest {
	s.NotificationTypes = v
	return s
}

func (s *ModifyNotificationConfigurationRequest) SetOwnerId(v int64) *ModifyNotificationConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyNotificationConfigurationRequest) SetRegionId(v string) *ModifyNotificationConfigurationRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyNotificationConfigurationRequest) SetResourceOwnerAccount(v string) *ModifyNotificationConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyNotificationConfigurationRequest) SetScalingGroupId(v string) *ModifyNotificationConfigurationRequest {
	s.ScalingGroupId = &v
	return s
}

type ModifyNotificationConfigurationResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyNotificationConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyNotificationConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyNotificationConfigurationResponseBody) SetRequestId(v string) *ModifyNotificationConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type ModifyNotificationConfigurationResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyNotificationConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyNotificationConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyNotificationConfigurationResponse) GoString() string {
	return s.String()
}

func (s *ModifyNotificationConfigurationResponse) SetHeaders(v map[string]*string) *ModifyNotificationConfigurationResponse {
	s.Headers = v
	return s
}

func (s *ModifyNotificationConfigurationResponse) SetStatusCode(v int32) *ModifyNotificationConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyNotificationConfigurationResponse) SetBody(v *ModifyNotificationConfigurationResponseBody) *ModifyNotificationConfigurationResponse {
	s.Body = v
	return s
}

type ModifyScalingConfigurationRequest struct {
	PrivatePoolOptions *ModifyScalingConfigurationRequestPrivatePoolOptions `json:"PrivatePoolOptions,omitempty" xml:"PrivatePoolOptions,omitempty" type:"Struct"`
	SystemDisk         *ModifyScalingConfigurationRequestSystemDisk         `json:"SystemDisk,omitempty" xml:"SystemDisk,omitempty" type:"Struct"`
	// Specifies whether to associate the instance on a dedicated host with the dedicated host. Valid values:
	//
	// *   default: does not associate the instance with the dedicated host. If you start an instance that was stopped in economical mode and the original dedicated host of the instance has insufficient resources, the instance is automatically deployed to another dedicated host in the automatic deployment resource pool.
	// *   host: associates the instance with the dedicated host. If you start an instance that was stopped in economical mode, the instance remains on the original dedicated host. If the original dedicated host of the instance has insufficient resources, you cannot start the instance.
	Affinity *string `json:"Affinity,omitempty" xml:"Affinity,omitempty"`
	// The number of vCPUs.
	//
	// You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.
	//
	// > You can specify the Cpu and Memory parameters to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The performance mode of the burstable instance. Valid values:
	//
	// *   Standard: standard mode. For more information, see the "Standard mode" section in [Burstable instances](~~59977~~).
	// *   Unlimited: unlimited mode. For more information, see the "Unlimited mode" section in [Burstable instances](~~59977~~).
	CreditSpecification *string `json:"CreditSpecification,omitempty" xml:"CreditSpecification,omitempty"`
	// Details of the data disks.
	DataDisks []*ModifyScalingConfigurationRequestDataDisks `json:"DataDisks,omitempty" xml:"DataDisks,omitempty" type:"Repeated"`
	// The ID of the dedicated host on which you want to create the ECS instance. You cannot create preemptible instances on dedicated hosts. If you specify the DedicatedHostId parameter, the SpotStrategy and SpotPriceLimit parameters are ignored.
	//
	// You can call the DescribeDedicatedHosts operation to query dedicated host IDs.
	DedicatedHostId *string `json:"DedicatedHostId,omitempty" xml:"DedicatedHostId,omitempty"`
	// The ID of the deployment set to which the ECS instance belongs.
	DeploymentSetId *string `json:"DeploymentSetId,omitempty" xml:"DeploymentSetId,omitempty"`
	// The hostname of the ECS instance. The hostname cannot start or end with a period (.) or a hyphen (-). The hostname cannot contain consecutive periods (.) or hyphens (-). Naming conventions for different types of instances:
	//
	// *   Windows instances: The hostname must be 2 to 15 characters in length, and can contain letters, digits, and hyphens (-). The hostname cannot contain periods (.) or contain only digits.
	// *   Other instances such as Linux instances: The hostname must be 2 to 64 characters in length. You can use periods (.) to separate a hostname into multiple segments. Each segment can contain letters, digits, and hyphens (-).
	HostName *string `json:"HostName,omitempty" xml:"HostName,omitempty"`
	// The ID of the Elastic High Performance Computing (E-HPC) cluster to which the ECS instance belongs.
	HpcClusterId *string `json:"HpcClusterId,omitempty" xml:"HpcClusterId,omitempty"`
	// The name of the image family. You can specify this parameter to obtain the latest custom images that are available in the specified image family. The images are used to create instances. If the ImageId parameter is specified, you cannot specify the ImageFamily parameter.
	ImageFamily *string `json:"ImageFamily,omitempty" xml:"ImageFamily,omitempty"`
	// The ID of the image that is used by Auto Scaling to automatically create instances.
	//
	// > If the image that is specified in the scaling configuration contains system disks and data disks, the data that is stored in the data disks is cleared after you modify the image.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The name of the image. Each image name must be unique in a region. If you specify the ImageId parameter, the ImageName parameter is ignored.
	//
	// You cannot use the ImageName parameter to specify Alibaba Cloud Marketplace images.
	ImageName *string `json:"ImageName,omitempty" xml:"ImageName,omitempty"`
	// The description of the ECS instance. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
	InstanceDescription *string `json:"InstanceDescription,omitempty" xml:"InstanceDescription,omitempty"`
	// The name of the ECS instance that is automatically created based on the scaling configuration.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// Information about the intelligent configuration settings, which determines the available instance types.
	InstancePatternInfos []*ModifyScalingConfigurationRequestInstancePatternInfos `json:"InstancePatternInfos,omitempty" xml:"InstancePatternInfos,omitempty" type:"Repeated"`
	// Information about the instance type.
	InstanceTypeOverrides []*ModifyScalingConfigurationRequestInstanceTypeOverrides `json:"InstanceTypeOverrides,omitempty" xml:"InstanceTypeOverrides,omitempty" type:"Repeated"`
	// The instance types. If you specify this parameter, the InstanceType parameter is ignored. You can specify up to 10 instance types in a scaling configuration.
	//
	// The first instance type has the highest priority. The priority decreases based on the specified order of instance types. Auto Scaling creates instances based on the priorities of the instance types. If Auto Scaling cannot create instances of the instance type that has the highest priority, Auto Scaling creates instances of the instance type that has the next highest priority.
	InstanceTypes []*string `json:"InstanceTypes,omitempty" xml:"InstanceTypes,omitempty" type:"Repeated"`
	// The billing method for network usage. Valid values:
	//
	// *   PayByBandwidth: You are charged for the maximum available bandwidth that is specified by the InternetMaxBandwidthOut parameter.
	// *   PayByTraffic: You are charged for the actual traffic that is used. The InternetMaxBandwidthOut parameter specifies only the maximum available bandwidth.
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The maximum outbound public bandwidth. Unit: Mbit/s. Valid values:
	//
	// *   0 to 100 if you set the InternetChargeType parameter to PayByBandwidth. If you leave this parameter empty, this parameter is automatically set to 0.
	// *   0 to 100 if you set the InternetChargeType parameter to PayByTraffic. If you leave this parameter empty, an error will be reported.
	InternetMaxBandwidthOut *int32 `json:"InternetMaxBandwidthOut,omitempty" xml:"InternetMaxBandwidthOut,omitempty"`
	// Specifies whether to create an I/O optimized instance. Valid values:
	//
	// *   none: does not create an I/O optimized instance.
	// *   optimized: creates an I/O optimized instance.
	IoOptimized *string `json:"IoOptimized,omitempty" xml:"IoOptimized,omitempty"`
	// The number of randomly generated IPv6 addresses that you want to allocate to the elastic network interface (ENI).
	Ipv6AddressCount *int32 `json:"Ipv6AddressCount,omitempty" xml:"Ipv6AddressCount,omitempty"`
	// The name of the key pair that is used to log on to the ECS instance.
	//
	// *   Windows instances do not use this parameter.
	// *   By default, the username and password authentication method is disabled for Linux instances.
	KeyPairName *string `json:"KeyPairName,omitempty" xml:"KeyPairName,omitempty"`
	// The weight of the ECS instance as a backend server. Valid values: 1 to 100.
	LoadBalancerWeight *int32 `json:"LoadBalancerWeight,omitempty" xml:"LoadBalancerWeight,omitempty"`
	// The size of the memory. Unit: GiB.
	//
	// You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.
	//
	// > You can specify the Cpu and Memory parameters to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
	Memory *int32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// Specifies whether to overwrite existing data. Valid values:
	//
	// *   true: overwrites existing data.
	// *   false: does not overwrite existing data.
	Override     *bool   `json:"Override,omitempty" xml:"Override,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Specifies whether to use the password that is preconfigured in the image. Before you use this parameter, make sure that a password is configured for the image.
	PasswordInherit *bool `json:"PasswordInherit,omitempty" xml:"PasswordInherit,omitempty"`
	// The name of the RAM role that is associated with the ECS instance. The name is provided and maintained by Resource Access Management (RAM). You can call the ListRoles operation to query the available RAM roles. You can call the CreateRole operation to create RAM roles.
	RamRoleName *string `json:"RamRoleName,omitempty" xml:"RamRoleName,omitempty"`
	// The ID of the resource group to which the ECS instance belongs.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling configuration that you want to modify.
	ScalingConfigurationId *string `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
	// The name of the scaling configuration. The name must be 2 to 64 characters in length and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). It must start with a letter or a digit.
	//
	// The name of the scaling configuration must be unique within a scaling group in a region. If you do not specify the ScalingConfigurationName parameter, the scaling configuration ID is used.
	ScalingConfigurationName *string `json:"ScalingConfigurationName,omitempty" xml:"ScalingConfigurationName,omitempty"`
	// The options of the scheduler.
	SchedulerOptions map[string]interface{} `json:"SchedulerOptions,omitempty" xml:"SchedulerOptions,omitempty"`
	// The ID of the security group with which the ECS instance is associated. The ECS instances that are associated with the same security group can access each other.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// The IDs of the security groups.
	SecurityGroupIds []*string `json:"SecurityGroupIds,omitempty" xml:"SecurityGroupIds,omitempty" type:"Repeated"`
	// The retention period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.
	//
	// *   The following retention periods are available in invitational preview: 2, 3, 4, 5, and 6 hours. If you want to set this parameter to one of these values, submit a ticket.
	// *   If you set this parameter to 0, no retention period is specified for the preemptible instance.
	SpotDuration *int32 `json:"SpotDuration,omitempty" xml:"SpotDuration,omitempty"`
	// The interruption event of the preemptible instance. Default value: Terminate. Set the value to Terminate, which specifies that the preemptible instance is to be released.
	SpotInterruptionBehavior *string `json:"SpotInterruptionBehavior,omitempty" xml:"SpotInterruptionBehavior,omitempty"`
	// Information about the instance types of preemptible instances.
	SpotPriceLimits []*ModifyScalingConfigurationRequestSpotPriceLimits `json:"SpotPriceLimits,omitempty" xml:"SpotPriceLimits,omitempty" type:"Repeated"`
	// The preemption policy that you want to apply to pay-as-you-go instances and preemptible instances. Valid values:
	//
	// *   NoSpot: The instance is created as a pay-as-you-go instance.
	// *   SpotWithPriceLimit: The instance is a preemptible instance that has a user-defined maximum hourly price.
	// *   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.
	SpotStrategy *string `json:"SpotStrategy,omitempty" xml:"SpotStrategy,omitempty"`
	// The categories of the system disks. You can specify one to four disk categories in a scaling configuration. The first disk category that is specified in a scaling configuration has the highest priority. The priority deceases based on the specified order of disk categories. If Auto Scaling cannot create instances by using the disk category that has the highest priority, Auto Scaling creates instances by using the disk category that has the next highest priority. Valid values:
	//
	// *   cloud: basic disk.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   cloud_essd: ESSD.
	//
	// > You cannot specify the SystemDiskCategories and `SystemDisk.Category` parameters at the same time.
	SystemDiskCategories []*string `json:"SystemDiskCategories,omitempty" xml:"SystemDiskCategories,omitempty" type:"Repeated"`
	// The tags of the ECS instance. The tags must be specified in the key-value pair format. You can specify up to 20 tags. When you specify tag keys and tag values, take note of the following items:
	//
	// *   A tag key can be up to 64 characters in length. The key cannot start with `acs:` or `aliyun`, and cannot contain `http://` or `https://`. You cannot specify an empty string as a tag key.
	// *   A tag value can be up to 128 characters in length. The value cannot start with `acs:` or `aliyun`, and cannot contain `http://` or `https://`. You can specify an empty string as a tag value.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// Specifies whether to create the instance on a dedicated host. Valid values:
	//
	// *   default: does not create the instance on a dedicated host.
	// *   host: creates the instance on a dedicated host. If you do not specify the DedicatedHostId parameter, Alibaba Cloud selects a dedicated host for the instance that you want to create.
	Tenancy *string `json:"Tenancy,omitempty" xml:"Tenancy,omitempty"`
	// The user data of the ECS instance. The data must be encoded in Base64. The maximum size of the data before encoding is 16 KB.
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The zone ID of the ECS instance.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s ModifyScalingConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationRequest) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationRequest) SetPrivatePoolOptions(v *ModifyScalingConfigurationRequestPrivatePoolOptions) *ModifyScalingConfigurationRequest {
	s.PrivatePoolOptions = v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetSystemDisk(v *ModifyScalingConfigurationRequestSystemDisk) *ModifyScalingConfigurationRequest {
	s.SystemDisk = v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetAffinity(v string) *ModifyScalingConfigurationRequest {
	s.Affinity = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetCpu(v int32) *ModifyScalingConfigurationRequest {
	s.Cpu = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetCreditSpecification(v string) *ModifyScalingConfigurationRequest {
	s.CreditSpecification = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetDataDisks(v []*ModifyScalingConfigurationRequestDataDisks) *ModifyScalingConfigurationRequest {
	s.DataDisks = v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetDedicatedHostId(v string) *ModifyScalingConfigurationRequest {
	s.DedicatedHostId = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetDeploymentSetId(v string) *ModifyScalingConfigurationRequest {
	s.DeploymentSetId = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetHostName(v string) *ModifyScalingConfigurationRequest {
	s.HostName = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetHpcClusterId(v string) *ModifyScalingConfigurationRequest {
	s.HpcClusterId = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetImageFamily(v string) *ModifyScalingConfigurationRequest {
	s.ImageFamily = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetImageId(v string) *ModifyScalingConfigurationRequest {
	s.ImageId = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetImageName(v string) *ModifyScalingConfigurationRequest {
	s.ImageName = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetInstanceDescription(v string) *ModifyScalingConfigurationRequest {
	s.InstanceDescription = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetInstanceName(v string) *ModifyScalingConfigurationRequest {
	s.InstanceName = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetInstancePatternInfos(v []*ModifyScalingConfigurationRequestInstancePatternInfos) *ModifyScalingConfigurationRequest {
	s.InstancePatternInfos = v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetInstanceTypeOverrides(v []*ModifyScalingConfigurationRequestInstanceTypeOverrides) *ModifyScalingConfigurationRequest {
	s.InstanceTypeOverrides = v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetInstanceTypes(v []*string) *ModifyScalingConfigurationRequest {
	s.InstanceTypes = v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetInternetChargeType(v string) *ModifyScalingConfigurationRequest {
	s.InternetChargeType = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetInternetMaxBandwidthOut(v int32) *ModifyScalingConfigurationRequest {
	s.InternetMaxBandwidthOut = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetIoOptimized(v string) *ModifyScalingConfigurationRequest {
	s.IoOptimized = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetIpv6AddressCount(v int32) *ModifyScalingConfigurationRequest {
	s.Ipv6AddressCount = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetKeyPairName(v string) *ModifyScalingConfigurationRequest {
	s.KeyPairName = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetLoadBalancerWeight(v int32) *ModifyScalingConfigurationRequest {
	s.LoadBalancerWeight = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetMemory(v int32) *ModifyScalingConfigurationRequest {
	s.Memory = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetOverride(v bool) *ModifyScalingConfigurationRequest {
	s.Override = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetOwnerAccount(v string) *ModifyScalingConfigurationRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetOwnerId(v int64) *ModifyScalingConfigurationRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetPasswordInherit(v bool) *ModifyScalingConfigurationRequest {
	s.PasswordInherit = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetRamRoleName(v string) *ModifyScalingConfigurationRequest {
	s.RamRoleName = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetResourceGroupId(v string) *ModifyScalingConfigurationRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetResourceOwnerAccount(v string) *ModifyScalingConfigurationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetScalingConfigurationId(v string) *ModifyScalingConfigurationRequest {
	s.ScalingConfigurationId = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetScalingConfigurationName(v string) *ModifyScalingConfigurationRequest {
	s.ScalingConfigurationName = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetSchedulerOptions(v map[string]interface{}) *ModifyScalingConfigurationRequest {
	s.SchedulerOptions = v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetSecurityGroupId(v string) *ModifyScalingConfigurationRequest {
	s.SecurityGroupId = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetSecurityGroupIds(v []*string) *ModifyScalingConfigurationRequest {
	s.SecurityGroupIds = v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetSpotDuration(v int32) *ModifyScalingConfigurationRequest {
	s.SpotDuration = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetSpotInterruptionBehavior(v string) *ModifyScalingConfigurationRequest {
	s.SpotInterruptionBehavior = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetSpotPriceLimits(v []*ModifyScalingConfigurationRequestSpotPriceLimits) *ModifyScalingConfigurationRequest {
	s.SpotPriceLimits = v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetSpotStrategy(v string) *ModifyScalingConfigurationRequest {
	s.SpotStrategy = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetSystemDiskCategories(v []*string) *ModifyScalingConfigurationRequest {
	s.SystemDiskCategories = v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetTags(v string) *ModifyScalingConfigurationRequest {
	s.Tags = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetTenancy(v string) *ModifyScalingConfigurationRequest {
	s.Tenancy = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetUserData(v string) *ModifyScalingConfigurationRequest {
	s.UserData = &v
	return s
}

func (s *ModifyScalingConfigurationRequest) SetZoneId(v string) *ModifyScalingConfigurationRequest {
	s.ZoneId = &v
	return s
}

type ModifyScalingConfigurationRequestPrivatePoolOptions struct {
	// The ID of the private pool. The ID of a private pool is the same as the ID of the elasticity assurance or capacity reservation for which the private pool is generated.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The type of the private pool that you want to use to create instances. A private pool is generated when an elasticity assurance or a capacity reservation takes effect. You can select a private pool when you create instances. Valid values:
	//
	// *   Open: open private pool. The system selects an open private pool for instance startup. If no open private pool meets your business requirements, the resources in the public pool are used for instance startup. In this case, you do not need to specify the PrivatePoolOptions.Id parameter.
	// *   Target: specified private pool. The resources in the specified private pool are used for instance startup. If the specified private pool is unavailable, the instance startup fails. If you set this parameter to Target, you must specify the PrivatePoolOptions.Id parameter.
	// *   None: no private pool. The resources of private pools are not used for instance startup.
	MatchCriteria *string `json:"MatchCriteria,omitempty" xml:"MatchCriteria,omitempty"`
}

func (s ModifyScalingConfigurationRequestPrivatePoolOptions) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationRequestPrivatePoolOptions) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationRequestPrivatePoolOptions) SetId(v string) *ModifyScalingConfigurationRequestPrivatePoolOptions {
	s.Id = &v
	return s
}

func (s *ModifyScalingConfigurationRequestPrivatePoolOptions) SetMatchCriteria(v string) *ModifyScalingConfigurationRequestPrivatePoolOptions {
	s.MatchCriteria = &v
	return s
}

type ModifyScalingConfigurationRequestSystemDisk struct {
	// The ID of the automatic snapshot policy that you want to apply to the system disk.
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// Specifies whether to enable the burst feature for the system disk. Valid values:
	//
	// *   true
	// *   false
	//
	// > This parameter is available only if you set the `SystemDisk.Category` parameter to `cloud_auto`.
	//
	// For more information, see [ESSD AutoPL disks](~~368372~~).
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The category of the system disk. Valid values:
	//
	// *   cloud: basic disk.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   cloud_essd: ESSD.
	// *   ephemeral_ssd: local SSD.
	//
	// You cannot specify the SystemDisk.Category and `SystemDiskCategories` parameters at the same time. If you do not specify the Category and `SystemDiskCategories` parameters, the default value of the Category parameter is used. For non-I/O optimized instances of Generation I instance types, the default value is cloud. For instances of other instance types, the default value is cloud_efficiency.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The description of the system disk. The description must be 2 to 256 characters in length. The description can contain letters but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the system disk. The name must be 2 to 128 characters in length. The name must start with a letter but cannot start with `http://` or `https://`. The name can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
	DiskName *string `json:"DiskName,omitempty" xml:"DiskName,omitempty"`
	// The algorithm that is used to encrypt the system disk. Valid values:
	//
	// *   AES-256
	// *   SM4-128
	//
	// Default value: AES-256.
	EncryptAlgorithm *string `json:"EncryptAlgorithm,omitempty" xml:"EncryptAlgorithm,omitempty"`
	// Specifies whether to encrypt the system disk. Valid values:
	//
	// *   true: encrypts the system disk.
	// *   false: does not encrypt the system disk.
	//
	// Default value: false.
	Encrypted *bool `json:"Encrypted,omitempty" xml:"Encrypted,omitempty"`
	// The ID of the KMS key that is used to encrypt the system disk.
	KMSKeyId *string `json:"KMSKeyId,omitempty" xml:"KMSKeyId,omitempty"`
	// The PL of the system disk of the ESSD category. Valid values:
	//
	// *   PL0: An ESSD can deliver up to 10,000 random read/write IOPS.
	// *   PL1: An ESSD can deliver up to 50,000 random read/write IOPS.
	// *   PL2: An ESSD can deliver up to 100,000 random read/write IOPS.
	// *   PL3: An ESSD can deliver up to 1,000,000 random read/write IOPS.
	//
	// > For more information about how to choose ESSD PLs, see [ESSD](~~122389~~).
	PerformanceLevel *string `json:"PerformanceLevel,omitempty" xml:"PerformanceLevel,omitempty"`
	// The IOPS metric that is preconfigured for the system disk.
	//
	// > IOPS measures the number of read and write operations that an EBS device can process per second.
	ProvisionedIops *int64 `json:"ProvisionedIops,omitempty" xml:"ProvisionedIops,omitempty"`
	// The size of the system disk. Unit: GiB.
	//
	// *   Valid values if you set the SystemDisk.Category parameter to cloud: 20 to 500.
	// *   Valid values if you set the SystemDisk.Category parameter to cloud_efficiency: 20 to 500
	// *   Valid values if you set the SystemDisk.Category parameter to cloud_ssd: 20 to 500
	// *   Valid values if you set the SystemDisk.Category parameter to cloud_essd: 20 to 500
	// *   Valid values if you set the SystemDisk.Category parameter to ephemeral_ssd: 20 to 500
	//
	// The value of SystemDisk.Size must be greater than or equal to max{20, ImageSize}.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
}

func (s ModifyScalingConfigurationRequestSystemDisk) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationRequestSystemDisk) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationRequestSystemDisk) SetAutoSnapshotPolicyId(v string) *ModifyScalingConfigurationRequestSystemDisk {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *ModifyScalingConfigurationRequestSystemDisk) SetBurstingEnabled(v bool) *ModifyScalingConfigurationRequestSystemDisk {
	s.BurstingEnabled = &v
	return s
}

func (s *ModifyScalingConfigurationRequestSystemDisk) SetCategory(v string) *ModifyScalingConfigurationRequestSystemDisk {
	s.Category = &v
	return s
}

func (s *ModifyScalingConfigurationRequestSystemDisk) SetDescription(v string) *ModifyScalingConfigurationRequestSystemDisk {
	s.Description = &v
	return s
}

func (s *ModifyScalingConfigurationRequestSystemDisk) SetDiskName(v string) *ModifyScalingConfigurationRequestSystemDisk {
	s.DiskName = &v
	return s
}

func (s *ModifyScalingConfigurationRequestSystemDisk) SetEncryptAlgorithm(v string) *ModifyScalingConfigurationRequestSystemDisk {
	s.EncryptAlgorithm = &v
	return s
}

func (s *ModifyScalingConfigurationRequestSystemDisk) SetEncrypted(v bool) *ModifyScalingConfigurationRequestSystemDisk {
	s.Encrypted = &v
	return s
}

func (s *ModifyScalingConfigurationRequestSystemDisk) SetKMSKeyId(v string) *ModifyScalingConfigurationRequestSystemDisk {
	s.KMSKeyId = &v
	return s
}

func (s *ModifyScalingConfigurationRequestSystemDisk) SetPerformanceLevel(v string) *ModifyScalingConfigurationRequestSystemDisk {
	s.PerformanceLevel = &v
	return s
}

func (s *ModifyScalingConfigurationRequestSystemDisk) SetProvisionedIops(v int64) *ModifyScalingConfigurationRequestSystemDisk {
	s.ProvisionedIops = &v
	return s
}

func (s *ModifyScalingConfigurationRequestSystemDisk) SetSize(v int32) *ModifyScalingConfigurationRequestSystemDisk {
	s.Size = &v
	return s
}

type ModifyScalingConfigurationRequestDataDisks struct {
	// The ID of the automatic snapshot policy that you want to apply to the data disk.
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// Specifies whether to enable the burst feature for the system disk. Valid values:
	//
	// *   true
	// *   false
	//
	// > This parameter is available only if you set the `SystemDisk.Category` parameter to `cloud_auto`.
	//
	// For more information, see [ESSD AutoPL disks](~~368372~~).
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The categories of the data disks. You can specify 1 to 16 data disks. You can specify 1 to 4 disk categories in a scaling configuration. The first disk category that is specified in a scaling configuration has the highest priority. The priority deceases based on the specified order of disk categories. If Auto Scaling cannot create instances by using the data disk that has the highest priority, Auto Scaling creates instances by using the data disk that has the next highest priority. Valid values:
	//
	// *   cloud: basic disk. The DeleteWithInstance attribute of a basic disk that is created together with the instance is set to true.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   cloud_essd: ESSD.
	//
	// > You cannot specify the Categories and `Category` parameters at the same time.
	Categories []*string `json:"Categories,omitempty" xml:"Categories,omitempty" type:"Repeated"`
	// The category of the data disk. You can specify 1 to 16 data disks. Valid values:
	//
	// *   cloud: basic disk. The DeleteWithInstance attribute of a basic disk that is created together with the instance is set to true.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   ephemeral_ssd: local standard SSD.
	// *   cloud_essd: ESSD.
	//
	// You cannot specify the Category and `Categories` parameters at the same time. If you do not specify the Category and `Categories` parameters, the default value of the Category parameter is:
	//
	// *   cloud_efficiency for I/O optimized instances.
	// *   cloud for non-I/O optimized instances.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// Specifies whether to release the data disk when the instance to which the data disk is attached is released. Valid values:
	//
	// *   true
	// *   false
	//
	// This parameter is available only for independent disks whose Category parameter is set to cloud, cloud_efficiency, cloud_ssd, cloud_essd, or cloud_auto. If you specify this parameter for disks of other categories, an error will be reported.
	DeleteWithInstance *bool `json:"DeleteWithInstance,omitempty" xml:"DeleteWithInstance,omitempty"`
	// The description of the system disk. The description must be 2 to 256 characters in length. The description can contain letters but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The mount target of the data disk. If you do not specify the Device parameter, a mount target is automatically created when Auto Scaling creates ECS instance. The name of the mount target ranges from /dev/xvdb to /dev/xvdz.
	Device *string `json:"Device,omitempty" xml:"Device,omitempty"`
	// The name of the system disk. The name must be 2 to 128 characters in length and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
	DiskName *string `json:"DiskName,omitempty" xml:"DiskName,omitempty"`
	// Specifies whether to encrypt the system disk. Valid values:
	//
	// *   true: encrypts the system disk.
	// *   false: does not encrypt the system disk.
	Encrypted *string `json:"Encrypted,omitempty" xml:"Encrypted,omitempty"`
	// The ID of the KMS key of the data disk.
	KMSKeyId *string `json:"KMSKeyId,omitempty" xml:"KMSKeyId,omitempty"`
	// The PL of the data disk of the ESSD category. If you set the Category parameter to cloud_essd, you must also specify the PerformanceLevel parameter. Valid values:
	//
	// *   PL0: An ESSD can deliver up to 10,000 random read/write IOPS.
	// *   PL1: An ESSD can deliver up to 50,000 random read/write IOPS.
	// *   PL2: An ESSD can deliver up to 100,000 random read/write IOPS.
	// *   PL3: An ESSD can deliver up to 1,000,000 random read/write IOPS.
	//
	// > For more information about how to choose ESSD PLs, see [ESSD](~~122389~~).
	PerformanceLevel *string `json:"PerformanceLevel,omitempty" xml:"PerformanceLevel,omitempty"`
	// The input/output operations per second (IOPS) metric that is preconfigured for the data disk.
	//
	// > IOPS measures the number of read and write operations that an EBS device can process per second.
	ProvisionedIops *int64 `json:"ProvisionedIops,omitempty" xml:"ProvisionedIops,omitempty"`
	// The size of the data disk. Unit: GiB.
	//
	// *   Valid values if you set the Category parameter to cloud: 5 to 2000.
	// *   Valid values if you set the Category parameter to cloud_efficiency: 20 to 32768.
	// *   Valid values if you set the Category parameter to cloud_ssd: 20 to 32768.
	// *   Valid values if you set the Category parameter to cloud_essd: 20 to 32768.
	// *   Valid values if you set the Category parameter to ephemeral_ssd: 5 to 800.
	//
	// The value of the Size parameter must be greater than or equal to the size of the snapshot that is specified by the SnapshotId parameter.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The ID of the snapshot that you want to use to create data disks. If you specify this parameter, the Size parameter is ignored. The size of the disk is the same as the size of the specified snapshot.
	//
	// If you specify a snapshot created on or before July 15, 2013, the operation fails and the system returns InvalidSnapshot.TooOld.
	SnapshotId *string `json:"SnapshotId,omitempty" xml:"SnapshotId,omitempty"`
}

func (s ModifyScalingConfigurationRequestDataDisks) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationRequestDataDisks) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetAutoSnapshotPolicyId(v string) *ModifyScalingConfigurationRequestDataDisks {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetBurstingEnabled(v bool) *ModifyScalingConfigurationRequestDataDisks {
	s.BurstingEnabled = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetCategories(v []*string) *ModifyScalingConfigurationRequestDataDisks {
	s.Categories = v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetCategory(v string) *ModifyScalingConfigurationRequestDataDisks {
	s.Category = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetDeleteWithInstance(v bool) *ModifyScalingConfigurationRequestDataDisks {
	s.DeleteWithInstance = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetDescription(v string) *ModifyScalingConfigurationRequestDataDisks {
	s.Description = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetDevice(v string) *ModifyScalingConfigurationRequestDataDisks {
	s.Device = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetDiskName(v string) *ModifyScalingConfigurationRequestDataDisks {
	s.DiskName = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetEncrypted(v string) *ModifyScalingConfigurationRequestDataDisks {
	s.Encrypted = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetKMSKeyId(v string) *ModifyScalingConfigurationRequestDataDisks {
	s.KMSKeyId = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetPerformanceLevel(v string) *ModifyScalingConfigurationRequestDataDisks {
	s.PerformanceLevel = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetProvisionedIops(v int64) *ModifyScalingConfigurationRequestDataDisks {
	s.ProvisionedIops = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetSize(v int32) *ModifyScalingConfigurationRequestDataDisks {
	s.Size = &v
	return s
}

func (s *ModifyScalingConfigurationRequestDataDisks) SetSnapshotId(v string) *ModifyScalingConfigurationRequestDataDisks {
	s.SnapshotId = &v
	return s
}

type ModifyScalingConfigurationRequestInstancePatternInfos struct {
	// The architectures of the instance types. Valid values:
	//
	// *   X86: x86 architecture.
	// *   Heterogeneous: heterogeneous architecture, such as GPUs and FPGAs.
	// *   BareMetal: ECS Bare Metal Instance architecture.
	// *   Arm: ARM architecture.
	// *   SuperComputeCluster: Super Computing Cluster architecture.
	//
	// By default, all values are selected.
	Architectures []*string `json:"Architectures,omitempty" xml:"Architectures,omitempty" type:"Repeated"`
	// Specifies whether to include burstable instance types. Valid values:
	//
	// *   Exclude: excludes burstable instance types.
	// *   Include: includes burstable instance types.
	// *   Required: includes only burstable instance types.
	//
	// Default value: Include.
	BurstablePerformance *string `json:"BurstablePerformance,omitempty" xml:"BurstablePerformance,omitempty"`
	// The number of vCPUs that is specified for an instance type in the intelligent configuration mode. This parameter is used to filter the available instance types that meet the specified criteria. For more information, see [Instance family](~~25378~~).
	//
	// Take note of the following items:
	//
	// *   The InstancePatternInfos parameter is available only for scaling groups that reside in VPCs.
	// *   You must specify the InstancePatternInfos, Cores, and Memory parameters at the same time.
	// *   If you specify an instance type by using the InstanceType or InstanceTypes parameter, Auto Scaling preferentially uses the instance type that is specified by the InstanceType or InstanceTypes parameter for scale-out activities. If the specified instance type does not have sufficient inventory, Auto Scaling creates instances of the instance type that is specified by the InstancePatternInfos parameter based on the price in ascending order.
	Cores *int32 `json:"Cores,omitempty" xml:"Cores,omitempty"`
	// The instance types that you want to filter out. You can use wildcard characters such as an asterisk (\*) to filter out a single instance type or an instance family. Example:
	//
	// *   ecs.c6.large: The ecs.c6.large instance type is filtered out.
	// *   ecs.c6.\*: The c6 instance family is filtered out.
	ExcludedInstanceTypes []*string `json:"ExcludedInstanceTypes,omitempty" xml:"ExcludedInstanceTypes,omitempty" type:"Repeated"`
	// The level of the instance type, which is used to filter the instance types that meet the specified criteria. This parameter takes effect only if you set the `CostOptimization` parameter to true. Valid values:
	//
	// *   EntryLevel: shared instance type. Instances of this level are the most cost-effective but may not provide stable computing performance in a consistent manner. Instances of this level are suitable for business scenarios in which the CPU utilization is low. For more information, see [Shared instance families](~~108489~~).
	// *   EnterpriseLevel: Instances of this level provide stable performance and dedicated resources, and are suitable for business scenarios that require high stability. For more information, see [Instance family](~~25378~~).
	// *   CreditEntryLevel: This value is valid only for burstable instances. CPU credits are used to ensure computing performance. Instances of this level are suitable for scenarios in which the CPU utilization is low but may fluctuate in specific cases. For more information, see the [Overview](~~59977~~) topic of burstable instances.
	InstanceFamilyLevel *string `json:"InstanceFamilyLevel,omitempty" xml:"InstanceFamilyLevel,omitempty"`
	// The maximum hourly price for a pay-as-you-go instance or a preemptible instance in the intelligent configuration mode. This parameter is used to filter the available instance types that meet the specified criteria.
	//
	// > If you set the SpotStrategy parameter to SpotWithPriceLimit, you must specify the MaxPrice parameter. In other cases, you do not need to specify the MaxPrice parameter.
	MaxPrice *float32 `json:"MaxPrice,omitempty" xml:"MaxPrice,omitempty"`
	// The memory size that is specified for an instance type in the intelligent configuration mode. Unit: GiB. This parameter is used to filter the available instance types that meet the specified criteria.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
}

func (s ModifyScalingConfigurationRequestInstancePatternInfos) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationRequestInstancePatternInfos) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationRequestInstancePatternInfos) SetArchitectures(v []*string) *ModifyScalingConfigurationRequestInstancePatternInfos {
	s.Architectures = v
	return s
}

func (s *ModifyScalingConfigurationRequestInstancePatternInfos) SetBurstablePerformance(v string) *ModifyScalingConfigurationRequestInstancePatternInfos {
	s.BurstablePerformance = &v
	return s
}

func (s *ModifyScalingConfigurationRequestInstancePatternInfos) SetCores(v int32) *ModifyScalingConfigurationRequestInstancePatternInfos {
	s.Cores = &v
	return s
}

func (s *ModifyScalingConfigurationRequestInstancePatternInfos) SetExcludedInstanceTypes(v []*string) *ModifyScalingConfigurationRequestInstancePatternInfos {
	s.ExcludedInstanceTypes = v
	return s
}

func (s *ModifyScalingConfigurationRequestInstancePatternInfos) SetInstanceFamilyLevel(v string) *ModifyScalingConfigurationRequestInstancePatternInfos {
	s.InstanceFamilyLevel = &v
	return s
}

func (s *ModifyScalingConfigurationRequestInstancePatternInfos) SetMaxPrice(v float32) *ModifyScalingConfigurationRequestInstancePatternInfos {
	s.MaxPrice = &v
	return s
}

func (s *ModifyScalingConfigurationRequestInstancePatternInfos) SetMemory(v float32) *ModifyScalingConfigurationRequestInstancePatternInfos {
	s.Memory = &v
	return s
}

type ModifyScalingConfigurationRequestInstanceTypeOverrides struct {
	// The instance type. If you want to specify the weight of the instance type in the scaling configuration, you must specify the InstanceType and WeightedCapacity parameters at the same time.
	//
	// You can use the InstanceType parameter to specify 1 to 10 instance types. You can use the WeightedCapacity parameter to specify weights of instance types.
	//
	// > You cannot specify the InstanceType and InstanceTypes parameters at the same time.
	//
	// You can specify instance types that are available for purchase as the values of the InstanceType parameter.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The weight of the instance type. The weight of the instance type indicates the capacity of the instance of the specified instance type in the scaling group. If you want Auto Scaling to scale instances based on the instance type weight, you must specify the WeightedCapacity parameter after you specify the InstanceType parameter.
	//
	// A higher weight specifies that a smaller number of instances of the specified instance type are required to meet the expected capacity.
	//
	// Performance metrics, such as the number of vCPUs and the memory size of each instance type, may vary. You can specify different weights for different instance types based on your business requirements.
	//
	// Example:
	//
	// *   Current capacity: 0
	// *   Expected capacity: 6
	// *   Capacity of ecs.c5.xlarge: 4
	//
	// To meet the expected capacity requirement, Auto Scaling must create and add two ecs.c5.xlarge instances.
	//
	// > The capacity of the scaling group cannot exceed the sum of the maximum number of instances that is specified by the MaxSize parameter and the maximum weight of the instance types.
	//
	// Valid values of the WeightedCapacity parameter: 1 to 500.
	WeightedCapacity *int32 `json:"WeightedCapacity,omitempty" xml:"WeightedCapacity,omitempty"`
}

func (s ModifyScalingConfigurationRequestInstanceTypeOverrides) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationRequestInstanceTypeOverrides) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationRequestInstanceTypeOverrides) SetInstanceType(v string) *ModifyScalingConfigurationRequestInstanceTypeOverrides {
	s.InstanceType = &v
	return s
}

func (s *ModifyScalingConfigurationRequestInstanceTypeOverrides) SetWeightedCapacity(v int32) *ModifyScalingConfigurationRequestInstanceTypeOverrides {
	s.WeightedCapacity = &v
	return s
}

type ModifyScalingConfigurationRequestSpotPriceLimits struct {
	// The instance type of the preemptible instance. This parameter takes effect only if you set the SpotStrategy parameter to SpotWithPriceLimit.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The price limit of the preemptible instance. This parameter takes effect only if you set the SpotStrategy parameter to SpotWithPriceLimit.
	PriceLimit *float32 `json:"PriceLimit,omitempty" xml:"PriceLimit,omitempty"`
}

func (s ModifyScalingConfigurationRequestSpotPriceLimits) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationRequestSpotPriceLimits) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationRequestSpotPriceLimits) SetInstanceType(v string) *ModifyScalingConfigurationRequestSpotPriceLimits {
	s.InstanceType = &v
	return s
}

func (s *ModifyScalingConfigurationRequestSpotPriceLimits) SetPriceLimit(v float32) *ModifyScalingConfigurationRequestSpotPriceLimits {
	s.PriceLimit = &v
	return s
}

type ModifyScalingConfigurationShrinkRequest struct {
	PrivatePoolOptions *ModifyScalingConfigurationShrinkRequestPrivatePoolOptions `json:"PrivatePoolOptions,omitempty" xml:"PrivatePoolOptions,omitempty" type:"Struct"`
	SystemDisk         *ModifyScalingConfigurationShrinkRequestSystemDisk         `json:"SystemDisk,omitempty" xml:"SystemDisk,omitempty" type:"Struct"`
	// Specifies whether to associate the instance on a dedicated host with the dedicated host. Valid values:
	//
	// *   default: does not associate the instance with the dedicated host. If you start an instance that was stopped in economical mode and the original dedicated host of the instance has insufficient resources, the instance is automatically deployed to another dedicated host in the automatic deployment resource pool.
	// *   host: associates the instance with the dedicated host. If you start an instance that was stopped in economical mode, the instance remains on the original dedicated host. If the original dedicated host of the instance has insufficient resources, you cannot start the instance.
	Affinity *string `json:"Affinity,omitempty" xml:"Affinity,omitempty"`
	// The number of vCPUs.
	//
	// You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.
	//
	// > You can specify the Cpu and Memory parameters to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The performance mode of the burstable instance. Valid values:
	//
	// *   Standard: standard mode. For more information, see the "Standard mode" section in [Burstable instances](~~59977~~).
	// *   Unlimited: unlimited mode. For more information, see the "Unlimited mode" section in [Burstable instances](~~59977~~).
	CreditSpecification *string `json:"CreditSpecification,omitempty" xml:"CreditSpecification,omitempty"`
	// Details of the data disks.
	DataDisks []*ModifyScalingConfigurationShrinkRequestDataDisks `json:"DataDisks,omitempty" xml:"DataDisks,omitempty" type:"Repeated"`
	// The ID of the dedicated host on which you want to create the ECS instance. You cannot create preemptible instances on dedicated hosts. If you specify the DedicatedHostId parameter, the SpotStrategy and SpotPriceLimit parameters are ignored.
	//
	// You can call the DescribeDedicatedHosts operation to query dedicated host IDs.
	DedicatedHostId *string `json:"DedicatedHostId,omitempty" xml:"DedicatedHostId,omitempty"`
	// The ID of the deployment set to which the ECS instance belongs.
	DeploymentSetId *string `json:"DeploymentSetId,omitempty" xml:"DeploymentSetId,omitempty"`
	// The hostname of the ECS instance. The hostname cannot start or end with a period (.) or a hyphen (-). The hostname cannot contain consecutive periods (.) or hyphens (-). Naming conventions for different types of instances:
	//
	// *   Windows instances: The hostname must be 2 to 15 characters in length, and can contain letters, digits, and hyphens (-). The hostname cannot contain periods (.) or contain only digits.
	// *   Other instances such as Linux instances: The hostname must be 2 to 64 characters in length. You can use periods (.) to separate a hostname into multiple segments. Each segment can contain letters, digits, and hyphens (-).
	HostName *string `json:"HostName,omitempty" xml:"HostName,omitempty"`
	// The ID of the Elastic High Performance Computing (E-HPC) cluster to which the ECS instance belongs.
	HpcClusterId *string `json:"HpcClusterId,omitempty" xml:"HpcClusterId,omitempty"`
	// The name of the image family. You can specify this parameter to obtain the latest custom images that are available in the specified image family. The images are used to create instances. If the ImageId parameter is specified, you cannot specify the ImageFamily parameter.
	ImageFamily *string `json:"ImageFamily,omitempty" xml:"ImageFamily,omitempty"`
	// The ID of the image that is used by Auto Scaling to automatically create instances.
	//
	// > If the image that is specified in the scaling configuration contains system disks and data disks, the data that is stored in the data disks is cleared after you modify the image.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The name of the image. Each image name must be unique in a region. If you specify the ImageId parameter, the ImageName parameter is ignored.
	//
	// You cannot use the ImageName parameter to specify Alibaba Cloud Marketplace images.
	ImageName *string `json:"ImageName,omitempty" xml:"ImageName,omitempty"`
	// The description of the ECS instance. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
	InstanceDescription *string `json:"InstanceDescription,omitempty" xml:"InstanceDescription,omitempty"`
	// The name of the ECS instance that is automatically created based on the scaling configuration.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// Information about the intelligent configuration settings, which determines the available instance types.
	InstancePatternInfos []*ModifyScalingConfigurationShrinkRequestInstancePatternInfos `json:"InstancePatternInfos,omitempty" xml:"InstancePatternInfos,omitempty" type:"Repeated"`
	// Information about the instance type.
	InstanceTypeOverrides []*ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides `json:"InstanceTypeOverrides,omitempty" xml:"InstanceTypeOverrides,omitempty" type:"Repeated"`
	// The instance types. If you specify this parameter, the InstanceType parameter is ignored. You can specify up to 10 instance types in a scaling configuration.
	//
	// The first instance type has the highest priority. The priority decreases based on the specified order of instance types. Auto Scaling creates instances based on the priorities of the instance types. If Auto Scaling cannot create instances of the instance type that has the highest priority, Auto Scaling creates instances of the instance type that has the next highest priority.
	InstanceTypes []*string `json:"InstanceTypes,omitempty" xml:"InstanceTypes,omitempty" type:"Repeated"`
	// The billing method for network usage. Valid values:
	//
	// *   PayByBandwidth: You are charged for the maximum available bandwidth that is specified by the InternetMaxBandwidthOut parameter.
	// *   PayByTraffic: You are charged for the actual traffic that is used. The InternetMaxBandwidthOut parameter specifies only the maximum available bandwidth.
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The maximum outbound public bandwidth. Unit: Mbit/s. Valid values:
	//
	// *   0 to 100 if you set the InternetChargeType parameter to PayByBandwidth. If you leave this parameter empty, this parameter is automatically set to 0.
	// *   0 to 100 if you set the InternetChargeType parameter to PayByTraffic. If you leave this parameter empty, an error will be reported.
	InternetMaxBandwidthOut *int32 `json:"InternetMaxBandwidthOut,omitempty" xml:"InternetMaxBandwidthOut,omitempty"`
	// Specifies whether to create an I/O optimized instance. Valid values:
	//
	// *   none: does not create an I/O optimized instance.
	// *   optimized: creates an I/O optimized instance.
	IoOptimized *string `json:"IoOptimized,omitempty" xml:"IoOptimized,omitempty"`
	// The number of randomly generated IPv6 addresses that you want to allocate to the elastic network interface (ENI).
	Ipv6AddressCount *int32 `json:"Ipv6AddressCount,omitempty" xml:"Ipv6AddressCount,omitempty"`
	// The name of the key pair that is used to log on to the ECS instance.
	//
	// *   Windows instances do not use this parameter.
	// *   By default, the username and password authentication method is disabled for Linux instances.
	KeyPairName *string `json:"KeyPairName,omitempty" xml:"KeyPairName,omitempty"`
	// The weight of the ECS instance as a backend server. Valid values: 1 to 100.
	LoadBalancerWeight *int32 `json:"LoadBalancerWeight,omitempty" xml:"LoadBalancerWeight,omitempty"`
	// The size of the memory. Unit: GiB.
	//
	// You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.
	//
	// > You can specify the Cpu and Memory parameters to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
	Memory *int32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// Specifies whether to overwrite existing data. Valid values:
	//
	// *   true: overwrites existing data.
	// *   false: does not overwrite existing data.
	Override     *bool   `json:"Override,omitempty" xml:"Override,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Specifies whether to use the password that is preconfigured in the image. Before you use this parameter, make sure that a password is configured for the image.
	PasswordInherit *bool `json:"PasswordInherit,omitempty" xml:"PasswordInherit,omitempty"`
	// The name of the RAM role that is associated with the ECS instance. The name is provided and maintained by Resource Access Management (RAM). You can call the ListRoles operation to query the available RAM roles. You can call the CreateRole operation to create RAM roles.
	RamRoleName *string `json:"RamRoleName,omitempty" xml:"RamRoleName,omitempty"`
	// The ID of the resource group to which the ECS instance belongs.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling configuration that you want to modify.
	ScalingConfigurationId *string `json:"ScalingConfigurationId,omitempty" xml:"ScalingConfigurationId,omitempty"`
	// The name of the scaling configuration. The name must be 2 to 64 characters in length and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). It must start with a letter or a digit.
	//
	// The name of the scaling configuration must be unique within a scaling group in a region. If you do not specify the ScalingConfigurationName parameter, the scaling configuration ID is used.
	ScalingConfigurationName *string `json:"ScalingConfigurationName,omitempty" xml:"ScalingConfigurationName,omitempty"`
	// The options of the scheduler.
	SchedulerOptionsShrink *string `json:"SchedulerOptions,omitempty" xml:"SchedulerOptions,omitempty"`
	// The ID of the security group with which the ECS instance is associated. The ECS instances that are associated with the same security group can access each other.
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// The IDs of the security groups.
	SecurityGroupIds []*string `json:"SecurityGroupIds,omitempty" xml:"SecurityGroupIds,omitempty" type:"Repeated"`
	// The retention period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.
	//
	// *   The following retention periods are available in invitational preview: 2, 3, 4, 5, and 6 hours. If you want to set this parameter to one of these values, submit a ticket.
	// *   If you set this parameter to 0, no retention period is specified for the preemptible instance.
	SpotDuration *int32 `json:"SpotDuration,omitempty" xml:"SpotDuration,omitempty"`
	// The interruption event of the preemptible instance. Default value: Terminate. Set the value to Terminate, which specifies that the preemptible instance is to be released.
	SpotInterruptionBehavior *string `json:"SpotInterruptionBehavior,omitempty" xml:"SpotInterruptionBehavior,omitempty"`
	// Information about the instance types of preemptible instances.
	SpotPriceLimits []*ModifyScalingConfigurationShrinkRequestSpotPriceLimits `json:"SpotPriceLimits,omitempty" xml:"SpotPriceLimits,omitempty" type:"Repeated"`
	// The preemption policy that you want to apply to pay-as-you-go instances and preemptible instances. Valid values:
	//
	// *   NoSpot: The instance is created as a pay-as-you-go instance.
	// *   SpotWithPriceLimit: The instance is a preemptible instance that has a user-defined maximum hourly price.
	// *   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.
	SpotStrategy *string `json:"SpotStrategy,omitempty" xml:"SpotStrategy,omitempty"`
	// The categories of the system disks. You can specify one to four disk categories in a scaling configuration. The first disk category that is specified in a scaling configuration has the highest priority. The priority deceases based on the specified order of disk categories. If Auto Scaling cannot create instances by using the disk category that has the highest priority, Auto Scaling creates instances by using the disk category that has the next highest priority. Valid values:
	//
	// *   cloud: basic disk.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   cloud_essd: ESSD.
	//
	// > You cannot specify the SystemDiskCategories and `SystemDisk.Category` parameters at the same time.
	SystemDiskCategories []*string `json:"SystemDiskCategories,omitempty" xml:"SystemDiskCategories,omitempty" type:"Repeated"`
	// The tags of the ECS instance. The tags must be specified in the key-value pair format. You can specify up to 20 tags. When you specify tag keys and tag values, take note of the following items:
	//
	// *   A tag key can be up to 64 characters in length. The key cannot start with `acs:` or `aliyun`, and cannot contain `http://` or `https://`. You cannot specify an empty string as a tag key.
	// *   A tag value can be up to 128 characters in length. The value cannot start with `acs:` or `aliyun`, and cannot contain `http://` or `https://`. You can specify an empty string as a tag value.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// Specifies whether to create the instance on a dedicated host. Valid values:
	//
	// *   default: does not create the instance on a dedicated host.
	// *   host: creates the instance on a dedicated host. If you do not specify the DedicatedHostId parameter, Alibaba Cloud selects a dedicated host for the instance that you want to create.
	Tenancy *string `json:"Tenancy,omitempty" xml:"Tenancy,omitempty"`
	// The user data of the ECS instance. The data must be encoded in Base64. The maximum size of the data before encoding is 16 KB.
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The zone ID of the ECS instance.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s ModifyScalingConfigurationShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationShrinkRequest) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationShrinkRequest) SetPrivatePoolOptions(v *ModifyScalingConfigurationShrinkRequestPrivatePoolOptions) *ModifyScalingConfigurationShrinkRequest {
	s.PrivatePoolOptions = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetSystemDisk(v *ModifyScalingConfigurationShrinkRequestSystemDisk) *ModifyScalingConfigurationShrinkRequest {
	s.SystemDisk = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetAffinity(v string) *ModifyScalingConfigurationShrinkRequest {
	s.Affinity = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetCpu(v int32) *ModifyScalingConfigurationShrinkRequest {
	s.Cpu = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetCreditSpecification(v string) *ModifyScalingConfigurationShrinkRequest {
	s.CreditSpecification = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetDataDisks(v []*ModifyScalingConfigurationShrinkRequestDataDisks) *ModifyScalingConfigurationShrinkRequest {
	s.DataDisks = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetDedicatedHostId(v string) *ModifyScalingConfigurationShrinkRequest {
	s.DedicatedHostId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetDeploymentSetId(v string) *ModifyScalingConfigurationShrinkRequest {
	s.DeploymentSetId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetHostName(v string) *ModifyScalingConfigurationShrinkRequest {
	s.HostName = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetHpcClusterId(v string) *ModifyScalingConfigurationShrinkRequest {
	s.HpcClusterId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetImageFamily(v string) *ModifyScalingConfigurationShrinkRequest {
	s.ImageFamily = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetImageId(v string) *ModifyScalingConfigurationShrinkRequest {
	s.ImageId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetImageName(v string) *ModifyScalingConfigurationShrinkRequest {
	s.ImageName = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetInstanceDescription(v string) *ModifyScalingConfigurationShrinkRequest {
	s.InstanceDescription = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetInstanceName(v string) *ModifyScalingConfigurationShrinkRequest {
	s.InstanceName = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetInstancePatternInfos(v []*ModifyScalingConfigurationShrinkRequestInstancePatternInfos) *ModifyScalingConfigurationShrinkRequest {
	s.InstancePatternInfos = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetInstanceTypeOverrides(v []*ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides) *ModifyScalingConfigurationShrinkRequest {
	s.InstanceTypeOverrides = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetInstanceTypes(v []*string) *ModifyScalingConfigurationShrinkRequest {
	s.InstanceTypes = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetInternetChargeType(v string) *ModifyScalingConfigurationShrinkRequest {
	s.InternetChargeType = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetInternetMaxBandwidthOut(v int32) *ModifyScalingConfigurationShrinkRequest {
	s.InternetMaxBandwidthOut = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetIoOptimized(v string) *ModifyScalingConfigurationShrinkRequest {
	s.IoOptimized = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetIpv6AddressCount(v int32) *ModifyScalingConfigurationShrinkRequest {
	s.Ipv6AddressCount = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetKeyPairName(v string) *ModifyScalingConfigurationShrinkRequest {
	s.KeyPairName = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetLoadBalancerWeight(v int32) *ModifyScalingConfigurationShrinkRequest {
	s.LoadBalancerWeight = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetMemory(v int32) *ModifyScalingConfigurationShrinkRequest {
	s.Memory = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetOverride(v bool) *ModifyScalingConfigurationShrinkRequest {
	s.Override = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetOwnerAccount(v string) *ModifyScalingConfigurationShrinkRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetOwnerId(v int64) *ModifyScalingConfigurationShrinkRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetPasswordInherit(v bool) *ModifyScalingConfigurationShrinkRequest {
	s.PasswordInherit = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetRamRoleName(v string) *ModifyScalingConfigurationShrinkRequest {
	s.RamRoleName = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetResourceGroupId(v string) *ModifyScalingConfigurationShrinkRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetResourceOwnerAccount(v string) *ModifyScalingConfigurationShrinkRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetScalingConfigurationId(v string) *ModifyScalingConfigurationShrinkRequest {
	s.ScalingConfigurationId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetScalingConfigurationName(v string) *ModifyScalingConfigurationShrinkRequest {
	s.ScalingConfigurationName = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetSchedulerOptionsShrink(v string) *ModifyScalingConfigurationShrinkRequest {
	s.SchedulerOptionsShrink = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetSecurityGroupId(v string) *ModifyScalingConfigurationShrinkRequest {
	s.SecurityGroupId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetSecurityGroupIds(v []*string) *ModifyScalingConfigurationShrinkRequest {
	s.SecurityGroupIds = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetSpotDuration(v int32) *ModifyScalingConfigurationShrinkRequest {
	s.SpotDuration = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetSpotInterruptionBehavior(v string) *ModifyScalingConfigurationShrinkRequest {
	s.SpotInterruptionBehavior = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetSpotPriceLimits(v []*ModifyScalingConfigurationShrinkRequestSpotPriceLimits) *ModifyScalingConfigurationShrinkRequest {
	s.SpotPriceLimits = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetSpotStrategy(v string) *ModifyScalingConfigurationShrinkRequest {
	s.SpotStrategy = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetSystemDiskCategories(v []*string) *ModifyScalingConfigurationShrinkRequest {
	s.SystemDiskCategories = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetTags(v string) *ModifyScalingConfigurationShrinkRequest {
	s.Tags = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetTenancy(v string) *ModifyScalingConfigurationShrinkRequest {
	s.Tenancy = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetUserData(v string) *ModifyScalingConfigurationShrinkRequest {
	s.UserData = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequest) SetZoneId(v string) *ModifyScalingConfigurationShrinkRequest {
	s.ZoneId = &v
	return s
}

type ModifyScalingConfigurationShrinkRequestPrivatePoolOptions struct {
	// The ID of the private pool. The ID of a private pool is the same as the ID of the elasticity assurance or capacity reservation for which the private pool is generated.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The type of the private pool that you want to use to create instances. A private pool is generated when an elasticity assurance or a capacity reservation takes effect. You can select a private pool when you create instances. Valid values:
	//
	// *   Open: open private pool. The system selects an open private pool for instance startup. If no open private pool meets your business requirements, the resources in the public pool are used for instance startup. In this case, you do not need to specify the PrivatePoolOptions.Id parameter.
	// *   Target: specified private pool. The resources in the specified private pool are used for instance startup. If the specified private pool is unavailable, the instance startup fails. If you set this parameter to Target, you must specify the PrivatePoolOptions.Id parameter.
	// *   None: no private pool. The resources of private pools are not used for instance startup.
	MatchCriteria *string `json:"MatchCriteria,omitempty" xml:"MatchCriteria,omitempty"`
}

func (s ModifyScalingConfigurationShrinkRequestPrivatePoolOptions) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationShrinkRequestPrivatePoolOptions) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationShrinkRequestPrivatePoolOptions) SetId(v string) *ModifyScalingConfigurationShrinkRequestPrivatePoolOptions {
	s.Id = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestPrivatePoolOptions) SetMatchCriteria(v string) *ModifyScalingConfigurationShrinkRequestPrivatePoolOptions {
	s.MatchCriteria = &v
	return s
}

type ModifyScalingConfigurationShrinkRequestSystemDisk struct {
	// The ID of the automatic snapshot policy that you want to apply to the system disk.
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// Specifies whether to enable the burst feature for the system disk. Valid values:
	//
	// *   true
	// *   false
	//
	// > This parameter is available only if you set the `SystemDisk.Category` parameter to `cloud_auto`.
	//
	// For more information, see [ESSD AutoPL disks](~~368372~~).
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The category of the system disk. Valid values:
	//
	// *   cloud: basic disk.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   cloud_essd: ESSD.
	// *   ephemeral_ssd: local SSD.
	//
	// You cannot specify the SystemDisk.Category and `SystemDiskCategories` parameters at the same time. If you do not specify the Category and `SystemDiskCategories` parameters, the default value of the Category parameter is used. For non-I/O optimized instances of Generation I instance types, the default value is cloud. For instances of other instance types, the default value is cloud_efficiency.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The description of the system disk. The description must be 2 to 256 characters in length. The description can contain letters but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the system disk. The name must be 2 to 128 characters in length. The name must start with a letter but cannot start with `http://` or `https://`. The name can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
	DiskName *string `json:"DiskName,omitempty" xml:"DiskName,omitempty"`
	// The algorithm that is used to encrypt the system disk. Valid values:
	//
	// *   AES-256
	// *   SM4-128
	//
	// Default value: AES-256.
	EncryptAlgorithm *string `json:"EncryptAlgorithm,omitempty" xml:"EncryptAlgorithm,omitempty"`
	// Specifies whether to encrypt the system disk. Valid values:
	//
	// *   true: encrypts the system disk.
	// *   false: does not encrypt the system disk.
	//
	// Default value: false.
	Encrypted *bool `json:"Encrypted,omitempty" xml:"Encrypted,omitempty"`
	// The ID of the KMS key that is used to encrypt the system disk.
	KMSKeyId *string `json:"KMSKeyId,omitempty" xml:"KMSKeyId,omitempty"`
	// The PL of the system disk of the ESSD category. Valid values:
	//
	// *   PL0: An ESSD can deliver up to 10,000 random read/write IOPS.
	// *   PL1: An ESSD can deliver up to 50,000 random read/write IOPS.
	// *   PL2: An ESSD can deliver up to 100,000 random read/write IOPS.
	// *   PL3: An ESSD can deliver up to 1,000,000 random read/write IOPS.
	//
	// > For more information about how to choose ESSD PLs, see [ESSD](~~122389~~).
	PerformanceLevel *string `json:"PerformanceLevel,omitempty" xml:"PerformanceLevel,omitempty"`
	// The IOPS metric that is preconfigured for the system disk.
	//
	// > IOPS measures the number of read and write operations that an EBS device can process per second.
	ProvisionedIops *int64 `json:"ProvisionedIops,omitempty" xml:"ProvisionedIops,omitempty"`
	// The size of the system disk. Unit: GiB.
	//
	// *   Valid values if you set the SystemDisk.Category parameter to cloud: 20 to 500.
	// *   Valid values if you set the SystemDisk.Category parameter to cloud_efficiency: 20 to 500
	// *   Valid values if you set the SystemDisk.Category parameter to cloud_ssd: 20 to 500
	// *   Valid values if you set the SystemDisk.Category parameter to cloud_essd: 20 to 500
	// *   Valid values if you set the SystemDisk.Category parameter to ephemeral_ssd: 20 to 500
	//
	// The value of SystemDisk.Size must be greater than or equal to max{20, ImageSize}.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
}

func (s ModifyScalingConfigurationShrinkRequestSystemDisk) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationShrinkRequestSystemDisk) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationShrinkRequestSystemDisk) SetAutoSnapshotPolicyId(v string) *ModifyScalingConfigurationShrinkRequestSystemDisk {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestSystemDisk) SetBurstingEnabled(v bool) *ModifyScalingConfigurationShrinkRequestSystemDisk {
	s.BurstingEnabled = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestSystemDisk) SetCategory(v string) *ModifyScalingConfigurationShrinkRequestSystemDisk {
	s.Category = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestSystemDisk) SetDescription(v string) *ModifyScalingConfigurationShrinkRequestSystemDisk {
	s.Description = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestSystemDisk) SetDiskName(v string) *ModifyScalingConfigurationShrinkRequestSystemDisk {
	s.DiskName = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestSystemDisk) SetEncryptAlgorithm(v string) *ModifyScalingConfigurationShrinkRequestSystemDisk {
	s.EncryptAlgorithm = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestSystemDisk) SetEncrypted(v bool) *ModifyScalingConfigurationShrinkRequestSystemDisk {
	s.Encrypted = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestSystemDisk) SetKMSKeyId(v string) *ModifyScalingConfigurationShrinkRequestSystemDisk {
	s.KMSKeyId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestSystemDisk) SetPerformanceLevel(v string) *ModifyScalingConfigurationShrinkRequestSystemDisk {
	s.PerformanceLevel = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestSystemDisk) SetProvisionedIops(v int64) *ModifyScalingConfigurationShrinkRequestSystemDisk {
	s.ProvisionedIops = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestSystemDisk) SetSize(v int32) *ModifyScalingConfigurationShrinkRequestSystemDisk {
	s.Size = &v
	return s
}

type ModifyScalingConfigurationShrinkRequestDataDisks struct {
	// The ID of the automatic snapshot policy that you want to apply to the data disk.
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// Specifies whether to enable the burst feature for the system disk. Valid values:
	//
	// *   true
	// *   false
	//
	// > This parameter is available only if you set the `SystemDisk.Category` parameter to `cloud_auto`.
	//
	// For more information, see [ESSD AutoPL disks](~~368372~~).
	BurstingEnabled *bool `json:"BurstingEnabled,omitempty" xml:"BurstingEnabled,omitempty"`
	// The categories of the data disks. You can specify 1 to 16 data disks. You can specify 1 to 4 disk categories in a scaling configuration. The first disk category that is specified in a scaling configuration has the highest priority. The priority deceases based on the specified order of disk categories. If Auto Scaling cannot create instances by using the data disk that has the highest priority, Auto Scaling creates instances by using the data disk that has the next highest priority. Valid values:
	//
	// *   cloud: basic disk. The DeleteWithInstance attribute of a basic disk that is created together with the instance is set to true.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   cloud_essd: ESSD.
	//
	// > You cannot specify the Categories and `Category` parameters at the same time.
	Categories []*string `json:"Categories,omitempty" xml:"Categories,omitempty" type:"Repeated"`
	// The category of the data disk. You can specify 1 to 16 data disks. Valid values:
	//
	// *   cloud: basic disk. The DeleteWithInstance attribute of a basic disk that is created together with the instance is set to true.
	// *   cloud_efficiency: ultra disk.
	// *   cloud_ssd: standard SSD.
	// *   ephemeral_ssd: local standard SSD.
	// *   cloud_essd: ESSD.
	//
	// You cannot specify the Category and `Categories` parameters at the same time. If you do not specify the Category and `Categories` parameters, the default value of the Category parameter is:
	//
	// *   cloud_efficiency for I/O optimized instances.
	// *   cloud for non-I/O optimized instances.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// Specifies whether to release the data disk when the instance to which the data disk is attached is released. Valid values:
	//
	// *   true
	// *   false
	//
	// This parameter is available only for independent disks whose Category parameter is set to cloud, cloud_efficiency, cloud_ssd, cloud_essd, or cloud_auto. If you specify this parameter for disks of other categories, an error will be reported.
	DeleteWithInstance *bool `json:"DeleteWithInstance,omitempty" xml:"DeleteWithInstance,omitempty"`
	// The description of the system disk. The description must be 2 to 256 characters in length. The description can contain letters but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The mount target of the data disk. If you do not specify the Device parameter, a mount target is automatically created when Auto Scaling creates ECS instance. The name of the mount target ranges from /dev/xvdb to /dev/xvdz.
	Device *string `json:"Device,omitempty" xml:"Device,omitempty"`
	// The name of the system disk. The name must be 2 to 128 characters in length and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
	DiskName *string `json:"DiskName,omitempty" xml:"DiskName,omitempty"`
	// Specifies whether to encrypt the system disk. Valid values:
	//
	// *   true: encrypts the system disk.
	// *   false: does not encrypt the system disk.
	Encrypted *string `json:"Encrypted,omitempty" xml:"Encrypted,omitempty"`
	// The ID of the KMS key of the data disk.
	KMSKeyId *string `json:"KMSKeyId,omitempty" xml:"KMSKeyId,omitempty"`
	// The PL of the data disk of the ESSD category. If you set the Category parameter to cloud_essd, you must also specify the PerformanceLevel parameter. Valid values:
	//
	// *   PL0: An ESSD can deliver up to 10,000 random read/write IOPS.
	// *   PL1: An ESSD can deliver up to 50,000 random read/write IOPS.
	// *   PL2: An ESSD can deliver up to 100,000 random read/write IOPS.
	// *   PL3: An ESSD can deliver up to 1,000,000 random read/write IOPS.
	//
	// > For more information about how to choose ESSD PLs, see [ESSD](~~122389~~).
	PerformanceLevel *string `json:"PerformanceLevel,omitempty" xml:"PerformanceLevel,omitempty"`
	// The input/output operations per second (IOPS) metric that is preconfigured for the data disk.
	//
	// > IOPS measures the number of read and write operations that an EBS device can process per second.
	ProvisionedIops *int64 `json:"ProvisionedIops,omitempty" xml:"ProvisionedIops,omitempty"`
	// The size of the data disk. Unit: GiB.
	//
	// *   Valid values if you set the Category parameter to cloud: 5 to 2000.
	// *   Valid values if you set the Category parameter to cloud_efficiency: 20 to 32768.
	// *   Valid values if you set the Category parameter to cloud_ssd: 20 to 32768.
	// *   Valid values if you set the Category parameter to cloud_essd: 20 to 32768.
	// *   Valid values if you set the Category parameter to ephemeral_ssd: 5 to 800.
	//
	// The value of the Size parameter must be greater than or equal to the size of the snapshot that is specified by the SnapshotId parameter.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The ID of the snapshot that you want to use to create data disks. If you specify this parameter, the Size parameter is ignored. The size of the disk is the same as the size of the specified snapshot.
	//
	// If you specify a snapshot created on or before July 15, 2013, the operation fails and the system returns InvalidSnapshot.TooOld.
	SnapshotId *string `json:"SnapshotId,omitempty" xml:"SnapshotId,omitempty"`
}

func (s ModifyScalingConfigurationShrinkRequestDataDisks) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationShrinkRequestDataDisks) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetAutoSnapshotPolicyId(v string) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetBurstingEnabled(v bool) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.BurstingEnabled = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetCategories(v []*string) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.Categories = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetCategory(v string) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.Category = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetDeleteWithInstance(v bool) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.DeleteWithInstance = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetDescription(v string) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.Description = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetDevice(v string) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.Device = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetDiskName(v string) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.DiskName = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetEncrypted(v string) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.Encrypted = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetKMSKeyId(v string) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.KMSKeyId = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetPerformanceLevel(v string) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.PerformanceLevel = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetProvisionedIops(v int64) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.ProvisionedIops = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetSize(v int32) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.Size = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestDataDisks) SetSnapshotId(v string) *ModifyScalingConfigurationShrinkRequestDataDisks {
	s.SnapshotId = &v
	return s
}

type ModifyScalingConfigurationShrinkRequestInstancePatternInfos struct {
	// The architectures of the instance types. Valid values:
	//
	// *   X86: x86 architecture.
	// *   Heterogeneous: heterogeneous architecture, such as GPUs and FPGAs.
	// *   BareMetal: ECS Bare Metal Instance architecture.
	// *   Arm: ARM architecture.
	// *   SuperComputeCluster: Super Computing Cluster architecture.
	//
	// By default, all values are selected.
	Architectures []*string `json:"Architectures,omitempty" xml:"Architectures,omitempty" type:"Repeated"`
	// Specifies whether to include burstable instance types. Valid values:
	//
	// *   Exclude: excludes burstable instance types.
	// *   Include: includes burstable instance types.
	// *   Required: includes only burstable instance types.
	//
	// Default value: Include.
	BurstablePerformance *string `json:"BurstablePerformance,omitempty" xml:"BurstablePerformance,omitempty"`
	// The number of vCPUs that is specified for an instance type in the intelligent configuration mode. This parameter is used to filter the available instance types that meet the specified criteria. For more information, see [Instance family](~~25378~~).
	//
	// Take note of the following items:
	//
	// *   The InstancePatternInfos parameter is available only for scaling groups that reside in VPCs.
	// *   You must specify the InstancePatternInfos, Cores, and Memory parameters at the same time.
	// *   If you specify an instance type by using the InstanceType or InstanceTypes parameter, Auto Scaling preferentially uses the instance type that is specified by the InstanceType or InstanceTypes parameter for scale-out activities. If the specified instance type does not have sufficient inventory, Auto Scaling creates instances of the instance type that is specified by the InstancePatternInfos parameter based on the price in ascending order.
	Cores *int32 `json:"Cores,omitempty" xml:"Cores,omitempty"`
	// The instance types that you want to filter out. You can use wildcard characters such as an asterisk (\*) to filter out a single instance type or an instance family. Example:
	//
	// *   ecs.c6.large: The ecs.c6.large instance type is filtered out.
	// *   ecs.c6.\*: The c6 instance family is filtered out.
	ExcludedInstanceTypes []*string `json:"ExcludedInstanceTypes,omitempty" xml:"ExcludedInstanceTypes,omitempty" type:"Repeated"`
	// The level of the instance type, which is used to filter the instance types that meet the specified criteria. This parameter takes effect only if you set the `CostOptimization` parameter to true. Valid values:
	//
	// *   EntryLevel: shared instance type. Instances of this level are the most cost-effective but may not provide stable computing performance in a consistent manner. Instances of this level are suitable for business scenarios in which the CPU utilization is low. For more information, see [Shared instance families](~~108489~~).
	// *   EnterpriseLevel: Instances of this level provide stable performance and dedicated resources, and are suitable for business scenarios that require high stability. For more information, see [Instance family](~~25378~~).
	// *   CreditEntryLevel: This value is valid only for burstable instances. CPU credits are used to ensure computing performance. Instances of this level are suitable for scenarios in which the CPU utilization is low but may fluctuate in specific cases. For more information, see the [Overview](~~59977~~) topic of burstable instances.
	InstanceFamilyLevel *string `json:"InstanceFamilyLevel,omitempty" xml:"InstanceFamilyLevel,omitempty"`
	// The maximum hourly price for a pay-as-you-go instance or a preemptible instance in the intelligent configuration mode. This parameter is used to filter the available instance types that meet the specified criteria.
	//
	// > If you set the SpotStrategy parameter to SpotWithPriceLimit, you must specify the MaxPrice parameter. In other cases, you do not need to specify the MaxPrice parameter.
	MaxPrice *float32 `json:"MaxPrice,omitempty" xml:"MaxPrice,omitempty"`
	// The memory size that is specified for an instance type in the intelligent configuration mode. Unit: GiB. This parameter is used to filter the available instance types that meet the specified criteria.
	Memory *float32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
}

func (s ModifyScalingConfigurationShrinkRequestInstancePatternInfos) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationShrinkRequestInstancePatternInfos) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationShrinkRequestInstancePatternInfos) SetArchitectures(v []*string) *ModifyScalingConfigurationShrinkRequestInstancePatternInfos {
	s.Architectures = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestInstancePatternInfos) SetBurstablePerformance(v string) *ModifyScalingConfigurationShrinkRequestInstancePatternInfos {
	s.BurstablePerformance = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestInstancePatternInfos) SetCores(v int32) *ModifyScalingConfigurationShrinkRequestInstancePatternInfos {
	s.Cores = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestInstancePatternInfos) SetExcludedInstanceTypes(v []*string) *ModifyScalingConfigurationShrinkRequestInstancePatternInfos {
	s.ExcludedInstanceTypes = v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestInstancePatternInfos) SetInstanceFamilyLevel(v string) *ModifyScalingConfigurationShrinkRequestInstancePatternInfos {
	s.InstanceFamilyLevel = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestInstancePatternInfos) SetMaxPrice(v float32) *ModifyScalingConfigurationShrinkRequestInstancePatternInfos {
	s.MaxPrice = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestInstancePatternInfos) SetMemory(v float32) *ModifyScalingConfigurationShrinkRequestInstancePatternInfos {
	s.Memory = &v
	return s
}

type ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides struct {
	// The instance type. If you want to specify the weight of the instance type in the scaling configuration, you must specify the InstanceType and WeightedCapacity parameters at the same time.
	//
	// You can use the InstanceType parameter to specify 1 to 10 instance types. You can use the WeightedCapacity parameter to specify weights of instance types.
	//
	// > You cannot specify the InstanceType and InstanceTypes parameters at the same time.
	//
	// You can specify instance types that are available for purchase as the values of the InstanceType parameter.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The weight of the instance type. The weight of the instance type indicates the capacity of the instance of the specified instance type in the scaling group. If you want Auto Scaling to scale instances based on the instance type weight, you must specify the WeightedCapacity parameter after you specify the InstanceType parameter.
	//
	// A higher weight specifies that a smaller number of instances of the specified instance type are required to meet the expected capacity.
	//
	// Performance metrics, such as the number of vCPUs and the memory size of each instance type, may vary. You can specify different weights for different instance types based on your business requirements.
	//
	// Example:
	//
	// *   Current capacity: 0
	// *   Expected capacity: 6
	// *   Capacity of ecs.c5.xlarge: 4
	//
	// To meet the expected capacity requirement, Auto Scaling must create and add two ecs.c5.xlarge instances.
	//
	// > The capacity of the scaling group cannot exceed the sum of the maximum number of instances that is specified by the MaxSize parameter and the maximum weight of the instance types.
	//
	// Valid values of the WeightedCapacity parameter: 1 to 500.
	WeightedCapacity *int32 `json:"WeightedCapacity,omitempty" xml:"WeightedCapacity,omitempty"`
}

func (s ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides) SetInstanceType(v string) *ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides {
	s.InstanceType = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides) SetWeightedCapacity(v int32) *ModifyScalingConfigurationShrinkRequestInstanceTypeOverrides {
	s.WeightedCapacity = &v
	return s
}

type ModifyScalingConfigurationShrinkRequestSpotPriceLimits struct {
	// The instance type of the preemptible instance. This parameter takes effect only if you set the SpotStrategy parameter to SpotWithPriceLimit.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The price limit of the preemptible instance. This parameter takes effect only if you set the SpotStrategy parameter to SpotWithPriceLimit.
	PriceLimit *float32 `json:"PriceLimit,omitempty" xml:"PriceLimit,omitempty"`
}

func (s ModifyScalingConfigurationShrinkRequestSpotPriceLimits) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationShrinkRequestSpotPriceLimits) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationShrinkRequestSpotPriceLimits) SetInstanceType(v string) *ModifyScalingConfigurationShrinkRequestSpotPriceLimits {
	s.InstanceType = &v
	return s
}

func (s *ModifyScalingConfigurationShrinkRequestSpotPriceLimits) SetPriceLimit(v float32) *ModifyScalingConfigurationShrinkRequestSpotPriceLimits {
	s.PriceLimit = &v
	return s
}

type ModifyScalingConfigurationResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyScalingConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationResponseBody) SetRequestId(v string) *ModifyScalingConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type ModifyScalingConfigurationResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyScalingConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyScalingConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingConfigurationResponse) GoString() string {
	return s.String()
}

func (s *ModifyScalingConfigurationResponse) SetHeaders(v map[string]*string) *ModifyScalingConfigurationResponse {
	s.Headers = v
	return s
}

func (s *ModifyScalingConfigurationResponse) SetStatusCode(v int32) *ModifyScalingConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyScalingConfigurationResponse) SetBody(v *ModifyScalingConfigurationResponseBody) *ModifyScalingConfigurationResponse {
	s.Body = v
	return s
}

type ModifyScalingGroupRequest struct {
	// The health check mode of the scaling group. Valid values:
	//
	// *   NONE: Auto Scaling does not perform health checks on instances in the scaling group.
	// *   ECS: Auto Scaling performs health checks on ECS instances in the scaling group.
	ActiveScalingConfigurationId *string `json:"ActiveScalingConfigurationId,omitempty" xml:"ActiveScalingConfigurationId,omitempty"`
	// The allocation policy of preemptible instances. You can use this parameter to individually specify the allocation policy of preemptible instances. This parameter takes effect only when you set the `MultiAZPolicy` parameter to `COMPOSABLE`. Valid values:
	//
	// *   priority: Auto Scaling selects instance types based on the specified order to create the required number of preemptible instances.
	// *   lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of preemptible instances.
	//
	// Default value: priority.
	AllocationStrategy *string `json:"AllocationStrategy,omitempty" xml:"AllocationStrategy,omitempty"`
	// The allocation policy. Auto Scaling selects instance types based on the allocation policy to create the required number of instances. The policy can be applied to pay-as-you-go instances and preemptible instances at the same time. This parameter takes effect only when you set the MultiAZPolicy parameter to COMPOSABLE. Valid values:
	//
	// *   priority: Auto Scaling selects instance types based on the specified order to create the required number of instances.
	// *   lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of instances.
	//
	// Default value: priority.
	AzBalance *bool `json:"AzBalance,omitempty" xml:"AzBalance,omitempty"`
	// The number of instance types that you specify. Auto Scaling creates preemptible instances of multiple instance types that are provided at the lowest price. Valid values: 0 to 10.
	//
	// If you set the `MultiAZPolicy` parameter to `COMPOSABLE` Policy, the default value is 2.
	CompensateWithOnDemand *bool `json:"CompensateWithOnDemand,omitempty" xml:"CompensateWithOnDemand,omitempty"`
	// The ID of the request.
	CustomPolicyARN *string `json:"CustomPolicyARN,omitempty" xml:"CustomPolicyARN,omitempty"`
	// The policy that is used to remove ECS instances from the scaling group. Valid values:
	//
	// *   OldestInstance: removes ECS instances that are added at the earliest point in time to the scaling group.
	// *   NewestInstance: removes ECS instances that are most recently added to the scaling group.
	// *   OldestScalingConfiguration: removes ECS instances that are created based on the earliest scaling configuration.
	DefaultCooldown *int32 `json:"DefaultCooldown,omitempty" xml:"DefaultCooldown,omitempty"`
	// Specifies whether to enable deletion protection for the scaling group. Valid values:
	//
	// *   true: enables deletion protection for the scaling group. This way, the scaling group cannot be deleted.
	// *   false: disables deletion protection for the scaling group.
	DesiredCapacity *int32 `json:"DesiredCapacity,omitempty" xml:"DesiredCapacity,omitempty"`
	// The scaling policy for the multi-zone scaling group that contains ECS instances. Valid values:
	//
	// *   PRIORITY: ECS instances are scaled based on the vSwitch priority. The first vSwitch specified by using the VSwitchIds parameter has the highest priority. Auto Scaling preferentially scales instances in the zone where the vSwitch that has the highest priority resides. If the scaling fails, Auto Scaling scales instances in the zone where the vSwitch that has the next highest priority resides.
	// *   COST_OPTIMIZED: During a scale-out activity, Auto Scaling preferentially creates ECS instances of the instance type that has the lowest unit price of vCPU. During a scale-in activity, Auto Scaling preferentially removes ECS instances of the instance types that have the highest unit price of vCPU. Auto Scaling preferentially creates preemptible instances when preemptible instance types are specified in the scaling configuration. You can use the `CompensateWithOnDemand` parameter to specify whether to automatically create pay-as-you-go instances when Auto Scaling fails to create preemptible instances.
	//
	// > The `COST_OPTIMIZED` setting takes effect only when multiple instance types are specified or at least one instance type is specified for preemptible instances.
	//
	// *   BALANCE: ECS instances are evenly distributed across zones that are specified in the scaling group. If ECS instances are unevenly distributed among zones due to insufficient resources, you can call the RebalanceInstance operation to evenly distribute the instances among the zones.
	// *   COMPOSABLE: You can flexibly combine the preceding policies based on your business requirements.
	GroupDeletionProtection *bool `json:"GroupDeletionProtection,omitempty" xml:"GroupDeletionProtection,omitempty"`
	// The ID of the launch template that is used by Auto Scaling to create instances.
	HealthCheckType *string `json:"HealthCheckType,omitempty" xml:"HealthCheckType,omitempty"`
	// The version number of the launch template. Valid values:
	//
	// *   A fixed template version number.
	// *   Default: The default template version is always used.
	// *   Latest: The latest template version is always used.
	LaunchTemplateId *string `json:"LaunchTemplateId,omitempty" xml:"LaunchTemplateId,omitempty"`
	// Details of the instance types that are specified in the extended configurations of the launch template.
	LaunchTemplateOverrides []*ModifyScalingGroupRequestLaunchTemplateOverrides `json:"LaunchTemplateOverrides,omitempty" xml:"LaunchTemplateOverrides,omitempty" type:"Repeated"`
	// The minimum number of pay-as-you-go instances that must be included in the scaling group. Valid values: 0 to 1000. If the number of pay-as-you-go instances is less than the value of this parameter, Auto Scaling preferentially creates pay-as-you-go instances.
	//
	// If you set the `MultiAZPolicy` parameter to `COMPOSABLE` Policy, the default value is 0.
	LaunchTemplateVersion *string `json:"LaunchTemplateVersion,omitempty" xml:"LaunchTemplateVersion,omitempty"`
	// Specifies whether to evenly distribute instances in the scaling group across zones. This parameter takes effect only when you set the `MultiAZPolicy` parameter to `COMPOSABLE`. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: false.
	MaxInstanceLifetime *int32 `json:"MaxInstanceLifetime,omitempty" xml:"MaxInstanceLifetime,omitempty"`
	// The default cooldown time of the scaling group. This parameter takes effect only for scaling groups that have simple scaling rules. Valid values: 0 to 86400. Unit: seconds. During the cooldown time, Auto Scaling executes only scaling activities that are triggered by event-triggered tasks associated with CloudMonitor.
	MaxSize *int32 `json:"MaxSize,omitempty" xml:"MaxSize,omitempty"`
	// The maximum number of ECS instances in the scaling group. When the number of ECS instances in the scaling group is greater than the value of the MaxSize parameter, Auto Scaling automatically removes ECS instances from the scaling group until the number of instances is equal to the value of the MaxSize parameter.
	//
	// The value range of the MaxSize parameter varies based on the instance quota. You can go to [Quota Center](https://quotas.console.aliyun.com/products/ess/quotas) to check the quota of **instances that can be included in a scaling group**.
	//
	// For example, if the quota of instances that can be included in a scaling group is 2000, the valid values of the MaxSize parameter range from 0 to 2000.
	MinSize *int32 `json:"MinSize,omitempty" xml:"MinSize,omitempty"`
	// The IDs of vSwitches.
	//
	// This parameter takes effect only when the network type of the scaling group is virtual private cloud (VPC). The specified vSwitches and the scaling group must reside in the same VPC.
	//
	// The vSwitches can reside in different zones. The vSwitches are sorted in ascending order. The first vSwitch specified by using the VSwitchIds parameter has the highest priority. If Auto Scaling fails to create ECS instances in the zone where the vSwitch that has the highest priority resides, Auto Scaling creates ECS instances in the zone where the vSwitch that has the next highest priority resides.
	MultiAZPolicy *string `json:"MultiAZPolicy,omitempty" xml:"MultiAZPolicy,omitempty"`
	// The expected percentage of pay-as-you-go instances in the excess instances when the minimum number of pay-as-you-go instances reaches the requirement. Valid values: 0 to 100.
	//
	// If you set the `MultiAZPolicy` parameter to `COMPOSABLE` Policy, the default value is 100.
	OnDemandBaseCapacity *int32 `json:"OnDemandBaseCapacity,omitempty" xml:"OnDemandBaseCapacity,omitempty"`
	// Specifies whether to supplement preemptible instances. If this parameter is set to true, Auto Scaling creates an instance to replace a preemptible instance when Auto Scaling receives the system message that the preemptible instance is to be reclaimed.
	OnDemandPercentageAboveBaseCapacity *int32  `json:"OnDemandPercentageAboveBaseCapacity,omitempty" xml:"OnDemandPercentageAboveBaseCapacity,omitempty"`
	OwnerAccount                        *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                             *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The policy that is used to remove ECS instances from the scaling group. Valid values:
	//
	// *   OldestInstance: removes ECS instances that are added at the earliest point in time to the scaling group.
	// *   NewestInstance: removes ECS instances that are most recently added to the scaling group.
	// *   OldestScalingConfiguration: removes ECS instances that are created based on the earliest scaling configuration.
	RemovalPolicies      []*string `json:"RemovalPolicies,omitempty" xml:"RemovalPolicies,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The name of the scaling group. The name of each scaling group must be unique in a region. The name must be 2 to 64 characters in length and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). The name must start with a letter or a digit.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The minimum number of ECS instances in the scaling group. When the number of ECS instances in the scaling group is less than the value of the MinSize parameter, Auto Scaling automatically creates ECS instances and adds the instances to the scaling group until the number of instances is equal to the value of the MinSize parameter.
	//
	// > The value of the MinSize parameter must be less than or equal to the value of the MaxSize parameter.
	ScalingGroupName *string `json:"ScalingGroupName,omitempty" xml:"ScalingGroupName,omitempty"`
	// The ARN of the custom scaling policy (Function). This parameter takes effect only when you specify CustomPolicy as the first step of the instance removal policy.
	SpotAllocationStrategy *string `json:"SpotAllocationStrategy,omitempty" xml:"SpotAllocationStrategy,omitempty"`
	// The expected number of ECS instances in the scaling group. Auto Scaling automatically maintains the specified expected number of ECS instances. The expected number cannot be greater than the value of the MaxSize parameter and cannot be less than the value of the MinSize parameter.
	SpotInstancePools *int32 `json:"SpotInstancePools,omitempty" xml:"SpotInstancePools,omitempty"`
	// Specifies whether to automatically create pay-as-you-go instances to meet the requirements on the number of ECS instances in the scaling group when the number of preemptible instances cannot be reached due to reasons such as costs and insufficient resources. This parameter takes effect only if you set the MultiAZPolicy parameter in the CreateScalingGroup operation to COST_OPTIMIZED. Valid values:
	//
	// *   true
	// *   false
	SpotInstanceRemedy *bool `json:"SpotInstanceRemedy,omitempty" xml:"SpotInstanceRemedy,omitempty"`
	// The IDs of vSwitches.
	//
	// This parameter takes effect only when the network type of the scaling group is VPC. The specified vSwitches and the scaling group must reside in the same VPC.
	//
	// The vSwitches can reside in different zones. The vSwitches are sorted in ascending order. The first vSwitch specified by using the VSwitchIds parameter has the highest priority. If Auto Scaling fails to create ECS instances in the zone where the vSwitch that has the highest priority resides, Auto Scaling creates ECS instances in the zone where the vSwitch that has the next highest priority resides.
	VSwitchIds []*string `json:"VSwitchIds,omitempty" xml:"VSwitchIds,omitempty" type:"Repeated"`
}

func (s ModifyScalingGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingGroupRequest) GoString() string {
	return s.String()
}

func (s *ModifyScalingGroupRequest) SetActiveScalingConfigurationId(v string) *ModifyScalingGroupRequest {
	s.ActiveScalingConfigurationId = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetAllocationStrategy(v string) *ModifyScalingGroupRequest {
	s.AllocationStrategy = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetAzBalance(v bool) *ModifyScalingGroupRequest {
	s.AzBalance = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetCompensateWithOnDemand(v bool) *ModifyScalingGroupRequest {
	s.CompensateWithOnDemand = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetCustomPolicyARN(v string) *ModifyScalingGroupRequest {
	s.CustomPolicyARN = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetDefaultCooldown(v int32) *ModifyScalingGroupRequest {
	s.DefaultCooldown = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetDesiredCapacity(v int32) *ModifyScalingGroupRequest {
	s.DesiredCapacity = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetGroupDeletionProtection(v bool) *ModifyScalingGroupRequest {
	s.GroupDeletionProtection = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetHealthCheckType(v string) *ModifyScalingGroupRequest {
	s.HealthCheckType = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetLaunchTemplateId(v string) *ModifyScalingGroupRequest {
	s.LaunchTemplateId = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetLaunchTemplateOverrides(v []*ModifyScalingGroupRequestLaunchTemplateOverrides) *ModifyScalingGroupRequest {
	s.LaunchTemplateOverrides = v
	return s
}

func (s *ModifyScalingGroupRequest) SetLaunchTemplateVersion(v string) *ModifyScalingGroupRequest {
	s.LaunchTemplateVersion = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetMaxInstanceLifetime(v int32) *ModifyScalingGroupRequest {
	s.MaxInstanceLifetime = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetMaxSize(v int32) *ModifyScalingGroupRequest {
	s.MaxSize = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetMinSize(v int32) *ModifyScalingGroupRequest {
	s.MinSize = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetMultiAZPolicy(v string) *ModifyScalingGroupRequest {
	s.MultiAZPolicy = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetOnDemandBaseCapacity(v int32) *ModifyScalingGroupRequest {
	s.OnDemandBaseCapacity = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetOnDemandPercentageAboveBaseCapacity(v int32) *ModifyScalingGroupRequest {
	s.OnDemandPercentageAboveBaseCapacity = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetOwnerAccount(v string) *ModifyScalingGroupRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetOwnerId(v int64) *ModifyScalingGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetRemovalPolicies(v []*string) *ModifyScalingGroupRequest {
	s.RemovalPolicies = v
	return s
}

func (s *ModifyScalingGroupRequest) SetResourceOwnerAccount(v string) *ModifyScalingGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetResourceOwnerId(v int64) *ModifyScalingGroupRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetScalingGroupId(v string) *ModifyScalingGroupRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetScalingGroupName(v string) *ModifyScalingGroupRequest {
	s.ScalingGroupName = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetSpotAllocationStrategy(v string) *ModifyScalingGroupRequest {
	s.SpotAllocationStrategy = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetSpotInstancePools(v int32) *ModifyScalingGroupRequest {
	s.SpotInstancePools = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetSpotInstanceRemedy(v bool) *ModifyScalingGroupRequest {
	s.SpotInstanceRemedy = &v
	return s
}

func (s *ModifyScalingGroupRequest) SetVSwitchIds(v []*string) *ModifyScalingGroupRequest {
	s.VSwitchIds = v
	return s
}

type ModifyScalingGroupRequestLaunchTemplateOverrides struct {
	// The weight of the instance type. The weight specifies the capacity of a single instance of the specified instance type in the scaling group. If you want Auto Scaling to scale instances in the scaling group based on the weighted capacity of instances, you must specify the WeightedCapacity parameter after you specify the InstanceType parameter.
	//
	// A higher weight specifies that a smaller number of instances of the specified instance type are required to meet the expected capacity.
	//
	// Performance metrics, such as the number of vCPUs and the memory size of each instance type, may vary. You can specify different weights for different instance types based on your business requirements.
	//
	// Example:
	//
	// *   Current capacity: 0
	// *   Expected capacity: 6
	// *   Capacity of ecs.c5.xlarge: 4
	//
	// To meet the expected capacity requirement, Auto Scaling must create and add two ecs.c5.xlarge instances.
	//
	// > The capacity of the scaling group cannot exceed the sum of the maximum number of instances that is specified by the MaxSize parameter and the maximum weight of the instance type.
	//
	// Valid values of the WeightedCapacity parameter: 1 to 500.
	InstanceType   *string  `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	SpotPriceLimit *float32 `json:"SpotPriceLimit,omitempty" xml:"SpotPriceLimit,omitempty"`
	// The maximum life span of the instance in the scaling group. Unit: seconds.
	//
	// Valid values: 86400 to Integer.maxValue. ``You can also set this parameter to 0. A value of 0 indicates that the instance has an unlimited life span in the scaling group.
	//
	// Default value: null.
	//
	// > You cannot specify this parameter for scaling groups that manage elastic container instances or scaling groups whose ScalingPolicy is set to recycle.
	WeightedCapacity *int32 `json:"WeightedCapacity,omitempty" xml:"WeightedCapacity,omitempty"`
}

func (s ModifyScalingGroupRequestLaunchTemplateOverrides) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingGroupRequestLaunchTemplateOverrides) GoString() string {
	return s.String()
}

func (s *ModifyScalingGroupRequestLaunchTemplateOverrides) SetInstanceType(v string) *ModifyScalingGroupRequestLaunchTemplateOverrides {
	s.InstanceType = &v
	return s
}

func (s *ModifyScalingGroupRequestLaunchTemplateOverrides) SetSpotPriceLimit(v float32) *ModifyScalingGroupRequestLaunchTemplateOverrides {
	s.SpotPriceLimit = &v
	return s
}

func (s *ModifyScalingGroupRequestLaunchTemplateOverrides) SetWeightedCapacity(v int32) *ModifyScalingGroupRequestLaunchTemplateOverrides {
	s.WeightedCapacity = &v
	return s
}

type ModifyScalingGroupResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyScalingGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyScalingGroupResponseBody) SetRequestId(v string) *ModifyScalingGroupResponseBody {
	s.RequestId = &v
	return s
}

type ModifyScalingGroupResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyScalingGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyScalingGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingGroupResponse) GoString() string {
	return s.String()
}

func (s *ModifyScalingGroupResponse) SetHeaders(v map[string]*string) *ModifyScalingGroupResponse {
	s.Headers = v
	return s
}

func (s *ModifyScalingGroupResponse) SetStatusCode(v int32) *ModifyScalingGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyScalingGroupResponse) SetBody(v *ModifyScalingGroupResponseBody) *ModifyScalingGroupResponse {
	s.Body = v
	return s
}

type ModifyScalingRuleRequest struct {
	// The target value specified in the scaling rule. This parameter is required when the ScalingRuleType parameter is set to SimpleScalingRule or StepScalingRule. The number of ECS instances that are scaled in a single scaling activity cannot exceed 1,000.
	//
	// *   Valid values if you set the AdjustmentType parameter to QuantityChangeInCapacity: -1000 to 1000.
	// *   Valid values if you set the AdjustmentType parameter to PercentChangeInCapacity: -100 to 10000.
	// *   Valid values if you set the AdjustmentType parameter to TotalCapacity: 0 to 2000.
	AdjustmentType *string `json:"AdjustmentType,omitempty" xml:"AdjustmentType,omitempty"`
	// The warmup period of an instance. This parameter is available only if you set the ScalingRuleType parameter to TargetTrackingScalingRule or PredictiveScalingRule. Auto Scaling adds ECS instances that are in the warmup state to a scaling group but does not report monitoring data to CloudMonitor during the warmup period.
	//
	// > Auto Scaling calculates the number of ECS instances that need to be scaled. ECS instances in the warmup state are not counted towards the current capacity of the scaling group.
	//
	// Valid values: 0 to 86400. Unit: seconds.
	AdjustmentValue *int32 `json:"AdjustmentValue,omitempty" xml:"AdjustmentValue,omitempty"`
	// The minimum number of instances that must be scaled when the AdjustmentType parameter is set to PercentChangeInCapacity. This parameter takes effect only if you set the ScalingRuleType parameter to SimpleScalingRule or StepScalingRule.
	Cooldown *int32 `json:"Cooldown,omitempty" xml:"Cooldown,omitempty"`
	// The number of consecutive times that the event-triggered task created for scale-in activities must meet the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.
	DisableScaleIn *bool `json:"DisableScaleIn,omitempty" xml:"DisableScaleIn,omitempty"`
	// The predefined metric that you want to monitor. This parameter is required only if you set the ScalingRuleType parameter to TargetTrackingScalingRule or PredictiveScalingRule.
	//
	// Valid values if you set the ScalingRuleType parameter to TargetTrackingScalingRule:
	//
	// *   CpuUtilization: the average CPU utilization
	// *   ClassicInternetRx: the average inbound Internet traffic over the classic network
	// *   ClassicInternetTx: the average outbound Internet traffic over the classic network
	// *   VpcInternetRx: the average inbound Internet traffic over the virtual private cloud (VPC)
	// *   VpcInternetTx: the average outbound Internet traffic over the VPC
	// *   IntranetRx: the average inbound traffic over the internal network
	// *   IntranetTx: the average outbound traffic over the internal network
	//
	// Valid values if you set the ScalingRuleType parameter to PredictiveScalingRule:
	//
	// *   CpuUtilization: the average CPU utilization
	// *   IntranetRx: the average inbound traffic over the internal network
	// *   IntranetTx: the average outbound traffic over the internal network
	EstimatedInstanceWarmup *int32 `json:"EstimatedInstanceWarmup,omitempty" xml:"EstimatedInstanceWarmup,omitempty"`
	// Details of the step adjustments.
	InitialMaxSize *int32 `json:"InitialMaxSize,omitempty" xml:"InitialMaxSize,omitempty"`
	// The target value. This parameter is available only if you set the ScalingRuleType parameter to TargetTrackingScalingRule or PredictiveScalingRule. The value must be greater than 0 and can have up to three decimal places.
	MetricName *string `json:"MetricName,omitempty" xml:"MetricName,omitempty"`
	// The adjustment method of the scaling rule. This is required when the ScalingRuleType parameter is set to SimpleScalingRule or StepScalingRule. Valid values:
	//
	// *   QuantityChangeInCapacity: adds the specified number of ECS instances to or removes the specified number of ECS instances from the scaling group.
	// *   PercentChangeInCapacity: adds the specified percentage of ECS instances to or removes the specified percentage of ECS instances from the scaling group.
	// *   TotalCapacity: adjusts the number of ECS instances in the scaling group to the specified number.
	MinAdjustmentMagnitude *int32  `json:"MinAdjustmentMagnitude,omitempty" xml:"MinAdjustmentMagnitude,omitempty"`
	OwnerAccount           *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Specifies which one of the initial maximum capacity and the predicted value can be used as the maximum value for prediction tasks. Valid values:
	//
	// *   MaxOverridePredictiveValue: uses the initial maximum capacity as the maximum value for prediction tasks if the predicted value is greater than the initial maximum capacity.
	// *   PredictiveValueOverrideMax: uses the predicted value as the maximum value for prediction tasks when the predicted value is greater than the initial maximum capacity.
	// *   PredictiveValueOverrideMaxWithBuffer: increases the predicted value by a percentage that is specified by the PredictiveValueBuffer parameter. If the predicted value that is increased by the percentage is greater than the initial maximum capacity, the increased value is used as the maximum value for prediction tasks.
	PredictiveScalingMode *string `json:"PredictiveScalingMode,omitempty" xml:"PredictiveScalingMode,omitempty"`
	// The maximum number of ECS instances in the scaling group. If you specify this parameter, you must also specify the PredictiveValueBehavior parameter.
	PredictiveTaskBufferTime *int32 `json:"PredictiveTaskBufferTime,omitempty" xml:"PredictiveTaskBufferTime,omitempty"`
	// The percentage of the increment to the predicted value when the PredictiveValueBehavior parameter is set to PredictiveValueOverrideMaxWithBuffer. If the predicted value increased by this percentage is greater than the initial maximum capacity, the increased value is used as the maximum value for prediction tasks. Valid values: 0 to 100.
	PredictiveValueBehavior *string `json:"PredictiveValueBehavior,omitempty" xml:"PredictiveValueBehavior,omitempty"`
	// The amount of buffer time before the prediction task is executed. By default, all prediction tasks that are automatically created for a predictive scaling rule are executed on the hour. You can specify an amount of buffer time for resource preparation before the prediction tasks are executed. Valid values: 0 to 60.
	PredictiveValueBuffer *int32  `json:"PredictiveValueBuffer,omitempty" xml:"PredictiveValueBuffer,omitempty"`
	ResourceOwnerAccount  *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId       *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The number of consecutive times that the event-triggered task created for scale-out activities must meet the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.
	ScaleInEvaluationCount *int32 `json:"ScaleInEvaluationCount,omitempty" xml:"ScaleInEvaluationCount,omitempty"`
	// The mode of the predictive scaling rule. Valid values:
	//
	// *   PredictAndScale: produces predictions and creates prediction tasks.
	// *   PredictOnly: produces predictions but does not create prediction tasks.
	ScaleOutEvaluationCount *int32 `json:"ScaleOutEvaluationCount,omitempty" xml:"ScaleOutEvaluationCount,omitempty"`
	// The name of the scaling rule. The name must be 2 to 64 characters in length, and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). The name must start with a letter or a digit. The name of a scaling rule must be unique in the scaling group to which the scaling rule belongs and within an Alibaba Cloud account.
	ScalingRuleId *string `json:"ScalingRuleId,omitempty" xml:"ScalingRuleId,omitempty"`
	// The cooldown time of the scaling rule. This parameter is available only if you set the ScalingRuleType parameter to SimpleScalingRule.
	//
	// Valid values: 0 to 86400. Unit: seconds.
	ScalingRuleName *string `json:"ScalingRuleName,omitempty" xml:"ScalingRuleName,omitempty"`
	// Details of the step adjustments.
	StepAdjustments []*ModifyScalingRuleRequestStepAdjustments `json:"StepAdjustments,omitempty" xml:"StepAdjustments,omitempty" type:"Repeated"`
	// Specifies whether to disable scale-in. This parameter is available only if you set the ScalingRuleType parameter to TargetTrackingScalingRule.
	TargetValue *float32 `json:"TargetValue,omitempty" xml:"TargetValue,omitempty"`
}

func (s ModifyScalingRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingRuleRequest) GoString() string {
	return s.String()
}

func (s *ModifyScalingRuleRequest) SetAdjustmentType(v string) *ModifyScalingRuleRequest {
	s.AdjustmentType = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetAdjustmentValue(v int32) *ModifyScalingRuleRequest {
	s.AdjustmentValue = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetCooldown(v int32) *ModifyScalingRuleRequest {
	s.Cooldown = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetDisableScaleIn(v bool) *ModifyScalingRuleRequest {
	s.DisableScaleIn = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetEstimatedInstanceWarmup(v int32) *ModifyScalingRuleRequest {
	s.EstimatedInstanceWarmup = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetInitialMaxSize(v int32) *ModifyScalingRuleRequest {
	s.InitialMaxSize = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetMetricName(v string) *ModifyScalingRuleRequest {
	s.MetricName = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetMinAdjustmentMagnitude(v int32) *ModifyScalingRuleRequest {
	s.MinAdjustmentMagnitude = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetOwnerAccount(v string) *ModifyScalingRuleRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetOwnerId(v int64) *ModifyScalingRuleRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetPredictiveScalingMode(v string) *ModifyScalingRuleRequest {
	s.PredictiveScalingMode = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetPredictiveTaskBufferTime(v int32) *ModifyScalingRuleRequest {
	s.PredictiveTaskBufferTime = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetPredictiveValueBehavior(v string) *ModifyScalingRuleRequest {
	s.PredictiveValueBehavior = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetPredictiveValueBuffer(v int32) *ModifyScalingRuleRequest {
	s.PredictiveValueBuffer = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetResourceOwnerAccount(v string) *ModifyScalingRuleRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetResourceOwnerId(v int64) *ModifyScalingRuleRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetScaleInEvaluationCount(v int32) *ModifyScalingRuleRequest {
	s.ScaleInEvaluationCount = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetScaleOutEvaluationCount(v int32) *ModifyScalingRuleRequest {
	s.ScaleOutEvaluationCount = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetScalingRuleId(v string) *ModifyScalingRuleRequest {
	s.ScalingRuleId = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetScalingRuleName(v string) *ModifyScalingRuleRequest {
	s.ScalingRuleName = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetStepAdjustments(v []*ModifyScalingRuleRequestStepAdjustments) *ModifyScalingRuleRequest {
	s.StepAdjustments = v
	return s
}

func (s *ModifyScalingRuleRequest) SetTargetValue(v float32) *ModifyScalingRuleRequest {
	s.TargetValue = &v
	return s
}

type ModifyScalingRuleRequestStepAdjustments struct {
	// The ID of the request.
	MetricIntervalLowerBound *float32 `json:"MetricIntervalLowerBound,omitempty" xml:"MetricIntervalLowerBound,omitempty"`
	// The number of ECS instances that you want to scale in a step adjustment. This parameter is available only if you set the ScalingRuleType parameter to StepScalingRule.
	MetricIntervalUpperBound *float32 `json:"MetricIntervalUpperBound,omitempty" xml:"MetricIntervalUpperBound,omitempty"`
	// The lower limit that is specified in a step adjustment. This parameter is available only if you set the ScalingRuleType parameter to StepScalingRule. Valid values: -9.999999E18 to 9.999999E18.
	ScalingAdjustment *int32 `json:"ScalingAdjustment,omitempty" xml:"ScalingAdjustment,omitempty"`
}

func (s ModifyScalingRuleRequestStepAdjustments) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingRuleRequestStepAdjustments) GoString() string {
	return s.String()
}

func (s *ModifyScalingRuleRequestStepAdjustments) SetMetricIntervalLowerBound(v float32) *ModifyScalingRuleRequestStepAdjustments {
	s.MetricIntervalLowerBound = &v
	return s
}

func (s *ModifyScalingRuleRequestStepAdjustments) SetMetricIntervalUpperBound(v float32) *ModifyScalingRuleRequestStepAdjustments {
	s.MetricIntervalUpperBound = &v
	return s
}

func (s *ModifyScalingRuleRequestStepAdjustments) SetScalingAdjustment(v int32) *ModifyScalingRuleRequestStepAdjustments {
	s.ScalingAdjustment = &v
	return s
}

type ModifyScalingRuleResponseBody struct {
	// 4454
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyScalingRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingRuleResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyScalingRuleResponseBody) SetRequestId(v string) *ModifyScalingRuleResponseBody {
	s.RequestId = &v
	return s
}

type ModifyScalingRuleResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyScalingRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyScalingRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingRuleResponse) GoString() string {
	return s.String()
}

func (s *ModifyScalingRuleResponse) SetHeaders(v map[string]*string) *ModifyScalingRuleResponse {
	s.Headers = v
	return s
}

func (s *ModifyScalingRuleResponse) SetStatusCode(v int32) *ModifyScalingRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyScalingRuleResponse) SetBody(v *ModifyScalingRuleResponseBody) *ModifyScalingRuleResponse {
	s.Body = v
	return s
}

type ModifyScheduledTaskRequest struct {
	// The scaling rule that you want to execute when the scheduled task is triggered. Specify the unique identifier of the scaling rule. If you specify the `ScheduledAction` parameter, you must select an existing scaling rule for the scheduled task.
	//
	// > You cannot specify the `ScheduledAction` and `ScalingGroupId` parameters at the same time.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the scaling group whose number of instances must be modified when the scheduled task is triggered. If you specify the `ScalingGroupId` parameter for a scheduled task, you must specify the minimum, maximum, or expected numbers of instances for a scaling group in the scheduled task. That is, you must specify at least one of the `MinValue`, `MaxValue`, and `DesiredCapacity` parameters.
	//
	// > You cannot specify the `ScheduledAction` and `ScalingGroupId` parameters at the same time.
	DesiredCapacity *int32 `json:"DesiredCapacity,omitempty" xml:"DesiredCapacity,omitempty"`
	// The minimum number of instances in the scaling group if you specify the ScalingGroupId parameter.
	LaunchExpirationTime *int32 `json:"LaunchExpirationTime,omitempty" xml:"LaunchExpirationTime,omitempty"`
	// The interval at which the scheduled task is repeated. Valid values:
	//
	// *   Daily: The scheduled task is executed once every specified number of days.
	// *   Weekly: The scheduled task is executed on each specified day of the week.
	// *   Monthly: The scheduled task is executed on each specified day of the month.
	// *   Cron: The scheduled task is executed based on the specified cron expression.
	//
	// After you modify the scheduled task, the values that you specify for the `RecurrenceType` and `RecurrenceValue` parameters must be valid at the same time.
	LaunchTime *string `json:"LaunchTime,omitempty" xml:"LaunchTime,omitempty"`
	// The expected number of instances in the scaling group if you specify the ScalingGroupId parameter.
	//
	// > You must specify the `DesiredCapacity` parameter when you create a scaling group.
	MaxValue *int32 `json:"MaxValue,omitempty" xml:"MaxValue,omitempty"`
	// The maximum number of instances in the scaling group if you specify the ScalingGroupId parameter.
	MinValue     *int32  `json:"MinValue,omitempty" xml:"MinValue,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The point in time at which the scheduled task is triggered. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mmZ format. The time must be in UTC. You cannot enter a time point later than 90 days from the point in time at which the scheduled task is modified.
	//
	// *   If you specify the `RecurrenceType` parameter, the task is repeatedly executed at the time point that is specified by the LaunchTime parameter.
	// *   If you do not specify the `RecurrenceType` parameter, the task is executed only once at the point in time that is specified by the LaunchTime parameter.
	RecurrenceEndTime *string `json:"RecurrenceEndTime,omitempty" xml:"RecurrenceEndTime,omitempty"`
	// The number of recurrences of the scheduled task.
	//
	// *   If you set the `RecurrenceType` parameter to `Daily`, you can specify only one value for this parameter. Valid values: 1 to 31.
	// *   If you set the `RecurrenceType` parameter to `Weekly`, you can specify multiple values for this parameter. Separate the values with commas (,). The values that correspond to Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, and Saturday are 0, 1, 2, 3, 4, 5, and 6.``
	// *   If you set the `RecurrenceType` parameter to `Monthly`, you can specify two values in the `A-B` format for this parameter. Valid values of A and B: 1 to 31. B must be greater than or equal to A.
	// *   If you set the `RecurrenceType` parameter to `Cron`, you can specify a cron expression. A cron expression is written in UTC time and consists of the following fields: minute, hour, day, month, and week. The expression can contain the letters L and W and the following wildcard characters: commas (,), question marks (?), hyphens (-), asterisks (\*), number signs (#), and forward slashes (/).
	//
	// After you modify the scheduled task, the values that you specify for the `RecurrenceType` and `RecurrenceValue` parameters must be valid at the same time.
	RecurrenceType *string `json:"RecurrenceType,omitempty" xml:"RecurrenceType,omitempty"`
	// Specifies whether to enable the scheduled task. Valid values:
	//
	// *   true
	// *   false
	//
	// Default value: true.
	RecurrenceValue      *string `json:"RecurrenceValue,omitempty" xml:"RecurrenceValue,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the request.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// The end time of the scheduled task. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mmZ format. The time must be in UTC. You cannot enter a point in time that is later than 365 days from the point in time at which the scheduled task is modified.
	ScheduledAction *string `json:"ScheduledAction,omitempty" xml:"ScheduledAction,omitempty"`
	// The name of the scheduled task. The name must be 2 to 64 characters in length, and can contain letters, digits, underscores (\_), hyphens (-), and periods (.). It must start with a letter or a digit. The name of the scheduled task must be unique in the region and within the Alibaba Cloud account.
	ScheduledTaskId *string `json:"ScheduledTaskId,omitempty" xml:"ScheduledTaskId,omitempty"`
	// The description of the scheduled task. The description must be 2 to 200 characters in length.
	ScheduledTaskName *string `json:"ScheduledTaskName,omitempty" xml:"ScheduledTaskName,omitempty"`
	// The time period during which the failed scheduled task is retried. Unit: seconds. Valid values: 0 to 1800.
	//
	// Default value: 600.
	TaskEnabled *bool `json:"TaskEnabled,omitempty" xml:"TaskEnabled,omitempty"`
}

func (s ModifyScheduledTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyScheduledTaskRequest) GoString() string {
	return s.String()
}

func (s *ModifyScheduledTaskRequest) SetDescription(v string) *ModifyScheduledTaskRequest {
	s.Description = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetDesiredCapacity(v int32) *ModifyScheduledTaskRequest {
	s.DesiredCapacity = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetLaunchExpirationTime(v int32) *ModifyScheduledTaskRequest {
	s.LaunchExpirationTime = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetLaunchTime(v string) *ModifyScheduledTaskRequest {
	s.LaunchTime = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetMaxValue(v int32) *ModifyScheduledTaskRequest {
	s.MaxValue = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetMinValue(v int32) *ModifyScheduledTaskRequest {
	s.MinValue = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetOwnerAccount(v string) *ModifyScheduledTaskRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetOwnerId(v int64) *ModifyScheduledTaskRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetRecurrenceEndTime(v string) *ModifyScheduledTaskRequest {
	s.RecurrenceEndTime = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetRecurrenceType(v string) *ModifyScheduledTaskRequest {
	s.RecurrenceType = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetRecurrenceValue(v string) *ModifyScheduledTaskRequest {
	s.RecurrenceValue = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetResourceOwnerAccount(v string) *ModifyScheduledTaskRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetResourceOwnerId(v int64) *ModifyScheduledTaskRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetScalingGroupId(v string) *ModifyScheduledTaskRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetScheduledAction(v string) *ModifyScheduledTaskRequest {
	s.ScheduledAction = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetScheduledTaskId(v string) *ModifyScheduledTaskRequest {
	s.ScheduledTaskId = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetScheduledTaskName(v string) *ModifyScheduledTaskRequest {
	s.ScheduledTaskName = &v
	return s
}

func (s *ModifyScheduledTaskRequest) SetTaskEnabled(v bool) *ModifyScheduledTaskRequest {
	s.TaskEnabled = &v
	return s
}

type ModifyScheduledTaskResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyScheduledTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyScheduledTaskResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyScheduledTaskResponseBody) SetRequestId(v string) *ModifyScheduledTaskResponseBody {
	s.RequestId = &v
	return s
}

type ModifyScheduledTaskResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyScheduledTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyScheduledTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyScheduledTaskResponse) GoString() string {
	return s.String()
}

func (s *ModifyScheduledTaskResponse) SetHeaders(v map[string]*string) *ModifyScheduledTaskResponse {
	s.Headers = v
	return s
}

func (s *ModifyScheduledTaskResponse) SetStatusCode(v int32) *ModifyScheduledTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyScheduledTaskResponse) SetBody(v *ModifyScheduledTaskResponseBody) *ModifyScheduledTaskResponse {
	s.Body = v
	return s
}

type RebalanceInstancesRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the scaling activity.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The region ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s RebalanceInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s RebalanceInstancesRequest) GoString() string {
	return s.String()
}

func (s *RebalanceInstancesRequest) SetOwnerAccount(v string) *RebalanceInstancesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RebalanceInstancesRequest) SetOwnerId(v int64) *RebalanceInstancesRequest {
	s.OwnerId = &v
	return s
}

func (s *RebalanceInstancesRequest) SetRegionId(v string) *RebalanceInstancesRequest {
	s.RegionId = &v
	return s
}

func (s *RebalanceInstancesRequest) SetResourceOwnerAccount(v string) *RebalanceInstancesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RebalanceInstancesRequest) SetResourceOwnerId(v int64) *RebalanceInstancesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *RebalanceInstancesRequest) SetScalingGroupId(v string) *RebalanceInstancesRequest {
	s.ScalingGroupId = &v
	return s
}

type RebalanceInstancesResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s RebalanceInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RebalanceInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *RebalanceInstancesResponseBody) SetRequestId(v string) *RebalanceInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *RebalanceInstancesResponseBody) SetScalingActivityId(v string) *RebalanceInstancesResponseBody {
	s.ScalingActivityId = &v
	return s
}

type RebalanceInstancesResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RebalanceInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RebalanceInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s RebalanceInstancesResponse) GoString() string {
	return s.String()
}

func (s *RebalanceInstancesResponse) SetHeaders(v map[string]*string) *RebalanceInstancesResponse {
	s.Headers = v
	return s
}

func (s *RebalanceInstancesResponse) SetStatusCode(v int32) *RebalanceInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *RebalanceInstancesResponse) SetBody(v *RebalanceInstancesResponseBody) *RebalanceInstancesResponse {
	s.Body = v
	return s
}

type RecordLifecycleActionHeartbeatRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The region ID of the scaling group.
	HeartbeatTimeout *int32 `json:"heartbeatTimeout,omitempty" xml:"heartbeatTimeout,omitempty"`
	// The period of time before the lifecycle hook ends. Auto Scaling performs the specified action after the lifecycle hook ends. Valid values: 30 to 21600. Unit: seconds.
	//
	// You can call this operation to prolong the length of a lifecycle hook. You can also call the CompleteLifecycleAction operation to end a lifecycle hook ahead of schedule.
	//
	// Default value: 600.
	LifecycleActionToken *string `json:"lifecycleActionToken,omitempty" xml:"lifecycleActionToken,omitempty"`
	// The token of the lifecycle hook. You can obtain this token by using a Message Service (MNS) queue or an MNS topic that is specified for the lifecycle hook.
	LifecycleHookId *string `json:"lifecycleHookId,omitempty" xml:"lifecycleHookId,omitempty"`
}

func (s RecordLifecycleActionHeartbeatRequest) String() string {
	return tea.Prettify(s)
}

func (s RecordLifecycleActionHeartbeatRequest) GoString() string {
	return s.String()
}

func (s *RecordLifecycleActionHeartbeatRequest) SetOwnerAccount(v string) *RecordLifecycleActionHeartbeatRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RecordLifecycleActionHeartbeatRequest) SetOwnerId(v int64) *RecordLifecycleActionHeartbeatRequest {
	s.OwnerId = &v
	return s
}

func (s *RecordLifecycleActionHeartbeatRequest) SetRegionId(v string) *RecordLifecycleActionHeartbeatRequest {
	s.RegionId = &v
	return s
}

func (s *RecordLifecycleActionHeartbeatRequest) SetResourceOwnerAccount(v string) *RecordLifecycleActionHeartbeatRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RecordLifecycleActionHeartbeatRequest) SetHeartbeatTimeout(v int32) *RecordLifecycleActionHeartbeatRequest {
	s.HeartbeatTimeout = &v
	return s
}

func (s *RecordLifecycleActionHeartbeatRequest) SetLifecycleActionToken(v string) *RecordLifecycleActionHeartbeatRequest {
	s.LifecycleActionToken = &v
	return s
}

func (s *RecordLifecycleActionHeartbeatRequest) SetLifecycleHookId(v string) *RecordLifecycleActionHeartbeatRequest {
	s.LifecycleHookId = &v
	return s
}

type RecordLifecycleActionHeartbeatResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RecordLifecycleActionHeartbeatResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RecordLifecycleActionHeartbeatResponseBody) GoString() string {
	return s.String()
}

func (s *RecordLifecycleActionHeartbeatResponseBody) SetRequestId(v string) *RecordLifecycleActionHeartbeatResponseBody {
	s.RequestId = &v
	return s
}

type RecordLifecycleActionHeartbeatResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RecordLifecycleActionHeartbeatResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RecordLifecycleActionHeartbeatResponse) String() string {
	return tea.Prettify(s)
}

func (s RecordLifecycleActionHeartbeatResponse) GoString() string {
	return s.String()
}

func (s *RecordLifecycleActionHeartbeatResponse) SetHeaders(v map[string]*string) *RecordLifecycleActionHeartbeatResponse {
	s.Headers = v
	return s
}

func (s *RecordLifecycleActionHeartbeatResponse) SetStatusCode(v int32) *RecordLifecycleActionHeartbeatResponse {
	s.StatusCode = &v
	return s
}

func (s *RecordLifecycleActionHeartbeatResponse) SetBody(v *RecordLifecycleActionHeartbeatResponseBody) *RecordLifecycleActionHeartbeatResponse {
	s.Body = v
	return s
}

type RemoveInstancesRequest struct {
	// Specifies whether to adjust the expected number of ECS instances in the scaling group. Valid values:
	//
	// *   true: After ECS instances are removed from the scaling group, the expected number of ECS instances in the scaling group decreases.
	// *   false: After ECS instances are removed from the scaling group, the expected number of ECS instances in the scaling group remains unchanged.
	//
	// Default value: true.
	DecreaseDesiredCapacity *bool `json:"DecreaseDesiredCapacity,omitempty" xml:"DecreaseDesiredCapacity,omitempty"`
	// The IDs of the ECS instances that you want to remove from the scaling group.
	InstanceIds  []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	OwnerAccount *string   `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the scaling group.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The action that you want Auto Scaling to perform after the ECS instance is removed from the scaling group. Valid values:
	//
	// *   recycle: puts the ECS instance into economical mode.
	//
	//     **
	//
	//     **Note**This setting takes effect only if you set the ScalingPolicy parameter to recycle.
	//
	// *   release: releases the ECS instance.
	//
	// The ScalingPolicy parameter that you specify when you call the CreateScalingGroup operation specifies the reclaim mode of the scaling group. The RemovePolicy parameter that you specify when you call the RemoveInstances operation specifies the action to be performed on ECS instances after the ECS instances are removed. Example:
	//
	// *   If you set both the ScalingPolicy parameter and the RemovePolicy parameter to recycle, the ECS instances are put into economical mode after the ECS instances are removed from the scaling group.
	// *   If you set the ScalingPolicy parameter to recycle and the RemovePolicy parameter to release, the ECS instances are released after the ECS instances are removed from the scaling group.
	// *   If you set the ScalingPolicy parameter to release and the RemovePolicy parameter to recycle, the ECS instances are released after the ECS instances are removed from the scaling group.
	// *   If you set both the ScalingPolicy parameter and the RemovePolicy parameter to release, the ECS instances are released after the ECS instances are removed from the scaling group.
	//
	// Default value: release.
	RemovePolicy         *string `json:"RemovePolicy,omitempty" xml:"RemovePolicy,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s RemoveInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveInstancesRequest) GoString() string {
	return s.String()
}

func (s *RemoveInstancesRequest) SetDecreaseDesiredCapacity(v bool) *RemoveInstancesRequest {
	s.DecreaseDesiredCapacity = &v
	return s
}

func (s *RemoveInstancesRequest) SetInstanceIds(v []*string) *RemoveInstancesRequest {
	s.InstanceIds = v
	return s
}

func (s *RemoveInstancesRequest) SetOwnerAccount(v string) *RemoveInstancesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RemoveInstancesRequest) SetOwnerId(v int64) *RemoveInstancesRequest {
	s.OwnerId = &v
	return s
}

func (s *RemoveInstancesRequest) SetRegionId(v string) *RemoveInstancesRequest {
	s.RegionId = &v
	return s
}

func (s *RemoveInstancesRequest) SetRemovePolicy(v string) *RemoveInstancesRequest {
	s.RemovePolicy = &v
	return s
}

func (s *RemoveInstancesRequest) SetResourceOwnerAccount(v string) *RemoveInstancesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RemoveInstancesRequest) SetResourceOwnerId(v int64) *RemoveInstancesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *RemoveInstancesRequest) SetScalingGroupId(v string) *RemoveInstancesRequest {
	s.ScalingGroupId = &v
	return s
}

type RemoveInstancesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the scaling activity.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s RemoveInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveInstancesResponseBody) SetRequestId(v string) *RemoveInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *RemoveInstancesResponseBody) SetScalingActivityId(v string) *RemoveInstancesResponseBody {
	s.ScalingActivityId = &v
	return s
}

type RemoveInstancesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemoveInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemoveInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveInstancesResponse) GoString() string {
	return s.String()
}

func (s *RemoveInstancesResponse) SetHeaders(v map[string]*string) *RemoveInstancesResponse {
	s.Headers = v
	return s
}

func (s *RemoveInstancesResponse) SetStatusCode(v int32) *RemoveInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveInstancesResponse) SetBody(v *RemoveInstancesResponseBody) *RemoveInstancesResponse {
	s.Body = v
	return s
}

type ResumeProcessesRequest struct {
	// Details of the processes that you want to resume.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerId     *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The type of the process that you want to resume. Valid values:
	//
	// *   ScaleIn
	// *   ScaleOut
	// *   HealthCheck
	// *   AlarmNotification
	// *   ScheduledAction
	//
	// You can resume five processes of the preceding types at the same time. If you try to resume more than five processes at the same time, Auto Scaling automatically removes the duplicate processes.
	Processes []*string `json:"Processes,omitempty" xml:"Processes,omitempty" type:"Repeated"`
	// The ID of the request
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.
	//
	// The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s ResumeProcessesRequest) String() string {
	return tea.Prettify(s)
}

func (s ResumeProcessesRequest) GoString() string {
	return s.String()
}

func (s *ResumeProcessesRequest) SetClientToken(v string) *ResumeProcessesRequest {
	s.ClientToken = &v
	return s
}

func (s *ResumeProcessesRequest) SetOwnerId(v int64) *ResumeProcessesRequest {
	s.OwnerId = &v
	return s
}

func (s *ResumeProcessesRequest) SetProcesses(v []*string) *ResumeProcessesRequest {
	s.Processes = v
	return s
}

func (s *ResumeProcessesRequest) SetRegionId(v string) *ResumeProcessesRequest {
	s.RegionId = &v
	return s
}

func (s *ResumeProcessesRequest) SetResourceOwnerAccount(v string) *ResumeProcessesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ResumeProcessesRequest) SetScalingGroupId(v string) *ResumeProcessesRequest {
	s.ScalingGroupId = &v
	return s
}

type ResumeProcessesResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ResumeProcessesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ResumeProcessesResponseBody) GoString() string {
	return s.String()
}

func (s *ResumeProcessesResponseBody) SetRequestId(v string) *ResumeProcessesResponseBody {
	s.RequestId = &v
	return s
}

type ResumeProcessesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ResumeProcessesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ResumeProcessesResponse) String() string {
	return tea.Prettify(s)
}

func (s ResumeProcessesResponse) GoString() string {
	return s.String()
}

func (s *ResumeProcessesResponse) SetHeaders(v map[string]*string) *ResumeProcessesResponse {
	s.Headers = v
	return s
}

func (s *ResumeProcessesResponse) SetStatusCode(v int32) *ResumeProcessesResponse {
	s.StatusCode = &v
	return s
}

func (s *ResumeProcessesResponse) SetBody(v *ResumeProcessesResponseBody) *ResumeProcessesResponse {
	s.Body = v
	return s
}

type ScaleWithAdjustmentRequest struct {
	// The type of the scaling policy. Valid values:
	//
	// *   QuantityChangeInCapacity: adds the specified number of ECS instances to or removes the specified number of ECS instances from the scaling group.
	// *   PercentChangeInCapacity: adds the specified percentage of ECS instances to or removes the specified percentage of ECS instances from the scaling group.
	// *   TotalCapacity: adjusts the number of ECS instances in the scaling group to a specified number.
	AdjustmentType *string `json:"AdjustmentType,omitempty" xml:"AdjustmentType,omitempty"`
	// The number of instances in each adjustment. The number of ECS instances in each adjustment cannot exceed 1,000.
	//
	// *   Valid values if you set the AdjustmentType parameter to QuantityChangeInCapacity: -1000 to 1000.
	// *   Valid values if you set the AdjustmentType parameter to PercentChangeInCapacity: -100 to 10000.
	// *   Valid values if you set the AdjustmentType parameter to TotalCapacity: 0 to 2000.
	AdjustmentValue *int32 `json:"AdjustmentValue,omitempty" xml:"AdjustmentValue,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The minimum number of instances allowed in each adjustment. This parameter takes effect only if you set the `AdjustmentType` parameter to `PercentChangeInCapacity`.
	MinAdjustmentMagnitude *int32  `json:"MinAdjustmentMagnitude,omitempty" xml:"MinAdjustmentMagnitude,omitempty"`
	OwnerId                *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount   *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
	// Specifies whether to trigger the scaling activity in a synchronous manner. This parameter takes effect only on scaling groups for which you specified an expected number of instances. Valid values:
	//
	// *   true: triggers the scaling activity in a synchronous manner. The scaling activity is triggered at the time when the scaling rule is executed.
	// *   false: does not trigger the scaling activity in a synchronous manner. After you change the expected number of instances for the scaling group, Auto Scaling checks whether the total number of instances in the scaling group matches the new expected number of instances and determines whether to trigger the scaling activity based on the check result.
	//
	// > For more information about the Expected Number of Instances feature, see [Expected number of instances](~~146231~~).
	//
	// Default value: false.
	SyncActivity *bool `json:"SyncActivity,omitempty" xml:"SyncActivity,omitempty"`
}

func (s ScaleWithAdjustmentRequest) String() string {
	return tea.Prettify(s)
}

func (s ScaleWithAdjustmentRequest) GoString() string {
	return s.String()
}

func (s *ScaleWithAdjustmentRequest) SetAdjustmentType(v string) *ScaleWithAdjustmentRequest {
	s.AdjustmentType = &v
	return s
}

func (s *ScaleWithAdjustmentRequest) SetAdjustmentValue(v int32) *ScaleWithAdjustmentRequest {
	s.AdjustmentValue = &v
	return s
}

func (s *ScaleWithAdjustmentRequest) SetClientToken(v string) *ScaleWithAdjustmentRequest {
	s.ClientToken = &v
	return s
}

func (s *ScaleWithAdjustmentRequest) SetMinAdjustmentMagnitude(v int32) *ScaleWithAdjustmentRequest {
	s.MinAdjustmentMagnitude = &v
	return s
}

func (s *ScaleWithAdjustmentRequest) SetOwnerId(v int64) *ScaleWithAdjustmentRequest {
	s.OwnerId = &v
	return s
}

func (s *ScaleWithAdjustmentRequest) SetResourceOwnerAccount(v string) *ScaleWithAdjustmentRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ScaleWithAdjustmentRequest) SetScalingGroupId(v string) *ScaleWithAdjustmentRequest {
	s.ScalingGroupId = &v
	return s
}

func (s *ScaleWithAdjustmentRequest) SetSyncActivity(v bool) *ScaleWithAdjustmentRequest {
	s.SyncActivity = &v
	return s
}

type ScaleWithAdjustmentResponseBody struct {
	// The type of scaling activity.
	//
	// When the ActivityType is CapacityChange, it means that the scaling activity corresponding to the return value ScalingActivityId only modifies the expected number of instances of the scaling group, and does not perform scaling immediately. Scope of application: scaling groups of the expected number of instances.
	ActivityType *string `json:"ActivityType,omitempty" xml:"ActivityType,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the scaling activity.
	ScalingActivityId *string `json:"ScalingActivityId,omitempty" xml:"ScalingActivityId,omitempty"`
}

func (s ScaleWithAdjustmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ScaleWithAdjustmentResponseBody) GoString() string {
	return s.String()
}

func (s *ScaleWithAdjustmentResponseBody) SetActivityType(v string) *ScaleWithAdjustmentResponseBody {
	s.ActivityType = &v
	return s
}

func (s *ScaleWithAdjustmentResponseBody) SetRequestId(v string) *ScaleWithAdjustmentResponseBody {
	s.RequestId = &v
	return s
}

func (s *ScaleWithAdjustmentResponseBody) SetScalingActivityId(v string) *ScaleWithAdjustmentResponseBody {
	s.ScalingActivityId = &v
	return s
}

type ScaleWithAdjustmentResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ScaleWithAdjustmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ScaleWithAdjustmentResponse) String() string {
	return tea.Prettify(s)
}

func (s ScaleWithAdjustmentResponse) GoString() string {
	return s.String()
}

func (s *ScaleWithAdjustmentResponse) SetHeaders(v map[string]*string) *ScaleWithAdjustmentResponse {
	s.Headers = v
	return s
}

func (s *ScaleWithAdjustmentResponse) SetStatusCode(v int32) *ScaleWithAdjustmentResponse {
	s.StatusCode = &v
	return s
}

func (s *ScaleWithAdjustmentResponse) SetBody(v *ScaleWithAdjustmentResponseBody) *ScaleWithAdjustmentResponse {
	s.Body = v
	return s
}

type SetGroupDeletionProtectionRequest struct {
	// The ID of the scaling group.
	GroupDeletionProtection *bool  `json:"GroupDeletionProtection,omitempty" xml:"GroupDeletionProtection,omitempty"`
	OwnerId                 *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The region ID of the scaling group.
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s SetGroupDeletionProtectionRequest) String() string {
	return tea.Prettify(s)
}

func (s SetGroupDeletionProtectionRequest) GoString() string {
	return s.String()
}

func (s *SetGroupDeletionProtectionRequest) SetGroupDeletionProtection(v bool) *SetGroupDeletionProtectionRequest {
	s.GroupDeletionProtection = &v
	return s
}

func (s *SetGroupDeletionProtectionRequest) SetOwnerId(v int64) *SetGroupDeletionProtectionRequest {
	s.OwnerId = &v
	return s
}

func (s *SetGroupDeletionProtectionRequest) SetRegionId(v string) *SetGroupDeletionProtectionRequest {
	s.RegionId = &v
	return s
}

func (s *SetGroupDeletionProtectionRequest) SetResourceOwnerAccount(v string) *SetGroupDeletionProtectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetGroupDeletionProtectionRequest) SetScalingGroupId(v string) *SetGroupDeletionProtectionRequest {
	s.ScalingGroupId = &v
	return s
}

type SetGroupDeletionProtectionResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetGroupDeletionProtectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetGroupDeletionProtectionResponseBody) GoString() string {
	return s.String()
}

func (s *SetGroupDeletionProtectionResponseBody) SetRequestId(v string) *SetGroupDeletionProtectionResponseBody {
	s.RequestId = &v
	return s
}

type SetGroupDeletionProtectionResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetGroupDeletionProtectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetGroupDeletionProtectionResponse) String() string {
	return tea.Prettify(s)
}

func (s SetGroupDeletionProtectionResponse) GoString() string {
	return s.String()
}

func (s *SetGroupDeletionProtectionResponse) SetHeaders(v map[string]*string) *SetGroupDeletionProtectionResponse {
	s.Headers = v
	return s
}

func (s *SetGroupDeletionProtectionResponse) SetStatusCode(v int32) *SetGroupDeletionProtectionResponse {
	s.StatusCode = &v
	return s
}

func (s *SetGroupDeletionProtectionResponse) SetBody(v *SetGroupDeletionProtectionResponseBody) *SetGroupDeletionProtectionResponse {
	s.Body = v
	return s
}

type SetInstanceHealthRequest struct {
	// The ID of the request.
	HealthStatus *string `json:"HealthStatus,omitempty" xml:"HealthStatus,omitempty"`
	// The health status of the ECS instance. Valid values:
	//
	// *   Healthy
	// *   Unhealthy
	InstanceId           *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
}

func (s SetInstanceHealthRequest) String() string {
	return tea.Prettify(s)
}

func (s SetInstanceHealthRequest) GoString() string {
	return s.String()
}

func (s *SetInstanceHealthRequest) SetHealthStatus(v string) *SetInstanceHealthRequest {
	s.HealthStatus = &v
	return s
}

func (s *SetInstanceHealthRequest) SetInstanceId(v string) *SetInstanceHealthRequest {
	s.InstanceId = &v
	return s
}

func (s *SetInstanceHealthRequest) SetOwnerId(v int64) *SetInstanceHealthRequest {
	s.OwnerId = &v
	return s
}

func (s *SetInstanceHealthRequest) SetResourceOwnerAccount(v string) *SetInstanceHealthRequest {
	s.ResourceOwnerAccount = &v
	return s
}

type SetInstanceHealthResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetInstanceHealthResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetInstanceHealthResponseBody) GoString() string {
	return s.String()
}

func (s *SetInstanceHealthResponseBody) SetRequestId(v string) *SetInstanceHealthResponseBody {
	s.RequestId = &v
	return s
}

type SetInstanceHealthResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetInstanceHealthResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetInstanceHealthResponse) String() string {
	return tea.Prettify(s)
}

func (s SetInstanceHealthResponse) GoString() string {
	return s.String()
}

func (s *SetInstanceHealthResponse) SetHeaders(v map[string]*string) *SetInstanceHealthResponse {
	s.Headers = v
	return s
}

func (s *SetInstanceHealthResponse) SetStatusCode(v int32) *SetInstanceHealthResponse {
	s.StatusCode = &v
	return s
}

func (s *SetInstanceHealthResponse) SetBody(v *SetInstanceHealthResponseBody) *SetInstanceHealthResponse {
	s.Body = v
	return s
}

type SetInstancesProtectionRequest struct {
	// The IDs of the ECS instances.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	OwnerId     *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The IDs of the ECS instances.
	ProtectedFromScaleIn *bool   `json:"ProtectedFromScaleIn,omitempty" xml:"ProtectedFromScaleIn,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// Specifies whether to put ECS instances into the Protected state. Auto Scaling does not remove ECS instances in the Protected state from scaling groups during scale-in activities.
	//
	// *   true
	// *   false
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s SetInstancesProtectionRequest) String() string {
	return tea.Prettify(s)
}

func (s SetInstancesProtectionRequest) GoString() string {
	return s.String()
}

func (s *SetInstancesProtectionRequest) SetInstanceIds(v []*string) *SetInstancesProtectionRequest {
	s.InstanceIds = v
	return s
}

func (s *SetInstancesProtectionRequest) SetOwnerId(v int64) *SetInstancesProtectionRequest {
	s.OwnerId = &v
	return s
}

func (s *SetInstancesProtectionRequest) SetProtectedFromScaleIn(v bool) *SetInstancesProtectionRequest {
	s.ProtectedFromScaleIn = &v
	return s
}

func (s *SetInstancesProtectionRequest) SetResourceOwnerAccount(v string) *SetInstancesProtectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetInstancesProtectionRequest) SetScalingGroupId(v string) *SetInstancesProtectionRequest {
	s.ScalingGroupId = &v
	return s
}

type SetInstancesProtectionResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetInstancesProtectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetInstancesProtectionResponseBody) GoString() string {
	return s.String()
}

func (s *SetInstancesProtectionResponseBody) SetRequestId(v string) *SetInstancesProtectionResponseBody {
	s.RequestId = &v
	return s
}

type SetInstancesProtectionResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetInstancesProtectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetInstancesProtectionResponse) String() string {
	return tea.Prettify(s)
}

func (s SetInstancesProtectionResponse) GoString() string {
	return s.String()
}

func (s *SetInstancesProtectionResponse) SetHeaders(v map[string]*string) *SetInstancesProtectionResponse {
	s.Headers = v
	return s
}

func (s *SetInstancesProtectionResponse) SetStatusCode(v int32) *SetInstancesProtectionResponse {
	s.StatusCode = &v
	return s
}

func (s *SetInstancesProtectionResponse) SetBody(v *SetInstancesProtectionResponseBody) *SetInstancesProtectionResponse {
	s.Body = v
	return s
}

type SuspendProcessesRequest struct {
	// The types of the processes that you want to suspend. Valid values:
	//
	// *   scalein
	// *   scaleout
	// *   healthcheck
	// *   alarmnotification
	// *   scheduledaction
	//
	// You can suspend five processes of the preceding types at the same time. If you try to suspend more than five processes at the same time, Auto Scaling automatically removes duplicate processes.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerId     *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The types of the processes that you want to suspend. Valid values:
	//
	// *   scalein
	// *   scaleout
	// *   healthcheck
	// *   alarmnotification
	// *   scheduledaction
	//
	// You can suspend five processes of the preceding types at the same time. If you try to suspend more than five processes at the same time, Auto Scaling automatically removes duplicate processes.
	Processes []*string `json:"Processes,omitempty" xml:"Processes,omitempty" type:"Repeated"`
	// The ID of the request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.
	//
	// The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).
	ScalingGroupId *string `json:"ScalingGroupId,omitempty" xml:"ScalingGroupId,omitempty"`
}

func (s SuspendProcessesRequest) String() string {
	return tea.Prettify(s)
}

func (s SuspendProcessesRequest) GoString() string {
	return s.String()
}

func (s *SuspendProcessesRequest) SetClientToken(v string) *SuspendProcessesRequest {
	s.ClientToken = &v
	return s
}

func (s *SuspendProcessesRequest) SetOwnerId(v int64) *SuspendProcessesRequest {
	s.OwnerId = &v
	return s
}

func (s *SuspendProcessesRequest) SetProcesses(v []*string) *SuspendProcessesRequest {
	s.Processes = v
	return s
}

func (s *SuspendProcessesRequest) SetRegionId(v string) *SuspendProcessesRequest {
	s.RegionId = &v
	return s
}

func (s *SuspendProcessesRequest) SetResourceOwnerAccount(v string) *SuspendProcessesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SuspendProcessesRequest) SetScalingGroupId(v string) *SuspendProcessesRequest {
	s.ScalingGroupId = &v
	return s
}

type SuspendProcessesResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SuspendProcessesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SuspendProcessesResponseBody) GoString() string {
	return s.String()
}

func (s *SuspendProcessesResponseBody) SetRequestId(v string) *SuspendProcessesResponseBody {
	s.RequestId = &v
	return s
}

type SuspendProcessesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SuspendProcessesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SuspendProcessesResponse) String() string {
	return tea.Prettify(s)
}

func (s SuspendProcessesResponse) GoString() string {
	return s.String()
}

func (s *SuspendProcessesResponse) SetHeaders(v map[string]*string) *SuspendProcessesResponse {
	s.Headers = v
	return s
}

func (s *SuspendProcessesResponse) SetStatusCode(v int32) *SuspendProcessesResponse {
	s.StatusCode = &v
	return s
}

func (s *SuspendProcessesResponse) SetBody(v *SuspendProcessesResponseBody) *SuspendProcessesResponse {
	s.Body = v
	return s
}

type TagResourcesRequest struct {
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The type of the Auto Scaling resource. Only scaling groups are supported. Set the value to scalinggroup.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource.
	ResourceIds          []*string `json:"ResourceIds,omitempty" xml:"ResourceIds,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// The ID of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// Details of the tags.
	Tags []*TagResourcesRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s TagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequest) GoString() string {
	return s.String()
}

func (s *TagResourcesRequest) SetOwnerId(v int64) *TagResourcesRequest {
	s.OwnerId = &v
	return s
}

func (s *TagResourcesRequest) SetRegionId(v string) *TagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *TagResourcesRequest) SetResourceIds(v []*string) *TagResourcesRequest {
	s.ResourceIds = v
	return s
}

func (s *TagResourcesRequest) SetResourceOwnerAccount(v string) *TagResourcesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *TagResourcesRequest) SetResourceType(v string) *TagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *TagResourcesRequest) SetTags(v []*TagResourcesRequestTags) *TagResourcesRequest {
	s.Tags = v
	return s
}

type TagResourcesRequestTags struct {
	// The value of the tag that you want to add to the Auto Scaling resource.
	//
	// You can specify empty strings as tag values. The tag value must be 0 to 128 characters in length and cannot contain `http://` or `https://`. The tag value cannot start with `acs:`.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The ID of the request.
	Propagate *bool `json:"Propagate,omitempty" xml:"Propagate,omitempty"`
	// Specifies whether to propagate the tag that you want to add. Valid values:
	//
	// *   true: propagates the tag only to instances that are newly created and does not propagate the tag to instances that are already running in the scaling group.
	// *   false: does not propagate the tag to any instances.
	//
	// Default value: false.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s TagResourcesRequestTags) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequestTags) GoString() string {
	return s.String()
}

func (s *TagResourcesRequestTags) SetKey(v string) *TagResourcesRequestTags {
	s.Key = &v
	return s
}

func (s *TagResourcesRequestTags) SetPropagate(v bool) *TagResourcesRequestTags {
	s.Propagate = &v
	return s
}

func (s *TagResourcesRequestTags) SetValue(v string) *TagResourcesRequestTags {
	s.Value = &v
	return s
}

type TagResourcesResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *TagResourcesResponseBody) SetRequestId(v string) *TagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type TagResourcesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponse) GoString() string {
	return s.String()
}

func (s *TagResourcesResponse) SetHeaders(v map[string]*string) *TagResourcesResponse {
	s.Headers = v
	return s
}

func (s *TagResourcesResponse) SetStatusCode(v int32) *TagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *TagResourcesResponse) SetBody(v *TagResourcesResponseBody) *TagResourcesResponse {
	s.Body = v
	return s
}

type UntagResourcesRequest struct {
	// The IDs of the Auto Scaling resources. You can specify 1 to 50 resource IDs.
	All     *bool  `json:"All,omitempty" xml:"All,omitempty"`
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The type of the resource. Only scaling groups are supported. Set the value to scalinggroup.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The IDs of the Auto Scaling resources. You can specify 1 to 50 resource IDs.
	ResourceIds          []*string `json:"ResourceIds,omitempty" xml:"ResourceIds,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	// Specifies whether to remove all tags from the Auto Scaling resource. This parameter takes effect only if you do not specify the `TagKeys` parameter. Valid values:
	//
	// *   true: removes all tags from the Auto Scaling resource.
	// *   false: does not remove tags from the Auto Scaling resource.
	//
	// Default value: false.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The keys of the tags that you want to remove from the Auto Scaling resource. You can specify 1 to 20 tag keys.
	TagKeys []*string `json:"TagKeys,omitempty" xml:"TagKeys,omitempty" type:"Repeated"`
}

func (s UntagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesRequest) GoString() string {
	return s.String()
}

func (s *UntagResourcesRequest) SetAll(v bool) *UntagResourcesRequest {
	s.All = &v
	return s
}

func (s *UntagResourcesRequest) SetOwnerId(v int64) *UntagResourcesRequest {
	s.OwnerId = &v
	return s
}

func (s *UntagResourcesRequest) SetRegionId(v string) *UntagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceIds(v []*string) *UntagResourcesRequest {
	s.ResourceIds = v
	return s
}

func (s *UntagResourcesRequest) SetResourceOwnerAccount(v string) *UntagResourcesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceType(v string) *UntagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *UntagResourcesRequest) SetTagKeys(v []*string) *UntagResourcesRequest {
	s.TagKeys = v
	return s
}

type UntagResourcesResponseBody struct {
	// auditing
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UntagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponseBody) SetRequestId(v string) *UntagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type UntagResourcesResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UntagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UntagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponse) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponse) SetHeaders(v map[string]*string) *UntagResourcesResponse {
	s.Headers = v
	return s
}

func (s *UntagResourcesResponse) SetStatusCode(v int32) *UntagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *UntagResourcesResponse) SetBody(v *UntagResourcesResponseBody) *UntagResourcesResponse {
	s.Body = v
	return s
}

type VerifyAuthenticationRequest struct {
	OnlyCheck            *bool   `json:"OnlyCheck,omitempty" xml:"OnlyCheck,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Uid                  *int64  `json:"Uid,omitempty" xml:"Uid,omitempty"`
}

func (s VerifyAuthenticationRequest) String() string {
	return tea.Prettify(s)
}

func (s VerifyAuthenticationRequest) GoString() string {
	return s.String()
}

func (s *VerifyAuthenticationRequest) SetOnlyCheck(v bool) *VerifyAuthenticationRequest {
	s.OnlyCheck = &v
	return s
}

func (s *VerifyAuthenticationRequest) SetOwnerId(v int64) *VerifyAuthenticationRequest {
	s.OwnerId = &v
	return s
}

func (s *VerifyAuthenticationRequest) SetResourceOwnerAccount(v string) *VerifyAuthenticationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *VerifyAuthenticationRequest) SetResourceOwnerId(v int64) *VerifyAuthenticationRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *VerifyAuthenticationRequest) SetUid(v int64) *VerifyAuthenticationRequest {
	s.Uid = &v
	return s
}

type VerifyAuthenticationResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s VerifyAuthenticationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s VerifyAuthenticationResponseBody) GoString() string {
	return s.String()
}

func (s *VerifyAuthenticationResponseBody) SetRequestId(v string) *VerifyAuthenticationResponseBody {
	s.RequestId = &v
	return s
}

type VerifyAuthenticationResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *VerifyAuthenticationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s VerifyAuthenticationResponse) String() string {
	return tea.Prettify(s)
}

func (s VerifyAuthenticationResponse) GoString() string {
	return s.String()
}

func (s *VerifyAuthenticationResponse) SetHeaders(v map[string]*string) *VerifyAuthenticationResponse {
	s.Headers = v
	return s
}

func (s *VerifyAuthenticationResponse) SetStatusCode(v int32) *VerifyAuthenticationResponse {
	s.StatusCode = &v
	return s
}

func (s *VerifyAuthenticationResponse) SetBody(v *VerifyAuthenticationResponseBody) *VerifyAuthenticationResponse {
	s.Body = v
	return s
}

type VerifyUserRequest struct {
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s VerifyUserRequest) String() string {
	return tea.Prettify(s)
}

func (s VerifyUserRequest) GoString() string {
	return s.String()
}

func (s *VerifyUserRequest) SetOwnerId(v int64) *VerifyUserRequest {
	s.OwnerId = &v
	return s
}

func (s *VerifyUserRequest) SetResourceOwnerAccount(v string) *VerifyUserRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *VerifyUserRequest) SetResourceOwnerId(v int64) *VerifyUserRequest {
	s.ResourceOwnerId = &v
	return s
}

type VerifyUserResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s VerifyUserResponseBody) String() string {
	return tea.Prettify(s)
}

func (s VerifyUserResponseBody) GoString() string {
	return s.String()
}

func (s *VerifyUserResponseBody) SetRequestId(v string) *VerifyUserResponseBody {
	s.RequestId = &v
	return s
}

type VerifyUserResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *VerifyUserResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s VerifyUserResponse) String() string {
	return tea.Prettify(s)
}

func (s VerifyUserResponse) GoString() string {
	return s.String()
}

func (s *VerifyUserResponse) SetHeaders(v map[string]*string) *VerifyUserResponse {
	s.Headers = v
	return s
}

func (s *VerifyUserResponse) SetStatusCode(v int32) *VerifyUserResponse {
	s.StatusCode = &v
	return s
}

func (s *VerifyUserResponse) SetBody(v *VerifyUserResponseBody) *VerifyUserResponse {
	s.Body = v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.EndpointRule = tea.String("regional")
	client.EndpointMap = map[string]*string{
		"cn-qingdao":                  tea.String("ess.aliyuncs.com"),
		"cn-beijing":                  tea.String("ess.aliyuncs.com"),
		"cn-hangzhou":                 tea.String("ess.aliyuncs.com"),
		"cn-shanghai":                 tea.String("ess.aliyuncs.com"),
		"cn-shenzhen":                 tea.String("ess.aliyuncs.com"),
		"cn-hongkong":                 tea.String("ess.aliyuncs.com"),
		"ap-southeast-1":              tea.String("ess.aliyuncs.com"),
		"us-east-1":                   tea.String("ess.aliyuncs.com"),
		"us-west-1":                   tea.String("ess.aliyuncs.com"),
		"cn-shanghai-finance-1":       tea.String("ess.aliyuncs.com"),
		"cn-shenzhen-finance-1":       tea.String("ess.aliyuncs.com"),
		"cn-north-2-gov-1":            tea.String("ess.aliyuncs.com"),
		"ap-northeast-2-pop":          tea.String("ess.aliyuncs.com"),
		"cn-beijing-finance-pop":      tea.String("ess.aliyuncs.com"),
		"cn-beijing-gov-1":            tea.String("ess.aliyuncs.com"),
		"cn-beijing-nu16-b01":         tea.String("ess.aliyuncs.com"),
		"cn-edge-1":                   tea.String("ess.aliyuncs.com"),
		"cn-fujian":                   tea.String("ess.aliyuncs.com"),
		"cn-haidian-cm12-c01":         tea.String("ess.aliyuncs.com"),
		"cn-hangzhou-bj-b01":          tea.String("ess.aliyuncs.com"),
		"cn-hangzhou-finance":         tea.String("ess.aliyuncs.com"),
		"cn-hangzhou-internal-prod-1": tea.String("ess.aliyuncs.com"),
		"cn-hangzhou-internal-test-1": tea.String("ess.aliyuncs.com"),
		"cn-hangzhou-internal-test-2": tea.String("ess.aliyuncs.com"),
		"cn-hangzhou-internal-test-3": tea.String("ess.aliyuncs.com"),
		"cn-hangzhou-test-306":        tea.String("ess.aliyuncs.com"),
		"cn-hongkong-finance-pop":     tea.String("ess.aliyuncs.com"),
		"cn-huhehaote-nebula-1":       tea.String("ess.aliyuncs.com"),
		"cn-qingdao-nebula":           tea.String("ess.aliyuncs.com"),
		"cn-shanghai-et15-b01":        tea.String("ess.aliyuncs.com"),
		"cn-shanghai-et2-b01":         tea.String("ess.aliyuncs.com"),
		"cn-shanghai-inner":           tea.String("ess.aliyuncs.com"),
		"cn-shanghai-internal-test-1": tea.String("ess.aliyuncs.com"),
		"cn-shenzhen-inner":           tea.String("ess.aliyuncs.com"),
		"cn-shenzhen-st4-d01":         tea.String("ess.aliyuncs.com"),
		"cn-shenzhen-su18-b01":        tea.String("ess.aliyuncs.com"),
		"cn-wuhan":                    tea.String("ess.aliyuncs.com"),
		"cn-yushanfang":               tea.String("ess.aliyuncs.com"),
		"cn-zhangbei":                 tea.String("ess.aliyuncs.com"),
		"cn-zhangbei-na61-b01":        tea.String("ess.aliyuncs.com"),
		"cn-zhangjiakou-na62-a01":     tea.String("ess.aliyuncs.com"),
		"cn-zhengzhou-nebula-1":       tea.String("ess.aliyuncs.com"),
		"eu-west-1-oxs":               tea.String("ess.aliyuncs.com"),
		"rus-west-1-pop":              tea.String("ess.aliyuncs.com"),
	}
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(tea.String("ess"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !tea.BoolValue(util.Empty(endpoint)) {
		_result = endpoint
		return _result, _err
	}

	if !tea.BoolValue(util.IsUnset(endpointMap)) && !tea.BoolValue(util.Empty(endpointMap[tea.StringValue(regionId)])) {
		_result = endpointMap[tea.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := endpointutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Associates one or more Application Load Balancer (ALB) server groups with a scaling group.
 *
 * @param request AttachAlbServerGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachAlbServerGroupsResponse
 */
func (client *Client) AttachAlbServerGroupsWithOptions(request *AttachAlbServerGroupsRequest, runtime *util.RuntimeOptions) (_result *AttachAlbServerGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlbServerGroups)) {
		query["AlbServerGroups"] = request.AlbServerGroups
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ForceAttach)) {
		query["ForceAttach"] = request.ForceAttach
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachAlbServerGroups"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachAlbServerGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Associates one or more Application Load Balancer (ALB) server groups with a scaling group.
 *
 * @param request AttachAlbServerGroupsRequest
 * @return AttachAlbServerGroupsResponse
 */
func (client *Client) AttachAlbServerGroups(request *AttachAlbServerGroupsRequest) (_result *AttachAlbServerGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachAlbServerGroupsResponse{}
	_body, _err := client.AttachAlbServerGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Associates one or more ApsaraDB RDS instances with a scaling group.
 *
 * @param request AttachDBInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachDBInstancesResponse
 */
func (client *Client) AttachDBInstancesWithOptions(request *AttachDBInstancesRequest, runtime *util.RuntimeOptions) (_result *AttachDBInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstances)) {
		query["DBInstances"] = request.DBInstances
	}

	if !tea.BoolValue(util.IsUnset(request.ForceAttach)) {
		query["ForceAttach"] = request.ForceAttach
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachDBInstances"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachDBInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Associates one or more ApsaraDB RDS instances with a scaling group.
 *
 * @param request AttachDBInstancesRequest
 * @return AttachDBInstancesResponse
 */
func (client *Client) AttachDBInstances(request *AttachDBInstancesRequest) (_result *AttachDBInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachDBInstancesResponse{}
	_body, _err := client.AttachDBInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Manually adds Elastic Compute Service (ECS) instances or elastic container instances to a scaling group.
 *
 * @param request AttachInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachInstancesResponse
 */
func (client *Client) AttachInstancesWithOptions(request *AttachInstancesRequest, runtime *util.RuntimeOptions) (_result *AttachInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Entrusted)) {
		query["Entrusted"] = request.Entrusted
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleHook)) {
		query["LifecycleHook"] = request.LifecycleHook
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerWeights)) {
		query["LoadBalancerWeights"] = request.LoadBalancerWeights
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachInstances"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Manually adds Elastic Compute Service (ECS) instances or elastic container instances to a scaling group.
 *
 * @param request AttachInstancesRequest
 * @return AttachInstancesResponse
 */
func (client *Client) AttachInstances(request *AttachInstancesRequest) (_result *AttachInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachInstancesResponse{}
	_body, _err := client.AttachInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Attaches one or more Classic Load Balancer (CLB) instances to a scaling group.
 *
 * @param request AttachLoadBalancersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachLoadBalancersResponse
 */
func (client *Client) AttachLoadBalancersWithOptions(request *AttachLoadBalancersRequest, runtime *util.RuntimeOptions) (_result *AttachLoadBalancersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Async)) {
		query["Async"] = request.Async
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ForceAttach)) {
		query["ForceAttach"] = request.ForceAttach
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancers)) {
		query["LoadBalancers"] = request.LoadBalancers
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachLoadBalancers"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachLoadBalancersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Attaches one or more Classic Load Balancer (CLB) instances to a scaling group.
 *
 * @param request AttachLoadBalancersRequest
 * @return AttachLoadBalancersResponse
 */
func (client *Client) AttachLoadBalancers(request *AttachLoadBalancersRequest) (_result *AttachLoadBalancersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachLoadBalancersResponse{}
	_body, _err := client.AttachLoadBalancersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Attaches one or more vServer groups of a Classic Load Balancer (CLB) instance to a scaling group.
 *
 * @param request AttachVServerGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachVServerGroupsResponse
 */
func (client *Client) AttachVServerGroupsWithOptions(request *AttachVServerGroupsRequest, runtime *util.RuntimeOptions) (_result *AttachVServerGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ForceAttach)) {
		query["ForceAttach"] = request.ForceAttach
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroups)) {
		query["VServerGroups"] = request.VServerGroups
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachVServerGroups"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachVServerGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Attaches one or more vServer groups of a Classic Load Balancer (CLB) instance to a scaling group.
 *
 * @param request AttachVServerGroupsRequest
 * @return AttachVServerGroupsResponse
 */
func (client *Client) AttachVServerGroups(request *AttachVServerGroupsRequest) (_result *AttachVServerGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachVServerGroupsResponse{}
	_body, _err := client.AttachVServerGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ChangeResourceGroupWithOptions(request *ChangeResourceGroupRequest, runtime *util.RuntimeOptions) (_result *ChangeResourceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NewResourceGroupId)) {
		query["NewResourceGroupId"] = request.NewResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ChangeResourceGroup"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ChangeResourceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ChangeResourceGroup(request *ChangeResourceGroupRequest) (_result *ChangeResourceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ChangeResourceGroupResponse{}
	_body, _err := client.ChangeResourceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call this operation to end a lifecycle hook ahead of schedule, you can use the LifecycleActionResult parameter to specify the action that you want Auto Scaling to perform after the lifecycle hook ends. You can set the LifecycleActionResult parameter to CONTINUE or ABANDON.
 *
 * @param request CompleteLifecycleActionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CompleteLifecycleActionResponse
 */
func (client *Client) CompleteLifecycleActionWithOptions(request *CompleteLifecycleActionRequest, runtime *util.RuntimeOptions) (_result *CompleteLifecycleActionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleActionResult)) {
		query["LifecycleActionResult"] = request.LifecycleActionResult
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleActionToken)) {
		query["LifecycleActionToken"] = request.LifecycleActionToken
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleHookId)) {
		query["LifecycleHookId"] = request.LifecycleHookId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CompleteLifecycleAction"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CompleteLifecycleActionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call this operation to end a lifecycle hook ahead of schedule, you can use the LifecycleActionResult parameter to specify the action that you want Auto Scaling to perform after the lifecycle hook ends. You can set the LifecycleActionResult parameter to CONTINUE or ABANDON.
 *
 * @param request CompleteLifecycleActionRequest
 * @return CompleteLifecycleActionResponse
 */
func (client *Client) CompleteLifecycleAction(request *CompleteLifecycleActionRequest) (_result *CompleteLifecycleActionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CompleteLifecycleActionResponse{}
	_body, _err := client.CompleteLifecycleActionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If you set the MetricType parameter to custom, you must report your custom metrics to CloudMonitor before you can create event-triggered tasks by using custom metrics. For more information, see [Custom monitoring event-triggered tasks](~~74861~~).
 * *   When you create an event-triggered task, you must specify the MetricName, DimensionKey, and DimensionValue parameters to determine the range of statistics that you want to aggregate for the metrics of the scaling group. For example, you can specify the user_id and scaling_group dimensions for an event-triggered task to aggregate monitoring data of all Elastic Compute Service (ECS) instances or elastic container instances in a scaling group within an Alibaba Cloud account.
 *     *   If you set the MetricType parameter to custom, the valid values are your custom metrics.
 *     *   For information about the supported metrics when you set the MetricType parameter to system, see [Event-triggered task for system monitoring](~~74854~~).
 * > The user_id and scaling_group dimensions are automatically populated. You need to only specify the device and state dimensions. For more information, see the `DimensionKey` and `DimensionValue` parameters in the "Request parameters" section of this topic.
 *
 * @param request CreateAlarmRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAlarmResponse
 */
func (client *Client) CreateAlarmWithOptions(request *CreateAlarmRequest, runtime *util.RuntimeOptions) (_result *CreateAlarmResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlarmActions)) {
		query["AlarmActions"] = request.AlarmActions
	}

	if !tea.BoolValue(util.IsUnset(request.ComparisonOperator)) {
		query["ComparisonOperator"] = request.ComparisonOperator
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Dimensions)) {
		query["Dimensions"] = request.Dimensions
	}

	if !tea.BoolValue(util.IsUnset(request.Effective)) {
		query["Effective"] = request.Effective
	}

	if !tea.BoolValue(util.IsUnset(request.EvaluationCount)) {
		query["EvaluationCount"] = request.EvaluationCount
	}

	if !tea.BoolValue(util.IsUnset(request.Expressions)) {
		query["Expressions"] = request.Expressions
	}

	if !tea.BoolValue(util.IsUnset(request.ExpressionsLogicOperator)) {
		query["ExpressionsLogicOperator"] = request.ExpressionsLogicOperator
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.MetricName)) {
		query["MetricName"] = request.MetricName
	}

	if !tea.BoolValue(util.IsUnset(request.MetricType)) {
		query["MetricType"] = request.MetricType
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Statistics)) {
		query["Statistics"] = request.Statistics
	}

	if !tea.BoolValue(util.IsUnset(request.Threshold)) {
		query["Threshold"] = request.Threshold
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAlarm"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateAlarmResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If you set the MetricType parameter to custom, you must report your custom metrics to CloudMonitor before you can create event-triggered tasks by using custom metrics. For more information, see [Custom monitoring event-triggered tasks](~~74861~~).
 * *   When you create an event-triggered task, you must specify the MetricName, DimensionKey, and DimensionValue parameters to determine the range of statistics that you want to aggregate for the metrics of the scaling group. For example, you can specify the user_id and scaling_group dimensions for an event-triggered task to aggregate monitoring data of all Elastic Compute Service (ECS) instances or elastic container instances in a scaling group within an Alibaba Cloud account.
 *     *   If you set the MetricType parameter to custom, the valid values are your custom metrics.
 *     *   For information about the supported metrics when you set the MetricType parameter to system, see [Event-triggered task for system monitoring](~~74854~~).
 * > The user_id and scaling_group dimensions are automatically populated. You need to only specify the device and state dimensions. For more information, see the `DimensionKey` and `DimensionValue` parameters in the "Request parameters" section of this topic.
 *
 * @param request CreateAlarmRequest
 * @return CreateAlarmResponse
 */
func (client *Client) CreateAlarm(request *CreateAlarmRequest) (_result *CreateAlarmResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateAlarmResponse{}
	_body, _err := client.CreateAlarmWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * A scaling configuration is a template that is used to create elastic container instances during scale-out activities.
 * You can specify the Cpu and Memory parameters to determine the range of instance types. If you specify the parameters, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Auto Scaling preferentially creates elastic container instances of the instance type that is provided at the lowest price. This scaling mode is available only if Scaling Policy is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
 *
 * @param request CreateEciScalingConfigurationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEciScalingConfigurationResponse
 */
func (client *Client) CreateEciScalingConfigurationWithOptions(request *CreateEciScalingConfigurationRequest, runtime *util.RuntimeOptions) (_result *CreateEciScalingConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcrRegistryInfos)) {
		query["AcrRegistryInfos"] = request.AcrRegistryInfos
	}

	if !tea.BoolValue(util.IsUnset(request.ActiveDeadlineSeconds)) {
		query["ActiveDeadlineSeconds"] = request.ActiveDeadlineSeconds
	}

	if !tea.BoolValue(util.IsUnset(request.AutoCreateEip)) {
		query["AutoCreateEip"] = request.AutoCreateEip
	}

	if !tea.BoolValue(util.IsUnset(request.AutoMatchImageCache)) {
		query["AutoMatchImageCache"] = request.AutoMatchImageCache
	}

	if !tea.BoolValue(util.IsUnset(request.ContainerGroupName)) {
		query["ContainerGroupName"] = request.ContainerGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.Containers)) {
		query["Containers"] = request.Containers
	}

	if !tea.BoolValue(util.IsUnset(request.CostOptimization)) {
		query["CostOptimization"] = request.CostOptimization
	}

	if !tea.BoolValue(util.IsUnset(request.Cpu)) {
		query["Cpu"] = request.Cpu
	}

	if !tea.BoolValue(util.IsUnset(request.CpuOptionsCore)) {
		query["CpuOptionsCore"] = request.CpuOptionsCore
	}

	if !tea.BoolValue(util.IsUnset(request.CpuOptionsThreadsPerCore)) {
		query["CpuOptionsThreadsPerCore"] = request.CpuOptionsThreadsPerCore
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DnsConfigNameServers)) {
		query["DnsConfigNameServers"] = request.DnsConfigNameServers
	}

	if !tea.BoolValue(util.IsUnset(request.DnsConfigOptions)) {
		query["DnsConfigOptions"] = request.DnsConfigOptions
	}

	if !tea.BoolValue(util.IsUnset(request.DnsConfigSearchs)) {
		query["DnsConfigSearchs"] = request.DnsConfigSearchs
	}

	if !tea.BoolValue(util.IsUnset(request.DnsPolicy)) {
		query["DnsPolicy"] = request.DnsPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.EgressBandwidth)) {
		query["EgressBandwidth"] = request.EgressBandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.EipBandwidth)) {
		query["EipBandwidth"] = request.EipBandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.EnableSls)) {
		query["EnableSls"] = request.EnableSls
	}

	if !tea.BoolValue(util.IsUnset(request.EphemeralStorage)) {
		query["EphemeralStorage"] = request.EphemeralStorage
	}

	if !tea.BoolValue(util.IsUnset(request.HostAliases)) {
		query["HostAliases"] = request.HostAliases
	}

	if !tea.BoolValue(util.IsUnset(request.HostName)) {
		query["HostName"] = request.HostName
	}

	if !tea.BoolValue(util.IsUnset(request.ImageRegistryCredentials)) {
		query["ImageRegistryCredentials"] = request.ImageRegistryCredentials
	}

	if !tea.BoolValue(util.IsUnset(request.ImageSnapshotId)) {
		query["ImageSnapshotId"] = request.ImageSnapshotId
	}

	if !tea.BoolValue(util.IsUnset(request.IngressBandwidth)) {
		query["IngressBandwidth"] = request.IngressBandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.InitContainers)) {
		query["InitContainers"] = request.InitContainers
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceFamilyLevel)) {
		query["InstanceFamilyLevel"] = request.InstanceFamilyLevel
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6AddressCount)) {
		query["Ipv6AddressCount"] = request.Ipv6AddressCount
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerWeight)) {
		query["LoadBalancerWeight"] = request.LoadBalancerWeight
	}

	if !tea.BoolValue(util.IsUnset(request.Memory)) {
		query["Memory"] = request.Memory
	}

	if !tea.BoolValue(util.IsUnset(request.NtpServers)) {
		query["NtpServers"] = request.NtpServers
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RamRoleName)) {
		query["RamRoleName"] = request.RamRoleName
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.RestartPolicy)) {
		query["RestartPolicy"] = request.RestartPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationName)) {
		query["ScalingConfigurationName"] = request.ScalingConfigurationName
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityContextSysctls)) {
		query["SecurityContextSysctls"] = request.SecurityContextSysctls
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityGroupId)) {
		query["SecurityGroupId"] = request.SecurityGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SpotPriceLimit)) {
		query["SpotPriceLimit"] = request.SpotPriceLimit
	}

	if !tea.BoolValue(util.IsUnset(request.SpotStrategy)) {
		query["SpotStrategy"] = request.SpotStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.TerminationGracePeriodSeconds)) {
		query["TerminationGracePeriodSeconds"] = request.TerminationGracePeriodSeconds
	}

	if !tea.BoolValue(util.IsUnset(request.Volumes)) {
		query["Volumes"] = request.Volumes
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateEciScalingConfiguration"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateEciScalingConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * A scaling configuration is a template that is used to create elastic container instances during scale-out activities.
 * You can specify the Cpu and Memory parameters to determine the range of instance types. If you specify the parameters, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Auto Scaling preferentially creates elastic container instances of the instance type that is provided at the lowest price. This scaling mode is available only if Scaling Policy is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
 *
 * @param request CreateEciScalingConfigurationRequest
 * @return CreateEciScalingConfigurationResponse
 */
func (client *Client) CreateEciScalingConfiguration(request *CreateEciScalingConfigurationRequest) (_result *CreateEciScalingConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateEciScalingConfigurationResponse{}
	_body, _err := client.CreateEciScalingConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can create up to six lifecycle hooks for each scaling group. After a lifecycle hook is created for a scaling group, Elastic Compute Service (ECS) instances in the scaling group waits to be added to or removed from the scaling group during scaling activities. You can use the HeartbeatTimeout parameter to specify the timeout period of the lifecycle hook. During the timeout period of a lifecycle hook, you can perform custom operations such as initialize ECS instance configurations and download ECS instance data on the ECS instances for which the lifecycle hook is applied.
 * During a scale-out activity and the timeout period of a lifecycle hook, the private IP addresses of ECS instances wait to be added to the associated whitelist that manages access to the ApsaraDB RDS instance. The ECS instances also wait to be added to the backend server group of the associated Classic Load Balancer (CLB) instance. After the lifecycle hook times out, the private IP addresses of the ECS instances are added to the whitelist that manages access to the associated ApsaraDB RDS instance. The ECS instances are also added to the backend server group of the associated CLB instance. During a scale-in activity and the timeout period of a lifecycle hook, the private IP addresses of ECS instances wait to be removed from the whitelist that manages access to the associated ApsaraDB RDS instance. The ECS instances also wait to be removed from the backend server group of the associated CLB instance. After the lifecycle hook times out, the private IP addresses of the ECS instances are removed from the whitelist that manages access to the associated ApsaraDB RDS instance. The ECS instances are also removed from the backend server group of the associated CLB instance.
 * You can configure a notification method for a lifecycle hook. When the lifecycle hook is triggered, a notification can be sent to the specified Message Service (MNS) topic or queue, or an operation can be performed based on the specified Operation Orchestration Service (OOS) template. If you want to configure an OOS template, you must create a Resource Access Management (RAM) role for OOS. For more information, see [Grant RAM permissions to OOS](~~120810~~).
 * > If your scaling group has existing ECS instances and you configured an OOS template that is used to add the private IP addresses of ECS instances to or remove the private IP addresses of ECS instances from the whitelists that manage access to cloud databases that are not ApsaraDB RDS databases, you must manually add the private IP addresses of the ECS instances to or remove the private IP addresses of the ECS instances from the whitelists that manage access to the cloud databases.
 *
 * @param request CreateLifecycleHookRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLifecycleHookResponse
 */
func (client *Client) CreateLifecycleHookWithOptions(request *CreateLifecycleHookRequest, runtime *util.RuntimeOptions) (_result *CreateLifecycleHookResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DefaultResult)) {
		query["DefaultResult"] = request.DefaultResult
	}

	if !tea.BoolValue(util.IsUnset(request.HeartbeatTimeout)) {
		query["HeartbeatTimeout"] = request.HeartbeatTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleHookName)) {
		query["LifecycleHookName"] = request.LifecycleHookName
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleTransition)) {
		query["LifecycleTransition"] = request.LifecycleTransition
	}

	if !tea.BoolValue(util.IsUnset(request.NotificationArn)) {
		query["NotificationArn"] = request.NotificationArn
	}

	if !tea.BoolValue(util.IsUnset(request.NotificationMetadata)) {
		query["NotificationMetadata"] = request.NotificationMetadata
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateLifecycleHook"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateLifecycleHookResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can create up to six lifecycle hooks for each scaling group. After a lifecycle hook is created for a scaling group, Elastic Compute Service (ECS) instances in the scaling group waits to be added to or removed from the scaling group during scaling activities. You can use the HeartbeatTimeout parameter to specify the timeout period of the lifecycle hook. During the timeout period of a lifecycle hook, you can perform custom operations such as initialize ECS instance configurations and download ECS instance data on the ECS instances for which the lifecycle hook is applied.
 * During a scale-out activity and the timeout period of a lifecycle hook, the private IP addresses of ECS instances wait to be added to the associated whitelist that manages access to the ApsaraDB RDS instance. The ECS instances also wait to be added to the backend server group of the associated Classic Load Balancer (CLB) instance. After the lifecycle hook times out, the private IP addresses of the ECS instances are added to the whitelist that manages access to the associated ApsaraDB RDS instance. The ECS instances are also added to the backend server group of the associated CLB instance. During a scale-in activity and the timeout period of a lifecycle hook, the private IP addresses of ECS instances wait to be removed from the whitelist that manages access to the associated ApsaraDB RDS instance. The ECS instances also wait to be removed from the backend server group of the associated CLB instance. After the lifecycle hook times out, the private IP addresses of the ECS instances are removed from the whitelist that manages access to the associated ApsaraDB RDS instance. The ECS instances are also removed from the backend server group of the associated CLB instance.
 * You can configure a notification method for a lifecycle hook. When the lifecycle hook is triggered, a notification can be sent to the specified Message Service (MNS) topic or queue, or an operation can be performed based on the specified Operation Orchestration Service (OOS) template. If you want to configure an OOS template, you must create a Resource Access Management (RAM) role for OOS. For more information, see [Grant RAM permissions to OOS](~~120810~~).
 * > If your scaling group has existing ECS instances and you configured an OOS template that is used to add the private IP addresses of ECS instances to or remove the private IP addresses of ECS instances from the whitelists that manage access to cloud databases that are not ApsaraDB RDS databases, you must manually add the private IP addresses of the ECS instances to or remove the private IP addresses of the ECS instances from the whitelists that manage access to the cloud databases.
 *
 * @param request CreateLifecycleHookRequest
 * @return CreateLifecycleHookResponse
 */
func (client *Client) CreateLifecycleHook(request *CreateLifecycleHookRequest) (_result *CreateLifecycleHookResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateLifecycleHookResponse{}
	_body, _err := client.CreateLifecycleHookWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Creates a notification.
 *
 * @param request CreateNotificationConfigurationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateNotificationConfigurationResponse
 */
func (client *Client) CreateNotificationConfigurationWithOptions(request *CreateNotificationConfigurationRequest, runtime *util.RuntimeOptions) (_result *CreateNotificationConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NotificationArn)) {
		query["NotificationArn"] = request.NotificationArn
	}

	if !tea.BoolValue(util.IsUnset(request.NotificationTypes)) {
		query["NotificationTypes"] = request.NotificationTypes
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateNotificationConfiguration"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateNotificationConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Creates a notification.
 *
 * @param request CreateNotificationConfigurationRequest
 * @return CreateNotificationConfigurationResponse
 */
func (client *Client) CreateNotificationConfiguration(request *CreateNotificationConfigurationRequest) (_result *CreateNotificationConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateNotificationConfigurationResponse{}
	_body, _err := client.CreateNotificationConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Auto Scaling automatically scales out Elastic Compute Service (ECS) instances based on the specified scaling configuration. ECS instances can be configured in the following modes:
 * *   InstancePatternInfo.N: intelligent configuration mode. In this mode, you need to only specify the number of vCPUs, memory size, instance family, and maximum price. The system selects an instance type that is provided at the lowest price based on your configurations to create ECS instances. This mode is available only for scaling groups that reside in virtual private clouds (VPCs). This mode helps reduce the failures of scale-out activities caused by insufficient inventory of instance types.
 * *   InstanceType: In this mode, you must specify one instance type.
 * *   InstanceTypes.N: In this mode, you must specify multiple instance types.
 * *   InstanceTypeOverride.N: In this mode, you must specify multiple instance types and specify weights for the instance types.
 * *   Cpu and Memory: In this mode, you must specify the number of vCPUs and the memory size. Auto Scaling determines a set of available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates ECS instances of the instance type that is provided at the lowest price. This mode is available only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
 * > You cannot use InstanceType, InstanceTypes, InstanceTypeOverride, and Cpu and Memory at the same time. You can use InstanceType and InstancePatternInfos or use InstanceTypes and InstancePatternInfos at the same time. If you use InstanceType and InstancePatternInfos or use InstanceTypes and InstancePatternInfos at the same time, Auto Scaling preferentially uses the instance types that are specified by InstanceType or InstanceTypes for scale-out activities. If the instance types that are specified by InstanceType or InstanceTypes do not have sufficient inventory, Auto Scaling uses the instance types that are specified by InstancePatternInfos for scale-out activities.
 *
 * @param tmpReq CreateScalingConfigurationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateScalingConfigurationResponse
 */
func (client *Client) CreateScalingConfigurationWithOptions(tmpReq *CreateScalingConfigurationRequest, runtime *util.RuntimeOptions) (_result *CreateScalingConfigurationResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateScalingConfigurationShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.SchedulerOptions)) {
		request.SchedulerOptionsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.SchedulerOptions, tea.String("SchedulerOptions"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Affinity)) {
		query["Affinity"] = request.Affinity
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Cpu)) {
		query["Cpu"] = request.Cpu
	}

	if !tea.BoolValue(util.IsUnset(request.CreditSpecification)) {
		query["CreditSpecification"] = request.CreditSpecification
	}

	if !tea.BoolValue(util.IsUnset(request.DataDisks)) {
		query["DataDisks"] = request.DataDisks
	}

	if !tea.BoolValue(util.IsUnset(request.DedicatedHostId)) {
		query["DedicatedHostId"] = request.DedicatedHostId
	}

	if !tea.BoolValue(util.IsUnset(request.DeploymentSetId)) {
		query["DeploymentSetId"] = request.DeploymentSetId
	}

	if !tea.BoolValue(util.IsUnset(request.HostName)) {
		query["HostName"] = request.HostName
	}

	if !tea.BoolValue(util.IsUnset(request.HpcClusterId)) {
		query["HpcClusterId"] = request.HpcClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ImageFamily)) {
		query["ImageFamily"] = request.ImageFamily
	}

	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.ImageName)) {
		query["ImageName"] = request.ImageName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceDescription)) {
		query["InstanceDescription"] = request.InstanceDescription
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceName)) {
		query["InstanceName"] = request.InstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.InstancePatternInfos)) {
		query["InstancePatternInfos"] = request.InstancePatternInfos
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceTypeOverrides)) {
		query["InstanceTypeOverrides"] = request.InstanceTypeOverrides
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceTypes)) {
		query["InstanceTypes"] = request.InstanceTypes
	}

	if !tea.BoolValue(util.IsUnset(request.InternetChargeType)) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.InternetMaxBandwidthIn)) {
		query["InternetMaxBandwidthIn"] = request.InternetMaxBandwidthIn
	}

	if !tea.BoolValue(util.IsUnset(request.InternetMaxBandwidthOut)) {
		query["InternetMaxBandwidthOut"] = request.InternetMaxBandwidthOut
	}

	if !tea.BoolValue(util.IsUnset(request.IoOptimized)) {
		query["IoOptimized"] = request.IoOptimized
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6AddressCount)) {
		query["Ipv6AddressCount"] = request.Ipv6AddressCount
	}

	if !tea.BoolValue(util.IsUnset(request.KeyPairName)) {
		query["KeyPairName"] = request.KeyPairName
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerWeight)) {
		query["LoadBalancerWeight"] = request.LoadBalancerWeight
	}

	if !tea.BoolValue(util.IsUnset(request.Memory)) {
		query["Memory"] = request.Memory
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Password)) {
		query["Password"] = request.Password
	}

	if !tea.BoolValue(util.IsUnset(request.PasswordInherit)) {
		query["PasswordInherit"] = request.PasswordInherit
	}

	if !tea.BoolValue(util.IsUnset(request.RamRoleName)) {
		query["RamRoleName"] = request.RamRoleName
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationName)) {
		query["ScalingConfigurationName"] = request.ScalingConfigurationName
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SchedulerOptionsShrink)) {
		query["SchedulerOptions"] = request.SchedulerOptionsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityEnhancementStrategy)) {
		query["SecurityEnhancementStrategy"] = request.SecurityEnhancementStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityGroupId)) {
		query["SecurityGroupId"] = request.SecurityGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityGroupIds)) {
		query["SecurityGroupIds"] = request.SecurityGroupIds
	}

	if !tea.BoolValue(util.IsUnset(request.SpotDuration)) {
		query["SpotDuration"] = request.SpotDuration
	}

	if !tea.BoolValue(util.IsUnset(request.SpotInterruptionBehavior)) {
		query["SpotInterruptionBehavior"] = request.SpotInterruptionBehavior
	}

	if !tea.BoolValue(util.IsUnset(request.SpotPriceLimits)) {
		query["SpotPriceLimits"] = request.SpotPriceLimits
	}

	if !tea.BoolValue(util.IsUnset(request.SpotStrategy)) {
		query["SpotStrategy"] = request.SpotStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.SystemDiskCategories)) {
		query["SystemDiskCategories"] = request.SystemDiskCategories
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.Tenancy)) {
		query["Tenancy"] = request.Tenancy
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	if !tea.BoolValue(util.IsUnset(request.PrivatePoolOptions)) {
		query["PrivatePoolOptions"] = request.PrivatePoolOptions
	}

	if !tea.BoolValue(util.IsUnset(request.SystemDisk)) {
		query["SystemDisk"] = request.SystemDisk
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateScalingConfiguration"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateScalingConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Auto Scaling automatically scales out Elastic Compute Service (ECS) instances based on the specified scaling configuration. ECS instances can be configured in the following modes:
 * *   InstancePatternInfo.N: intelligent configuration mode. In this mode, you need to only specify the number of vCPUs, memory size, instance family, and maximum price. The system selects an instance type that is provided at the lowest price based on your configurations to create ECS instances. This mode is available only for scaling groups that reside in virtual private clouds (VPCs). This mode helps reduce the failures of scale-out activities caused by insufficient inventory of instance types.
 * *   InstanceType: In this mode, you must specify one instance type.
 * *   InstanceTypes.N: In this mode, you must specify multiple instance types.
 * *   InstanceTypeOverride.N: In this mode, you must specify multiple instance types and specify weights for the instance types.
 * *   Cpu and Memory: In this mode, you must specify the number of vCPUs and the memory size. Auto Scaling determines a set of available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates ECS instances of the instance type that is provided at the lowest price. This mode is available only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
 * > You cannot use InstanceType, InstanceTypes, InstanceTypeOverride, and Cpu and Memory at the same time. You can use InstanceType and InstancePatternInfos or use InstanceTypes and InstancePatternInfos at the same time. If you use InstanceType and InstancePatternInfos or use InstanceTypes and InstancePatternInfos at the same time, Auto Scaling preferentially uses the instance types that are specified by InstanceType or InstanceTypes for scale-out activities. If the instance types that are specified by InstanceType or InstanceTypes do not have sufficient inventory, Auto Scaling uses the instance types that are specified by InstancePatternInfos for scale-out activities.
 *
 * @param request CreateScalingConfigurationRequest
 * @return CreateScalingConfigurationResponse
 */
func (client *Client) CreateScalingConfiguration(request *CreateScalingConfigurationRequest) (_result *CreateScalingConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateScalingConfigurationResponse{}
	_body, _err := client.CreateScalingConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * A scaling group is a group of Elastic Compute Service (ECS) instances that can be used in similar business scenarios.
 * You can create only a limited number of scaling groups in a region. Go to Quota Center to check the quota of the scaling groups.
 * A scaling group does not immediately take effect after you create the scaling group. You must call the EnableScalingGroup operation to enable the scaling group. After you enable the scaling group, Auto Scaling can execute scaling rules to trigger scaling activities in the scaling group.
 * The Classic Load Balancer (CLB) instances and ApsaraDB RDS instances must reside in the same region as the scaling group with which you want to associate the instances. CLB instances are formerly known as Server Load Balancer (SLB) instances. For more information, see the "Regions and zones" topic in ECS Product Introduction.
 * If you associate a CLB instance when you create a scaling group, Auto Scaling automatically adds ECS instances in the scaling group to the backend server group of the associated CLB instance. You can specify a server group to which ECS instances are to be added. You can add ECS instances to the following types of server groups:
 * *   Default server group: a group of ECS instances that are used to receive requests. If you do not specify a vServer group or a primary/secondary server group for a listener, requests are forwarded to the ECS instances in the default server group.
 * *   vServer group: If you want to forward requests to backend servers that are not in the default server group or configure domain name-based or URL-based forwarding rules, you can use vServer groups.
 * > If you specify the default server group and multiple vServer groups at the same time, ECS instances are added to all specified server groups.
 * The default weight of an ECS instance that is added as a backend server of a CLB instance is 50. The CLB instance that you want to associate with your scaling group must meet the following requirements:
 * *   The CLB instance must be in the Active state. You can call the DescribeLoadBalancers operation to query the state of the specified CLB instance.
 * *   The health check feature must be enabled on all listener ports that are configured for the CLB instance. Otherwise, the scaling group fails to be created.
 * If you have associated an Application Load Balancer (ALB) server group with a scaling group, Auto Scaling automatically adds ECS instances in the scaling group to the ALB server group to process requests distributed by the ALB instance to which the ALB server group belongs. You can specify multiple ALB server groups. The server groups must belong to the same virtual private cloud (VPC) as the scaling group. For more information, see the AttachAlbServerGroups topic.
 * If you associated an ApsaraDB RDS instance when you created a scaling group, Auto Scaling automatically adds the private IP addresses of the ECS instances in the scaling group to the IP whitelist that manages access to the associated ApsaraDB RDS instance. The ApsaraDB RDS instance that you want to associate with your scaling group must meet the following requirements:
 * *   The ApsaraDB RDS instance must be in the Running state. You can call the DescribeDBInstances operation to query the state of the specified ApsaraDB RDS instance.
 * *   The number of IP addresses in the IP whitelist that manages access to the ApsaraDB RDS instance cannot exceed the upper limit. For more information, see the Configure whitelists topic in ApsaraDB RDS User Guide.
 * If the MultiAZPolicy parameter of the scaling group is set to COST_OPTIMIZED, the following rules apply:
 * *   You can use the OnDemandBaseCapacity, OnDemandPercentageAboveBaseCapacity, and SpotInstancePools parameters to specify an instance allocation method based on the cost optimization policy. The specified instance allocation method is prioritized during scaling.
 * *   If you do not specify the OnDemandBaseCapacity, OnDemandPercentageAboveBaseCapacity, or SpotInstancePools parameter, the instance types that are provided at the lowest price are used to create instances based on the cost optimization policy.
 * If you set the `Tag.N.Propagate` parameter for the scaling group to true, tags that you add to the scaling group are propagated to new instances.
 * *   Tags that you add to the scaling group cannot be propagated to existing instances in the scaling group.
 * *   If you specify instance tags in the scaling configuration that is used to create instances, and propagate the tags that you add to the scaling group to the instances, all tags exist at the same time.
 * *   If you specify the same tag key for a scaling configuration and a scaling group that uses the scaling configuration, the tag value in the scaling configuration is used.
 *
 * @param request CreateScalingGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateScalingGroupResponse
 */
func (client *Client) CreateScalingGroupWithOptions(request *CreateScalingGroupRequest, runtime *util.RuntimeOptions) (_result *CreateScalingGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlbServerGroups)) {
		query["AlbServerGroups"] = request.AlbServerGroups
	}

	if !tea.BoolValue(util.IsUnset(request.AllocationStrategy)) {
		query["AllocationStrategy"] = request.AllocationStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.AzBalance)) {
		query["AzBalance"] = request.AzBalance
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CompensateWithOnDemand)) {
		query["CompensateWithOnDemand"] = request.CompensateWithOnDemand
	}

	if !tea.BoolValue(util.IsUnset(request.ContainerGroupId)) {
		query["ContainerGroupId"] = request.ContainerGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.CustomPolicyARN)) {
		query["CustomPolicyARN"] = request.CustomPolicyARN
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstanceIds)) {
		query["DBInstanceIds"] = request.DBInstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.DefaultCooldown)) {
		query["DefaultCooldown"] = request.DefaultCooldown
	}

	if !tea.BoolValue(util.IsUnset(request.DesiredCapacity)) {
		query["DesiredCapacity"] = request.DesiredCapacity
	}

	if !tea.BoolValue(util.IsUnset(request.GroupDeletionProtection)) {
		query["GroupDeletionProtection"] = request.GroupDeletionProtection
	}

	if !tea.BoolValue(util.IsUnset(request.GroupType)) {
		query["GroupType"] = request.GroupType
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckType)) {
		query["HealthCheckType"] = request.HealthCheckType
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchTemplateId)) {
		query["LaunchTemplateId"] = request.LaunchTemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchTemplateOverrides)) {
		query["LaunchTemplateOverrides"] = request.LaunchTemplateOverrides
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchTemplateVersion)) {
		query["LaunchTemplateVersion"] = request.LaunchTemplateVersion
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleHooks)) {
		query["LifecycleHooks"] = request.LifecycleHooks
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerIds)) {
		query["LoadBalancerIds"] = request.LoadBalancerIds
	}

	if !tea.BoolValue(util.IsUnset(request.MaxInstanceLifetime)) {
		query["MaxInstanceLifetime"] = request.MaxInstanceLifetime
	}

	if !tea.BoolValue(util.IsUnset(request.MaxSize)) {
		query["MaxSize"] = request.MaxSize
	}

	if !tea.BoolValue(util.IsUnset(request.MinSize)) {
		query["MinSize"] = request.MinSize
	}

	if !tea.BoolValue(util.IsUnset(request.MultiAZPolicy)) {
		query["MultiAZPolicy"] = request.MultiAZPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.OnDemandBaseCapacity)) {
		query["OnDemandBaseCapacity"] = request.OnDemandBaseCapacity
	}

	if !tea.BoolValue(util.IsUnset(request.OnDemandPercentageAboveBaseCapacity)) {
		query["OnDemandPercentageAboveBaseCapacity"] = request.OnDemandPercentageAboveBaseCapacity
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RemovalPolicies)) {
		query["RemovalPolicies"] = request.RemovalPolicies
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupName)) {
		query["ScalingGroupName"] = request.ScalingGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingPolicy)) {
		query["ScalingPolicy"] = request.ScalingPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.SpotAllocationStrategy)) {
		query["SpotAllocationStrategy"] = request.SpotAllocationStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.SpotInstancePools)) {
		query["SpotInstancePools"] = request.SpotInstancePools
	}

	if !tea.BoolValue(util.IsUnset(request.SpotInstanceRemedy)) {
		query["SpotInstanceRemedy"] = request.SpotInstanceRemedy
	}

	if !tea.BoolValue(util.IsUnset(request.SyncAlarmRuleToCms)) {
		query["SyncAlarmRuleToCms"] = request.SyncAlarmRuleToCms
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroups)) {
		query["VServerGroups"] = request.VServerGroups
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchIds)) {
		query["VSwitchIds"] = request.VSwitchIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateScalingGroup"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateScalingGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * A scaling group is a group of Elastic Compute Service (ECS) instances that can be used in similar business scenarios.
 * You can create only a limited number of scaling groups in a region. Go to Quota Center to check the quota of the scaling groups.
 * A scaling group does not immediately take effect after you create the scaling group. You must call the EnableScalingGroup operation to enable the scaling group. After you enable the scaling group, Auto Scaling can execute scaling rules to trigger scaling activities in the scaling group.
 * The Classic Load Balancer (CLB) instances and ApsaraDB RDS instances must reside in the same region as the scaling group with which you want to associate the instances. CLB instances are formerly known as Server Load Balancer (SLB) instances. For more information, see the "Regions and zones" topic in ECS Product Introduction.
 * If you associate a CLB instance when you create a scaling group, Auto Scaling automatically adds ECS instances in the scaling group to the backend server group of the associated CLB instance. You can specify a server group to which ECS instances are to be added. You can add ECS instances to the following types of server groups:
 * *   Default server group: a group of ECS instances that are used to receive requests. If you do not specify a vServer group or a primary/secondary server group for a listener, requests are forwarded to the ECS instances in the default server group.
 * *   vServer group: If you want to forward requests to backend servers that are not in the default server group or configure domain name-based or URL-based forwarding rules, you can use vServer groups.
 * > If you specify the default server group and multiple vServer groups at the same time, ECS instances are added to all specified server groups.
 * The default weight of an ECS instance that is added as a backend server of a CLB instance is 50. The CLB instance that you want to associate with your scaling group must meet the following requirements:
 * *   The CLB instance must be in the Active state. You can call the DescribeLoadBalancers operation to query the state of the specified CLB instance.
 * *   The health check feature must be enabled on all listener ports that are configured for the CLB instance. Otherwise, the scaling group fails to be created.
 * If you have associated an Application Load Balancer (ALB) server group with a scaling group, Auto Scaling automatically adds ECS instances in the scaling group to the ALB server group to process requests distributed by the ALB instance to which the ALB server group belongs. You can specify multiple ALB server groups. The server groups must belong to the same virtual private cloud (VPC) as the scaling group. For more information, see the AttachAlbServerGroups topic.
 * If you associated an ApsaraDB RDS instance when you created a scaling group, Auto Scaling automatically adds the private IP addresses of the ECS instances in the scaling group to the IP whitelist that manages access to the associated ApsaraDB RDS instance. The ApsaraDB RDS instance that you want to associate with your scaling group must meet the following requirements:
 * *   The ApsaraDB RDS instance must be in the Running state. You can call the DescribeDBInstances operation to query the state of the specified ApsaraDB RDS instance.
 * *   The number of IP addresses in the IP whitelist that manages access to the ApsaraDB RDS instance cannot exceed the upper limit. For more information, see the Configure whitelists topic in ApsaraDB RDS User Guide.
 * If the MultiAZPolicy parameter of the scaling group is set to COST_OPTIMIZED, the following rules apply:
 * *   You can use the OnDemandBaseCapacity, OnDemandPercentageAboveBaseCapacity, and SpotInstancePools parameters to specify an instance allocation method based on the cost optimization policy. The specified instance allocation method is prioritized during scaling.
 * *   If you do not specify the OnDemandBaseCapacity, OnDemandPercentageAboveBaseCapacity, or SpotInstancePools parameter, the instance types that are provided at the lowest price are used to create instances based on the cost optimization policy.
 * If you set the `Tag.N.Propagate` parameter for the scaling group to true, tags that you add to the scaling group are propagated to new instances.
 * *   Tags that you add to the scaling group cannot be propagated to existing instances in the scaling group.
 * *   If you specify instance tags in the scaling configuration that is used to create instances, and propagate the tags that you add to the scaling group to the instances, all tags exist at the same time.
 * *   If you specify the same tag key for a scaling configuration and a scaling group that uses the scaling configuration, the tag value in the scaling configuration is used.
 *
 * @param request CreateScalingGroupRequest
 * @return CreateScalingGroupResponse
 */
func (client *Client) CreateScalingGroup(request *CreateScalingGroupRequest) (_result *CreateScalingGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateScalingGroupResponse{}
	_body, _err := client.CreateScalingGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Creates a scaling rule.
 *
 * @param request CreateScalingRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateScalingRuleResponse
 */
func (client *Client) CreateScalingRuleWithOptions(request *CreateScalingRuleRequest, runtime *util.RuntimeOptions) (_result *CreateScalingRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AdjustmentType)) {
		query["AdjustmentType"] = request.AdjustmentType
	}

	if !tea.BoolValue(util.IsUnset(request.AdjustmentValue)) {
		query["AdjustmentValue"] = request.AdjustmentValue
	}

	if !tea.BoolValue(util.IsUnset(request.Cooldown)) {
		query["Cooldown"] = request.Cooldown
	}

	if !tea.BoolValue(util.IsUnset(request.DisableScaleIn)) {
		query["DisableScaleIn"] = request.DisableScaleIn
	}

	if !tea.BoolValue(util.IsUnset(request.EstimatedInstanceWarmup)) {
		query["EstimatedInstanceWarmup"] = request.EstimatedInstanceWarmup
	}

	if !tea.BoolValue(util.IsUnset(request.InitialMaxSize)) {
		query["InitialMaxSize"] = request.InitialMaxSize
	}

	if !tea.BoolValue(util.IsUnset(request.MetricName)) {
		query["MetricName"] = request.MetricName
	}

	if !tea.BoolValue(util.IsUnset(request.MinAdjustmentMagnitude)) {
		query["MinAdjustmentMagnitude"] = request.MinAdjustmentMagnitude
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PredictiveScalingMode)) {
		query["PredictiveScalingMode"] = request.PredictiveScalingMode
	}

	if !tea.BoolValue(util.IsUnset(request.PredictiveTaskBufferTime)) {
		query["PredictiveTaskBufferTime"] = request.PredictiveTaskBufferTime
	}

	if !tea.BoolValue(util.IsUnset(request.PredictiveValueBehavior)) {
		query["PredictiveValueBehavior"] = request.PredictiveValueBehavior
	}

	if !tea.BoolValue(util.IsUnset(request.PredictiveValueBuffer)) {
		query["PredictiveValueBuffer"] = request.PredictiveValueBuffer
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScaleInEvaluationCount)) {
		query["ScaleInEvaluationCount"] = request.ScaleInEvaluationCount
	}

	if !tea.BoolValue(util.IsUnset(request.ScaleOutEvaluationCount)) {
		query["ScaleOutEvaluationCount"] = request.ScaleOutEvaluationCount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleName)) {
		query["ScalingRuleName"] = request.ScalingRuleName
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleType)) {
		query["ScalingRuleType"] = request.ScalingRuleType
	}

	if !tea.BoolValue(util.IsUnset(request.StepAdjustments)) {
		query["StepAdjustments"] = request.StepAdjustments
	}

	if !tea.BoolValue(util.IsUnset(request.TargetValue)) {
		query["TargetValue"] = request.TargetValue
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateScalingRule"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateScalingRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Creates a scaling rule.
 *
 * @param request CreateScalingRuleRequest
 * @return CreateScalingRuleResponse
 */
func (client *Client) CreateScalingRule(request *CreateScalingRuleRequest) (_result *CreateScalingRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateScalingRuleResponse{}
	_body, _err := client.CreateScalingRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Creates a scheduled task.
 *
 * @param request CreateScheduledTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateScheduledTaskResponse
 */
func (client *Client) CreateScheduledTaskWithOptions(request *CreateScheduledTaskRequest, runtime *util.RuntimeOptions) (_result *CreateScheduledTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DesiredCapacity)) {
		query["DesiredCapacity"] = request.DesiredCapacity
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchExpirationTime)) {
		query["LaunchExpirationTime"] = request.LaunchExpirationTime
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchTime)) {
		query["LaunchTime"] = request.LaunchTime
	}

	if !tea.BoolValue(util.IsUnset(request.MaxValue)) {
		query["MaxValue"] = request.MaxValue
	}

	if !tea.BoolValue(util.IsUnset(request.MinValue)) {
		query["MinValue"] = request.MinValue
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RecurrenceEndTime)) {
		query["RecurrenceEndTime"] = request.RecurrenceEndTime
	}

	if !tea.BoolValue(util.IsUnset(request.RecurrenceType)) {
		query["RecurrenceType"] = request.RecurrenceType
	}

	if !tea.BoolValue(util.IsUnset(request.RecurrenceValue)) {
		query["RecurrenceValue"] = request.RecurrenceValue
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduledAction)) {
		query["ScheduledAction"] = request.ScheduledAction
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduledTaskName)) {
		query["ScheduledTaskName"] = request.ScheduledTaskName
	}

	if !tea.BoolValue(util.IsUnset(request.TaskEnabled)) {
		query["TaskEnabled"] = request.TaskEnabled
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateScheduledTask"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateScheduledTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Creates a scheduled task.
 *
 * @param request CreateScheduledTaskRequest
 * @return CreateScheduledTaskResponse
 */
func (client *Client) CreateScheduledTask(request *CreateScheduledTaskRequest) (_result *CreateScheduledTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateScheduledTaskResponse{}
	_body, _err := client.CreateScheduledTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeactivateScalingConfigurationWithOptions(request *DeactivateScalingConfigurationRequest, runtime *util.RuntimeOptions) (_result *DeactivateScalingConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationId)) {
		query["ScalingConfigurationId"] = request.ScalingConfigurationId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeactivateScalingConfiguration"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeactivateScalingConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeactivateScalingConfiguration(request *DeactivateScalingConfigurationRequest) (_result *DeactivateScalingConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeactivateScalingConfigurationResponse{}
	_body, _err := client.DeactivateScalingConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteAlarmWithOptions(request *DeleteAlarmRequest, runtime *util.RuntimeOptions) (_result *DeleteAlarmResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlarmTaskId)) {
		query["AlarmTaskId"] = request.AlarmTaskId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAlarm"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAlarmResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteAlarm(request *DeleteAlarmRequest) (_result *DeleteAlarmResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAlarmResponse{}
	_body, _err := client.DeleteAlarmWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Deletes a scaling configuration that is used to create elastic container instances.
 *
 * @param request DeleteEciScalingConfigurationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteEciScalingConfigurationResponse
 */
func (client *Client) DeleteEciScalingConfigurationWithOptions(request *DeleteEciScalingConfigurationRequest, runtime *util.RuntimeOptions) (_result *DeleteEciScalingConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationId)) {
		query["ScalingConfigurationId"] = request.ScalingConfigurationId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteEciScalingConfiguration"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteEciScalingConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Deletes a scaling configuration that is used to create elastic container instances.
 *
 * @param request DeleteEciScalingConfigurationRequest
 * @return DeleteEciScalingConfigurationResponse
 */
func (client *Client) DeleteEciScalingConfiguration(request *DeleteEciScalingConfigurationRequest) (_result *DeleteEciScalingConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteEciScalingConfigurationResponse{}
	_body, _err := client.DeleteEciScalingConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If you delete a lifecycle hook that is in effect in a scaling group, instances exit the Pending state in advance. You can use one of the following methods to specify the lifecycle hooks that you want to delete:
 * *   Specify the scaling group ID of the lifecycle hook that you want to delete by using the ScalingGroupId parameter and the lifecycle hook name by using the LifecycleHookName parameter.
 * *   Specify the lifecycle hook ID by using the LifecycleHookId parameter. In this case, the ScalingGroupId parameter and the LifecycleHookName parameter are ignored.
 *
 * @param request DeleteLifecycleHookRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteLifecycleHookResponse
 */
func (client *Client) DeleteLifecycleHookWithOptions(request *DeleteLifecycleHookRequest, runtime *util.RuntimeOptions) (_result *DeleteLifecycleHookResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LifecycleHookId)) {
		query["LifecycleHookId"] = request.LifecycleHookId
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleHookName)) {
		query["LifecycleHookName"] = request.LifecycleHookName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteLifecycleHook"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteLifecycleHookResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If you delete a lifecycle hook that is in effect in a scaling group, instances exit the Pending state in advance. You can use one of the following methods to specify the lifecycle hooks that you want to delete:
 * *   Specify the scaling group ID of the lifecycle hook that you want to delete by using the ScalingGroupId parameter and the lifecycle hook name by using the LifecycleHookName parameter.
 * *   Specify the lifecycle hook ID by using the LifecycleHookId parameter. In this case, the ScalingGroupId parameter and the LifecycleHookName parameter are ignored.
 *
 * @param request DeleteLifecycleHookRequest
 * @return DeleteLifecycleHookResponse
 */
func (client *Client) DeleteLifecycleHook(request *DeleteLifecycleHookRequest) (_result *DeleteLifecycleHookResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteLifecycleHookResponse{}
	_body, _err := client.DeleteLifecycleHookWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteNotificationConfigurationWithOptions(request *DeleteNotificationConfigurationRequest, runtime *util.RuntimeOptions) (_result *DeleteNotificationConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NotificationArn)) {
		query["NotificationArn"] = request.NotificationArn
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteNotificationConfiguration"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteNotificationConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteNotificationConfiguration(request *DeleteNotificationConfigurationRequest) (_result *DeleteNotificationConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteNotificationConfigurationResponse{}
	_body, _err := client.DeleteNotificationConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Deletes a scaling configuration that is used to create Elastic Compute Service (ECS) instances.
 *
 * @param request DeleteScalingConfigurationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteScalingConfigurationResponse
 */
func (client *Client) DeleteScalingConfigurationWithOptions(request *DeleteScalingConfigurationRequest, runtime *util.RuntimeOptions) (_result *DeleteScalingConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationId)) {
		query["ScalingConfigurationId"] = request.ScalingConfigurationId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteScalingConfiguration"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteScalingConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Deletes a scaling configuration that is used to create Elastic Compute Service (ECS) instances.
 *
 * @param request DeleteScalingConfigurationRequest
 * @return DeleteScalingConfigurationResponse
 */
func (client *Client) DeleteScalingConfiguration(request *DeleteScalingConfigurationRequest) (_result *DeleteScalingConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteScalingConfigurationResponse{}
	_body, _err := client.DeleteScalingConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Deletes a scaling group.
 *
 * @param request DeleteScalingGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteScalingGroupResponse
 */
func (client *Client) DeleteScalingGroupWithOptions(request *DeleteScalingGroupRequest, runtime *util.RuntimeOptions) (_result *DeleteScalingGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ForceDelete)) {
		query["ForceDelete"] = request.ForceDelete
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteScalingGroup"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteScalingGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Deletes a scaling group.
 *
 * @param request DeleteScalingGroupRequest
 * @return DeleteScalingGroupResponse
 */
func (client *Client) DeleteScalingGroup(request *DeleteScalingGroupRequest) (_result *DeleteScalingGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteScalingGroupResponse{}
	_body, _err := client.DeleteScalingGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteScalingRuleWithOptions(request *DeleteScalingRuleRequest, runtime *util.RuntimeOptions) (_result *DeleteScalingRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleId)) {
		query["ScalingRuleId"] = request.ScalingRuleId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteScalingRule"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteScalingRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteScalingRule(request *DeleteScalingRuleRequest) (_result *DeleteScalingRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteScalingRuleResponse{}
	_body, _err := client.DeleteScalingRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteScheduledTaskWithOptions(request *DeleteScheduledTaskRequest, runtime *util.RuntimeOptions) (_result *DeleteScheduledTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduledTaskId)) {
		query["ScheduledTaskId"] = request.ScheduledTaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteScheduledTask"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteScheduledTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteScheduledTask(request *DeleteScheduledTaskRequest) (_result *DeleteScheduledTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteScheduledTaskResponse{}
	_body, _err := client.DeleteScheduledTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeAlarmsWithOptions(request *DescribeAlarmsRequest, runtime *util.RuntimeOptions) (_result *DescribeAlarmsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlarmTaskId)) {
		query["AlarmTaskId"] = request.AlarmTaskId
	}

	if !tea.BoolValue(util.IsUnset(request.IsEnable)) {
		query["IsEnable"] = request.IsEnable
	}

	if !tea.BoolValue(util.IsUnset(request.MetricName)) {
		query["MetricName"] = request.MetricName
	}

	if !tea.BoolValue(util.IsUnset(request.MetricType)) {
		query["MetricType"] = request.MetricType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.State)) {
		query["State"] = request.State
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAlarms"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAlarmsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeAlarms(request *DescribeAlarmsRequest) (_result *DescribeAlarmsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAlarmsResponse{}
	_body, _err := client.DescribeAlarmsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeEciScalingConfigurationsWithOptions(request *DescribeEciScalingConfigurationsRequest, runtime *util.RuntimeOptions) (_result *DescribeEciScalingConfigurationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationIds)) {
		query["ScalingConfigurationIds"] = request.ScalingConfigurationIds
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationNames)) {
		query["ScalingConfigurationNames"] = request.ScalingConfigurationNames
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeEciScalingConfigurations"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeEciScalingConfigurationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeEciScalingConfigurations(request *DescribeEciScalingConfigurationsRequest) (_result *DescribeEciScalingConfigurationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeEciScalingConfigurationsResponse{}
	_body, _err := client.DescribeEciScalingConfigurationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Queries lifecycle actions.
 *
 * @param request DescribeLifecycleActionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLifecycleActionsResponse
 */
func (client *Client) DescribeLifecycleActionsWithOptions(request *DescribeLifecycleActionsRequest, runtime *util.RuntimeOptions) (_result *DescribeLifecycleActionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LifecycleActionStatus)) {
		query["LifecycleActionStatus"] = request.LifecycleActionStatus
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingActivityId)) {
		query["ScalingActivityId"] = request.ScalingActivityId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeLifecycleActions"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeLifecycleActionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Queries lifecycle actions.
 *
 * @param request DescribeLifecycleActionsRequest
 * @return DescribeLifecycleActionsResponse
 */
func (client *Client) DescribeLifecycleActions(request *DescribeLifecycleActionsRequest) (_result *DescribeLifecycleActionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeLifecycleActionsResponse{}
	_body, _err := client.DescribeLifecycleActionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can use one of the following methods to query lifecycle hooks:
 * *   Specify a list of lifecycle hook IDs by using the LifecycleHookIds parameter. In this case, you do not need to specify the ScalingGroupId and LifecycleHookName parameters.
 * *   Specify the scaling group ID by using the ScalingGroupId parameter.
 * *   Specify the scaling group ID by using the ScalingGroupId parameter and the lifecycle hook name by using the LifecycleHookName parameter at the same time.
 *
 * @param request DescribeLifecycleHooksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLifecycleHooksResponse
 */
func (client *Client) DescribeLifecycleHooksWithOptions(request *DescribeLifecycleHooksRequest, runtime *util.RuntimeOptions) (_result *DescribeLifecycleHooksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LifecycleHookIds)) {
		query["LifecycleHookIds"] = request.LifecycleHookIds
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleHookName)) {
		query["LifecycleHookName"] = request.LifecycleHookName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeLifecycleHooks"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeLifecycleHooksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can use one of the following methods to query lifecycle hooks:
 * *   Specify a list of lifecycle hook IDs by using the LifecycleHookIds parameter. In this case, you do not need to specify the ScalingGroupId and LifecycleHookName parameters.
 * *   Specify the scaling group ID by using the ScalingGroupId parameter.
 * *   Specify the scaling group ID by using the ScalingGroupId parameter and the lifecycle hook name by using the LifecycleHookName parameter at the same time.
 *
 * @param request DescribeLifecycleHooksRequest
 * @return DescribeLifecycleHooksResponse
 */
func (client *Client) DescribeLifecycleHooks(request *DescribeLifecycleHooksRequest) (_result *DescribeLifecycleHooksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeLifecycleHooksResponse{}
	_body, _err := client.DescribeLifecycleHooksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeLimitationWithOptions(request *DescribeLimitationRequest, runtime *util.RuntimeOptions) (_result *DescribeLimitationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeLimitation"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeLimitationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeLimitation(request *DescribeLimitationRequest) (_result *DescribeLimitationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeLimitationResponse{}
	_body, _err := client.DescribeLimitationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeNotificationConfigurationsWithOptions(request *DescribeNotificationConfigurationsRequest, runtime *util.RuntimeOptions) (_result *DescribeNotificationConfigurationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeNotificationConfigurations"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeNotificationConfigurationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeNotificationConfigurations(request *DescribeNotificationConfigurationsRequest) (_result *DescribeNotificationConfigurationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeNotificationConfigurationsResponse{}
	_body, _err := client.DescribeNotificationConfigurationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeNotificationTypesWithOptions(request *DescribeNotificationTypesRequest, runtime *util.RuntimeOptions) (_result *DescribeNotificationTypesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeNotificationTypes"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeNotificationTypesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeNotificationTypes(request *DescribeNotificationTypesRequest) (_result *DescribeNotificationTypesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeNotificationTypesResponse{}
	_body, _err := client.DescribeNotificationTypesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeRegionsWithOptions(request *DescribeRegionsRequest, runtime *util.RuntimeOptions) (_result *DescribeRegionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRegions"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRegionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeRegions(request *DescribeRegionsRequest) (_result *DescribeRegionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRegionsResponse{}
	_body, _err := client.DescribeRegionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can specify a scaling group ID to query all scaling activities in the scaling group.
 * You can filter query results based on the status of scaling activities.
 * You can query scaling activities that are executed in the previous 30 days.
 *
 * @param request DescribeScalingActivitiesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeScalingActivitiesResponse
 */
func (client *Client) DescribeScalingActivitiesWithOptions(request *DescribeScalingActivitiesRequest, runtime *util.RuntimeOptions) (_result *DescribeScalingActivitiesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingActivityIds)) {
		query["ScalingActivityIds"] = request.ScalingActivityIds
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StatusCode)) {
		query["StatusCode"] = request.StatusCode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeScalingActivities"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeScalingActivitiesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can specify a scaling group ID to query all scaling activities in the scaling group.
 * You can filter query results based on the status of scaling activities.
 * You can query scaling activities that are executed in the previous 30 days.
 *
 * @param request DescribeScalingActivitiesRequest
 * @return DescribeScalingActivitiesResponse
 */
func (client *Client) DescribeScalingActivities(request *DescribeScalingActivitiesRequest) (_result *DescribeScalingActivitiesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeScalingActivitiesResponse{}
	_body, _err := client.DescribeScalingActivitiesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeScalingActivityDetailWithOptions(request *DescribeScalingActivityDetailRequest, runtime *util.RuntimeOptions) (_result *DescribeScalingActivityDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingActivityId)) {
		query["ScalingActivityId"] = request.ScalingActivityId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeScalingActivityDetail"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeScalingActivityDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeScalingActivityDetail(request *DescribeScalingActivityDetailRequest) (_result *DescribeScalingActivityDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeScalingActivityDetailResponse{}
	_body, _err := client.DescribeScalingActivityDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeScalingConfigurationsWithOptions(request *DescribeScalingConfigurationsRequest, runtime *util.RuntimeOptions) (_result *DescribeScalingConfigurationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationIds)) {
		query["ScalingConfigurationIds"] = request.ScalingConfigurationIds
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationNames)) {
		query["ScalingConfigurationNames"] = request.ScalingConfigurationNames
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeScalingConfigurations"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeScalingConfigurationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeScalingConfigurations(request *DescribeScalingConfigurationsRequest) (_result *DescribeScalingConfigurationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeScalingConfigurationsResponse{}
	_body, _err := client.DescribeScalingConfigurationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeScalingGroupsWithOptions(request *DescribeScalingGroupsRequest, runtime *util.RuntimeOptions) (_result *DescribeScalingGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupType)) {
		query["GroupType"] = request.GroupType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupIds)) {
		query["ScalingGroupIds"] = request.ScalingGroupIds
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupName)) {
		query["ScalingGroupName"] = request.ScalingGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupNames)) {
		query["ScalingGroupNames"] = request.ScalingGroupNames
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeScalingGroups"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeScalingGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeScalingGroups(request *DescribeScalingGroupsRequest) (_result *DescribeScalingGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeScalingGroupsResponse{}
	_body, _err := client.DescribeScalingGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can query ECS instances by scaling group ID, scaling configuration ID, health status, lifecycle status, and instance creation method.
 *
 * @param request DescribeScalingInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeScalingInstancesResponse
 */
func (client *Client) DescribeScalingInstancesWithOptions(request *DescribeScalingInstancesRequest, runtime *util.RuntimeOptions) (_result *DescribeScalingInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CreationType)) {
		query["CreationType"] = request.CreationType
	}

	if !tea.BoolValue(util.IsUnset(request.HealthStatus)) {
		query["HealthStatus"] = request.HealthStatus
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleState)) {
		query["LifecycleState"] = request.LifecycleState
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingActivityId)) {
		query["ScalingActivityId"] = request.ScalingActivityId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationId)) {
		query["ScalingConfigurationId"] = request.ScalingConfigurationId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeScalingInstances"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeScalingInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can query ECS instances by scaling group ID, scaling configuration ID, health status, lifecycle status, and instance creation method.
 *
 * @param request DescribeScalingInstancesRequest
 * @return DescribeScalingInstancesResponse
 */
func (client *Client) DescribeScalingInstances(request *DescribeScalingInstancesRequest) (_result *DescribeScalingInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeScalingInstancesResponse{}
	_body, _err := client.DescribeScalingInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Queries all scaling rules in a scaling group.
 *
 * @param request DescribeScalingRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeScalingRulesResponse
 */
func (client *Client) DescribeScalingRulesWithOptions(request *DescribeScalingRulesRequest, runtime *util.RuntimeOptions) (_result *DescribeScalingRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleAris)) {
		query["ScalingRuleAris"] = request.ScalingRuleAris
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleIds)) {
		query["ScalingRuleIds"] = request.ScalingRuleIds
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleNames)) {
		query["ScalingRuleNames"] = request.ScalingRuleNames
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleType)) {
		query["ScalingRuleType"] = request.ScalingRuleType
	}

	if !tea.BoolValue(util.IsUnset(request.ShowAlarmRules)) {
		query["ShowAlarmRules"] = request.ShowAlarmRules
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeScalingRules"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeScalingRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Queries all scaling rules in a scaling group.
 *
 * @param request DescribeScalingRulesRequest
 * @return DescribeScalingRulesResponse
 */
func (client *Client) DescribeScalingRules(request *DescribeScalingRulesRequest) (_result *DescribeScalingRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeScalingRulesResponse{}
	_body, _err := client.DescribeScalingRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can query scheduled tasks by scaling rule, task ID, or task name.
 *
 * @param request DescribeScheduledTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeScheduledTasksResponse
 */
func (client *Client) DescribeScheduledTasksWithOptions(request *DescribeScheduledTasksRequest, runtime *util.RuntimeOptions) (_result *DescribeScheduledTasksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduledActions)) {
		query["ScheduledActions"] = request.ScheduledActions
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduledTaskIds)) {
		query["ScheduledTaskIds"] = request.ScheduledTaskIds
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduledTaskNames)) {
		query["ScheduledTaskNames"] = request.ScheduledTaskNames
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeScheduledTasks"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeScheduledTasksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can query scheduled tasks by scaling rule, task ID, or task name.
 *
 * @param request DescribeScheduledTasksRequest
 * @return DescribeScheduledTasksResponse
 */
func (client *Client) DescribeScheduledTasks(request *DescribeScheduledTasksRequest) (_result *DescribeScheduledTasksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeScheduledTasksResponse{}
	_body, _err := client.DescribeScheduledTasksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DetachAlbServerGroupsWithOptions(request *DetachAlbServerGroupsRequest, runtime *util.RuntimeOptions) (_result *DetachAlbServerGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlbServerGroups)) {
		query["AlbServerGroups"] = request.AlbServerGroups
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ForceDetach)) {
		query["ForceDetach"] = request.ForceDetach
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachAlbServerGroups"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachAlbServerGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DetachAlbServerGroups(request *DetachAlbServerGroupsRequest) (_result *DetachAlbServerGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachAlbServerGroupsResponse{}
	_body, _err := client.DetachAlbServerGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DetachDBInstancesWithOptions(request *DetachDBInstancesRequest, runtime *util.RuntimeOptions) (_result *DetachDBInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DBInstances)) {
		query["DBInstances"] = request.DBInstances
	}

	if !tea.BoolValue(util.IsUnset(request.ForceDetach)) {
		query["ForceDetach"] = request.ForceDetach
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachDBInstances"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachDBInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DetachDBInstances(request *DetachDBInstancesRequest) (_result *DetachDBInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachDBInstancesResponse{}
	_body, _err := client.DetachDBInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Removes one or more Elastic Compute Service (ECS) instances or elastic container instances from a scaling group.
 *
 * @param request DetachInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DetachInstancesResponse
 */
func (client *Client) DetachInstancesWithOptions(request *DetachInstancesRequest, runtime *util.RuntimeOptions) (_result *DetachInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DecreaseDesiredCapacity)) {
		query["DecreaseDesiredCapacity"] = request.DecreaseDesiredCapacity
	}

	if !tea.BoolValue(util.IsUnset(request.DetachOption)) {
		query["DetachOption"] = request.DetachOption
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleHook)) {
		query["LifecycleHook"] = request.LifecycleHook
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachInstances"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Removes one or more Elastic Compute Service (ECS) instances or elastic container instances from a scaling group.
 *
 * @param request DetachInstancesRequest
 * @return DetachInstancesResponse
 */
func (client *Client) DetachInstances(request *DetachInstancesRequest) (_result *DetachInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachInstancesResponse{}
	_body, _err := client.DetachInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DetachLoadBalancersWithOptions(request *DetachLoadBalancersRequest, runtime *util.RuntimeOptions) (_result *DetachLoadBalancersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Async)) {
		query["Async"] = request.Async
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ForceDetach)) {
		query["ForceDetach"] = request.ForceDetach
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancers)) {
		query["LoadBalancers"] = request.LoadBalancers
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachLoadBalancers"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachLoadBalancersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DetachLoadBalancers(request *DetachLoadBalancersRequest) (_result *DetachLoadBalancersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachLoadBalancersResponse{}
	_body, _err := client.DetachLoadBalancersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Detaches one or more vServer groups of a Classic Load Balancer (CLB) instance from a scaling group.
 *
 * @param request DetachVServerGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DetachVServerGroupsResponse
 */
func (client *Client) DetachVServerGroupsWithOptions(request *DetachVServerGroupsRequest, runtime *util.RuntimeOptions) (_result *DetachVServerGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ForceDetach)) {
		query["ForceDetach"] = request.ForceDetach
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroups)) {
		query["VServerGroups"] = request.VServerGroups
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachVServerGroups"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachVServerGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Detaches one or more vServer groups of a Classic Load Balancer (CLB) instance from a scaling group.
 *
 * @param request DetachVServerGroupsRequest
 * @return DetachVServerGroupsResponse
 */
func (client *Client) DetachVServerGroups(request *DetachVServerGroupsRequest) (_result *DetachVServerGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachVServerGroupsResponse{}
	_body, _err := client.DetachVServerGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DisableAlarmWithOptions(request *DisableAlarmRequest, runtime *util.RuntimeOptions) (_result *DisableAlarmResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlarmTaskId)) {
		query["AlarmTaskId"] = request.AlarmTaskId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DisableAlarm"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DisableAlarmResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DisableAlarm(request *DisableAlarmRequest) (_result *DisableAlarmResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DisableAlarmResponse{}
	_body, _err := client.DisableAlarmWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Disables a scaling group.
 *
 * @param request DisableScalingGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableScalingGroupResponse
 */
func (client *Client) DisableScalingGroupWithOptions(request *DisableScalingGroupRequest, runtime *util.RuntimeOptions) (_result *DisableScalingGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DisableScalingGroup"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DisableScalingGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Disables a scaling group.
 *
 * @param request DisableScalingGroupRequest
 * @return DisableScalingGroupResponse
 */
func (client *Client) DisableScalingGroup(request *DisableScalingGroupRequest) (_result *DisableScalingGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DisableScalingGroupResponse{}
	_body, _err := client.DisableScalingGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EnableAlarmWithOptions(request *EnableAlarmRequest, runtime *util.RuntimeOptions) (_result *EnableAlarmResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlarmTaskId)) {
		query["AlarmTaskId"] = request.AlarmTaskId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableAlarm"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableAlarmResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EnableAlarm(request *EnableAlarmRequest) (_result *EnableAlarmResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnableAlarmResponse{}
	_body, _err := client.EnableAlarmWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to enable a scaling group that is in the Inactive state and has an instance configuration source. The instance configuration source can be a scaling configuration, a launch template, or an Elastic Compute Service (ECS) instance that you specified when you created the scaling group. If a scaling group is not in the Inactive state or does not have an active instance configuration source, you cannot call this operation to enable the scaling group.
 * > A scaling group can have only one active instance configuration source. When you call this operation to enable a scaling group, you can specify a scaling configuration or a launch template for the scaling group. If an instance configuration source has been configured for the scaling group before you call this operation, the scaling configuration or launch template that you specify in the request overwrites the original scaling configuration or launch template.
 * If you specify a value for the InstanceId parameter when you call the operation, Auto Scaling checks whether the total number of ECS instances is within the range allowed in the scaling group after you call the operation.
 * *   If the total number of ECS instances is less than the minimum number of instances allowed in the scaling group after you call the operation, Auto Scaling automatically creates the required number of pay-as-you-go ECS instances and adds the instances to the scaling group to reach the minimum number. For example, if the minimum number of instances allowed in your scaling group is five, and you specify the InstanceId parameter to add two created ECS instances to the scaling group, Auto Scaling automatically creates three instances in the scaling group after the two instances are added.
 * *   If the value of the TotalCapactiy parameter is greater than the value of the MaxSize parameter, the call fails.
 *
 * @param request EnableScalingGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableScalingGroupResponse
 */
func (client *Client) EnableScalingGroupWithOptions(request *EnableScalingGroupRequest, runtime *util.RuntimeOptions) (_result *EnableScalingGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ActiveScalingConfigurationId)) {
		query["ActiveScalingConfigurationId"] = request.ActiveScalingConfigurationId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchTemplateId)) {
		query["LaunchTemplateId"] = request.LaunchTemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchTemplateOverrides)) {
		query["LaunchTemplateOverrides"] = request.LaunchTemplateOverrides
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchTemplateVersion)) {
		query["LaunchTemplateVersion"] = request.LaunchTemplateVersion
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerWeights)) {
		query["LoadBalancerWeights"] = request.LoadBalancerWeights
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableScalingGroup"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableScalingGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to enable a scaling group that is in the Inactive state and has an instance configuration source. The instance configuration source can be a scaling configuration, a launch template, or an Elastic Compute Service (ECS) instance that you specified when you created the scaling group. If a scaling group is not in the Inactive state or does not have an active instance configuration source, you cannot call this operation to enable the scaling group.
 * > A scaling group can have only one active instance configuration source. When you call this operation to enable a scaling group, you can specify a scaling configuration or a launch template for the scaling group. If an instance configuration source has been configured for the scaling group before you call this operation, the scaling configuration or launch template that you specify in the request overwrites the original scaling configuration or launch template.
 * If you specify a value for the InstanceId parameter when you call the operation, Auto Scaling checks whether the total number of ECS instances is within the range allowed in the scaling group after you call the operation.
 * *   If the total number of ECS instances is less than the minimum number of instances allowed in the scaling group after you call the operation, Auto Scaling automatically creates the required number of pay-as-you-go ECS instances and adds the instances to the scaling group to reach the minimum number. For example, if the minimum number of instances allowed in your scaling group is five, and you specify the InstanceId parameter to add two created ECS instances to the scaling group, Auto Scaling automatically creates three instances in the scaling group after the two instances are added.
 * *   If the value of the TotalCapactiy parameter is greater than the value of the MaxSize parameter, the call fails.
 *
 * @param request EnableScalingGroupRequest
 * @return EnableScalingGroupResponse
 */
func (client *Client) EnableScalingGroup(request *EnableScalingGroupRequest) (_result *EnableScalingGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnableScalingGroupResponse{}
	_body, _err := client.EnableScalingGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If you call the operation to set an Elastic Compute Service (ECS) instance in a scaling group that is associated with a Server Load Balancer (SLB) instance to the Standby state, the weight of the ECS instance as a backend server of the SLB instance is set to 0.
 * *   You can remove an ECS instance that is in the Standby state from a scaling group and release the instance.
 * *   When scale-in activities are triggered by changes in the number of scaling groups or by event-triggered tasks, the ECS instances that are in the Standby state are not removed from the scaling groups.
 * *   If Auto Scaling considers an ECS instance that is in the Standby state unhealthy, such as in the Stopping or Restarting state, Auto Scaling does not update the health check status of the ECS instance or trigger scale-in activities to remove the ECS instance from the scaling group. Auto Scaling updates the health check status of the ECS instance only when the ECS instance is no longer in the Standby state.
 *
 * @param request EnterStandbyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnterStandbyResponse
 */
func (client *Client) EnterStandbyWithOptions(request *EnterStandbyRequest, runtime *util.RuntimeOptions) (_result *EnterStandbyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Async)) {
		query["Async"] = request.Async
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnterStandby"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnterStandbyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If you call the operation to set an Elastic Compute Service (ECS) instance in a scaling group that is associated with a Server Load Balancer (SLB) instance to the Standby state, the weight of the ECS instance as a backend server of the SLB instance is set to 0.
 * *   You can remove an ECS instance that is in the Standby state from a scaling group and release the instance.
 * *   When scale-in activities are triggered by changes in the number of scaling groups or by event-triggered tasks, the ECS instances that are in the Standby state are not removed from the scaling groups.
 * *   If Auto Scaling considers an ECS instance that is in the Standby state unhealthy, such as in the Stopping or Restarting state, Auto Scaling does not update the health check status of the ECS instance or trigger scale-in activities to remove the ECS instance from the scaling group. Auto Scaling updates the health check status of the ECS instance only when the ECS instance is no longer in the Standby state.
 *
 * @param request EnterStandbyRequest
 * @return EnterStandbyResponse
 */
func (client *Client) EnterStandby(request *EnterStandbyRequest) (_result *EnterStandbyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnterStandbyResponse{}
	_body, _err := client.EnterStandbyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Executes a scaling rule.
 *
 * @param request ExecuteScalingRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExecuteScalingRuleResponse
 */
func (client *Client) ExecuteScalingRuleWithOptions(request *ExecuteScalingRuleRequest, runtime *util.RuntimeOptions) (_result *ExecuteScalingRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BreachThreshold)) {
		query["BreachThreshold"] = request.BreachThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.MetricValue)) {
		query["MetricValue"] = request.MetricValue
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleAri)) {
		query["ScalingRuleAri"] = request.ScalingRuleAri
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ExecuteScalingRule"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ExecuteScalingRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Executes a scaling rule.
 *
 * @param request ExecuteScalingRuleRequest
 * @return ExecuteScalingRuleResponse
 */
func (client *Client) ExecuteScalingRule(request *ExecuteScalingRuleRequest) (_result *ExecuteScalingRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ExecuteScalingRuleResponse{}
	_body, _err := client.ExecuteScalingRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If the scaling group is associated with a load balancing instance, the ECS instance weight will be set to the weight value defined in the scaling configuration.
 *
 * @param request ExitStandbyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExitStandbyResponse
 */
func (client *Client) ExitStandbyWithOptions(request *ExitStandbyRequest, runtime *util.RuntimeOptions) (_result *ExitStandbyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Async)) {
		query["Async"] = request.Async
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ExitStandby"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ExitStandbyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If the scaling group is associated with a load balancing instance, the ECS instance weight will be set to the weight value defined in the scaling configuration.
 *
 * @param request ExitStandbyRequest
 * @return ExitStandbyResponse
 */
func (client *Client) ExitStandby(request *ExitStandbyRequest) (_result *ExitStandbyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ExitStandbyResponse{}
	_body, _err := client.ExitStandbyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTagKeysWithOptions(request *ListTagKeysRequest, runtime *util.RuntimeOptions) (_result *ListTagKeysResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTagKeys"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTagKeysResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTagKeys(request *ListTagKeysRequest) (_result *ListTagKeysResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTagKeysResponse{}
	_body, _err := client.ListTagKeysWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTagResourcesWithOptions(request *ListTagResourcesRequest, runtime *util.RuntimeOptions) (_result *ListTagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceIds)) {
		query["ResourceIds"] = request.ResourceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTagResources"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTagResources(request *ListTagResourcesRequest) (_result *ListTagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.ListTagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTagValuesWithOptions(request *ListTagValuesRequest, runtime *util.RuntimeOptions) (_result *ListTagValuesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Key)) {
		query["Key"] = request.Key
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTagValues"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTagValuesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTagValues(request *ListTagValuesRequest) (_result *ListTagValuesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTagValuesResponse{}
	_body, _err := client.ListTagValuesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Modifies an event-triggered task.
 *
 * @param request ModifyAlarmRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAlarmResponse
 */
func (client *Client) ModifyAlarmWithOptions(request *ModifyAlarmRequest, runtime *util.RuntimeOptions) (_result *ModifyAlarmResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlarmActions)) {
		query["AlarmActions"] = request.AlarmActions
	}

	if !tea.BoolValue(util.IsUnset(request.AlarmTaskId)) {
		query["AlarmTaskId"] = request.AlarmTaskId
	}

	if !tea.BoolValue(util.IsUnset(request.ComparisonOperator)) {
		query["ComparisonOperator"] = request.ComparisonOperator
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Dimensions)) {
		query["Dimensions"] = request.Dimensions
	}

	if !tea.BoolValue(util.IsUnset(request.Effective)) {
		query["Effective"] = request.Effective
	}

	if !tea.BoolValue(util.IsUnset(request.EvaluationCount)) {
		query["EvaluationCount"] = request.EvaluationCount
	}

	if !tea.BoolValue(util.IsUnset(request.Expressions)) {
		query["Expressions"] = request.Expressions
	}

	if !tea.BoolValue(util.IsUnset(request.ExpressionsLogicOperator)) {
		query["ExpressionsLogicOperator"] = request.ExpressionsLogicOperator
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.MetricName)) {
		query["MetricName"] = request.MetricName
	}

	if !tea.BoolValue(util.IsUnset(request.MetricType)) {
		query["MetricType"] = request.MetricType
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.Statistics)) {
		query["Statistics"] = request.Statistics
	}

	if !tea.BoolValue(util.IsUnset(request.Threshold)) {
		query["Threshold"] = request.Threshold
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyAlarm"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyAlarmResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Modifies an event-triggered task.
 *
 * @param request ModifyAlarmRequest
 * @return ModifyAlarmResponse
 */
func (client *Client) ModifyAlarm(request *ModifyAlarmRequest) (_result *ModifyAlarmResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyAlarmResponse{}
	_body, _err := client.ModifyAlarmWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If you want to change the name of a scaling configuration in a scaling group, make sure that the new name is unique within the scaling group.
 *
 * @param request ModifyEciScalingConfigurationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyEciScalingConfigurationResponse
 */
func (client *Client) ModifyEciScalingConfigurationWithOptions(request *ModifyEciScalingConfigurationRequest, runtime *util.RuntimeOptions) (_result *ModifyEciScalingConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcrRegistryInfos)) {
		query["AcrRegistryInfos"] = request.AcrRegistryInfos
	}

	if !tea.BoolValue(util.IsUnset(request.ActiveDeadlineSeconds)) {
		query["ActiveDeadlineSeconds"] = request.ActiveDeadlineSeconds
	}

	if !tea.BoolValue(util.IsUnset(request.AutoCreateEip)) {
		query["AutoCreateEip"] = request.AutoCreateEip
	}

	if !tea.BoolValue(util.IsUnset(request.AutoMatchImageCache)) {
		query["AutoMatchImageCache"] = request.AutoMatchImageCache
	}

	if !tea.BoolValue(util.IsUnset(request.ContainerGroupName)) {
		query["ContainerGroupName"] = request.ContainerGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.Containers)) {
		query["Containers"] = request.Containers
	}

	if !tea.BoolValue(util.IsUnset(request.ContainersUpdateType)) {
		query["ContainersUpdateType"] = request.ContainersUpdateType
	}

	if !tea.BoolValue(util.IsUnset(request.CostOptimization)) {
		query["CostOptimization"] = request.CostOptimization
	}

	if !tea.BoolValue(util.IsUnset(request.Cpu)) {
		query["Cpu"] = request.Cpu
	}

	if !tea.BoolValue(util.IsUnset(request.CpuOptionsCore)) {
		query["CpuOptionsCore"] = request.CpuOptionsCore
	}

	if !tea.BoolValue(util.IsUnset(request.CpuOptionsThreadsPerCore)) {
		query["CpuOptionsThreadsPerCore"] = request.CpuOptionsThreadsPerCore
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DnsConfigNameServers)) {
		query["DnsConfigNameServers"] = request.DnsConfigNameServers
	}

	if !tea.BoolValue(util.IsUnset(request.DnsConfigOptions)) {
		query["DnsConfigOptions"] = request.DnsConfigOptions
	}

	if !tea.BoolValue(util.IsUnset(request.DnsConfigSearchs)) {
		query["DnsConfigSearchs"] = request.DnsConfigSearchs
	}

	if !tea.BoolValue(util.IsUnset(request.DnsPolicy)) {
		query["DnsPolicy"] = request.DnsPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.EgressBandwidth)) {
		query["EgressBandwidth"] = request.EgressBandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.EipBandwidth)) {
		query["EipBandwidth"] = request.EipBandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.EnableSls)) {
		query["EnableSls"] = request.EnableSls
	}

	if !tea.BoolValue(util.IsUnset(request.EphemeralStorage)) {
		query["EphemeralStorage"] = request.EphemeralStorage
	}

	if !tea.BoolValue(util.IsUnset(request.HostAliases)) {
		query["HostAliases"] = request.HostAliases
	}

	if !tea.BoolValue(util.IsUnset(request.HostName)) {
		query["HostName"] = request.HostName
	}

	if !tea.BoolValue(util.IsUnset(request.ImageRegistryCredentials)) {
		query["ImageRegistryCredentials"] = request.ImageRegistryCredentials
	}

	if !tea.BoolValue(util.IsUnset(request.ImageSnapshotId)) {
		query["ImageSnapshotId"] = request.ImageSnapshotId
	}

	if !tea.BoolValue(util.IsUnset(request.IngressBandwidth)) {
		query["IngressBandwidth"] = request.IngressBandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.InitContainers)) {
		query["InitContainers"] = request.InitContainers
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceFamilyLevel)) {
		query["InstanceFamilyLevel"] = request.InstanceFamilyLevel
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6AddressCount)) {
		query["Ipv6AddressCount"] = request.Ipv6AddressCount
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerWeight)) {
		query["LoadBalancerWeight"] = request.LoadBalancerWeight
	}

	if !tea.BoolValue(util.IsUnset(request.Memory)) {
		query["Memory"] = request.Memory
	}

	if !tea.BoolValue(util.IsUnset(request.NtpServers)) {
		query["NtpServers"] = request.NtpServers
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RamRoleName)) {
		query["RamRoleName"] = request.RamRoleName
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.RestartPolicy)) {
		query["RestartPolicy"] = request.RestartPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationId)) {
		query["ScalingConfigurationId"] = request.ScalingConfigurationId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationName)) {
		query["ScalingConfigurationName"] = request.ScalingConfigurationName
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityContextSysCtls)) {
		query["SecurityContextSysCtls"] = request.SecurityContextSysCtls
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityGroupId)) {
		query["SecurityGroupId"] = request.SecurityGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SpotPriceLimit)) {
		query["SpotPriceLimit"] = request.SpotPriceLimit
	}

	if !tea.BoolValue(util.IsUnset(request.SpotStrategy)) {
		query["SpotStrategy"] = request.SpotStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.TerminationGracePeriodSeconds)) {
		query["TerminationGracePeriodSeconds"] = request.TerminationGracePeriodSeconds
	}

	if !tea.BoolValue(util.IsUnset(request.Volumes)) {
		query["Volumes"] = request.Volumes
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyEciScalingConfiguration"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyEciScalingConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If you want to change the name of a scaling configuration in a scaling group, make sure that the new name is unique within the scaling group.
 *
 * @param request ModifyEciScalingConfigurationRequest
 * @return ModifyEciScalingConfigurationResponse
 */
func (client *Client) ModifyEciScalingConfiguration(request *ModifyEciScalingConfigurationRequest) (_result *ModifyEciScalingConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyEciScalingConfigurationResponse{}
	_body, _err := client.ModifyEciScalingConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Modifies a lifecycle hook.
 *
 * @param request ModifyLifecycleHookRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyLifecycleHookResponse
 */
func (client *Client) ModifyLifecycleHookWithOptions(request *ModifyLifecycleHookRequest, runtime *util.RuntimeOptions) (_result *ModifyLifecycleHookResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DefaultResult)) {
		query["DefaultResult"] = request.DefaultResult
	}

	if !tea.BoolValue(util.IsUnset(request.HeartbeatTimeout)) {
		query["HeartbeatTimeout"] = request.HeartbeatTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleHookId)) {
		query["LifecycleHookId"] = request.LifecycleHookId
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleHookName)) {
		query["LifecycleHookName"] = request.LifecycleHookName
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleHookStatus)) {
		query["LifecycleHookStatus"] = request.LifecycleHookStatus
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleTransition)) {
		query["LifecycleTransition"] = request.LifecycleTransition
	}

	if !tea.BoolValue(util.IsUnset(request.NotificationArn)) {
		query["NotificationArn"] = request.NotificationArn
	}

	if !tea.BoolValue(util.IsUnset(request.NotificationMetadata)) {
		query["NotificationMetadata"] = request.NotificationMetadata
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyLifecycleHook"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyLifecycleHookResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Modifies a lifecycle hook.
 *
 * @param request ModifyLifecycleHookRequest
 * @return ModifyLifecycleHookResponse
 */
func (client *Client) ModifyLifecycleHook(request *ModifyLifecycleHookRequest) (_result *ModifyLifecycleHookResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyLifecycleHookResponse{}
	_body, _err := client.ModifyLifecycleHookWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyNotificationConfigurationWithOptions(request *ModifyNotificationConfigurationRequest, runtime *util.RuntimeOptions) (_result *ModifyNotificationConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NotificationArn)) {
		query["NotificationArn"] = request.NotificationArn
	}

	if !tea.BoolValue(util.IsUnset(request.NotificationTypes)) {
		query["NotificationTypes"] = request.NotificationTypes
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyNotificationConfiguration"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyNotificationConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyNotificationConfiguration(request *ModifyNotificationConfigurationRequest) (_result *ModifyNotificationConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyNotificationConfigurationResponse{}
	_body, _err := client.ModifyNotificationConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If you want to change the name of a scaling configuration in a scaling group, make sure that the new name is unique within the scaling group.
 *
 * @param tmpReq ModifyScalingConfigurationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyScalingConfigurationResponse
 */
func (client *Client) ModifyScalingConfigurationWithOptions(tmpReq *ModifyScalingConfigurationRequest, runtime *util.RuntimeOptions) (_result *ModifyScalingConfigurationResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ModifyScalingConfigurationShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.SchedulerOptions)) {
		request.SchedulerOptionsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.SchedulerOptions, tea.String("SchedulerOptions"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Affinity)) {
		query["Affinity"] = request.Affinity
	}

	if !tea.BoolValue(util.IsUnset(request.Cpu)) {
		query["Cpu"] = request.Cpu
	}

	if !tea.BoolValue(util.IsUnset(request.CreditSpecification)) {
		query["CreditSpecification"] = request.CreditSpecification
	}

	if !tea.BoolValue(util.IsUnset(request.DataDisks)) {
		query["DataDisks"] = request.DataDisks
	}

	if !tea.BoolValue(util.IsUnset(request.DedicatedHostId)) {
		query["DedicatedHostId"] = request.DedicatedHostId
	}

	if !tea.BoolValue(util.IsUnset(request.DeploymentSetId)) {
		query["DeploymentSetId"] = request.DeploymentSetId
	}

	if !tea.BoolValue(util.IsUnset(request.HostName)) {
		query["HostName"] = request.HostName
	}

	if !tea.BoolValue(util.IsUnset(request.HpcClusterId)) {
		query["HpcClusterId"] = request.HpcClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ImageFamily)) {
		query["ImageFamily"] = request.ImageFamily
	}

	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.ImageName)) {
		query["ImageName"] = request.ImageName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceDescription)) {
		query["InstanceDescription"] = request.InstanceDescription
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceName)) {
		query["InstanceName"] = request.InstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.InstancePatternInfos)) {
		query["InstancePatternInfos"] = request.InstancePatternInfos
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceTypeOverrides)) {
		query["InstanceTypeOverrides"] = request.InstanceTypeOverrides
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceTypes)) {
		query["InstanceTypes"] = request.InstanceTypes
	}

	if !tea.BoolValue(util.IsUnset(request.InternetChargeType)) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.InternetMaxBandwidthOut)) {
		query["InternetMaxBandwidthOut"] = request.InternetMaxBandwidthOut
	}

	if !tea.BoolValue(util.IsUnset(request.IoOptimized)) {
		query["IoOptimized"] = request.IoOptimized
	}

	if !tea.BoolValue(util.IsUnset(request.Ipv6AddressCount)) {
		query["Ipv6AddressCount"] = request.Ipv6AddressCount
	}

	if !tea.BoolValue(util.IsUnset(request.KeyPairName)) {
		query["KeyPairName"] = request.KeyPairName
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerWeight)) {
		query["LoadBalancerWeight"] = request.LoadBalancerWeight
	}

	if !tea.BoolValue(util.IsUnset(request.Memory)) {
		query["Memory"] = request.Memory
	}

	if !tea.BoolValue(util.IsUnset(request.Override)) {
		query["Override"] = request.Override
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PasswordInherit)) {
		query["PasswordInherit"] = request.PasswordInherit
	}

	if !tea.BoolValue(util.IsUnset(request.RamRoleName)) {
		query["RamRoleName"] = request.RamRoleName
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationId)) {
		query["ScalingConfigurationId"] = request.ScalingConfigurationId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingConfigurationName)) {
		query["ScalingConfigurationName"] = request.ScalingConfigurationName
	}

	if !tea.BoolValue(util.IsUnset(request.SchedulerOptionsShrink)) {
		query["SchedulerOptions"] = request.SchedulerOptionsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityGroupId)) {
		query["SecurityGroupId"] = request.SecurityGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityGroupIds)) {
		query["SecurityGroupIds"] = request.SecurityGroupIds
	}

	if !tea.BoolValue(util.IsUnset(request.SpotDuration)) {
		query["SpotDuration"] = request.SpotDuration
	}

	if !tea.BoolValue(util.IsUnset(request.SpotInterruptionBehavior)) {
		query["SpotInterruptionBehavior"] = request.SpotInterruptionBehavior
	}

	if !tea.BoolValue(util.IsUnset(request.SpotPriceLimits)) {
		query["SpotPriceLimits"] = request.SpotPriceLimits
	}

	if !tea.BoolValue(util.IsUnset(request.SpotStrategy)) {
		query["SpotStrategy"] = request.SpotStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.SystemDiskCategories)) {
		query["SystemDiskCategories"] = request.SystemDiskCategories
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.Tenancy)) {
		query["Tenancy"] = request.Tenancy
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	if !tea.BoolValue(util.IsUnset(request.PrivatePoolOptions)) {
		query["PrivatePoolOptions"] = request.PrivatePoolOptions
	}

	if !tea.BoolValue(util.IsUnset(request.SystemDisk)) {
		query["SystemDisk"] = request.SystemDisk
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyScalingConfiguration"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyScalingConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If you want to change the name of a scaling configuration in a scaling group, make sure that the new name is unique within the scaling group.
 *
 * @param request ModifyScalingConfigurationRequest
 * @return ModifyScalingConfigurationResponse
 */
func (client *Client) ModifyScalingConfiguration(request *ModifyScalingConfigurationRequest) (_result *ModifyScalingConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyScalingConfigurationResponse{}
	_body, _err := client.ModifyScalingConfigurationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Modifies a scaling group.
 *
 * @param request ModifyScalingGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyScalingGroupResponse
 */
func (client *Client) ModifyScalingGroupWithOptions(request *ModifyScalingGroupRequest, runtime *util.RuntimeOptions) (_result *ModifyScalingGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ActiveScalingConfigurationId)) {
		query["ActiveScalingConfigurationId"] = request.ActiveScalingConfigurationId
	}

	if !tea.BoolValue(util.IsUnset(request.AllocationStrategy)) {
		query["AllocationStrategy"] = request.AllocationStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.AzBalance)) {
		query["AzBalance"] = request.AzBalance
	}

	if !tea.BoolValue(util.IsUnset(request.CompensateWithOnDemand)) {
		query["CompensateWithOnDemand"] = request.CompensateWithOnDemand
	}

	if !tea.BoolValue(util.IsUnset(request.CustomPolicyARN)) {
		query["CustomPolicyARN"] = request.CustomPolicyARN
	}

	if !tea.BoolValue(util.IsUnset(request.DefaultCooldown)) {
		query["DefaultCooldown"] = request.DefaultCooldown
	}

	if !tea.BoolValue(util.IsUnset(request.DesiredCapacity)) {
		query["DesiredCapacity"] = request.DesiredCapacity
	}

	if !tea.BoolValue(util.IsUnset(request.GroupDeletionProtection)) {
		query["GroupDeletionProtection"] = request.GroupDeletionProtection
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckType)) {
		query["HealthCheckType"] = request.HealthCheckType
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchTemplateId)) {
		query["LaunchTemplateId"] = request.LaunchTemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchTemplateOverrides)) {
		query["LaunchTemplateOverrides"] = request.LaunchTemplateOverrides
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchTemplateVersion)) {
		query["LaunchTemplateVersion"] = request.LaunchTemplateVersion
	}

	if !tea.BoolValue(util.IsUnset(request.MaxInstanceLifetime)) {
		query["MaxInstanceLifetime"] = request.MaxInstanceLifetime
	}

	if !tea.BoolValue(util.IsUnset(request.MaxSize)) {
		query["MaxSize"] = request.MaxSize
	}

	if !tea.BoolValue(util.IsUnset(request.MinSize)) {
		query["MinSize"] = request.MinSize
	}

	if !tea.BoolValue(util.IsUnset(request.MultiAZPolicy)) {
		query["MultiAZPolicy"] = request.MultiAZPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.OnDemandBaseCapacity)) {
		query["OnDemandBaseCapacity"] = request.OnDemandBaseCapacity
	}

	if !tea.BoolValue(util.IsUnset(request.OnDemandPercentageAboveBaseCapacity)) {
		query["OnDemandPercentageAboveBaseCapacity"] = request.OnDemandPercentageAboveBaseCapacity
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RemovalPolicies)) {
		query["RemovalPolicies"] = request.RemovalPolicies
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupName)) {
		query["ScalingGroupName"] = request.ScalingGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.SpotAllocationStrategy)) {
		query["SpotAllocationStrategy"] = request.SpotAllocationStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.SpotInstancePools)) {
		query["SpotInstancePools"] = request.SpotInstancePools
	}

	if !tea.BoolValue(util.IsUnset(request.SpotInstanceRemedy)) {
		query["SpotInstanceRemedy"] = request.SpotInstanceRemedy
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchIds)) {
		query["VSwitchIds"] = request.VSwitchIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyScalingGroup"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyScalingGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Modifies a scaling group.
 *
 * @param request ModifyScalingGroupRequest
 * @return ModifyScalingGroupResponse
 */
func (client *Client) ModifyScalingGroup(request *ModifyScalingGroupRequest) (_result *ModifyScalingGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyScalingGroupResponse{}
	_body, _err := client.ModifyScalingGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyScalingRuleWithOptions(request *ModifyScalingRuleRequest, runtime *util.RuntimeOptions) (_result *ModifyScalingRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AdjustmentType)) {
		query["AdjustmentType"] = request.AdjustmentType
	}

	if !tea.BoolValue(util.IsUnset(request.AdjustmentValue)) {
		query["AdjustmentValue"] = request.AdjustmentValue
	}

	if !tea.BoolValue(util.IsUnset(request.Cooldown)) {
		query["Cooldown"] = request.Cooldown
	}

	if !tea.BoolValue(util.IsUnset(request.DisableScaleIn)) {
		query["DisableScaleIn"] = request.DisableScaleIn
	}

	if !tea.BoolValue(util.IsUnset(request.EstimatedInstanceWarmup)) {
		query["EstimatedInstanceWarmup"] = request.EstimatedInstanceWarmup
	}

	if !tea.BoolValue(util.IsUnset(request.InitialMaxSize)) {
		query["InitialMaxSize"] = request.InitialMaxSize
	}

	if !tea.BoolValue(util.IsUnset(request.MetricName)) {
		query["MetricName"] = request.MetricName
	}

	if !tea.BoolValue(util.IsUnset(request.MinAdjustmentMagnitude)) {
		query["MinAdjustmentMagnitude"] = request.MinAdjustmentMagnitude
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PredictiveScalingMode)) {
		query["PredictiveScalingMode"] = request.PredictiveScalingMode
	}

	if !tea.BoolValue(util.IsUnset(request.PredictiveTaskBufferTime)) {
		query["PredictiveTaskBufferTime"] = request.PredictiveTaskBufferTime
	}

	if !tea.BoolValue(util.IsUnset(request.PredictiveValueBehavior)) {
		query["PredictiveValueBehavior"] = request.PredictiveValueBehavior
	}

	if !tea.BoolValue(util.IsUnset(request.PredictiveValueBuffer)) {
		query["PredictiveValueBuffer"] = request.PredictiveValueBuffer
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScaleInEvaluationCount)) {
		query["ScaleInEvaluationCount"] = request.ScaleInEvaluationCount
	}

	if !tea.BoolValue(util.IsUnset(request.ScaleOutEvaluationCount)) {
		query["ScaleOutEvaluationCount"] = request.ScaleOutEvaluationCount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleId)) {
		query["ScalingRuleId"] = request.ScalingRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleName)) {
		query["ScalingRuleName"] = request.ScalingRuleName
	}

	if !tea.BoolValue(util.IsUnset(request.StepAdjustments)) {
		query["StepAdjustments"] = request.StepAdjustments
	}

	if !tea.BoolValue(util.IsUnset(request.TargetValue)) {
		query["TargetValue"] = request.TargetValue
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyScalingRule"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyScalingRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyScalingRule(request *ModifyScalingRuleRequest) (_result *ModifyScalingRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyScalingRuleResponse{}
	_body, _err := client.ModifyScalingRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Modifies a scheduled task.
 *
 * @param request ModifyScheduledTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyScheduledTaskResponse
 */
func (client *Client) ModifyScheduledTaskWithOptions(request *ModifyScheduledTaskRequest, runtime *util.RuntimeOptions) (_result *ModifyScheduledTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DesiredCapacity)) {
		query["DesiredCapacity"] = request.DesiredCapacity
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchExpirationTime)) {
		query["LaunchExpirationTime"] = request.LaunchExpirationTime
	}

	if !tea.BoolValue(util.IsUnset(request.LaunchTime)) {
		query["LaunchTime"] = request.LaunchTime
	}

	if !tea.BoolValue(util.IsUnset(request.MaxValue)) {
		query["MaxValue"] = request.MaxValue
	}

	if !tea.BoolValue(util.IsUnset(request.MinValue)) {
		query["MinValue"] = request.MinValue
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RecurrenceEndTime)) {
		query["RecurrenceEndTime"] = request.RecurrenceEndTime
	}

	if !tea.BoolValue(util.IsUnset(request.RecurrenceType)) {
		query["RecurrenceType"] = request.RecurrenceType
	}

	if !tea.BoolValue(util.IsUnset(request.RecurrenceValue)) {
		query["RecurrenceValue"] = request.RecurrenceValue
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduledAction)) {
		query["ScheduledAction"] = request.ScheduledAction
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduledTaskId)) {
		query["ScheduledTaskId"] = request.ScheduledTaskId
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduledTaskName)) {
		query["ScheduledTaskName"] = request.ScheduledTaskName
	}

	if !tea.BoolValue(util.IsUnset(request.TaskEnabled)) {
		query["TaskEnabled"] = request.TaskEnabled
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyScheduledTask"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyScheduledTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Modifies a scheduled task.
 *
 * @param request ModifyScheduledTaskRequest
 * @return ModifyScheduledTaskResponse
 */
func (client *Client) ModifyScheduledTask(request *ModifyScheduledTaskRequest) (_result *ModifyScheduledTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyScheduledTaskResponse{}
	_body, _err := client.ModifyScheduledTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Rebalances Elastic Compute Service (ECS) instances in a multi-zone scaling group across zones.
 *
 * @param request RebalanceInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RebalanceInstancesResponse
 */
func (client *Client) RebalanceInstancesWithOptions(request *RebalanceInstancesRequest, runtime *util.RuntimeOptions) (_result *RebalanceInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RebalanceInstances"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RebalanceInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Rebalances Elastic Compute Service (ECS) instances in a multi-zone scaling group across zones.
 *
 * @param request RebalanceInstancesRequest
 * @return RebalanceInstancesResponse
 */
func (client *Client) RebalanceInstances(request *RebalanceInstancesRequest) (_result *RebalanceInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RebalanceInstancesResponse{}
	_body, _err := client.RebalanceInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Prolongs a lifecycle hook for Elastic Compute Service (ECS) instances.
 *
 * @param request RecordLifecycleActionHeartbeatRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RecordLifecycleActionHeartbeatResponse
 */
func (client *Client) RecordLifecycleActionHeartbeatWithOptions(request *RecordLifecycleActionHeartbeatRequest, runtime *util.RuntimeOptions) (_result *RecordLifecycleActionHeartbeatResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.HeartbeatTimeout)) {
		query["heartbeatTimeout"] = request.HeartbeatTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleActionToken)) {
		query["lifecycleActionToken"] = request.LifecycleActionToken
	}

	if !tea.BoolValue(util.IsUnset(request.LifecycleHookId)) {
		query["lifecycleHookId"] = request.LifecycleHookId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RecordLifecycleActionHeartbeat"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RecordLifecycleActionHeartbeatResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Prolongs a lifecycle hook for Elastic Compute Service (ECS) instances.
 *
 * @param request RecordLifecycleActionHeartbeatRequest
 * @return RecordLifecycleActionHeartbeatResponse
 */
func (client *Client) RecordLifecycleActionHeartbeat(request *RecordLifecycleActionHeartbeatRequest) (_result *RecordLifecycleActionHeartbeatResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RecordLifecycleActionHeartbeatResponse{}
	_body, _err := client.RecordLifecycleActionHeartbeatWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   Before you call this operation, make sure that the following requirements are met:
 *     *   The scaling group is in the Active state.
 *     *   No scaling activity is in progress within the scaling group.
 * > If no scaling activity is in progress within the scaling group, you can call the operation even within the cooldown period.
 * *   If an ECS instance is automatically created by Auto Scaling, or if an ECS instance is manually added to a scaling group and managed by the scaling group, the ECS instance is stopped in economical mode or is released after the instance is removed from the scaling group.
 * *   If an ECS instance is manually added to a scaling group and is not managed by the scaling group, the ECS instance is not stopped or released after the instance is removed from the scaling group.
 * *   If the difference between the number of existing ECS instances specified by the TotalCapacity parameter and the number of ECS instances that you call this operation to remove is less than the value of the MinSize parameter, the call fails.
 * A successful call only means that Auto Scaling accepts the request. The scaling activity may still fail. You can obtain the status of a scaling activity based on the value of the ScalingActivityId parameter in the response.
 *
 * @param request RemoveInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveInstancesResponse
 */
func (client *Client) RemoveInstancesWithOptions(request *RemoveInstancesRequest, runtime *util.RuntimeOptions) (_result *RemoveInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DecreaseDesiredCapacity)) {
		query["DecreaseDesiredCapacity"] = request.DecreaseDesiredCapacity
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RemovePolicy)) {
		query["RemovePolicy"] = request.RemovePolicy
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveInstances"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   Before you call this operation, make sure that the following requirements are met:
 *     *   The scaling group is in the Active state.
 *     *   No scaling activity is in progress within the scaling group.
 * > If no scaling activity is in progress within the scaling group, you can call the operation even within the cooldown period.
 * *   If an ECS instance is automatically created by Auto Scaling, or if an ECS instance is manually added to a scaling group and managed by the scaling group, the ECS instance is stopped in economical mode or is released after the instance is removed from the scaling group.
 * *   If an ECS instance is manually added to a scaling group and is not managed by the scaling group, the ECS instance is not stopped or released after the instance is removed from the scaling group.
 * *   If the difference between the number of existing ECS instances specified by the TotalCapacity parameter and the number of ECS instances that you call this operation to remove is less than the value of the MinSize parameter, the call fails.
 * A successful call only means that Auto Scaling accepts the request. The scaling activity may still fail. You can obtain the status of a scaling activity based on the value of the ScalingActivityId parameter in the response.
 *
 * @param request RemoveInstancesRequest
 * @return RemoveInstancesResponse
 */
func (client *Client) RemoveInstances(request *RemoveInstancesRequest) (_result *RemoveInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveInstancesResponse{}
	_body, _err := client.RemoveInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ResumeProcessesWithOptions(request *ResumeProcessesRequest, runtime *util.RuntimeOptions) (_result *ResumeProcessesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Processes)) {
		query["Processes"] = request.Processes
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ResumeProcesses"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ResumeProcessesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ResumeProcesses(request *ResumeProcessesRequest) (_result *ResumeProcessesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ResumeProcessesResponse{}
	_body, _err := client.ResumeProcessesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Compared with the ExecuteScalingRule operation, the ScaleWithAdjustment operation does not require a scaling rule to be created in advance. Before you call the ScaleWithAdjustment operation, take note of the following items:
 * *   The following conditions must be met:
 *     *   The scaling group is in the Active state.
 *     *   No scaling activities in the scaling group are in progress.
 * *   If no scaling activities in the scaling group are in progress, the operation can trigger scaling activities even before the cooldown time expires.
 * *   If the addition of a specified number of Elastic Compute Service (ECS) instances to a scaling group causes the total number of ECS instances in the scaling group to exceed the maximum number of instances allowed, Auto Scaling adds only a specific number of ECS instances to ensure that the total number of instances is equal to the maximum number of instances.
 * *   If the removal of a specified number of ECS instances from a scaling group causes the total number of ECS instances in the scaling group to drop below the minimum number of instances allowed, Auto Scaling removes only a specific number of ECS instances to ensure that the total number of instances is equal to the minimum number of instances.
 * A successful call indicates that Auto Scaling accepts the request. However, the scaling activity may still fail. You can obtain the status of a scaling activity by using the value of the `ScalingActivityId` parameter in the response.
 *
 * @param request ScaleWithAdjustmentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ScaleWithAdjustmentResponse
 */
func (client *Client) ScaleWithAdjustmentWithOptions(request *ScaleWithAdjustmentRequest, runtime *util.RuntimeOptions) (_result *ScaleWithAdjustmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AdjustmentType)) {
		query["AdjustmentType"] = request.AdjustmentType
	}

	if !tea.BoolValue(util.IsUnset(request.AdjustmentValue)) {
		query["AdjustmentValue"] = request.AdjustmentValue
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.MinAdjustmentMagnitude)) {
		query["MinAdjustmentMagnitude"] = request.MinAdjustmentMagnitude
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SyncActivity)) {
		query["SyncActivity"] = request.SyncActivity
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ScaleWithAdjustment"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ScaleWithAdjustmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Compared with the ExecuteScalingRule operation, the ScaleWithAdjustment operation does not require a scaling rule to be created in advance. Before you call the ScaleWithAdjustment operation, take note of the following items:
 * *   The following conditions must be met:
 *     *   The scaling group is in the Active state.
 *     *   No scaling activities in the scaling group are in progress.
 * *   If no scaling activities in the scaling group are in progress, the operation can trigger scaling activities even before the cooldown time expires.
 * *   If the addition of a specified number of Elastic Compute Service (ECS) instances to a scaling group causes the total number of ECS instances in the scaling group to exceed the maximum number of instances allowed, Auto Scaling adds only a specific number of ECS instances to ensure that the total number of instances is equal to the maximum number of instances.
 * *   If the removal of a specified number of ECS instances from a scaling group causes the total number of ECS instances in the scaling group to drop below the minimum number of instances allowed, Auto Scaling removes only a specific number of ECS instances to ensure that the total number of instances is equal to the minimum number of instances.
 * A successful call indicates that Auto Scaling accepts the request. However, the scaling activity may still fail. You can obtain the status of a scaling activity by using the value of the `ScalingActivityId` parameter in the response.
 *
 * @param request ScaleWithAdjustmentRequest
 * @return ScaleWithAdjustmentResponse
 */
func (client *Client) ScaleWithAdjustment(request *ScaleWithAdjustmentRequest) (_result *ScaleWithAdjustmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ScaleWithAdjustmentResponse{}
	_body, _err := client.ScaleWithAdjustmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetGroupDeletionProtectionWithOptions(request *SetGroupDeletionProtectionRequest, runtime *util.RuntimeOptions) (_result *SetGroupDeletionProtectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupDeletionProtection)) {
		query["GroupDeletionProtection"] = request.GroupDeletionProtection
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetGroupDeletionProtection"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetGroupDeletionProtectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetGroupDeletionProtection(request *SetGroupDeletionProtectionRequest) (_result *SetGroupDeletionProtectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetGroupDeletionProtectionResponse{}
	_body, _err := client.SetGroupDeletionProtectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Configures the health check feature for Elastic Compute Service (ECS) instances.
 *
 * @param request SetInstanceHealthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetInstanceHealthResponse
 */
func (client *Client) SetInstanceHealthWithOptions(request *SetInstanceHealthRequest, runtime *util.RuntimeOptions) (_result *SetInstanceHealthResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.HealthStatus)) {
		query["HealthStatus"] = request.HealthStatus
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetInstanceHealth"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetInstanceHealthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Configures the health check feature for Elastic Compute Service (ECS) instances.
 *
 * @param request SetInstanceHealthRequest
 * @return SetInstanceHealthResponse
 */
func (client *Client) SetInstanceHealth(request *SetInstanceHealthRequest) (_result *SetInstanceHealthResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetInstanceHealthResponse{}
	_body, _err := client.SetInstanceHealthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Puts one or more Elastic Compute Service (ECS) instances into the Protected state.
 *
 * @param request SetInstancesProtectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetInstancesProtectionResponse
 */
func (client *Client) SetInstancesProtectionWithOptions(request *SetInstancesProtectionRequest, runtime *util.RuntimeOptions) (_result *SetInstancesProtectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProtectedFromScaleIn)) {
		query["ProtectedFromScaleIn"] = request.ProtectedFromScaleIn
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetInstancesProtection"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetInstancesProtectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Puts one or more Elastic Compute Service (ECS) instances into the Protected state.
 *
 * @param request SetInstancesProtectionRequest
 * @return SetInstancesProtectionResponse
 */
func (client *Client) SetInstancesProtection(request *SetInstancesProtectionRequest) (_result *SetInstancesProtectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetInstancesProtectionResponse{}
	_body, _err := client.SetInstancesProtectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SuspendProcessesWithOptions(request *SuspendProcessesRequest, runtime *util.RuntimeOptions) (_result *SuspendProcessesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Processes)) {
		query["Processes"] = request.Processes
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingGroupId)) {
		query["ScalingGroupId"] = request.ScalingGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SuspendProcesses"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SuspendProcessesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SuspendProcesses(request *SuspendProcessesRequest) (_result *SuspendProcessesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SuspendProcessesResponse{}
	_body, _err := client.SuspendProcessesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) TagResourcesWithOptions(request *TagResourcesRequest, runtime *util.RuntimeOptions) (_result *TagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceIds)) {
		query["ResourceIds"] = request.ResourceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TagResources"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) TagResources(request *TagResourcesRequest) (_result *TagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TagResourcesResponse{}
	_body, _err := client.TagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UntagResourcesWithOptions(request *UntagResourcesRequest, runtime *util.RuntimeOptions) (_result *UntagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.All)) {
		query["All"] = request.All
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceIds)) {
		query["ResourceIds"] = request.ResourceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TagKeys)) {
		query["TagKeys"] = request.TagKeys
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UntagResources"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UntagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UntagResources(request *UntagResourcesRequest) (_result *UntagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UntagResourcesResponse{}
	_body, _err := client.UntagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) VerifyAuthenticationWithOptions(request *VerifyAuthenticationRequest, runtime *util.RuntimeOptions) (_result *VerifyAuthenticationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OnlyCheck)) {
		query["OnlyCheck"] = request.OnlyCheck
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Uid)) {
		query["Uid"] = request.Uid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("VerifyAuthentication"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &VerifyAuthenticationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) VerifyAuthentication(request *VerifyAuthenticationRequest) (_result *VerifyAuthenticationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &VerifyAuthenticationResponse{}
	_body, _err := client.VerifyAuthenticationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) VerifyUserWithOptions(request *VerifyUserRequest, runtime *util.RuntimeOptions) (_result *VerifyUserResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("VerifyUser"),
		Version:     tea.String("2022-02-22"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &VerifyUserResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) VerifyUser(request *VerifyUserRequest) (_result *VerifyUserResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &VerifyUserResponse{}
	_body, _err := client.VerifyUserWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
