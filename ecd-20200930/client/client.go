// This file is auto-generated, don't edit it. Thanks.
/**
 *
 */
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	endpointutil "github.com/alibabacloud-go/endpoint-util/service"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
)

type CdsFileShareLinkModel struct {
	AccessCount       *int64  `json:"AccessCount,omitempty" xml:"AccessCount,omitempty"`
	CreateTime        *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	Creator           *string `json:"Creator,omitempty" xml:"Creator,omitempty"`
	Description       *string `json:"Description,omitempty" xml:"Description,omitempty"`
	DisableDownload   *bool   `json:"DisableDownload,omitempty" xml:"DisableDownload,omitempty"`
	DisablePreview    *bool   `json:"DisablePreview,omitempty" xml:"DisablePreview,omitempty"`
	DisableSave       *bool   `json:"DisableSave,omitempty" xml:"DisableSave,omitempty"`
	DownloadCount     *int64  `json:"DownloadCount,omitempty" xml:"DownloadCount,omitempty"`
	DownloadLimit     *int64  `json:"DownloadLimit,omitempty" xml:"DownloadLimit,omitempty"`
	DriveId           *string `json:"DriveId,omitempty" xml:"DriveId,omitempty"`
	Expiration        *string `json:"Expiration,omitempty" xml:"Expiration,omitempty"`
	Expired           *bool   `json:"Expired,omitempty" xml:"Expired,omitempty"`
	FileIds           *string `json:"FileIds,omitempty" xml:"FileIds,omitempty"`
	ModifiyTime       *string `json:"ModifiyTime,omitempty" xml:"ModifiyTime,omitempty"`
	PreviewCount      *int64  `json:"PreviewCount,omitempty" xml:"PreviewCount,omitempty"`
	PreviewLimit      *int64  `json:"PreviewLimit,omitempty" xml:"PreviewLimit,omitempty"`
	ReportCount       *int64  `json:"ReportCount,omitempty" xml:"ReportCount,omitempty"`
	SaveCount         *int64  `json:"SaveCount,omitempty" xml:"SaveCount,omitempty"`
	SaveLimit         *int64  `json:"SaveLimit,omitempty" xml:"SaveLimit,omitempty"`
	ShareId           *string `json:"ShareId,omitempty" xml:"ShareId,omitempty"`
	ShareLink         *string `json:"ShareLink,omitempty" xml:"ShareLink,omitempty"`
	ShareName         *string `json:"ShareName,omitempty" xml:"ShareName,omitempty"`
	SharePwd          *string `json:"SharePwd,omitempty" xml:"SharePwd,omitempty"`
	Status            *string `json:"Status,omitempty" xml:"Status,omitempty"`
	VideoPreviewCount *int64  `json:"VideoPreviewCount,omitempty" xml:"VideoPreviewCount,omitempty"`
}

func (s CdsFileShareLinkModel) String() string {
	return tea.Prettify(s)
}

func (s CdsFileShareLinkModel) GoString() string {
	return s.String()
}

func (s *CdsFileShareLinkModel) SetAccessCount(v int64) *CdsFileShareLinkModel {
	s.AccessCount = &v
	return s
}

func (s *CdsFileShareLinkModel) SetCreateTime(v string) *CdsFileShareLinkModel {
	s.CreateTime = &v
	return s
}

func (s *CdsFileShareLinkModel) SetCreator(v string) *CdsFileShareLinkModel {
	s.Creator = &v
	return s
}

func (s *CdsFileShareLinkModel) SetDescription(v string) *CdsFileShareLinkModel {
	s.Description = &v
	return s
}

func (s *CdsFileShareLinkModel) SetDisableDownload(v bool) *CdsFileShareLinkModel {
	s.DisableDownload = &v
	return s
}

func (s *CdsFileShareLinkModel) SetDisablePreview(v bool) *CdsFileShareLinkModel {
	s.DisablePreview = &v
	return s
}

func (s *CdsFileShareLinkModel) SetDisableSave(v bool) *CdsFileShareLinkModel {
	s.DisableSave = &v
	return s
}

func (s *CdsFileShareLinkModel) SetDownloadCount(v int64) *CdsFileShareLinkModel {
	s.DownloadCount = &v
	return s
}

func (s *CdsFileShareLinkModel) SetDownloadLimit(v int64) *CdsFileShareLinkModel {
	s.DownloadLimit = &v
	return s
}

func (s *CdsFileShareLinkModel) SetDriveId(v string) *CdsFileShareLinkModel {
	s.DriveId = &v
	return s
}

func (s *CdsFileShareLinkModel) SetExpiration(v string) *CdsFileShareLinkModel {
	s.Expiration = &v
	return s
}

func (s *CdsFileShareLinkModel) SetExpired(v bool) *CdsFileShareLinkModel {
	s.Expired = &v
	return s
}

func (s *CdsFileShareLinkModel) SetFileIds(v string) *CdsFileShareLinkModel {
	s.FileIds = &v
	return s
}

func (s *CdsFileShareLinkModel) SetModifiyTime(v string) *CdsFileShareLinkModel {
	s.ModifiyTime = &v
	return s
}

func (s *CdsFileShareLinkModel) SetPreviewCount(v int64) *CdsFileShareLinkModel {
	s.PreviewCount = &v
	return s
}

func (s *CdsFileShareLinkModel) SetPreviewLimit(v int64) *CdsFileShareLinkModel {
	s.PreviewLimit = &v
	return s
}

func (s *CdsFileShareLinkModel) SetReportCount(v int64) *CdsFileShareLinkModel {
	s.ReportCount = &v
	return s
}

func (s *CdsFileShareLinkModel) SetSaveCount(v int64) *CdsFileShareLinkModel {
	s.SaveCount = &v
	return s
}

func (s *CdsFileShareLinkModel) SetSaveLimit(v int64) *CdsFileShareLinkModel {
	s.SaveLimit = &v
	return s
}

func (s *CdsFileShareLinkModel) SetShareId(v string) *CdsFileShareLinkModel {
	s.ShareId = &v
	return s
}

func (s *CdsFileShareLinkModel) SetShareLink(v string) *CdsFileShareLinkModel {
	s.ShareLink = &v
	return s
}

func (s *CdsFileShareLinkModel) SetShareName(v string) *CdsFileShareLinkModel {
	s.ShareName = &v
	return s
}

func (s *CdsFileShareLinkModel) SetSharePwd(v string) *CdsFileShareLinkModel {
	s.SharePwd = &v
	return s
}

func (s *CdsFileShareLinkModel) SetStatus(v string) *CdsFileShareLinkModel {
	s.Status = &v
	return s
}

func (s *CdsFileShareLinkModel) SetVideoPreviewCount(v int64) *CdsFileShareLinkModel {
	s.VideoPreviewCount = &v
	return s
}

type FilePermissionMember struct {
	CdsIdentity        *FilePermissionMemberCdsIdentity `json:"CdsIdentity,omitempty" xml:"CdsIdentity,omitempty" type:"Struct"`
	DisinheritSubGroup *bool                            `json:"DisinheritSubGroup,omitempty" xml:"DisinheritSubGroup,omitempty"`
	ExpireTime         *int64                           `json:"ExpireTime,omitempty" xml:"ExpireTime,omitempty"`
	RoleId             *string                          `json:"RoleId,omitempty" xml:"RoleId,omitempty"`
}

func (s FilePermissionMember) String() string {
	return tea.Prettify(s)
}

func (s FilePermissionMember) GoString() string {
	return s.String()
}

func (s *FilePermissionMember) SetCdsIdentity(v *FilePermissionMemberCdsIdentity) *FilePermissionMember {
	s.CdsIdentity = v
	return s
}

func (s *FilePermissionMember) SetDisinheritSubGroup(v bool) *FilePermissionMember {
	s.DisinheritSubGroup = &v
	return s
}

func (s *FilePermissionMember) SetExpireTime(v int64) *FilePermissionMember {
	s.ExpireTime = &v
	return s
}

func (s *FilePermissionMember) SetRoleId(v string) *FilePermissionMember {
	s.RoleId = &v
	return s
}

type FilePermissionMemberCdsIdentity struct {
	Id   *string `json:"Id,omitempty" xml:"Id,omitempty"`
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s FilePermissionMemberCdsIdentity) String() string {
	return tea.Prettify(s)
}

func (s FilePermissionMemberCdsIdentity) GoString() string {
	return s.String()
}

func (s *FilePermissionMemberCdsIdentity) SetId(v string) *FilePermissionMemberCdsIdentity {
	s.Id = &v
	return s
}

func (s *FilePermissionMemberCdsIdentity) SetType(v string) *FilePermissionMemberCdsIdentity {
	s.Type = &v
	return s
}

type ActivateOfficeSiteRequest struct {
	// The ID of the convenience workspace that is locked.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ActivateOfficeSiteRequest) String() string {
	return tea.Prettify(s)
}

func (s ActivateOfficeSiteRequest) GoString() string {
	return s.String()
}

func (s *ActivateOfficeSiteRequest) SetOfficeSiteId(v string) *ActivateOfficeSiteRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *ActivateOfficeSiteRequest) SetRegionId(v string) *ActivateOfficeSiteRequest {
	s.RegionId = &v
	return s
}

type ActivateOfficeSiteResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ActivateOfficeSiteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ActivateOfficeSiteResponseBody) GoString() string {
	return s.String()
}

func (s *ActivateOfficeSiteResponseBody) SetRequestId(v string) *ActivateOfficeSiteResponseBody {
	s.RequestId = &v
	return s
}

type ActivateOfficeSiteResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ActivateOfficeSiteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ActivateOfficeSiteResponse) String() string {
	return tea.Prettify(s)
}

func (s ActivateOfficeSiteResponse) GoString() string {
	return s.String()
}

func (s *ActivateOfficeSiteResponse) SetHeaders(v map[string]*string) *ActivateOfficeSiteResponse {
	s.Headers = v
	return s
}

func (s *ActivateOfficeSiteResponse) SetStatusCode(v int32) *ActivateOfficeSiteResponse {
	s.StatusCode = &v
	return s
}

func (s *ActivateOfficeSiteResponse) SetBody(v *ActivateOfficeSiteResponseBody) *ActivateOfficeSiteResponse {
	s.Body = v
	return s
}

type AddDesktopOversoldUserGroupRequest struct {
	ImageId         *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	Name            *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OversoldGroupId *string `json:"OversoldGroupId,omitempty" xml:"OversoldGroupId,omitempty"`
	PolicyGroupId   *string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty"`
}

func (s AddDesktopOversoldUserGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s AddDesktopOversoldUserGroupRequest) GoString() string {
	return s.String()
}

func (s *AddDesktopOversoldUserGroupRequest) SetImageId(v string) *AddDesktopOversoldUserGroupRequest {
	s.ImageId = &v
	return s
}

func (s *AddDesktopOversoldUserGroupRequest) SetName(v string) *AddDesktopOversoldUserGroupRequest {
	s.Name = &v
	return s
}

func (s *AddDesktopOversoldUserGroupRequest) SetOversoldGroupId(v string) *AddDesktopOversoldUserGroupRequest {
	s.OversoldGroupId = &v
	return s
}

func (s *AddDesktopOversoldUserGroupRequest) SetPolicyGroupId(v string) *AddDesktopOversoldUserGroupRequest {
	s.PolicyGroupId = &v
	return s
}

type AddDesktopOversoldUserGroupResponseBody struct {
	Data      *AddDesktopOversoldUserGroupResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	RequestId *string                                      `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddDesktopOversoldUserGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddDesktopOversoldUserGroupResponseBody) GoString() string {
	return s.String()
}

func (s *AddDesktopOversoldUserGroupResponseBody) SetData(v *AddDesktopOversoldUserGroupResponseBodyData) *AddDesktopOversoldUserGroupResponseBody {
	s.Data = v
	return s
}

func (s *AddDesktopOversoldUserGroupResponseBody) SetRequestId(v string) *AddDesktopOversoldUserGroupResponseBody {
	s.RequestId = &v
	return s
}

type AddDesktopOversoldUserGroupResponseBodyData struct {
	UserGroupId *string `json:"UserGroupId,omitempty" xml:"UserGroupId,omitempty"`
}

func (s AddDesktopOversoldUserGroupResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s AddDesktopOversoldUserGroupResponseBodyData) GoString() string {
	return s.String()
}

func (s *AddDesktopOversoldUserGroupResponseBodyData) SetUserGroupId(v string) *AddDesktopOversoldUserGroupResponseBodyData {
	s.UserGroupId = &v
	return s
}

type AddDesktopOversoldUserGroupResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddDesktopOversoldUserGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddDesktopOversoldUserGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s AddDesktopOversoldUserGroupResponse) GoString() string {
	return s.String()
}

func (s *AddDesktopOversoldUserGroupResponse) SetHeaders(v map[string]*string) *AddDesktopOversoldUserGroupResponse {
	s.Headers = v
	return s
}

func (s *AddDesktopOversoldUserGroupResponse) SetStatusCode(v int32) *AddDesktopOversoldUserGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *AddDesktopOversoldUserGroupResponse) SetBody(v *AddDesktopOversoldUserGroupResponseBody) *AddDesktopOversoldUserGroupResponse {
	s.Body = v
	return s
}

type AddDevicesRequest struct {
	// The type of the Alibaba Cloud Workspace client that runs on the device.
	//
	// *   1: the hardware client
	// *   2: the software client
	ClientType *int32 `json:"ClientType,omitempty" xml:"ClientType,omitempty"`
	// The list of devices.
	DeviceIds []*string `json:"DeviceIds,omitempty" xml:"DeviceIds,omitempty" type:"Repeated"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s AddDevicesRequest) String() string {
	return tea.Prettify(s)
}

func (s AddDevicesRequest) GoString() string {
	return s.String()
}

func (s *AddDevicesRequest) SetClientType(v int32) *AddDevicesRequest {
	s.ClientType = &v
	return s
}

func (s *AddDevicesRequest) SetDeviceIds(v []*string) *AddDevicesRequest {
	s.DeviceIds = v
	return s
}

func (s *AddDevicesRequest) SetRegionId(v string) *AddDevicesRequest {
	s.RegionId = &v
	return s
}

type AddDevicesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddDevicesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddDevicesResponseBody) GoString() string {
	return s.String()
}

func (s *AddDevicesResponseBody) SetRequestId(v string) *AddDevicesResponseBody {
	s.RequestId = &v
	return s
}

type AddDevicesResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddDevicesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddDevicesResponse) String() string {
	return tea.Prettify(s)
}

func (s AddDevicesResponse) GoString() string {
	return s.String()
}

func (s *AddDevicesResponse) SetHeaders(v map[string]*string) *AddDevicesResponse {
	s.Headers = v
	return s
}

func (s *AddDevicesResponse) SetStatusCode(v int32) *AddDevicesResponse {
	s.StatusCode = &v
	return s
}

func (s *AddDevicesResponse) SetBody(v *AddDevicesResponseBody) *AddDevicesResponse {
	s.Body = v
	return s
}

type AddFilePermissionRequest struct {
	// The ID of the cloud disk whose folder you want to share.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	// The ID of the end user who uses the cloud disk.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The ID of the file.
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The group ID.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The members who are granted the folder permissions.
	MemberList []*AddFilePermissionRequestMemberList `json:"MemberList,omitempty" xml:"MemberList,omitempty" type:"Repeated"`
	// The region ID of the folder. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s AddFilePermissionRequest) String() string {
	return tea.Prettify(s)
}

func (s AddFilePermissionRequest) GoString() string {
	return s.String()
}

func (s *AddFilePermissionRequest) SetCdsId(v string) *AddFilePermissionRequest {
	s.CdsId = &v
	return s
}

func (s *AddFilePermissionRequest) SetEndUserId(v string) *AddFilePermissionRequest {
	s.EndUserId = &v
	return s
}

func (s *AddFilePermissionRequest) SetFileId(v string) *AddFilePermissionRequest {
	s.FileId = &v
	return s
}

func (s *AddFilePermissionRequest) SetGroupId(v string) *AddFilePermissionRequest {
	s.GroupId = &v
	return s
}

func (s *AddFilePermissionRequest) SetMemberList(v []*AddFilePermissionRequestMemberList) *AddFilePermissionRequest {
	s.MemberList = v
	return s
}

func (s *AddFilePermissionRequest) SetRegionId(v string) *AddFilePermissionRequest {
	s.RegionId = &v
	return s
}

type AddFilePermissionRequestMemberList struct {
	// The user of the cloud disk.
	CdsIdentity *AddFilePermissionRequestMemberListCdsIdentity `json:"CdsIdentity,omitempty" xml:"CdsIdentity,omitempty" type:"Struct"`
	// Specifies whether the users of the child group can inherit the folder permissions.
	DisinheritSubGroup *bool `json:"DisinheritSubGroup,omitempty" xml:"DisinheritSubGroup,omitempty"`
	// The time when the authorization expires. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. The value never expires. You can specify a value that is predefined by the system for this parameter. Example: 4775500800000.
	ExpireTime *int64 `json:"ExpireTime,omitempty" xml:"ExpireTime,omitempty"`
	// The ID of the role to which you want to attach the folder permissions. To configure the folder permissions: you can specify a role or create custom operation permissions. You can use RoleId to specify a role. RoleId is mutually exclusive with ActionList. If you specify both of them, the value of RoleId takes precedence.
	//
	// Valid values:
	//
	// *   <!-- -->
	//
	//     SystemFileEditorWithoutShareLink
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	// *   <!-- -->
	//
	//     SystemFileUploaderAndDownloaderWithShareLink
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   <!-- -->
	//
	//     SystemFileDownloader
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   <!-- -->
	//
	//     SystemFileEditorWithoutDelete
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   <!-- -->
	//
	//     SystemFileOwner
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   <!-- -->
	//
	//     SystemFileDownloaderWithShareLink
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   <!-- -->
	//
	//     SystemFileUploaderAndViewer
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   <!-- -->
	//
	//     SystemFileViewer
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   <!-- -->
	//
	//     SystemFileEditor
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   <!-- -->
	//
	//     SystemFileUploaderWithShareLink
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   <!-- -->
	//
	//     SystemFileUploader
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   <!-- -->
	//
	//     SystemFileUploaderAndDownloader
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   <!-- -->
	//
	//     SystemFileMetaViewer
	//
	//     <!-- -->
	//
	//     <!-- -->
	RoleId *string `json:"RoleId,omitempty" xml:"RoleId,omitempty"`
}

func (s AddFilePermissionRequestMemberList) String() string {
	return tea.Prettify(s)
}

func (s AddFilePermissionRequestMemberList) GoString() string {
	return s.String()
}

func (s *AddFilePermissionRequestMemberList) SetCdsIdentity(v *AddFilePermissionRequestMemberListCdsIdentity) *AddFilePermissionRequestMemberList {
	s.CdsIdentity = v
	return s
}

func (s *AddFilePermissionRequestMemberList) SetDisinheritSubGroup(v bool) *AddFilePermissionRequestMemberList {
	s.DisinheritSubGroup = &v
	return s
}

func (s *AddFilePermissionRequestMemberList) SetExpireTime(v int64) *AddFilePermissionRequestMemberList {
	s.ExpireTime = &v
	return s
}

func (s *AddFilePermissionRequestMemberList) SetRoleId(v string) *AddFilePermissionRequestMemberList {
	s.RoleId = &v
	return s
}

type AddFilePermissionRequestMemberListCdsIdentity struct {
	// The ID of the user.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The type of the user.
	//
	// Valid values:
	//
	// *   <!-- -->
	//
	//     IT_Group
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   <!-- -->
	//
	//     IT_User
	//
	//     <!-- -->
	//
	//     <!-- -->
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s AddFilePermissionRequestMemberListCdsIdentity) String() string {
	return tea.Prettify(s)
}

func (s AddFilePermissionRequestMemberListCdsIdentity) GoString() string {
	return s.String()
}

func (s *AddFilePermissionRequestMemberListCdsIdentity) SetId(v string) *AddFilePermissionRequestMemberListCdsIdentity {
	s.Id = &v
	return s
}

func (s *AddFilePermissionRequestMemberListCdsIdentity) SetType(v string) *AddFilePermissionRequestMemberListCdsIdentity {
	s.Type = &v
	return s
}

type AddFilePermissionShrinkRequest struct {
	// The ID of the cloud disk whose folder you want to share.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	// The ID of the end user who uses the cloud disk.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The ID of the file.
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The group ID.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The members who are granted the folder permissions.
	MemberListShrink *string `json:"MemberList,omitempty" xml:"MemberList,omitempty"`
	// The region ID of the folder. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s AddFilePermissionShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s AddFilePermissionShrinkRequest) GoString() string {
	return s.String()
}

func (s *AddFilePermissionShrinkRequest) SetCdsId(v string) *AddFilePermissionShrinkRequest {
	s.CdsId = &v
	return s
}

func (s *AddFilePermissionShrinkRequest) SetEndUserId(v string) *AddFilePermissionShrinkRequest {
	s.EndUserId = &v
	return s
}

func (s *AddFilePermissionShrinkRequest) SetFileId(v string) *AddFilePermissionShrinkRequest {
	s.FileId = &v
	return s
}

func (s *AddFilePermissionShrinkRequest) SetGroupId(v string) *AddFilePermissionShrinkRequest {
	s.GroupId = &v
	return s
}

func (s *AddFilePermissionShrinkRequest) SetMemberListShrink(v string) *AddFilePermissionShrinkRequest {
	s.MemberListShrink = &v
	return s
}

func (s *AddFilePermissionShrinkRequest) SetRegionId(v string) *AddFilePermissionShrinkRequest {
	s.RegionId = &v
	return s
}

type AddFilePermissionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddFilePermissionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddFilePermissionResponseBody) GoString() string {
	return s.String()
}

func (s *AddFilePermissionResponseBody) SetRequestId(v string) *AddFilePermissionResponseBody {
	s.RequestId = &v
	return s
}

type AddFilePermissionResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddFilePermissionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddFilePermissionResponse) String() string {
	return tea.Prettify(s)
}

func (s AddFilePermissionResponse) GoString() string {
	return s.String()
}

func (s *AddFilePermissionResponse) SetHeaders(v map[string]*string) *AddFilePermissionResponse {
	s.Headers = v
	return s
}

func (s *AddFilePermissionResponse) SetStatusCode(v int32) *AddFilePermissionResponse {
	s.StatusCode = &v
	return s
}

func (s *AddFilePermissionResponse) SetBody(v *AddFilePermissionResponseBody) *AddFilePermissionResponse {
	s.Body = v
	return s
}

type AddUserToDesktopGroupRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request](~~25693~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the desktop group that you want to assign to more regular users.
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// The IDs of the desktop groups.
	DesktopGroupIds []*string `json:"DesktopGroupIds,omitempty" xml:"DesktopGroupIds,omitempty" type:"Repeated"`
	// The regular users to whom you want to assign the desktop group.
	EndUserIds []*string `json:"EndUserIds,omitempty" xml:"EndUserIds,omitempty" type:"Repeated"`
	// The ID of the region
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s AddUserToDesktopGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s AddUserToDesktopGroupRequest) GoString() string {
	return s.String()
}

func (s *AddUserToDesktopGroupRequest) SetClientToken(v string) *AddUserToDesktopGroupRequest {
	s.ClientToken = &v
	return s
}

func (s *AddUserToDesktopGroupRequest) SetDesktopGroupId(v string) *AddUserToDesktopGroupRequest {
	s.DesktopGroupId = &v
	return s
}

func (s *AddUserToDesktopGroupRequest) SetDesktopGroupIds(v []*string) *AddUserToDesktopGroupRequest {
	s.DesktopGroupIds = v
	return s
}

func (s *AddUserToDesktopGroupRequest) SetEndUserIds(v []*string) *AddUserToDesktopGroupRequest {
	s.EndUserIds = v
	return s
}

func (s *AddUserToDesktopGroupRequest) SetRegionId(v string) *AddUserToDesktopGroupRequest {
	s.RegionId = &v
	return s
}

type AddUserToDesktopGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddUserToDesktopGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddUserToDesktopGroupResponseBody) GoString() string {
	return s.String()
}

func (s *AddUserToDesktopGroupResponseBody) SetRequestId(v string) *AddUserToDesktopGroupResponseBody {
	s.RequestId = &v
	return s
}

type AddUserToDesktopGroupResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddUserToDesktopGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddUserToDesktopGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s AddUserToDesktopGroupResponse) GoString() string {
	return s.String()
}

func (s *AddUserToDesktopGroupResponse) SetHeaders(v map[string]*string) *AddUserToDesktopGroupResponse {
	s.Headers = v
	return s
}

func (s *AddUserToDesktopGroupResponse) SetStatusCode(v int32) *AddUserToDesktopGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *AddUserToDesktopGroupResponse) SetBody(v *AddUserToDesktopGroupResponseBody) *AddUserToDesktopGroupResponse {
	s.Body = v
	return s
}

type AddUserToDesktopOversoldUserGroupRequest struct {
	AddUserAmount   *int32  `json:"AddUserAmount,omitempty" xml:"AddUserAmount,omitempty"`
	EndUserId       *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	OversoldGroupId *string `json:"OversoldGroupId,omitempty" xml:"OversoldGroupId,omitempty"`
	UserGroupId     *string `json:"UserGroupId,omitempty" xml:"UserGroupId,omitempty"`
}

func (s AddUserToDesktopOversoldUserGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s AddUserToDesktopOversoldUserGroupRequest) GoString() string {
	return s.String()
}

func (s *AddUserToDesktopOversoldUserGroupRequest) SetAddUserAmount(v int32) *AddUserToDesktopOversoldUserGroupRequest {
	s.AddUserAmount = &v
	return s
}

func (s *AddUserToDesktopOversoldUserGroupRequest) SetEndUserId(v string) *AddUserToDesktopOversoldUserGroupRequest {
	s.EndUserId = &v
	return s
}

func (s *AddUserToDesktopOversoldUserGroupRequest) SetOversoldGroupId(v string) *AddUserToDesktopOversoldUserGroupRequest {
	s.OversoldGroupId = &v
	return s
}

func (s *AddUserToDesktopOversoldUserGroupRequest) SetUserGroupId(v string) *AddUserToDesktopOversoldUserGroupRequest {
	s.UserGroupId = &v
	return s
}

type AddUserToDesktopOversoldUserGroupResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddUserToDesktopOversoldUserGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddUserToDesktopOversoldUserGroupResponseBody) GoString() string {
	return s.String()
}

func (s *AddUserToDesktopOversoldUserGroupResponseBody) SetRequestId(v string) *AddUserToDesktopOversoldUserGroupResponseBody {
	s.RequestId = &v
	return s
}

type AddUserToDesktopOversoldUserGroupResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddUserToDesktopOversoldUserGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddUserToDesktopOversoldUserGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s AddUserToDesktopOversoldUserGroupResponse) GoString() string {
	return s.String()
}

func (s *AddUserToDesktopOversoldUserGroupResponse) SetHeaders(v map[string]*string) *AddUserToDesktopOversoldUserGroupResponse {
	s.Headers = v
	return s
}

func (s *AddUserToDesktopOversoldUserGroupResponse) SetStatusCode(v int32) *AddUserToDesktopOversoldUserGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *AddUserToDesktopOversoldUserGroupResponse) SetBody(v *AddUserToDesktopOversoldUserGroupResponseBody) *AddUserToDesktopOversoldUserGroupResponse {
	s.Body = v
	return s
}

type ApplyAutoSnapshotPolicyRequest struct {
	// The IDs of cloud desktops. You can specify 1 to 20 cloud desktops.
	DesktopId []*string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty" type:"Repeated"`
	// The ID of the automatic snapshot policy.
	PolicyId *string `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ApplyAutoSnapshotPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s ApplyAutoSnapshotPolicyRequest) GoString() string {
	return s.String()
}

func (s *ApplyAutoSnapshotPolicyRequest) SetDesktopId(v []*string) *ApplyAutoSnapshotPolicyRequest {
	s.DesktopId = v
	return s
}

func (s *ApplyAutoSnapshotPolicyRequest) SetPolicyId(v string) *ApplyAutoSnapshotPolicyRequest {
	s.PolicyId = &v
	return s
}

func (s *ApplyAutoSnapshotPolicyRequest) SetRegionId(v string) *ApplyAutoSnapshotPolicyRequest {
	s.RegionId = &v
	return s
}

type ApplyAutoSnapshotPolicyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ApplyAutoSnapshotPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ApplyAutoSnapshotPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *ApplyAutoSnapshotPolicyResponseBody) SetRequestId(v string) *ApplyAutoSnapshotPolicyResponseBody {
	s.RequestId = &v
	return s
}

type ApplyAutoSnapshotPolicyResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ApplyAutoSnapshotPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ApplyAutoSnapshotPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s ApplyAutoSnapshotPolicyResponse) GoString() string {
	return s.String()
}

func (s *ApplyAutoSnapshotPolicyResponse) SetHeaders(v map[string]*string) *ApplyAutoSnapshotPolicyResponse {
	s.Headers = v
	return s
}

func (s *ApplyAutoSnapshotPolicyResponse) SetStatusCode(v int32) *ApplyAutoSnapshotPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *ApplyAutoSnapshotPolicyResponse) SetBody(v *ApplyAutoSnapshotPolicyResponseBody) *ApplyAutoSnapshotPolicyResponse {
	s.Body = v
	return s
}

type ApplyCoordinatePrivilegeRequest struct {
	// The ID of the application for the coordinate permissions.
	CoId *string `json:"CoId,omitempty" xml:"CoId,omitempty"`
	// The ID of the end user.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The type of user who requires the coordinate permissions.
	//
	// Valid value: TENANT_ADMIN.
	UserType *string `json:"UserType,omitempty" xml:"UserType,omitempty"`
	// The unique identifier of the client. If you use an Alibaba Cloud Workspace client, click **About** on the client logon page to view the identifier of the client.
	Uuid *string `json:"Uuid,omitempty" xml:"Uuid,omitempty"`
}

func (s ApplyCoordinatePrivilegeRequest) String() string {
	return tea.Prettify(s)
}

func (s ApplyCoordinatePrivilegeRequest) GoString() string {
	return s.String()
}

func (s *ApplyCoordinatePrivilegeRequest) SetCoId(v string) *ApplyCoordinatePrivilegeRequest {
	s.CoId = &v
	return s
}

func (s *ApplyCoordinatePrivilegeRequest) SetEndUserId(v string) *ApplyCoordinatePrivilegeRequest {
	s.EndUserId = &v
	return s
}

func (s *ApplyCoordinatePrivilegeRequest) SetRegionId(v string) *ApplyCoordinatePrivilegeRequest {
	s.RegionId = &v
	return s
}

func (s *ApplyCoordinatePrivilegeRequest) SetUserType(v string) *ApplyCoordinatePrivilegeRequest {
	s.UserType = &v
	return s
}

func (s *ApplyCoordinatePrivilegeRequest) SetUuid(v string) *ApplyCoordinatePrivilegeRequest {
	s.Uuid = &v
	return s
}

type ApplyCoordinatePrivilegeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ApplyCoordinatePrivilegeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ApplyCoordinatePrivilegeResponseBody) GoString() string {
	return s.String()
}

func (s *ApplyCoordinatePrivilegeResponseBody) SetRequestId(v string) *ApplyCoordinatePrivilegeResponseBody {
	s.RequestId = &v
	return s
}

type ApplyCoordinatePrivilegeResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ApplyCoordinatePrivilegeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ApplyCoordinatePrivilegeResponse) String() string {
	return tea.Prettify(s)
}

func (s ApplyCoordinatePrivilegeResponse) GoString() string {
	return s.String()
}

func (s *ApplyCoordinatePrivilegeResponse) SetHeaders(v map[string]*string) *ApplyCoordinatePrivilegeResponse {
	s.Headers = v
	return s
}

func (s *ApplyCoordinatePrivilegeResponse) SetStatusCode(v int32) *ApplyCoordinatePrivilegeResponse {
	s.StatusCode = &v
	return s
}

func (s *ApplyCoordinatePrivilegeResponse) SetBody(v *ApplyCoordinatePrivilegeResponseBody) *ApplyCoordinatePrivilegeResponse {
	s.Body = v
	return s
}

type ApplyCoordinationForMonitoringRequest struct {
	// The coordination policy.
	//
	// Set the value to FULL_CONTROL.
	//
	// *   The value FULL_CONTROL specifies that the cloud desktop is shared and remote access to the cloud desktop is allowed.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	CoordinatePolicyType *string `json:"CoordinatePolicyType,omitempty" xml:"CoordinatePolicyType,omitempty"`
	// The ID of the end user who initiates the stream collaboration. If the initiator is the administrator, do not specify this parameter.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The type of the initiator.
	//
	// Set the value to ADMIN_INITIATE.
	//
	// *   The value ADMIN_INITIATE specifies that the administrator initiates the coordination request.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	InitiatorType *string `json:"InitiatorType,omitempty" xml:"InitiatorType,omitempty"`
	// The region ID. You can call the [DescribeRegions](https://next.api.aliyun.com/document/ecd/2020-09-30/DescribeRegions) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The list of cloud desktops that run the collaboration task at the same time.
	ResourceCandidates []*ApplyCoordinationForMonitoringRequestResourceCandidates `json:"ResourceCandidates,omitempty" xml:"ResourceCandidates,omitempty" type:"Repeated"`
	// The universally unique identifier (UUID) of the device.
	Uuid *string `json:"Uuid,omitempty" xml:"Uuid,omitempty"`
}

func (s ApplyCoordinationForMonitoringRequest) String() string {
	return tea.Prettify(s)
}

func (s ApplyCoordinationForMonitoringRequest) GoString() string {
	return s.String()
}

func (s *ApplyCoordinationForMonitoringRequest) SetCoordinatePolicyType(v string) *ApplyCoordinationForMonitoringRequest {
	s.CoordinatePolicyType = &v
	return s
}

func (s *ApplyCoordinationForMonitoringRequest) SetEndUserId(v string) *ApplyCoordinationForMonitoringRequest {
	s.EndUserId = &v
	return s
}

func (s *ApplyCoordinationForMonitoringRequest) SetInitiatorType(v string) *ApplyCoordinationForMonitoringRequest {
	s.InitiatorType = &v
	return s
}

func (s *ApplyCoordinationForMonitoringRequest) SetRegionId(v string) *ApplyCoordinationForMonitoringRequest {
	s.RegionId = &v
	return s
}

func (s *ApplyCoordinationForMonitoringRequest) SetResourceCandidates(v []*ApplyCoordinationForMonitoringRequestResourceCandidates) *ApplyCoordinationForMonitoringRequest {
	s.ResourceCandidates = v
	return s
}

func (s *ApplyCoordinationForMonitoringRequest) SetUuid(v string) *ApplyCoordinationForMonitoringRequest {
	s.Uuid = &v
	return s
}

type ApplyCoordinationForMonitoringRequestResourceCandidates struct {
	// The ID of the Alibaba Cloud account to which the current cloud desktop belongs.
	OwnerAliUid *int64 `json:"OwnerAliUid,omitempty" xml:"OwnerAliUid,omitempty"`
	// The ID of the current end user.
	OwnerEndUserId *string `json:"OwnerEndUserId,omitempty" xml:"OwnerEndUserId,omitempty"`
	// The ID of the cloud desktop.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The name of the cloud desktop.
	ResourceName *string `json:"ResourceName,omitempty" xml:"ResourceName,omitempty"`
	// The properties of the cloud desktop.
	ResourceProperties *string `json:"ResourceProperties,omitempty" xml:"ResourceProperties,omitempty"`
	// The region where the resource resides.
	ResourceRegionId *string `json:"ResourceRegionId,omitempty" xml:"ResourceRegionId,omitempty"`
	// The resource type.
	//
	// Set the value to CLOUD_DESKTOP.
	//
	// *   The value CLOUD_DESKTOP specifies that the resource is a cloud desktop.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s ApplyCoordinationForMonitoringRequestResourceCandidates) String() string {
	return tea.Prettify(s)
}

func (s ApplyCoordinationForMonitoringRequestResourceCandidates) GoString() string {
	return s.String()
}

func (s *ApplyCoordinationForMonitoringRequestResourceCandidates) SetOwnerAliUid(v int64) *ApplyCoordinationForMonitoringRequestResourceCandidates {
	s.OwnerAliUid = &v
	return s
}

func (s *ApplyCoordinationForMonitoringRequestResourceCandidates) SetOwnerEndUserId(v string) *ApplyCoordinationForMonitoringRequestResourceCandidates {
	s.OwnerEndUserId = &v
	return s
}

func (s *ApplyCoordinationForMonitoringRequestResourceCandidates) SetResourceId(v string) *ApplyCoordinationForMonitoringRequestResourceCandidates {
	s.ResourceId = &v
	return s
}

func (s *ApplyCoordinationForMonitoringRequestResourceCandidates) SetResourceName(v string) *ApplyCoordinationForMonitoringRequestResourceCandidates {
	s.ResourceName = &v
	return s
}

func (s *ApplyCoordinationForMonitoringRequestResourceCandidates) SetResourceProperties(v string) *ApplyCoordinationForMonitoringRequestResourceCandidates {
	s.ResourceProperties = &v
	return s
}

func (s *ApplyCoordinationForMonitoringRequestResourceCandidates) SetResourceRegionId(v string) *ApplyCoordinationForMonitoringRequestResourceCandidates {
	s.ResourceRegionId = &v
	return s
}

func (s *ApplyCoordinationForMonitoringRequestResourceCandidates) SetResourceType(v string) *ApplyCoordinationForMonitoringRequestResourceCandidates {
	s.ResourceType = &v
	return s
}

type ApplyCoordinationForMonitoringResponseBody struct {
	// The list of stream collaboration models.
	CoordinateFlowModels []*ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels `json:"CoordinateFlowModels,omitempty" xml:"CoordinateFlowModels,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ApplyCoordinationForMonitoringResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ApplyCoordinationForMonitoringResponseBody) GoString() string {
	return s.String()
}

func (s *ApplyCoordinationForMonitoringResponseBody) SetCoordinateFlowModels(v []*ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels) *ApplyCoordinationForMonitoringResponseBody {
	s.CoordinateFlowModels = v
	return s
}

func (s *ApplyCoordinationForMonitoringResponseBody) SetRequestId(v string) *ApplyCoordinationForMonitoringResponseBody {
	s.RequestId = &v
	return s
}

type ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels struct {
	// The ID of the stream collaboration.
	CoId *string `json:"CoId,omitempty" xml:"CoId,omitempty"`
	// The current status of the collaboration task.
	//
	// Valid values:
	//
	// *   COORDINATING
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The collaboration task is being executed
	//
	//     <!-- -->
	//
	//     .
	//
	// *   TERMINATING
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The collaboration task is being terminated
	//
	//     <!-- -->
	//
	//     .
	//
	// *   TERMINATED
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The collaboration task is terminated
	//
	//     <!-- -->
	//
	//     .
	//
	// *   PENDING
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The collaboration task is pending to be executed
	//
	//     <!-- -->
	//
	//     .
	CoordinateStatus *string `json:"CoordinateStatus,omitempty" xml:"CoordinateStatus,omitempty"`
	// The ticket that is used to establish the Adaptive Streaming Protocol (ASP)-based connection.
	CoordinateTicket *string `json:"CoordinateTicket,omitempty" xml:"CoordinateTicket,omitempty"`
	// The type of the initiator.
	//
	// Valid values:
	//
	// *   ADMIN_INITIATE_FORCE
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The administrator forcibly initiates the collaboration request
	//
	//     <!-- -->
	//
	//     .
	//
	// *   ADMIN_INITIATE
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The administrator initiates the collaboration request
	//
	//     <!-- -->
	//
	//     .
	//
	// *   COORDINATOR_INITIATE_FORCE
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The coordinator forcibly initiates the collaboration request
	//
	//     <!-- -->
	//
	//     .
	InitiatorType *string `json:"InitiatorType,omitempty" xml:"InitiatorType,omitempty"`
	// The ID of the Alibaba Cloud account of the end user.
	OwnerUserId *string `json:"OwnerUserId,omitempty" xml:"OwnerUserId,omitempty"`
	// The ID of the cloud desktop.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The name of the cloud desktop.
	ResourceName *string `json:"ResourceName,omitempty" xml:"ResourceName,omitempty"`
}

func (s ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels) String() string {
	return tea.Prettify(s)
}

func (s ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels) GoString() string {
	return s.String()
}

func (s *ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels) SetCoId(v string) *ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels {
	s.CoId = &v
	return s
}

func (s *ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels) SetCoordinateStatus(v string) *ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels {
	s.CoordinateStatus = &v
	return s
}

func (s *ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels) SetCoordinateTicket(v string) *ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels {
	s.CoordinateTicket = &v
	return s
}

func (s *ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels) SetInitiatorType(v string) *ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels {
	s.InitiatorType = &v
	return s
}

func (s *ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels) SetOwnerUserId(v string) *ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels {
	s.OwnerUserId = &v
	return s
}

func (s *ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels) SetResourceId(v string) *ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels {
	s.ResourceId = &v
	return s
}

func (s *ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels) SetResourceName(v string) *ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels {
	s.ResourceName = &v
	return s
}

type ApplyCoordinationForMonitoringResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ApplyCoordinationForMonitoringResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ApplyCoordinationForMonitoringResponse) String() string {
	return tea.Prettify(s)
}

func (s ApplyCoordinationForMonitoringResponse) GoString() string {
	return s.String()
}

func (s *ApplyCoordinationForMonitoringResponse) SetHeaders(v map[string]*string) *ApplyCoordinationForMonitoringResponse {
	s.Headers = v
	return s
}

func (s *ApplyCoordinationForMonitoringResponse) SetStatusCode(v int32) *ApplyCoordinationForMonitoringResponse {
	s.StatusCode = &v
	return s
}

func (s *ApplyCoordinationForMonitoringResponse) SetBody(v *ApplyCoordinationForMonitoringResponseBody) *ApplyCoordinationForMonitoringResponse {
	s.Body = v
	return s
}

type ApproveFotaUpdateRequest struct {
	// Mirror version.
	AppVersion *string `json:"AppVersion,omitempty" xml:"AppVersion,omitempty"`
	// The ID of the cloud desktop.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ApproveFotaUpdateRequest) String() string {
	return tea.Prettify(s)
}

func (s ApproveFotaUpdateRequest) GoString() string {
	return s.String()
}

func (s *ApproveFotaUpdateRequest) SetAppVersion(v string) *ApproveFotaUpdateRequest {
	s.AppVersion = &v
	return s
}

func (s *ApproveFotaUpdateRequest) SetDesktopId(v string) *ApproveFotaUpdateRequest {
	s.DesktopId = &v
	return s
}

func (s *ApproveFotaUpdateRequest) SetRegionId(v string) *ApproveFotaUpdateRequest {
	s.RegionId = &v
	return s
}

type ApproveFotaUpdateResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ApproveFotaUpdateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ApproveFotaUpdateResponseBody) GoString() string {
	return s.String()
}

func (s *ApproveFotaUpdateResponseBody) SetRequestId(v string) *ApproveFotaUpdateResponseBody {
	s.RequestId = &v
	return s
}

type ApproveFotaUpdateResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ApproveFotaUpdateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ApproveFotaUpdateResponse) String() string {
	return tea.Prettify(s)
}

func (s ApproveFotaUpdateResponse) GoString() string {
	return s.String()
}

func (s *ApproveFotaUpdateResponse) SetHeaders(v map[string]*string) *ApproveFotaUpdateResponse {
	s.Headers = v
	return s
}

func (s *ApproveFotaUpdateResponse) SetStatusCode(v int32) *ApproveFotaUpdateResponse {
	s.StatusCode = &v
	return s
}

func (s *ApproveFotaUpdateResponse) SetBody(v *ApproveFotaUpdateResponseBody) *ApproveFotaUpdateResponse {
	s.Body = v
	return s
}

type AssociateNetworkPackageRequest struct {
	// The ID of the Internet access package. You can call the [DescribeNetworkPackages](~~216079~~) operation to query the ID of the Internet access package.
	NetworkPackageId *string `json:"NetworkPackageId,omitempty" xml:"NetworkPackageId,omitempty"`
	// The ID of the workspace. You can call the [DescribeOfficeSites](~~216071~~) operation to query the ID of the workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s AssociateNetworkPackageRequest) String() string {
	return tea.Prettify(s)
}

func (s AssociateNetworkPackageRequest) GoString() string {
	return s.String()
}

func (s *AssociateNetworkPackageRequest) SetNetworkPackageId(v string) *AssociateNetworkPackageRequest {
	s.NetworkPackageId = &v
	return s
}

func (s *AssociateNetworkPackageRequest) SetOfficeSiteId(v string) *AssociateNetworkPackageRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *AssociateNetworkPackageRequest) SetRegionId(v string) *AssociateNetworkPackageRequest {
	s.RegionId = &v
	return s
}

type AssociateNetworkPackageResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AssociateNetworkPackageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AssociateNetworkPackageResponseBody) GoString() string {
	return s.String()
}

func (s *AssociateNetworkPackageResponseBody) SetRequestId(v string) *AssociateNetworkPackageResponseBody {
	s.RequestId = &v
	return s
}

type AssociateNetworkPackageResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AssociateNetworkPackageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AssociateNetworkPackageResponse) String() string {
	return tea.Prettify(s)
}

func (s AssociateNetworkPackageResponse) GoString() string {
	return s.String()
}

func (s *AssociateNetworkPackageResponse) SetHeaders(v map[string]*string) *AssociateNetworkPackageResponse {
	s.Headers = v
	return s
}

func (s *AssociateNetworkPackageResponse) SetStatusCode(v int32) *AssociateNetworkPackageResponse {
	s.StatusCode = &v
	return s
}

func (s *AssociateNetworkPackageResponse) SetBody(v *AssociateNetworkPackageResponseBody) *AssociateNetworkPackageResponse {
	s.Body = v
	return s
}

type AttachCenRequest struct {
	// The ID of the CEN instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The ID of the Alibaba Cloud account to which the CEN instance belongs.
	//
	// *   If the CEN instance specified by CenId belongs to the current Alibaba Cloud account, you can skip this parameter.
	// *   If the CEN instance specified by CenId belongs to another Alibaba Cloud account, you must specify this parameter.
	CenOwnerId *int64 `json:"CenOwnerId,omitempty" xml:"CenOwnerId,omitempty"`
	// The ID of the workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The region ID of the workspace.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The verification code. If the CEN instance that is specified by CenId belongs to another Alibaba Cloud account, you must call the SendVerifyCode operation to obtain the verification code.
	VerifyCode *string `json:"VerifyCode,omitempty" xml:"VerifyCode,omitempty"`
}

func (s AttachCenRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachCenRequest) GoString() string {
	return s.String()
}

func (s *AttachCenRequest) SetCenId(v string) *AttachCenRequest {
	s.CenId = &v
	return s
}

func (s *AttachCenRequest) SetCenOwnerId(v int64) *AttachCenRequest {
	s.CenOwnerId = &v
	return s
}

func (s *AttachCenRequest) SetOfficeSiteId(v string) *AttachCenRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *AttachCenRequest) SetRegionId(v string) *AttachCenRequest {
	s.RegionId = &v
	return s
}

func (s *AttachCenRequest) SetVerifyCode(v string) *AttachCenRequest {
	s.VerifyCode = &v
	return s
}

type AttachCenResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AttachCenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachCenResponseBody) GoString() string {
	return s.String()
}

func (s *AttachCenResponseBody) SetRequestId(v string) *AttachCenResponseBody {
	s.RequestId = &v
	return s
}

type AttachCenResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachCenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachCenResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachCenResponse) GoString() string {
	return s.String()
}

func (s *AttachCenResponse) SetHeaders(v map[string]*string) *AttachCenResponse {
	s.Headers = v
	return s
}

func (s *AttachCenResponse) SetStatusCode(v int32) *AttachCenResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachCenResponse) SetBody(v *AttachCenResponseBody) *AttachCenResponse {
	s.Body = v
	return s
}

type AttachEndUserRequest struct {
	// The address of the Active Directory (AD) workspace.
	AdDomain *string `json:"AdDomain,omitempty" xml:"AdDomain,omitempty"`
	// The type of the Alibaba Cloud Workspace client that runs on the device.
	//
	// *   1: the hardware client
	// *   2: the software client
	ClientType *int32 `json:"ClientType,omitempty" xml:"ClientType,omitempty"`
	// The ID of the device.
	DeviceId *string `json:"DeviceId,omitempty" xml:"DeviceId,omitempty"`
	// The ID of the workspace.
	DirectoryId *string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	// The ID of the user.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The account type of the user.
	//
	// *   SIMPLE: the convenience user
	// *   AD: the AD user
	UserType *string `json:"UserType,omitempty" xml:"UserType,omitempty"`
}

func (s AttachEndUserRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachEndUserRequest) GoString() string {
	return s.String()
}

func (s *AttachEndUserRequest) SetAdDomain(v string) *AttachEndUserRequest {
	s.AdDomain = &v
	return s
}

func (s *AttachEndUserRequest) SetClientType(v int32) *AttachEndUserRequest {
	s.ClientType = &v
	return s
}

func (s *AttachEndUserRequest) SetDeviceId(v string) *AttachEndUserRequest {
	s.DeviceId = &v
	return s
}

func (s *AttachEndUserRequest) SetDirectoryId(v string) *AttachEndUserRequest {
	s.DirectoryId = &v
	return s
}

func (s *AttachEndUserRequest) SetEndUserId(v string) *AttachEndUserRequest {
	s.EndUserId = &v
	return s
}

func (s *AttachEndUserRequest) SetRegionId(v string) *AttachEndUserRequest {
	s.RegionId = &v
	return s
}

func (s *AttachEndUserRequest) SetUserType(v string) *AttachEndUserRequest {
	s.UserType = &v
	return s
}

type AttachEndUserResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AttachEndUserResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachEndUserResponseBody) GoString() string {
	return s.String()
}

func (s *AttachEndUserResponseBody) SetRequestId(v string) *AttachEndUserResponseBody {
	s.RequestId = &v
	return s
}

type AttachEndUserResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachEndUserResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachEndUserResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachEndUserResponse) GoString() string {
	return s.String()
}

func (s *AttachEndUserResponse) SetHeaders(v map[string]*string) *AttachEndUserResponse {
	s.Headers = v
	return s
}

func (s *AttachEndUserResponse) SetStatusCode(v int32) *AttachEndUserResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachEndUserResponse) SetBody(v *AttachEndUserResponseBody) *AttachEndUserResponse {
	s.Body = v
	return s
}

type CancelAutoSnapshotPolicyRequest struct {
	// The IDs of the cloud desktops. Valid values of N: 1 to 50. You cannot leave this parameter empty. The value can be up to 64 characters in length and cannot start with acs: or aliyun. It cannot contain [http:// or https://.](http://https://)
	DesktopId []*string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty" type:"Repeated"`
	// The ID of the automatic snapshot policy.
	PolicyId *string `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The region ID of the automatic snapshot policy. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CancelAutoSnapshotPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s CancelAutoSnapshotPolicyRequest) GoString() string {
	return s.String()
}

func (s *CancelAutoSnapshotPolicyRequest) SetDesktopId(v []*string) *CancelAutoSnapshotPolicyRequest {
	s.DesktopId = v
	return s
}

func (s *CancelAutoSnapshotPolicyRequest) SetPolicyId(v string) *CancelAutoSnapshotPolicyRequest {
	s.PolicyId = &v
	return s
}

func (s *CancelAutoSnapshotPolicyRequest) SetRegionId(v string) *CancelAutoSnapshotPolicyRequest {
	s.RegionId = &v
	return s
}

type CancelAutoSnapshotPolicyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CancelAutoSnapshotPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CancelAutoSnapshotPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *CancelAutoSnapshotPolicyResponseBody) SetRequestId(v string) *CancelAutoSnapshotPolicyResponseBody {
	s.RequestId = &v
	return s
}

type CancelAutoSnapshotPolicyResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CancelAutoSnapshotPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CancelAutoSnapshotPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s CancelAutoSnapshotPolicyResponse) GoString() string {
	return s.String()
}

func (s *CancelAutoSnapshotPolicyResponse) SetHeaders(v map[string]*string) *CancelAutoSnapshotPolicyResponse {
	s.Headers = v
	return s
}

func (s *CancelAutoSnapshotPolicyResponse) SetStatusCode(v int32) *CancelAutoSnapshotPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelAutoSnapshotPolicyResponse) SetBody(v *CancelAutoSnapshotPolicyResponseBody) *CancelAutoSnapshotPolicyResponse {
	s.Body = v
	return s
}

type CancelCdsFileShareLinkRequest struct {
	// The ID of the cloud disk.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	// The ID of the file sharing task.
	ShareId *string `json:"ShareId,omitempty" xml:"ShareId,omitempty"`
}

func (s CancelCdsFileShareLinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CancelCdsFileShareLinkRequest) GoString() string {
	return s.String()
}

func (s *CancelCdsFileShareLinkRequest) SetCdsId(v string) *CancelCdsFileShareLinkRequest {
	s.CdsId = &v
	return s
}

func (s *CancelCdsFileShareLinkRequest) SetShareId(v string) *CancelCdsFileShareLinkRequest {
	s.ShareId = &v
	return s
}

type CancelCdsFileShareLinkResponseBody struct {
	// The operation result. The value success indicates that the operation is successful. If the operation failed, an error message is returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data information.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error message that is returned if the request failed. This parameter is not returned if the value of Code is `success`.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   false
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CancelCdsFileShareLinkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CancelCdsFileShareLinkResponseBody) GoString() string {
	return s.String()
}

func (s *CancelCdsFileShareLinkResponseBody) SetCode(v string) *CancelCdsFileShareLinkResponseBody {
	s.Code = &v
	return s
}

func (s *CancelCdsFileShareLinkResponseBody) SetData(v bool) *CancelCdsFileShareLinkResponseBody {
	s.Data = &v
	return s
}

func (s *CancelCdsFileShareLinkResponseBody) SetMessage(v string) *CancelCdsFileShareLinkResponseBody {
	s.Message = &v
	return s
}

func (s *CancelCdsFileShareLinkResponseBody) SetRequestId(v string) *CancelCdsFileShareLinkResponseBody {
	s.RequestId = &v
	return s
}

func (s *CancelCdsFileShareLinkResponseBody) SetSuccess(v bool) *CancelCdsFileShareLinkResponseBody {
	s.Success = &v
	return s
}

type CancelCdsFileShareLinkResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CancelCdsFileShareLinkResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CancelCdsFileShareLinkResponse) String() string {
	return tea.Prettify(s)
}

func (s CancelCdsFileShareLinkResponse) GoString() string {
	return s.String()
}

func (s *CancelCdsFileShareLinkResponse) SetHeaders(v map[string]*string) *CancelCdsFileShareLinkResponse {
	s.Headers = v
	return s
}

func (s *CancelCdsFileShareLinkResponse) SetStatusCode(v int32) *CancelCdsFileShareLinkResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelCdsFileShareLinkResponse) SetBody(v *CancelCdsFileShareLinkResponseBody) *CancelCdsFileShareLinkResponse {
	s.Body = v
	return s
}

type CancelCoordinationForMonitoringRequest struct {
	CoIds     []*string `json:"CoIds,omitempty" xml:"CoIds,omitempty" type:"Repeated"`
	EndUserId *string   `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	RegionId  *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	UserType  *string   `json:"UserType,omitempty" xml:"UserType,omitempty"`
}

func (s CancelCoordinationForMonitoringRequest) String() string {
	return tea.Prettify(s)
}

func (s CancelCoordinationForMonitoringRequest) GoString() string {
	return s.String()
}

func (s *CancelCoordinationForMonitoringRequest) SetCoIds(v []*string) *CancelCoordinationForMonitoringRequest {
	s.CoIds = v
	return s
}

func (s *CancelCoordinationForMonitoringRequest) SetEndUserId(v string) *CancelCoordinationForMonitoringRequest {
	s.EndUserId = &v
	return s
}

func (s *CancelCoordinationForMonitoringRequest) SetRegionId(v string) *CancelCoordinationForMonitoringRequest {
	s.RegionId = &v
	return s
}

func (s *CancelCoordinationForMonitoringRequest) SetUserType(v string) *CancelCoordinationForMonitoringRequest {
	s.UserType = &v
	return s
}

type CancelCoordinationForMonitoringResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CancelCoordinationForMonitoringResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CancelCoordinationForMonitoringResponseBody) GoString() string {
	return s.String()
}

func (s *CancelCoordinationForMonitoringResponseBody) SetRequestId(v string) *CancelCoordinationForMonitoringResponseBody {
	s.RequestId = &v
	return s
}

type CancelCoordinationForMonitoringResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CancelCoordinationForMonitoringResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CancelCoordinationForMonitoringResponse) String() string {
	return tea.Prettify(s)
}

func (s CancelCoordinationForMonitoringResponse) GoString() string {
	return s.String()
}

func (s *CancelCoordinationForMonitoringResponse) SetHeaders(v map[string]*string) *CancelCoordinationForMonitoringResponse {
	s.Headers = v
	return s
}

func (s *CancelCoordinationForMonitoringResponse) SetStatusCode(v int32) *CancelCoordinationForMonitoringResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelCoordinationForMonitoringResponse) SetBody(v *CancelCoordinationForMonitoringResponseBody) *CancelCoordinationForMonitoringResponse {
	s.Body = v
	return s
}

type CancelCopyImageRequest struct {
	// The ID of the image that is being copied.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CancelCopyImageRequest) String() string {
	return tea.Prettify(s)
}

func (s CancelCopyImageRequest) GoString() string {
	return s.String()
}

func (s *CancelCopyImageRequest) SetImageId(v string) *CancelCopyImageRequest {
	s.ImageId = &v
	return s
}

func (s *CancelCopyImageRequest) SetRegionId(v string) *CancelCopyImageRequest {
	s.RegionId = &v
	return s
}

type CancelCopyImageResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CancelCopyImageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CancelCopyImageResponseBody) GoString() string {
	return s.String()
}

func (s *CancelCopyImageResponseBody) SetRequestId(v string) *CancelCopyImageResponseBody {
	s.RequestId = &v
	return s
}

type CancelCopyImageResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CancelCopyImageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CancelCopyImageResponse) String() string {
	return tea.Prettify(s)
}

func (s CancelCopyImageResponse) GoString() string {
	return s.String()
}

func (s *CancelCopyImageResponse) SetHeaders(v map[string]*string) *CancelCopyImageResponse {
	s.Headers = v
	return s
}

func (s *CancelCopyImageResponse) SetStatusCode(v int32) *CancelCopyImageResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelCopyImageResponse) SetBody(v *CancelCopyImageResponseBody) *CancelCopyImageResponse {
	s.Body = v
	return s
}

type ClonePolicyGroupRequest struct {
	// The name of the policy.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the policy that you want to clone.
	PolicyGroupId *string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ClonePolicyGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ClonePolicyGroupRequest) GoString() string {
	return s.String()
}

func (s *ClonePolicyGroupRequest) SetName(v string) *ClonePolicyGroupRequest {
	s.Name = &v
	return s
}

func (s *ClonePolicyGroupRequest) SetPolicyGroupId(v string) *ClonePolicyGroupRequest {
	s.PolicyGroupId = &v
	return s
}

func (s *ClonePolicyGroupRequest) SetRegionId(v string) *ClonePolicyGroupRequest {
	s.RegionId = &v
	return s
}

type ClonePolicyGroupResponseBody struct {
	// The ID of the new policy.
	PolicyGroupId *string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ClonePolicyGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ClonePolicyGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ClonePolicyGroupResponseBody) SetPolicyGroupId(v string) *ClonePolicyGroupResponseBody {
	s.PolicyGroupId = &v
	return s
}

func (s *ClonePolicyGroupResponseBody) SetRequestId(v string) *ClonePolicyGroupResponseBody {
	s.RequestId = &v
	return s
}

type ClonePolicyGroupResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ClonePolicyGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ClonePolicyGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ClonePolicyGroupResponse) GoString() string {
	return s.String()
}

func (s *ClonePolicyGroupResponse) SetHeaders(v map[string]*string) *ClonePolicyGroupResponse {
	s.Headers = v
	return s
}

func (s *ClonePolicyGroupResponse) SetStatusCode(v int32) *ClonePolicyGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ClonePolicyGroupResponse) SetBody(v *ClonePolicyGroupResponseBody) *ClonePolicyGroupResponse {
	s.Body = v
	return s
}

type CompleteCdsFileRequest struct {
	// The ID of the cloud disk.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	// The name of the end user.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The file ID. An ID is the unique identifier of a file.
	FileId  *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The region ID. You can call the DescribeRegions operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the file uploading task.
	UploadId *string `json:"UploadId,omitempty" xml:"UploadId,omitempty"`
}

func (s CompleteCdsFileRequest) String() string {
	return tea.Prettify(s)
}

func (s CompleteCdsFileRequest) GoString() string {
	return s.String()
}

func (s *CompleteCdsFileRequest) SetCdsId(v string) *CompleteCdsFileRequest {
	s.CdsId = &v
	return s
}

func (s *CompleteCdsFileRequest) SetEndUserId(v string) *CompleteCdsFileRequest {
	s.EndUserId = &v
	return s
}

func (s *CompleteCdsFileRequest) SetFileId(v string) *CompleteCdsFileRequest {
	s.FileId = &v
	return s
}

func (s *CompleteCdsFileRequest) SetGroupId(v string) *CompleteCdsFileRequest {
	s.GroupId = &v
	return s
}

func (s *CompleteCdsFileRequest) SetRegionId(v string) *CompleteCdsFileRequest {
	s.RegionId = &v
	return s
}

func (s *CompleteCdsFileRequest) SetUploadId(v string) *CompleteCdsFileRequest {
	s.UploadId = &v
	return s
}

type CompleteCdsFileResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CompleteCdsFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CompleteCdsFileResponseBody) GoString() string {
	return s.String()
}

func (s *CompleteCdsFileResponseBody) SetRequestId(v string) *CompleteCdsFileResponseBody {
	s.RequestId = &v
	return s
}

type CompleteCdsFileResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CompleteCdsFileResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CompleteCdsFileResponse) String() string {
	return tea.Prettify(s)
}

func (s CompleteCdsFileResponse) GoString() string {
	return s.String()
}

func (s *CompleteCdsFileResponse) SetHeaders(v map[string]*string) *CompleteCdsFileResponse {
	s.Headers = v
	return s
}

func (s *CompleteCdsFileResponse) SetStatusCode(v int32) *CompleteCdsFileResponse {
	s.StatusCode = &v
	return s
}

func (s *CompleteCdsFileResponse) SetBody(v *CompleteCdsFileResponseBody) *CompleteCdsFileResponse {
	s.Body = v
	return s
}

type ConfigADConnectorTrustRequest struct {
	// The ID of the AD workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// Specifies whether to configure the trust password for the RDS license domain of the AD workspace.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     configures the trust password
	//
	//     <!-- -->
	//
	//     for the RDS license domain of the AD workspace.
	//
	// *   false
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     configures the trust password
	//
	//     <!-- -->
	//
	//     for common AD workspaces.
	RdsLicenseDomain *bool `json:"RdsLicenseDomain,omitempty" xml:"RdsLicenseDomain,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The trust password. You can specify the password when you configure a trust relationship between the AD domain and the ecd.acs domain.
	TrustKey *string `json:"TrustKey,omitempty" xml:"TrustKey,omitempty"`
}

func (s ConfigADConnectorTrustRequest) String() string {
	return tea.Prettify(s)
}

func (s ConfigADConnectorTrustRequest) GoString() string {
	return s.String()
}

func (s *ConfigADConnectorTrustRequest) SetOfficeSiteId(v string) *ConfigADConnectorTrustRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *ConfigADConnectorTrustRequest) SetRdsLicenseDomain(v bool) *ConfigADConnectorTrustRequest {
	s.RdsLicenseDomain = &v
	return s
}

func (s *ConfigADConnectorTrustRequest) SetRegionId(v string) *ConfigADConnectorTrustRequest {
	s.RegionId = &v
	return s
}

func (s *ConfigADConnectorTrustRequest) SetTrustKey(v string) *ConfigADConnectorTrustRequest {
	s.TrustKey = &v
	return s
}

type ConfigADConnectorTrustResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ConfigADConnectorTrustResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ConfigADConnectorTrustResponseBody) GoString() string {
	return s.String()
}

func (s *ConfigADConnectorTrustResponseBody) SetRequestId(v string) *ConfigADConnectorTrustResponseBody {
	s.RequestId = &v
	return s
}

type ConfigADConnectorTrustResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ConfigADConnectorTrustResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ConfigADConnectorTrustResponse) String() string {
	return tea.Prettify(s)
}

func (s ConfigADConnectorTrustResponse) GoString() string {
	return s.String()
}

func (s *ConfigADConnectorTrustResponse) SetHeaders(v map[string]*string) *ConfigADConnectorTrustResponse {
	s.Headers = v
	return s
}

func (s *ConfigADConnectorTrustResponse) SetStatusCode(v int32) *ConfigADConnectorTrustResponse {
	s.StatusCode = &v
	return s
}

func (s *ConfigADConnectorTrustResponse) SetBody(v *ConfigADConnectorTrustResponseBody) *ConfigADConnectorTrustResponse {
	s.Body = v
	return s
}

type ConfigADConnectorUserRequest struct {
	// The password of the AD user that has the permissions to join computers to domains.
	DomainPassword *string `json:"DomainPassword,omitempty" xml:"DomainPassword,omitempty"`
	// The username of the AD user that has the permissions to join computers to domains.
	//
	// After the username is configured, the cloud desktops in the same AD workspace are joined to the specified OU.
	DomainUserName *string `json:"DomainUserName,omitempty" xml:"DomainUserName,omitempty"`
	// The name of the OU in the AD domain. You can call the [ListUserAdOrganizationUnits](~~311259~~) to obtain the OU name.
	OUName *string `json:"OUName,omitempty" xml:"OUName,omitempty"`
	// The ID of the AD workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ConfigADConnectorUserRequest) String() string {
	return tea.Prettify(s)
}

func (s ConfigADConnectorUserRequest) GoString() string {
	return s.String()
}

func (s *ConfigADConnectorUserRequest) SetDomainPassword(v string) *ConfigADConnectorUserRequest {
	s.DomainPassword = &v
	return s
}

func (s *ConfigADConnectorUserRequest) SetDomainUserName(v string) *ConfigADConnectorUserRequest {
	s.DomainUserName = &v
	return s
}

func (s *ConfigADConnectorUserRequest) SetOUName(v string) *ConfigADConnectorUserRequest {
	s.OUName = &v
	return s
}

func (s *ConfigADConnectorUserRequest) SetOfficeSiteId(v string) *ConfigADConnectorUserRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *ConfigADConnectorUserRequest) SetRegionId(v string) *ConfigADConnectorUserRequest {
	s.RegionId = &v
	return s
}

type ConfigADConnectorUserResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ConfigADConnectorUserResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ConfigADConnectorUserResponseBody) GoString() string {
	return s.String()
}

func (s *ConfigADConnectorUserResponseBody) SetRequestId(v string) *ConfigADConnectorUserResponseBody {
	s.RequestId = &v
	return s
}

type ConfigADConnectorUserResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ConfigADConnectorUserResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ConfigADConnectorUserResponse) String() string {
	return tea.Prettify(s)
}

func (s ConfigADConnectorUserResponse) GoString() string {
	return s.String()
}

func (s *ConfigADConnectorUserResponse) SetHeaders(v map[string]*string) *ConfigADConnectorUserResponse {
	s.Headers = v
	return s
}

func (s *ConfigADConnectorUserResponse) SetStatusCode(v int32) *ConfigADConnectorUserResponse {
	s.StatusCode = &v
	return s
}

func (s *ConfigADConnectorUserResponse) SetBody(v *ConfigADConnectorUserResponseBody) *ConfigADConnectorUserResponse {
	s.Body = v
	return s
}

type CopyCdsFileRequest struct {
	// Specifies whether to automatically rename the file if a file that has the same name exists in the folder to which you want to copy the file. Default value: false.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   false
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	AutoRename *bool `json:"AutoRename,omitempty" xml:"AutoRename,omitempty"`
	// The ID of the cloud disk.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	// The user ID that you want to use to access the cloud disk.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The file ID. You can call the CreateCdsFile operation to query the file ID.
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// IDUserIdDescribeCloudDriveUsersIDGroupIdDescribeCloudDriveGroups
	// > FileReceiverIdFileReceiverType
	// >
	FileReceiverId *string `json:"FileReceiverId,omitempty" xml:"FileReceiverId,omitempty"`
	// 
	FileReceiverType *string `json:"FileReceiverType,omitempty" xml:"FileReceiverType,omitempty"`
	GroupId          *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the parent folder of the folder to which you want to copy the file. If you want to copy the file to the root directory, set this parameter to root.
	ParentFolderId *string `json:"ParentFolderId,omitempty" xml:"ParentFolderId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CopyCdsFileRequest) String() string {
	return tea.Prettify(s)
}

func (s CopyCdsFileRequest) GoString() string {
	return s.String()
}

func (s *CopyCdsFileRequest) SetAutoRename(v bool) *CopyCdsFileRequest {
	s.AutoRename = &v
	return s
}

func (s *CopyCdsFileRequest) SetCdsId(v string) *CopyCdsFileRequest {
	s.CdsId = &v
	return s
}

func (s *CopyCdsFileRequest) SetEndUserId(v string) *CopyCdsFileRequest {
	s.EndUserId = &v
	return s
}

func (s *CopyCdsFileRequest) SetFileId(v string) *CopyCdsFileRequest {
	s.FileId = &v
	return s
}

func (s *CopyCdsFileRequest) SetFileReceiverId(v string) *CopyCdsFileRequest {
	s.FileReceiverId = &v
	return s
}

func (s *CopyCdsFileRequest) SetFileReceiverType(v string) *CopyCdsFileRequest {
	s.FileReceiverType = &v
	return s
}

func (s *CopyCdsFileRequest) SetGroupId(v string) *CopyCdsFileRequest {
	s.GroupId = &v
	return s
}

func (s *CopyCdsFileRequest) SetParentFolderId(v string) *CopyCdsFileRequest {
	s.ParentFolderId = &v
	return s
}

func (s *CopyCdsFileRequest) SetRegionId(v string) *CopyCdsFileRequest {
	s.RegionId = &v
	return s
}

type CopyCdsFileResponseBody struct {
	// The operation result. The value success indicates that the operation is successful. If the operation failed, an error message is returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details about the file copying.
	CopyCdsFileModel *CopyCdsFileResponseBodyCopyCdsFileModel `json:"CopyCdsFileModel,omitempty" xml:"CopyCdsFileModel,omitempty" type:"Struct"`
	// The error message that is returned. This parameter is not returned if the value of Code is success.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   false
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CopyCdsFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CopyCdsFileResponseBody) GoString() string {
	return s.String()
}

func (s *CopyCdsFileResponseBody) SetCode(v string) *CopyCdsFileResponseBody {
	s.Code = &v
	return s
}

func (s *CopyCdsFileResponseBody) SetCopyCdsFileModel(v *CopyCdsFileResponseBodyCopyCdsFileModel) *CopyCdsFileResponseBody {
	s.CopyCdsFileModel = v
	return s
}

func (s *CopyCdsFileResponseBody) SetMessage(v string) *CopyCdsFileResponseBody {
	s.Message = &v
	return s
}

func (s *CopyCdsFileResponseBody) SetRequestId(v string) *CopyCdsFileResponseBody {
	s.RequestId = &v
	return s
}

func (s *CopyCdsFileResponseBody) SetSuccess(v string) *CopyCdsFileResponseBody {
	s.Success = &v
	return s
}

type CopyCdsFileResponseBodyCopyCdsFileModel struct {
	// The ID of the asynchronous task. This parameter is not returned if you copy a file. This parameter is returned if you copy a folder in the backend in an asynchronous manner. You can call the GetAsyncTask operation to obtain the ID and details of an asynchronous task.
	AsyncTaskId *string `json:"AsyncTaskId,omitempty" xml:"AsyncTaskId,omitempty"`
	// The ID of the copied file or folder.
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
}

func (s CopyCdsFileResponseBodyCopyCdsFileModel) String() string {
	return tea.Prettify(s)
}

func (s CopyCdsFileResponseBodyCopyCdsFileModel) GoString() string {
	return s.String()
}

func (s *CopyCdsFileResponseBodyCopyCdsFileModel) SetAsyncTaskId(v string) *CopyCdsFileResponseBodyCopyCdsFileModel {
	s.AsyncTaskId = &v
	return s
}

func (s *CopyCdsFileResponseBodyCopyCdsFileModel) SetFileId(v string) *CopyCdsFileResponseBodyCopyCdsFileModel {
	s.FileId = &v
	return s
}

type CopyCdsFileResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CopyCdsFileResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CopyCdsFileResponse) String() string {
	return tea.Prettify(s)
}

func (s CopyCdsFileResponse) GoString() string {
	return s.String()
}

func (s *CopyCdsFileResponse) SetHeaders(v map[string]*string) *CopyCdsFileResponse {
	s.Headers = v
	return s
}

func (s *CopyCdsFileResponse) SetStatusCode(v int32) *CopyCdsFileResponse {
	s.StatusCode = &v
	return s
}

func (s *CopyCdsFileResponse) SetBody(v *CopyCdsFileResponseBody) *CopyCdsFileResponse {
	s.Body = v
	return s
}

type CopyImageRequest struct {
	DestinationDescription *string `json:"DestinationDescription,omitempty" xml:"DestinationDescription,omitempty"`
	DestinationImageName   *string `json:"DestinationImageName,omitempty" xml:"DestinationImageName,omitempty"`
	DestinationRegionId    *string `json:"DestinationRegionId,omitempty" xml:"DestinationRegionId,omitempty"`
	ImageId                *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	RegionId               *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CopyImageRequest) String() string {
	return tea.Prettify(s)
}

func (s CopyImageRequest) GoString() string {
	return s.String()
}

func (s *CopyImageRequest) SetDestinationDescription(v string) *CopyImageRequest {
	s.DestinationDescription = &v
	return s
}

func (s *CopyImageRequest) SetDestinationImageName(v string) *CopyImageRequest {
	s.DestinationImageName = &v
	return s
}

func (s *CopyImageRequest) SetDestinationRegionId(v string) *CopyImageRequest {
	s.DestinationRegionId = &v
	return s
}

func (s *CopyImageRequest) SetImageId(v string) *CopyImageRequest {
	s.ImageId = &v
	return s
}

func (s *CopyImageRequest) SetRegionId(v string) *CopyImageRequest {
	s.RegionId = &v
	return s
}

type CopyImageResponseBody struct {
	ImageId   *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CopyImageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CopyImageResponseBody) GoString() string {
	return s.String()
}

func (s *CopyImageResponseBody) SetImageId(v string) *CopyImageResponseBody {
	s.ImageId = &v
	return s
}

func (s *CopyImageResponseBody) SetRequestId(v string) *CopyImageResponseBody {
	s.RequestId = &v
	return s
}

type CopyImageResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CopyImageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CopyImageResponse) String() string {
	return tea.Prettify(s)
}

func (s CopyImageResponse) GoString() string {
	return s.String()
}

func (s *CopyImageResponse) SetHeaders(v map[string]*string) *CopyImageResponse {
	s.Headers = v
	return s
}

func (s *CopyImageResponse) SetStatusCode(v int32) *CopyImageResponse {
	s.StatusCode = &v
	return s
}

func (s *CopyImageResponse) SetBody(v *CopyImageResponseBody) *CopyImageResponse {
	s.Body = v
	return s
}

type CreateADConnectorDirectoryRequest struct {
	// The method that is used to connect the client to cloud desktops.
	DesktopAccessType *string `json:"DesktopAccessType,omitempty" xml:"DesktopAccessType,omitempty"`
	// The name of the AD directory. The name must be 2 to 255 characters in length, and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
	DirectoryName *string `json:"DirectoryName,omitempty" xml:"DirectoryName,omitempty"`
	// Details of the IP addresses of the Domain Name System (DNS) servers of the enterprise AD system. You can specify only one IP address. Make sure that the specified IP address is accessible in the network of the selected vSwitch.
	DnsAddress []*string `json:"DnsAddress,omitempty" xml:"DnsAddress,omitempty" type:"Repeated"`
	// The fully qualified domain name (FQDN) of the enterprise AD system. The value must contain the hostname and the domain name. You can register each FQDN only once.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The password of the domain administrator. The password can be up to 64 characters in length.
	DomainPassword *string `json:"DomainPassword,omitempty" xml:"DomainPassword,omitempty"`
	// The username of the domain administrator. The username can be up to 64 characters in length.
	DomainUserName *string `json:"DomainUserName,omitempty" xml:"DomainUserName,omitempty"`
	// Specifies whether to grant the permissions of the local administrator to the regular user of the cloud desktop.
	EnableAdminAccess *bool `json:"EnableAdminAccess,omitempty" xml:"EnableAdminAccess,omitempty"`
	// Specifies whether to enable multi-factor authentication (MFA). If you enable MFA, all AD users in the AD directory must enter the password and the dynamic verification code generated by the MFA device when they log on to a cloud desktop.
	//
	// >  The first time you log on to the Elastic Desktop Service (EDS) client as a regular user, you must bind an MFA device.
	MfaEnabled *bool `json:"MfaEnabled,omitempty" xml:"MfaEnabled,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The type of the AD connector.
	Specification *int64 `json:"Specification,omitempty" xml:"Specification,omitempty"`
	// The DNS address of the enterprise AD subdomain.\
	// If you specify the `SubDomainName` parameter but you do not specify this parameter, the DNS address of the subdomain is the same as the DNS address of the parent domain.
	SubDomainDnsAddress []*string `json:"SubDomainDnsAddress,omitempty" xml:"SubDomainDnsAddress,omitempty" type:"Repeated"`
	// The FQDN of the enterprise AD subdomain. The value must contain the hostname and the subdomain name.
	SubDomainName *string `json:"SubDomainName,omitempty" xml:"SubDomainName,omitempty"`
	// Details of the vSwitch IDs. You can specify only one vSwitch ID.
	VSwitchId []*string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty" type:"Repeated"`
}

func (s CreateADConnectorDirectoryRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateADConnectorDirectoryRequest) GoString() string {
	return s.String()
}

func (s *CreateADConnectorDirectoryRequest) SetDesktopAccessType(v string) *CreateADConnectorDirectoryRequest {
	s.DesktopAccessType = &v
	return s
}

func (s *CreateADConnectorDirectoryRequest) SetDirectoryName(v string) *CreateADConnectorDirectoryRequest {
	s.DirectoryName = &v
	return s
}

func (s *CreateADConnectorDirectoryRequest) SetDnsAddress(v []*string) *CreateADConnectorDirectoryRequest {
	s.DnsAddress = v
	return s
}

func (s *CreateADConnectorDirectoryRequest) SetDomainName(v string) *CreateADConnectorDirectoryRequest {
	s.DomainName = &v
	return s
}

func (s *CreateADConnectorDirectoryRequest) SetDomainPassword(v string) *CreateADConnectorDirectoryRequest {
	s.DomainPassword = &v
	return s
}

func (s *CreateADConnectorDirectoryRequest) SetDomainUserName(v string) *CreateADConnectorDirectoryRequest {
	s.DomainUserName = &v
	return s
}

func (s *CreateADConnectorDirectoryRequest) SetEnableAdminAccess(v bool) *CreateADConnectorDirectoryRequest {
	s.EnableAdminAccess = &v
	return s
}

func (s *CreateADConnectorDirectoryRequest) SetMfaEnabled(v bool) *CreateADConnectorDirectoryRequest {
	s.MfaEnabled = &v
	return s
}

func (s *CreateADConnectorDirectoryRequest) SetRegionId(v string) *CreateADConnectorDirectoryRequest {
	s.RegionId = &v
	return s
}

func (s *CreateADConnectorDirectoryRequest) SetSpecification(v int64) *CreateADConnectorDirectoryRequest {
	s.Specification = &v
	return s
}

func (s *CreateADConnectorDirectoryRequest) SetSubDomainDnsAddress(v []*string) *CreateADConnectorDirectoryRequest {
	s.SubDomainDnsAddress = v
	return s
}

func (s *CreateADConnectorDirectoryRequest) SetSubDomainName(v string) *CreateADConnectorDirectoryRequest {
	s.SubDomainName = &v
	return s
}

func (s *CreateADConnectorDirectoryRequest) SetVSwitchId(v []*string) *CreateADConnectorDirectoryRequest {
	s.VSwitchId = v
	return s
}

type CreateADConnectorDirectoryResponseBody struct {
	// Details of the AD connectors.
	AdConnectors []*CreateADConnectorDirectoryResponseBodyAdConnectors `json:"AdConnectors,omitempty" xml:"AdConnectors,omitempty" type:"Repeated"`
	// The ID of the AD directory.
	DirectoryId *string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The AD trust password.
	TrustPassword *string `json:"TrustPassword,omitempty" xml:"TrustPassword,omitempty"`
}

func (s CreateADConnectorDirectoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateADConnectorDirectoryResponseBody) GoString() string {
	return s.String()
}

func (s *CreateADConnectorDirectoryResponseBody) SetAdConnectors(v []*CreateADConnectorDirectoryResponseBodyAdConnectors) *CreateADConnectorDirectoryResponseBody {
	s.AdConnectors = v
	return s
}

func (s *CreateADConnectorDirectoryResponseBody) SetDirectoryId(v string) *CreateADConnectorDirectoryResponseBody {
	s.DirectoryId = &v
	return s
}

func (s *CreateADConnectorDirectoryResponseBody) SetRequestId(v string) *CreateADConnectorDirectoryResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateADConnectorDirectoryResponseBody) SetTrustPassword(v string) *CreateADConnectorDirectoryResponseBody {
	s.TrustPassword = &v
	return s
}

type CreateADConnectorDirectoryResponseBodyAdConnectors struct {
	// The IP address of the AD connector.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
}

func (s CreateADConnectorDirectoryResponseBodyAdConnectors) String() string {
	return tea.Prettify(s)
}

func (s CreateADConnectorDirectoryResponseBodyAdConnectors) GoString() string {
	return s.String()
}

func (s *CreateADConnectorDirectoryResponseBodyAdConnectors) SetAddress(v string) *CreateADConnectorDirectoryResponseBodyAdConnectors {
	s.Address = &v
	return s
}

type CreateADConnectorDirectoryResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateADConnectorDirectoryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateADConnectorDirectoryResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateADConnectorDirectoryResponse) GoString() string {
	return s.String()
}

func (s *CreateADConnectorDirectoryResponse) SetHeaders(v map[string]*string) *CreateADConnectorDirectoryResponse {
	s.Headers = v
	return s
}

func (s *CreateADConnectorDirectoryResponse) SetStatusCode(v int32) *CreateADConnectorDirectoryResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateADConnectorDirectoryResponse) SetBody(v *CreateADConnectorDirectoryResponseBody) *CreateADConnectorDirectoryResponse {
	s.Body = v
	return s
}

type CreateADConnectorOfficeSiteRequest struct {
	// The hostname of the domain controller. The hostname must comply with the naming conventions for Windows hosts.
	AdHostname *string `json:"AdHostname,omitempty" xml:"AdHostname,omitempty"`
	// The maximum public bandwidth of the Internet access package. Valid values: 0 to 200.\
	// If you do not specify this parameter or you set this parameter to 0, Internet access is disabled.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The ID of the CEN instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The ID of the Alibaba Cloud account to which the Cloud Enterprise Network (CEN) instance belongs.
	//
	// *   If you do not specify CenId or the CEN instance that is specified by CenId belongs to the current Alibaba Cloud account, leave this parameter empty.
	// *   If you specify CenId and the CEN instance that is specified by CenId belongs to another Alibaba Cloud account, enter the ID of the Alibaba Cloud account.
	CenOwnerId *int64 `json:"CenOwnerId,omitempty" xml:"CenOwnerId,omitempty"`
	// The IPv4 CIDR block in the secure office network of the workspace. The IPv4 CIDR block that the system uses to create a virtual private cloud (VPC) for the workspace. We recommend that you set the IPv4 CIDR block to 10.0.0.0/12, 172.16.0.0/12, 192.168.0.0/16, or a subnet of these CIDR blocks. If you set the IPv4 CIDR block to 10.0.0.0/12 or 172.16.0.0/12, the mask is 1224 bits in length. If you set the IPv4 CIDR block to 192.168.0.0/16, the mask is 1624 bits in length.
	CidrBlock *string `json:"CidrBlock,omitempty" xml:"CidrBlock,omitempty"`
	// The connection method that is used to connect clients to cloud desktops. Valid values:
	//
	// *   Internet: connects clients to cloud desktops only over the Internet.
	// *   VPC: connects clients to cloud desktops only over a VPC.
	// *   Any: connects clients to cloud desktops over the Internet or a VPC. You can select a connection method based on your business requirements when you connect to your cloud desktop from a client.
	//
	// Default value: Internet
	//
	// > VPC connections are established by using Alibaba Cloud PrivateLink. You can use PrivateLink free of charge. If you set this parameter to VPC or Any, PrivateLink is automatically activated.
	DesktopAccessType *string `json:"DesktopAccessType,omitempty" xml:"DesktopAccessType,omitempty"`
	// The IP address of the DNS server of the enterprise AD system. You can specify only one IP address.
	DnsAddress []*string `json:"DnsAddress,omitempty" xml:"DnsAddress,omitempty" type:"Repeated"`
	// The domain name of the enterprise AD system. You can register each domain name only once.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The password of the domain administrator. The password can be up to 64 characters in length.
	DomainPassword *string `json:"DomainPassword,omitempty" xml:"DomainPassword,omitempty"`
	// The username of the domain administrator. The username can be up to 64 characters in length.
	//
	// > Specify the username by using sAMAccountName instead of userPrincipalName.
	DomainUserName *string `json:"DomainUserName,omitempty" xml:"DomainUserName,omitempty"`
	// Specifies whether to grant the permissions of the local administrator to end users of the cloud desktops that belong to the workspace. Default value: `true`
	EnableAdminAccess *bool `json:"EnableAdminAccess,omitempty" xml:"EnableAdminAccess,omitempty"`
	// Specifies whether to enable Internet access.
	EnableInternetAccess *bool `json:"EnableInternetAccess,omitempty" xml:"EnableInternetAccess,omitempty"`
	// Specifies whether to enable multi-factor authentication (MFA).
	MfaEnabled *bool `json:"MfaEnabled,omitempty" xml:"MfaEnabled,omitempty"`
	// The name of the workspace. The name must be 2 to 255 characters in length. The name must start with a letter but cannot start with `http://` or `https://`. The name can contain letters, digits, colons (:), underscores (\_), and hyphens (-).\
	// Default value: null
	OfficeSiteName *string `json:"OfficeSiteName,omitempty" xml:"OfficeSiteName,omitempty"`
	// The type of the protocol. Set the value to ASP.
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The region ID of the workspace.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The type of the AD connector.
	//
	// *   1: General
	// *   2: Advanced
	Specification *int64 `json:"Specification,omitempty" xml:"Specification,omitempty"`
	// The DNS address of the enterprise AD subdomain. If you specify `SubDomainName` but do not specify this parameter, the DNS address of the subdomain is the same as the DNS address of the parent domain.
	SubDomainDnsAddress []*string `json:"SubDomainDnsAddress,omitempty" xml:"SubDomainDnsAddress,omitempty" type:"Repeated"`
	// The domain name of the enterprise AD subdomain.
	SubDomainName *string `json:"SubDomainName,omitempty" xml:"SubDomainName,omitempty"`
	// The verification code. If the CEN instance that is specified by CenId belongs to another Alibaba Cloud account, you must call the SendVerifyCode operation to obtain the verification code.
	VerifyCode *string `json:"VerifyCode,omitempty" xml:"VerifyCode,omitempty"`
}

func (s CreateADConnectorOfficeSiteRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateADConnectorOfficeSiteRequest) GoString() string {
	return s.String()
}

func (s *CreateADConnectorOfficeSiteRequest) SetAdHostname(v string) *CreateADConnectorOfficeSiteRequest {
	s.AdHostname = &v
	return s
}

func (s *CreateADConnectorOfficeSiteRequest) SetBandwidth(v int32) *CreateADConnectorOfficeSiteRequest {
	s.Bandwidth = &v
	return s
}

func (s *CreateADConnectorOfficeSiteRequest) SetCenId(v string) *CreateADConnectorOfficeSiteRequest {
	s.CenId = &v
	return s
}

func (s *CreateADConnectorOfficeSiteRequest) SetCenOwnerId(v int64) *CreateADConnectorOfficeSiteRequest {
	s.CenOwnerId = &v
	return s
}

func (s *CreateADConnectorOfficeSiteRequest) SetCidrBlock(v string) *CreateADConnectorOfficeSiteRequest {
	s.CidrBlock = &v
	return s
}

func (s *CreateADConnectorOfficeSiteRequest) SetDesktopAccessType(v string) *CreateADConnectorOfficeSiteRequest {
	s.DesktopAccessType = &v
	return s
}

func (s *CreateADConnectorOfficeSiteRequest) SetDnsAddress(v []*string) *CreateADConnectorOfficeSiteRequest {
	s.DnsAddress = v
	return s
}

func (s *CreateADConnectorOfficeSiteRequest) SetDomainName(v string) *CreateADConnectorOfficeSiteRequest {
	s.DomainName = &v
	return s
}

func (s *CreateADConnectorOfficeSiteRequest) SetDomainPassword(v string) *CreateADConnectorOfficeSiteRequest {
	s.DomainPassword = &v
	return s
}

func (s *CreateADConnectorOfficeSiteRequest) SetDomainUserName(v string) *CreateADConnectorOfficeSiteRequest {
	s.DomainUserName = &v
	return s
}

func (s *CreateADConnectorOfficeSiteRequest) SetEnableAdminAccess(v bool) *CreateADConnectorOfficeSiteRequest {
	s.EnableAdminAccess = &v
	return s
}

func (s *CreateADConnectorOfficeSiteRequest) SetEnableInternetAccess(v bool) *CreateADConnectorOfficeSiteRequest {
	s.EnableInternetAccess = &v
	return s
}

func (s *CreateADConnectorOfficeSiteRequest) SetMfaEnabled(v bool) *CreateADConnectorOfficeSiteRequest {
	s.MfaEnabled = &v
	return s
}

func (s *CreateADConnectorOfficeSiteRequest) SetOfficeSiteName(v string) *CreateADConnectorOfficeSiteRequest {
	s.OfficeSiteName = &v
	return s
}

func (s *CreateADConnectorOfficeSiteRequest) SetProtocolType(v string) *CreateADConnectorOfficeSiteRequest {
	s.ProtocolType = &v
	return s
}

func (s *CreateADConnectorOfficeSiteRequest) SetRegionId(v string) *CreateADConnectorOfficeSiteRequest {
	s.RegionId = &v
	return s
}

func (s *CreateADConnectorOfficeSiteRequest) SetSpecification(v int64) *CreateADConnectorOfficeSiteRequest {
	s.Specification = &v
	return s
}

func (s *CreateADConnectorOfficeSiteRequest) SetSubDomainDnsAddress(v []*string) *CreateADConnectorOfficeSiteRequest {
	s.SubDomainDnsAddress = v
	return s
}

func (s *CreateADConnectorOfficeSiteRequest) SetSubDomainName(v string) *CreateADConnectorOfficeSiteRequest {
	s.SubDomainName = &v
	return s
}

func (s *CreateADConnectorOfficeSiteRequest) SetVerifyCode(v string) *CreateADConnectorOfficeSiteRequest {
	s.VerifyCode = &v
	return s
}

type CreateADConnectorOfficeSiteResponseBody struct {
	// The ID of the workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateADConnectorOfficeSiteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateADConnectorOfficeSiteResponseBody) GoString() string {
	return s.String()
}

func (s *CreateADConnectorOfficeSiteResponseBody) SetOfficeSiteId(v string) *CreateADConnectorOfficeSiteResponseBody {
	s.OfficeSiteId = &v
	return s
}

func (s *CreateADConnectorOfficeSiteResponseBody) SetRequestId(v string) *CreateADConnectorOfficeSiteResponseBody {
	s.RequestId = &v
	return s
}

type CreateADConnectorOfficeSiteResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateADConnectorOfficeSiteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateADConnectorOfficeSiteResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateADConnectorOfficeSiteResponse) GoString() string {
	return s.String()
}

func (s *CreateADConnectorOfficeSiteResponse) SetHeaders(v map[string]*string) *CreateADConnectorOfficeSiteResponse {
	s.Headers = v
	return s
}

func (s *CreateADConnectorOfficeSiteResponse) SetStatusCode(v int32) *CreateADConnectorOfficeSiteResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateADConnectorOfficeSiteResponse) SetBody(v *CreateADConnectorOfficeSiteResponseBody) *CreateADConnectorOfficeSiteResponse {
	s.Body = v
	return s
}

type CreateAndBindNasFileSystemRequest struct {
	Description    *string   `json:"Description,omitempty" xml:"Description,omitempty"`
	DesktopGroupId *string   `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	EncryptType    *int32    `json:"EncryptType,omitempty" xml:"EncryptType,omitempty"`
	EndUserIds     []*string `json:"EndUserIds,omitempty" xml:"EndUserIds,omitempty" type:"Repeated"`
	FileSystemName *string   `json:"FileSystemName,omitempty" xml:"FileSystemName,omitempty"`
	OfficeSiteId   *string   `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	RegionId       *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	StorageType    *string   `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
}

func (s CreateAndBindNasFileSystemRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAndBindNasFileSystemRequest) GoString() string {
	return s.String()
}

func (s *CreateAndBindNasFileSystemRequest) SetDescription(v string) *CreateAndBindNasFileSystemRequest {
	s.Description = &v
	return s
}

func (s *CreateAndBindNasFileSystemRequest) SetDesktopGroupId(v string) *CreateAndBindNasFileSystemRequest {
	s.DesktopGroupId = &v
	return s
}

func (s *CreateAndBindNasFileSystemRequest) SetEncryptType(v int32) *CreateAndBindNasFileSystemRequest {
	s.EncryptType = &v
	return s
}

func (s *CreateAndBindNasFileSystemRequest) SetEndUserIds(v []*string) *CreateAndBindNasFileSystemRequest {
	s.EndUserIds = v
	return s
}

func (s *CreateAndBindNasFileSystemRequest) SetFileSystemName(v string) *CreateAndBindNasFileSystemRequest {
	s.FileSystemName = &v
	return s
}

func (s *CreateAndBindNasFileSystemRequest) SetOfficeSiteId(v string) *CreateAndBindNasFileSystemRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *CreateAndBindNasFileSystemRequest) SetRegionId(v string) *CreateAndBindNasFileSystemRequest {
	s.RegionId = &v
	return s
}

func (s *CreateAndBindNasFileSystemRequest) SetStorageType(v string) *CreateAndBindNasFileSystemRequest {
	s.StorageType = &v
	return s
}

type CreateAndBindNasFileSystemResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAndBindNasFileSystemResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateAndBindNasFileSystemResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAndBindNasFileSystemResponseBody) SetRequestId(v string) *CreateAndBindNasFileSystemResponseBody {
	s.RequestId = &v
	return s
}

type CreateAndBindNasFileSystemResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateAndBindNasFileSystemResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateAndBindNasFileSystemResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAndBindNasFileSystemResponse) GoString() string {
	return s.String()
}

func (s *CreateAndBindNasFileSystemResponse) SetHeaders(v map[string]*string) *CreateAndBindNasFileSystemResponse {
	s.Headers = v
	return s
}

func (s *CreateAndBindNasFileSystemResponse) SetStatusCode(v int32) *CreateAndBindNasFileSystemResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAndBindNasFileSystemResponse) SetBody(v *CreateAndBindNasFileSystemResponseBody) *CreateAndBindNasFileSystemResponse {
	s.Body = v
	return s
}

type CreateAutoSnapshotPolicyRequest struct {
	// The CRON expression for periodic scheduling.
	CronExpression *string `json:"CronExpression,omitempty" xml:"CronExpression,omitempty"`
	// The name of the automatic snapshot policy.
	PolicyName *string `json:"PolicyName,omitempty" xml:"PolicyName,omitempty"`
	// The ID of the region where the automatic snapshot policy is created. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The retention period of automatic snapshots. Unit: days. Valid values:
	//
	// *   \-1: Automatic snapshots are retained until they are deleted.
	// *   1 to 65536: Automatic snapshots are retained for the specified number of days.
	RetentionDays *int32 `json:"RetentionDays,omitempty" xml:"RetentionDays,omitempty"`
}

func (s CreateAutoSnapshotPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAutoSnapshotPolicyRequest) GoString() string {
	return s.String()
}

func (s *CreateAutoSnapshotPolicyRequest) SetCronExpression(v string) *CreateAutoSnapshotPolicyRequest {
	s.CronExpression = &v
	return s
}

func (s *CreateAutoSnapshotPolicyRequest) SetPolicyName(v string) *CreateAutoSnapshotPolicyRequest {
	s.PolicyName = &v
	return s
}

func (s *CreateAutoSnapshotPolicyRequest) SetRegionId(v string) *CreateAutoSnapshotPolicyRequest {
	s.RegionId = &v
	return s
}

func (s *CreateAutoSnapshotPolicyRequest) SetRetentionDays(v int32) *CreateAutoSnapshotPolicyRequest {
	s.RetentionDays = &v
	return s
}

type CreateAutoSnapshotPolicyResponseBody struct {
	// The ID of the automatic snapshot policy.
	PolicyId *string `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAutoSnapshotPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateAutoSnapshotPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAutoSnapshotPolicyResponseBody) SetPolicyId(v string) *CreateAutoSnapshotPolicyResponseBody {
	s.PolicyId = &v
	return s
}

func (s *CreateAutoSnapshotPolicyResponseBody) SetRequestId(v string) *CreateAutoSnapshotPolicyResponseBody {
	s.RequestId = &v
	return s
}

type CreateAutoSnapshotPolicyResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateAutoSnapshotPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateAutoSnapshotPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAutoSnapshotPolicyResponse) GoString() string {
	return s.String()
}

func (s *CreateAutoSnapshotPolicyResponse) SetHeaders(v map[string]*string) *CreateAutoSnapshotPolicyResponse {
	s.Headers = v
	return s
}

func (s *CreateAutoSnapshotPolicyResponse) SetStatusCode(v int32) *CreateAutoSnapshotPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAutoSnapshotPolicyResponse) SetBody(v *CreateAutoSnapshotPolicyResponseBody) *CreateAutoSnapshotPolicyResponse {
	s.Body = v
	return s
}

type CreateBundleRequest struct {
	// The name of the desktop template.
	BundleName *string `json:"BundleName,omitempty" xml:"BundleName,omitempty"`
	// The description of the desktop template.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The type of the cloud desktop. You can call the DescribeBundles operation to query the cloud desktop templates and obtain the supported desktop type from the value of the DesktopType parameter.
	//
	// >  You can select GPU-accelerated desktop types only when you use GPU-accelerated images.
	DesktopType *string `json:"DesktopType,omitempty" xml:"DesktopType,omitempty"`
	// The ID of the image.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The language of the OS. This parameter is available only for system images. Valid values:
	//
	// *   zh-CN: Simplified Chinese
	// *   zh-HK: Traditional Chinese (Hong Kong)
	// *   en-US: English
	// *   ja-JP: Japanese
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The performance level (PL) of the system disk. If the cloud desktop type is Graphics or High Frequency, you can set the PL of the system disk. Valid values:
	//
	// *   PL0
	// *   PL1
	// *   PL2
	// *   PL3
	//
	// For more information about the differences between disks at different PLs, see [Enhanced SSDs](~~122389~~).
	RootDiskPerformanceLevel *string `json:"RootDiskPerformanceLevel,omitempty" xml:"RootDiskPerformanceLevel,omitempty"`
	// The size of the system disk. Unit: GiB.
	//
	// The value of this parameter must be consistent with the system disk size supported by the cloud desktop type. For more information, see [Cloud desktop types](~~188609~~).
	RootDiskSizeGib *int32 `json:"RootDiskSizeGib,omitempty" xml:"RootDiskSizeGib,omitempty"`
	// The PL of the data disk. If the cloud desktop type is Graphics or High Frequency, you can set the PL of the data disk. Valid values:
	//
	// *   PL0
	// *   PL1
	// *   PL2
	// *   PL3
	//
	// For more information about the differences between disks at different PLs, see [Enhanced SSDs](~~122389~~).
	UserDiskPerformanceLevel *string  `json:"UserDiskPerformanceLevel,omitempty" xml:"UserDiskPerformanceLevel,omitempty"`
	UserDiskSizeGib          []*int32 `json:"UserDiskSizeGib,omitempty" xml:"UserDiskSizeGib,omitempty" type:"Repeated"`
}

func (s CreateBundleRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateBundleRequest) GoString() string {
	return s.String()
}

func (s *CreateBundleRequest) SetBundleName(v string) *CreateBundleRequest {
	s.BundleName = &v
	return s
}

func (s *CreateBundleRequest) SetDescription(v string) *CreateBundleRequest {
	s.Description = &v
	return s
}

func (s *CreateBundleRequest) SetDesktopType(v string) *CreateBundleRequest {
	s.DesktopType = &v
	return s
}

func (s *CreateBundleRequest) SetImageId(v string) *CreateBundleRequest {
	s.ImageId = &v
	return s
}

func (s *CreateBundleRequest) SetLanguage(v string) *CreateBundleRequest {
	s.Language = &v
	return s
}

func (s *CreateBundleRequest) SetRegionId(v string) *CreateBundleRequest {
	s.RegionId = &v
	return s
}

func (s *CreateBundleRequest) SetRootDiskPerformanceLevel(v string) *CreateBundleRequest {
	s.RootDiskPerformanceLevel = &v
	return s
}

func (s *CreateBundleRequest) SetRootDiskSizeGib(v int32) *CreateBundleRequest {
	s.RootDiskSizeGib = &v
	return s
}

func (s *CreateBundleRequest) SetUserDiskPerformanceLevel(v string) *CreateBundleRequest {
	s.UserDiskPerformanceLevel = &v
	return s
}

func (s *CreateBundleRequest) SetUserDiskSizeGib(v []*int32) *CreateBundleRequest {
	s.UserDiskSizeGib = v
	return s
}

type CreateBundleResponseBody struct {
	// The ID of the desktop template.
	BundleId *string `json:"BundleId,omitempty" xml:"BundleId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateBundleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateBundleResponseBody) GoString() string {
	return s.String()
}

func (s *CreateBundleResponseBody) SetBundleId(v string) *CreateBundleResponseBody {
	s.BundleId = &v
	return s
}

func (s *CreateBundleResponseBody) SetRequestId(v string) *CreateBundleResponseBody {
	s.RequestId = &v
	return s
}

type CreateBundleResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateBundleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateBundleResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateBundleResponse) GoString() string {
	return s.String()
}

func (s *CreateBundleResponse) SetHeaders(v map[string]*string) *CreateBundleResponse {
	s.Headers = v
	return s
}

func (s *CreateBundleResponse) SetStatusCode(v int32) *CreateBundleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateBundleResponse) SetBody(v *CreateBundleResponseBody) *CreateBundleResponse {
	s.Body = v
	return s
}

type CreateCdsFileRequest struct {
	// The ID of the cloud disk.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	// The policy that is used when the file that you want to upload has the same name as an existing file in the cloud disk.
	//
	// Valid values:
	//
	// *   refuse
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     denies creating the file
	//
	//     <!-- -->
	//
	//     .
	//
	// *   auto_rename
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     automatically renames the file
	//
	//     <!-- -->
	//
	//     .
	//
	// *   ignore
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     allows the file to use the same name as the existing file in the cloud disk
	//
	//     <!-- -->
	//
	//     .
	//
	// *   over_write
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     overwrites the existing file in the cloud disk
	//
	//     <!-- -->
	//
	//     .
	ConflictPolicy *string `json:"ConflictPolicy,omitempty" xml:"ConflictPolicy,omitempty"`
	// The user ID.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The hash value of the SHA1 algorithm that is used by the file.
	FileHash *string `json:"FileHash,omitempty" xml:"FileHash,omitempty"`
	// The file size. Unit: bytes.
	FileLength *int64 `json:"FileLength,omitempty" xml:"FileLength,omitempty"`
	// The file name.
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The file type.
	//
	// Valid values:
	//
	// *   file
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   folder
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	FileType *string `json:"FileType,omitempty" xml:"FileType,omitempty"`
	GroupId  *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the parent folder.
	ParentFileId *string `json:"ParentFileId,omitempty" xml:"ParentFileId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateCdsFileRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCdsFileRequest) GoString() string {
	return s.String()
}

func (s *CreateCdsFileRequest) SetCdsId(v string) *CreateCdsFileRequest {
	s.CdsId = &v
	return s
}

func (s *CreateCdsFileRequest) SetConflictPolicy(v string) *CreateCdsFileRequest {
	s.ConflictPolicy = &v
	return s
}

func (s *CreateCdsFileRequest) SetEndUserId(v string) *CreateCdsFileRequest {
	s.EndUserId = &v
	return s
}

func (s *CreateCdsFileRequest) SetFileHash(v string) *CreateCdsFileRequest {
	s.FileHash = &v
	return s
}

func (s *CreateCdsFileRequest) SetFileLength(v int64) *CreateCdsFileRequest {
	s.FileLength = &v
	return s
}

func (s *CreateCdsFileRequest) SetFileName(v string) *CreateCdsFileRequest {
	s.FileName = &v
	return s
}

func (s *CreateCdsFileRequest) SetFileType(v string) *CreateCdsFileRequest {
	s.FileType = &v
	return s
}

func (s *CreateCdsFileRequest) SetGroupId(v string) *CreateCdsFileRequest {
	s.GroupId = &v
	return s
}

func (s *CreateCdsFileRequest) SetParentFileId(v string) *CreateCdsFileRequest {
	s.ParentFileId = &v
	return s
}

func (s *CreateCdsFileRequest) SetRegionId(v string) *CreateCdsFileRequest {
	s.RegionId = &v
	return s
}

type CreateCdsFileResponseBody struct {
	FileModel *CreateCdsFileResponseBodyFileModel `json:"FileModel,omitempty" xml:"FileModel,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateCdsFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCdsFileResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCdsFileResponseBody) SetFileModel(v *CreateCdsFileResponseBodyFileModel) *CreateCdsFileResponseBody {
	s.FileModel = v
	return s
}

func (s *CreateCdsFileResponseBody) SetRequestId(v string) *CreateCdsFileResponseBody {
	s.RequestId = &v
	return s
}

type CreateCdsFileResponseBodyFileModel struct {
	FileId    *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	UploadId  *string `json:"UploadId,omitempty" xml:"UploadId,omitempty"`
	UploadUrl *string `json:"UploadUrl,omitempty" xml:"UploadUrl,omitempty"`
}

func (s CreateCdsFileResponseBodyFileModel) String() string {
	return tea.Prettify(s)
}

func (s CreateCdsFileResponseBodyFileModel) GoString() string {
	return s.String()
}

func (s *CreateCdsFileResponseBodyFileModel) SetFileId(v string) *CreateCdsFileResponseBodyFileModel {
	s.FileId = &v
	return s
}

func (s *CreateCdsFileResponseBodyFileModel) SetUploadId(v string) *CreateCdsFileResponseBodyFileModel {
	s.UploadId = &v
	return s
}

func (s *CreateCdsFileResponseBodyFileModel) SetUploadUrl(v string) *CreateCdsFileResponseBodyFileModel {
	s.UploadUrl = &v
	return s
}

type CreateCdsFileResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCdsFileResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCdsFileResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCdsFileResponse) GoString() string {
	return s.String()
}

func (s *CreateCdsFileResponse) SetHeaders(v map[string]*string) *CreateCdsFileResponse {
	s.Headers = v
	return s
}

func (s *CreateCdsFileResponse) SetStatusCode(v int32) *CreateCdsFileResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCdsFileResponse) SetBody(v *CreateCdsFileResponseBody) *CreateCdsFileResponse {
	s.Body = v
	return s
}

type CreateCdsFileShareLinkRequest struct {
	// The ID of the cloud disk.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	// The description of the file sharing task. The description must be 0 to 1,024 characters in length.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to prohibit the download of the files that are being shared.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     prohibits file download
	//
	//     <!-- -->
	//
	//     .
	//
	// *   false
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     allows file download
	//
	//     <!-- -->
	//
	//     .
	DisableDownload *bool `json:"DisableDownload,omitempty" xml:"DisableDownload,omitempty"`
	// Specifies whether to prohibit the preview of the files that are being shared.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     prohibits file preview
	//
	//     <!-- -->
	//
	//     .
	//
	// *   false
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     allows file preview
	//
	//     <!-- -->
	//
	//     .
	DisablePreview *bool `json:"DisablePreview,omitempty" xml:"DisablePreview,omitempty"`
	// Specifies whether to prohibit the dump of the files that are being shared.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     prohibits file dump
	//
	//     <!-- -->
	//
	//     .
	//
	// *   false
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     allows file dump
	//
	//     <!-- -->
	//
	//     .
	DisableSave *bool `json:"DisableSave,omitempty" xml:"DisableSave,omitempty"`
	// The limit on the number of times that the shared files can be downloaded. The value of this parameter must be equal to or greater than 0. The value 0 specifies that no limit is imposed on the number of times that the shared files can be downloaded.
	DownloadLimit *int64 `json:"DownloadLimit,omitempty" xml:"DownloadLimit,omitempty"`
	// The ID of the end user.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The time when the file sharing link expires. The value of this parameter follows the RFC 3339 standard. Example: "2020-06-28T11:33:00.000+08:00". If this parameter is set to "", the file sharing link never expires.
	Expiration *string `json:"Expiration,omitempty" xml:"Expiration,omitempty"`
	// The file IDs.
	FileIds []*string `json:"FileIds,omitempty" xml:"FileIds,omitempty" type:"Repeated"`
	GroupId *string   `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The limit on the number of times that the shared files can be previewed. The value of this parameter must be equal to or greater than 0. The value 0 specifies that no limit is imposed on the number of times that the shared files can be previewed.
	PreviewLimit *int64 `json:"PreviewLimit,omitempty" xml:"PreviewLimit,omitempty"`
	// The limit on the number of times that the shared files can be dumped. The value of this parameter must be equal to or greater than 0. The value 0 specifies that no limit is imposed on the number of times that the shared files can be dumped.
	SaveLimit *int64 `json:"SaveLimit,omitempty" xml:"SaveLimit,omitempty"`
	// The name of the file sharing task. If you leave this parameter empty, the file name that corresponds to the first ID in the file ID list is used. The name must be 0 to 128 characters in length.
	ShareName *string `json:"ShareName,omitempty" xml:"ShareName,omitempty"`
	// The length of the access code. Valid values: 6 to 8. Unit: bytes. If you leave this parameter empty or set it to null, no access code is required. If you use a token to share files, you do not need to configure this parameter. The access code can contain only visible ASCII characters.
	SharePwd *string `json:"SharePwd,omitempty" xml:"SharePwd,omitempty"`
}

func (s CreateCdsFileShareLinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCdsFileShareLinkRequest) GoString() string {
	return s.String()
}

func (s *CreateCdsFileShareLinkRequest) SetCdsId(v string) *CreateCdsFileShareLinkRequest {
	s.CdsId = &v
	return s
}

func (s *CreateCdsFileShareLinkRequest) SetDescription(v string) *CreateCdsFileShareLinkRequest {
	s.Description = &v
	return s
}

func (s *CreateCdsFileShareLinkRequest) SetDisableDownload(v bool) *CreateCdsFileShareLinkRequest {
	s.DisableDownload = &v
	return s
}

func (s *CreateCdsFileShareLinkRequest) SetDisablePreview(v bool) *CreateCdsFileShareLinkRequest {
	s.DisablePreview = &v
	return s
}

func (s *CreateCdsFileShareLinkRequest) SetDisableSave(v bool) *CreateCdsFileShareLinkRequest {
	s.DisableSave = &v
	return s
}

func (s *CreateCdsFileShareLinkRequest) SetDownloadLimit(v int64) *CreateCdsFileShareLinkRequest {
	s.DownloadLimit = &v
	return s
}

func (s *CreateCdsFileShareLinkRequest) SetEndUserId(v string) *CreateCdsFileShareLinkRequest {
	s.EndUserId = &v
	return s
}

func (s *CreateCdsFileShareLinkRequest) SetExpiration(v string) *CreateCdsFileShareLinkRequest {
	s.Expiration = &v
	return s
}

func (s *CreateCdsFileShareLinkRequest) SetFileIds(v []*string) *CreateCdsFileShareLinkRequest {
	s.FileIds = v
	return s
}

func (s *CreateCdsFileShareLinkRequest) SetGroupId(v string) *CreateCdsFileShareLinkRequest {
	s.GroupId = &v
	return s
}

func (s *CreateCdsFileShareLinkRequest) SetPreviewLimit(v int64) *CreateCdsFileShareLinkRequest {
	s.PreviewLimit = &v
	return s
}

func (s *CreateCdsFileShareLinkRequest) SetSaveLimit(v int64) *CreateCdsFileShareLinkRequest {
	s.SaveLimit = &v
	return s
}

func (s *CreateCdsFileShareLinkRequest) SetShareName(v string) *CreateCdsFileShareLinkRequest {
	s.ShareName = &v
	return s
}

func (s *CreateCdsFileShareLinkRequest) SetSharePwd(v string) *CreateCdsFileShareLinkRequest {
	s.SharePwd = &v
	return s
}

type CreateCdsFileShareLinkResponseBody struct {
	// The operation result. The value success indicates that the operation is successful. If the operation failed, an error message is returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data information.
	Data *CdsFileShareLinkModel `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error message that is returned. This parameter is not returned if the value of Code is success.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   false
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateCdsFileShareLinkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCdsFileShareLinkResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCdsFileShareLinkResponseBody) SetCode(v string) *CreateCdsFileShareLinkResponseBody {
	s.Code = &v
	return s
}

func (s *CreateCdsFileShareLinkResponseBody) SetData(v *CdsFileShareLinkModel) *CreateCdsFileShareLinkResponseBody {
	s.Data = v
	return s
}

func (s *CreateCdsFileShareLinkResponseBody) SetMessage(v string) *CreateCdsFileShareLinkResponseBody {
	s.Message = &v
	return s
}

func (s *CreateCdsFileShareLinkResponseBody) SetRequestId(v string) *CreateCdsFileShareLinkResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateCdsFileShareLinkResponseBody) SetSuccess(v bool) *CreateCdsFileShareLinkResponseBody {
	s.Success = &v
	return s
}

type CreateCdsFileShareLinkResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCdsFileShareLinkResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCdsFileShareLinkResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCdsFileShareLinkResponse) GoString() string {
	return s.String()
}

func (s *CreateCdsFileShareLinkResponse) SetHeaders(v map[string]*string) *CreateCdsFileShareLinkResponse {
	s.Headers = v
	return s
}

func (s *CreateCdsFileShareLinkResponse) SetStatusCode(v int32) *CreateCdsFileShareLinkResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCdsFileShareLinkResponse) SetBody(v *CreateCdsFileShareLinkResponseBody) *CreateCdsFileShareLinkResponse {
	s.Body = v
	return s
}

type CreateCloudDriveServiceRequest struct {
	BizType    *int32    `json:"BizType,omitempty" xml:"BizType,omitempty"`
	CenId      *string   `json:"CenId,omitempty" xml:"CenId,omitempty"`
	DomainName *string   `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	EndUserId  []*string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty" type:"Repeated"`
	MaxSize    *int64    `json:"MaxSize,omitempty" xml:"MaxSize,omitempty"`
	// The name of the cloud disk that you want to create in Cloud Drive Service.
	Name           *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OfficeSiteId   *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	OfficeSiteType *string `json:"OfficeSiteType,omitempty" xml:"OfficeSiteType,omitempty"`
	// The region ID.
	RegionId    *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	SolutionId  *string `json:"SolutionId,omitempty" xml:"SolutionId,omitempty"`
	UserMaxSize *int64  `json:"UserMaxSize,omitempty" xml:"UserMaxSize,omitempty"`
}

func (s CreateCloudDriveServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCloudDriveServiceRequest) GoString() string {
	return s.String()
}

func (s *CreateCloudDriveServiceRequest) SetBizType(v int32) *CreateCloudDriveServiceRequest {
	s.BizType = &v
	return s
}

func (s *CreateCloudDriveServiceRequest) SetCenId(v string) *CreateCloudDriveServiceRequest {
	s.CenId = &v
	return s
}

func (s *CreateCloudDriveServiceRequest) SetDomainName(v string) *CreateCloudDriveServiceRequest {
	s.DomainName = &v
	return s
}

func (s *CreateCloudDriveServiceRequest) SetEndUserId(v []*string) *CreateCloudDriveServiceRequest {
	s.EndUserId = v
	return s
}

func (s *CreateCloudDriveServiceRequest) SetMaxSize(v int64) *CreateCloudDriveServiceRequest {
	s.MaxSize = &v
	return s
}

func (s *CreateCloudDriveServiceRequest) SetName(v string) *CreateCloudDriveServiceRequest {
	s.Name = &v
	return s
}

func (s *CreateCloudDriveServiceRequest) SetOfficeSiteId(v string) *CreateCloudDriveServiceRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *CreateCloudDriveServiceRequest) SetOfficeSiteType(v string) *CreateCloudDriveServiceRequest {
	s.OfficeSiteType = &v
	return s
}

func (s *CreateCloudDriveServiceRequest) SetRegionId(v string) *CreateCloudDriveServiceRequest {
	s.RegionId = &v
	return s
}

func (s *CreateCloudDriveServiceRequest) SetSolutionId(v string) *CreateCloudDriveServiceRequest {
	s.SolutionId = &v
	return s
}

func (s *CreateCloudDriveServiceRequest) SetUserMaxSize(v int64) *CreateCloudDriveServiceRequest {
	s.UserMaxSize = &v
	return s
}

type CreateCloudDriveServiceResponseBody struct {
	// The ID of the attached cloud disk.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	// The name of the cloud disk that is created in Cloud Drive Service.
	CdsName    *string `json:"CdsName,omitempty" xml:"CdsName,omitempty"`
	CenId      *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The maximum capacity of each instance in Cloud Drive Service. Unit: GiB
	MaxSize        *string `json:"MaxSize,omitempty" xml:"MaxSize,omitempty"`
	OfficeSiteType *string `json:"OfficeSiteType,omitempty" xml:"OfficeSiteType,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateCloudDriveServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCloudDriveServiceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCloudDriveServiceResponseBody) SetCdsId(v string) *CreateCloudDriveServiceResponseBody {
	s.CdsId = &v
	return s
}

func (s *CreateCloudDriveServiceResponseBody) SetCdsName(v string) *CreateCloudDriveServiceResponseBody {
	s.CdsName = &v
	return s
}

func (s *CreateCloudDriveServiceResponseBody) SetCenId(v string) *CreateCloudDriveServiceResponseBody {
	s.CenId = &v
	return s
}

func (s *CreateCloudDriveServiceResponseBody) SetDomainName(v string) *CreateCloudDriveServiceResponseBody {
	s.DomainName = &v
	return s
}

func (s *CreateCloudDriveServiceResponseBody) SetMaxSize(v string) *CreateCloudDriveServiceResponseBody {
	s.MaxSize = &v
	return s
}

func (s *CreateCloudDriveServiceResponseBody) SetOfficeSiteType(v string) *CreateCloudDriveServiceResponseBody {
	s.OfficeSiteType = &v
	return s
}

func (s *CreateCloudDriveServiceResponseBody) SetRequestId(v string) *CreateCloudDriveServiceResponseBody {
	s.RequestId = &v
	return s
}

type CreateCloudDriveServiceResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCloudDriveServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCloudDriveServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCloudDriveServiceResponse) GoString() string {
	return s.String()
}

func (s *CreateCloudDriveServiceResponse) SetHeaders(v map[string]*string) *CreateCloudDriveServiceResponse {
	s.Headers = v
	return s
}

func (s *CreateCloudDriveServiceResponse) SetStatusCode(v int32) *CreateCloudDriveServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCloudDriveServiceResponse) SetBody(v *CreateCloudDriveServiceResponseBody) *CreateCloudDriveServiceResponse {
	s.Body = v
	return s
}

type CreateCloudDriveUsersRequest struct {
	// The ID of the cloud disk.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	// The IDs of the end users.
	EndUserId []*string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty" type:"Repeated"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The maximum storage space of an end user. Unit: bytes.
	UserMaxSize *int64 `json:"UserMaxSize,omitempty" xml:"UserMaxSize,omitempty"`
}

func (s CreateCloudDriveUsersRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCloudDriveUsersRequest) GoString() string {
	return s.String()
}

func (s *CreateCloudDriveUsersRequest) SetCdsId(v string) *CreateCloudDriveUsersRequest {
	s.CdsId = &v
	return s
}

func (s *CreateCloudDriveUsersRequest) SetEndUserId(v []*string) *CreateCloudDriveUsersRequest {
	s.EndUserId = v
	return s
}

func (s *CreateCloudDriveUsersRequest) SetRegionId(v string) *CreateCloudDriveUsersRequest {
	s.RegionId = &v
	return s
}

func (s *CreateCloudDriveUsersRequest) SetUserMaxSize(v int64) *CreateCloudDriveUsersRequest {
	s.UserMaxSize = &v
	return s
}

type CreateCloudDriveUsersResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateCloudDriveUsersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCloudDriveUsersResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCloudDriveUsersResponseBody) SetRequestId(v string) *CreateCloudDriveUsersResponseBody {
	s.RequestId = &v
	return s
}

type CreateCloudDriveUsersResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCloudDriveUsersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCloudDriveUsersResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCloudDriveUsersResponse) GoString() string {
	return s.String()
}

func (s *CreateCloudDriveUsersResponse) SetHeaders(v map[string]*string) *CreateCloudDriveUsersResponse {
	s.Headers = v
	return s
}

func (s *CreateCloudDriveUsersResponse) SetStatusCode(v int32) *CreateCloudDriveUsersResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCloudDriveUsersResponse) SetBody(v *CreateCloudDriveUsersResponseBody) *CreateCloudDriveUsersResponse {
	s.Body = v
	return s
}

type CreateDesktopGroupRequest struct {
	// The end users whom you want to add to all types of desktop groups.
	AllClassifyUsers *bool `json:"AllClassifyUsers,omitempty" xml:"AllClassifyUsers,omitempty"`
	// Specifies whether to automatically create cloud desktops in the desktop group if you set the billing method to subscription. If you set the ChargeType parameter to PrePaid, this parameter is required.
	AllowAutoSetup *int32 `json:"AllowAutoSetup,omitempty" xml:"AllowAutoSetup,omitempty"`
	// Specifies whether to reserve cloud desktops if you set the billing method to pay-as-you-go. If you set the ChargeType parameter to PostPaid, this parameter is required. Valid values: 0: does not allow the system to reserve cloud desktops. N: allows the system to reserve N cloud desktops. The variable N must be an integer that ranges from 1 to 100.
	AllowBufferCount *int32 `json:"AllowBufferCount,omitempty" xml:"AllowBufferCount,omitempty"`
	// Specifies whether to enable automatic payment.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// Specifies whether to enable auto-renewal.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   false
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	AutoRenew *bool `json:"AutoRenew,omitempty" xml:"AutoRenew,omitempty"`
	// The number of sessions that are allowed per cloud desktop in a multi-session desktop group.
	BindAmount *int64 `json:"BindAmount,omitempty" xml:"BindAmount,omitempty"`
	// The ID of the desktop template.
	BundleId *string `json:"BundleId,omitempty" xml:"BundleId,omitempty"`
	// The number of cloud desktops that you want to purchase. Valid values: 0 to 200.
	BuyDesktopsCount *int32 `json:"BuyDesktopsCount,omitempty" xml:"BuyDesktopsCount,omitempty"`
	// The billing method of the cloud desktops in the desktop group.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The type of the desktop group.
	Classify *string `json:"Classify,omitempty" xml:"Classify,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The remarks on the desktop group.
	Comments *string `json:"Comments,omitempty" xml:"Comments,omitempty"`
	// The maximum period of time during which the session is connected. When the specified maximum period of time is reached, the session automatically disconnects. Unit: milliseconds. This parameter is required only for cloud desktops in the same desktop group.
	ConnectDuration *int64 `json:"ConnectDuration,omitempty" xml:"ConnectDuration,omitempty"`
	// The default number of cloud desktops to create when you create the desktop group. Default value: 1.
	DefaultInitDesktopCount *int32 `json:"DefaultInitDesktopCount,omitempty" xml:"DefaultInitDesktopCount,omitempty"`
	// The name of the desktop group.
	DesktopGroupName *string `json:"DesktopGroupName,omitempty" xml:"DesktopGroupName,omitempty"`
	// The ID of the directory.
	DirectoryId *string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	// The end users that can use the desktop group.
	EndUserIds []*string `json:"EndUserIds,omitempty" xml:"EndUserIds,omitempty" type:"Repeated"`
	// The Apsara File Storage NAS (NAS) file system that is used after data roaming is enabled.
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The desktop group version.
	GroupVersion *int32 `json:"GroupVersion,omitempty" xml:"GroupVersion,omitempty"`
	// The maximum period of time for which a session remains idle. If an end user performs no operations on a cloud desktop by using keyboards or mouses during a session, the session becomes idle. When the specified maximum period of time is reached, the session automatically disconnects. Unit: milliseconds. This parameter is required only for cloud desktops in the same desktop group.
	IdleDisconnectDuration *int64 `json:"IdleDisconnectDuration,omitempty" xml:"IdleDisconnectDuration,omitempty"`
	// The retention period of the cloud desktop after the end user disconnects from the cloud desktop. Unit: milliseconds.
	KeepDuration *int64 `json:"KeepDuration,omitempty" xml:"KeepDuration,omitempty"`
	// The load balancing policy of the multi-session desktop group.
	LoadPolicy *int64 `json:"LoadPolicy,omitempty" xml:"LoadPolicy,omitempty"`
	// The maximum number of cloud desktops that the desktop group can contain. Valid values: 0 to 200.
	MaxDesktopsCount *int32 `json:"MaxDesktopsCount,omitempty" xml:"MaxDesktopsCount,omitempty"`
	// The minimum number of cloud desktops that must be contained in the desktop group if you set the billing method to subscription. If you set the ChargeType parameter to PrePaid, this parameter is required. Valid values: 0 to the value of MaxDesktopsCount. Default value: 1.
	MinDesktopsCount *int32 `json:"MinDesktopsCount,omitempty" xml:"MinDesktopsCount,omitempty"`
	// The ID of the workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The type of the desktop group.
	OwnType *int32 `json:"OwnType,omitempty" xml:"OwnType,omitempty"`
	// The subscription period of the cloud desktops in the desktop group. The unit is specified by the PeriodUnit parameter. The Period parameter takes effect only if you set the ChargeType parameter to PrePaid.
	//
	// *   Valid values if you set the PeriodUnit parameter to Month:
	//
	//     *   1
	//     *   2
	//     *   3
	//     *   6
	//
	// *   Valid values if you set the PeriodUnit parameter to Year:
	//
	//     *   1
	//     *   2
	//     *   3
	//     *   4
	//     *   5
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The unit of the subscription duration.
	PeriodUnit *string `json:"PeriodUnit,omitempty" xml:"PeriodUnit,omitempty"`
	// The ID of the policy.
	PolicyGroupId *string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty"`
	// Specifies whether to enable data roaming.
	ProfileFollowSwitch *bool `json:"ProfileFollowSwitch,omitempty" xml:"ProfileFollowSwitch,omitempty"`
	// The threshold for the ratio of connected sessions. This parameter is the condition that triggers auto scaling in a multi-session desktop group. `Ratio of connected sessions = Number of connected sessions/(Total number of cloud desktops  Maximum number of sessions allowed for each cloud desktop)  100%`. When the specified threshold is reached, new cloud desktops are automatically created. When the specified threshold is not reached, idle cloud desktops are released.
	RatioThreshold *float32 `json:"RatioThreshold,omitempty" xml:"RatioThreshold,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Specifies which type of the disk to reset for cloud desktops in the desktop group.
	ResetType *int64 `json:"ResetType,omitempty" xml:"ResetType,omitempty"`
	// The ID of the scaling policy.
	//
	// > This parameter is unavailable.
	ScaleStrategyId *string `json:"ScaleStrategyId,omitempty" xml:"ScaleStrategyId,omitempty"`
	// The period of time before the idle cloud desktop is stopped. When the specified period of time is reached, the idle cloud desktop automatically stops. If an end user connects to a stopped cloud desktop, the cloud desktop automatically starts. Unit: milliseconds.
	StopDuration *int64 `json:"StopDuration,omitempty" xml:"StopDuration,omitempty"`
	// Specifies whether to enable disk encryption.
	VolumeEncryptionEnabled *bool `json:"VolumeEncryptionEnabled,omitempty" xml:"VolumeEncryptionEnabled,omitempty"`
	// The ID of the Key Management Service (KMS) key that you want to use when disk encryption is enabled. You can call the [ListKeys](~~28951~~) operation to obtain a list of KMS keys.
	VolumeEncryptionKey *string `json:"VolumeEncryptionKey,omitempty" xml:"VolumeEncryptionKey,omitempty"`
	// The ID of the virtual private cloud (VPC) in which you want to create the desktop group.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s CreateDesktopGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDesktopGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateDesktopGroupRequest) SetAllClassifyUsers(v bool) *CreateDesktopGroupRequest {
	s.AllClassifyUsers = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetAllowAutoSetup(v int32) *CreateDesktopGroupRequest {
	s.AllowAutoSetup = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetAllowBufferCount(v int32) *CreateDesktopGroupRequest {
	s.AllowBufferCount = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetAutoPay(v bool) *CreateDesktopGroupRequest {
	s.AutoPay = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetAutoRenew(v bool) *CreateDesktopGroupRequest {
	s.AutoRenew = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetBindAmount(v int64) *CreateDesktopGroupRequest {
	s.BindAmount = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetBundleId(v string) *CreateDesktopGroupRequest {
	s.BundleId = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetBuyDesktopsCount(v int32) *CreateDesktopGroupRequest {
	s.BuyDesktopsCount = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetChargeType(v string) *CreateDesktopGroupRequest {
	s.ChargeType = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetClassify(v string) *CreateDesktopGroupRequest {
	s.Classify = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetClientToken(v string) *CreateDesktopGroupRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetComments(v string) *CreateDesktopGroupRequest {
	s.Comments = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetConnectDuration(v int64) *CreateDesktopGroupRequest {
	s.ConnectDuration = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetDefaultInitDesktopCount(v int32) *CreateDesktopGroupRequest {
	s.DefaultInitDesktopCount = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetDesktopGroupName(v string) *CreateDesktopGroupRequest {
	s.DesktopGroupName = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetDirectoryId(v string) *CreateDesktopGroupRequest {
	s.DirectoryId = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetEndUserIds(v []*string) *CreateDesktopGroupRequest {
	s.EndUserIds = v
	return s
}

func (s *CreateDesktopGroupRequest) SetFileSystemId(v string) *CreateDesktopGroupRequest {
	s.FileSystemId = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetGroupVersion(v int32) *CreateDesktopGroupRequest {
	s.GroupVersion = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetIdleDisconnectDuration(v int64) *CreateDesktopGroupRequest {
	s.IdleDisconnectDuration = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetKeepDuration(v int64) *CreateDesktopGroupRequest {
	s.KeepDuration = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetLoadPolicy(v int64) *CreateDesktopGroupRequest {
	s.LoadPolicy = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetMaxDesktopsCount(v int32) *CreateDesktopGroupRequest {
	s.MaxDesktopsCount = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetMinDesktopsCount(v int32) *CreateDesktopGroupRequest {
	s.MinDesktopsCount = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetOfficeSiteId(v string) *CreateDesktopGroupRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetOwnType(v int32) *CreateDesktopGroupRequest {
	s.OwnType = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetPeriod(v int32) *CreateDesktopGroupRequest {
	s.Period = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetPeriodUnit(v string) *CreateDesktopGroupRequest {
	s.PeriodUnit = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetPolicyGroupId(v string) *CreateDesktopGroupRequest {
	s.PolicyGroupId = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetProfileFollowSwitch(v bool) *CreateDesktopGroupRequest {
	s.ProfileFollowSwitch = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetRatioThreshold(v float32) *CreateDesktopGroupRequest {
	s.RatioThreshold = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetRegionId(v string) *CreateDesktopGroupRequest {
	s.RegionId = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetResetType(v int64) *CreateDesktopGroupRequest {
	s.ResetType = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetScaleStrategyId(v string) *CreateDesktopGroupRequest {
	s.ScaleStrategyId = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetStopDuration(v int64) *CreateDesktopGroupRequest {
	s.StopDuration = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetVolumeEncryptionEnabled(v bool) *CreateDesktopGroupRequest {
	s.VolumeEncryptionEnabled = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetVolumeEncryptionKey(v string) *CreateDesktopGroupRequest {
	s.VolumeEncryptionKey = &v
	return s
}

func (s *CreateDesktopGroupRequest) SetVpcId(v string) *CreateDesktopGroupRequest {
	s.VpcId = &v
	return s
}

type CreateDesktopGroupResponseBody struct {
	// The ID of the desktop group.
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// The IDs of the orders.
	OrderIds []*string `json:"OrderIds,omitempty" xml:"OrderIds,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDesktopGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDesktopGroupResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDesktopGroupResponseBody) SetDesktopGroupId(v string) *CreateDesktopGroupResponseBody {
	s.DesktopGroupId = &v
	return s
}

func (s *CreateDesktopGroupResponseBody) SetOrderIds(v []*string) *CreateDesktopGroupResponseBody {
	s.OrderIds = v
	return s
}

func (s *CreateDesktopGroupResponseBody) SetRequestId(v string) *CreateDesktopGroupResponseBody {
	s.RequestId = &v
	return s
}

type CreateDesktopGroupResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDesktopGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDesktopGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDesktopGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateDesktopGroupResponse) SetHeaders(v map[string]*string) *CreateDesktopGroupResponse {
	s.Headers = v
	return s
}

func (s *CreateDesktopGroupResponse) SetStatusCode(v int32) *CreateDesktopGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDesktopGroupResponse) SetBody(v *CreateDesktopGroupResponseBody) *CreateDesktopGroupResponse {
	s.Body = v
	return s
}

type CreateDesktopOversoldGroupRequest struct {
	ConcurrenceCount  *int32  `json:"ConcurrenceCount,omitempty" xml:"ConcurrenceCount,omitempty"`
	DataDiskSize      *int32  `json:"DataDiskSize,omitempty" xml:"DataDiskSize,omitempty"`
	Description       *string `json:"Description,omitempty" xml:"Description,omitempty"`
	DesktopType       *string `json:"DesktopType,omitempty" xml:"DesktopType,omitempty"`
	DirectoryId       *string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	ImageId           *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	Name              *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OversoldUserCount *int32  `json:"OversoldUserCount,omitempty" xml:"OversoldUserCount,omitempty"`
	OversoldWarn      *int32  `json:"OversoldWarn,omitempty" xml:"OversoldWarn,omitempty"`
	Period            *int32  `json:"Period,omitempty" xml:"Period,omitempty"`
	PeriodUnit        *string `json:"PeriodUnit,omitempty" xml:"PeriodUnit,omitempty"`
	PolicyGroupId     *string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty"`
	StopDuration      *int32  `json:"StopDuration,omitempty" xml:"StopDuration,omitempty"`
	SystemDiskSize    *int32  `json:"SystemDiskSize,omitempty" xml:"SystemDiskSize,omitempty"`
}

func (s CreateDesktopOversoldGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDesktopOversoldGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateDesktopOversoldGroupRequest) SetConcurrenceCount(v int32) *CreateDesktopOversoldGroupRequest {
	s.ConcurrenceCount = &v
	return s
}

func (s *CreateDesktopOversoldGroupRequest) SetDataDiskSize(v int32) *CreateDesktopOversoldGroupRequest {
	s.DataDiskSize = &v
	return s
}

func (s *CreateDesktopOversoldGroupRequest) SetDescription(v string) *CreateDesktopOversoldGroupRequest {
	s.Description = &v
	return s
}

func (s *CreateDesktopOversoldGroupRequest) SetDesktopType(v string) *CreateDesktopOversoldGroupRequest {
	s.DesktopType = &v
	return s
}

func (s *CreateDesktopOversoldGroupRequest) SetDirectoryId(v string) *CreateDesktopOversoldGroupRequest {
	s.DirectoryId = &v
	return s
}

func (s *CreateDesktopOversoldGroupRequest) SetImageId(v string) *CreateDesktopOversoldGroupRequest {
	s.ImageId = &v
	return s
}

func (s *CreateDesktopOversoldGroupRequest) SetName(v string) *CreateDesktopOversoldGroupRequest {
	s.Name = &v
	return s
}

func (s *CreateDesktopOversoldGroupRequest) SetOversoldUserCount(v int32) *CreateDesktopOversoldGroupRequest {
	s.OversoldUserCount = &v
	return s
}

func (s *CreateDesktopOversoldGroupRequest) SetOversoldWarn(v int32) *CreateDesktopOversoldGroupRequest {
	s.OversoldWarn = &v
	return s
}

func (s *CreateDesktopOversoldGroupRequest) SetPeriod(v int32) *CreateDesktopOversoldGroupRequest {
	s.Period = &v
	return s
}

func (s *CreateDesktopOversoldGroupRequest) SetPeriodUnit(v string) *CreateDesktopOversoldGroupRequest {
	s.PeriodUnit = &v
	return s
}

func (s *CreateDesktopOversoldGroupRequest) SetPolicyGroupId(v string) *CreateDesktopOversoldGroupRequest {
	s.PolicyGroupId = &v
	return s
}

func (s *CreateDesktopOversoldGroupRequest) SetStopDuration(v int32) *CreateDesktopOversoldGroupRequest {
	s.StopDuration = &v
	return s
}

func (s *CreateDesktopOversoldGroupRequest) SetSystemDiskSize(v int32) *CreateDesktopOversoldGroupRequest {
	s.SystemDiskSize = &v
	return s
}

type CreateDesktopOversoldGroupResponseBody struct {
	Data      *CreateDesktopOversoldGroupResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	RequestId *string                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDesktopOversoldGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDesktopOversoldGroupResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDesktopOversoldGroupResponseBody) SetData(v *CreateDesktopOversoldGroupResponseBodyData) *CreateDesktopOversoldGroupResponseBody {
	s.Data = v
	return s
}

func (s *CreateDesktopOversoldGroupResponseBody) SetRequestId(v string) *CreateDesktopOversoldGroupResponseBody {
	s.RequestId = &v
	return s
}

type CreateDesktopOversoldGroupResponseBodyData struct {
	OrderId         *int64  `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	OversoldGroupId *string `json:"OversoldGroupId,omitempty" xml:"OversoldGroupId,omitempty"`
}

func (s CreateDesktopOversoldGroupResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateDesktopOversoldGroupResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateDesktopOversoldGroupResponseBodyData) SetOrderId(v int64) *CreateDesktopOversoldGroupResponseBodyData {
	s.OrderId = &v
	return s
}

func (s *CreateDesktopOversoldGroupResponseBodyData) SetOversoldGroupId(v string) *CreateDesktopOversoldGroupResponseBodyData {
	s.OversoldGroupId = &v
	return s
}

type CreateDesktopOversoldGroupResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDesktopOversoldGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDesktopOversoldGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDesktopOversoldGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateDesktopOversoldGroupResponse) SetHeaders(v map[string]*string) *CreateDesktopOversoldGroupResponse {
	s.Headers = v
	return s
}

func (s *CreateDesktopOversoldGroupResponse) SetStatusCode(v int32) *CreateDesktopOversoldGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDesktopOversoldGroupResponse) SetBody(v *CreateDesktopOversoldGroupResponseBody) *CreateDesktopOversoldGroupResponse {
	s.Body = v
	return s
}

type CreateDesktopsRequest struct {
	// The number of cloud desktops that you want to create. Valid values: 1 to 300. Default value: 1.
	Amount *int32 `json:"Amount,omitempty" xml:"Amount,omitempty"`
	// Specifies whether to enable automatic payment.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// Specifies whether to enable auto-renewal. This parameter takes effect only when the ChargeType parameter is set to PrePaid.````
	AutoRenew *bool `json:"AutoRenew,omitempty" xml:"AutoRenew,omitempty"`
	// The ID of the desktop template.
	BundleId *string `json:"BundleId,omitempty" xml:"BundleId,omitempty"`
	// The desktop templates that you want to use.
	BundleModels []*CreateDesktopsRequestBundleModels `json:"BundleModels,omitempty" xml:"BundleModels,omitempty" type:"Repeated"`
	// The billing method of the cloud desktop.
	ChargeType      *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	DesktopMemberIp *string `json:"DesktopMemberIp,omitempty" xml:"DesktopMemberIp,omitempty"`
	// The name of the cloud desktop. The name must meet the following requirements:
	//
	// *   The name must be 1 to 64 characters in length.
	// *   The name can contain letters, digits, colons (:), underscores (\_), periods (.), and hyphens (-). It must start with a letter but cannot start with http:// or https://.
	DesktopName *string `json:"DesktopName,omitempty" xml:"DesktopName,omitempty"`
	// Specifies whether to automatically add a suffix to the cloud desktop name when you create multiple cloud desktops at a time.
	DesktopNameSuffix *bool                                 `json:"DesktopNameSuffix,omitempty" xml:"DesktopNameSuffix,omitempty"`
	DesktopTimers     []*CreateDesktopsRequestDesktopTimers `json:"DesktopTimers,omitempty" xml:"DesktopTimers,omitempty" type:"Repeated"`
	// This parameter is not available.
	DirectoryId *string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	// The IDs of the users that you want to authorize to use the cloud desktop. The cloud desktop is assigned to the users. You can specify IDs of 1 to 100 users.
	//
	// *   Only one user can use the cloud desktop at a time.
	// *   If you do not specify the `EndUserId` parameter, the cloud desktop that you create is not assigned to users.
	EndUserId []*string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty" type:"Repeated"`
	// The ID of the desktop group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The hostname that you specify for the cloud desktop. You can specify only the hostname of a Windows cloud desktop in the workspace of the enterprise AD account type.
	//
	// The hostname must meet the following requirements:
	//
	// *   It must be 2 to 15 characters in length.
	// *   It can contain letters, digits, and hyphens (-). The hostname cannot start or end with a hyphen (-), contain consecutive hyphens (-), or contain only digits.
	//
	// If you create multiple cloud desktops, you can use the`  name_prefix[begin_number,bits]name_suffix ` format to determine the hostnames of the cloud desktops. For example, if you set Hostname to ecd-\[1,4]-test, the hostname of the first cloud desktop is ecd-0001-test and the hostname of the second cloud desktop is ecd-0002-test. Other hostnames follow the same rule.
	//
	// *   `name_prefix`: the prefix of the hostname.
	// *   `[begin_number,bits]`: the ordered numbers in the hostname. begin_number: the start number. Valid values: 0 to 999999. Default value: 0. bits: the digit. Valid values: 1 to 6. Default value: 6.
	// *   `name_suffix`: the suffix of the hostname.
	Hostname *string `json:"Hostname,omitempty" xml:"Hostname,omitempty"`
	// The ID of the workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The subscription duration of the cloud desktop that you want to create. The unit is specified by the `PeriodUnit` parameter. This parameter takes effect and is required only when the `ChargeType` parameter is set to `PrePaid`.
	//
	// *   Valid values if the `PeriodUnit` parameter is set to `Month`:
	//
	//     *   1
	//     *   2
	//     *   3
	//     *   6
	//
	// *   Valid values if the `PeriodUnit` parameter is set to `Year`:
	//
	//     *   1
	//     *   2
	//     *   3
	//     *   4
	//     *   5
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The unit of the subscription duration.
	PeriodUnit *string `json:"PeriodUnit,omitempty" xml:"PeriodUnit,omitempty"`
	// The ID of the policy.
	PolicyGroupId *string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty"`
	// The ID of the sales promotion.
	PromotionId *string `json:"PromotionId,omitempty" xml:"PromotionId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The tags that you want to add to the cloud desktop.
	Tag []*CreateDesktopsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The assignment mode of the cloud desktop.
	//
	// > If you do not specify the `EndUserId` parameter, the cloud desktop that you create is not assigned to users.
	UserAssignMode *string `json:"UserAssignMode,omitempty" xml:"UserAssignMode,omitempty"`
	// The custom command scripts of the user.
	UserCommands []*CreateDesktopsRequestUserCommands `json:"UserCommands,omitempty" xml:"UserCommands,omitempty" type:"Repeated"`
	// This parameter is not available.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
	// Specifies whether to enable disk encryption.
	VolumeEncryptionEnabled *bool `json:"VolumeEncryptionEnabled,omitempty" xml:"VolumeEncryptionEnabled,omitempty"`
	// The ID of the Key Management Service (KMS) key that you want to use when disk encryption is enabled. You can call the [ListKeys](~~28951~~) operation to obtain a list of KMS keys.
	VolumeEncryptionKey *string `json:"VolumeEncryptionKey,omitempty" xml:"VolumeEncryptionKey,omitempty"`
	// This parameter is not available.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s CreateDesktopsRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDesktopsRequest) GoString() string {
	return s.String()
}

func (s *CreateDesktopsRequest) SetAmount(v int32) *CreateDesktopsRequest {
	s.Amount = &v
	return s
}

func (s *CreateDesktopsRequest) SetAutoPay(v bool) *CreateDesktopsRequest {
	s.AutoPay = &v
	return s
}

func (s *CreateDesktopsRequest) SetAutoRenew(v bool) *CreateDesktopsRequest {
	s.AutoRenew = &v
	return s
}

func (s *CreateDesktopsRequest) SetBundleId(v string) *CreateDesktopsRequest {
	s.BundleId = &v
	return s
}

func (s *CreateDesktopsRequest) SetBundleModels(v []*CreateDesktopsRequestBundleModels) *CreateDesktopsRequest {
	s.BundleModels = v
	return s
}

func (s *CreateDesktopsRequest) SetChargeType(v string) *CreateDesktopsRequest {
	s.ChargeType = &v
	return s
}

func (s *CreateDesktopsRequest) SetDesktopMemberIp(v string) *CreateDesktopsRequest {
	s.DesktopMemberIp = &v
	return s
}

func (s *CreateDesktopsRequest) SetDesktopName(v string) *CreateDesktopsRequest {
	s.DesktopName = &v
	return s
}

func (s *CreateDesktopsRequest) SetDesktopNameSuffix(v bool) *CreateDesktopsRequest {
	s.DesktopNameSuffix = &v
	return s
}

func (s *CreateDesktopsRequest) SetDesktopTimers(v []*CreateDesktopsRequestDesktopTimers) *CreateDesktopsRequest {
	s.DesktopTimers = v
	return s
}

func (s *CreateDesktopsRequest) SetDirectoryId(v string) *CreateDesktopsRequest {
	s.DirectoryId = &v
	return s
}

func (s *CreateDesktopsRequest) SetEndUserId(v []*string) *CreateDesktopsRequest {
	s.EndUserId = v
	return s
}

func (s *CreateDesktopsRequest) SetGroupId(v string) *CreateDesktopsRequest {
	s.GroupId = &v
	return s
}

func (s *CreateDesktopsRequest) SetHostname(v string) *CreateDesktopsRequest {
	s.Hostname = &v
	return s
}

func (s *CreateDesktopsRequest) SetOfficeSiteId(v string) *CreateDesktopsRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *CreateDesktopsRequest) SetPeriod(v int32) *CreateDesktopsRequest {
	s.Period = &v
	return s
}

func (s *CreateDesktopsRequest) SetPeriodUnit(v string) *CreateDesktopsRequest {
	s.PeriodUnit = &v
	return s
}

func (s *CreateDesktopsRequest) SetPolicyGroupId(v string) *CreateDesktopsRequest {
	s.PolicyGroupId = &v
	return s
}

func (s *CreateDesktopsRequest) SetPromotionId(v string) *CreateDesktopsRequest {
	s.PromotionId = &v
	return s
}

func (s *CreateDesktopsRequest) SetRegionId(v string) *CreateDesktopsRequest {
	s.RegionId = &v
	return s
}

func (s *CreateDesktopsRequest) SetTag(v []*CreateDesktopsRequestTag) *CreateDesktopsRequest {
	s.Tag = v
	return s
}

func (s *CreateDesktopsRequest) SetUserAssignMode(v string) *CreateDesktopsRequest {
	s.UserAssignMode = &v
	return s
}

func (s *CreateDesktopsRequest) SetUserCommands(v []*CreateDesktopsRequestUserCommands) *CreateDesktopsRequest {
	s.UserCommands = v
	return s
}

func (s *CreateDesktopsRequest) SetUserName(v string) *CreateDesktopsRequest {
	s.UserName = &v
	return s
}

func (s *CreateDesktopsRequest) SetVolumeEncryptionEnabled(v bool) *CreateDesktopsRequest {
	s.VolumeEncryptionEnabled = &v
	return s
}

func (s *CreateDesktopsRequest) SetVolumeEncryptionKey(v string) *CreateDesktopsRequest {
	s.VolumeEncryptionKey = &v
	return s
}

func (s *CreateDesktopsRequest) SetVpcId(v string) *CreateDesktopsRequest {
	s.VpcId = &v
	return s
}

type CreateDesktopsRequestBundleModels struct {
	// The number of cloud desktops that you want to create. Valid values: 1 to 300. Default value: 0.
	Amount *int32 `json:"Amount,omitempty" xml:"Amount,omitempty"`
	// The ID of the desktop template.
	BundleId *string `json:"BundleId,omitempty" xml:"BundleId,omitempty"`
	// The name of the cloud desktop.
	DesktopName *string `json:"DesktopName,omitempty" xml:"DesktopName,omitempty"`
	// The users to whom you want to assign the cloud desktops.
	EndUserIds []*string `json:"EndUserIds,omitempty" xml:"EndUserIds,omitempty" type:"Repeated"`
	// The hostname that you specify for the cloud desktop. You can only specify the hostname of a Windows cloud desktop in the workspace of the enterprise AD account type.
	//
	// The hostname must meet the following requirements:
	//
	// *   It must be 2 to 15 characters in length.
	// *   It can contain letters, digits, and hyphens (-). The hostname cannot start or end with a hyphen (-), contain consecutive hyphens (-), or contain only digits.
	//
	// If you create multiple cloud desktops, you can use the`  name_prefix[begin_number,bits]name_suffix ` format to determine the hostnames of the cloud desktops. For example, if you set Hostname to ecd-\[1,4]-test, the hostname of the first cloud desktop is ecd-0001-test and the hostname of the second cloud desktop is ecd-0002-test. Other hostnames follow the same rule.
	//
	// *   `name_prefix`: the prefix of the hostname.
	// *   `[begin_number,bits]`: the ordered numbers in the hostname. begin_number: the start number. Valid values: 0 to 999999. Default value: 0. bits: the digit. Valid values: 1 to 6. Default value: 6.
	// *   `name_suffix`: the suffix of the hostname.
	Hostname *string `json:"Hostname,omitempty" xml:"Hostname,omitempty"`
	// Specifies whether to enable disk encryption.
	VolumeEncryptionEnabled *bool `json:"VolumeEncryptionEnabled,omitempty" xml:"VolumeEncryptionEnabled,omitempty"`
	// The ID of the Key Management Service (KMS) key that you want to use when disk encryption is enabled. You can call the [ListKeys](~~28951~~) operation to obtain a list of KMS keys.
	VolumeEncryptionKey *string `json:"VolumeEncryptionKey,omitempty" xml:"VolumeEncryptionKey,omitempty"`
}

func (s CreateDesktopsRequestBundleModels) String() string {
	return tea.Prettify(s)
}

func (s CreateDesktopsRequestBundleModels) GoString() string {
	return s.String()
}

func (s *CreateDesktopsRequestBundleModels) SetAmount(v int32) *CreateDesktopsRequestBundleModels {
	s.Amount = &v
	return s
}

func (s *CreateDesktopsRequestBundleModels) SetBundleId(v string) *CreateDesktopsRequestBundleModels {
	s.BundleId = &v
	return s
}

func (s *CreateDesktopsRequestBundleModels) SetDesktopName(v string) *CreateDesktopsRequestBundleModels {
	s.DesktopName = &v
	return s
}

func (s *CreateDesktopsRequestBundleModels) SetEndUserIds(v []*string) *CreateDesktopsRequestBundleModels {
	s.EndUserIds = v
	return s
}

func (s *CreateDesktopsRequestBundleModels) SetHostname(v string) *CreateDesktopsRequestBundleModels {
	s.Hostname = &v
	return s
}

func (s *CreateDesktopsRequestBundleModels) SetVolumeEncryptionEnabled(v bool) *CreateDesktopsRequestBundleModels {
	s.VolumeEncryptionEnabled = &v
	return s
}

func (s *CreateDesktopsRequestBundleModels) SetVolumeEncryptionKey(v string) *CreateDesktopsRequestBundleModels {
	s.VolumeEncryptionKey = &v
	return s
}

type CreateDesktopsRequestDesktopTimers struct {
	AllowClientSetting *bool   `json:"AllowClientSetting,omitempty" xml:"AllowClientSetting,omitempty"`
	CronExpression     *string `json:"CronExpression,omitempty" xml:"CronExpression,omitempty"`
	Enforce            *bool   `json:"Enforce,omitempty" xml:"Enforce,omitempty"`
	Interval           *int32  `json:"Interval,omitempty" xml:"Interval,omitempty"`
	OperationType      *string `json:"OperationType,omitempty" xml:"OperationType,omitempty"`
	ResetType          *string `json:"ResetType,omitempty" xml:"ResetType,omitempty"`
	TimerType          *string `json:"TimerType,omitempty" xml:"TimerType,omitempty"`
}

func (s CreateDesktopsRequestDesktopTimers) String() string {
	return tea.Prettify(s)
}

func (s CreateDesktopsRequestDesktopTimers) GoString() string {
	return s.String()
}

func (s *CreateDesktopsRequestDesktopTimers) SetAllowClientSetting(v bool) *CreateDesktopsRequestDesktopTimers {
	s.AllowClientSetting = &v
	return s
}

func (s *CreateDesktopsRequestDesktopTimers) SetCronExpression(v string) *CreateDesktopsRequestDesktopTimers {
	s.CronExpression = &v
	return s
}

func (s *CreateDesktopsRequestDesktopTimers) SetEnforce(v bool) *CreateDesktopsRequestDesktopTimers {
	s.Enforce = &v
	return s
}

func (s *CreateDesktopsRequestDesktopTimers) SetInterval(v int32) *CreateDesktopsRequestDesktopTimers {
	s.Interval = &v
	return s
}

func (s *CreateDesktopsRequestDesktopTimers) SetOperationType(v string) *CreateDesktopsRequestDesktopTimers {
	s.OperationType = &v
	return s
}

func (s *CreateDesktopsRequestDesktopTimers) SetResetType(v string) *CreateDesktopsRequestDesktopTimers {
	s.ResetType = &v
	return s
}

func (s *CreateDesktopsRequestDesktopTimers) SetTimerType(v string) *CreateDesktopsRequestDesktopTimers {
	s.TimerType = &v
	return s
}

type CreateDesktopsRequestTag struct {
	// The key of the tag. You can specify 1 to 20 keys for a tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag. You can specify 1 to 20 values for a tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateDesktopsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateDesktopsRequestTag) GoString() string {
	return s.String()
}

func (s *CreateDesktopsRequestTag) SetKey(v string) *CreateDesktopsRequestTag {
	s.Key = &v
	return s
}

func (s *CreateDesktopsRequestTag) SetValue(v string) *CreateDesktopsRequestTag {
	s.Value = &v
	return s
}

type CreateDesktopsRequestUserCommands struct {
	// The command content.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The encoding mode of the command content (CommandContent).
	//
	// Valid values:
	//
	// *   Base64: encodes the command content in Base64.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   PlainText: does not encode the command content.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	ContentEncoding *string `json:"ContentEncoding,omitempty" xml:"ContentEncoding,omitempty"`
	// The command language.
	//
	// Valid values:
	//
	// *   RunPowerShellScript: PowerShell command (applicable to Windows cloud desktops).
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   RunShellScript: shell command (applicable to Linux cloud desktops).
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   RunBatScript: batch command (applicable to Windows cloud desktops).
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	ContentType *string `json:"ContentType,omitempty" xml:"ContentType,omitempty"`
}

func (s CreateDesktopsRequestUserCommands) String() string {
	return tea.Prettify(s)
}

func (s CreateDesktopsRequestUserCommands) GoString() string {
	return s.String()
}

func (s *CreateDesktopsRequestUserCommands) SetContent(v string) *CreateDesktopsRequestUserCommands {
	s.Content = &v
	return s
}

func (s *CreateDesktopsRequestUserCommands) SetContentEncoding(v string) *CreateDesktopsRequestUserCommands {
	s.ContentEncoding = &v
	return s
}

func (s *CreateDesktopsRequestUserCommands) SetContentType(v string) *CreateDesktopsRequestUserCommands {
	s.ContentType = &v
	return s
}

type CreateDesktopsResponseBody struct {
	// If multiple cloud desktops are created in a call, the IDs of the cloud desktops are returned.
	DesktopId []*string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty" type:"Repeated"`
	// The ID of the order.
	//
	// > This parameter is returned only when you set the ChargeType parameter to PrePaid.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDesktopsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDesktopsResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDesktopsResponseBody) SetDesktopId(v []*string) *CreateDesktopsResponseBody {
	s.DesktopId = v
	return s
}

func (s *CreateDesktopsResponseBody) SetOrderId(v string) *CreateDesktopsResponseBody {
	s.OrderId = &v
	return s
}

func (s *CreateDesktopsResponseBody) SetRequestId(v string) *CreateDesktopsResponseBody {
	s.RequestId = &v
	return s
}

type CreateDesktopsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDesktopsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDesktopsResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDesktopsResponse) GoString() string {
	return s.String()
}

func (s *CreateDesktopsResponse) SetHeaders(v map[string]*string) *CreateDesktopsResponse {
	s.Headers = v
	return s
}

func (s *CreateDesktopsResponse) SetStatusCode(v int32) *CreateDesktopsResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDesktopsResponse) SetBody(v *CreateDesktopsResponseBody) *CreateDesktopsResponse {
	s.Body = v
	return s
}

type CreateDiskEncryptionServiceRequest struct {
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateDiskEncryptionServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDiskEncryptionServiceRequest) GoString() string {
	return s.String()
}

func (s *CreateDiskEncryptionServiceRequest) SetRegionId(v string) *CreateDiskEncryptionServiceRequest {
	s.RegionId = &v
	return s
}

type CreateDiskEncryptionServiceResponseBody struct {
	OrderId   *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateDiskEncryptionServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDiskEncryptionServiceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDiskEncryptionServiceResponseBody) SetOrderId(v string) *CreateDiskEncryptionServiceResponseBody {
	s.OrderId = &v
	return s
}

func (s *CreateDiskEncryptionServiceResponseBody) SetRequestId(v string) *CreateDiskEncryptionServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDiskEncryptionServiceResponseBody) SetSuccess(v bool) *CreateDiskEncryptionServiceResponseBody {
	s.Success = &v
	return s
}

type CreateDiskEncryptionServiceResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDiskEncryptionServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDiskEncryptionServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDiskEncryptionServiceResponse) GoString() string {
	return s.String()
}

func (s *CreateDiskEncryptionServiceResponse) SetHeaders(v map[string]*string) *CreateDiskEncryptionServiceResponse {
	s.Headers = v
	return s
}

func (s *CreateDiskEncryptionServiceResponse) SetStatusCode(v int32) *CreateDiskEncryptionServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDiskEncryptionServiceResponse) SetBody(v *CreateDiskEncryptionServiceResponseBody) *CreateDiskEncryptionServiceResponse {
	s.Body = v
	return s
}

type CreateImageRequest struct {
	AutoCleanUserdata *bool     `json:"AutoCleanUserdata,omitempty" xml:"AutoCleanUserdata,omitempty"`
	Description       *string   `json:"Description,omitempty" xml:"Description,omitempty"`
	DesktopId         *string   `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	DiskType          *string   `json:"DiskType,omitempty" xml:"DiskType,omitempty"`
	ImageName         *string   `json:"ImageName,omitempty" xml:"ImageName,omitempty"`
	ImageResourceType *string   `json:"ImageResourceType,omitempty" xml:"ImageResourceType,omitempty"`
	RegionId          *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	SnapshotId        *string   `json:"SnapshotId,omitempty" xml:"SnapshotId,omitempty"`
	SnapshotIds       []*string `json:"SnapshotIds,omitempty" xml:"SnapshotIds,omitempty" type:"Repeated"`
}

func (s CreateImageRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateImageRequest) GoString() string {
	return s.String()
}

func (s *CreateImageRequest) SetAutoCleanUserdata(v bool) *CreateImageRequest {
	s.AutoCleanUserdata = &v
	return s
}

func (s *CreateImageRequest) SetDescription(v string) *CreateImageRequest {
	s.Description = &v
	return s
}

func (s *CreateImageRequest) SetDesktopId(v string) *CreateImageRequest {
	s.DesktopId = &v
	return s
}

func (s *CreateImageRequest) SetDiskType(v string) *CreateImageRequest {
	s.DiskType = &v
	return s
}

func (s *CreateImageRequest) SetImageName(v string) *CreateImageRequest {
	s.ImageName = &v
	return s
}

func (s *CreateImageRequest) SetImageResourceType(v string) *CreateImageRequest {
	s.ImageResourceType = &v
	return s
}

func (s *CreateImageRequest) SetRegionId(v string) *CreateImageRequest {
	s.RegionId = &v
	return s
}

func (s *CreateImageRequest) SetSnapshotId(v string) *CreateImageRequest {
	s.SnapshotId = &v
	return s
}

func (s *CreateImageRequest) SetSnapshotIds(v []*string) *CreateImageRequest {
	s.SnapshotIds = v
	return s
}

type CreateImageResponseBody struct {
	ImageId   *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateImageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateImageResponseBody) GoString() string {
	return s.String()
}

func (s *CreateImageResponseBody) SetImageId(v string) *CreateImageResponseBody {
	s.ImageId = &v
	return s
}

func (s *CreateImageResponseBody) SetRequestId(v string) *CreateImageResponseBody {
	s.RequestId = &v
	return s
}

type CreateImageResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateImageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateImageResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateImageResponse) GoString() string {
	return s.String()
}

func (s *CreateImageResponse) SetHeaders(v map[string]*string) *CreateImageResponse {
	s.Headers = v
	return s
}

func (s *CreateImageResponse) SetStatusCode(v int32) *CreateImageResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateImageResponse) SetBody(v *CreateImageResponseBody) *CreateImageResponse {
	s.Body = v
	return s
}

type CreateNASFileSystemRequest struct {
	Description  *string `json:"Description,omitempty" xml:"Description,omitempty"`
	EncryptType  *string `json:"EncryptType,omitempty" xml:"EncryptType,omitempty"`
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	RegionId     *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	StorageType  *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
}

func (s CreateNASFileSystemRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateNASFileSystemRequest) GoString() string {
	return s.String()
}

func (s *CreateNASFileSystemRequest) SetDescription(v string) *CreateNASFileSystemRequest {
	s.Description = &v
	return s
}

func (s *CreateNASFileSystemRequest) SetEncryptType(v string) *CreateNASFileSystemRequest {
	s.EncryptType = &v
	return s
}

func (s *CreateNASFileSystemRequest) SetName(v string) *CreateNASFileSystemRequest {
	s.Name = &v
	return s
}

func (s *CreateNASFileSystemRequest) SetOfficeSiteId(v string) *CreateNASFileSystemRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *CreateNASFileSystemRequest) SetRegionId(v string) *CreateNASFileSystemRequest {
	s.RegionId = &v
	return s
}

func (s *CreateNASFileSystemRequest) SetStorageType(v string) *CreateNASFileSystemRequest {
	s.StorageType = &v
	return s
}

type CreateNASFileSystemResponseBody struct {
	FileSystemId      *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	FileSystemName    *string `json:"FileSystemName,omitempty" xml:"FileSystemName,omitempty"`
	MountTargetDomain *string `json:"MountTargetDomain,omitempty" xml:"MountTargetDomain,omitempty"`
	OfficeSiteId      *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	RequestId         *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateNASFileSystemResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateNASFileSystemResponseBody) GoString() string {
	return s.String()
}

func (s *CreateNASFileSystemResponseBody) SetFileSystemId(v string) *CreateNASFileSystemResponseBody {
	s.FileSystemId = &v
	return s
}

func (s *CreateNASFileSystemResponseBody) SetFileSystemName(v string) *CreateNASFileSystemResponseBody {
	s.FileSystemName = &v
	return s
}

func (s *CreateNASFileSystemResponseBody) SetMountTargetDomain(v string) *CreateNASFileSystemResponseBody {
	s.MountTargetDomain = &v
	return s
}

func (s *CreateNASFileSystemResponseBody) SetOfficeSiteId(v string) *CreateNASFileSystemResponseBody {
	s.OfficeSiteId = &v
	return s
}

func (s *CreateNASFileSystemResponseBody) SetRequestId(v string) *CreateNASFileSystemResponseBody {
	s.RequestId = &v
	return s
}

type CreateNASFileSystemResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateNASFileSystemResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateNASFileSystemResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateNASFileSystemResponse) GoString() string {
	return s.String()
}

func (s *CreateNASFileSystemResponse) SetHeaders(v map[string]*string) *CreateNASFileSystemResponse {
	s.Headers = v
	return s
}

func (s *CreateNASFileSystemResponse) SetStatusCode(v int32) *CreateNASFileSystemResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateNASFileSystemResponse) SetBody(v *CreateNASFileSystemResponseBody) *CreateNASFileSystemResponse {
	s.Body = v
	return s
}

type CreateNetworkPackageRequest struct {
	// Specifies whether to enable automatic payment.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// Specifies whether to enable auto-renewal.
	AutoRenew *bool `json:"AutoRenew,omitempty" xml:"AutoRenew,omitempty"`
	// The maximum public bandwidth. Unit: Mbit/s.\
	// Valid values for the pay-by-data-transfer type (PayByTraffic): 10 to 200. Valid values for the pay-by-bandwith type (PayByBandwidth): 10 to 1000.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The metering method of the pay-as-you-go Internet access package. Valid values: PayByTraffic: pay-by-data-transfer. PayByBandwidth: pay-by-bandwidth. Default value: PayByTraffic.
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The ID of the workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The billing method of the Internet access package.
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The duration of the Internet access package.
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The unit of duration that you want to use for the Internet access package.
	PeriodUnit *string `json:"PeriodUnit,omitempty" xml:"PeriodUnit,omitempty"`
	// The ID of the sales promotion.
	PromotionId *string `json:"PromotionId,omitempty" xml:"PromotionId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateNetworkPackageRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateNetworkPackageRequest) GoString() string {
	return s.String()
}

func (s *CreateNetworkPackageRequest) SetAutoPay(v bool) *CreateNetworkPackageRequest {
	s.AutoPay = &v
	return s
}

func (s *CreateNetworkPackageRequest) SetAutoRenew(v bool) *CreateNetworkPackageRequest {
	s.AutoRenew = &v
	return s
}

func (s *CreateNetworkPackageRequest) SetBandwidth(v int32) *CreateNetworkPackageRequest {
	s.Bandwidth = &v
	return s
}

func (s *CreateNetworkPackageRequest) SetInternetChargeType(v string) *CreateNetworkPackageRequest {
	s.InternetChargeType = &v
	return s
}

func (s *CreateNetworkPackageRequest) SetOfficeSiteId(v string) *CreateNetworkPackageRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *CreateNetworkPackageRequest) SetPayType(v string) *CreateNetworkPackageRequest {
	s.PayType = &v
	return s
}

func (s *CreateNetworkPackageRequest) SetPeriod(v int32) *CreateNetworkPackageRequest {
	s.Period = &v
	return s
}

func (s *CreateNetworkPackageRequest) SetPeriodUnit(v string) *CreateNetworkPackageRequest {
	s.PeriodUnit = &v
	return s
}

func (s *CreateNetworkPackageRequest) SetPromotionId(v string) *CreateNetworkPackageRequest {
	s.PromotionId = &v
	return s
}

func (s *CreateNetworkPackageRequest) SetRegionId(v string) *CreateNetworkPackageRequest {
	s.RegionId = &v
	return s
}

type CreateNetworkPackageResponseBody struct {
	// The ID of the Internet access package.
	NetworkPackageId *string `json:"NetworkPackageId,omitempty" xml:"NetworkPackageId,omitempty"`
	// The ID of the bill.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateNetworkPackageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateNetworkPackageResponseBody) GoString() string {
	return s.String()
}

func (s *CreateNetworkPackageResponseBody) SetNetworkPackageId(v string) *CreateNetworkPackageResponseBody {
	s.NetworkPackageId = &v
	return s
}

func (s *CreateNetworkPackageResponseBody) SetOrderId(v string) *CreateNetworkPackageResponseBody {
	s.OrderId = &v
	return s
}

func (s *CreateNetworkPackageResponseBody) SetRequestId(v string) *CreateNetworkPackageResponseBody {
	s.RequestId = &v
	return s
}

type CreateNetworkPackageResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateNetworkPackageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateNetworkPackageResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateNetworkPackageResponse) GoString() string {
	return s.String()
}

func (s *CreateNetworkPackageResponse) SetHeaders(v map[string]*string) *CreateNetworkPackageResponse {
	s.Headers = v
	return s
}

func (s *CreateNetworkPackageResponse) SetStatusCode(v int32) *CreateNetworkPackageResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateNetworkPackageResponse) SetBody(v *CreateNetworkPackageResponseBody) *CreateNetworkPackageResponse {
	s.Body = v
	return s
}

type CreatePolicyGroupRequest struct {
	AdminAccess *string `json:"AdminAccess,omitempty" xml:"AdminAccess,omitempty"`
	// Specifies whether to enable the anti-screenshot feature.
	//
	// Valid values:
	//
	// *   off: Anti-screenshot is disabled. This value is the default value.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   on: Anti-screenshot is enabled.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	AppContentProtection *string `json:"AppContentProtection,omitempty" xml:"AppContentProtection,omitempty"`
	// The client IP address whitelists. Only the client IP addresses in whitelists can access the cloud desktop.
	AuthorizeAccessPolicyRule []*CreatePolicyGroupRequestAuthorizeAccessPolicyRule `json:"AuthorizeAccessPolicyRule,omitempty" xml:"AuthorizeAccessPolicyRule,omitempty" type:"Repeated"`
	// The security group rules.
	AuthorizeSecurityPolicyRule []*CreatePolicyGroupRequestAuthorizeSecurityPolicyRule `json:"AuthorizeSecurityPolicyRule,omitempty" xml:"AuthorizeSecurityPolicyRule,omitempty" type:"Repeated"`
	// Specifies whether to enable the webcam redirection feature.
	//
	// Valid values:
	//
	// *   off: Webcam redirection is disabled.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   on: Webcam redirection is enabled. This value is the default value.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	CameraRedirect *string `json:"CameraRedirect,omitempty" xml:"CameraRedirect,omitempty"`
	// The logon methods. You can use this parameter to determine which clients can be used to connect to the cloud desktop.
	ClientType []*CreatePolicyGroupRequestClientType `json:"ClientType,omitempty" xml:"ClientType,omitempty" type:"Repeated"`
	// The permissions on the clipboard.
	//
	// Valid values:
	//
	// *   read: specifies one-way transfer
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     You can copy data from your local computer to the cloud desktop, but cannot copy data from the cloud desktop to your local computer.
	//
	//     <!-- -->
	//
	// *   readwrite: specifies two-way transfer
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     You can copy data between your local computer and the cloud desktop.
	//
	//     <!-- -->
	//
	// *   off: disables both one-way and two-way transfer
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     You cannot copy data between your local computer and the cloud desktop. This value is the default value.
	//
	//     <!-- -->
	Clipboard *string `json:"Clipboard,omitempty" xml:"Clipboard,omitempty"`
	// Access control for domain names. The wildcard character (\*) is supported for domain names. Separate multiple domain names with commas (,). Valid values:
	//
	// *   off
	// *   on
	DomainList *string `json:"DomainList,omitempty" xml:"DomainList,omitempty"`
	// The details of the domain name resolution policy.
	DomainResolveRule []*CreatePolicyGroupRequestDomainResolveRule `json:"DomainResolveRule,omitempty" xml:"DomainResolveRule,omitempty" type:"Repeated"`
	// The type of the domain name resolution policy.
	//
	// Valid values:
	//
	// *   OFF
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   ON
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	DomainResolveRuleType *string `json:"DomainResolveRuleType,omitempty" xml:"DomainResolveRuleType,omitempty"`
	// Specifies whether to allow end users to seek assistance from the administrator. Valid values: ON OFF
	EndUserApplyAdminCoordinate *string `json:"EndUserApplyAdminCoordinate,omitempty" xml:"EndUserApplyAdminCoordinate,omitempty"`
	// The switch for collaboration between end users. Valid values: ON OFF
	EndUserGroupCoordinate *string `json:"EndUserGroupCoordinate,omitempty" xml:"EndUserGroupCoordinate,omitempty"`
	// Specifies whether to enable the image display quality feature for the Graphics cloud desktop. If you have high requirements for desktop performance and user experience, we recommend that you enable this feature. For example, you can enable this feature in professional design scenarios.
	//
	// Valid values:
	//
	// *   off
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   on
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	GpuAcceleration *string `json:"GpuAcceleration,omitempty" xml:"GpuAcceleration,omitempty"`
	// The policy for HTML5 client access.
	//
	// > We recommend that you use the ClientType parameter to manage the type of Alibaba Cloud Workspace clients for desktop connection.
	//
	// Valid values:
	//
	// *   off: HTML5 client access is disabled. This value is the default value.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   on: HTML5 client access is enabled.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Html5Access *string `json:"Html5Access,omitempty" xml:"Html5Access,omitempty"`
	// The file transfer policy for HTML5 clients.
	//
	// Valid values:
	//
	// *   all: Files can be uploaded and downloaded between your computer and HTML5 clients.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   download: Files on HTML5 clients can be downloaded to your computer.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   upload: Files on your computer can be uploaded to HTML5 clients.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   off: File transfer between HTML5 clients and your computer is disabled. This value is the default value.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Html5FileTransfer *string `json:"Html5FileTransfer,omitempty" xml:"Html5FileTransfer,omitempty"`
	// The protocol that you want to use for network communication. Valid values: -TCP: Only TCP is allowed. -BOTH: Automatic switch between TCP and UDP is allowed. Default value: TCP.
	InternetCommunicationProtocol *string `json:"InternetCommunicationProtocol,omitempty" xml:"InternetCommunicationProtocol,omitempty"`
	// The permissions on local disk mapping.
	//
	// Valid values:
	//
	// *   read: read-only
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     The disks on your local computer are mapped to the cloud desktop. You can only read (copy) files on the local computer.
	//
	//     <!-- -->
	//
	// *   readwrite: read and write
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     The disks on your local computer are mapped to the cloud desktop. You can read (copy) and modify files on your local computer.
	//
	//     <!-- -->
	//
	// *   off:
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     The disks on your local computer are not mapped to the cloud desktop. This value is the default value.
	//
	//     <!-- -->
	LocalDrive *string `json:"LocalDrive,omitempty" xml:"LocalDrive,omitempty"`
	// The name of the policy.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Specifies whether to enable the network redirection feature.
	//
	// > This feature is in invitational preview and is not available to the public.
	//
	// Valid values:
	//
	// *   off (default): The network redirection feature is disabled.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   on: The network redirection feature is enabled.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	NetRedirect *string `json:"NetRedirect,omitempty" xml:"NetRedirect,omitempty"`
	// Specifies whether to allow user preemption.
	//
	// > To improve user experience and ensure data security, multiple end users cannot connect to the same cloud desktop at the same time. The default value of this parameter is `off`, and the value cannot be changed.
	PreemptLogin *string `json:"PreemptLogin,omitempty" xml:"PreemptLogin,omitempty"`
	// The names of the users that are allowed to connect to the same cloud desktop at the same time. You can specify up to five usernames.
	//
	// > To improve user experience and ensure data security, we recommend that you disable the user preemption feature.
	PreemptLoginUser []*string `json:"PreemptLoginUser,omitempty" xml:"PreemptLoginUser,omitempty" type:"Repeated"`
	// The policy for printer redirection.
	//
	// Valid values:
	//
	// *   off: Printer redirection is disabled.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   on: Printer redirection is enabled.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	PrinterRedirection *string `json:"PrinterRedirection,omitempty" xml:"PrinterRedirection,omitempty"`
	// Specifies whether to enable the custom screen recording feature.
	//
	// Valid values:
	//
	// *   off: Custom screen recording is disabled. This value is the default value.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   on: Custom screen recording is enabled.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	RecordContent *string `json:"RecordContent,omitempty" xml:"RecordContent,omitempty"`
	// The duration in which the custom screen recording is valid. Default value: 30. Unit: days.
	RecordContentExpires *int64 `json:"RecordContentExpires,omitempty" xml:"RecordContentExpires,omitempty"`
	// Specifies whether to enable screen recording.
	//
	// Valid values:
	//
	// *   ALLTIME: All operations that are performed by end users on cloud desktops are recorded. The recording starts immediately when end users connect to cloud desktops and ends when the end users disconnect from the cloud desktops.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   PERIOD: The operations that are performed by end users on cloud desktops during a specified period of time are recorded. You must set the start time and end time for the recording period.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   OFF: Screen recording is disabled.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Recording *string `json:"Recording,omitempty" xml:"Recording,omitempty"`
	// Specifies whether to record audio data during the screen recording. Valid values:
	//
	// *   on: records audio and video data
	// *   off: records only video data
	RecordingAudio *string `json:"RecordingAudio,omitempty" xml:"RecordingAudio,omitempty"`
	// The duration from the time when the screen recording starts to the time when the screen recording stops. If you specify the Recording parameter, you must also specify the RecordingDuration parameter. When the specified duration ends, a recording file is generated.
	RecordingDuration *int32 `json:"RecordingDuration,omitempty" xml:"RecordingDuration,omitempty"`
	// The time when the screen recording stops. Specify the value in the HH:MM:SS format. The value of this parameter is valid only if you set the Recording parameter to PERIOD.
	RecordingEndTime *string `json:"RecordingEndTime,omitempty" xml:"RecordingEndTime,omitempty"`
	// The duration in which the screen recording is valid. Unit: days.
	RecordingExpires *int64 `json:"RecordingExpires,omitempty" xml:"RecordingExpires,omitempty"`
	// The frame rate of screen recording.
	//
	// Valid values:
	//
	// *   2
	//
	// *   5
	//
	// *  10
	//
	// *   15
	RecordingFps *int64 `json:"RecordingFps,omitempty" xml:"RecordingFps,omitempty"`
	// The time when screen recording starts. Specify the value in the HH:MM:SS format. The value of this parameter is valid only if you set the Recording parameter to PERIOD.
	RecordingStartTime *string `json:"RecordingStartTime,omitempty" xml:"RecordingStartTime,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The permission to control the keyboard and the mouse during remote assistance.
	//
	// Valid values:
	//
	// *   \-
	//
	//     <!-- -->
	//
	//     optionalControl
	//
	//     <!-- -->
	//
	//     : By default, this feature is disabled. You can enable it by applying permissions.
	//
	//     <!-- -->
	//
	// *   fullControl: The permission is granted.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   disableControl: The permission is revoked.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	RemoteCoordinate *string `json:"RemoteCoordinate,omitempty" xml:"RemoteCoordinate,omitempty"`
	// The effective scope of the policy. Valid values:
	//
	// *   GLOBAL: The policy takes effect globally.
	// *   IP: The policy takes effect for specified IP addresses.
	Scope *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
	// The effective CIDR block ranges. If you set the Scope parameter to IP, you must specify this parameter.
	ScopeValue []*string `json:"ScopeValue,omitempty" xml:"ScopeValue,omitempty" type:"Repeated"`
	// Specifies whether to enable USB redirection.
	//
	// Valid values:
	//
	// *   off: USB redirection is disabled. This value is the default value.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   on: USB redirection is enabled.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	UsbRedirect *string `json:"UsbRedirect,omitempty" xml:"UsbRedirect,omitempty"`
	// The USB redirection rules.
	UsbSupplyRedirectRule []*CreatePolicyGroupRequestUsbSupplyRedirectRule `json:"UsbSupplyRedirectRule,omitempty" xml:"UsbSupplyRedirectRule,omitempty" type:"Repeated"`
	// Specifies whether to enable the multimedia redirection feature. Valid values:
	//
	// *   on: Multimedia redirection is enabled.
	// *   off: Multimedia redirection is disabled.
	VideoRedirect *string `json:"VideoRedirect,omitempty" xml:"VideoRedirect,omitempty"`
	// The policy for image display quality.
	//
	// Valid values:
	//
	// *   high
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   low
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   lossless
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   medium: adaptive. This value is the default value.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	VisualQuality *string `json:"VisualQuality,omitempty" xml:"VisualQuality,omitempty"`
	// Specifies whether to enable watermarking.
	//
	// Valid values:
	//
	// *   off: Watermarking is disabled. This value is the default value.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   on: Watermarking is enabled.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Watermark *string `json:"Watermark,omitempty" xml:"Watermark,omitempty"`
	// The font color of the watermark. Valid values: 0 to 16777215.
	WatermarkColor *int32 `json:"WatermarkColor,omitempty" xml:"WatermarkColor,omitempty"`
	// The inclination angle of the watermark. Valid values: -10 to -30.
	WatermarkDegree *float64 `json:"WatermarkDegree,omitempty" xml:"WatermarkDegree,omitempty"`
	// The font size of the watermark. Valid values: 10 to 20.
	WatermarkFontSize *int32 `json:"WatermarkFontSize,omitempty" xml:"WatermarkFontSize,omitempty"`
	// The font style of the watermark. Valid values:
	//
	// *   plain
	// *   bold
	WatermarkFontStyle *string `json:"WatermarkFontStyle,omitempty" xml:"WatermarkFontStyle,omitempty"`
	// The number of watermark rows. This parameter is now invalid.
	WatermarkRowAmount *int32 `json:"WatermarkRowAmount,omitempty" xml:"WatermarkRowAmount,omitempty"`
	// The security priority for invisible watermarks. Valid values: on and off.
	WatermarkSecurity *string `json:"WatermarkSecurity,omitempty" xml:"WatermarkSecurity,omitempty"`
	// The transparency of the watermark.
	//
	// Valid values:
	//
	// *   LIGHT
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   DARK
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   MIDDLE
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	WatermarkTransparency *string `json:"WatermarkTransparency,omitempty" xml:"WatermarkTransparency,omitempty"`
	// The transparency of the watermark. A larger value specifies that the watermark is less transparent. Valid values: 10 to 100.
	WatermarkTransparencyValue *int32 `json:"WatermarkTransparencyValue,omitempty" xml:"WatermarkTransparencyValue,omitempty"`
	// The type of the watermark. You can specify multiple types of watermarks at the same time. Separate multiple watermark types with commas (,).
	//
	// Valid values:
	//
	// *   EndUserId: The ID of the end user is displayed.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   HostName: The rightmost 15 characters of the cloud desktop ID are displayed.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	WatermarkType *string `json:"WatermarkType,omitempty" xml:"WatermarkType,omitempty"`
}

func (s CreatePolicyGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreatePolicyGroupRequest) GoString() string {
	return s.String()
}

func (s *CreatePolicyGroupRequest) SetAdminAccess(v string) *CreatePolicyGroupRequest {
	s.AdminAccess = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetAppContentProtection(v string) *CreatePolicyGroupRequest {
	s.AppContentProtection = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetAuthorizeAccessPolicyRule(v []*CreatePolicyGroupRequestAuthorizeAccessPolicyRule) *CreatePolicyGroupRequest {
	s.AuthorizeAccessPolicyRule = v
	return s
}

func (s *CreatePolicyGroupRequest) SetAuthorizeSecurityPolicyRule(v []*CreatePolicyGroupRequestAuthorizeSecurityPolicyRule) *CreatePolicyGroupRequest {
	s.AuthorizeSecurityPolicyRule = v
	return s
}

func (s *CreatePolicyGroupRequest) SetCameraRedirect(v string) *CreatePolicyGroupRequest {
	s.CameraRedirect = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetClientType(v []*CreatePolicyGroupRequestClientType) *CreatePolicyGroupRequest {
	s.ClientType = v
	return s
}

func (s *CreatePolicyGroupRequest) SetClipboard(v string) *CreatePolicyGroupRequest {
	s.Clipboard = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetDomainList(v string) *CreatePolicyGroupRequest {
	s.DomainList = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetDomainResolveRule(v []*CreatePolicyGroupRequestDomainResolveRule) *CreatePolicyGroupRequest {
	s.DomainResolveRule = v
	return s
}

func (s *CreatePolicyGroupRequest) SetDomainResolveRuleType(v string) *CreatePolicyGroupRequest {
	s.DomainResolveRuleType = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetEndUserApplyAdminCoordinate(v string) *CreatePolicyGroupRequest {
	s.EndUserApplyAdminCoordinate = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetEndUserGroupCoordinate(v string) *CreatePolicyGroupRequest {
	s.EndUserGroupCoordinate = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetGpuAcceleration(v string) *CreatePolicyGroupRequest {
	s.GpuAcceleration = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetHtml5Access(v string) *CreatePolicyGroupRequest {
	s.Html5Access = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetHtml5FileTransfer(v string) *CreatePolicyGroupRequest {
	s.Html5FileTransfer = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetInternetCommunicationProtocol(v string) *CreatePolicyGroupRequest {
	s.InternetCommunicationProtocol = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetLocalDrive(v string) *CreatePolicyGroupRequest {
	s.LocalDrive = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetName(v string) *CreatePolicyGroupRequest {
	s.Name = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetNetRedirect(v string) *CreatePolicyGroupRequest {
	s.NetRedirect = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetPreemptLogin(v string) *CreatePolicyGroupRequest {
	s.PreemptLogin = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetPreemptLoginUser(v []*string) *CreatePolicyGroupRequest {
	s.PreemptLoginUser = v
	return s
}

func (s *CreatePolicyGroupRequest) SetPrinterRedirection(v string) *CreatePolicyGroupRequest {
	s.PrinterRedirection = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetRecordContent(v string) *CreatePolicyGroupRequest {
	s.RecordContent = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetRecordContentExpires(v int64) *CreatePolicyGroupRequest {
	s.RecordContentExpires = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetRecording(v string) *CreatePolicyGroupRequest {
	s.Recording = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetRecordingAudio(v string) *CreatePolicyGroupRequest {
	s.RecordingAudio = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetRecordingDuration(v int32) *CreatePolicyGroupRequest {
	s.RecordingDuration = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetRecordingEndTime(v string) *CreatePolicyGroupRequest {
	s.RecordingEndTime = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetRecordingExpires(v int64) *CreatePolicyGroupRequest {
	s.RecordingExpires = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetRecordingFps(v int64) *CreatePolicyGroupRequest {
	s.RecordingFps = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetRecordingStartTime(v string) *CreatePolicyGroupRequest {
	s.RecordingStartTime = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetRegionId(v string) *CreatePolicyGroupRequest {
	s.RegionId = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetRemoteCoordinate(v string) *CreatePolicyGroupRequest {
	s.RemoteCoordinate = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetScope(v string) *CreatePolicyGroupRequest {
	s.Scope = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetScopeValue(v []*string) *CreatePolicyGroupRequest {
	s.ScopeValue = v
	return s
}

func (s *CreatePolicyGroupRequest) SetUsbRedirect(v string) *CreatePolicyGroupRequest {
	s.UsbRedirect = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetUsbSupplyRedirectRule(v []*CreatePolicyGroupRequestUsbSupplyRedirectRule) *CreatePolicyGroupRequest {
	s.UsbSupplyRedirectRule = v
	return s
}

func (s *CreatePolicyGroupRequest) SetVideoRedirect(v string) *CreatePolicyGroupRequest {
	s.VideoRedirect = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetVisualQuality(v string) *CreatePolicyGroupRequest {
	s.VisualQuality = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetWatermark(v string) *CreatePolicyGroupRequest {
	s.Watermark = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetWatermarkColor(v int32) *CreatePolicyGroupRequest {
	s.WatermarkColor = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetWatermarkDegree(v float64) *CreatePolicyGroupRequest {
	s.WatermarkDegree = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetWatermarkFontSize(v int32) *CreatePolicyGroupRequest {
	s.WatermarkFontSize = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetWatermarkFontStyle(v string) *CreatePolicyGroupRequest {
	s.WatermarkFontStyle = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetWatermarkRowAmount(v int32) *CreatePolicyGroupRequest {
	s.WatermarkRowAmount = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetWatermarkSecurity(v string) *CreatePolicyGroupRequest {
	s.WatermarkSecurity = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetWatermarkTransparency(v string) *CreatePolicyGroupRequest {
	s.WatermarkTransparency = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetWatermarkTransparencyValue(v int32) *CreatePolicyGroupRequest {
	s.WatermarkTransparencyValue = &v
	return s
}

func (s *CreatePolicyGroupRequest) SetWatermarkType(v string) *CreatePolicyGroupRequest {
	s.WatermarkType = &v
	return s
}

type CreatePolicyGroupRequestAuthorizeAccessPolicyRule struct {
	// The IPv4 CIDR block that you want to access from the client. The value is an IPv4 CIDR block.
	CidrIp *string `json:"CidrIp,omitempty" xml:"CidrIp,omitempty"`
	// The description of the client IP address whitelist.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
}

func (s CreatePolicyGroupRequestAuthorizeAccessPolicyRule) String() string {
	return tea.Prettify(s)
}

func (s CreatePolicyGroupRequestAuthorizeAccessPolicyRule) GoString() string {
	return s.String()
}

func (s *CreatePolicyGroupRequestAuthorizeAccessPolicyRule) SetCidrIp(v string) *CreatePolicyGroupRequestAuthorizeAccessPolicyRule {
	s.CidrIp = &v
	return s
}

func (s *CreatePolicyGroupRequestAuthorizeAccessPolicyRule) SetDescription(v string) *CreatePolicyGroupRequestAuthorizeAccessPolicyRule {
	s.Description = &v
	return s
}

type CreatePolicyGroupRequestAuthorizeSecurityPolicyRule struct {
	// The IPv4 CIDR block of the security group rule.
	CidrIp *string `json:"CidrIp,omitempty" xml:"CidrIp,omitempty"`
	// The description of the security group rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The protocol type of the security group rule.
	//
	// Valid values:
	//
	// *   TCP
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   UDP
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   ALL: all protocols
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   GRE
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   ICMP: ICMP (IPv4)
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	IpProtocol *string `json:"IpProtocol,omitempty" xml:"IpProtocol,omitempty"`
	// The authorization policy of the security group rule.
	//
	// Valid values:
	//
	// *   drop: denies all access requests
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     If no denied messages are returned, the requests timed out or failed.
	//
	//     <!-- -->
	//
	// *   accept: accepts all access requests
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     This value is the default value.
	//
	//     <!-- -->
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	// The port range of the security group rule. The value range of this parameter varies based on the value of the IpProtocol parameter.
	//
	// *   If you set the IpProtocol parameter to TCP or UDP, the value range is 1 to 65535. Separate the start port number and the end port number with a forward slash (/). Example: 1/200.
	// *   If you set the IpProtocol parameter to ICMP, the start port number and the end port number are -1/-1.
	// *   If you set the IpProtocol parameter to GRE, the start port number and the end port number are -1/-1.
	// *   If you set the IpProtocol parameter to ALL, the start port number and the end port number are -1/-1.
	//
	// For more information about the common ports of applications, see [Common ports](~~40724~~).
	PortRange *string `json:"PortRange,omitempty" xml:"PortRange,omitempty"`
	// The priority of the security group rule. A smaller value specifies a higher priority.\
	// Valid values: 1 to 60.\
	// Default value: 1.
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The direction of the security group rule.
	//
	// Valid values:
	//
	// *   outflow: outbound
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   inflow: inbound
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreatePolicyGroupRequestAuthorizeSecurityPolicyRule) String() string {
	return tea.Prettify(s)
}

func (s CreatePolicyGroupRequestAuthorizeSecurityPolicyRule) GoString() string {
	return s.String()
}

func (s *CreatePolicyGroupRequestAuthorizeSecurityPolicyRule) SetCidrIp(v string) *CreatePolicyGroupRequestAuthorizeSecurityPolicyRule {
	s.CidrIp = &v
	return s
}

func (s *CreatePolicyGroupRequestAuthorizeSecurityPolicyRule) SetDescription(v string) *CreatePolicyGroupRequestAuthorizeSecurityPolicyRule {
	s.Description = &v
	return s
}

func (s *CreatePolicyGroupRequestAuthorizeSecurityPolicyRule) SetIpProtocol(v string) *CreatePolicyGroupRequestAuthorizeSecurityPolicyRule {
	s.IpProtocol = &v
	return s
}

func (s *CreatePolicyGroupRequestAuthorizeSecurityPolicyRule) SetPolicy(v string) *CreatePolicyGroupRequestAuthorizeSecurityPolicyRule {
	s.Policy = &v
	return s
}

func (s *CreatePolicyGroupRequestAuthorizeSecurityPolicyRule) SetPortRange(v string) *CreatePolicyGroupRequestAuthorizeSecurityPolicyRule {
	s.PortRange = &v
	return s
}

func (s *CreatePolicyGroupRequestAuthorizeSecurityPolicyRule) SetPriority(v string) *CreatePolicyGroupRequestAuthorizeSecurityPolicyRule {
	s.Priority = &v
	return s
}

func (s *CreatePolicyGroupRequestAuthorizeSecurityPolicyRule) SetType(v string) *CreatePolicyGroupRequestAuthorizeSecurityPolicyRule {
	s.Type = &v
	return s
}

type CreatePolicyGroupRequestClientType struct {
	// The type of the client.
	//
	// > By default, if you do not specify the ClientType parameter, all types of clients can be used to connect to cloud desktops.
	//
	// Valid values:
	//
	// *   html5: web clients
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   android: Android clients
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   linux: Alibaba Cloud Workspace clients
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   ios: iOS clients
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   windows: Windows clients
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   macos: macOS clients
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	ClientType *string `json:"ClientType,omitempty" xml:"ClientType,omitempty"`
	// Specifies whether a specific client type can be used to connect to the cloud desktop.
	//
	// > By default, if you do not specify the ClientType parameter, all types of clients can be used to connect to cloud desktops.
	//
	// Valid values:
	//
	// *   OFF: Clients of the specified type cannot be used to connect to cloud desktops.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   ON: Clients of the specified type can be used to connect to cloud desktops.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s CreatePolicyGroupRequestClientType) String() string {
	return tea.Prettify(s)
}

func (s CreatePolicyGroupRequestClientType) GoString() string {
	return s.String()
}

func (s *CreatePolicyGroupRequestClientType) SetClientType(v string) *CreatePolicyGroupRequestClientType {
	s.ClientType = &v
	return s
}

func (s *CreatePolicyGroupRequestClientType) SetStatus(v string) *CreatePolicyGroupRequestClientType {
	s.Status = &v
	return s
}

type CreatePolicyGroupRequestDomainResolveRule struct {
	// The description of the policy.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The domain name.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// Specifies whether to allow the policy.
	//
	// Valid values:
	//
	// *   allow
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   block
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
}

func (s CreatePolicyGroupRequestDomainResolveRule) String() string {
	return tea.Prettify(s)
}

func (s CreatePolicyGroupRequestDomainResolveRule) GoString() string {
	return s.String()
}

func (s *CreatePolicyGroupRequestDomainResolveRule) SetDescription(v string) *CreatePolicyGroupRequestDomainResolveRule {
	s.Description = &v
	return s
}

func (s *CreatePolicyGroupRequestDomainResolveRule) SetDomain(v string) *CreatePolicyGroupRequestDomainResolveRule {
	s.Domain = &v
	return s
}

func (s *CreatePolicyGroupRequestDomainResolveRule) SetPolicy(v string) *CreatePolicyGroupRequestDomainResolveRule {
	s.Policy = &v
	return s
}

type CreatePolicyGroupRequestUsbSupplyRedirectRule struct {
	// The description of the rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The class of the device. If you set the `usbRuleType` parameter to 1, you must specify this parameter. For more information, see [Defined Class Codes](https://www.usb.org/defined-class-codes).
	DeviceClass *string `json:"DeviceClass,omitempty" xml:"DeviceClass,omitempty"`
	// The subclass of the device. If you set the `usbRuleType` parameter to 1, you must specify this parameter. For more information, see [Defined Class Codes](https://www.usb.org/defined-class-codes).
	DeviceSubclass *string `json:"DeviceSubclass,omitempty" xml:"DeviceSubclass,omitempty"`
	// The ID of the service.
	ProductId *string `json:"ProductId,omitempty" xml:"ProductId,omitempty"`
	// The type of USB redirection.
	//
	// Valid values:
	//
	// *   1: allows USB redirection
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   2: forbids USB redirection
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	UsbRedirectType *int64 `json:"UsbRedirectType,omitempty" xml:"UsbRedirectType,omitempty"`
	// The type of the USB redirection rule.
	//
	// Valid values:
	//
	// *   1: by device class
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   2: by device vendor
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	UsbRuleType *int64 `json:"UsbRuleType,omitempty" xml:"UsbRuleType,omitempty"`
	// The ID of the vendor. For more information, see [Valid USB Vendor IDs (VIDs)](https://www.usb.org/sites/default/files/vendor_ids032322.pdf\_1.pdf).
	VendorId *string `json:"VendorId,omitempty" xml:"VendorId,omitempty"`
}

func (s CreatePolicyGroupRequestUsbSupplyRedirectRule) String() string {
	return tea.Prettify(s)
}

func (s CreatePolicyGroupRequestUsbSupplyRedirectRule) GoString() string {
	return s.String()
}

func (s *CreatePolicyGroupRequestUsbSupplyRedirectRule) SetDescription(v string) *CreatePolicyGroupRequestUsbSupplyRedirectRule {
	s.Description = &v
	return s
}

func (s *CreatePolicyGroupRequestUsbSupplyRedirectRule) SetDeviceClass(v string) *CreatePolicyGroupRequestUsbSupplyRedirectRule {
	s.DeviceClass = &v
	return s
}

func (s *CreatePolicyGroupRequestUsbSupplyRedirectRule) SetDeviceSubclass(v string) *CreatePolicyGroupRequestUsbSupplyRedirectRule {
	s.DeviceSubclass = &v
	return s
}

func (s *CreatePolicyGroupRequestUsbSupplyRedirectRule) SetProductId(v string) *CreatePolicyGroupRequestUsbSupplyRedirectRule {
	s.ProductId = &v
	return s
}

func (s *CreatePolicyGroupRequestUsbSupplyRedirectRule) SetUsbRedirectType(v int64) *CreatePolicyGroupRequestUsbSupplyRedirectRule {
	s.UsbRedirectType = &v
	return s
}

func (s *CreatePolicyGroupRequestUsbSupplyRedirectRule) SetUsbRuleType(v int64) *CreatePolicyGroupRequestUsbSupplyRedirectRule {
	s.UsbRuleType = &v
	return s
}

func (s *CreatePolicyGroupRequestUsbSupplyRedirectRule) SetVendorId(v string) *CreatePolicyGroupRequestUsbSupplyRedirectRule {
	s.VendorId = &v
	return s
}

type CreatePolicyGroupResponseBody struct {
	// The ID of the policy.
	PolicyGroupId *string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreatePolicyGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreatePolicyGroupResponseBody) GoString() string {
	return s.String()
}

func (s *CreatePolicyGroupResponseBody) SetPolicyGroupId(v string) *CreatePolicyGroupResponseBody {
	s.PolicyGroupId = &v
	return s
}

func (s *CreatePolicyGroupResponseBody) SetRequestId(v string) *CreatePolicyGroupResponseBody {
	s.RequestId = &v
	return s
}

type CreatePolicyGroupResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreatePolicyGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreatePolicyGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreatePolicyGroupResponse) GoString() string {
	return s.String()
}

func (s *CreatePolicyGroupResponse) SetHeaders(v map[string]*string) *CreatePolicyGroupResponse {
	s.Headers = v
	return s
}

func (s *CreatePolicyGroupResponse) SetStatusCode(v int32) *CreatePolicyGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *CreatePolicyGroupResponse) SetBody(v *CreatePolicyGroupResponseBody) *CreatePolicyGroupResponse {
	s.Body = v
	return s
}

type CreateRAMDirectoryRequest struct {
	// The method that you use to connect clients to cloud desktops. Valid values:
	//
	// *   Internet: connects clients to cloud desktops only over the Internet.
	// *   VPC: connects clients to cloud desktops only over a VPC.
	// *   Any: connects clients to cloud desktops over the Internet or a VPC. You can select a connection method when you connect clients to cloud desktops.
	//
	// Default value: Internet.
	//
	//
	// > The VPC connection method is provided by Alibaba Cloud PrivateLink. You are not charged for PrivateLink. If you set this parameter to VPC or Any, PrivateLink is automatically activated.
	DesktopAccessType *string `json:"DesktopAccessType,omitempty" xml:"DesktopAccessType,omitempty"`
	// The name of the directory. The name must be 2 to 255 characters in length and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). It must start with a letter and cannot start with `http://` or `https://`.
	//
	// This parameter is empty by default.
	DirectoryName *string `json:"DirectoryName,omitempty" xml:"DirectoryName,omitempty"`
	// Specifies whether to grant the permissions of the local administrator to the desktop users.
	//
	// Default value: true.
	EnableAdminAccess *bool `json:"EnableAdminAccess,omitempty" xml:"EnableAdminAccess,omitempty"`
	// Specifies whether to enable the Internet access feature.
	EnableInternetAccess *bool `json:"EnableInternetAccess,omitempty" xml:"EnableInternetAccess,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The IDs of vSwitches. You can configure only one vSwitch.
	VSwitchId []*string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty" type:"Repeated"`
}

func (s CreateRAMDirectoryRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateRAMDirectoryRequest) GoString() string {
	return s.String()
}

func (s *CreateRAMDirectoryRequest) SetDesktopAccessType(v string) *CreateRAMDirectoryRequest {
	s.DesktopAccessType = &v
	return s
}

func (s *CreateRAMDirectoryRequest) SetDirectoryName(v string) *CreateRAMDirectoryRequest {
	s.DirectoryName = &v
	return s
}

func (s *CreateRAMDirectoryRequest) SetEnableAdminAccess(v bool) *CreateRAMDirectoryRequest {
	s.EnableAdminAccess = &v
	return s
}

func (s *CreateRAMDirectoryRequest) SetEnableInternetAccess(v bool) *CreateRAMDirectoryRequest {
	s.EnableInternetAccess = &v
	return s
}

func (s *CreateRAMDirectoryRequest) SetRegionId(v string) *CreateRAMDirectoryRequest {
	s.RegionId = &v
	return s
}

func (s *CreateRAMDirectoryRequest) SetVSwitchId(v []*string) *CreateRAMDirectoryRequest {
	s.VSwitchId = v
	return s
}

type CreateRAMDirectoryResponseBody struct {
	// The ID of the RAM directory.
	DirectoryId *string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateRAMDirectoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateRAMDirectoryResponseBody) GoString() string {
	return s.String()
}

func (s *CreateRAMDirectoryResponseBody) SetDirectoryId(v string) *CreateRAMDirectoryResponseBody {
	s.DirectoryId = &v
	return s
}

func (s *CreateRAMDirectoryResponseBody) SetRequestId(v string) *CreateRAMDirectoryResponseBody {
	s.RequestId = &v
	return s
}

type CreateRAMDirectoryResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateRAMDirectoryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateRAMDirectoryResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateRAMDirectoryResponse) GoString() string {
	return s.String()
}

func (s *CreateRAMDirectoryResponse) SetHeaders(v map[string]*string) *CreateRAMDirectoryResponse {
	s.Headers = v
	return s
}

func (s *CreateRAMDirectoryResponse) SetStatusCode(v int32) *CreateRAMDirectoryResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateRAMDirectoryResponse) SetBody(v *CreateRAMDirectoryResponseBody) *CreateRAMDirectoryResponse {
	s.Body = v
	return s
}

type CreateSimpleOfficeSiteRequest struct {
	// The maximum public bandwidth. Value range: 10 to 200. Unit: Mbit/s. This parameter is available if you set `EnableInternetAccess` to `true`.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The ID of the Cloud Enterprise Network (CEN) instance.
	//
	// > If you want to connect to your cloud desktops over a VPC, you can attach the network of the workspace to the CEN instance. The CEN instance is connected to the on-premises network over VPN Gateway or Express Connect.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The ID of the Alibaba Cloud account to which the Cloud Enterprise Network (CEN) instance belongs.
	//
	// - If you do not specify the CenId parameter, or the CEN instance that is specified by the CenId parameter belongs to the current Alibaba Cloud account, skip this parameter.
	// - If you specify the CenId parameter and the CEN instance that you specify for the CenId parameter belongs to another Alibaba Cloud account, enter the ID of the Alibaba Cloud account.
	CenOwnerId *int64 `json:"CenOwnerId,omitempty" xml:"CenOwnerId,omitempty"`
	// The IPv4 CIDR block in the secure office network of the workspace. The IPv4 CIDR block that the system uses to create a virtual private cloud (VPC) for the workspace. We recommend that you set the IPv4 CIDR block to 10.0.0.0/12, 172.16.0.0/12, 192.168.0.0/16, or a subnet of these CIDR blocks. If you set the IPv4 CIDR block to 10.0.0.0/12 or 172.16.0.0/12, the mask is 1224 bits in length. If you set the IPv4 CIDR block to 192.168.0.0/16, the mask is 1624 bits in length.
	CidrBlock *string `json:"CidrBlock,omitempty" xml:"CidrBlock,omitempty"`
	// Specifies whether the workspace is a CloudBox-based workspace.
	CloudBoxOfficeSite *bool `json:"CloudBoxOfficeSite,omitempty" xml:"CloudBoxOfficeSite,omitempty"`
	// The method that is used to connect the client to cloud desktops.
	//
	// > VPC connections are established by using Alibaba Cloud PrivateLink. You can use PrivateLink for free. When you set this parameter to VPC or Any, PrivateLink is automatically activated.
	DesktopAccessType *string `json:"DesktopAccessType,omitempty" xml:"DesktopAccessType,omitempty"`
	// Specifies whether to grant the permissions of the local administrator to the regular user of the cloud desktop.
	EnableAdminAccess *bool `json:"EnableAdminAccess,omitempty" xml:"EnableAdminAccess,omitempty"`
	// Specifies whether to enable Internet access. By default, Internet access is not enabled.
	EnableInternetAccess *bool `json:"EnableInternetAccess,omitempty" xml:"EnableInternetAccess,omitempty"`
	// Specifies whether to enable trusted device verification.
	NeedVerifyZeroDevice *bool `json:"NeedVerifyZeroDevice,omitempty" xml:"NeedVerifyZeroDevice,omitempty"`
	// The name of the workspace. The name must be 2 to 255 characters in length. It must start with a letter and cannot start with `http://` or `https://`. The name can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
	OfficeSiteName *string `json:"OfficeSiteName,omitempty" xml:"OfficeSiteName,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The IDs of the vSwitches in the VPC. This parameter is required when you create a CloudBox-based workspace.
	VSwitchId []*string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty" type:"Repeated"`
	// The verification code. If the CEN instance that you specify for the CenId parameter belongs to another Alibaba Cloud account, you must call the [SendVerifyCode](~~335132~~) operation to obtain the verification code.
	VerifyCode *string `json:"VerifyCode,omitempty" xml:"VerifyCode,omitempty"`
	VpcType    *string `json:"VpcType,omitempty" xml:"VpcType,omitempty"`
}

func (s CreateSimpleOfficeSiteRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSimpleOfficeSiteRequest) GoString() string {
	return s.String()
}

func (s *CreateSimpleOfficeSiteRequest) SetBandwidth(v int32) *CreateSimpleOfficeSiteRequest {
	s.Bandwidth = &v
	return s
}

func (s *CreateSimpleOfficeSiteRequest) SetCenId(v string) *CreateSimpleOfficeSiteRequest {
	s.CenId = &v
	return s
}

func (s *CreateSimpleOfficeSiteRequest) SetCenOwnerId(v int64) *CreateSimpleOfficeSiteRequest {
	s.CenOwnerId = &v
	return s
}

func (s *CreateSimpleOfficeSiteRequest) SetCidrBlock(v string) *CreateSimpleOfficeSiteRequest {
	s.CidrBlock = &v
	return s
}

func (s *CreateSimpleOfficeSiteRequest) SetCloudBoxOfficeSite(v bool) *CreateSimpleOfficeSiteRequest {
	s.CloudBoxOfficeSite = &v
	return s
}

func (s *CreateSimpleOfficeSiteRequest) SetDesktopAccessType(v string) *CreateSimpleOfficeSiteRequest {
	s.DesktopAccessType = &v
	return s
}

func (s *CreateSimpleOfficeSiteRequest) SetEnableAdminAccess(v bool) *CreateSimpleOfficeSiteRequest {
	s.EnableAdminAccess = &v
	return s
}

func (s *CreateSimpleOfficeSiteRequest) SetEnableInternetAccess(v bool) *CreateSimpleOfficeSiteRequest {
	s.EnableInternetAccess = &v
	return s
}

func (s *CreateSimpleOfficeSiteRequest) SetNeedVerifyZeroDevice(v bool) *CreateSimpleOfficeSiteRequest {
	s.NeedVerifyZeroDevice = &v
	return s
}

func (s *CreateSimpleOfficeSiteRequest) SetOfficeSiteName(v string) *CreateSimpleOfficeSiteRequest {
	s.OfficeSiteName = &v
	return s
}

func (s *CreateSimpleOfficeSiteRequest) SetRegionId(v string) *CreateSimpleOfficeSiteRequest {
	s.RegionId = &v
	return s
}

func (s *CreateSimpleOfficeSiteRequest) SetVSwitchId(v []*string) *CreateSimpleOfficeSiteRequest {
	s.VSwitchId = v
	return s
}

func (s *CreateSimpleOfficeSiteRequest) SetVerifyCode(v string) *CreateSimpleOfficeSiteRequest {
	s.VerifyCode = &v
	return s
}

func (s *CreateSimpleOfficeSiteRequest) SetVpcType(v string) *CreateSimpleOfficeSiteRequest {
	s.VpcType = &v
	return s
}

type CreateSimpleOfficeSiteResponseBody struct {
	// The ID of the workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateSimpleOfficeSiteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateSimpleOfficeSiteResponseBody) GoString() string {
	return s.String()
}

func (s *CreateSimpleOfficeSiteResponseBody) SetOfficeSiteId(v string) *CreateSimpleOfficeSiteResponseBody {
	s.OfficeSiteId = &v
	return s
}

func (s *CreateSimpleOfficeSiteResponseBody) SetRequestId(v string) *CreateSimpleOfficeSiteResponseBody {
	s.RequestId = &v
	return s
}

type CreateSimpleOfficeSiteResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateSimpleOfficeSiteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateSimpleOfficeSiteResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSimpleOfficeSiteResponse) GoString() string {
	return s.String()
}

func (s *CreateSimpleOfficeSiteResponse) SetHeaders(v map[string]*string) *CreateSimpleOfficeSiteResponse {
	s.Headers = v
	return s
}

func (s *CreateSimpleOfficeSiteResponse) SetStatusCode(v int32) *CreateSimpleOfficeSiteResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateSimpleOfficeSiteResponse) SetBody(v *CreateSimpleOfficeSiteResponseBody) *CreateSimpleOfficeSiteResponse {
	s.Body = v
	return s
}

type CreateSnapshotRequest struct {
	// The description of the snapshot. The description can be up to 128 characters in length.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the cloud desktop.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The name of the snapshot. The name must be 2 to 128 characters in length.\
	// The name cannot start with auto because snapshots whose names start with auto are recognized as automatic snapshots.
	SnapshotName *string `json:"SnapshotName,omitempty" xml:"SnapshotName,omitempty"`
	// The type of the disk for which to create a snapshot. Valid values:
	//
	// *   system: system disk
	// *   data: data disk
	SourceDiskType *string `json:"SourceDiskType,omitempty" xml:"SourceDiskType,omitempty"`
}

func (s CreateSnapshotRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSnapshotRequest) GoString() string {
	return s.String()
}

func (s *CreateSnapshotRequest) SetDescription(v string) *CreateSnapshotRequest {
	s.Description = &v
	return s
}

func (s *CreateSnapshotRequest) SetDesktopId(v string) *CreateSnapshotRequest {
	s.DesktopId = &v
	return s
}

func (s *CreateSnapshotRequest) SetRegionId(v string) *CreateSnapshotRequest {
	s.RegionId = &v
	return s
}

func (s *CreateSnapshotRequest) SetSnapshotName(v string) *CreateSnapshotRequest {
	s.SnapshotName = &v
	return s
}

func (s *CreateSnapshotRequest) SetSourceDiskType(v string) *CreateSnapshotRequest {
	s.SourceDiskType = &v
	return s
}

type CreateSnapshotResponseBody struct {
	// The ID of the region.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the snapshot.
	SnapshotId *string `json:"SnapshotId,omitempty" xml:"SnapshotId,omitempty"`
}

func (s CreateSnapshotResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateSnapshotResponseBody) GoString() string {
	return s.String()
}

func (s *CreateSnapshotResponseBody) SetRequestId(v string) *CreateSnapshotResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateSnapshotResponseBody) SetSnapshotId(v string) *CreateSnapshotResponseBody {
	s.SnapshotId = &v
	return s
}

type CreateSnapshotResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateSnapshotResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateSnapshotResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSnapshotResponse) GoString() string {
	return s.String()
}

func (s *CreateSnapshotResponse) SetHeaders(v map[string]*string) *CreateSnapshotResponse {
	s.Headers = v
	return s
}

func (s *CreateSnapshotResponse) SetStatusCode(v int32) *CreateSnapshotResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateSnapshotResponse) SetBody(v *CreateSnapshotResponseBody) *CreateSnapshotResponse {
	s.Body = v
	return s
}

type DeleteAutoSnapshotPolicyRequest struct {
	// The ID of the policy template that you want to manage.
	PolicyId []*string `json:"PolicyId,omitempty" xml:"PolicyId,omitempty" type:"Repeated"`
	// The ID of the region where the automatic snapshot policy is created.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteAutoSnapshotPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAutoSnapshotPolicyRequest) GoString() string {
	return s.String()
}

func (s *DeleteAutoSnapshotPolicyRequest) SetPolicyId(v []*string) *DeleteAutoSnapshotPolicyRequest {
	s.PolicyId = v
	return s
}

func (s *DeleteAutoSnapshotPolicyRequest) SetRegionId(v string) *DeleteAutoSnapshotPolicyRequest {
	s.RegionId = &v
	return s
}

type DeleteAutoSnapshotPolicyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAutoSnapshotPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAutoSnapshotPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAutoSnapshotPolicyResponseBody) SetRequestId(v string) *DeleteAutoSnapshotPolicyResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAutoSnapshotPolicyResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAutoSnapshotPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAutoSnapshotPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAutoSnapshotPolicyResponse) GoString() string {
	return s.String()
}

func (s *DeleteAutoSnapshotPolicyResponse) SetHeaders(v map[string]*string) *DeleteAutoSnapshotPolicyResponse {
	s.Headers = v
	return s
}

func (s *DeleteAutoSnapshotPolicyResponse) SetStatusCode(v int32) *DeleteAutoSnapshotPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAutoSnapshotPolicyResponse) SetBody(v *DeleteAutoSnapshotPolicyResponseBody) *DeleteAutoSnapshotPolicyResponse {
	s.Body = v
	return s
}

type DeleteBundlesRequest struct {
	BundleId []*string `json:"BundleId,omitempty" xml:"BundleId,omitempty" type:"Repeated"`
	// DeleteBundles
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteBundlesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteBundlesRequest) GoString() string {
	return s.String()
}

func (s *DeleteBundlesRequest) SetBundleId(v []*string) *DeleteBundlesRequest {
	s.BundleId = v
	return s
}

func (s *DeleteBundlesRequest) SetRegionId(v string) *DeleteBundlesRequest {
	s.RegionId = &v
	return s
}

type DeleteBundlesResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteBundlesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteBundlesResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteBundlesResponseBody) SetRequestId(v string) *DeleteBundlesResponseBody {
	s.RequestId = &v
	return s
}

type DeleteBundlesResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteBundlesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteBundlesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteBundlesResponse) GoString() string {
	return s.String()
}

func (s *DeleteBundlesResponse) SetHeaders(v map[string]*string) *DeleteBundlesResponse {
	s.Headers = v
	return s
}

func (s *DeleteBundlesResponse) SetStatusCode(v int32) *DeleteBundlesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteBundlesResponse) SetBody(v *DeleteBundlesResponseBody) *DeleteBundlesResponse {
	s.Body = v
	return s
}

type DeleteCdsFileRequest struct {
	// The ID of the cloud disk.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	// The ID of the end user who uses the cloud disk.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The ID of the file. The ID is a unique identifier for the file.
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The group ID.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteCdsFileRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCdsFileRequest) GoString() string {
	return s.String()
}

func (s *DeleteCdsFileRequest) SetCdsId(v string) *DeleteCdsFileRequest {
	s.CdsId = &v
	return s
}

func (s *DeleteCdsFileRequest) SetEndUserId(v string) *DeleteCdsFileRequest {
	s.EndUserId = &v
	return s
}

func (s *DeleteCdsFileRequest) SetFileId(v string) *DeleteCdsFileRequest {
	s.FileId = &v
	return s
}

func (s *DeleteCdsFileRequest) SetGroupId(v string) *DeleteCdsFileRequest {
	s.GroupId = &v
	return s
}

func (s *DeleteCdsFileRequest) SetRegionId(v string) *DeleteCdsFileRequest {
	s.RegionId = &v
	return s
}

type DeleteCdsFileResponseBody struct {
	// The operation result. A value of success indicates that the operation is successful. If the operation failed, an error message is returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the data is returned.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   false
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   false
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteCdsFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCdsFileResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCdsFileResponseBody) SetCode(v string) *DeleteCdsFileResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteCdsFileResponseBody) SetData(v string) *DeleteCdsFileResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteCdsFileResponseBody) SetMessage(v string) *DeleteCdsFileResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteCdsFileResponseBody) SetRequestId(v string) *DeleteCdsFileResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteCdsFileResponseBody) SetSuccess(v bool) *DeleteCdsFileResponseBody {
	s.Success = &v
	return s
}

type DeleteCdsFileResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCdsFileResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCdsFileResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCdsFileResponse) GoString() string {
	return s.String()
}

func (s *DeleteCdsFileResponse) SetHeaders(v map[string]*string) *DeleteCdsFileResponse {
	s.Headers = v
	return s
}

func (s *DeleteCdsFileResponse) SetStatusCode(v int32) *DeleteCdsFileResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCdsFileResponse) SetBody(v *DeleteCdsFileResponseBody) *DeleteCdsFileResponse {
	s.Body = v
	return s
}

type DeleteCloudDriveGroupsRequest struct {
	// The ID of the cloud disk in Cloud Drive Service.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	// The IDs of the teams that you want to delete. You can delete multiple teams at a time.
	GroupId []*string `json:"GroupId,omitempty" xml:"GroupId,omitempty" type:"Repeated"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteCloudDriveGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCloudDriveGroupsRequest) GoString() string {
	return s.String()
}

func (s *DeleteCloudDriveGroupsRequest) SetCdsId(v string) *DeleteCloudDriveGroupsRequest {
	s.CdsId = &v
	return s
}

func (s *DeleteCloudDriveGroupsRequest) SetGroupId(v []*string) *DeleteCloudDriveGroupsRequest {
	s.GroupId = v
	return s
}

func (s *DeleteCloudDriveGroupsRequest) SetRegionId(v string) *DeleteCloudDriveGroupsRequest {
	s.RegionId = &v
	return s
}

type DeleteCloudDriveGroupsResponseBody struct {
	// The result of the operation. A value of success indicates that the operation is successful. If the operation failed, an error message is returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data information.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error message returned. This parameter is not returned if the value of Code is `success`.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values: true: The request is successful. false: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteCloudDriveGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCloudDriveGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCloudDriveGroupsResponseBody) SetCode(v string) *DeleteCloudDriveGroupsResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteCloudDriveGroupsResponseBody) SetData(v string) *DeleteCloudDriveGroupsResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteCloudDriveGroupsResponseBody) SetMessage(v string) *DeleteCloudDriveGroupsResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteCloudDriveGroupsResponseBody) SetRequestId(v string) *DeleteCloudDriveGroupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteCloudDriveGroupsResponseBody) SetSuccess(v bool) *DeleteCloudDriveGroupsResponseBody {
	s.Success = &v
	return s
}

type DeleteCloudDriveGroupsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCloudDriveGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCloudDriveGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCloudDriveGroupsResponse) GoString() string {
	return s.String()
}

func (s *DeleteCloudDriveGroupsResponse) SetHeaders(v map[string]*string) *DeleteCloudDriveGroupsResponse {
	s.Headers = v
	return s
}

func (s *DeleteCloudDriveGroupsResponse) SetStatusCode(v int32) *DeleteCloudDriveGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCloudDriveGroupsResponse) SetBody(v *DeleteCloudDriveGroupsResponseBody) *DeleteCloudDriveGroupsResponse {
	s.Body = v
	return s
}

type DeleteCloudDriveUsersRequest struct {
	CdsId     *string   `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	EndUserId []*string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty" type:"Repeated"`
	RegionId  *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteCloudDriveUsersRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCloudDriveUsersRequest) GoString() string {
	return s.String()
}

func (s *DeleteCloudDriveUsersRequest) SetCdsId(v string) *DeleteCloudDriveUsersRequest {
	s.CdsId = &v
	return s
}

func (s *DeleteCloudDriveUsersRequest) SetEndUserId(v []*string) *DeleteCloudDriveUsersRequest {
	s.EndUserId = v
	return s
}

func (s *DeleteCloudDriveUsersRequest) SetRegionId(v string) *DeleteCloudDriveUsersRequest {
	s.RegionId = &v
	return s
}

type DeleteCloudDriveUsersResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteCloudDriveUsersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCloudDriveUsersResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCloudDriveUsersResponseBody) SetRequestId(v string) *DeleteCloudDriveUsersResponseBody {
	s.RequestId = &v
	return s
}

type DeleteCloudDriveUsersResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCloudDriveUsersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCloudDriveUsersResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCloudDriveUsersResponse) GoString() string {
	return s.String()
}

func (s *DeleteCloudDriveUsersResponse) SetHeaders(v map[string]*string) *DeleteCloudDriveUsersResponse {
	s.Headers = v
	return s
}

func (s *DeleteCloudDriveUsersResponse) SetStatusCode(v int32) *DeleteCloudDriveUsersResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCloudDriveUsersResponse) SetBody(v *DeleteCloudDriveUsersResponseBody) *DeleteCloudDriveUsersResponse {
	s.Body = v
	return s
}

type DeleteDesktopGroupRequest struct {
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	RegionId       *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteDesktopGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDesktopGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteDesktopGroupRequest) SetDesktopGroupId(v string) *DeleteDesktopGroupRequest {
	s.DesktopGroupId = &v
	return s
}

func (s *DeleteDesktopGroupRequest) SetRegionId(v string) *DeleteDesktopGroupRequest {
	s.RegionId = &v
	return s
}

type DeleteDesktopGroupResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDesktopGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDesktopGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDesktopGroupResponseBody) SetRequestId(v string) *DeleteDesktopGroupResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDesktopGroupResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDesktopGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDesktopGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDesktopGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteDesktopGroupResponse) SetHeaders(v map[string]*string) *DeleteDesktopGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteDesktopGroupResponse) SetStatusCode(v int32) *DeleteDesktopGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDesktopGroupResponse) SetBody(v *DeleteDesktopGroupResponseBody) *DeleteDesktopGroupResponse {
	s.Body = v
	return s
}

type DeleteDesktopsRequest struct {
	// The IDs of the cloud desktops that you want to release. You can configure up to 100 desktop IDs.
	DesktopId []*string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty" type:"Repeated"`
	// The ID of the region where the cloud desktops to release are located.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteDesktopsRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDesktopsRequest) GoString() string {
	return s.String()
}

func (s *DeleteDesktopsRequest) SetDesktopId(v []*string) *DeleteDesktopsRequest {
	s.DesktopId = v
	return s
}

func (s *DeleteDesktopsRequest) SetRegionId(v string) *DeleteDesktopsRequest {
	s.RegionId = &v
	return s
}

type DeleteDesktopsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDesktopsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDesktopsResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDesktopsResponseBody) SetRequestId(v string) *DeleteDesktopsResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDesktopsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDesktopsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDesktopsResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDesktopsResponse) GoString() string {
	return s.String()
}

func (s *DeleteDesktopsResponse) SetHeaders(v map[string]*string) *DeleteDesktopsResponse {
	s.Headers = v
	return s
}

func (s *DeleteDesktopsResponse) SetStatusCode(v int32) *DeleteDesktopsResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDesktopsResponse) SetBody(v *DeleteDesktopsResponseBody) *DeleteDesktopsResponse {
	s.Body = v
	return s
}

type DeleteDevicesRequest struct {
	// The type of the device.
	//
	// *   1: the hardware client device
	// *   2: the software client device
	ClientType *int32 `json:"ClientType,omitempty" xml:"ClientType,omitempty"`
	// The list of universally unique identifiers (UUIDs) of devices.
	DeviceIds []*string `json:"DeviceIds,omitempty" xml:"DeviceIds,omitempty" type:"Repeated"`
	// Specifies whether to forcefully delete the device.
	//
	// *   1: forcefully deletes the device.
	// *   0: does not forcefully delete the device. (You cannot delete a device to which a user is bound.)
	Force *int32 `json:"Force,omitempty" xml:"Force,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteDevicesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDevicesRequest) GoString() string {
	return s.String()
}

func (s *DeleteDevicesRequest) SetClientType(v int32) *DeleteDevicesRequest {
	s.ClientType = &v
	return s
}

func (s *DeleteDevicesRequest) SetDeviceIds(v []*string) *DeleteDevicesRequest {
	s.DeviceIds = v
	return s
}

func (s *DeleteDevicesRequest) SetForce(v int32) *DeleteDevicesRequest {
	s.Force = &v
	return s
}

func (s *DeleteDevicesRequest) SetRegionId(v string) *DeleteDevicesRequest {
	s.RegionId = &v
	return s
}

type DeleteDevicesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDevicesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDevicesResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDevicesResponseBody) SetRequestId(v string) *DeleteDevicesResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDevicesResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDevicesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDevicesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDevicesResponse) GoString() string {
	return s.String()
}

func (s *DeleteDevicesResponse) SetHeaders(v map[string]*string) *DeleteDevicesResponse {
	s.Headers = v
	return s
}

func (s *DeleteDevicesResponse) SetStatusCode(v int32) *DeleteDevicesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDevicesResponse) SetBody(v *DeleteDevicesResponseBody) *DeleteDevicesResponse {
	s.Body = v
	return s
}

type DeleteDirectoriesRequest struct {
	// The IDs of directories.
	DirectoryId []*string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty" type:"Repeated"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteDirectoriesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDirectoriesRequest) GoString() string {
	return s.String()
}

func (s *DeleteDirectoriesRequest) SetDirectoryId(v []*string) *DeleteDirectoriesRequest {
	s.DirectoryId = v
	return s
}

func (s *DeleteDirectoriesRequest) SetRegionId(v string) *DeleteDirectoriesRequest {
	s.RegionId = &v
	return s
}

type DeleteDirectoriesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDirectoriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDirectoriesResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDirectoriesResponseBody) SetRequestId(v string) *DeleteDirectoriesResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDirectoriesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDirectoriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDirectoriesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDirectoriesResponse) GoString() string {
	return s.String()
}

func (s *DeleteDirectoriesResponse) SetHeaders(v map[string]*string) *DeleteDirectoriesResponse {
	s.Headers = v
	return s
}

func (s *DeleteDirectoriesResponse) SetStatusCode(v int32) *DeleteDirectoriesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDirectoriesResponse) SetBody(v *DeleteDirectoriesResponseBody) *DeleteDirectoriesResponse {
	s.Body = v
	return s
}

type DeleteEduRoomRequest struct {
	EduRoomId *string `json:"EduRoomId,omitempty" xml:"EduRoomId,omitempty"`
	RegionId  *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteEduRoomRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteEduRoomRequest) GoString() string {
	return s.String()
}

func (s *DeleteEduRoomRequest) SetEduRoomId(v string) *DeleteEduRoomRequest {
	s.EduRoomId = &v
	return s
}

func (s *DeleteEduRoomRequest) SetRegionId(v string) *DeleteEduRoomRequest {
	s.RegionId = &v
	return s
}

type DeleteEduRoomResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteEduRoomResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteEduRoomResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteEduRoomResponseBody) SetRequestId(v string) *DeleteEduRoomResponseBody {
	s.RequestId = &v
	return s
}

type DeleteEduRoomResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteEduRoomResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteEduRoomResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteEduRoomResponse) GoString() string {
	return s.String()
}

func (s *DeleteEduRoomResponse) SetHeaders(v map[string]*string) *DeleteEduRoomResponse {
	s.Headers = v
	return s
}

func (s *DeleteEduRoomResponse) SetStatusCode(v int32) *DeleteEduRoomResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteEduRoomResponse) SetBody(v *DeleteEduRoomResponseBody) *DeleteEduRoomResponse {
	s.Body = v
	return s
}

type DeleteImagesRequest struct {
	// Specifies whether to delete the associated template.
	DeleteCascadedBundle *bool `json:"DeleteCascadedBundle,omitempty" xml:"DeleteCascadedBundle,omitempty"`
	// The image IDs. You can specify 1 to 100 image IDs.
	ImageId []*string `json:"ImageId,omitempty" xml:"ImageId,omitempty" type:"Repeated"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteImagesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteImagesRequest) GoString() string {
	return s.String()
}

func (s *DeleteImagesRequest) SetDeleteCascadedBundle(v bool) *DeleteImagesRequest {
	s.DeleteCascadedBundle = &v
	return s
}

func (s *DeleteImagesRequest) SetImageId(v []*string) *DeleteImagesRequest {
	s.ImageId = v
	return s
}

func (s *DeleteImagesRequest) SetRegionId(v string) *DeleteImagesRequest {
	s.RegionId = &v
	return s
}

type DeleteImagesResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteImagesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteImagesResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteImagesResponseBody) SetRequestId(v string) *DeleteImagesResponseBody {
	s.RequestId = &v
	return s
}

type DeleteImagesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteImagesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteImagesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteImagesResponse) GoString() string {
	return s.String()
}

func (s *DeleteImagesResponse) SetHeaders(v map[string]*string) *DeleteImagesResponse {
	s.Headers = v
	return s
}

func (s *DeleteImagesResponse) SetStatusCode(v int32) *DeleteImagesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteImagesResponse) SetBody(v *DeleteImagesResponseBody) *DeleteImagesResponse {
	s.Body = v
	return s
}

type DeleteNASFileSystemsRequest struct {
	// The IDs of the NAS file systems that you want to delete.
	FileSystemId []*string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty" type:"Repeated"`
	// The region ID of the NAS file system that you want to delete.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteNASFileSystemsRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteNASFileSystemsRequest) GoString() string {
	return s.String()
}

func (s *DeleteNASFileSystemsRequest) SetFileSystemId(v []*string) *DeleteNASFileSystemsRequest {
	s.FileSystemId = v
	return s
}

func (s *DeleteNASFileSystemsRequest) SetRegionId(v string) *DeleteNASFileSystemsRequest {
	s.RegionId = &v
	return s
}

type DeleteNASFileSystemsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteNASFileSystemsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteNASFileSystemsResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteNASFileSystemsResponseBody) SetRequestId(v string) *DeleteNASFileSystemsResponseBody {
	s.RequestId = &v
	return s
}

type DeleteNASFileSystemsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteNASFileSystemsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteNASFileSystemsResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteNASFileSystemsResponse) GoString() string {
	return s.String()
}

func (s *DeleteNASFileSystemsResponse) SetHeaders(v map[string]*string) *DeleteNASFileSystemsResponse {
	s.Headers = v
	return s
}

func (s *DeleteNASFileSystemsResponse) SetStatusCode(v int32) *DeleteNASFileSystemsResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteNASFileSystemsResponse) SetBody(v *DeleteNASFileSystemsResponseBody) *DeleteNASFileSystemsResponse {
	s.Body = v
	return s
}

type DeleteNetworkPackagesRequest struct {
	// The IDs of Internet access packages.
	NetworkPackageId []*string `json:"NetworkPackageId,omitempty" xml:"NetworkPackageId,omitempty" type:"Repeated"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteNetworkPackagesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteNetworkPackagesRequest) GoString() string {
	return s.String()
}

func (s *DeleteNetworkPackagesRequest) SetNetworkPackageId(v []*string) *DeleteNetworkPackagesRequest {
	s.NetworkPackageId = v
	return s
}

func (s *DeleteNetworkPackagesRequest) SetRegionId(v string) *DeleteNetworkPackagesRequest {
	s.RegionId = &v
	return s
}

type DeleteNetworkPackagesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteNetworkPackagesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteNetworkPackagesResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteNetworkPackagesResponseBody) SetRequestId(v string) *DeleteNetworkPackagesResponseBody {
	s.RequestId = &v
	return s
}

type DeleteNetworkPackagesResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteNetworkPackagesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteNetworkPackagesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteNetworkPackagesResponse) GoString() string {
	return s.String()
}

func (s *DeleteNetworkPackagesResponse) SetHeaders(v map[string]*string) *DeleteNetworkPackagesResponse {
	s.Headers = v
	return s
}

func (s *DeleteNetworkPackagesResponse) SetStatusCode(v int32) *DeleteNetworkPackagesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteNetworkPackagesResponse) SetBody(v *DeleteNetworkPackagesResponseBody) *DeleteNetworkPackagesResponse {
	s.Body = v
	return s
}

type DeleteOfficeSitesRequest struct {
	// The ID of the workspace that you want to delete. You can specify 1 to 100 IDs of workspaces.
	OfficeSiteId []*string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty" type:"Repeated"`
	// The region ID of the workspace that you want to delete. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteOfficeSitesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteOfficeSitesRequest) GoString() string {
	return s.String()
}

func (s *DeleteOfficeSitesRequest) SetOfficeSiteId(v []*string) *DeleteOfficeSitesRequest {
	s.OfficeSiteId = v
	return s
}

func (s *DeleteOfficeSitesRequest) SetRegionId(v string) *DeleteOfficeSitesRequest {
	s.RegionId = &v
	return s
}

type DeleteOfficeSitesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteOfficeSitesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteOfficeSitesResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteOfficeSitesResponseBody) SetRequestId(v string) *DeleteOfficeSitesResponseBody {
	s.RequestId = &v
	return s
}

type DeleteOfficeSitesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteOfficeSitesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteOfficeSitesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteOfficeSitesResponse) GoString() string {
	return s.String()
}

func (s *DeleteOfficeSitesResponse) SetHeaders(v map[string]*string) *DeleteOfficeSitesResponse {
	s.Headers = v
	return s
}

func (s *DeleteOfficeSitesResponse) SetStatusCode(v int32) *DeleteOfficeSitesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteOfficeSitesResponse) SetBody(v *DeleteOfficeSitesResponseBody) *DeleteOfficeSitesResponse {
	s.Body = v
	return s
}

type DeletePolicyGroupsRequest struct {
	PolicyGroupId []*string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty" type:"Repeated"`
	RegionId      *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeletePolicyGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DeletePolicyGroupsRequest) GoString() string {
	return s.String()
}

func (s *DeletePolicyGroupsRequest) SetPolicyGroupId(v []*string) *DeletePolicyGroupsRequest {
	s.PolicyGroupId = v
	return s
}

func (s *DeletePolicyGroupsRequest) SetRegionId(v string) *DeletePolicyGroupsRequest {
	s.RegionId = &v
	return s
}

type DeletePolicyGroupsResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeletePolicyGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeletePolicyGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *DeletePolicyGroupsResponseBody) SetRequestId(v string) *DeletePolicyGroupsResponseBody {
	s.RequestId = &v
	return s
}

type DeletePolicyGroupsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeletePolicyGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeletePolicyGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DeletePolicyGroupsResponse) GoString() string {
	return s.String()
}

func (s *DeletePolicyGroupsResponse) SetHeaders(v map[string]*string) *DeletePolicyGroupsResponse {
	s.Headers = v
	return s
}

func (s *DeletePolicyGroupsResponse) SetStatusCode(v int32) *DeletePolicyGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DeletePolicyGroupsResponse) SetBody(v *DeletePolicyGroupsResponseBody) *DeletePolicyGroupsResponse {
	s.Body = v
	return s
}

type DeleteSnapshotRequest struct {
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The IDs of the snapshots. You can specify 1 to 100 IDs of snapshots.
	SnapshotId []*string `json:"SnapshotId,omitempty" xml:"SnapshotId,omitempty" type:"Repeated"`
}

func (s DeleteSnapshotRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSnapshotRequest) GoString() string {
	return s.String()
}

func (s *DeleteSnapshotRequest) SetRegionId(v string) *DeleteSnapshotRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteSnapshotRequest) SetSnapshotId(v []*string) *DeleteSnapshotRequest {
	s.SnapshotId = v
	return s
}

type DeleteSnapshotResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteSnapshotResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSnapshotResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSnapshotResponseBody) SetRequestId(v string) *DeleteSnapshotResponseBody {
	s.RequestId = &v
	return s
}

type DeleteSnapshotResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSnapshotResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSnapshotResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSnapshotResponse) GoString() string {
	return s.String()
}

func (s *DeleteSnapshotResponse) SetHeaders(v map[string]*string) *DeleteSnapshotResponse {
	s.Headers = v
	return s
}

func (s *DeleteSnapshotResponse) SetStatusCode(v int32) *DeleteSnapshotResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSnapshotResponse) SetBody(v *DeleteSnapshotResponseBody) *DeleteSnapshotResponse {
	s.Body = v
	return s
}

type DeleteVirtualMFADeviceRequest struct {
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The serial number of the virtual MFA device, which is a unique identifier.
	//
	// You can call the [DescribeVirtualMFADevices](~~206210~~) operation to query the serial number of the virtual MFA device bound to AD users.
	SerialNumber *string `json:"SerialNumber,omitempty" xml:"SerialNumber,omitempty"`
}

func (s DeleteVirtualMFADeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteVirtualMFADeviceRequest) GoString() string {
	return s.String()
}

func (s *DeleteVirtualMFADeviceRequest) SetRegionId(v string) *DeleteVirtualMFADeviceRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteVirtualMFADeviceRequest) SetSerialNumber(v string) *DeleteVirtualMFADeviceRequest {
	s.SerialNumber = &v
	return s
}

type DeleteVirtualMFADeviceResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteVirtualMFADeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteVirtualMFADeviceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVirtualMFADeviceResponseBody) SetRequestId(v string) *DeleteVirtualMFADeviceResponseBody {
	s.RequestId = &v
	return s
}

type DeleteVirtualMFADeviceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteVirtualMFADeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteVirtualMFADeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteVirtualMFADeviceResponse) GoString() string {
	return s.String()
}

func (s *DeleteVirtualMFADeviceResponse) SetHeaders(v map[string]*string) *DeleteVirtualMFADeviceResponse {
	s.Headers = v
	return s
}

func (s *DeleteVirtualMFADeviceResponse) SetStatusCode(v int32) *DeleteVirtualMFADeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVirtualMFADeviceResponse) SetBody(v *DeleteVirtualMFADeviceResponseBody) *DeleteVirtualMFADeviceResponse {
	s.Body = v
	return s
}

type DescribeAclEntriesRequest struct {
	// The number of entries per page. Maximum value: 1600.
	//
	// Default value: 1600.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used for the next query. If this parameter is empty, all results have been returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the instance corresponding to the ACL.
	SourceId *string `json:"SourceId,omitempty" xml:"SourceId,omitempty"`
	// The object on which the ACL takes effect.
	//
	// *   **vpc**: workspace.
	// *   **desktop**: cloud desktop.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
}

func (s DescribeAclEntriesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAclEntriesRequest) GoString() string {
	return s.String()
}

func (s *DescribeAclEntriesRequest) SetMaxResults(v int32) *DescribeAclEntriesRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeAclEntriesRequest) SetNextToken(v string) *DescribeAclEntriesRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeAclEntriesRequest) SetRegionId(v string) *DescribeAclEntriesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeAclEntriesRequest) SetSourceId(v string) *DescribeAclEntriesRequest {
	s.SourceId = &v
	return s
}

func (s *DescribeAclEntriesRequest) SetSourceType(v string) *DescribeAclEntriesRequest {
	s.SourceType = &v
	return s
}

type DescribeAclEntriesResponseBody struct {
	// The ACL entry.
	AclEntries []*DescribeAclEntriesResponseBodyAclEntries `json:"AclEntries,omitempty" xml:"AclEntries,omitempty" type:"Repeated"`
	// The token that is used to start the next query. If the value of this parameter is empty, all results are returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeAclEntriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAclEntriesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAclEntriesResponseBody) SetAclEntries(v []*DescribeAclEntriesResponseBodyAclEntries) *DescribeAclEntriesResponseBody {
	s.AclEntries = v
	return s
}

func (s *DescribeAclEntriesResponseBody) SetNextToken(v string) *DescribeAclEntriesResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeAclEntriesResponseBody) SetRequestId(v string) *DescribeAclEntriesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeAclEntriesResponseBodyAclEntries struct {
	// The ACL policy.
	//
	// *   **allow**: allows access.
	// *   **drop**: denies access.
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	// The ID of the instance corresponding to the ACL.
	SourceId *string `json:"SourceId,omitempty" xml:"SourceId,omitempty"`
	// The object on which the ACL takes effect.
	//
	// *   **vpc**: workspace.
	// *   **desktop**: cloud desktop.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
}

func (s DescribeAclEntriesResponseBodyAclEntries) String() string {
	return tea.Prettify(s)
}

func (s DescribeAclEntriesResponseBodyAclEntries) GoString() string {
	return s.String()
}

func (s *DescribeAclEntriesResponseBodyAclEntries) SetPolicy(v string) *DescribeAclEntriesResponseBodyAclEntries {
	s.Policy = &v
	return s
}

func (s *DescribeAclEntriesResponseBodyAclEntries) SetSourceId(v string) *DescribeAclEntriesResponseBodyAclEntries {
	s.SourceId = &v
	return s
}

func (s *DescribeAclEntriesResponseBodyAclEntries) SetSourceType(v string) *DescribeAclEntriesResponseBodyAclEntries {
	s.SourceType = &v
	return s
}

type DescribeAclEntriesResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeAclEntriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeAclEntriesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAclEntriesResponse) GoString() string {
	return s.String()
}

func (s *DescribeAclEntriesResponse) SetHeaders(v map[string]*string) *DescribeAclEntriesResponse {
	s.Headers = v
	return s
}

func (s *DescribeAclEntriesResponse) SetStatusCode(v int32) *DescribeAclEntriesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAclEntriesResponse) SetBody(v *DescribeAclEntriesResponseBody) *DescribeAclEntriesResponse {
	s.Body = v
	return s
}

type DescribeAutoSnapshotPolicyRequest struct {
	// The number of entries to return on each page.
	//
	// *   Maximum value: 100
	// *   Default value: 20
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the next query. If this parameter is left empty, all results are returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the automatic snapshot policy.
	PolicyId *string `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The name of the automatic snapshot policy.
	PolicyName *string `json:"PolicyName,omitempty" xml:"PolicyName,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeAutoSnapshotPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAutoSnapshotPolicyRequest) GoString() string {
	return s.String()
}

func (s *DescribeAutoSnapshotPolicyRequest) SetMaxResults(v int32) *DescribeAutoSnapshotPolicyRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeAutoSnapshotPolicyRequest) SetNextToken(v string) *DescribeAutoSnapshotPolicyRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeAutoSnapshotPolicyRequest) SetPolicyId(v string) *DescribeAutoSnapshotPolicyRequest {
	s.PolicyId = &v
	return s
}

func (s *DescribeAutoSnapshotPolicyRequest) SetPolicyName(v string) *DescribeAutoSnapshotPolicyRequest {
	s.PolicyName = &v
	return s
}

func (s *DescribeAutoSnapshotPolicyRequest) SetRegionId(v string) *DescribeAutoSnapshotPolicyRequest {
	s.RegionId = &v
	return s
}

type DescribeAutoSnapshotPolicyResponseBody struct {
	// Details of the automatic snapshot policies.
	AutoSnapshotPolicies []*DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies `json:"AutoSnapshotPolicies,omitempty" xml:"AutoSnapshotPolicies,omitempty" type:"Repeated"`
	// The token that is used to start the next query. If this parameter is empty, all results haven been returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeAutoSnapshotPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAutoSnapshotPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAutoSnapshotPolicyResponseBody) SetAutoSnapshotPolicies(v []*DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies) *DescribeAutoSnapshotPolicyResponseBody {
	s.AutoSnapshotPolicies = v
	return s
}

func (s *DescribeAutoSnapshotPolicyResponseBody) SetNextToken(v string) *DescribeAutoSnapshotPolicyResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeAutoSnapshotPolicyResponseBody) SetRequestId(v string) *DescribeAutoSnapshotPolicyResponseBody {
	s.RequestId = &v
	return s
}

type DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies struct {
	// The time when the automatic snapshot policy was created. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-mm-ddthh:mm:ssz format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The CRON expression that is used to create the snapshot.
	CronExpression *string `json:"CronExpression,omitempty" xml:"CronExpression,omitempty"`
	// The number of cloud desktops that are associated with the automatic snapshot policy.
	DesktopNum *int32 `json:"DesktopNum,omitempty" xml:"DesktopNum,omitempty"`
	// The ID of the automatic snapshot policy.
	PolicyId *string `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The name of the automatic snapshot policy.
	PolicyName *string `json:"PolicyName,omitempty" xml:"PolicyName,omitempty"`
	// The ID of the region where the automatic snapshot policy resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The retention period of the automatic snapshot. Unit: days. Valid values:
	//
	// *   \-1: The snapshot is permanently retained.
	// *   1 to 65536: The automatic snapshot is retained for the specified number of days.
	RetentionDays *string `json:"RetentionDays,omitempty" xml:"RetentionDays,omitempty"`
	// The state of the automatic snapshot policy. Valid values:
	//
	// *   Normal: The automatic snapshot policy is normal.
	// *   Expire: The automatic snapshot policy cannot be used because your account has an overdue payment.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The points in time at which automatic snapshots are created.
	//
	// The time is displayed in UTC+8. Unit: hours. Valid values are 0 to 23, which correspond to the 24 points in time on the hour from 00:00:00 to 23:00:00. 1 indicates 01:00:00. Multiple points in time can be specified.
	//
	// The parameter value is a JSON array that contains up to 24 points in time separated by commas (,). Example: `["0", "1", ... "23"]`.
	TimePoints *string `json:"TimePoints,omitempty" xml:"TimePoints,omitempty"`
}

func (s DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies) String() string {
	return tea.Prettify(s)
}

func (s DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies) GoString() string {
	return s.String()
}

func (s *DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies) SetCreationTime(v string) *DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies {
	s.CreationTime = &v
	return s
}

func (s *DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies) SetCronExpression(v string) *DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies {
	s.CronExpression = &v
	return s
}

func (s *DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies) SetDesktopNum(v int32) *DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies {
	s.DesktopNum = &v
	return s
}

func (s *DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies) SetPolicyId(v string) *DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies {
	s.PolicyId = &v
	return s
}

func (s *DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies) SetPolicyName(v string) *DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies {
	s.PolicyName = &v
	return s
}

func (s *DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies) SetRegionId(v string) *DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies {
	s.RegionId = &v
	return s
}

func (s *DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies) SetRetentionDays(v string) *DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies {
	s.RetentionDays = &v
	return s
}

func (s *DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies) SetStatus(v string) *DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies {
	s.Status = &v
	return s
}

func (s *DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies) SetTimePoints(v string) *DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies {
	s.TimePoints = &v
	return s
}

type DescribeAutoSnapshotPolicyResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeAutoSnapshotPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeAutoSnapshotPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAutoSnapshotPolicyResponse) GoString() string {
	return s.String()
}

func (s *DescribeAutoSnapshotPolicyResponse) SetHeaders(v map[string]*string) *DescribeAutoSnapshotPolicyResponse {
	s.Headers = v
	return s
}

func (s *DescribeAutoSnapshotPolicyResponse) SetStatusCode(v int32) *DescribeAutoSnapshotPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAutoSnapshotPolicyResponse) SetBody(v *DescribeAutoSnapshotPolicyResponseBody) *DescribeAutoSnapshotPolicyResponse {
	s.Body = v
	return s
}

type DescribeBundlesRequest struct {
	// The IDs of the desktop templates. You can specify 1 to 100 desktop templates.
	BundleId []*string `json:"BundleId,omitempty" xml:"BundleId,omitempty" type:"Repeated"`
	// The type of the cloud desktop template. Valid values:
	//
	// *   SYSTEM: the system template
	// *   CUSTOM: the custom template
	BundleType *string `json:"BundleType,omitempty" xml:"BundleType,omitempty"`
	// Specifies whether to query the inventory status of the cloud desktop type.
	CheckStock *bool `json:"CheckStock,omitempty" xml:"CheckStock,omitempty"`
	// The number of vCPUs that is defined in the cloud desktop type.
	CpuCount *int32 `json:"CpuCount,omitempty" xml:"CpuCount,omitempty"`
	// The family of the cloud desktop type. Valid values:
	//
	// *   eds.general: General Office
	// *   eds.hf: High Frequency
	// *   eds.graphics: Graphics
	DesktopTypeFamily *string `json:"DesktopTypeFamily,omitempty" xml:"DesktopTypeFamily,omitempty"`
	// This parameter is now in invitational preview and unavailable.
	FotaChannel *string `json:"FotaChannel,omitempty" xml:"FotaChannel,omitempty"`
	// Specifies whether the cloud desktop template belongs to a desktop group. Default value: false.
	FromDesktopGroup *bool `json:"FromDesktopGroup,omitempty" xml:"FromDesktopGroup,omitempty"`
	// The number of GPUs that is defined in the cloud desktop type.
	GpuCount *float32 `json:"GpuCount,omitempty" xml:"GpuCount,omitempty"`
	// The image ID.
	ImageId []*string `json:"ImageId,omitempty" xml:"ImageId,omitempty" type:"Repeated"`
	// The number of entries to return on each page.
	//
	// Maximum value: 100.
	//
	// Default value: 10.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The memory size that is defined in the cloud desktop type. Unit: GiB.
	MemorySize *int32 `json:"MemorySize,omitempty" xml:"MemorySize,omitempty"`
	// The token that is used to start the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The OS. Valid values:
	//
	// * **Windows**
	// * **Linux**
	OsType *string `json:"OsType,omitempty" xml:"OsType,omitempty"`
	// The protocol type.
	//
	// *   HDX
	// *   ASP (Recommend)
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~436773~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The scenario to use the image.
	Scope *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
	// The desktop template that is selected based on specific criteria.
	SelectedBundle *bool `json:"SelectedBundle,omitempty" xml:"SelectedBundle,omitempty"`
	// The type of the session.
	//
	// Enumeration Value:
	// * **SingleSession**
	// * **MultipleSession**
	SessionType *string `json:"SessionType,omitempty" xml:"SessionType,omitempty"`
	// Specifies whether to return multi-session desktop templates in this call. Default value: false.
	SupportMultiSession *bool `json:"SupportMultiSession,omitempty" xml:"SupportMultiSession,omitempty"`
	// Specifies whether to enable disk encryption.
	VolumeEncryptionEnabled *bool `json:"VolumeEncryptionEnabled,omitempty" xml:"VolumeEncryptionEnabled,omitempty"`
}

func (s DescribeBundlesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeBundlesRequest) GoString() string {
	return s.String()
}

func (s *DescribeBundlesRequest) SetBundleId(v []*string) *DescribeBundlesRequest {
	s.BundleId = v
	return s
}

func (s *DescribeBundlesRequest) SetBundleType(v string) *DescribeBundlesRequest {
	s.BundleType = &v
	return s
}

func (s *DescribeBundlesRequest) SetCheckStock(v bool) *DescribeBundlesRequest {
	s.CheckStock = &v
	return s
}

func (s *DescribeBundlesRequest) SetCpuCount(v int32) *DescribeBundlesRequest {
	s.CpuCount = &v
	return s
}

func (s *DescribeBundlesRequest) SetDesktopTypeFamily(v string) *DescribeBundlesRequest {
	s.DesktopTypeFamily = &v
	return s
}

func (s *DescribeBundlesRequest) SetFotaChannel(v string) *DescribeBundlesRequest {
	s.FotaChannel = &v
	return s
}

func (s *DescribeBundlesRequest) SetFromDesktopGroup(v bool) *DescribeBundlesRequest {
	s.FromDesktopGroup = &v
	return s
}

func (s *DescribeBundlesRequest) SetGpuCount(v float32) *DescribeBundlesRequest {
	s.GpuCount = &v
	return s
}

func (s *DescribeBundlesRequest) SetImageId(v []*string) *DescribeBundlesRequest {
	s.ImageId = v
	return s
}

func (s *DescribeBundlesRequest) SetMaxResults(v int32) *DescribeBundlesRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeBundlesRequest) SetMemorySize(v int32) *DescribeBundlesRequest {
	s.MemorySize = &v
	return s
}

func (s *DescribeBundlesRequest) SetNextToken(v string) *DescribeBundlesRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeBundlesRequest) SetOsType(v string) *DescribeBundlesRequest {
	s.OsType = &v
	return s
}

func (s *DescribeBundlesRequest) SetProtocolType(v string) *DescribeBundlesRequest {
	s.ProtocolType = &v
	return s
}

func (s *DescribeBundlesRequest) SetRegionId(v string) *DescribeBundlesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeBundlesRequest) SetScope(v string) *DescribeBundlesRequest {
	s.Scope = &v
	return s
}

func (s *DescribeBundlesRequest) SetSelectedBundle(v bool) *DescribeBundlesRequest {
	s.SelectedBundle = &v
	return s
}

func (s *DescribeBundlesRequest) SetSessionType(v string) *DescribeBundlesRequest {
	s.SessionType = &v
	return s
}

func (s *DescribeBundlesRequest) SetSupportMultiSession(v bool) *DescribeBundlesRequest {
	s.SupportMultiSession = &v
	return s
}

func (s *DescribeBundlesRequest) SetVolumeEncryptionEnabled(v bool) *DescribeBundlesRequest {
	s.VolumeEncryptionEnabled = &v
	return s
}

type DescribeBundlesResponseBody struct {
	// Details about the cloud desktop templates.
	Bundles []*DescribeBundlesResponseBodyBundles `json:"Bundles,omitempty" xml:"Bundles,omitempty" type:"Repeated"`
	// The token that is used for the next query. If this parameter is empty, all results have been returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeBundlesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeBundlesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeBundlesResponseBody) SetBundles(v []*DescribeBundlesResponseBodyBundles) *DescribeBundlesResponseBody {
	s.Bundles = v
	return s
}

func (s *DescribeBundlesResponseBody) SetNextToken(v string) *DescribeBundlesResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeBundlesResponseBody) SetRequestId(v string) *DescribeBundlesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeBundlesResponseBodyBundles struct {
	// The ID of the cloud desktop template.
	BundleId *string `json:"BundleId,omitempty" xml:"BundleId,omitempty"`
	// The name of the cloud desktop template.
	BundleName *string `json:"BundleName,omitempty" xml:"BundleName,omitempty"`
	// The type of the cloud desktop template. Valid values:
	//
	// *   SYSTEM: the system template
	// *   CUSTOM: the custom template
	BundleType *string `json:"BundleType,omitempty" xml:"BundleType,omitempty"`
	// The time when the cloud desktop template was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the cloud desktop template.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The type of the cloud desktop.
	DesktopType *string `json:"DesktopType,omitempty" xml:"DesktopType,omitempty"`
	// Details about the cloud desktop type.
	DesktopTypeAttribute *DescribeBundlesResponseBodyBundlesDesktopTypeAttribute `json:"DesktopTypeAttribute,omitempty" xml:"DesktopTypeAttribute,omitempty" type:"Struct"`
	// The family of the cloud desktop type. Valid values:
	//
	// *   eds.general: General Office
	// *   eds.hf: High Frequency
	// *   eds.graphics: Graphics
	DesktopTypeFamily *string `json:"DesktopTypeFamily,omitempty" xml:"DesktopTypeFamily,omitempty"`
	// Details about the disks.
	Disks []*DescribeBundlesResponseBodyBundlesDisks `json:"Disks,omitempty" xml:"Disks,omitempty" type:"Repeated"`
	// The ID of the image.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The name of the image.
	ImageName *string `json:"ImageName,omitempty" xml:"ImageName,omitempty"`
	// The status of the image.
	ImageStatus *string `json:"ImageStatus,omitempty" xml:"ImageStatus,omitempty"`
	// The OS language of the image.
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// The OS type.
	OsType *string `json:"OsType,omitempty" xml:"OsType,omitempty"`
	// The information about the OS platform. Valid values:
	//
	// * CentOS
	// * Ubuntu
	// * Windows Server 2016
	// * Windows Server 2019
	// * UOS
	Platform *string `json:"Platform,omitempty" xml:"Platform,omitempty"`
	// The protocol type.
	//
	// *   HDX
	// *   ASP (Recommend)
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The session type. Valid values:
	//
	// *   0: single_session
	// *   1: multiple_session
	SessionType *string `json:"SessionType,omitempty" xml:"SessionType,omitempty"`
	// The inventory status of the cloud desktop type, which is returned when the CheckStock parameter is set to true.
	StockState *string `json:"StockState,omitempty" xml:"StockState,omitempty"`
	// Indicates whether disk encryption is enabled.
	VolumeEncryptionEnabled *bool `json:"VolumeEncryptionEnabled,omitempty" xml:"VolumeEncryptionEnabled,omitempty"`
	// The ID of the Key Management Service (KMS) key that is used when disk encryption is enabled.
	VolumeEncryptionKey *string `json:"VolumeEncryptionKey,omitempty" xml:"VolumeEncryptionKey,omitempty"`
}

func (s DescribeBundlesResponseBodyBundles) String() string {
	return tea.Prettify(s)
}

func (s DescribeBundlesResponseBodyBundles) GoString() string {
	return s.String()
}

func (s *DescribeBundlesResponseBodyBundles) SetBundleId(v string) *DescribeBundlesResponseBodyBundles {
	s.BundleId = &v
	return s
}

func (s *DescribeBundlesResponseBodyBundles) SetBundleName(v string) *DescribeBundlesResponseBodyBundles {
	s.BundleName = &v
	return s
}

func (s *DescribeBundlesResponseBodyBundles) SetBundleType(v string) *DescribeBundlesResponseBodyBundles {
	s.BundleType = &v
	return s
}

func (s *DescribeBundlesResponseBodyBundles) SetCreationTime(v string) *DescribeBundlesResponseBodyBundles {
	s.CreationTime = &v
	return s
}

func (s *DescribeBundlesResponseBodyBundles) SetDescription(v string) *DescribeBundlesResponseBodyBundles {
	s.Description = &v
	return s
}

func (s *DescribeBundlesResponseBodyBundles) SetDesktopType(v string) *DescribeBundlesResponseBodyBundles {
	s.DesktopType = &v
	return s
}

func (s *DescribeBundlesResponseBodyBundles) SetDesktopTypeAttribute(v *DescribeBundlesResponseBodyBundlesDesktopTypeAttribute) *DescribeBundlesResponseBodyBundles {
	s.DesktopTypeAttribute = v
	return s
}

func (s *DescribeBundlesResponseBodyBundles) SetDesktopTypeFamily(v string) *DescribeBundlesResponseBodyBundles {
	s.DesktopTypeFamily = &v
	return s
}

func (s *DescribeBundlesResponseBodyBundles) SetDisks(v []*DescribeBundlesResponseBodyBundlesDisks) *DescribeBundlesResponseBodyBundles {
	s.Disks = v
	return s
}

func (s *DescribeBundlesResponseBodyBundles) SetImageId(v string) *DescribeBundlesResponseBodyBundles {
	s.ImageId = &v
	return s
}

func (s *DescribeBundlesResponseBodyBundles) SetImageName(v string) *DescribeBundlesResponseBodyBundles {
	s.ImageName = &v
	return s
}

func (s *DescribeBundlesResponseBodyBundles) SetImageStatus(v string) *DescribeBundlesResponseBodyBundles {
	s.ImageStatus = &v
	return s
}

func (s *DescribeBundlesResponseBodyBundles) SetLanguage(v string) *DescribeBundlesResponseBodyBundles {
	s.Language = &v
	return s
}

func (s *DescribeBundlesResponseBodyBundles) SetOsType(v string) *DescribeBundlesResponseBodyBundles {
	s.OsType = &v
	return s
}

func (s *DescribeBundlesResponseBodyBundles) SetPlatform(v string) *DescribeBundlesResponseBodyBundles {
	s.Platform = &v
	return s
}

func (s *DescribeBundlesResponseBodyBundles) SetProtocolType(v string) *DescribeBundlesResponseBodyBundles {
	s.ProtocolType = &v
	return s
}

func (s *DescribeBundlesResponseBodyBundles) SetSessionType(v string) *DescribeBundlesResponseBodyBundles {
	s.SessionType = &v
	return s
}

func (s *DescribeBundlesResponseBodyBundles) SetStockState(v string) *DescribeBundlesResponseBodyBundles {
	s.StockState = &v
	return s
}

func (s *DescribeBundlesResponseBodyBundles) SetVolumeEncryptionEnabled(v bool) *DescribeBundlesResponseBodyBundles {
	s.VolumeEncryptionEnabled = &v
	return s
}

func (s *DescribeBundlesResponseBodyBundles) SetVolumeEncryptionKey(v string) *DescribeBundlesResponseBodyBundles {
	s.VolumeEncryptionKey = &v
	return s
}

type DescribeBundlesResponseBodyBundlesDesktopTypeAttribute struct {
	// The number of vCPUs.
	CpuCount *int32 `json:"CpuCount,omitempty" xml:"CpuCount,omitempty"`
	// The number of GPUs.
	GpuCount *float32 `json:"GpuCount,omitempty" xml:"GpuCount,omitempty"`
	// The GPU type.
	GpuSpec *string `json:"GpuSpec,omitempty" xml:"GpuSpec,omitempty"`
	// The memory size. Unit: MB.
	MemorySize *int32 `json:"MemorySize,omitempty" xml:"MemorySize,omitempty"`
}

func (s DescribeBundlesResponseBodyBundlesDesktopTypeAttribute) String() string {
	return tea.Prettify(s)
}

func (s DescribeBundlesResponseBodyBundlesDesktopTypeAttribute) GoString() string {
	return s.String()
}

func (s *DescribeBundlesResponseBodyBundlesDesktopTypeAttribute) SetCpuCount(v int32) *DescribeBundlesResponseBodyBundlesDesktopTypeAttribute {
	s.CpuCount = &v
	return s
}

func (s *DescribeBundlesResponseBodyBundlesDesktopTypeAttribute) SetGpuCount(v float32) *DescribeBundlesResponseBodyBundlesDesktopTypeAttribute {
	s.GpuCount = &v
	return s
}

func (s *DescribeBundlesResponseBodyBundlesDesktopTypeAttribute) SetGpuSpec(v string) *DescribeBundlesResponseBodyBundlesDesktopTypeAttribute {
	s.GpuSpec = &v
	return s
}

func (s *DescribeBundlesResponseBodyBundlesDesktopTypeAttribute) SetMemorySize(v int32) *DescribeBundlesResponseBodyBundlesDesktopTypeAttribute {
	s.MemorySize = &v
	return s
}

type DescribeBundlesResponseBodyBundlesDisks struct {
	// The performance level (PL) of the disk.
	DiskPerformanceLevel *string `json:"DiskPerformanceLevel,omitempty" xml:"DiskPerformanceLevel,omitempty"`
	// The size of the disk. Unit: GiB.
	DiskSize *int32 `json:"DiskSize,omitempty" xml:"DiskSize,omitempty"`
	// The disk type. Valid values:
	//
	// *   SYSTEM: the system disk
	// *   DATA: the data disk
	DiskType *string `json:"DiskType,omitempty" xml:"DiskType,omitempty"`
}

func (s DescribeBundlesResponseBodyBundlesDisks) String() string {
	return tea.Prettify(s)
}

func (s DescribeBundlesResponseBodyBundlesDisks) GoString() string {
	return s.String()
}

func (s *DescribeBundlesResponseBodyBundlesDisks) SetDiskPerformanceLevel(v string) *DescribeBundlesResponseBodyBundlesDisks {
	s.DiskPerformanceLevel = &v
	return s
}

func (s *DescribeBundlesResponseBodyBundlesDisks) SetDiskSize(v int32) *DescribeBundlesResponseBodyBundlesDisks {
	s.DiskSize = &v
	return s
}

func (s *DescribeBundlesResponseBodyBundlesDisks) SetDiskType(v string) *DescribeBundlesResponseBodyBundlesDisks {
	s.DiskType = &v
	return s
}

type DescribeBundlesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeBundlesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeBundlesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeBundlesResponse) GoString() string {
	return s.String()
}

func (s *DescribeBundlesResponse) SetHeaders(v map[string]*string) *DescribeBundlesResponse {
	s.Headers = v
	return s
}

func (s *DescribeBundlesResponse) SetStatusCode(v int32) *DescribeBundlesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeBundlesResponse) SetBody(v *DescribeBundlesResponseBody) *DescribeBundlesResponse {
	s.Body = v
	return s
}

type DescribeCdsFileShareLinksRequest struct {
	// The ID of the cloud disk.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	// The users that create the file sharing links.
	Creators []*string `json:"Creators,omitempty" xml:"Creators,omitempty" type:"Repeated"`
	// The maximum number of resources to return. Valid values: 1 to 100. Default value: 100. The number of returned resources must be less than or equal to the specified number.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// Specifies the marker after which the returned list begins. If this parameter is not specified, all results are returned. Default value: null.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the file sharing link.
	ShareId *string `json:"ShareId,omitempty" xml:"ShareId,omitempty"`
	// The sharing name for fuzzy search.
	ShareName *string `json:"ShareName,omitempty" xml:"ShareName,omitempty"`
	// The file sharing status. Valid values:  disabled: canceled  enabled: valid
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeCdsFileShareLinksRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdsFileShareLinksRequest) GoString() string {
	return s.String()
}

func (s *DescribeCdsFileShareLinksRequest) SetCdsId(v string) *DescribeCdsFileShareLinksRequest {
	s.CdsId = &v
	return s
}

func (s *DescribeCdsFileShareLinksRequest) SetCreators(v []*string) *DescribeCdsFileShareLinksRequest {
	s.Creators = v
	return s
}

func (s *DescribeCdsFileShareLinksRequest) SetMaxResults(v int32) *DescribeCdsFileShareLinksRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeCdsFileShareLinksRequest) SetNextToken(v string) *DescribeCdsFileShareLinksRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeCdsFileShareLinksRequest) SetShareId(v string) *DescribeCdsFileShareLinksRequest {
	s.ShareId = &v
	return s
}

func (s *DescribeCdsFileShareLinksRequest) SetShareName(v string) *DescribeCdsFileShareLinksRequest {
	s.ShareName = &v
	return s
}

func (s *DescribeCdsFileShareLinksRequest) SetStatus(v string) *DescribeCdsFileShareLinksRequest {
	s.Status = &v
	return s
}

type DescribeCdsFileShareLinksResponseBody struct {
	// The operation result. A value of success indicates that the operation is successful. If the operation failed, an error message is returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data information.
	Data []*CdsFileShareLinkModel `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error message that is returned. This parameter is not returned if the value of Code is `success`.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// A pagination token. It can be used in the next request to retrieve a new page of results. If NextToken is empty, no next page exists.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DescribeCdsFileShareLinksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdsFileShareLinksResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCdsFileShareLinksResponseBody) SetCode(v string) *DescribeCdsFileShareLinksResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeCdsFileShareLinksResponseBody) SetData(v []*CdsFileShareLinkModel) *DescribeCdsFileShareLinksResponseBody {
	s.Data = v
	return s
}

func (s *DescribeCdsFileShareLinksResponseBody) SetMessage(v string) *DescribeCdsFileShareLinksResponseBody {
	s.Message = &v
	return s
}

func (s *DescribeCdsFileShareLinksResponseBody) SetNextToken(v string) *DescribeCdsFileShareLinksResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeCdsFileShareLinksResponseBody) SetRequestId(v string) *DescribeCdsFileShareLinksResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCdsFileShareLinksResponseBody) SetSuccess(v bool) *DescribeCdsFileShareLinksResponseBody {
	s.Success = &v
	return s
}

type DescribeCdsFileShareLinksResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCdsFileShareLinksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCdsFileShareLinksResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCdsFileShareLinksResponse) GoString() string {
	return s.String()
}

func (s *DescribeCdsFileShareLinksResponse) SetHeaders(v map[string]*string) *DescribeCdsFileShareLinksResponse {
	s.Headers = v
	return s
}

func (s *DescribeCdsFileShareLinksResponse) SetStatusCode(v int32) *DescribeCdsFileShareLinksResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCdsFileShareLinksResponse) SetBody(v *DescribeCdsFileShareLinksResponseBody) *DescribeCdsFileShareLinksResponse {
	s.Body = v
	return s
}

type DescribeCensRequest struct {
	// Details about CEN instances.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of the page to return.
	//
	// Default value: 1.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the bandwidth plan that is associated with the CEN instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeCensRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCensRequest) GoString() string {
	return s.String()
}

func (s *DescribeCensRequest) SetPageNumber(v int32) *DescribeCensRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCensRequest) SetPageSize(v int32) *DescribeCensRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeCensRequest) SetRegionId(v string) *DescribeCensRequest {
	s.RegionId = &v
	return s
}

type DescribeCensResponseBody struct {
	// The level of CIDR block overlapping. Valid value: REDUCED. This value indicates that the CIDR blocks can overlap with each other but must not be the same.
	Cens []*DescribeCensResponseBodyCens `json:"Cens,omitempty" xml:"Cens,omitempty" type:"Repeated"`
	// The status of the CEN instance. Valid values:
	//
	// *   Creating: The CEN instance is being created.
	// *   Active: The CEN instance is running.
	// *   Deleting: The CEN instance is being deleted.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The description of the CEN instance.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The operation that you want to perform. Set the value to DescribeCens.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The IDs of the bandwidth plans that are associated with the CEN instance.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeCensResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCensResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCensResponseBody) SetCens(v []*DescribeCensResponseBodyCens) *DescribeCensResponseBody {
	s.Cens = v
	return s
}

func (s *DescribeCensResponseBody) SetPageNumber(v int32) *DescribeCensResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeCensResponseBody) SetPageSize(v int32) *DescribeCensResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeCensResponseBody) SetRequestId(v string) *DescribeCensResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCensResponseBody) SetTotalCount(v int32) *DescribeCensResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeCensResponseBodyCens struct {
	// The number of entries returned per page.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The tag value of the CEN instance.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The tag key of the CEN instance.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether IPv6 is supported. Valid value: DISABLED. This value indicates that IPv6 is not supported.
	//
	// >  IPv6 is not supported.
	Ipv6Level *string `json:"Ipv6Level,omitempty" xml:"Ipv6Level,omitempty"`
	// The ID of the request.
	Name       *string                                   `json:"Name,omitempty" xml:"Name,omitempty"`
	PackageIds []*DescribeCensResponseBodyCensPackageIds `json:"PackageIds,omitempty" xml:"PackageIds,omitempty" type:"Repeated"`
	// The name of the CEN instance.
	ProtectionLevel *string `json:"ProtectionLevel,omitempty" xml:"ProtectionLevel,omitempty"`
	// The ID of the region.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the CEN instance.
	Tags []*DescribeCensResponseBodyCensTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s DescribeCensResponseBodyCens) String() string {
	return tea.Prettify(s)
}

func (s DescribeCensResponseBodyCens) GoString() string {
	return s.String()
}

func (s *DescribeCensResponseBodyCens) SetCenId(v string) *DescribeCensResponseBodyCens {
	s.CenId = &v
	return s
}

func (s *DescribeCensResponseBodyCens) SetCreationTime(v string) *DescribeCensResponseBodyCens {
	s.CreationTime = &v
	return s
}

func (s *DescribeCensResponseBodyCens) SetDescription(v string) *DescribeCensResponseBodyCens {
	s.Description = &v
	return s
}

func (s *DescribeCensResponseBodyCens) SetIpv6Level(v string) *DescribeCensResponseBodyCens {
	s.Ipv6Level = &v
	return s
}

func (s *DescribeCensResponseBodyCens) SetName(v string) *DescribeCensResponseBodyCens {
	s.Name = &v
	return s
}

func (s *DescribeCensResponseBodyCens) SetPackageIds(v []*DescribeCensResponseBodyCensPackageIds) *DescribeCensResponseBodyCens {
	s.PackageIds = v
	return s
}

func (s *DescribeCensResponseBodyCens) SetProtectionLevel(v string) *DescribeCensResponseBodyCens {
	s.ProtectionLevel = &v
	return s
}

func (s *DescribeCensResponseBodyCens) SetStatus(v string) *DescribeCensResponseBodyCens {
	s.Status = &v
	return s
}

func (s *DescribeCensResponseBodyCens) SetTags(v []*DescribeCensResponseBodyCensTags) *DescribeCensResponseBodyCens {
	s.Tags = v
	return s
}

type DescribeCensResponseBodyCensPackageIds struct {
	PackageId *string `json:"PackageId,omitempty" xml:"PackageId,omitempty"`
}

func (s DescribeCensResponseBodyCensPackageIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeCensResponseBodyCensPackageIds) GoString() string {
	return s.String()
}

func (s *DescribeCensResponseBodyCensPackageIds) SetPackageId(v string) *DescribeCensResponseBodyCensPackageIds {
	s.PackageId = &v
	return s
}

type DescribeCensResponseBodyCensTags struct {
	// DescribeCens
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeCensResponseBodyCensTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeCensResponseBodyCensTags) GoString() string {
	return s.String()
}

func (s *DescribeCensResponseBodyCensTags) SetKey(v string) *DescribeCensResponseBodyCensTags {
	s.Key = &v
	return s
}

func (s *DescribeCensResponseBodyCensTags) SetValue(v string) *DescribeCensResponseBodyCensTags {
	s.Value = &v
	return s
}

type DescribeCensResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCensResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCensResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCensResponse) GoString() string {
	return s.String()
}

func (s *DescribeCensResponse) SetHeaders(v map[string]*string) *DescribeCensResponse {
	s.Headers = v
	return s
}

func (s *DescribeCensResponse) SetStatusCode(v int32) *DescribeCensResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCensResponse) SetBody(v *DescribeCensResponseBody) *DescribeCensResponse {
	s.Body = v
	return s
}

type DescribeClientEventsRequest struct {
	// The ID of the Alibaba Cloud account with which the event is associated.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The account type of the workspace. Valid values:
	//
	// *   SIMPLE: convenience account
	// *   AD_CONNECTOR: enterprise AD account
	DesktopIp *string `json:"DesktopIp,omitempty" xml:"DesktopIp,omitempty"`
	// The types of event.
	DesktopName *string `json:"DesktopName,omitempty" xml:"DesktopName,omitempty"`
	// The ID of the desktop group.
	DirectoryId *string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	// The ID of the region where the cloud desktop resides.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the directory to which the cloud desktop belongs.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The ID of the workspace to which the cloud desktop belongs. If you do not specify a value for this parameter, events of all workspaces in the specified region are queried.
	EventType *string `json:"EventType,omitempty" xml:"EventType,omitempty"`
	// Details about the events.
	EventTypes []*string `json:"EventTypes,omitempty" xml:"EventTypes,omitempty" type:"Repeated"`
	// The status of the event. This parameter is returned if you set the EventType parameter to DESKTOP_DISCONNECT or GET_CONNECTION_TICKET. Valid values:
	//
	// *   200\. The value indicates that the request is successful.
	// *   An error message. The value indicates that the request failed. Example: FailedToGetConnectionTicket.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The IP address of the client.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the workspace to which the cloud desktop belongs.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The OS that the client runs.
	OfficeSiteName *string `json:"OfficeSiteName,omitempty" xml:"OfficeSiteName,omitempty"`
	// The number of bytes that are received.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The IP address of the cloud desktop.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeClientEventsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeClientEventsRequest) GoString() string {
	return s.String()
}

func (s *DescribeClientEventsRequest) SetDesktopId(v string) *DescribeClientEventsRequest {
	s.DesktopId = &v
	return s
}

func (s *DescribeClientEventsRequest) SetDesktopIp(v string) *DescribeClientEventsRequest {
	s.DesktopIp = &v
	return s
}

func (s *DescribeClientEventsRequest) SetDesktopName(v string) *DescribeClientEventsRequest {
	s.DesktopName = &v
	return s
}

func (s *DescribeClientEventsRequest) SetDirectoryId(v string) *DescribeClientEventsRequest {
	s.DirectoryId = &v
	return s
}

func (s *DescribeClientEventsRequest) SetEndTime(v string) *DescribeClientEventsRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeClientEventsRequest) SetEndUserId(v string) *DescribeClientEventsRequest {
	s.EndUserId = &v
	return s
}

func (s *DescribeClientEventsRequest) SetEventType(v string) *DescribeClientEventsRequest {
	s.EventType = &v
	return s
}

func (s *DescribeClientEventsRequest) SetEventTypes(v []*string) *DescribeClientEventsRequest {
	s.EventTypes = v
	return s
}

func (s *DescribeClientEventsRequest) SetMaxResults(v int32) *DescribeClientEventsRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeClientEventsRequest) SetNextToken(v string) *DescribeClientEventsRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeClientEventsRequest) SetOfficeSiteId(v string) *DescribeClientEventsRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *DescribeClientEventsRequest) SetOfficeSiteName(v string) *DescribeClientEventsRequest {
	s.OfficeSiteName = &v
	return s
}

func (s *DescribeClientEventsRequest) SetRegionId(v string) *DescribeClientEventsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeClientEventsRequest) SetStartTime(v string) *DescribeClientEventsRequest {
	s.StartTime = &v
	return s
}

type DescribeClientEventsResponseBody struct {
	// The information about the regular user that connects to the cloud desktop from the EDS client. The information can be the RAM user ID or AD username.
	Events []*DescribeClientEventsResponseBodyEvents `json:"Events,omitempty" xml:"Events,omitempty" type:"Repeated"`
	// The ID of the region.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The type of the directory.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeClientEventsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeClientEventsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeClientEventsResponseBody) SetEvents(v []*DescribeClientEventsResponseBodyEvents) *DescribeClientEventsResponseBody {
	s.Events = v
	return s
}

func (s *DescribeClientEventsResponseBody) SetNextToken(v string) *DescribeClientEventsResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeClientEventsResponseBody) SetRequestId(v string) *DescribeClientEventsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeClientEventsResponseBodyEvents struct {
	// The name of the cloud desktop.
	AliUid *string `json:"AliUid,omitempty" xml:"AliUid,omitempty"`
	// The name of the cloud desktop.
	BytesReceived *string `json:"BytesReceived,omitempty" xml:"BytesReceived,omitempty"`
	// The information about the regular user that connects to the cloud desktop from the EDS client. The information can be the RAM user ID or Active Directory (AD) username. If you do not specify a value for this parameter, events of all regular users in the specified region are queried.
	BytesSend *string `json:"BytesSend,omitempty" xml:"BytesSend,omitempty"`
	// The IP address of the cloud desktop. If you do not specify a value for this parameter, events of all cloud desktops in the specified region are queried.
	ClientIp *string `json:"ClientIp,omitempty" xml:"ClientIp,omitempty"`
	// The ID of the cloud desktop.
	ClientOS *string `json:"ClientOS,omitempty" xml:"ClientOS,omitempty"`
	// DescribeClientEvents
	ClientVersion    *string `json:"ClientVersion,omitempty" xml:"ClientVersion,omitempty"`
	DesktopGroupId   *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	DesktopGroupName *string `json:"DesktopGroupName,omitempty" xml:"DesktopGroupName,omitempty"`
	// The name of the desktop group.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The name of the workspace.
	DesktopIp   *string `json:"DesktopIp,omitempty" xml:"DesktopIp,omitempty"`
	DesktopName *string `json:"DesktopName,omitempty" xml:"DesktopName,omitempty"`
	// The type of the event.
	DirectoryId *string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	// The type of event.
	DirectoryType *string `json:"DirectoryType,omitempty" xml:"DirectoryType,omitempty"`
	// The end of the time range to query. Specify the time in the [ISO 8601](~~25696~~) standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.
	//
	// If you do not specify a value for this parameter, the current time is used.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The type of event that you want to query. Valid values:
	//
	// *   DESKTOP_CONNECT: The desktop session is established.
	// *   DESKTOP_DISCONNECT: The desktop session is disconnected.
	// *   DESKTOP_REBOOT: The cloud desktop is restarted.
	// *   CLIENT_AD_LOGIN: The AD user logs on to the client.
	// *   GET_CONNECTION_TICKET: The request to connect to the cloud desktop is sent.
	// *   DESKTOP_START: The cloud desktop is started.
	// *   DESKTOP_STOP: The cloud desktop is stopped.
	//
	// If you do not specify a value for this parameter, events of all types are queried.
	EventId *string `json:"EventId,omitempty" xml:"EventId,omitempty"`
	// The beginning of the time range to query. Specify the time in the [ISO 8601](~~25696~~) standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.
	//
	// If you do not specify a value for this parameter, all events that occurred before the point in time that you specify for `EndTime` are queried.
	EventTime *string `json:"EventTime,omitempty" xml:"EventTime,omitempty"`
	// The query token. Set the value to the NextToken value that is returned from the last call to the DescribeClientEvents operation.
	EventType *string `json:"EventType,omitempty" xml:"EventType,omitempty"`
	// The ID of the event.
	OfficeSiteId   *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	OfficeSiteName *string `json:"OfficeSiteName,omitempty" xml:"OfficeSiteName,omitempty"`
	// The ID of the request.
	OfficeSiteType *string `json:"OfficeSiteType,omitempty" xml:"OfficeSiteType,omitempty"`
	// The ID of the cloud desktop. If you do not specify a value for this parameter, events of all cloud desktops in the specified region are queried.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The number of bytes that are sent.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeClientEventsResponseBodyEvents) String() string {
	return tea.Prettify(s)
}

func (s DescribeClientEventsResponseBodyEvents) GoString() string {
	return s.String()
}

func (s *DescribeClientEventsResponseBodyEvents) SetAliUid(v string) *DescribeClientEventsResponseBodyEvents {
	s.AliUid = &v
	return s
}

func (s *DescribeClientEventsResponseBodyEvents) SetBytesReceived(v string) *DescribeClientEventsResponseBodyEvents {
	s.BytesReceived = &v
	return s
}

func (s *DescribeClientEventsResponseBodyEvents) SetBytesSend(v string) *DescribeClientEventsResponseBodyEvents {
	s.BytesSend = &v
	return s
}

func (s *DescribeClientEventsResponseBodyEvents) SetClientIp(v string) *DescribeClientEventsResponseBodyEvents {
	s.ClientIp = &v
	return s
}

func (s *DescribeClientEventsResponseBodyEvents) SetClientOS(v string) *DescribeClientEventsResponseBodyEvents {
	s.ClientOS = &v
	return s
}

func (s *DescribeClientEventsResponseBodyEvents) SetClientVersion(v string) *DescribeClientEventsResponseBodyEvents {
	s.ClientVersion = &v
	return s
}

func (s *DescribeClientEventsResponseBodyEvents) SetDesktopGroupId(v string) *DescribeClientEventsResponseBodyEvents {
	s.DesktopGroupId = &v
	return s
}

func (s *DescribeClientEventsResponseBodyEvents) SetDesktopGroupName(v string) *DescribeClientEventsResponseBodyEvents {
	s.DesktopGroupName = &v
	return s
}

func (s *DescribeClientEventsResponseBodyEvents) SetDesktopId(v string) *DescribeClientEventsResponseBodyEvents {
	s.DesktopId = &v
	return s
}

func (s *DescribeClientEventsResponseBodyEvents) SetDesktopIp(v string) *DescribeClientEventsResponseBodyEvents {
	s.DesktopIp = &v
	return s
}

func (s *DescribeClientEventsResponseBodyEvents) SetDesktopName(v string) *DescribeClientEventsResponseBodyEvents {
	s.DesktopName = &v
	return s
}

func (s *DescribeClientEventsResponseBodyEvents) SetDirectoryId(v string) *DescribeClientEventsResponseBodyEvents {
	s.DirectoryId = &v
	return s
}

func (s *DescribeClientEventsResponseBodyEvents) SetDirectoryType(v string) *DescribeClientEventsResponseBodyEvents {
	s.DirectoryType = &v
	return s
}

func (s *DescribeClientEventsResponseBodyEvents) SetEndUserId(v string) *DescribeClientEventsResponseBodyEvents {
	s.EndUserId = &v
	return s
}

func (s *DescribeClientEventsResponseBodyEvents) SetEventId(v string) *DescribeClientEventsResponseBodyEvents {
	s.EventId = &v
	return s
}

func (s *DescribeClientEventsResponseBodyEvents) SetEventTime(v string) *DescribeClientEventsResponseBodyEvents {
	s.EventTime = &v
	return s
}

func (s *DescribeClientEventsResponseBodyEvents) SetEventType(v string) *DescribeClientEventsResponseBodyEvents {
	s.EventType = &v
	return s
}

func (s *DescribeClientEventsResponseBodyEvents) SetOfficeSiteId(v string) *DescribeClientEventsResponseBodyEvents {
	s.OfficeSiteId = &v
	return s
}

func (s *DescribeClientEventsResponseBodyEvents) SetOfficeSiteName(v string) *DescribeClientEventsResponseBodyEvents {
	s.OfficeSiteName = &v
	return s
}

func (s *DescribeClientEventsResponseBodyEvents) SetOfficeSiteType(v string) *DescribeClientEventsResponseBodyEvents {
	s.OfficeSiteType = &v
	return s
}

func (s *DescribeClientEventsResponseBodyEvents) SetRegionId(v string) *DescribeClientEventsResponseBodyEvents {
	s.RegionId = &v
	return s
}

func (s *DescribeClientEventsResponseBodyEvents) SetStatus(v string) *DescribeClientEventsResponseBodyEvents {
	s.Status = &v
	return s
}

type DescribeClientEventsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeClientEventsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeClientEventsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeClientEventsResponse) GoString() string {
	return s.String()
}

func (s *DescribeClientEventsResponse) SetHeaders(v map[string]*string) *DescribeClientEventsResponse {
	s.Headers = v
	return s
}

func (s *DescribeClientEventsResponse) SetStatusCode(v int32) *DescribeClientEventsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeClientEventsResponse) SetBody(v *DescribeClientEventsResponseBody) *DescribeClientEventsResponse {
	s.Body = v
	return s
}

type DescribeCloudDriveGroupsRequest struct {
	// The ID of the cloud disk in Cloud Drive Service.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	// The workspace ID.
	DirectoryId *string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	// The workspace name.
	DirectoryName *string `json:"DirectoryName,omitempty" xml:"DirectoryName,omitempty"`
	// The team space status. Valid values:
	//
	// *   enabled
	// *   disabled
	//
	// Default value: enabled.
	DriveStatus *string `json:"DriveStatus,omitempty" xml:"DriveStatus,omitempty"`
	// Specifies whether the space is increased.
	//
	// *   binding: increased
	// *   unbound: not increased
	//
	// Default value: null. The default value indicates that all spaces are queried.
	DriveType *string `json:"DriveType,omitempty" xml:"DriveType,omitempty"`
	// The team ID.
	GroupId []*string `json:"GroupId,omitempty" xml:"GroupId,omitempty" type:"Repeated"`
	// The team name for fuzzy search.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The team type.
	//
	// *   org: organizational structure
	// *   directory: workspace
	//
	// Default value: null. The default value indicates that all types of teams are queried.
	GroupType *string `json:"GroupType,omitempty" xml:"GroupType,omitempty"`
	// The number of entries to return on each page.
	//
	// *   Valid values: 1 to 100
	// *   Default value: 20
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the parent node. If a parent node ID is specified, the subnodes are queried. If you set the value of this parameter to root, the root node is queried.
	//
	// Default value: null. The default value indicates that all nodes are queried.
	ParentGroupId *string `json:"ParentGroupId,omitempty" xml:"ParentGroupId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeCloudDriveGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCloudDriveGroupsRequest) GoString() string {
	return s.String()
}

func (s *DescribeCloudDriveGroupsRequest) SetCdsId(v string) *DescribeCloudDriveGroupsRequest {
	s.CdsId = &v
	return s
}

func (s *DescribeCloudDriveGroupsRequest) SetDirectoryId(v string) *DescribeCloudDriveGroupsRequest {
	s.DirectoryId = &v
	return s
}

func (s *DescribeCloudDriveGroupsRequest) SetDirectoryName(v string) *DescribeCloudDriveGroupsRequest {
	s.DirectoryName = &v
	return s
}

func (s *DescribeCloudDriveGroupsRequest) SetDriveStatus(v string) *DescribeCloudDriveGroupsRequest {
	s.DriveStatus = &v
	return s
}

func (s *DescribeCloudDriveGroupsRequest) SetDriveType(v string) *DescribeCloudDriveGroupsRequest {
	s.DriveType = &v
	return s
}

func (s *DescribeCloudDriveGroupsRequest) SetGroupId(v []*string) *DescribeCloudDriveGroupsRequest {
	s.GroupId = v
	return s
}

func (s *DescribeCloudDriveGroupsRequest) SetGroupName(v string) *DescribeCloudDriveGroupsRequest {
	s.GroupName = &v
	return s
}

func (s *DescribeCloudDriveGroupsRequest) SetGroupType(v string) *DescribeCloudDriveGroupsRequest {
	s.GroupType = &v
	return s
}

func (s *DescribeCloudDriveGroupsRequest) SetMaxResults(v int32) *DescribeCloudDriveGroupsRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeCloudDriveGroupsRequest) SetNextToken(v string) *DescribeCloudDriveGroupsRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeCloudDriveGroupsRequest) SetParentGroupId(v string) *DescribeCloudDriveGroupsRequest {
	s.ParentGroupId = &v
	return s
}

func (s *DescribeCloudDriveGroupsRequest) SetRegionId(v string) *DescribeCloudDriveGroupsRequest {
	s.RegionId = &v
	return s
}

type DescribeCloudDriveGroupsResponseBody struct {
	// The list of team spaces.
	CloudDriveGroups []*DescribeCloudDriveGroupsResponseBodyCloudDriveGroups `json:"CloudDriveGroups,omitempty" xml:"CloudDriveGroups,omitempty" type:"Repeated"`
	// The total number of entries returned.
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The returned value of NextToken is a pagination token, which can be used in the next request to retrieve a new page of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DescribeCloudDriveGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCloudDriveGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCloudDriveGroupsResponseBody) SetCloudDriveGroups(v []*DescribeCloudDriveGroupsResponseBodyCloudDriveGroups) *DescribeCloudDriveGroupsResponseBody {
	s.CloudDriveGroups = v
	return s
}

func (s *DescribeCloudDriveGroupsResponseBody) SetCount(v int64) *DescribeCloudDriveGroupsResponseBody {
	s.Count = &v
	return s
}

func (s *DescribeCloudDriveGroupsResponseBody) SetNextToken(v string) *DescribeCloudDriveGroupsResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeCloudDriveGroupsResponseBody) SetRequestId(v string) *DescribeCloudDriveGroupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCloudDriveGroupsResponseBody) SetSuccess(v bool) *DescribeCloudDriveGroupsResponseBody {
	s.Success = &v
	return s
}

type DescribeCloudDriveGroupsResponseBodyCloudDriveGroups struct {
	AdminUserIds   *string                                                               `json:"AdminUserIds,omitempty" xml:"AdminUserIds,omitempty"`
	AdminUserInfos []*DescribeCloudDriveGroupsResponseBodyCloudDriveGroupsAdminUserInfos `json:"AdminUserInfos,omitempty" xml:"AdminUserInfos,omitempty" type:"Repeated"`
	// The time when the team space was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The workspace ID.
	DirectoryId *string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	// The team space ID.
	DriveId *string `json:"DriveId,omitempty" xml:"DriveId,omitempty"`
	// The team ID.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the team space.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	OrgId     *string `json:"OrgId,omitempty" xml:"OrgId,omitempty"`
	// The team space status. Valid values:
	//
	// *   enabled
	// *   disabled
	//
	// Default value: enabled.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The total capacity of the team space.
	TotalSize *int64 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
	// The capacity of the used space. Unit: bytes.
	UsedSize *string `json:"UsedSize,omitempty" xml:"UsedSize,omitempty"`
}

func (s DescribeCloudDriveGroupsResponseBodyCloudDriveGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribeCloudDriveGroupsResponseBodyCloudDriveGroups) GoString() string {
	return s.String()
}

func (s *DescribeCloudDriveGroupsResponseBodyCloudDriveGroups) SetAdminUserIds(v string) *DescribeCloudDriveGroupsResponseBodyCloudDriveGroups {
	s.AdminUserIds = &v
	return s
}

func (s *DescribeCloudDriveGroupsResponseBodyCloudDriveGroups) SetAdminUserInfos(v []*DescribeCloudDriveGroupsResponseBodyCloudDriveGroupsAdminUserInfos) *DescribeCloudDriveGroupsResponseBodyCloudDriveGroups {
	s.AdminUserInfos = v
	return s
}

func (s *DescribeCloudDriveGroupsResponseBodyCloudDriveGroups) SetCreateTime(v string) *DescribeCloudDriveGroupsResponseBodyCloudDriveGroups {
	s.CreateTime = &v
	return s
}

func (s *DescribeCloudDriveGroupsResponseBodyCloudDriveGroups) SetDirectoryId(v string) *DescribeCloudDriveGroupsResponseBodyCloudDriveGroups {
	s.DirectoryId = &v
	return s
}

func (s *DescribeCloudDriveGroupsResponseBodyCloudDriveGroups) SetDriveId(v string) *DescribeCloudDriveGroupsResponseBodyCloudDriveGroups {
	s.DriveId = &v
	return s
}

func (s *DescribeCloudDriveGroupsResponseBodyCloudDriveGroups) SetGroupId(v string) *DescribeCloudDriveGroupsResponseBodyCloudDriveGroups {
	s.GroupId = &v
	return s
}

func (s *DescribeCloudDriveGroupsResponseBodyCloudDriveGroups) SetGroupName(v string) *DescribeCloudDriveGroupsResponseBodyCloudDriveGroups {
	s.GroupName = &v
	return s
}

func (s *DescribeCloudDriveGroupsResponseBodyCloudDriveGroups) SetOrgId(v string) *DescribeCloudDriveGroupsResponseBodyCloudDriveGroups {
	s.OrgId = &v
	return s
}

func (s *DescribeCloudDriveGroupsResponseBodyCloudDriveGroups) SetStatus(v string) *DescribeCloudDriveGroupsResponseBodyCloudDriveGroups {
	s.Status = &v
	return s
}

func (s *DescribeCloudDriveGroupsResponseBodyCloudDriveGroups) SetTotalSize(v int64) *DescribeCloudDriveGroupsResponseBodyCloudDriveGroups {
	s.TotalSize = &v
	return s
}

func (s *DescribeCloudDriveGroupsResponseBodyCloudDriveGroups) SetUsedSize(v string) *DescribeCloudDriveGroupsResponseBodyCloudDriveGroups {
	s.UsedSize = &v
	return s
}

type DescribeCloudDriveGroupsResponseBodyCloudDriveGroupsAdminUserInfos struct {
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	NickName  *string `json:"NickName,omitempty" xml:"NickName,omitempty"`
}

func (s DescribeCloudDriveGroupsResponseBodyCloudDriveGroupsAdminUserInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeCloudDriveGroupsResponseBodyCloudDriveGroupsAdminUserInfos) GoString() string {
	return s.String()
}

func (s *DescribeCloudDriveGroupsResponseBodyCloudDriveGroupsAdminUserInfos) SetEndUserId(v string) *DescribeCloudDriveGroupsResponseBodyCloudDriveGroupsAdminUserInfos {
	s.EndUserId = &v
	return s
}

func (s *DescribeCloudDriveGroupsResponseBodyCloudDriveGroupsAdminUserInfos) SetNickName(v string) *DescribeCloudDriveGroupsResponseBodyCloudDriveGroupsAdminUserInfos {
	s.NickName = &v
	return s
}

type DescribeCloudDriveGroupsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCloudDriveGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCloudDriveGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCloudDriveGroupsResponse) GoString() string {
	return s.String()
}

func (s *DescribeCloudDriveGroupsResponse) SetHeaders(v map[string]*string) *DescribeCloudDriveGroupsResponse {
	s.Headers = v
	return s
}

func (s *DescribeCloudDriveGroupsResponse) SetStatusCode(v int32) *DescribeCloudDriveGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCloudDriveGroupsResponse) SetBody(v *DescribeCloudDriveGroupsResponseBody) *DescribeCloudDriveGroupsResponse {
	s.Body = v
	return s
}

type DescribeCloudDrivePermissionsRequest struct {
	CdsId    *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeCloudDrivePermissionsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCloudDrivePermissionsRequest) GoString() string {
	return s.String()
}

func (s *DescribeCloudDrivePermissionsRequest) SetCdsId(v string) *DescribeCloudDrivePermissionsRequest {
	s.CdsId = &v
	return s
}

func (s *DescribeCloudDrivePermissionsRequest) SetRegionId(v string) *DescribeCloudDrivePermissionsRequest {
	s.RegionId = &v
	return s
}

type DescribeCloudDrivePermissionsResponseBody struct {
	CloudDrivePermissionModels []*DescribeCloudDrivePermissionsResponseBodyCloudDrivePermissionModels `json:"CloudDrivePermissionModels,omitempty" xml:"CloudDrivePermissionModels,omitempty" type:"Repeated"`
	RequestId                  *string                                                                `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCloudDrivePermissionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCloudDrivePermissionsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCloudDrivePermissionsResponseBody) SetCloudDrivePermissionModels(v []*DescribeCloudDrivePermissionsResponseBodyCloudDrivePermissionModels) *DescribeCloudDrivePermissionsResponseBody {
	s.CloudDrivePermissionModels = v
	return s
}

func (s *DescribeCloudDrivePermissionsResponseBody) SetRequestId(v string) *DescribeCloudDrivePermissionsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCloudDrivePermissionsResponseBodyCloudDrivePermissionModels struct {
	EndUsers   []*string `json:"EndUsers,omitempty" xml:"EndUsers,omitempty" type:"Repeated"`
	Permission *string   `json:"Permission,omitempty" xml:"Permission,omitempty"`
}

func (s DescribeCloudDrivePermissionsResponseBodyCloudDrivePermissionModels) String() string {
	return tea.Prettify(s)
}

func (s DescribeCloudDrivePermissionsResponseBodyCloudDrivePermissionModels) GoString() string {
	return s.String()
}

func (s *DescribeCloudDrivePermissionsResponseBodyCloudDrivePermissionModels) SetEndUsers(v []*string) *DescribeCloudDrivePermissionsResponseBodyCloudDrivePermissionModels {
	s.EndUsers = v
	return s
}

func (s *DescribeCloudDrivePermissionsResponseBodyCloudDrivePermissionModels) SetPermission(v string) *DescribeCloudDrivePermissionsResponseBodyCloudDrivePermissionModels {
	s.Permission = &v
	return s
}

type DescribeCloudDrivePermissionsResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCloudDrivePermissionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCloudDrivePermissionsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCloudDrivePermissionsResponse) GoString() string {
	return s.String()
}

func (s *DescribeCloudDrivePermissionsResponse) SetHeaders(v map[string]*string) *DescribeCloudDrivePermissionsResponse {
	s.Headers = v
	return s
}

func (s *DescribeCloudDrivePermissionsResponse) SetStatusCode(v int32) *DescribeCloudDrivePermissionsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCloudDrivePermissionsResponse) SetBody(v *DescribeCloudDrivePermissionsResponseBody) *DescribeCloudDrivePermissionsResponse {
	s.Body = v
	return s
}

type DescribeCloudDriveUsersRequest struct {
	CdsId      *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	EndUserId  *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	MaxResults *int32  `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	NextToken  *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	RegionId   *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeCloudDriveUsersRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCloudDriveUsersRequest) GoString() string {
	return s.String()
}

func (s *DescribeCloudDriveUsersRequest) SetCdsId(v string) *DescribeCloudDriveUsersRequest {
	s.CdsId = &v
	return s
}

func (s *DescribeCloudDriveUsersRequest) SetEndUserId(v string) *DescribeCloudDriveUsersRequest {
	s.EndUserId = &v
	return s
}

func (s *DescribeCloudDriveUsersRequest) SetMaxResults(v int32) *DescribeCloudDriveUsersRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeCloudDriveUsersRequest) SetNextToken(v string) *DescribeCloudDriveUsersRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeCloudDriveUsersRequest) SetRegionId(v string) *DescribeCloudDriveUsersRequest {
	s.RegionId = &v
	return s
}

type DescribeCloudDriveUsersResponseBody struct {
	CloudDriveUsers []*DescribeCloudDriveUsersResponseBodyCloudDriveUsers `json:"CloudDriveUsers,omitempty" xml:"CloudDriveUsers,omitempty" type:"Repeated"`
	NextToken       *string                                               `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	RequestId       *string                                               `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCloudDriveUsersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCloudDriveUsersResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCloudDriveUsersResponseBody) SetCloudDriveUsers(v []*DescribeCloudDriveUsersResponseBodyCloudDriveUsers) *DescribeCloudDriveUsersResponseBody {
	s.CloudDriveUsers = v
	return s
}

func (s *DescribeCloudDriveUsersResponseBody) SetNextToken(v string) *DescribeCloudDriveUsersResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeCloudDriveUsersResponseBody) SetRequestId(v string) *DescribeCloudDriveUsersResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCloudDriveUsersResponseBodyCloudDriveUsers struct {
	DriveId   *string `json:"DriveId,omitempty" xml:"DriveId,omitempty"`
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	Status    *string `json:"Status,omitempty" xml:"Status,omitempty"`
	TotalSize *int64  `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
	UsedSize  *int64  `json:"UsedSize,omitempty" xml:"UsedSize,omitempty"`
	UserId    *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	UserName  *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
}

func (s DescribeCloudDriveUsersResponseBodyCloudDriveUsers) String() string {
	return tea.Prettify(s)
}

func (s DescribeCloudDriveUsersResponseBodyCloudDriveUsers) GoString() string {
	return s.String()
}

func (s *DescribeCloudDriveUsersResponseBodyCloudDriveUsers) SetDriveId(v string) *DescribeCloudDriveUsersResponseBodyCloudDriveUsers {
	s.DriveId = &v
	return s
}

func (s *DescribeCloudDriveUsersResponseBodyCloudDriveUsers) SetEndUserId(v string) *DescribeCloudDriveUsersResponseBodyCloudDriveUsers {
	s.EndUserId = &v
	return s
}

func (s *DescribeCloudDriveUsersResponseBodyCloudDriveUsers) SetStatus(v string) *DescribeCloudDriveUsersResponseBodyCloudDriveUsers {
	s.Status = &v
	return s
}

func (s *DescribeCloudDriveUsersResponseBodyCloudDriveUsers) SetTotalSize(v int64) *DescribeCloudDriveUsersResponseBodyCloudDriveUsers {
	s.TotalSize = &v
	return s
}

func (s *DescribeCloudDriveUsersResponseBodyCloudDriveUsers) SetUsedSize(v int64) *DescribeCloudDriveUsersResponseBodyCloudDriveUsers {
	s.UsedSize = &v
	return s
}

func (s *DescribeCloudDriveUsersResponseBodyCloudDriveUsers) SetUserId(v string) *DescribeCloudDriveUsersResponseBodyCloudDriveUsers {
	s.UserId = &v
	return s
}

func (s *DescribeCloudDriveUsersResponseBodyCloudDriveUsers) SetUserName(v string) *DescribeCloudDriveUsersResponseBodyCloudDriveUsers {
	s.UserName = &v
	return s
}

type DescribeCloudDriveUsersResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCloudDriveUsersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCloudDriveUsersResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCloudDriveUsersResponse) GoString() string {
	return s.String()
}

func (s *DescribeCloudDriveUsersResponse) SetHeaders(v map[string]*string) *DescribeCloudDriveUsersResponse {
	s.Headers = v
	return s
}

func (s *DescribeCloudDriveUsersResponse) SetStatusCode(v int32) *DescribeCloudDriveUsersResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCloudDriveUsersResponse) SetBody(v *DescribeCloudDriveUsersResponseBody) *DescribeCloudDriveUsersResponse {
	s.Body = v
	return s
}

type DescribeCustomizedListHeadersRequest struct {
	LangType *string `json:"LangType,omitempty" xml:"LangType,omitempty"`
	ListType *string `json:"ListType,omitempty" xml:"ListType,omitempty"`
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeCustomizedListHeadersRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomizedListHeadersRequest) GoString() string {
	return s.String()
}

func (s *DescribeCustomizedListHeadersRequest) SetLangType(v string) *DescribeCustomizedListHeadersRequest {
	s.LangType = &v
	return s
}

func (s *DescribeCustomizedListHeadersRequest) SetListType(v string) *DescribeCustomizedListHeadersRequest {
	s.ListType = &v
	return s
}

func (s *DescribeCustomizedListHeadersRequest) SetRegionId(v string) *DescribeCustomizedListHeadersRequest {
	s.RegionId = &v
	return s
}

type DescribeCustomizedListHeadersResponseBody struct {
	Headers   []*DescribeCustomizedListHeadersResponseBodyHeaders `json:"Headers,omitempty" xml:"Headers,omitempty" type:"Repeated"`
	RequestId *string                                             `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCustomizedListHeadersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomizedListHeadersResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCustomizedListHeadersResponseBody) SetHeaders(v []*DescribeCustomizedListHeadersResponseBodyHeaders) *DescribeCustomizedListHeadersResponseBody {
	s.Headers = v
	return s
}

func (s *DescribeCustomizedListHeadersResponseBody) SetRequestId(v string) *DescribeCustomizedListHeadersResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCustomizedListHeadersResponseBodyHeaders struct {
	DisplayType *string `json:"DisplayType,omitempty" xml:"DisplayType,omitempty"`
	HeaderKey   *string `json:"HeaderKey,omitempty" xml:"HeaderKey,omitempty"`
	HeaderName  *string `json:"HeaderName,omitempty" xml:"HeaderName,omitempty"`
}

func (s DescribeCustomizedListHeadersResponseBodyHeaders) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomizedListHeadersResponseBodyHeaders) GoString() string {
	return s.String()
}

func (s *DescribeCustomizedListHeadersResponseBodyHeaders) SetDisplayType(v string) *DescribeCustomizedListHeadersResponseBodyHeaders {
	s.DisplayType = &v
	return s
}

func (s *DescribeCustomizedListHeadersResponseBodyHeaders) SetHeaderKey(v string) *DescribeCustomizedListHeadersResponseBodyHeaders {
	s.HeaderKey = &v
	return s
}

func (s *DescribeCustomizedListHeadersResponseBodyHeaders) SetHeaderName(v string) *DescribeCustomizedListHeadersResponseBodyHeaders {
	s.HeaderName = &v
	return s
}

type DescribeCustomizedListHeadersResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCustomizedListHeadersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCustomizedListHeadersResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomizedListHeadersResponse) GoString() string {
	return s.String()
}

func (s *DescribeCustomizedListHeadersResponse) SetHeaders(v map[string]*string) *DescribeCustomizedListHeadersResponse {
	s.Headers = v
	return s
}

func (s *DescribeCustomizedListHeadersResponse) SetStatusCode(v int32) *DescribeCustomizedListHeadersResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCustomizedListHeadersResponse) SetBody(v *DescribeCustomizedListHeadersResponseBody) *DescribeCustomizedListHeadersResponse {
	s.Body = v
	return s
}

type DescribeDesktopGroupsRequest struct {
	// The IDs of the desktop templates.
	BundleId []*string `json:"BundleId,omitempty" xml:"BundleId,omitempty" type:"Repeated"`
	// The desktop group ID.
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// The name of the desktop group that you want to query. Fuzzy search is supported.
	DesktopGroupName *string `json:"DesktopGroupName,omitempty" xml:"DesktopGroupName,omitempty"`
	// The authorized users.
	EndUserIds []*string `json:"EndUserIds,omitempty" xml:"EndUserIds,omitempty" type:"Repeated"`
	// The authorized users that you want to exclude.
	ExcludedEndUserIds []*string `json:"ExcludedEndUserIds,omitempty" xml:"ExcludedEndUserIds,omitempty" type:"Repeated"`
	// The IDs of the images.
	ImageId []*string `json:"ImageId,omitempty" xml:"ImageId,omitempty" type:"Repeated"`
	// The number of entries to return on each page. Valid values: 1 to 100. Default value: 10.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. If the NextToken parameter is empty, no next page exists.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The workspace ID of the desktop group that you want to query.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The desktop group type.
	//
	// Valid values:
	//
	// *   0
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     personal desktop group
	//
	//     <!-- -->
	//
	// *   1
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     shared desktop group (multi-session)
	//
	//     <!-- -->
	OwnType *int64 `json:"OwnType,omitempty" xml:"OwnType,omitempty"`
	// The validity period of the desktop group. The unit is specified by the PeriodUnit parameter.
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The unit of the duration.
	//
	// Valid values:
	//
	// *   Month
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Year
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Day
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	PeriodUnit *string `json:"PeriodUnit,omitempty" xml:"PeriodUnit,omitempty"`
	// The ID of the policy with which the desktop group is associated.
	PolicyGroupId *string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty"`
	// The protocol. Valid values:
	//
	// *   ASP
	// *   HDX
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The payment status of the desktop group.
	//
	// Valid values:
	//
	// *   0
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     unpaid
	//
	//     <!-- -->
	//
	// *   1
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     paid
	//
	//     <!-- -->
	//
	// *   2
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     overdue or expired
	//
	//     <!-- -->
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeDesktopGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopGroupsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDesktopGroupsRequest) SetBundleId(v []*string) *DescribeDesktopGroupsRequest {
	s.BundleId = v
	return s
}

func (s *DescribeDesktopGroupsRequest) SetDesktopGroupId(v string) *DescribeDesktopGroupsRequest {
	s.DesktopGroupId = &v
	return s
}

func (s *DescribeDesktopGroupsRequest) SetDesktopGroupName(v string) *DescribeDesktopGroupsRequest {
	s.DesktopGroupName = &v
	return s
}

func (s *DescribeDesktopGroupsRequest) SetEndUserIds(v []*string) *DescribeDesktopGroupsRequest {
	s.EndUserIds = v
	return s
}

func (s *DescribeDesktopGroupsRequest) SetExcludedEndUserIds(v []*string) *DescribeDesktopGroupsRequest {
	s.ExcludedEndUserIds = v
	return s
}

func (s *DescribeDesktopGroupsRequest) SetImageId(v []*string) *DescribeDesktopGroupsRequest {
	s.ImageId = v
	return s
}

func (s *DescribeDesktopGroupsRequest) SetMaxResults(v int32) *DescribeDesktopGroupsRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeDesktopGroupsRequest) SetNextToken(v string) *DescribeDesktopGroupsRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeDesktopGroupsRequest) SetOfficeSiteId(v string) *DescribeDesktopGroupsRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *DescribeDesktopGroupsRequest) SetOwnType(v int64) *DescribeDesktopGroupsRequest {
	s.OwnType = &v
	return s
}

func (s *DescribeDesktopGroupsRequest) SetPeriod(v int32) *DescribeDesktopGroupsRequest {
	s.Period = &v
	return s
}

func (s *DescribeDesktopGroupsRequest) SetPeriodUnit(v string) *DescribeDesktopGroupsRequest {
	s.PeriodUnit = &v
	return s
}

func (s *DescribeDesktopGroupsRequest) SetPolicyGroupId(v string) *DescribeDesktopGroupsRequest {
	s.PolicyGroupId = &v
	return s
}

func (s *DescribeDesktopGroupsRequest) SetProtocolType(v string) *DescribeDesktopGroupsRequest {
	s.ProtocolType = &v
	return s
}

func (s *DescribeDesktopGroupsRequest) SetRegionId(v string) *DescribeDesktopGroupsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeDesktopGroupsRequest) SetStatus(v int32) *DescribeDesktopGroupsRequest {
	s.Status = &v
	return s
}

type DescribeDesktopGroupsResponseBody struct {
	// Details of the desktop groups.
	DesktopGroups []*DescribeDesktopGroupsResponseBodyDesktopGroups `json:"DesktopGroups,omitempty" xml:"DesktopGroups,omitempty" type:"Repeated"`
	// The returned value of NextToken is a pagination token, which can be used in the next request to retrieve a new page of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDesktopGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDesktopGroupsResponseBody) SetDesktopGroups(v []*DescribeDesktopGroupsResponseBodyDesktopGroups) *DescribeDesktopGroupsResponseBody {
	s.DesktopGroups = v
	return s
}

func (s *DescribeDesktopGroupsResponseBody) SetNextToken(v string) *DescribeDesktopGroupsResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBody) SetRequestId(v string) *DescribeDesktopGroupsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDesktopGroupsResponseBodyDesktopGroups struct {
	// The number of sessions that are allowed for each cloud desktop in the multi-session desktop group.
	BindAmount *int64 `json:"BindAmount,omitempty" xml:"BindAmount,omitempty"`
	// The number of purchased cloud desktops. Valid values: 0 to 200.
	BuyDesktopsCount *int32 `json:"BuyDesktopsCount,omitempty" xml:"BuyDesktopsCount,omitempty"`
	// The remarks of the desktop group.
	Comments *string `json:"Comments,omitempty" xml:"Comments,omitempty"`
	// The maximum period of time during which the session is connected. When the specified maximum period of time is reached, the session is automatically disconnected. Unit: milliseconds. This parameter is required only for cloud desktops of the same desktop group.
	ConnectDuration *int64                                                          `json:"ConnectDuration,omitempty" xml:"ConnectDuration,omitempty"`
	CountPerStatus  []*DescribeDesktopGroupsResponseBodyDesktopGroupsCountPerStatus `json:"CountPerStatus,omitempty" xml:"CountPerStatus,omitempty" type:"Repeated"`
	// The number of vCPUs.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The time when the desktop group was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the Alibaba Cloud account that is used to create the desktop group.
	Creator *string `json:"Creator,omitempty" xml:"Creator,omitempty"`
	// The category of the data disk.
	//
	// Valid values:
	//
	// *   cloud_efficiency
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     ultra disk
	//
	//     <!-- -->
	//
	// *   cloud_ssd
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     standard SSD
	//
	//     <!-- -->
	//
	// *   cloud_essd
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     ESSD
	//
	//     <!-- -->
	DataDiskCategory *string `json:"DataDiskCategory,omitempty" xml:"DataDiskCategory,omitempty"`
	// The size of the data disk. Unit: GiB.
	DataDiskSize *string `json:"DataDiskSize,omitempty" xml:"DataDiskSize,omitempty"`
	DesktopCount *int32  `json:"DesktopCount,omitempty" xml:"DesktopCount,omitempty"`
	// The ID of the desktop group.
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// The name of the desktop group.
	DesktopGroupName *string `json:"DesktopGroupName,omitempty" xml:"DesktopGroupName,omitempty"`
	DesktopType      *string `json:"DesktopType,omitempty" xml:"DesktopType,omitempty"`
	// The number of end users that are authorized to use the desktop group.
	EndUserCount *int32 `json:"EndUserCount,omitempty" xml:"EndUserCount,omitempty"`
	// The time when the subscription cloud desktop expires.
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The number of GPUs.
	GpuCount         *float32 `json:"GpuCount,omitempty" xml:"GpuCount,omitempty"`
	GpuDriverVersion *string  `json:"GpuDriverVersion,omitempty" xml:"GpuDriverVersion,omitempty"`
	// The GPU memory.
	GpuSpec *string `json:"GpuSpec,omitempty" xml:"GpuSpec,omitempty"`
	// The maximum period of time during which the session is idle. When a session is idle, no inputs of keyboards or mouses are detected. When the specified maximum period of time is reached, the session is automatically disconnected. Unit: milliseconds. This parameter is required only for cloud desktops of the same desktop group.
	IdleDisconnectDuration *int64 `json:"IdleDisconnectDuration,omitempty" xml:"IdleDisconnectDuration,omitempty"`
	// The ID of the image.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The retention period of the cloud desktop after the end user is disconnected from the cloud desktop. Unit: milliseconds.
	KeepDuration *int64 `json:"KeepDuration,omitempty" xml:"KeepDuration,omitempty"`
	// The load balancing policy of the multi-session desktop group.
	//
	// Valid values:
	//
	// *   0
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     depth first
	//
	//     <!-- -->
	//
	// *   1
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     breadth first
	//
	//     <!-- -->
	LoadPolicy *int64 `json:"LoadPolicy,omitempty" xml:"LoadPolicy,omitempty"`
	// The maximum number of cloud desktops that the desktop group can contain.
	MaxDesktopsCount *int32 `json:"MaxDesktopsCount,omitempty" xml:"MaxDesktopsCount,omitempty"`
	// The memory size. Unit: MiB.
	Memory *int64 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The minimum number of cloud desktops that the desktop group must contain.
	MinDesktopsCount *int32 `json:"MinDesktopsCount,omitempty" xml:"MinDesktopsCount,omitempty"`
	// The ID of the workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The name of the workspace.
	OfficeSiteName *string `json:"OfficeSiteName,omitempty" xml:"OfficeSiteName,omitempty"`
	// The account type of the workspace. Possible values: -simple: convenience account type. -ad_connector: enterprise Active Directory (AD) account.
	//
	// Valid values:
	//
	// *   PERSONAL
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     personal account type
	//
	//     <!-- -->
	//
	//     .
	//
	// *   SIMPLE
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     convenience account type
	//
	//     <!-- -->
	//
	//     .
	//
	// *   AD_CONNECTOR:
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     enterprise AD account type
	//
	//     <!-- -->
	//
	// *   RAM
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     Resource Access Management (RAM) account type
	//
	//     <!-- -->
	//
	//     .
	OfficeSiteType *string `json:"OfficeSiteType,omitempty" xml:"OfficeSiteType,omitempty"`
	// The OS. Valid values:
	//
	// *   Windows
	// *   Linux
	OsType *string `json:"OsType,omitempty" xml:"OsType,omitempty"`
	// The ID of the desktop template.
	OwnBundleId *string `json:"OwnBundleId,omitempty" xml:"OwnBundleId,omitempty"`
	// The name of the desktop template.
	OwnBundleName *string `json:"OwnBundleName,omitempty" xml:"OwnBundleName,omitempty"`
	// The type of the desktop group.
	//
	// Valid values:
	//
	// *   0
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     personal desktop group
	//
	//     <!-- -->
	//
	// *   1
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     shared desktop group (multi-session)
	//
	//     <!-- -->
	OwnType *int64 `json:"OwnType,omitempty" xml:"OwnType,omitempty"`
	// The billing method of the desktop group.
	//
	// Valid values:
	//
	// *   PostPaid
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     pay-as-you-go
	//
	//     <!-- -->
	//
	//     .
	//
	// *   PrePaid
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     subscription
	//
	//     <!-- -->
	//
	//     .
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The ID of the policy.
	PolicyGroupId *string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty"`
	// The name of the policy.
	PolicyGroupName *string `json:"PolicyGroupName,omitempty" xml:"PolicyGroupName,omitempty"`
	// The type of the protocol. Valid values:
	//
	// *   ASP
	// *   HDX
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The threshold for the ratio of connected sessions. This parameter is the condition that triggers auto scaling in a multi-session desktop group. `Ratio of connected sessions = Number of connected sessions/(Total number of cloud desktops  Maximum number of sessions allowed for each cloud desktop)  100%`. When the specified threshold is reached, new cloud desktops are automatically created. When the specified threshold is not reached, idle cloud desktops are released.
	RatioThreshold *float32 `json:"RatioThreshold,omitempty" xml:"RatioThreshold,omitempty"`
	// Indicates which type of disk that is used by cloud desktops in the desktop group is reset.
	//
	// Valid values:
	//
	// *   0
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     No disks are reset.
	//
	//     <!-- -->
	//
	// *   1
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     Only the system disk is reset.
	//
	//     <!-- -->
	//
	// *   2
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     Only the data disk is reset.
	//
	//     <!-- -->
	//
	// *   3
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     Both the system disk and data disk are reset.
	//
	//     <!-- -->
	ResetType *int64 `json:"ResetType,omitempty" xml:"ResetType,omitempty"`
	// The payment status of the desktop group.
	//
	// Valid values:
	//
	// *   0
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     unpaid
	//
	//     <!-- -->
	//
	// *   1
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     paid
	//
	//     <!-- -->
	//
	// *   2
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     overdue or expired
	//
	//     <!-- -->
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The period of time before the idle cloud desktop enters the Stopped state. When the specified period of time is reached, the idle cloud desktop automatically enters the Stopped state. If an end user connects to a cloud desktop that is in the Stopped state, the cloud desktop automatically starts. Unit: milliseconds.
	StopDuration *int64  `json:"StopDuration,omitempty" xml:"StopDuration,omitempty"`
	SubnetId     *string `json:"SubnetId,omitempty" xml:"SubnetId,omitempty"`
	// The category of the system disk.
	//
	// Valid values:
	//
	// *   cloud_efficiency
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     ultra disk
	//
	//     <!-- -->
	//
	// *   cloud_ssd
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     standard SSD
	//
	//     <!-- -->
	//
	// *   cloud_essd
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     ESSD
	//
	//     <!-- -->
	SystemDiskCategory *string `json:"SystemDiskCategory,omitempty" xml:"SystemDiskCategory,omitempty"`
	// The size of the system disk. Unit: GiB.
	SystemDiskSize *int32 `json:"SystemDiskSize,omitempty" xml:"SystemDiskSize,omitempty"`
	// The version number of the desktop group.
	Version *int32 `json:"Version,omitempty" xml:"Version,omitempty"`
	// Indicates whether disk encryption is enabled.
	VolumeEncryptionEnabled *bool `json:"VolumeEncryptionEnabled,omitempty" xml:"VolumeEncryptionEnabled,omitempty"`
	// The ID of the Key Management Service (KMS) key for disk encryption.
	VolumeEncryptionKey *string `json:"VolumeEncryptionKey,omitempty" xml:"VolumeEncryptionKey,omitempty"`
}

func (s DescribeDesktopGroupsResponseBodyDesktopGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopGroupsResponseBodyDesktopGroups) GoString() string {
	return s.String()
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetBindAmount(v int64) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.BindAmount = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetBuyDesktopsCount(v int32) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.BuyDesktopsCount = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetComments(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.Comments = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetConnectDuration(v int64) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.ConnectDuration = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetCountPerStatus(v []*DescribeDesktopGroupsResponseBodyDesktopGroupsCountPerStatus) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.CountPerStatus = v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetCpu(v int32) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.Cpu = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetCreateTime(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.CreateTime = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetCreator(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.Creator = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetDataDiskCategory(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.DataDiskCategory = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetDataDiskSize(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.DataDiskSize = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetDesktopCount(v int32) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.DesktopCount = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetDesktopGroupId(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.DesktopGroupId = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetDesktopGroupName(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.DesktopGroupName = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetDesktopType(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.DesktopType = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetEndUserCount(v int32) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.EndUserCount = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetExpiredTime(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.ExpiredTime = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetGpuCount(v float32) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.GpuCount = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetGpuDriverVersion(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.GpuDriverVersion = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetGpuSpec(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.GpuSpec = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetIdleDisconnectDuration(v int64) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.IdleDisconnectDuration = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetImageId(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.ImageId = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetKeepDuration(v int64) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.KeepDuration = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetLoadPolicy(v int64) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.LoadPolicy = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetMaxDesktopsCount(v int32) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.MaxDesktopsCount = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetMemory(v int64) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.Memory = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetMinDesktopsCount(v int32) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.MinDesktopsCount = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetOfficeSiteId(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.OfficeSiteId = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetOfficeSiteName(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.OfficeSiteName = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetOfficeSiteType(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.OfficeSiteType = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetOsType(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.OsType = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetOwnBundleId(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.OwnBundleId = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetOwnBundleName(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.OwnBundleName = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetOwnType(v int64) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.OwnType = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetPayType(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.PayType = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetPolicyGroupId(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.PolicyGroupId = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetPolicyGroupName(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.PolicyGroupName = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetProtocolType(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.ProtocolType = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetRatioThreshold(v float32) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.RatioThreshold = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetResetType(v int64) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.ResetType = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetStatus(v int32) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.Status = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetStopDuration(v int64) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.StopDuration = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetSubnetId(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.SubnetId = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetSystemDiskCategory(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.SystemDiskCategory = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetSystemDiskSize(v int32) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.SystemDiskSize = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetVersion(v int32) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.Version = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetVolumeEncryptionEnabled(v bool) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.VolumeEncryptionEnabled = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroups) SetVolumeEncryptionKey(v string) *DescribeDesktopGroupsResponseBodyDesktopGroups {
	s.VolumeEncryptionKey = &v
	return s
}

type DescribeDesktopGroupsResponseBodyDesktopGroupsCountPerStatus struct {
	Count  *int32  `json:"Count,omitempty" xml:"Count,omitempty"`
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeDesktopGroupsResponseBodyDesktopGroupsCountPerStatus) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopGroupsResponseBodyDesktopGroupsCountPerStatus) GoString() string {
	return s.String()
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroupsCountPerStatus) SetCount(v int32) *DescribeDesktopGroupsResponseBodyDesktopGroupsCountPerStatus {
	s.Count = &v
	return s
}

func (s *DescribeDesktopGroupsResponseBodyDesktopGroupsCountPerStatus) SetStatus(v string) *DescribeDesktopGroupsResponseBodyDesktopGroupsCountPerStatus {
	s.Status = &v
	return s
}

type DescribeDesktopGroupsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDesktopGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDesktopGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopGroupsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDesktopGroupsResponse) SetHeaders(v map[string]*string) *DescribeDesktopGroupsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDesktopGroupsResponse) SetStatusCode(v int32) *DescribeDesktopGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDesktopGroupsResponse) SetBody(v *DescribeDesktopGroupsResponseBody) *DescribeDesktopGroupsResponse {
	s.Body = v
	return s
}

type DescribeDesktopInfoRequest struct {
	// The cloud desktop ID. You can specify 1 to 100 cloud desktop IDs.
	DesktopId []*string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty" type:"Repeated"`
	// The region ID. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeDesktopInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribeDesktopInfoRequest) SetDesktopId(v []*string) *DescribeDesktopInfoRequest {
	s.DesktopId = v
	return s
}

func (s *DescribeDesktopInfoRequest) SetRegionId(v string) *DescribeDesktopInfoRequest {
	s.RegionId = &v
	return s
}

type DescribeDesktopInfoResponseBody struct {
	// The details about the cloud desktops.
	Desktops []*DescribeDesktopInfoResponseBodyDesktops `json:"Desktops,omitempty" xml:"Desktops,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDesktopInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDesktopInfoResponseBody) SetDesktops(v []*DescribeDesktopInfoResponseBodyDesktops) *DescribeDesktopInfoResponseBody {
	s.Desktops = v
	return s
}

func (s *DescribeDesktopInfoResponseBody) SetRequestId(v string) *DescribeDesktopInfoResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDesktopInfoResponseBodyDesktops struct {
	// The connection status of the end user. Valid values:
	//
	// *   Connected
	// *   Disconnected
	ConnectionStatus *string `json:"ConnectionStatus,omitempty" xml:"ConnectionStatus,omitempty"`
	// The current version of the cloud desktop.
	CurrentAppVersion *string `json:"CurrentAppVersion,omitempty" xml:"CurrentAppVersion,omitempty"`
	// The cloud desktop ID.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The status of the cloud desktop. Valid values:
	//
	// *   Pending
	// *   Starting
	// *   Running
	// *   Stopping
	// *   Stopped
	// *   Expired
	// *   Deleted
	// *   Failed
	DesktopStatus *string `json:"DesktopStatus,omitempty" xml:"DesktopStatus,omitempty"`
	// The flag that is used to manage the cloud desktop.
	ManagementFlag []*string `json:"ManagementFlag,omitempty" xml:"ManagementFlag,omitempty" type:"Repeated"`
	NewAppSize     *int64    `json:"NewAppSize,omitempty" xml:"NewAppSize,omitempty"`
	NewAppVersion  *string   `json:"NewAppVersion,omitempty" xml:"NewAppVersion,omitempty"`
	ReleaseNote    *string   `json:"ReleaseNote,omitempty" xml:"ReleaseNote,omitempty"`
	// The first time when the cloud desktop was started.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDesktopInfoResponseBodyDesktops) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopInfoResponseBodyDesktops) GoString() string {
	return s.String()
}

func (s *DescribeDesktopInfoResponseBodyDesktops) SetConnectionStatus(v string) *DescribeDesktopInfoResponseBodyDesktops {
	s.ConnectionStatus = &v
	return s
}

func (s *DescribeDesktopInfoResponseBodyDesktops) SetCurrentAppVersion(v string) *DescribeDesktopInfoResponseBodyDesktops {
	s.CurrentAppVersion = &v
	return s
}

func (s *DescribeDesktopInfoResponseBodyDesktops) SetDesktopId(v string) *DescribeDesktopInfoResponseBodyDesktops {
	s.DesktopId = &v
	return s
}

func (s *DescribeDesktopInfoResponseBodyDesktops) SetDesktopStatus(v string) *DescribeDesktopInfoResponseBodyDesktops {
	s.DesktopStatus = &v
	return s
}

func (s *DescribeDesktopInfoResponseBodyDesktops) SetManagementFlag(v []*string) *DescribeDesktopInfoResponseBodyDesktops {
	s.ManagementFlag = v
	return s
}

func (s *DescribeDesktopInfoResponseBodyDesktops) SetNewAppSize(v int64) *DescribeDesktopInfoResponseBodyDesktops {
	s.NewAppSize = &v
	return s
}

func (s *DescribeDesktopInfoResponseBodyDesktops) SetNewAppVersion(v string) *DescribeDesktopInfoResponseBodyDesktops {
	s.NewAppVersion = &v
	return s
}

func (s *DescribeDesktopInfoResponseBodyDesktops) SetReleaseNote(v string) *DescribeDesktopInfoResponseBodyDesktops {
	s.ReleaseNote = &v
	return s
}

func (s *DescribeDesktopInfoResponseBodyDesktops) SetStartTime(v string) *DescribeDesktopInfoResponseBodyDesktops {
	s.StartTime = &v
	return s
}

type DescribeDesktopInfoResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDesktopInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDesktopInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeDesktopInfoResponse) SetHeaders(v map[string]*string) *DescribeDesktopInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeDesktopInfoResponse) SetStatusCode(v int32) *DescribeDesktopInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDesktopInfoResponse) SetBody(v *DescribeDesktopInfoResponseBody) *DescribeDesktopInfoResponse {
	s.Body = v
	return s
}

type DescribeDesktopOversoldGroupRequest struct {
	MaxResults       *int32    `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	NextToken        *string   `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OversoldGroupIds []*string `json:"OversoldGroupIds,omitempty" xml:"OversoldGroupIds,omitempty" type:"Repeated"`
}

func (s DescribeDesktopOversoldGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopOversoldGroupRequest) GoString() string {
	return s.String()
}

func (s *DescribeDesktopOversoldGroupRequest) SetMaxResults(v int32) *DescribeDesktopOversoldGroupRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeDesktopOversoldGroupRequest) SetNextToken(v string) *DescribeDesktopOversoldGroupRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeDesktopOversoldGroupRequest) SetOversoldGroupIds(v []*string) *DescribeDesktopOversoldGroupRequest {
	s.OversoldGroupIds = v
	return s
}

type DescribeDesktopOversoldGroupResponseBody struct {
	Count     *int32                                          `json:"Count,omitempty" xml:"Count,omitempty"`
	Data      []*DescribeDesktopOversoldGroupResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	NextToken *string                                         `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	RequestId *string                                         `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDesktopOversoldGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopOversoldGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDesktopOversoldGroupResponseBody) SetCount(v int32) *DescribeDesktopOversoldGroupResponseBody {
	s.Count = &v
	return s
}

func (s *DescribeDesktopOversoldGroupResponseBody) SetData(v []*DescribeDesktopOversoldGroupResponseBodyData) *DescribeDesktopOversoldGroupResponseBody {
	s.Data = v
	return s
}

func (s *DescribeDesktopOversoldGroupResponseBody) SetNextToken(v string) *DescribeDesktopOversoldGroupResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeDesktopOversoldGroupResponseBody) SetRequestId(v string) *DescribeDesktopOversoldGroupResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDesktopOversoldGroupResponseBodyData struct {
	ConcurrenceCount    *int32  `json:"ConcurrenceCount,omitempty" xml:"ConcurrenceCount,omitempty"`
	CurConcurrenceCount *int32  `json:"CurConcurrenceCount,omitempty" xml:"CurConcurrenceCount,omitempty"`
	DataDiskSize        *int32  `json:"DataDiskSize,omitempty" xml:"DataDiskSize,omitempty"`
	Description         *string `json:"Description,omitempty" xml:"Description,omitempty"`
	DesktopType         *string `json:"DesktopType,omitempty" xml:"DesktopType,omitempty"`
	DirectoryId         *string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	ExpireTime          *string `json:"ExpireTime,omitempty" xml:"ExpireTime,omitempty"`
	ImageId             *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	Name                *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OversoldGroupId     *string `json:"OversoldGroupId,omitempty" xml:"OversoldGroupId,omitempty"`
	OversoldUserCount   *int32  `json:"OversoldUserCount,omitempty" xml:"OversoldUserCount,omitempty"`
	OversoldWarn        *int32  `json:"OversoldWarn,omitempty" xml:"OversoldWarn,omitempty"`
	PolicyGroupId       *string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty"`
	SaleStatus          *string `json:"SaleStatus,omitempty" xml:"SaleStatus,omitempty"`
	Status              *string `json:"Status,omitempty" xml:"Status,omitempty"`
	StopDuration        *int64  `json:"StopDuration,omitempty" xml:"StopDuration,omitempty"`
	SystemDiskSize      *int32  `json:"SystemDiskSize,omitempty" xml:"SystemDiskSize,omitempty"`
}

func (s DescribeDesktopOversoldGroupResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopOversoldGroupResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeDesktopOversoldGroupResponseBodyData) SetConcurrenceCount(v int32) *DescribeDesktopOversoldGroupResponseBodyData {
	s.ConcurrenceCount = &v
	return s
}

func (s *DescribeDesktopOversoldGroupResponseBodyData) SetCurConcurrenceCount(v int32) *DescribeDesktopOversoldGroupResponseBodyData {
	s.CurConcurrenceCount = &v
	return s
}

func (s *DescribeDesktopOversoldGroupResponseBodyData) SetDataDiskSize(v int32) *DescribeDesktopOversoldGroupResponseBodyData {
	s.DataDiskSize = &v
	return s
}

func (s *DescribeDesktopOversoldGroupResponseBodyData) SetDescription(v string) *DescribeDesktopOversoldGroupResponseBodyData {
	s.Description = &v
	return s
}

func (s *DescribeDesktopOversoldGroupResponseBodyData) SetDesktopType(v string) *DescribeDesktopOversoldGroupResponseBodyData {
	s.DesktopType = &v
	return s
}

func (s *DescribeDesktopOversoldGroupResponseBodyData) SetDirectoryId(v string) *DescribeDesktopOversoldGroupResponseBodyData {
	s.DirectoryId = &v
	return s
}

func (s *DescribeDesktopOversoldGroupResponseBodyData) SetExpireTime(v string) *DescribeDesktopOversoldGroupResponseBodyData {
	s.ExpireTime = &v
	return s
}

func (s *DescribeDesktopOversoldGroupResponseBodyData) SetImageId(v string) *DescribeDesktopOversoldGroupResponseBodyData {
	s.ImageId = &v
	return s
}

func (s *DescribeDesktopOversoldGroupResponseBodyData) SetName(v string) *DescribeDesktopOversoldGroupResponseBodyData {
	s.Name = &v
	return s
}

func (s *DescribeDesktopOversoldGroupResponseBodyData) SetOversoldGroupId(v string) *DescribeDesktopOversoldGroupResponseBodyData {
	s.OversoldGroupId = &v
	return s
}

func (s *DescribeDesktopOversoldGroupResponseBodyData) SetOversoldUserCount(v int32) *DescribeDesktopOversoldGroupResponseBodyData {
	s.OversoldUserCount = &v
	return s
}

func (s *DescribeDesktopOversoldGroupResponseBodyData) SetOversoldWarn(v int32) *DescribeDesktopOversoldGroupResponseBodyData {
	s.OversoldWarn = &v
	return s
}

func (s *DescribeDesktopOversoldGroupResponseBodyData) SetPolicyGroupId(v string) *DescribeDesktopOversoldGroupResponseBodyData {
	s.PolicyGroupId = &v
	return s
}

func (s *DescribeDesktopOversoldGroupResponseBodyData) SetSaleStatus(v string) *DescribeDesktopOversoldGroupResponseBodyData {
	s.SaleStatus = &v
	return s
}

func (s *DescribeDesktopOversoldGroupResponseBodyData) SetStatus(v string) *DescribeDesktopOversoldGroupResponseBodyData {
	s.Status = &v
	return s
}

func (s *DescribeDesktopOversoldGroupResponseBodyData) SetStopDuration(v int64) *DescribeDesktopOversoldGroupResponseBodyData {
	s.StopDuration = &v
	return s
}

func (s *DescribeDesktopOversoldGroupResponseBodyData) SetSystemDiskSize(v int32) *DescribeDesktopOversoldGroupResponseBodyData {
	s.SystemDiskSize = &v
	return s
}

type DescribeDesktopOversoldGroupResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDesktopOversoldGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDesktopOversoldGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopOversoldGroupResponse) GoString() string {
	return s.String()
}

func (s *DescribeDesktopOversoldGroupResponse) SetHeaders(v map[string]*string) *DescribeDesktopOversoldGroupResponse {
	s.Headers = v
	return s
}

func (s *DescribeDesktopOversoldGroupResponse) SetStatusCode(v int32) *DescribeDesktopOversoldGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDesktopOversoldGroupResponse) SetBody(v *DescribeDesktopOversoldGroupResponseBody) *DescribeDesktopOversoldGroupResponse {
	s.Body = v
	return s
}

type DescribeDesktopOversoldUserRequest struct {
	ClientToken     *string   `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	EndUserId       *string   `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	MaxResults      *int32    `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	NextToken       *string   `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OversoldGroupId *string   `json:"OversoldGroupId,omitempty" xml:"OversoldGroupId,omitempty"`
	UserDesktopIds  []*string `json:"UserDesktopIds,omitempty" xml:"UserDesktopIds,omitempty" type:"Repeated"`
	UserGroupId     *string   `json:"UserGroupId,omitempty" xml:"UserGroupId,omitempty"`
}

func (s DescribeDesktopOversoldUserRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopOversoldUserRequest) GoString() string {
	return s.String()
}

func (s *DescribeDesktopOversoldUserRequest) SetClientToken(v string) *DescribeDesktopOversoldUserRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeDesktopOversoldUserRequest) SetEndUserId(v string) *DescribeDesktopOversoldUserRequest {
	s.EndUserId = &v
	return s
}

func (s *DescribeDesktopOversoldUserRequest) SetMaxResults(v int32) *DescribeDesktopOversoldUserRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeDesktopOversoldUserRequest) SetNextToken(v string) *DescribeDesktopOversoldUserRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeDesktopOversoldUserRequest) SetOversoldGroupId(v string) *DescribeDesktopOversoldUserRequest {
	s.OversoldGroupId = &v
	return s
}

func (s *DescribeDesktopOversoldUserRequest) SetUserDesktopIds(v []*string) *DescribeDesktopOversoldUserRequest {
	s.UserDesktopIds = v
	return s
}

func (s *DescribeDesktopOversoldUserRequest) SetUserGroupId(v string) *DescribeDesktopOversoldUserRequest {
	s.UserGroupId = &v
	return s
}

type DescribeDesktopOversoldUserResponseBody struct {
	Count     *int32                                         `json:"Count,omitempty" xml:"Count,omitempty"`
	Data      []*DescribeDesktopOversoldUserResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	NextToken *string                                        `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	RequestId *string                                        `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDesktopOversoldUserResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopOversoldUserResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDesktopOversoldUserResponseBody) SetCount(v int32) *DescribeDesktopOversoldUserResponseBody {
	s.Count = &v
	return s
}

func (s *DescribeDesktopOversoldUserResponseBody) SetData(v []*DescribeDesktopOversoldUserResponseBodyData) *DescribeDesktopOversoldUserResponseBody {
	s.Data = v
	return s
}

func (s *DescribeDesktopOversoldUserResponseBody) SetNextToken(v string) *DescribeDesktopOversoldUserResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeDesktopOversoldUserResponseBody) SetRequestId(v string) *DescribeDesktopOversoldUserResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDesktopOversoldUserResponseBodyData struct {
	EndUserId       *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	OversoldGroupId *string `json:"OversoldGroupId,omitempty" xml:"OversoldGroupId,omitempty"`
	UserDesktopId   *string `json:"UserDesktopId,omitempty" xml:"UserDesktopId,omitempty"`
	UserGroupId     *string `json:"UserGroupId,omitempty" xml:"UserGroupId,omitempty"`
}

func (s DescribeDesktopOversoldUserResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopOversoldUserResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeDesktopOversoldUserResponseBodyData) SetEndUserId(v string) *DescribeDesktopOversoldUserResponseBodyData {
	s.EndUserId = &v
	return s
}

func (s *DescribeDesktopOversoldUserResponseBodyData) SetOversoldGroupId(v string) *DescribeDesktopOversoldUserResponseBodyData {
	s.OversoldGroupId = &v
	return s
}

func (s *DescribeDesktopOversoldUserResponseBodyData) SetUserDesktopId(v string) *DescribeDesktopOversoldUserResponseBodyData {
	s.UserDesktopId = &v
	return s
}

func (s *DescribeDesktopOversoldUserResponseBodyData) SetUserGroupId(v string) *DescribeDesktopOversoldUserResponseBodyData {
	s.UserGroupId = &v
	return s
}

type DescribeDesktopOversoldUserResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDesktopOversoldUserResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDesktopOversoldUserResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopOversoldUserResponse) GoString() string {
	return s.String()
}

func (s *DescribeDesktopOversoldUserResponse) SetHeaders(v map[string]*string) *DescribeDesktopOversoldUserResponse {
	s.Headers = v
	return s
}

func (s *DescribeDesktopOversoldUserResponse) SetStatusCode(v int32) *DescribeDesktopOversoldUserResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDesktopOversoldUserResponse) SetBody(v *DescribeDesktopOversoldUserResponseBody) *DescribeDesktopOversoldUserResponse {
	s.Body = v
	return s
}

type DescribeDesktopOversoldUserGroupRequest struct {
	MaxResults      *int32    `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	NextToken       *string   `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OversoldGroupId *string   `json:"OversoldGroupId,omitempty" xml:"OversoldGroupId,omitempty"`
	UserGroupIds    []*string `json:"UserGroupIds,omitempty" xml:"UserGroupIds,omitempty" type:"Repeated"`
}

func (s DescribeDesktopOversoldUserGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopOversoldUserGroupRequest) GoString() string {
	return s.String()
}

func (s *DescribeDesktopOversoldUserGroupRequest) SetMaxResults(v int32) *DescribeDesktopOversoldUserGroupRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeDesktopOversoldUserGroupRequest) SetNextToken(v string) *DescribeDesktopOversoldUserGroupRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeDesktopOversoldUserGroupRequest) SetOversoldGroupId(v string) *DescribeDesktopOversoldUserGroupRequest {
	s.OversoldGroupId = &v
	return s
}

func (s *DescribeDesktopOversoldUserGroupRequest) SetUserGroupIds(v []*string) *DescribeDesktopOversoldUserGroupRequest {
	s.UserGroupIds = v
	return s
}

type DescribeDesktopOversoldUserGroupResponseBody struct {
	Count     *int32                                              `json:"Count,omitempty" xml:"Count,omitempty"`
	Data      []*DescribeDesktopOversoldUserGroupResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	NextToken *string                                             `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	RequestId *string                                             `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDesktopOversoldUserGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopOversoldUserGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDesktopOversoldUserGroupResponseBody) SetCount(v int32) *DescribeDesktopOversoldUserGroupResponseBody {
	s.Count = &v
	return s
}

func (s *DescribeDesktopOversoldUserGroupResponseBody) SetData(v []*DescribeDesktopOversoldUserGroupResponseBodyData) *DescribeDesktopOversoldUserGroupResponseBody {
	s.Data = v
	return s
}

func (s *DescribeDesktopOversoldUserGroupResponseBody) SetNextToken(v string) *DescribeDesktopOversoldUserGroupResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeDesktopOversoldUserGroupResponseBody) SetRequestId(v string) *DescribeDesktopOversoldUserGroupResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDesktopOversoldUserGroupResponseBodyData struct {
	ImageId         *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	Name            *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OversoldGroupId *string `json:"OversoldGroupId,omitempty" xml:"OversoldGroupId,omitempty"`
	PolicyGroupId   *string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty"`
	UserGroupId     *string `json:"UserGroupId,omitempty" xml:"UserGroupId,omitempty"`
}

func (s DescribeDesktopOversoldUserGroupResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopOversoldUserGroupResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeDesktopOversoldUserGroupResponseBodyData) SetImageId(v string) *DescribeDesktopOversoldUserGroupResponseBodyData {
	s.ImageId = &v
	return s
}

func (s *DescribeDesktopOversoldUserGroupResponseBodyData) SetName(v string) *DescribeDesktopOversoldUserGroupResponseBodyData {
	s.Name = &v
	return s
}

func (s *DescribeDesktopOversoldUserGroupResponseBodyData) SetOversoldGroupId(v string) *DescribeDesktopOversoldUserGroupResponseBodyData {
	s.OversoldGroupId = &v
	return s
}

func (s *DescribeDesktopOversoldUserGroupResponseBodyData) SetPolicyGroupId(v string) *DescribeDesktopOversoldUserGroupResponseBodyData {
	s.PolicyGroupId = &v
	return s
}

func (s *DescribeDesktopOversoldUserGroupResponseBodyData) SetUserGroupId(v string) *DescribeDesktopOversoldUserGroupResponseBodyData {
	s.UserGroupId = &v
	return s
}

type DescribeDesktopOversoldUserGroupResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDesktopOversoldUserGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDesktopOversoldUserGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopOversoldUserGroupResponse) GoString() string {
	return s.String()
}

func (s *DescribeDesktopOversoldUserGroupResponse) SetHeaders(v map[string]*string) *DescribeDesktopOversoldUserGroupResponse {
	s.Headers = v
	return s
}

func (s *DescribeDesktopOversoldUserGroupResponse) SetStatusCode(v int32) *DescribeDesktopOversoldUserGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDesktopOversoldUserGroupResponse) SetBody(v *DescribeDesktopOversoldUserGroupResponseBody) *DescribeDesktopOversoldUserGroupResponse {
	s.Body = v
	return s
}

type DescribeDesktopSessionsRequest struct {
	// The end of the time range to query.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the end user.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The workspace ID.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The page number.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The session status. Valid values:
	//
	// *   Connected
	// *   Disconnected
	SessionStatus *string `json:"SessionStatus,omitempty" xml:"SessionStatus,omitempty"`
	// The start of the time range to query.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDesktopSessionsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopSessionsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDesktopSessionsRequest) SetEndTime(v string) *DescribeDesktopSessionsRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDesktopSessionsRequest) SetEndUserId(v string) *DescribeDesktopSessionsRequest {
	s.EndUserId = &v
	return s
}

func (s *DescribeDesktopSessionsRequest) SetOfficeSiteId(v string) *DescribeDesktopSessionsRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *DescribeDesktopSessionsRequest) SetPageNumber(v int32) *DescribeDesktopSessionsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDesktopSessionsRequest) SetPageSize(v int32) *DescribeDesktopSessionsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDesktopSessionsRequest) SetRegionId(v string) *DescribeDesktopSessionsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeDesktopSessionsRequest) SetSessionStatus(v string) *DescribeDesktopSessionsRequest {
	s.SessionStatus = &v
	return s
}

func (s *DescribeDesktopSessionsRequest) SetStartTime(v string) *DescribeDesktopSessionsRequest {
	s.StartTime = &v
	return s
}

type DescribeDesktopSessionsResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Details of the session.
	Sessions []*DescribeDesktopSessionsResponseBodySessions `json:"Sessions,omitempty" xml:"Sessions,omitempty" type:"Repeated"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDesktopSessionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopSessionsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDesktopSessionsResponseBody) SetRequestId(v string) *DescribeDesktopSessionsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDesktopSessionsResponseBody) SetSessions(v []*DescribeDesktopSessionsResponseBodySessions) *DescribeDesktopSessionsResponseBody {
	s.Sessions = v
	return s
}

func (s *DescribeDesktopSessionsResponseBody) SetTotalCount(v int32) *DescribeDesktopSessionsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDesktopSessionsResponseBodySessions struct {
	// The IP address of the client.
	ClientIp *string `json:"ClientIp,omitempty" xml:"ClientIp,omitempty"`
	// The OS that the client runs.
	ClientOS *string `json:"ClientOS,omitempty" xml:"ClientOS,omitempty"`
	// The client version.
	ClientVersion *string `json:"ClientVersion,omitempty" xml:"ClientVersion,omitempty"`
	// The cloud desktop ID.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The cloud desktop name.
	DesktopName *string `json:"DesktopName,omitempty" xml:"DesktopName,omitempty"`
	// The duration of the remote assistance. Unit: seconds.
	EndUserApplyCoordinateTime *int64 `json:"EndUserApplyCoordinateTime,omitempty" xml:"EndUserApplyCoordinateTime,omitempty"`
	// The ID of the end user.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The duration of the latest session. Unit: seconds.
	LatestConnectionTime *int64 `json:"LatestConnectionTime,omitempty" xml:"LatestConnectionTime,omitempty"`
	// The workspace ID.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The workspace name.
	OfficeSiteName *string `json:"OfficeSiteName,omitempty" xml:"OfficeSiteName,omitempty"`
	// The OS. Valid values:
	//
	// *   Windows
	// *   Linux
	OsType *string `json:"OsType,omitempty" xml:"OsType,omitempty"`
	// The protocol type that is supported by the cloud desktop. Valid values:
	//
	// *   HDX
	// *   ASP
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The end time of the session.
	SessionEndTime *string `json:"SessionEndTime,omitempty" xml:"SessionEndTime,omitempty"`
	// The idle duration of the session. Unit: seconds.
	SessionIdleTime *int64 `json:"SessionIdleTime,omitempty" xml:"SessionIdleTime,omitempty"`
	// The start time of the session.
	SessionStartTime *string `json:"SessionStartTime,omitempty" xml:"SessionStartTime,omitempty"`
	// The session status. Valid values:
	//
	// *   Connected
	// *   Disconnected
	SessionStatus *string `json:"SessionStatus,omitempty" xml:"SessionStatus,omitempty"`
	// The total session duration. Unit: seconds.
	TotalConnectionTime *int64 `json:"TotalConnectionTime,omitempty" xml:"TotalConnectionTime,omitempty"`
}

func (s DescribeDesktopSessionsResponseBodySessions) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopSessionsResponseBodySessions) GoString() string {
	return s.String()
}

func (s *DescribeDesktopSessionsResponseBodySessions) SetClientIp(v string) *DescribeDesktopSessionsResponseBodySessions {
	s.ClientIp = &v
	return s
}

func (s *DescribeDesktopSessionsResponseBodySessions) SetClientOS(v string) *DescribeDesktopSessionsResponseBodySessions {
	s.ClientOS = &v
	return s
}

func (s *DescribeDesktopSessionsResponseBodySessions) SetClientVersion(v string) *DescribeDesktopSessionsResponseBodySessions {
	s.ClientVersion = &v
	return s
}

func (s *DescribeDesktopSessionsResponseBodySessions) SetDesktopId(v string) *DescribeDesktopSessionsResponseBodySessions {
	s.DesktopId = &v
	return s
}

func (s *DescribeDesktopSessionsResponseBodySessions) SetDesktopName(v string) *DescribeDesktopSessionsResponseBodySessions {
	s.DesktopName = &v
	return s
}

func (s *DescribeDesktopSessionsResponseBodySessions) SetEndUserApplyCoordinateTime(v int64) *DescribeDesktopSessionsResponseBodySessions {
	s.EndUserApplyCoordinateTime = &v
	return s
}

func (s *DescribeDesktopSessionsResponseBodySessions) SetEndUserId(v string) *DescribeDesktopSessionsResponseBodySessions {
	s.EndUserId = &v
	return s
}

func (s *DescribeDesktopSessionsResponseBodySessions) SetLatestConnectionTime(v int64) *DescribeDesktopSessionsResponseBodySessions {
	s.LatestConnectionTime = &v
	return s
}

func (s *DescribeDesktopSessionsResponseBodySessions) SetOfficeSiteId(v string) *DescribeDesktopSessionsResponseBodySessions {
	s.OfficeSiteId = &v
	return s
}

func (s *DescribeDesktopSessionsResponseBodySessions) SetOfficeSiteName(v string) *DescribeDesktopSessionsResponseBodySessions {
	s.OfficeSiteName = &v
	return s
}

func (s *DescribeDesktopSessionsResponseBodySessions) SetOsType(v string) *DescribeDesktopSessionsResponseBodySessions {
	s.OsType = &v
	return s
}

func (s *DescribeDesktopSessionsResponseBodySessions) SetProtocolType(v string) *DescribeDesktopSessionsResponseBodySessions {
	s.ProtocolType = &v
	return s
}

func (s *DescribeDesktopSessionsResponseBodySessions) SetSessionEndTime(v string) *DescribeDesktopSessionsResponseBodySessions {
	s.SessionEndTime = &v
	return s
}

func (s *DescribeDesktopSessionsResponseBodySessions) SetSessionIdleTime(v int64) *DescribeDesktopSessionsResponseBodySessions {
	s.SessionIdleTime = &v
	return s
}

func (s *DescribeDesktopSessionsResponseBodySessions) SetSessionStartTime(v string) *DescribeDesktopSessionsResponseBodySessions {
	s.SessionStartTime = &v
	return s
}

func (s *DescribeDesktopSessionsResponseBodySessions) SetSessionStatus(v string) *DescribeDesktopSessionsResponseBodySessions {
	s.SessionStatus = &v
	return s
}

func (s *DescribeDesktopSessionsResponseBodySessions) SetTotalConnectionTime(v int64) *DescribeDesktopSessionsResponseBodySessions {
	s.TotalConnectionTime = &v
	return s
}

type DescribeDesktopSessionsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDesktopSessionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDesktopSessionsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopSessionsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDesktopSessionsResponse) SetHeaders(v map[string]*string) *DescribeDesktopSessionsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDesktopSessionsResponse) SetStatusCode(v int32) *DescribeDesktopSessionsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDesktopSessionsResponse) SetBody(v *DescribeDesktopSessionsResponseBody) *DescribeDesktopSessionsResponse {
	s.Body = v
	return s
}

type DescribeDesktopTypesRequest struct {
	// Applicable Scope of specifications. Default value: `Public`
	AppliedScope *string `json:"AppliedScope,omitempty" xml:"AppliedScope,omitempty"`
	// The number of vCPUs.
	CpuCount                *int32  `json:"CpuCount,omitempty" xml:"CpuCount,omitempty"`
	DesktopGroupIdForModify *string `json:"DesktopGroupIdForModify,omitempty" xml:"DesktopGroupIdForModify,omitempty"`
	// When changing the configuration, enter the desktop ID that needs to be changed. The return value will increase the compatibility between the specifications and the desktop.
	DesktopIdForModify *string `json:"DesktopIdForModify,omitempty" xml:"DesktopIdForModify,omitempty"`
	// The ID of the cloud desktop type. Valid values:
	//
	// *   eds.graphics.16c1t4
	// *   eds.graphics.24c1t4
	// *   eds.hf.12c24g
	// *   eds.hf.8c16g
	// *   eds.hf.4c8g
	// *   eds.general.8c32g
	// *   eds.general.16c32g
	// *   eds.general.8c16g
	// *   eds.general.4c16g
	// *   eds.general.4c8g
	// *   eds.general.2c8g
	// *   eds.general.2c4g
	// *   eds.general.2c2g
	// *   ecd.graphics.xlarge
	// *   ecd.graphics.2xlarge
	// *   ecd.performance.2xlarge
	// *   ecd.advanced.xlarge
	// *   ecd.advanced.large
	// *   ecd.basic.large
	// *   ecd.basic.small
	DesktopTypeId *string `json:"DesktopTypeId,omitempty" xml:"DesktopTypeId,omitempty"`
	// The number of GPUs.
	GpuCount *float32 `json:"GpuCount,omitempty" xml:"GpuCount,omitempty"`
	// The family of the cloud desktop type. Valid values:
	//
	// *   eds.graphics
	// *   eds.hf
	// *   eds.general
	// *   ecd.graphics
	// *   ecd.performance
	// *   ecd.advanced
	// *   ecd.basic
	InstanceTypeFamily *string `json:"InstanceTypeFamily,omitempty" xml:"InstanceTypeFamily,omitempty"`
	// The memory size. Unit: GiB.
	MemorySize *int32 `json:"MemorySize,omitempty" xml:"MemorySize,omitempty"`
	// The order type.
	OrderType *string `json:"OrderType,omitempty" xml:"OrderType,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeDesktopTypesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopTypesRequest) GoString() string {
	return s.String()
}

func (s *DescribeDesktopTypesRequest) SetAppliedScope(v string) *DescribeDesktopTypesRequest {
	s.AppliedScope = &v
	return s
}

func (s *DescribeDesktopTypesRequest) SetCpuCount(v int32) *DescribeDesktopTypesRequest {
	s.CpuCount = &v
	return s
}

func (s *DescribeDesktopTypesRequest) SetDesktopGroupIdForModify(v string) *DescribeDesktopTypesRequest {
	s.DesktopGroupIdForModify = &v
	return s
}

func (s *DescribeDesktopTypesRequest) SetDesktopIdForModify(v string) *DescribeDesktopTypesRequest {
	s.DesktopIdForModify = &v
	return s
}

func (s *DescribeDesktopTypesRequest) SetDesktopTypeId(v string) *DescribeDesktopTypesRequest {
	s.DesktopTypeId = &v
	return s
}

func (s *DescribeDesktopTypesRequest) SetGpuCount(v float32) *DescribeDesktopTypesRequest {
	s.GpuCount = &v
	return s
}

func (s *DescribeDesktopTypesRequest) SetInstanceTypeFamily(v string) *DescribeDesktopTypesRequest {
	s.InstanceTypeFamily = &v
	return s
}

func (s *DescribeDesktopTypesRequest) SetMemorySize(v int32) *DescribeDesktopTypesRequest {
	s.MemorySize = &v
	return s
}

func (s *DescribeDesktopTypesRequest) SetOrderType(v string) *DescribeDesktopTypesRequest {
	s.OrderType = &v
	return s
}

func (s *DescribeDesktopTypesRequest) SetRegionId(v string) *DescribeDesktopTypesRequest {
	s.RegionId = &v
	return s
}

type DescribeDesktopTypesResponseBody struct {
	// Details of cloud desktop types.
	DesktopTypes []*DescribeDesktopTypesResponseBodyDesktopTypes `json:"DesktopTypes,omitempty" xml:"DesktopTypes,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDesktopTypesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopTypesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDesktopTypesResponseBody) SetDesktopTypes(v []*DescribeDesktopTypesResponseBodyDesktopTypes) *DescribeDesktopTypesResponseBody {
	s.DesktopTypes = v
	return s
}

func (s *DescribeDesktopTypesResponseBody) SetRequestId(v string) *DescribeDesktopTypesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDesktopTypesResponseBodyDesktopTypes struct {
	// The number of vCPUs.
	CpuCount *string `json:"CpuCount,omitempty" xml:"CpuCount,omitempty"`
	// The size of the data disk. Unit: GiB.
	DataDiskSize *string `json:"DataDiskSize,omitempty" xml:"DataDiskSize,omitempty"`
	// The ID of the cloud desktop type.
	DesktopTypeId *string `json:"DesktopTypeId,omitempty" xml:"DesktopTypeId,omitempty"`
	// The status of the cloud desktop type. If SUFFICIENT is returned, the number of cloud desktops of the type is sufficient.
	DesktopTypeStatus *string `json:"DesktopTypeStatus,omitempty" xml:"DesktopTypeStatus,omitempty"`
	// The number of GPUs.
	GpuCount *float32 `json:"GpuCount,omitempty" xml:"GpuCount,omitempty"`
	// The GPU memory.
	GpuSpec *string `json:"GpuSpec,omitempty" xml:"GpuSpec,omitempty"`
	// The family of the cloud desktop type.
	InstanceTypeFamily *string `json:"InstanceTypeFamily,omitempty" xml:"InstanceTypeFamily,omitempty"`
	// The memory size. Unit: MiB.
	MemorySize *string `json:"MemorySize,omitempty" xml:"MemorySize,omitempty"`
	// The size of the system disk. Unit: GiB.
	SystemDiskSize *string `json:"SystemDiskSize,omitempty" xml:"SystemDiskSize,omitempty"`
}

func (s DescribeDesktopTypesResponseBodyDesktopTypes) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopTypesResponseBodyDesktopTypes) GoString() string {
	return s.String()
}

func (s *DescribeDesktopTypesResponseBodyDesktopTypes) SetCpuCount(v string) *DescribeDesktopTypesResponseBodyDesktopTypes {
	s.CpuCount = &v
	return s
}

func (s *DescribeDesktopTypesResponseBodyDesktopTypes) SetDataDiskSize(v string) *DescribeDesktopTypesResponseBodyDesktopTypes {
	s.DataDiskSize = &v
	return s
}

func (s *DescribeDesktopTypesResponseBodyDesktopTypes) SetDesktopTypeId(v string) *DescribeDesktopTypesResponseBodyDesktopTypes {
	s.DesktopTypeId = &v
	return s
}

func (s *DescribeDesktopTypesResponseBodyDesktopTypes) SetDesktopTypeStatus(v string) *DescribeDesktopTypesResponseBodyDesktopTypes {
	s.DesktopTypeStatus = &v
	return s
}

func (s *DescribeDesktopTypesResponseBodyDesktopTypes) SetGpuCount(v float32) *DescribeDesktopTypesResponseBodyDesktopTypes {
	s.GpuCount = &v
	return s
}

func (s *DescribeDesktopTypesResponseBodyDesktopTypes) SetGpuSpec(v string) *DescribeDesktopTypesResponseBodyDesktopTypes {
	s.GpuSpec = &v
	return s
}

func (s *DescribeDesktopTypesResponseBodyDesktopTypes) SetInstanceTypeFamily(v string) *DescribeDesktopTypesResponseBodyDesktopTypes {
	s.InstanceTypeFamily = &v
	return s
}

func (s *DescribeDesktopTypesResponseBodyDesktopTypes) SetMemorySize(v string) *DescribeDesktopTypesResponseBodyDesktopTypes {
	s.MemorySize = &v
	return s
}

func (s *DescribeDesktopTypesResponseBodyDesktopTypes) SetSystemDiskSize(v string) *DescribeDesktopTypesResponseBodyDesktopTypes {
	s.SystemDiskSize = &v
	return s
}

type DescribeDesktopTypesResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDesktopTypesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDesktopTypesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopTypesResponse) GoString() string {
	return s.String()
}

func (s *DescribeDesktopTypesResponse) SetHeaders(v map[string]*string) *DescribeDesktopTypesResponse {
	s.Headers = v
	return s
}

func (s *DescribeDesktopTypesResponse) SetStatusCode(v int32) *DescribeDesktopTypesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDesktopTypesResponse) SetBody(v *DescribeDesktopTypesResponseBody) *DescribeDesktopTypesResponse {
	s.Body = v
	return s
}

type DescribeDesktopsRequest struct {
	// The billing method of the cloud desktop.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The ID of the desktop group. If you specify the `DesktopId` parameter, ignore the `DesktopGroupId` parameter. If you do not specify the `DesktopId` parameter, specify the `DesktopGroupId` parameter in the call to request all IDs of the cloud desktops in the specified desktop group.
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// The IDs of the cloud desktops. You can specify 1 to 100 cloud desktop IDs.
	DesktopId []*string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty" type:"Repeated"`
	// The name of the cloud desktop.
	DesktopName *string `json:"DesktopName,omitempty" xml:"DesktopName,omitempty"`
	// The status of the cloud desktop.
	DesktopStatus *string `json:"DesktopStatus,omitempty" xml:"DesktopStatus,omitempty"`
	// The list of desktop status.
	DesktopStatusList []*string `json:"DesktopStatusList,omitempty" xml:"DesktopStatusList,omitempty" type:"Repeated"`
	// The new desktop type. You can call the [DescribeDesktopTypes](~~DescribeDesktopTypes~~) operation to query the IDs of supported desktop types.
	DesktopType *string `json:"DesktopType,omitempty" xml:"DesktopType,omitempty"`
	// The ID of the directory, The ID is the same as the workspace ID.
	DirectoryId *string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	// The IDs of the end users that are assigned the cloud desktop. You can specify 1 to 100 end user IDs.
	//
	// > Only one end user can use the cloud desktop at a time.
	EndUserId []*string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty" type:"Repeated"`
	// The IDs of the end users that are excluded from the end users that are assigned the cloud desktop. You can specify 1 to 100 end user IDs.
	ExcludedEndUserId []*string `json:"ExcludedEndUserId,omitempty" xml:"ExcludedEndUserId,omitempty" type:"Repeated"`
	// The time when the subscription cloud desktop expires.
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// Specifies whether to filter cloud desktops in the desktop group.
	FilterDesktopGroup *bool `json:"FilterDesktopGroup,omitempty" xml:"FilterDesktopGroup,omitempty"`
	// The ID of the desktop group.
	//
	// > The desktop group feature is in invitational preview. If you want to use this feature, submit a ticket.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The IDs of the images.
	ImageId []*string `json:"ImageId,omitempty" xml:"ImageId,omitempty" type:"Repeated"`
	// The flag that is used to manage the cloud desktops.
	ManagementFlag *string `json:"ManagementFlag,omitempty" xml:"ManagementFlag,omitempty"`
	// The number of entries to return on each page.
	//
	// *   Maximum value: 100.
	// *   Default value: 10.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the next query. If this parameter is left empty, all results are returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The name of the workspace.
	OfficeSiteName *string `json:"OfficeSiteName,omitempty" xml:"OfficeSiteName,omitempty"`
	// The progress when the cloud desktop was created.
	OnlyDesktopGroup *bool `json:"OnlyDesktopGroup,omitempty" xml:"OnlyDesktopGroup,omitempty"`
	// The types of the OSs.
	OsTypes []*string `json:"OsTypes,omitempty" xml:"OsTypes,omitempty" type:"Repeated"`
	// The ID of the policy.
	PolicyGroupId *string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty"`
	// The type of the protocol.
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// Specifies whether to query the information about image update of the cloud desktop.
	QueryFotaUpdate *bool `json:"QueryFotaUpdate,omitempty" xml:"QueryFotaUpdate,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~DescribeRegions~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the snapshot policy.
	SnapshotPolicyId *string `json:"SnapshotPolicyId,omitempty" xml:"SnapshotPolicyId,omitempty"`
	// The tags. A tag is a key-value pair that consists of a tag key and a tag value. Tags are used to identify resources. You can use tags to manage cloud desktops by group for easy searching and batch operations. For more information, see [Use tags to manage cloud desktops](~~203781~~).
	Tag []*DescribeDesktopsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The name of the end user.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
}

func (s DescribeDesktopsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDesktopsRequest) SetChargeType(v string) *DescribeDesktopsRequest {
	s.ChargeType = &v
	return s
}

func (s *DescribeDesktopsRequest) SetDesktopGroupId(v string) *DescribeDesktopsRequest {
	s.DesktopGroupId = &v
	return s
}

func (s *DescribeDesktopsRequest) SetDesktopId(v []*string) *DescribeDesktopsRequest {
	s.DesktopId = v
	return s
}

func (s *DescribeDesktopsRequest) SetDesktopName(v string) *DescribeDesktopsRequest {
	s.DesktopName = &v
	return s
}

func (s *DescribeDesktopsRequest) SetDesktopStatus(v string) *DescribeDesktopsRequest {
	s.DesktopStatus = &v
	return s
}

func (s *DescribeDesktopsRequest) SetDesktopStatusList(v []*string) *DescribeDesktopsRequest {
	s.DesktopStatusList = v
	return s
}

func (s *DescribeDesktopsRequest) SetDesktopType(v string) *DescribeDesktopsRequest {
	s.DesktopType = &v
	return s
}

func (s *DescribeDesktopsRequest) SetDirectoryId(v string) *DescribeDesktopsRequest {
	s.DirectoryId = &v
	return s
}

func (s *DescribeDesktopsRequest) SetEndUserId(v []*string) *DescribeDesktopsRequest {
	s.EndUserId = v
	return s
}

func (s *DescribeDesktopsRequest) SetExcludedEndUserId(v []*string) *DescribeDesktopsRequest {
	s.ExcludedEndUserId = v
	return s
}

func (s *DescribeDesktopsRequest) SetExpiredTime(v string) *DescribeDesktopsRequest {
	s.ExpiredTime = &v
	return s
}

func (s *DescribeDesktopsRequest) SetFilterDesktopGroup(v bool) *DescribeDesktopsRequest {
	s.FilterDesktopGroup = &v
	return s
}

func (s *DescribeDesktopsRequest) SetGroupId(v string) *DescribeDesktopsRequest {
	s.GroupId = &v
	return s
}

func (s *DescribeDesktopsRequest) SetImageId(v []*string) *DescribeDesktopsRequest {
	s.ImageId = v
	return s
}

func (s *DescribeDesktopsRequest) SetManagementFlag(v string) *DescribeDesktopsRequest {
	s.ManagementFlag = &v
	return s
}

func (s *DescribeDesktopsRequest) SetMaxResults(v int32) *DescribeDesktopsRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeDesktopsRequest) SetNextToken(v string) *DescribeDesktopsRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeDesktopsRequest) SetOfficeSiteId(v string) *DescribeDesktopsRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *DescribeDesktopsRequest) SetOfficeSiteName(v string) *DescribeDesktopsRequest {
	s.OfficeSiteName = &v
	return s
}

func (s *DescribeDesktopsRequest) SetOnlyDesktopGroup(v bool) *DescribeDesktopsRequest {
	s.OnlyDesktopGroup = &v
	return s
}

func (s *DescribeDesktopsRequest) SetOsTypes(v []*string) *DescribeDesktopsRequest {
	s.OsTypes = v
	return s
}

func (s *DescribeDesktopsRequest) SetPolicyGroupId(v string) *DescribeDesktopsRequest {
	s.PolicyGroupId = &v
	return s
}

func (s *DescribeDesktopsRequest) SetProtocolType(v string) *DescribeDesktopsRequest {
	s.ProtocolType = &v
	return s
}

func (s *DescribeDesktopsRequest) SetQueryFotaUpdate(v bool) *DescribeDesktopsRequest {
	s.QueryFotaUpdate = &v
	return s
}

func (s *DescribeDesktopsRequest) SetRegionId(v string) *DescribeDesktopsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeDesktopsRequest) SetSnapshotPolicyId(v string) *DescribeDesktopsRequest {
	s.SnapshotPolicyId = &v
	return s
}

func (s *DescribeDesktopsRequest) SetTag(v []*DescribeDesktopsRequestTag) *DescribeDesktopsRequest {
	s.Tag = v
	return s
}

func (s *DescribeDesktopsRequest) SetUserName(v string) *DescribeDesktopsRequest {
	s.UserName = &v
	return s
}

type DescribeDesktopsRequestTag struct {
	// The key of the tag. If you specify the `Tag` parameter, you must also specify the `Key` parameter. The tag key can be up to 128 characters in length and cannot contain `http://` or `https://`. The tag key cannot start with `aliyun` or `acs:`. You cannot specify an empty string as a tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag. The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`. The tag value cannot start with `aliyun` or `acs:`.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDesktopsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopsRequestTag) GoString() string {
	return s.String()
}

func (s *DescribeDesktopsRequestTag) SetKey(v string) *DescribeDesktopsRequestTag {
	s.Key = &v
	return s
}

func (s *DescribeDesktopsRequestTag) SetValue(v string) *DescribeDesktopsRequestTag {
	s.Value = &v
	return s
}

type DescribeDesktopsResponseBody struct {
	// Details of the cloud desktops.
	Desktops []*DescribeDesktopsResponseBodyDesktops `json:"Desktops,omitempty" xml:"Desktops,omitempty" type:"Repeated"`
	// The token that is used for the next query. If this parameter is left empty, all results are returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of cloud desktops.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDesktopsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDesktopsResponseBody) SetDesktops(v []*DescribeDesktopsResponseBodyDesktops) *DescribeDesktopsResponseBody {
	s.Desktops = v
	return s
}

func (s *DescribeDesktopsResponseBody) SetNextToken(v string) *DescribeDesktopsResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeDesktopsResponseBody) SetRequestId(v string) *DescribeDesktopsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDesktopsResponseBody) SetTotalCount(v int32) *DescribeDesktopsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDesktopsResponseBodyDesktops struct {
	// The number of sessions allowed for each cloud desktop in the multi-session desktop group.
	BindAmount *int32 `json:"BindAmount,omitempty" xml:"BindAmount,omitempty"`
	// The ID of the desktop template that is used to create the cloud desktop.
	BundleId *string `json:"BundleId,omitempty" xml:"BundleId,omitempty"`
	// The name of the desktop template that is used to create the cloud desktop.
	BundleName *string `json:"BundleName,omitempty" xml:"BundleName,omitempty"`
	// The billing method of the cloud desktop.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The connection status of the end user.
	ConnectionStatus *string `json:"ConnectionStatus,omitempty" xml:"ConnectionStatus,omitempty"`
	// The number of vCPUs.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The time when the cloud desktop was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// > This parameter is in invitational preview and is unavailable.
	DataDiskCategory *string `json:"DataDiskCategory,omitempty" xml:"DataDiskCategory,omitempty"`
	// > This parameter is in invitational preview and is unavailable.
	DataDiskSize *string `json:"DataDiskSize,omitempty" xml:"DataDiskSize,omitempty"`
	// The ID of the desktop group. Default value: null.
	//
	// > This parameter is in invitational preview and is unavailable.
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// The ID of the cloud desktop.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The name of the cloud desktop.
	DesktopName *string `json:"DesktopName,omitempty" xml:"DesktopName,omitempty"`
	// The status of the cloud desktop.
	DesktopStatus *string `json:"DesktopStatus,omitempty" xml:"DesktopStatus,omitempty"`
	// The desktop type.
	DesktopType *string `json:"DesktopType,omitempty" xml:"DesktopType,omitempty"`
	// The ID of the directory. The ID is the same as the workspace ID that is indicated by the OfficeSiteId parameter.
	DirectoryId *string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	// This parameter is in invitational preview and is unavailable.
	DirectoryType *string `json:"DirectoryType,omitempty" xml:"DirectoryType,omitempty"`
	// Details of the disks.
	Disks []*DescribeDesktopsResponseBodyDesktopsDisks `json:"Disks,omitempty" xml:"Disks,omitempty" type:"Repeated"`
	// The number of times for which the cloud desktop can be downgraded.
	DowngradeQuota *int64 `json:"DowngradeQuota,omitempty" xml:"DowngradeQuota,omitempty"`
	// The number of times for which the cloud desktop has been downgraded.
	DowngradedTimes *int64 `json:"DowngradedTimes,omitempty" xml:"DowngradedTimes,omitempty"`
	// The IDs of the end users that have the permissions to connect to the cloud desktops.
	EndUserIds []*string `json:"EndUserIds,omitempty" xml:"EndUserIds,omitempty" type:"Repeated"`
	// The time when the subscription cloud desktop expired.
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The information about the image version that the cloud desktop uses.
	FotaUpdate *DescribeDesktopsResponseBodyDesktopsFotaUpdate `json:"FotaUpdate,omitempty" xml:"FotaUpdate,omitempty" type:"Struct"`
	// Indicates whether the cloud desktop is of the GPU-accelerated type.
	GpuCategory *int64 `json:"GpuCategory,omitempty" xml:"GpuCategory,omitempty"`
	// The number of GPUs.
	GpuCount *float32 `json:"GpuCount,omitempty" xml:"GpuCount,omitempty"`
	// The version of the GPU driver with which the cloud desktop is equipped.
	GpuDriverVersion *string `json:"GpuDriverVersion,omitempty" xml:"GpuDriverVersion,omitempty"`
	// The GPU specifications.
	GpuSpec *string `json:"GpuSpec,omitempty" xml:"GpuSpec,omitempty"`
	// > This parameter is in invitational preview and is not available for use.
	HibernationBeta *bool `json:"HibernationBeta,omitempty" xml:"HibernationBeta,omitempty"`
	// > This parameter is in invitational preview and is not available for use.
	HibernationOptionsConfigured *bool `json:"HibernationOptionsConfigured,omitempty" xml:"HibernationOptionsConfigured,omitempty"`
	// The hostname of the cloud desktop.
	HostName *string `json:"HostName,omitempty" xml:"HostName,omitempty"`
	// The ID of the image.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The flag that is used to manage the cloud desktops.
	ManagementFlag *string `json:"ManagementFlag,omitempty" xml:"ManagementFlag,omitempty"`
	// The flag that is used to manage the cloud desktops.
	ManagementFlags []*string `json:"ManagementFlags,omitempty" xml:"ManagementFlags,omitempty" type:"Repeated"`
	// The memory size. Unit: MiB.
	Memory *int64 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The ID of the secondary network interface controller (NIC) created by the RAM user or Active Directory (AD) user in EDS. You do not have the permissions to modify this ID.
	NetworkInterfaceId *string `json:"NetworkInterfaceId,omitempty" xml:"NetworkInterfaceId,omitempty"`
	// The IP address of the secondary NIC that is created by the RAM user or AD user in EDS.
	NetworkInterfaceIp *string `json:"NetworkInterfaceIp,omitempty" xml:"NetworkInterfaceIp,omitempty"`
	// The ID of the workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The name of the workspace.
	OfficeSiteName *string `json:"OfficeSiteName,omitempty" xml:"OfficeSiteName,omitempty"`
	// The account type of the workspace.
	OfficeSiteType *string `json:"OfficeSiteType,omitempty" xml:"OfficeSiteType,omitempty"`
	// The virtual private cloud (VPC) type of the workspace.
	OfficeSiteVpcType *string `json:"OfficeSiteVpcType,omitempty" xml:"OfficeSiteVpcType,omitempty"`
	// The type of the OS.
	OsType *string `json:"OsType,omitempty" xml:"OsType,omitempty"`
	// The information about the OS platform. Valid values:
	//
	// *   CentOS
	// *   Ubuntu
	// *   Windows Server 2016
	// *   Windows Server 2019
	// *   UOS
	Platform *string `json:"Platform,omitempty" xml:"Platform,omitempty"`
	// The ID of the policy.
	PolicyGroupId *string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty"`
	// The policies IDs.
	PolicyGroupIdList []*string `json:"PolicyGroupIdList,omitempty" xml:"PolicyGroupIdList,omitempty" type:"Repeated"`
	// The name of the policy.
	PolicyGroupName *string `json:"PolicyGroupName,omitempty" xml:"PolicyGroupName,omitempty"`
	// The policy names.
	PolicyGroupNameList []*string `json:"PolicyGroupNameList,omitempty" xml:"PolicyGroupNameList,omitempty" type:"Repeated"`
	// The progress when the cloud desktop was created.
	Progress *string `json:"Progress,omitempty" xml:"Progress,omitempty"`
	// The type of the protocol.
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The session type.
	//
	// Valid values:
	//
	// * **SINGLE_SESSION**
	//
	// * **MULTIPLE_SESSION**
	SessionType *string `json:"SessionType,omitempty" xml:"SessionType,omitempty"`
	// Details of the desktop sessions that end users hold.
	Sessions []*DescribeDesktopsResponseBodyDesktopsSessions `json:"Sessions,omitempty" xml:"Sessions,omitempty" type:"Repeated"`
	// The ID of the snapshot policy.
	SnapshotPolicyId *string `json:"SnapshotPolicyId,omitempty" xml:"SnapshotPolicyId,omitempty"`
	// The name of the snapshot policy.
	SnapshotPolicyName *string `json:"SnapshotPolicyName,omitempty" xml:"SnapshotPolicyName,omitempty"`
	// The first time when the cloud desktop was started.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// Indicates whether hibernation is supported for the cloud desktop.
	SupportHibernation *bool `json:"SupportHibernation,omitempty" xml:"SupportHibernation,omitempty"`
	// > This parameter is in invitational preview and is unavailable.
	SystemDiskCategory *string `json:"SystemDiskCategory,omitempty" xml:"SystemDiskCategory,omitempty"`
	// > This parameter is in invitational preview and is unavailable.
	SystemDiskSize *int32 `json:"SystemDiskSize,omitempty" xml:"SystemDiskSize,omitempty"`
	// Details of the tags.
	Tags []*DescribeDesktopsResponseBodyDesktopsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// Indicates whether disk encryption is enabled.
	VolumeEncryptionEnabled *bool `json:"VolumeEncryptionEnabled,omitempty" xml:"VolumeEncryptionEnabled,omitempty"`
	// The ID of the Key Management Service (KMS) key that is used when disk encryption is enabled. You can call the [ListKeys](~~28951~~) operation to obtain a list of KMS keys.
	VolumeEncryptionKey *string `json:"VolumeEncryptionKey,omitempty" xml:"VolumeEncryptionKey,omitempty"`
	// The type of the zone. Default value: **AvailabilityZone**. This value indicates Alibaba Cloud zones.
	ZoneType *string `json:"ZoneType,omitempty" xml:"ZoneType,omitempty"`
}

func (s DescribeDesktopsResponseBodyDesktops) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopsResponseBodyDesktops) GoString() string {
	return s.String()
}

func (s *DescribeDesktopsResponseBodyDesktops) SetBindAmount(v int32) *DescribeDesktopsResponseBodyDesktops {
	s.BindAmount = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetBundleId(v string) *DescribeDesktopsResponseBodyDesktops {
	s.BundleId = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetBundleName(v string) *DescribeDesktopsResponseBodyDesktops {
	s.BundleName = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetChargeType(v string) *DescribeDesktopsResponseBodyDesktops {
	s.ChargeType = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetConnectionStatus(v string) *DescribeDesktopsResponseBodyDesktops {
	s.ConnectionStatus = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetCpu(v int32) *DescribeDesktopsResponseBodyDesktops {
	s.Cpu = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetCreationTime(v string) *DescribeDesktopsResponseBodyDesktops {
	s.CreationTime = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetDataDiskCategory(v string) *DescribeDesktopsResponseBodyDesktops {
	s.DataDiskCategory = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetDataDiskSize(v string) *DescribeDesktopsResponseBodyDesktops {
	s.DataDiskSize = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetDesktopGroupId(v string) *DescribeDesktopsResponseBodyDesktops {
	s.DesktopGroupId = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetDesktopId(v string) *DescribeDesktopsResponseBodyDesktops {
	s.DesktopId = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetDesktopName(v string) *DescribeDesktopsResponseBodyDesktops {
	s.DesktopName = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetDesktopStatus(v string) *DescribeDesktopsResponseBodyDesktops {
	s.DesktopStatus = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetDesktopType(v string) *DescribeDesktopsResponseBodyDesktops {
	s.DesktopType = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetDirectoryId(v string) *DescribeDesktopsResponseBodyDesktops {
	s.DirectoryId = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetDirectoryType(v string) *DescribeDesktopsResponseBodyDesktops {
	s.DirectoryType = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetDisks(v []*DescribeDesktopsResponseBodyDesktopsDisks) *DescribeDesktopsResponseBodyDesktops {
	s.Disks = v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetDowngradeQuota(v int64) *DescribeDesktopsResponseBodyDesktops {
	s.DowngradeQuota = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetDowngradedTimes(v int64) *DescribeDesktopsResponseBodyDesktops {
	s.DowngradedTimes = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetEndUserIds(v []*string) *DescribeDesktopsResponseBodyDesktops {
	s.EndUserIds = v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetExpiredTime(v string) *DescribeDesktopsResponseBodyDesktops {
	s.ExpiredTime = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetFotaUpdate(v *DescribeDesktopsResponseBodyDesktopsFotaUpdate) *DescribeDesktopsResponseBodyDesktops {
	s.FotaUpdate = v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetGpuCategory(v int64) *DescribeDesktopsResponseBodyDesktops {
	s.GpuCategory = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetGpuCount(v float32) *DescribeDesktopsResponseBodyDesktops {
	s.GpuCount = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetGpuDriverVersion(v string) *DescribeDesktopsResponseBodyDesktops {
	s.GpuDriverVersion = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetGpuSpec(v string) *DescribeDesktopsResponseBodyDesktops {
	s.GpuSpec = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetHibernationBeta(v bool) *DescribeDesktopsResponseBodyDesktops {
	s.HibernationBeta = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetHibernationOptionsConfigured(v bool) *DescribeDesktopsResponseBodyDesktops {
	s.HibernationOptionsConfigured = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetHostName(v string) *DescribeDesktopsResponseBodyDesktops {
	s.HostName = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetImageId(v string) *DescribeDesktopsResponseBodyDesktops {
	s.ImageId = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetManagementFlag(v string) *DescribeDesktopsResponseBodyDesktops {
	s.ManagementFlag = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetManagementFlags(v []*string) *DescribeDesktopsResponseBodyDesktops {
	s.ManagementFlags = v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetMemory(v int64) *DescribeDesktopsResponseBodyDesktops {
	s.Memory = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetNetworkInterfaceId(v string) *DescribeDesktopsResponseBodyDesktops {
	s.NetworkInterfaceId = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetNetworkInterfaceIp(v string) *DescribeDesktopsResponseBodyDesktops {
	s.NetworkInterfaceIp = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetOfficeSiteId(v string) *DescribeDesktopsResponseBodyDesktops {
	s.OfficeSiteId = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetOfficeSiteName(v string) *DescribeDesktopsResponseBodyDesktops {
	s.OfficeSiteName = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetOfficeSiteType(v string) *DescribeDesktopsResponseBodyDesktops {
	s.OfficeSiteType = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetOfficeSiteVpcType(v string) *DescribeDesktopsResponseBodyDesktops {
	s.OfficeSiteVpcType = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetOsType(v string) *DescribeDesktopsResponseBodyDesktops {
	s.OsType = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetPlatform(v string) *DescribeDesktopsResponseBodyDesktops {
	s.Platform = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetPolicyGroupId(v string) *DescribeDesktopsResponseBodyDesktops {
	s.PolicyGroupId = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetPolicyGroupIdList(v []*string) *DescribeDesktopsResponseBodyDesktops {
	s.PolicyGroupIdList = v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetPolicyGroupName(v string) *DescribeDesktopsResponseBodyDesktops {
	s.PolicyGroupName = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetPolicyGroupNameList(v []*string) *DescribeDesktopsResponseBodyDesktops {
	s.PolicyGroupNameList = v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetProgress(v string) *DescribeDesktopsResponseBodyDesktops {
	s.Progress = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetProtocolType(v string) *DescribeDesktopsResponseBodyDesktops {
	s.ProtocolType = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetSessionType(v string) *DescribeDesktopsResponseBodyDesktops {
	s.SessionType = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetSessions(v []*DescribeDesktopsResponseBodyDesktopsSessions) *DescribeDesktopsResponseBodyDesktops {
	s.Sessions = v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetSnapshotPolicyId(v string) *DescribeDesktopsResponseBodyDesktops {
	s.SnapshotPolicyId = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetSnapshotPolicyName(v string) *DescribeDesktopsResponseBodyDesktops {
	s.SnapshotPolicyName = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetStartTime(v string) *DescribeDesktopsResponseBodyDesktops {
	s.StartTime = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetSupportHibernation(v bool) *DescribeDesktopsResponseBodyDesktops {
	s.SupportHibernation = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetSystemDiskCategory(v string) *DescribeDesktopsResponseBodyDesktops {
	s.SystemDiskCategory = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetSystemDiskSize(v int32) *DescribeDesktopsResponseBodyDesktops {
	s.SystemDiskSize = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetTags(v []*DescribeDesktopsResponseBodyDesktopsTags) *DescribeDesktopsResponseBodyDesktops {
	s.Tags = v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetVolumeEncryptionEnabled(v bool) *DescribeDesktopsResponseBodyDesktops {
	s.VolumeEncryptionEnabled = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetVolumeEncryptionKey(v string) *DescribeDesktopsResponseBodyDesktops {
	s.VolumeEncryptionKey = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktops) SetZoneType(v string) *DescribeDesktopsResponseBodyDesktops {
	s.ZoneType = &v
	return s
}

type DescribeDesktopsResponseBodyDesktopsDisks struct {
	// The ID of the disk.
	DiskId *string `json:"DiskId,omitempty" xml:"DiskId,omitempty"`
	// The size of the disk. Unit: GiB.
	DiskSize *int32 `json:"DiskSize,omitempty" xml:"DiskSize,omitempty"`
	// The type of the disk.
	DiskType *string `json:"DiskType,omitempty" xml:"DiskType,omitempty"`
	// The performance level (PL) of the disk that is an enhanced SSD (ESSD). Valid values:
	//
	// *   PL0
	// *   PL1
	// *   PL2
	// *   PL3
	//
	// For more information about the differences between disks of different PLs, see [Enhanced SSDs](~~122389~~).
	PerformanceLevel *string `json:"PerformanceLevel,omitempty" xml:"PerformanceLevel,omitempty"`
}

func (s DescribeDesktopsResponseBodyDesktopsDisks) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopsResponseBodyDesktopsDisks) GoString() string {
	return s.String()
}

func (s *DescribeDesktopsResponseBodyDesktopsDisks) SetDiskId(v string) *DescribeDesktopsResponseBodyDesktopsDisks {
	s.DiskId = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktopsDisks) SetDiskSize(v int32) *DescribeDesktopsResponseBodyDesktopsDisks {
	s.DiskSize = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktopsDisks) SetDiskType(v string) *DescribeDesktopsResponseBodyDesktopsDisks {
	s.DiskType = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktopsDisks) SetPerformanceLevel(v string) *DescribeDesktopsResponseBodyDesktopsDisks {
	s.PerformanceLevel = &v
	return s
}

type DescribeDesktopsResponseBodyDesktopsFotaUpdate struct {
	// The current version of the cloud desktop.
	CurrentAppVersion *string `json:"CurrentAppVersion,omitempty" xml:"CurrentAppVersion,omitempty"`
	// The version to which the cloud desktop can be updated.
	NewAppVersion *string `json:"NewAppVersion,omitempty" xml:"NewAppVersion,omitempty"`
	// The description of the version to which the cloud desktop can be updated.
	ReleaseNote *string `json:"ReleaseNote,omitempty" xml:"ReleaseNote,omitempty"`
	// The description of the version that can be upgraded in English.
	ReleaseNoteEn *string `json:"ReleaseNoteEn,omitempty" xml:"ReleaseNoteEn,omitempty"`
	// The description of the version that can be upgraded in Japanese.
	ReleaseNoteJp *string `json:"ReleaseNoteJp,omitempty" xml:"ReleaseNoteJp,omitempty"`
	// The size of the installation package for the version to which the cloud desktop can be updated. Unit: KB.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
}

func (s DescribeDesktopsResponseBodyDesktopsFotaUpdate) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopsResponseBodyDesktopsFotaUpdate) GoString() string {
	return s.String()
}

func (s *DescribeDesktopsResponseBodyDesktopsFotaUpdate) SetCurrentAppVersion(v string) *DescribeDesktopsResponseBodyDesktopsFotaUpdate {
	s.CurrentAppVersion = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktopsFotaUpdate) SetNewAppVersion(v string) *DescribeDesktopsResponseBodyDesktopsFotaUpdate {
	s.NewAppVersion = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktopsFotaUpdate) SetReleaseNote(v string) *DescribeDesktopsResponseBodyDesktopsFotaUpdate {
	s.ReleaseNote = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktopsFotaUpdate) SetReleaseNoteEn(v string) *DescribeDesktopsResponseBodyDesktopsFotaUpdate {
	s.ReleaseNoteEn = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktopsFotaUpdate) SetReleaseNoteJp(v string) *DescribeDesktopsResponseBodyDesktopsFotaUpdate {
	s.ReleaseNoteJp = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktopsFotaUpdate) SetSize(v int64) *DescribeDesktopsResponseBodyDesktopsFotaUpdate {
	s.Size = &v
	return s
}

type DescribeDesktopsResponseBodyDesktopsSessions struct {
	// The ID of the end user that logged on to the cloud desktop.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The time when the desktop session was established.
	EstablishmentTime *string `json:"EstablishmentTime,omitempty" xml:"EstablishmentTime,omitempty"`
	// The name of the external user.
	ExternalUserName *string `json:"ExternalUserName,omitempty" xml:"ExternalUserName,omitempty"`
}

func (s DescribeDesktopsResponseBodyDesktopsSessions) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopsResponseBodyDesktopsSessions) GoString() string {
	return s.String()
}

func (s *DescribeDesktopsResponseBodyDesktopsSessions) SetEndUserId(v string) *DescribeDesktopsResponseBodyDesktopsSessions {
	s.EndUserId = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktopsSessions) SetEstablishmentTime(v string) *DescribeDesktopsResponseBodyDesktopsSessions {
	s.EstablishmentTime = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktopsSessions) SetExternalUserName(v string) *DescribeDesktopsResponseBodyDesktopsSessions {
	s.ExternalUserName = &v
	return s
}

type DescribeDesktopsResponseBodyDesktopsTags struct {
	// The key of the tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDesktopsResponseBodyDesktopsTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopsResponseBodyDesktopsTags) GoString() string {
	return s.String()
}

func (s *DescribeDesktopsResponseBodyDesktopsTags) SetKey(v string) *DescribeDesktopsResponseBodyDesktopsTags {
	s.Key = &v
	return s
}

func (s *DescribeDesktopsResponseBodyDesktopsTags) SetValue(v string) *DescribeDesktopsResponseBodyDesktopsTags {
	s.Value = &v
	return s
}

type DescribeDesktopsResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDesktopsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDesktopsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDesktopsResponse) SetHeaders(v map[string]*string) *DescribeDesktopsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDesktopsResponse) SetStatusCode(v int32) *DescribeDesktopsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDesktopsResponse) SetBody(v *DescribeDesktopsResponseBody) *DescribeDesktopsResponse {
	s.Body = v
	return s
}

type DescribeDesktopsInGroupRequest struct {
	// The desktop group ID.
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// Specifies whether to ignore the deleted cloud desktops.
	IgnoreDeleted *bool `json:"IgnoreDeleted,omitempty" xml:"IgnoreDeleted,omitempty"`
	// The number of entries to return on each page. Valid values: 1 to 100. Default value: 10.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. If the NextToken parameter is empty, no next page exists.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The billing method of the desktop group.
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeDesktopsInGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopsInGroupRequest) GoString() string {
	return s.String()
}

func (s *DescribeDesktopsInGroupRequest) SetDesktopGroupId(v string) *DescribeDesktopsInGroupRequest {
	s.DesktopGroupId = &v
	return s
}

func (s *DescribeDesktopsInGroupRequest) SetIgnoreDeleted(v bool) *DescribeDesktopsInGroupRequest {
	s.IgnoreDeleted = &v
	return s
}

func (s *DescribeDesktopsInGroupRequest) SetMaxResults(v int32) *DescribeDesktopsInGroupRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeDesktopsInGroupRequest) SetNextToken(v string) *DescribeDesktopsInGroupRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeDesktopsInGroupRequest) SetPayType(v string) *DescribeDesktopsInGroupRequest {
	s.PayType = &v
	return s
}

func (s *DescribeDesktopsInGroupRequest) SetRegionId(v string) *DescribeDesktopsInGroupRequest {
	s.RegionId = &v
	return s
}

type DescribeDesktopsInGroupResponseBody struct {
	// The returned value of NextToken is a pagination token, which can be used in the next request to retrieve a new page of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The number of subscription cloud desktops that are connected.
	OnlinePrePaidDesktopsCount *int32 `json:"OnlinePrePaidDesktopsCount,omitempty" xml:"OnlinePrePaidDesktopsCount,omitempty"`
	// The subscription cloud desktops.
	PaidDesktops []*DescribeDesktopsInGroupResponseBodyPaidDesktops `json:"PaidDesktops,omitempty" xml:"PaidDesktops,omitempty" type:"Repeated"`
	// The total number of subscription cloud desktops.
	PaidDesktopsCount *int32 `json:"PaidDesktopsCount,omitempty" xml:"PaidDesktopsCount,omitempty"`
	// The pay-as-you-go cloud desktops.
	PostPaidDesktops []*DescribeDesktopsInGroupResponseBodyPostPaidDesktops `json:"PostPaidDesktops,omitempty" xml:"PostPaidDesktops,omitempty" type:"Repeated"`
	// The total number of pay-as-you-go cloud desktops.
	PostPaidDesktopsCount *int32 `json:"PostPaidDesktopsCount,omitempty" xml:"PostPaidDesktopsCount,omitempty"`
	// The total bill amount for the pay-as-you-go cloud desktops.
	PostPaidDesktopsTotalAmount *int32 `json:"PostPaidDesktopsTotalAmount,omitempty" xml:"PostPaidDesktopsTotalAmount,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of subscription cloud desktops that are running.
	RunningPrePaidDesktopsCount *int32 `json:"RunningPrePaidDesktopsCount,omitempty" xml:"RunningPrePaidDesktopsCount,omitempty"`
	// The number of subscription cloud desktops that are stopped.
	StopedPrePaidDesktopsCount *int32 `json:"StopedPrePaidDesktopsCount,omitempty" xml:"StopedPrePaidDesktopsCount,omitempty"`
	// The number of subscription cloud desktops that are stopped.
	StoppedPrePaidDesktopsCount *int32 `json:"StoppedPrePaidDesktopsCount,omitempty" xml:"StoppedPrePaidDesktopsCount,omitempty"`
}

func (s DescribeDesktopsInGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopsInGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDesktopsInGroupResponseBody) SetNextToken(v string) *DescribeDesktopsInGroupResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBody) SetOnlinePrePaidDesktopsCount(v int32) *DescribeDesktopsInGroupResponseBody {
	s.OnlinePrePaidDesktopsCount = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBody) SetPaidDesktops(v []*DescribeDesktopsInGroupResponseBodyPaidDesktops) *DescribeDesktopsInGroupResponseBody {
	s.PaidDesktops = v
	return s
}

func (s *DescribeDesktopsInGroupResponseBody) SetPaidDesktopsCount(v int32) *DescribeDesktopsInGroupResponseBody {
	s.PaidDesktopsCount = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBody) SetPostPaidDesktops(v []*DescribeDesktopsInGroupResponseBodyPostPaidDesktops) *DescribeDesktopsInGroupResponseBody {
	s.PostPaidDesktops = v
	return s
}

func (s *DescribeDesktopsInGroupResponseBody) SetPostPaidDesktopsCount(v int32) *DescribeDesktopsInGroupResponseBody {
	s.PostPaidDesktopsCount = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBody) SetPostPaidDesktopsTotalAmount(v int32) *DescribeDesktopsInGroupResponseBody {
	s.PostPaidDesktopsTotalAmount = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBody) SetRequestId(v string) *DescribeDesktopsInGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBody) SetRunningPrePaidDesktopsCount(v int32) *DescribeDesktopsInGroupResponseBody {
	s.RunningPrePaidDesktopsCount = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBody) SetStopedPrePaidDesktopsCount(v int32) *DescribeDesktopsInGroupResponseBody {
	s.StopedPrePaidDesktopsCount = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBody) SetStoppedPrePaidDesktopsCount(v int32) *DescribeDesktopsInGroupResponseBody {
	s.StoppedPrePaidDesktopsCount = &v
	return s
}

type DescribeDesktopsInGroupResponseBodyPaidDesktops struct {
	// The connection state.
	//
	// Valid values:
	//
	// *   Unknown
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Connected
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Disconnected
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	ConnectionStatus *string `json:"ConnectionStatus,omitempty" xml:"ConnectionStatus,omitempty"`
	// The cloud desktop ID.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The cloud desktop name.
	DesktopName *string `json:"DesktopName,omitempty" xml:"DesktopName,omitempty"`
	// The state of the cloud desktop.
	//
	// Valid values:
	//
	// *   Stopped
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Starting
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Rebuilding
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Running
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Stopping
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Expired
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Deleted
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Pending
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	DesktopStatus *string `json:"DesktopStatus,omitempty" xml:"DesktopStatus,omitempty"`
	// The disk type.
	//
	// Valid values:
	//
	// *   SYSTEM
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     the system disk
	//
	//     <!-- -->
	//
	// *   DATA:
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     the data disk
	//
	//     <!-- -->
	DiskType *string `json:"DiskType,omitempty" xml:"DiskType,omitempty"`
	// The authorized user.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The IDs of users that are connected to cloud desktops. If no users are connected, null is returned.
	EndUserIds []*string `json:"EndUserIds,omitempty" xml:"EndUserIds,omitempty" type:"Repeated"`
	// The username of the authorized user.
	EndUserName *string `json:"EndUserName,omitempty" xml:"EndUserName,omitempty"`
	// The names of users that are connected to cloud desktops. If no users are connected, null is returned.
	EndUserNames []*string `json:"EndUserNames,omitempty" xml:"EndUserNames,omitempty" type:"Repeated"`
	// The image version.
	FotaVersion *string `json:"FotaVersion,omitempty" xml:"FotaVersion,omitempty"`
	// The GPU driver version.
	GpuDriverVersion *string `json:"GpuDriverVersion,omitempty" xml:"GpuDriverVersion,omitempty"`
	// The image ID.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The image name.
	ImageName *string `json:"ImageName,omitempty" xml:"ImageName,omitempty"`
	// The flag that is used for management.
	//
	// Valid values:
	//
	// *   Updating: The configurations of the cloud desktop are being changed.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   NoFlag: No flags are available.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	ManagementFlag *string `json:"ManagementFlag,omitempty" xml:"ManagementFlag,omitempty"`
	// The flags that are used for management.
	ManagementFlags []*string `json:"ManagementFlags,omitempty" xml:"ManagementFlags,omitempty" type:"Repeated"`
	// The IP address of the member Elastic Network Interface (ENI).
	MemberEniIp *string `json:"MemberEniIp,omitempty" xml:"MemberEniIp,omitempty"`
	// The OS.
	//
	// Valid values:
	//
	// *   Linux
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Windows
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	OsType *string `json:"OsType,omitempty" xml:"OsType,omitempty"`
	// The IP address of the primary ENI.
	PrimaryEniIp *string `json:"PrimaryEniIp,omitempty" xml:"PrimaryEniIp,omitempty"`
	// The protocol type. Valid values:
	//
	// *   ASP
	// *   HDX
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The point in time when the cloud desktop was reset.
	ResetTime *string `json:"ResetTime,omitempty" xml:"ResetTime,omitempty"`
	// The system disk size. Unit: GiB.
	SystemDiskSize *int32 `json:"SystemDiskSize,omitempty" xml:"SystemDiskSize,omitempty"`
}

func (s DescribeDesktopsInGroupResponseBodyPaidDesktops) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopsInGroupResponseBodyPaidDesktops) GoString() string {
	return s.String()
}

func (s *DescribeDesktopsInGroupResponseBodyPaidDesktops) SetConnectionStatus(v string) *DescribeDesktopsInGroupResponseBodyPaidDesktops {
	s.ConnectionStatus = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPaidDesktops) SetDesktopId(v string) *DescribeDesktopsInGroupResponseBodyPaidDesktops {
	s.DesktopId = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPaidDesktops) SetDesktopName(v string) *DescribeDesktopsInGroupResponseBodyPaidDesktops {
	s.DesktopName = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPaidDesktops) SetDesktopStatus(v string) *DescribeDesktopsInGroupResponseBodyPaidDesktops {
	s.DesktopStatus = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPaidDesktops) SetDiskType(v string) *DescribeDesktopsInGroupResponseBodyPaidDesktops {
	s.DiskType = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPaidDesktops) SetEndUserId(v string) *DescribeDesktopsInGroupResponseBodyPaidDesktops {
	s.EndUserId = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPaidDesktops) SetEndUserIds(v []*string) *DescribeDesktopsInGroupResponseBodyPaidDesktops {
	s.EndUserIds = v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPaidDesktops) SetEndUserName(v string) *DescribeDesktopsInGroupResponseBodyPaidDesktops {
	s.EndUserName = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPaidDesktops) SetEndUserNames(v []*string) *DescribeDesktopsInGroupResponseBodyPaidDesktops {
	s.EndUserNames = v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPaidDesktops) SetFotaVersion(v string) *DescribeDesktopsInGroupResponseBodyPaidDesktops {
	s.FotaVersion = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPaidDesktops) SetGpuDriverVersion(v string) *DescribeDesktopsInGroupResponseBodyPaidDesktops {
	s.GpuDriverVersion = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPaidDesktops) SetImageId(v string) *DescribeDesktopsInGroupResponseBodyPaidDesktops {
	s.ImageId = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPaidDesktops) SetImageName(v string) *DescribeDesktopsInGroupResponseBodyPaidDesktops {
	s.ImageName = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPaidDesktops) SetManagementFlag(v string) *DescribeDesktopsInGroupResponseBodyPaidDesktops {
	s.ManagementFlag = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPaidDesktops) SetManagementFlags(v []*string) *DescribeDesktopsInGroupResponseBodyPaidDesktops {
	s.ManagementFlags = v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPaidDesktops) SetMemberEniIp(v string) *DescribeDesktopsInGroupResponseBodyPaidDesktops {
	s.MemberEniIp = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPaidDesktops) SetOsType(v string) *DescribeDesktopsInGroupResponseBodyPaidDesktops {
	s.OsType = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPaidDesktops) SetPrimaryEniIp(v string) *DescribeDesktopsInGroupResponseBodyPaidDesktops {
	s.PrimaryEniIp = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPaidDesktops) SetProtocolType(v string) *DescribeDesktopsInGroupResponseBodyPaidDesktops {
	s.ProtocolType = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPaidDesktops) SetResetTime(v string) *DescribeDesktopsInGroupResponseBodyPaidDesktops {
	s.ResetTime = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPaidDesktops) SetSystemDiskSize(v int32) *DescribeDesktopsInGroupResponseBodyPaidDesktops {
	s.SystemDiskSize = &v
	return s
}

type DescribeDesktopsInGroupResponseBodyPostPaidDesktops struct {
	// The connection state.
	//
	// Valid values:
	//
	// *   Unknown
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Connected
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Disconnected
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	ConnectionStatus *string `json:"ConnectionStatus,omitempty" xml:"ConnectionStatus,omitempty"`
	// The retention period.
	CreateDuration *string `json:"CreateDuration,omitempty" xml:"CreateDuration,omitempty"`
	// The time when the auxiliary media asset was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The cloud desktop ID.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The cloud desktop name.
	DesktopName *string `json:"DesktopName,omitempty" xml:"DesktopName,omitempty"`
	// The state of the cloud desktop.
	//
	// Valid values:
	//
	// *   Stopped
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Starting
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Rebuilding
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Running
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Stopping
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Expired
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Deleted
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Pending
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	DesktopStatus *string `json:"DesktopStatus,omitempty" xml:"DesktopStatus,omitempty"`
	// The disk type.
	//
	// Valid values:
	//
	// *   SYSTEM
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     the system disk
	//
	//     <!-- -->
	//
	// *   DATA:
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     the data disk
	//
	//     <!-- -->
	DiskType *string `json:"DiskType,omitempty" xml:"DiskType,omitempty"`
	// The authorized user.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The IDs of users that are connected to cloud desktops. If no users are connected, null is returned.
	EndUserIds []*string `json:"EndUserIds,omitempty" xml:"EndUserIds,omitempty" type:"Repeated"`
	// The username of the authorized user.
	EndUserName *string `json:"EndUserName,omitempty" xml:"EndUserName,omitempty"`
	// The names of users that are connected to cloud desktops. If no users are connected, null is returned.
	EndUserNames []*string `json:"EndUserNames,omitempty" xml:"EndUserNames,omitempty" type:"Repeated"`
	// The image version.
	FotaVersion *string `json:"FotaVersion,omitempty" xml:"FotaVersion,omitempty"`
	// The GPU driver version.
	GpuDriverVersion *string `json:"GpuDriverVersion,omitempty" xml:"GpuDriverVersion,omitempty"`
	// The image ID.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The image name.
	ImageName *string `json:"ImageName,omitempty" xml:"ImageName,omitempty"`
	// The flag that is used for management.
	//
	// Valid values:
	//
	// *   Updating: The configurations of the cloud desktop are being changed.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   NoFlag: No flags are available.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	ManagementFlag *string `json:"ManagementFlag,omitempty" xml:"ManagementFlag,omitempty"`
	// The flags that are used for management.
	ManagementFlags []*string `json:"ManagementFlags,omitempty" xml:"ManagementFlags,omitempty" type:"Repeated"`
	// The IP address of the member Elastic Network Interface (ENI).
	MemberEniIp *string `json:"MemberEniIp,omitempty" xml:"MemberEniIp,omitempty"`
	// The OS.
	//
	// Valid values:
	//
	// *   Linux
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Windows
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	OsType *string `json:"OsType,omitempty" xml:"OsType,omitempty"`
	// The IP address of the primary ENI.
	PrimaryEniIp *string `json:"PrimaryEniIp,omitempty" xml:"PrimaryEniIp,omitempty"`
	// The protocol type. Valid values:
	//
	// *   ASP
	// *   HDX
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The time when the cloud desktop was released.
	ReleaseTime *string `json:"ReleaseTime,omitempty" xml:"ReleaseTime,omitempty"`
	// The point in time when the cloud desktop was reset.
	ResetTime *string `json:"ResetTime,omitempty" xml:"ResetTime,omitempty"`
	// The system disk size. Unit: GiB.
	SystemDiskSize *int32 `json:"SystemDiskSize,omitempty" xml:"SystemDiskSize,omitempty"`
}

func (s DescribeDesktopsInGroupResponseBodyPostPaidDesktops) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopsInGroupResponseBodyPostPaidDesktops) GoString() string {
	return s.String()
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetConnectionStatus(v string) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.ConnectionStatus = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetCreateDuration(v string) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.CreateDuration = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetCreateTime(v string) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.CreateTime = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetDesktopId(v string) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.DesktopId = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetDesktopName(v string) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.DesktopName = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetDesktopStatus(v string) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.DesktopStatus = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetDiskType(v string) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.DiskType = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetEndUserId(v string) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.EndUserId = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetEndUserIds(v []*string) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.EndUserIds = v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetEndUserName(v string) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.EndUserName = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetEndUserNames(v []*string) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.EndUserNames = v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetFotaVersion(v string) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.FotaVersion = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetGpuDriverVersion(v string) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.GpuDriverVersion = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetImageId(v string) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.ImageId = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetImageName(v string) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.ImageName = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetManagementFlag(v string) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.ManagementFlag = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetManagementFlags(v []*string) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.ManagementFlags = v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetMemberEniIp(v string) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.MemberEniIp = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetOsType(v string) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.OsType = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetPrimaryEniIp(v string) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.PrimaryEniIp = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetProtocolType(v string) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.ProtocolType = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetReleaseTime(v string) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.ReleaseTime = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetResetTime(v string) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.ResetTime = &v
	return s
}

func (s *DescribeDesktopsInGroupResponseBodyPostPaidDesktops) SetSystemDiskSize(v int32) *DescribeDesktopsInGroupResponseBodyPostPaidDesktops {
	s.SystemDiskSize = &v
	return s
}

type DescribeDesktopsInGroupResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDesktopsInGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDesktopsInGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDesktopsInGroupResponse) GoString() string {
	return s.String()
}

func (s *DescribeDesktopsInGroupResponse) SetHeaders(v map[string]*string) *DescribeDesktopsInGroupResponse {
	s.Headers = v
	return s
}

func (s *DescribeDesktopsInGroupResponse) SetStatusCode(v int32) *DescribeDesktopsInGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDesktopsInGroupResponse) SetBody(v *DescribeDesktopsInGroupResponseBody) *DescribeDesktopsInGroupResponse {
	s.Body = v
	return s
}

type DescribeDevicesRequest struct {
	// The address of the Active Directory (AD) workspace.
	AdDomain *string `json:"AdDomain,omitempty" xml:"AdDomain,omitempty"`
	// The type of the Alibaba Cloud Workspace client.
	//
	// *   1: hardware client.
	// *   2: software client.
	ClientType *string `json:"ClientType,omitempty" xml:"ClientType,omitempty"`
	// The ID of the device.
	DeviceId *string `json:"DeviceId,omitempty" xml:"DeviceId,omitempty"`
	// The ID of the workspace.
	DirectoryId *string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	// The ID of the convenience user to whom you want to bind the device.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The type of the user account.
	//
	// *   SIMPLE: convenience account.
	// *   AD: AD account.
	UserType *string `json:"UserType,omitempty" xml:"UserType,omitempty"`
}

func (s DescribeDevicesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDevicesRequest) GoString() string {
	return s.String()
}

func (s *DescribeDevicesRequest) SetAdDomain(v string) *DescribeDevicesRequest {
	s.AdDomain = &v
	return s
}

func (s *DescribeDevicesRequest) SetClientType(v string) *DescribeDevicesRequest {
	s.ClientType = &v
	return s
}

func (s *DescribeDevicesRequest) SetDeviceId(v string) *DescribeDevicesRequest {
	s.DeviceId = &v
	return s
}

func (s *DescribeDevicesRequest) SetDirectoryId(v string) *DescribeDevicesRequest {
	s.DirectoryId = &v
	return s
}

func (s *DescribeDevicesRequest) SetEndUserId(v string) *DescribeDevicesRequest {
	s.EndUserId = &v
	return s
}

func (s *DescribeDevicesRequest) SetPageNumber(v int32) *DescribeDevicesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDevicesRequest) SetPageSize(v int32) *DescribeDevicesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDevicesRequest) SetRegion(v string) *DescribeDevicesRequest {
	s.Region = &v
	return s
}

func (s *DescribeDevicesRequest) SetUserType(v string) *DescribeDevicesRequest {
	s.UserType = &v
	return s
}

type DescribeDevicesResponseBody struct {
	// Details of the devices that are returned.
	Devices []*DescribeDevicesResponseBodyDevices `json:"Devices,omitempty" xml:"Devices,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDevicesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDevicesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDevicesResponseBody) SetDevices(v []*DescribeDevicesResponseBodyDevices) *DescribeDevicesResponseBody {
	s.Devices = v
	return s
}

func (s *DescribeDevicesResponseBody) SetRequestId(v string) *DescribeDevicesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDevicesResponseBodyDevices struct {
	// The ID of the device.
	DeviceId *string `json:"DeviceId,omitempty" xml:"DeviceId,omitempty"`
	// The users who are bound to the device.
	EndUserList []*DescribeDevicesResponseBodyDevicesEndUserList `json:"EndUserList,omitempty" xml:"EndUserList,omitempty" type:"Repeated"`
}

func (s DescribeDevicesResponseBodyDevices) String() string {
	return tea.Prettify(s)
}

func (s DescribeDevicesResponseBodyDevices) GoString() string {
	return s.String()
}

func (s *DescribeDevicesResponseBodyDevices) SetDeviceId(v string) *DescribeDevicesResponseBodyDevices {
	s.DeviceId = &v
	return s
}

func (s *DescribeDevicesResponseBodyDevices) SetEndUserList(v []*DescribeDevicesResponseBodyDevicesEndUserList) *DescribeDevicesResponseBodyDevices {
	s.EndUserList = v
	return s
}

type DescribeDevicesResponseBodyDevicesEndUserList struct {
	// The address of the AD workspace.
	AdDomain *string `json:"AdDomain,omitempty" xml:"AdDomain,omitempty"`
	// The ID of the workspace.
	DirectoryId *string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	// The ID of the user.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The type of the account.
	UserType *string `json:"UserType,omitempty" xml:"UserType,omitempty"`
}

func (s DescribeDevicesResponseBodyDevicesEndUserList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDevicesResponseBodyDevicesEndUserList) GoString() string {
	return s.String()
}

func (s *DescribeDevicesResponseBodyDevicesEndUserList) SetAdDomain(v string) *DescribeDevicesResponseBodyDevicesEndUserList {
	s.AdDomain = &v
	return s
}

func (s *DescribeDevicesResponseBodyDevicesEndUserList) SetDirectoryId(v string) *DescribeDevicesResponseBodyDevicesEndUserList {
	s.DirectoryId = &v
	return s
}

func (s *DescribeDevicesResponseBodyDevicesEndUserList) SetEndUserId(v string) *DescribeDevicesResponseBodyDevicesEndUserList {
	s.EndUserId = &v
	return s
}

func (s *DescribeDevicesResponseBodyDevicesEndUserList) SetUserType(v string) *DescribeDevicesResponseBodyDevicesEndUserList {
	s.UserType = &v
	return s
}

type DescribeDevicesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDevicesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDevicesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDevicesResponse) GoString() string {
	return s.String()
}

func (s *DescribeDevicesResponse) SetHeaders(v map[string]*string) *DescribeDevicesResponse {
	s.Headers = v
	return s
}

func (s *DescribeDevicesResponse) SetStatusCode(v int32) *DescribeDevicesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDevicesResponse) SetBody(v *DescribeDevicesResponseBody) *DescribeDevicesResponse {
	s.Body = v
	return s
}

type DescribeDirectoriesRequest struct {
	// Details of directory IDs. You can specify one or more directory IDs.
	DirectoryId []*string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty" type:"Repeated"`
	// The status of the directory. The value of this parameter is the same as the value of the `Status` parameter.
	DirectoryStatus *string `json:"DirectoryStatus,omitempty" xml:"DirectoryStatus,omitempty"`
	// The type of the directory.
	DirectoryType *string `json:"DirectoryType,omitempty" xml:"DirectoryType,omitempty"`
	// The number of entries to return on each page.
	//
	// Maximum value: 100.
	//
	// Default value: 10.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the next query. If this parameter is empty, all results are returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The status of the workspace.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeDirectoriesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDirectoriesRequest) GoString() string {
	return s.String()
}

func (s *DescribeDirectoriesRequest) SetDirectoryId(v []*string) *DescribeDirectoriesRequest {
	s.DirectoryId = v
	return s
}

func (s *DescribeDirectoriesRequest) SetDirectoryStatus(v string) *DescribeDirectoriesRequest {
	s.DirectoryStatus = &v
	return s
}

func (s *DescribeDirectoriesRequest) SetDirectoryType(v string) *DescribeDirectoriesRequest {
	s.DirectoryType = &v
	return s
}

func (s *DescribeDirectoriesRequest) SetMaxResults(v int32) *DescribeDirectoriesRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeDirectoriesRequest) SetNextToken(v string) *DescribeDirectoriesRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeDirectoriesRequest) SetRegionId(v string) *DescribeDirectoriesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeDirectoriesRequest) SetStatus(v string) *DescribeDirectoriesRequest {
	s.Status = &v
	return s
}

type DescribeDirectoriesResponseBody struct {
	// The hostname of the domain controller. The hostname must comply with the hostname naming convention of Windows.
	AdHostname *string `json:"AdHostname,omitempty" xml:"AdHostname,omitempty"`
	// Details of the directories.
	Directories []*DescribeDirectoriesResponseBodyDirectories `json:"Directories,omitempty" xml:"Directories,omitempty" type:"Repeated"`
	// The token that is used for the next query. If this parameter is empty, all results are returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDirectoriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDirectoriesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDirectoriesResponseBody) SetAdHostname(v string) *DescribeDirectoriesResponseBody {
	s.AdHostname = &v
	return s
}

func (s *DescribeDirectoriesResponseBody) SetDirectories(v []*DescribeDirectoriesResponseBodyDirectories) *DescribeDirectoriesResponseBody {
	s.Directories = v
	return s
}

func (s *DescribeDirectoriesResponseBody) SetNextToken(v string) *DescribeDirectoriesResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeDirectoriesResponseBody) SetRequestId(v string) *DescribeDirectoriesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDirectoriesResponseBodyDirectories struct {
	// Details of the AD connectors.
	ADConnectors []*DescribeDirectoriesResponseBodyDirectoriesADConnectors `json:"ADConnectors,omitempty" xml:"ADConnectors,omitempty" type:"Repeated"`
	// The time when the directory was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The ID of the security group.
	CustomSecurityGroupId *string `json:"CustomSecurityGroupId,omitempty" xml:"CustomSecurityGroupId,omitempty"`
	// The method that is used to connect the client to cloud desktops.
	DesktopAccessType *string `json:"DesktopAccessType,omitempty" xml:"DesktopAccessType,omitempty"`
	// The endpoint that is used to connect to cloud desktops over a VPC.
	DesktopVpcEndpoint *string `json:"DesktopVpcEndpoint,omitempty" xml:"DesktopVpcEndpoint,omitempty"`
	// The ID of the directory.
	DirectoryId *string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	// The type of the directory.
	DirectoryType *string `json:"DirectoryType,omitempty" xml:"DirectoryType,omitempty"`
	// Details of the DNS addresses of the directory.
	DnsAddress []*string `json:"DnsAddress,omitempty" xml:"DnsAddress,omitempty" type:"Repeated"`
	// The username of the Domain Name System (DNS) user.
	DnsUserName *string `json:"DnsUserName,omitempty" xml:"DnsUserName,omitempty"`
	// The name of the domain.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The password of the domain administrator.
	DomainPassword *string `json:"DomainPassword,omitempty" xml:"DomainPassword,omitempty"`
	// The username of the domain administrator.
	DomainUserName *string `json:"DomainUserName,omitempty" xml:"DomainUserName,omitempty"`
	// Indicates whether the permissions of the local administrator are granted to the regular user of the cloud desktop.
	EnableAdminAccess *bool `json:"EnableAdminAccess,omitempty" xml:"EnableAdminAccess,omitempty"`
	// Indicates whether the desktop communication feature is enabled for cloud desktops in the same workspace.
	//
	// If the feature is enabled, the cloud desktops in the same workspace can access each other.
	EnableCrossDesktopAccess *bool `json:"EnableCrossDesktopAccess,omitempty" xml:"EnableCrossDesktopAccess,omitempty"`
	// Indicates whether access over the Internet is allowed.
	//
	// >  This parameter is unavailable.
	EnableInternetAccess *bool `json:"EnableInternetAccess,omitempty" xml:"EnableInternetAccess,omitempty"`
	// Details of the IDs of the Apsara File Storage NAS (NAS) file systems.
	FileSystemIds []*string `json:"FileSystemIds,omitempty" xml:"FileSystemIds,omitempty" type:"Repeated"`
	// Details of the registration logs.
	Logs []*DescribeDirectoriesResponseBodyDirectoriesLogs `json:"Logs,omitempty" xml:"Logs,omitempty" type:"Repeated"`
	// Indicates whether multi-factor authentication (MFA) is enabled.
	MfaEnabled *bool `json:"MfaEnabled,omitempty" xml:"MfaEnabled,omitempty"`
	// The name of the directory.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Indicates whether two-factor verification for logons is enabled. This parameter is returned only for workspaces of the convenience account type.\
	// If two-factor verification is enabled, the system checks whether security risks exist within the logon account when a convenience user logs on to the Elastic Desktop Service (EDS) client. If risks are detected, the system sends a verification code to the email address that is associated with the account. Then, the convenience user can log on to the client only after the user enters the correct verification code.
	NeedVerifyLoginRisk *bool `json:"NeedVerifyLoginRisk,omitempty" xml:"NeedVerifyLoginRisk,omitempty"`
	// The name of the organizational unit (OU) that you specified when you add cloud desktops to domains.
	OuName *string `json:"OuName,omitempty" xml:"OuName,omitempty"`
	// Indicates whether single sign-on (SSO) is enabled.
	SsoEnabled *bool `json:"SsoEnabled,omitempty" xml:"SsoEnabled,omitempty"`
	// The status of the AD directory. Valid values:
	//
	// *   REGISTERING
	// *   REGISTERED
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// Details of the DNS addresses of the AD subdomain.
	SubDnsAddress []*string `json:"SubDnsAddress,omitempty" xml:"SubDnsAddress,omitempty" type:"Repeated"`
	// The fully qualified domain name (FQDN) of the enterprise AD subdomain. The value must contain the hostname and the subdomain name. Example: child.example.com.
	SubDomainName *string `json:"SubDomainName,omitempty" xml:"SubDomainName,omitempty"`
	// The AD trust password.
	TrustPassword *string `json:"TrustPassword,omitempty" xml:"TrustPassword,omitempty"`
	// Details of vSwitch IDs that are specified when the directory is being created.
	VSwitchIds []*string `json:"VSwitchIds,omitempty" xml:"VSwitchIds,omitempty" type:"Repeated"`
	// The ID of the virtual private cloud (VPC) to which the vSwitch belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeDirectoriesResponseBodyDirectories) String() string {
	return tea.Prettify(s)
}

func (s DescribeDirectoriesResponseBodyDirectories) GoString() string {
	return s.String()
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetADConnectors(v []*DescribeDirectoriesResponseBodyDirectoriesADConnectors) *DescribeDirectoriesResponseBodyDirectories {
	s.ADConnectors = v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetCreationTime(v string) *DescribeDirectoriesResponseBodyDirectories {
	s.CreationTime = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetCustomSecurityGroupId(v string) *DescribeDirectoriesResponseBodyDirectories {
	s.CustomSecurityGroupId = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetDesktopAccessType(v string) *DescribeDirectoriesResponseBodyDirectories {
	s.DesktopAccessType = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetDesktopVpcEndpoint(v string) *DescribeDirectoriesResponseBodyDirectories {
	s.DesktopVpcEndpoint = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetDirectoryId(v string) *DescribeDirectoriesResponseBodyDirectories {
	s.DirectoryId = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetDirectoryType(v string) *DescribeDirectoriesResponseBodyDirectories {
	s.DirectoryType = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetDnsAddress(v []*string) *DescribeDirectoriesResponseBodyDirectories {
	s.DnsAddress = v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetDnsUserName(v string) *DescribeDirectoriesResponseBodyDirectories {
	s.DnsUserName = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetDomainName(v string) *DescribeDirectoriesResponseBodyDirectories {
	s.DomainName = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetDomainPassword(v string) *DescribeDirectoriesResponseBodyDirectories {
	s.DomainPassword = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetDomainUserName(v string) *DescribeDirectoriesResponseBodyDirectories {
	s.DomainUserName = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetEnableAdminAccess(v bool) *DescribeDirectoriesResponseBodyDirectories {
	s.EnableAdminAccess = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetEnableCrossDesktopAccess(v bool) *DescribeDirectoriesResponseBodyDirectories {
	s.EnableCrossDesktopAccess = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetEnableInternetAccess(v bool) *DescribeDirectoriesResponseBodyDirectories {
	s.EnableInternetAccess = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetFileSystemIds(v []*string) *DescribeDirectoriesResponseBodyDirectories {
	s.FileSystemIds = v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetLogs(v []*DescribeDirectoriesResponseBodyDirectoriesLogs) *DescribeDirectoriesResponseBodyDirectories {
	s.Logs = v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetMfaEnabled(v bool) *DescribeDirectoriesResponseBodyDirectories {
	s.MfaEnabled = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetName(v string) *DescribeDirectoriesResponseBodyDirectories {
	s.Name = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetNeedVerifyLoginRisk(v bool) *DescribeDirectoriesResponseBodyDirectories {
	s.NeedVerifyLoginRisk = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetOuName(v string) *DescribeDirectoriesResponseBodyDirectories {
	s.OuName = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetSsoEnabled(v bool) *DescribeDirectoriesResponseBodyDirectories {
	s.SsoEnabled = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetStatus(v string) *DescribeDirectoriesResponseBodyDirectories {
	s.Status = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetSubDnsAddress(v []*string) *DescribeDirectoriesResponseBodyDirectories {
	s.SubDnsAddress = v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetSubDomainName(v string) *DescribeDirectoriesResponseBodyDirectories {
	s.SubDomainName = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetTrustPassword(v string) *DescribeDirectoriesResponseBodyDirectories {
	s.TrustPassword = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetVSwitchIds(v []*string) *DescribeDirectoriesResponseBodyDirectories {
	s.VSwitchIds = v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectories) SetVpcId(v string) *DescribeDirectoriesResponseBodyDirectories {
	s.VpcId = &v
	return s
}

type DescribeDirectoriesResponseBodyDirectoriesADConnectors struct {
	// The address of the AD connector.
	ADConnectorAddress *string `json:"ADConnectorAddress,omitempty" xml:"ADConnectorAddress,omitempty"`
	// The status of the AD connector.
	ConnectorStatus *string `json:"ConnectorStatus,omitempty" xml:"ConnectorStatus,omitempty"`
	// The ID of the network interface controller (NIC) with which the AD connector is associated.
	NetworkInterfaceId *string `json:"NetworkInterfaceId,omitempty" xml:"NetworkInterfaceId,omitempty"`
	// The type of the AD connector.
	Specification *string `json:"Specification,omitempty" xml:"Specification,omitempty"`
	// The trust password of the AD domain controller.
	TrustKey *string `json:"TrustKey,omitempty" xml:"TrustKey,omitempty"`
	// The ID of the vSwitch with which the AD connector is associated.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
}

func (s DescribeDirectoriesResponseBodyDirectoriesADConnectors) String() string {
	return tea.Prettify(s)
}

func (s DescribeDirectoriesResponseBodyDirectoriesADConnectors) GoString() string {
	return s.String()
}

func (s *DescribeDirectoriesResponseBodyDirectoriesADConnectors) SetADConnectorAddress(v string) *DescribeDirectoriesResponseBodyDirectoriesADConnectors {
	s.ADConnectorAddress = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectoriesADConnectors) SetConnectorStatus(v string) *DescribeDirectoriesResponseBodyDirectoriesADConnectors {
	s.ConnectorStatus = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectoriesADConnectors) SetNetworkInterfaceId(v string) *DescribeDirectoriesResponseBodyDirectoriesADConnectors {
	s.NetworkInterfaceId = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectoriesADConnectors) SetSpecification(v string) *DescribeDirectoriesResponseBodyDirectoriesADConnectors {
	s.Specification = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectoriesADConnectors) SetTrustKey(v string) *DescribeDirectoriesResponseBodyDirectoriesADConnectors {
	s.TrustKey = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectoriesADConnectors) SetVSwitchId(v string) *DescribeDirectoriesResponseBodyDirectoriesADConnectors {
	s.VSwitchId = &v
	return s
}

type DescribeDirectoriesResponseBodyDirectoriesLogs struct {
	// The level of the log entry.
	Level *string `json:"Level,omitempty" xml:"Level,omitempty"`
	// Details of the log entry.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The step that corresponds to the log entry.
	Step *string `json:"Step,omitempty" xml:"Step,omitempty"`
	// The time when the log entry was printed.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeDirectoriesResponseBodyDirectoriesLogs) String() string {
	return tea.Prettify(s)
}

func (s DescribeDirectoriesResponseBodyDirectoriesLogs) GoString() string {
	return s.String()
}

func (s *DescribeDirectoriesResponseBodyDirectoriesLogs) SetLevel(v string) *DescribeDirectoriesResponseBodyDirectoriesLogs {
	s.Level = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectoriesLogs) SetMessage(v string) *DescribeDirectoriesResponseBodyDirectoriesLogs {
	s.Message = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectoriesLogs) SetStep(v string) *DescribeDirectoriesResponseBodyDirectoriesLogs {
	s.Step = &v
	return s
}

func (s *DescribeDirectoriesResponseBodyDirectoriesLogs) SetTimeStamp(v string) *DescribeDirectoriesResponseBodyDirectoriesLogs {
	s.TimeStamp = &v
	return s
}

type DescribeDirectoriesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDirectoriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDirectoriesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDirectoriesResponse) GoString() string {
	return s.String()
}

func (s *DescribeDirectoriesResponse) SetHeaders(v map[string]*string) *DescribeDirectoriesResponse {
	s.Headers = v
	return s
}

func (s *DescribeDirectoriesResponse) SetStatusCode(v int32) *DescribeDirectoriesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDirectoriesResponse) SetBody(v *DescribeDirectoriesResponseBody) *DescribeDirectoriesResponse {
	s.Body = v
	return s
}

type DescribeFlowMetricRequest struct {
	EndTime      *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	InstanceId   *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	MetricType   *string `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
	Period       *int32  `json:"Period,omitempty" xml:"Period,omitempty"`
	RegionId     *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	StartTime    *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeFlowMetricRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowMetricRequest) GoString() string {
	return s.String()
}

func (s *DescribeFlowMetricRequest) SetEndTime(v string) *DescribeFlowMetricRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeFlowMetricRequest) SetInstanceId(v string) *DescribeFlowMetricRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeFlowMetricRequest) SetInstanceType(v string) *DescribeFlowMetricRequest {
	s.InstanceType = &v
	return s
}

func (s *DescribeFlowMetricRequest) SetMetricType(v string) *DescribeFlowMetricRequest {
	s.MetricType = &v
	return s
}

func (s *DescribeFlowMetricRequest) SetPeriod(v int32) *DescribeFlowMetricRequest {
	s.Period = &v
	return s
}

func (s *DescribeFlowMetricRequest) SetRegionId(v string) *DescribeFlowMetricRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeFlowMetricRequest) SetStartTime(v string) *DescribeFlowMetricRequest {
	s.StartTime = &v
	return s
}

type DescribeFlowMetricResponseBody struct {
	Data      *string `json:"Data,omitempty" xml:"Data,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeFlowMetricResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowMetricResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeFlowMetricResponseBody) SetData(v string) *DescribeFlowMetricResponseBody {
	s.Data = &v
	return s
}

func (s *DescribeFlowMetricResponseBody) SetRequestId(v string) *DescribeFlowMetricResponseBody {
	s.RequestId = &v
	return s
}

type DescribeFlowMetricResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeFlowMetricResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeFlowMetricResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowMetricResponse) GoString() string {
	return s.String()
}

func (s *DescribeFlowMetricResponse) SetHeaders(v map[string]*string) *DescribeFlowMetricResponse {
	s.Headers = v
	return s
}

func (s *DescribeFlowMetricResponse) SetStatusCode(v int32) *DescribeFlowMetricResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeFlowMetricResponse) SetBody(v *DescribeFlowMetricResponseBody) *DescribeFlowMetricResponse {
	s.Body = v
	return s
}

type DescribeFlowStatisticRequest struct {
	// The ID of the cloud desktop.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The ID of the workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The number of the page to return.\
	// Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The interval to query the traffic data. Unit: seconds. Valid values:
	//
	// *   3600
	// *   10800
	// *   86400
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeFlowStatisticRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowStatisticRequest) GoString() string {
	return s.String()
}

func (s *DescribeFlowStatisticRequest) SetDesktopId(v string) *DescribeFlowStatisticRequest {
	s.DesktopId = &v
	return s
}

func (s *DescribeFlowStatisticRequest) SetOfficeSiteId(v string) *DescribeFlowStatisticRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *DescribeFlowStatisticRequest) SetPageNumber(v int32) *DescribeFlowStatisticRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeFlowStatisticRequest) SetPageSize(v int32) *DescribeFlowStatisticRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeFlowStatisticRequest) SetPeriod(v int32) *DescribeFlowStatisticRequest {
	s.Period = &v
	return s
}

func (s *DescribeFlowStatisticRequest) SetRegionId(v string) *DescribeFlowStatisticRequest {
	s.RegionId = &v
	return s
}

type DescribeFlowStatisticResponseBody struct {
	// The number of available cloud desktops in the workspace.
	DesktopCount *int32 `json:"DesktopCount,omitempty" xml:"DesktopCount,omitempty"`
	// Details of the traffic that is consumed by cloud desktops.
	DesktopFlowStatistic []*DescribeFlowStatisticResponseBodyDesktopFlowStatistic `json:"DesktopFlowStatistic,omitempty" xml:"DesktopFlowStatistic,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeFlowStatisticResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowStatisticResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeFlowStatisticResponseBody) SetDesktopCount(v int32) *DescribeFlowStatisticResponseBody {
	s.DesktopCount = &v
	return s
}

func (s *DescribeFlowStatisticResponseBody) SetDesktopFlowStatistic(v []*DescribeFlowStatisticResponseBodyDesktopFlowStatistic) *DescribeFlowStatisticResponseBody {
	s.DesktopFlowStatistic = v
	return s
}

func (s *DescribeFlowStatisticResponseBody) SetRequestId(v string) *DescribeFlowStatisticResponseBody {
	s.RequestId = &v
	return s
}

type DescribeFlowStatisticResponseBodyDesktopFlowStatistic struct {
	// The ID of the cloud desktop.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The name of the cloud desktop.
	DesktopName *string `json:"DesktopName,omitempty" xml:"DesktopName,omitempty"`
	// The amount of the traffic. Unit: KB.
	FlowIn *string `json:"FlowIn,omitempty" xml:"FlowIn,omitempty"`
	// The traffic ranking.
	FlowRank *int32 `json:"FlowRank,omitempty" xml:"FlowRank,omitempty"`
}

func (s DescribeFlowStatisticResponseBodyDesktopFlowStatistic) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowStatisticResponseBodyDesktopFlowStatistic) GoString() string {
	return s.String()
}

func (s *DescribeFlowStatisticResponseBodyDesktopFlowStatistic) SetDesktopId(v string) *DescribeFlowStatisticResponseBodyDesktopFlowStatistic {
	s.DesktopId = &v
	return s
}

func (s *DescribeFlowStatisticResponseBodyDesktopFlowStatistic) SetDesktopName(v string) *DescribeFlowStatisticResponseBodyDesktopFlowStatistic {
	s.DesktopName = &v
	return s
}

func (s *DescribeFlowStatisticResponseBodyDesktopFlowStatistic) SetFlowIn(v string) *DescribeFlowStatisticResponseBodyDesktopFlowStatistic {
	s.FlowIn = &v
	return s
}

func (s *DescribeFlowStatisticResponseBodyDesktopFlowStatistic) SetFlowRank(v int32) *DescribeFlowStatisticResponseBodyDesktopFlowStatistic {
	s.FlowRank = &v
	return s
}

type DescribeFlowStatisticResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeFlowStatisticResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeFlowStatisticResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowStatisticResponse) GoString() string {
	return s.String()
}

func (s *DescribeFlowStatisticResponse) SetHeaders(v map[string]*string) *DescribeFlowStatisticResponse {
	s.Headers = v
	return s
}

func (s *DescribeFlowStatisticResponse) SetStatusCode(v int32) *DescribeFlowStatisticResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeFlowStatisticResponse) SetBody(v *DescribeFlowStatisticResponseBody) *DescribeFlowStatisticResponse {
	s.Body = v
	return s
}

type DescribeFotaPendingDesktopsRequest struct {
	// The cloud desktop ID.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The name of the cloud desktop.
	DesktopName *string `json:"DesktopName,omitempty" xml:"DesktopName,omitempty"`
	// The number of entries to return on each page.
	//
	// *   Maximum value: 100.
	// *   Default value: 20.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the next query. If this parameter is left empty, all results are returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](https://next.api.aliyun.com/document/ecd/2020-09-30/DescribeRegions) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the image update task. You can call the [DescribeFotaTasks](~~DescribeFotaTasks~~) operation to obtain the value of this parameter.
	TaskUid *string `json:"TaskUid,omitempty" xml:"TaskUid,omitempty"`
}

func (s DescribeFotaPendingDesktopsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeFotaPendingDesktopsRequest) GoString() string {
	return s.String()
}

func (s *DescribeFotaPendingDesktopsRequest) SetDesktopId(v string) *DescribeFotaPendingDesktopsRequest {
	s.DesktopId = &v
	return s
}

func (s *DescribeFotaPendingDesktopsRequest) SetDesktopName(v string) *DescribeFotaPendingDesktopsRequest {
	s.DesktopName = &v
	return s
}

func (s *DescribeFotaPendingDesktopsRequest) SetMaxResults(v int32) *DescribeFotaPendingDesktopsRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeFotaPendingDesktopsRequest) SetNextToken(v string) *DescribeFotaPendingDesktopsRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeFotaPendingDesktopsRequest) SetOfficeSiteId(v string) *DescribeFotaPendingDesktopsRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *DescribeFotaPendingDesktopsRequest) SetRegionId(v string) *DescribeFotaPendingDesktopsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeFotaPendingDesktopsRequest) SetTaskUid(v string) *DescribeFotaPendingDesktopsRequest {
	s.TaskUid = &v
	return s
}

type DescribeFotaPendingDesktopsResponseBody struct {
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// Details about the cloud desktops whose images can be but are not yet updated to the version that is described in an image update task (TaskUid).
	FotaPendingDesktops []*DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops `json:"FotaPendingDesktops,omitempty" xml:"FotaPendingDesktops,omitempty" type:"Repeated"`
	Message             *string                                                       `json:"Message,omitempty" xml:"Message,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. If the NextToken parameter is empty, no next page exists.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeFotaPendingDesktopsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeFotaPendingDesktopsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeFotaPendingDesktopsResponseBody) SetCode(v string) *DescribeFotaPendingDesktopsResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeFotaPendingDesktopsResponseBody) SetFotaPendingDesktops(v []*DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops) *DescribeFotaPendingDesktopsResponseBody {
	s.FotaPendingDesktops = v
	return s
}

func (s *DescribeFotaPendingDesktopsResponseBody) SetMessage(v string) *DescribeFotaPendingDesktopsResponseBody {
	s.Message = &v
	return s
}

func (s *DescribeFotaPendingDesktopsResponseBody) SetNextToken(v string) *DescribeFotaPendingDesktopsResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeFotaPendingDesktopsResponseBody) SetRequestId(v string) *DescribeFotaPendingDesktopsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops struct {
	// The current version of the image used by the cloud desktop.
	CurrentAppVersion *string `json:"CurrentAppVersion,omitempty" xml:"CurrentAppVersion,omitempty"`
	// The cloud desktop ID.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The cloud desktop name.
	DesktopName *string `json:"DesktopName,omitempty" xml:"DesktopName,omitempty"`
	FotaProject *string `json:"FotaProject,omitempty" xml:"FotaProject,omitempty"`
	// The workspace ID.
	OfficeSiteId *string                                                               `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	Sessions     []*DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktopsSessions `json:"Sessions,omitempty" xml:"Sessions,omitempty" type:"Repeated"`
	Status       *int64                                                                `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops) String() string {
	return tea.Prettify(s)
}

func (s DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops) GoString() string {
	return s.String()
}

func (s *DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops) SetCurrentAppVersion(v string) *DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops {
	s.CurrentAppVersion = &v
	return s
}

func (s *DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops) SetDesktopId(v string) *DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops {
	s.DesktopId = &v
	return s
}

func (s *DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops) SetDesktopName(v string) *DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops {
	s.DesktopName = &v
	return s
}

func (s *DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops) SetFotaProject(v string) *DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops {
	s.FotaProject = &v
	return s
}

func (s *DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops) SetOfficeSiteId(v string) *DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops {
	s.OfficeSiteId = &v
	return s
}

func (s *DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops) SetSessions(v []*DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktopsSessions) *DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops {
	s.Sessions = v
	return s
}

func (s *DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops) SetStatus(v int64) *DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops {
	s.Status = &v
	return s
}

type DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktopsSessions struct {
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
}

func (s DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktopsSessions) String() string {
	return tea.Prettify(s)
}

func (s DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktopsSessions) GoString() string {
	return s.String()
}

func (s *DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktopsSessions) SetEndUserId(v string) *DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktopsSessions {
	s.EndUserId = &v
	return s
}

type DescribeFotaPendingDesktopsResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeFotaPendingDesktopsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeFotaPendingDesktopsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeFotaPendingDesktopsResponse) GoString() string {
	return s.String()
}

func (s *DescribeFotaPendingDesktopsResponse) SetHeaders(v map[string]*string) *DescribeFotaPendingDesktopsResponse {
	s.Headers = v
	return s
}

func (s *DescribeFotaPendingDesktopsResponse) SetStatusCode(v int32) *DescribeFotaPendingDesktopsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeFotaPendingDesktopsResponse) SetBody(v *DescribeFotaPendingDesktopsResponseBody) *DescribeFotaPendingDesktopsResponse {
	s.Body = v
	return s
}

type DescribeFotaTasksRequest struct {
	// This parameter is not available.
	FotaStatus *string `json:"FotaStatus,omitempty" xml:"FotaStatus,omitempty"`
	// The language of the image version to update. Valid values:
	//
	// *   zh: Chinese
	// *   en: English
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The number of entries per page.
	//
	// *   Valid values: 1 to 100
	// *   Default value: 20
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. If the NextToken parameter is empty, no next page exists.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The IDs of the image update tasks. You can call the DescribeFotaTasks operation to obtain the value of this parameter.
	TaskUid []*string `json:"TaskUid,omitempty" xml:"TaskUid,omitempty" type:"Repeated"`
	// Specifies whether to automatically push the image update task.
	//
	// Valid values:
	//
	// *   Running
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     automatically pushes the image update task.
	//
	//     <!-- -->
	//
	// *   Pending
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     does not automatically push the image update task.
	//
	//     <!-- -->
	UserStatus *string `json:"UserStatus,omitempty" xml:"UserStatus,omitempty"`
}

func (s DescribeFotaTasksRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeFotaTasksRequest) GoString() string {
	return s.String()
}

func (s *DescribeFotaTasksRequest) SetFotaStatus(v string) *DescribeFotaTasksRequest {
	s.FotaStatus = &v
	return s
}

func (s *DescribeFotaTasksRequest) SetLang(v string) *DescribeFotaTasksRequest {
	s.Lang = &v
	return s
}

func (s *DescribeFotaTasksRequest) SetMaxResults(v int32) *DescribeFotaTasksRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeFotaTasksRequest) SetNextToken(v string) *DescribeFotaTasksRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeFotaTasksRequest) SetRegionId(v string) *DescribeFotaTasksRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeFotaTasksRequest) SetTaskUid(v []*string) *DescribeFotaTasksRequest {
	s.TaskUid = v
	return s
}

func (s *DescribeFotaTasksRequest) SetUserStatus(v string) *DescribeFotaTasksRequest {
	s.UserStatus = &v
	return s
}

type DescribeFotaTasksResponseBody struct {
	// The operation result. If the request was successful, a success message is returned. If the request failed, an error message is returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// Details about the image update task.
	FotaTasks []*DescribeFotaTasksResponseBodyFotaTasks `json:"FotaTasks,omitempty" xml:"FotaTasks,omitempty" type:"Repeated"`
	// The returned error message. This parameter is not returned if the value of Code is `success`.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// A pagination token. It can be used in the next request to retrieve a new page of results. Valid values:
	//
	// *   If **NextToken** is empty, no next page exists.
	// *   If a value is returned for **NextToken**, the value is the token that is used for the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeFotaTasksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeFotaTasksResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeFotaTasksResponseBody) SetCode(v string) *DescribeFotaTasksResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeFotaTasksResponseBody) SetFotaTasks(v []*DescribeFotaTasksResponseBodyFotaTasks) *DescribeFotaTasksResponseBody {
	s.FotaTasks = v
	return s
}

func (s *DescribeFotaTasksResponseBody) SetMessage(v string) *DescribeFotaTasksResponseBody {
	s.Message = &v
	return s
}

func (s *DescribeFotaTasksResponseBody) SetNextToken(v string) *DescribeFotaTasksResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeFotaTasksResponseBody) SetRequestId(v string) *DescribeFotaTasksResponseBody {
	s.RequestId = &v
	return s
}

type DescribeFotaTasksResponseBodyFotaTasks struct {
	// The version of the image. You can call the [DescribeImages](~~188895~~) operation to obtain this parameter.
	AppVersion *string `json:"AppVersion,omitempty" xml:"AppVersion,omitempty"`
	// This parameter is not available.
	FotaProject *string `json:"FotaProject,omitempty" xml:"FotaProject,omitempty"`
	// The number of custom images that can be updated to this version.
	PendingCustomImageCount *int32 `json:"PendingCustomImageCount,omitempty" xml:"PendingCustomImageCount,omitempty"`
	// The number of cloud desktops for which images can be updated to this version.
	PendingDesktopCount *int32 `json:"PendingDesktopCount,omitempty" xml:"PendingDesktopCount,omitempty"`
	// The time when the image version is available for update was published.
	PublishTime *string `json:"PublishTime,omitempty" xml:"PublishTime,omitempty"`
	// The description of the image version that is available for update.
	ReleaseNote *string `json:"ReleaseNote,omitempty" xml:"ReleaseNote,omitempty"`
	// The size of the image update package. Unit: KB.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
	// Indicates whether an end user can update the image.
	//
	// Valid values:
	//
	// *   valid
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The end user can update the image.
	//
	//     <!-- -->
	//
	// *   invalid
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The end user cannot update the image.
	//
	//     <!-- -->
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the image update task.
	TaskUid *string `json:"TaskUid,omitempty" xml:"TaskUid,omitempty"`
}

func (s DescribeFotaTasksResponseBodyFotaTasks) String() string {
	return tea.Prettify(s)
}

func (s DescribeFotaTasksResponseBodyFotaTasks) GoString() string {
	return s.String()
}

func (s *DescribeFotaTasksResponseBodyFotaTasks) SetAppVersion(v string) *DescribeFotaTasksResponseBodyFotaTasks {
	s.AppVersion = &v
	return s
}

func (s *DescribeFotaTasksResponseBodyFotaTasks) SetFotaProject(v string) *DescribeFotaTasksResponseBodyFotaTasks {
	s.FotaProject = &v
	return s
}

func (s *DescribeFotaTasksResponseBodyFotaTasks) SetPendingCustomImageCount(v int32) *DescribeFotaTasksResponseBodyFotaTasks {
	s.PendingCustomImageCount = &v
	return s
}

func (s *DescribeFotaTasksResponseBodyFotaTasks) SetPendingDesktopCount(v int32) *DescribeFotaTasksResponseBodyFotaTasks {
	s.PendingDesktopCount = &v
	return s
}

func (s *DescribeFotaTasksResponseBodyFotaTasks) SetPublishTime(v string) *DescribeFotaTasksResponseBodyFotaTasks {
	s.PublishTime = &v
	return s
}

func (s *DescribeFotaTasksResponseBodyFotaTasks) SetReleaseNote(v string) *DescribeFotaTasksResponseBodyFotaTasks {
	s.ReleaseNote = &v
	return s
}

func (s *DescribeFotaTasksResponseBodyFotaTasks) SetSize(v int32) *DescribeFotaTasksResponseBodyFotaTasks {
	s.Size = &v
	return s
}

func (s *DescribeFotaTasksResponseBodyFotaTasks) SetStatus(v string) *DescribeFotaTasksResponseBodyFotaTasks {
	s.Status = &v
	return s
}

func (s *DescribeFotaTasksResponseBodyFotaTasks) SetTaskUid(v string) *DescribeFotaTasksResponseBodyFotaTasks {
	s.TaskUid = &v
	return s
}

type DescribeFotaTasksResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeFotaTasksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeFotaTasksResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeFotaTasksResponse) GoString() string {
	return s.String()
}

func (s *DescribeFotaTasksResponse) SetHeaders(v map[string]*string) *DescribeFotaTasksResponse {
	s.Headers = v
	return s
}

func (s *DescribeFotaTasksResponse) SetStatusCode(v int32) *DescribeFotaTasksResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeFotaTasksResponse) SetBody(v *DescribeFotaTasksResponseBody) *DescribeFotaTasksResponse {
	s.Body = v
	return s
}

type DescribeGuestApplicationsRequest struct {
	// The cloud desktop ID.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The end user ID.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeGuestApplicationsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeGuestApplicationsRequest) GoString() string {
	return s.String()
}

func (s *DescribeGuestApplicationsRequest) SetDesktopId(v string) *DescribeGuestApplicationsRequest {
	s.DesktopId = &v
	return s
}

func (s *DescribeGuestApplicationsRequest) SetEndUserId(v string) *DescribeGuestApplicationsRequest {
	s.EndUserId = &v
	return s
}

func (s *DescribeGuestApplicationsRequest) SetRegionId(v string) *DescribeGuestApplicationsRequest {
	s.RegionId = &v
	return s
}

type DescribeGuestApplicationsResponseBody struct {
	// The application details.
	Applications []*DescribeGuestApplicationsResponseBodyApplications `json:"Applications,omitempty" xml:"Applications,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeGuestApplicationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeGuestApplicationsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeGuestApplicationsResponseBody) SetApplications(v []*DescribeGuestApplicationsResponseBodyApplications) *DescribeGuestApplicationsResponseBody {
	s.Applications = v
	return s
}

func (s *DescribeGuestApplicationsResponseBody) SetRequestId(v string) *DescribeGuestApplicationsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeGuestApplicationsResponseBodyApplications struct {
	// The application name.
	ApplicationName *string `json:"ApplicationName,omitempty" xml:"ApplicationName,omitempty"`
	// The application version.
	ApplicationVersion *string `json:"ApplicationVersion,omitempty" xml:"ApplicationVersion,omitempty"`
	// The CPU usage.
	CpuPercent *float64 `json:"CpuPercent,omitempty" xml:"CpuPercent,omitempty"`
	// The GPU usage.
	GpuPercent *float64 `json:"GpuPercent,omitempty" xml:"GpuPercent,omitempty"`
	// The icon address of the application.
	IconUrl *string `json:"IconUrl,omitempty" xml:"IconUrl,omitempty"`
	// The I/O read and write performance.
	IoSpeed *float64 `json:"IoSpeed,omitempty" xml:"IoSpeed,omitempty"`
	// The memory usage.
	MemPercent *float64 `json:"MemPercent,omitempty" xml:"MemPercent,omitempty"`
	// The process ID.
	Pid *int32 `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The process information.
	ProcessData []*DescribeGuestApplicationsResponseBodyApplicationsProcessData `json:"ProcessData,omitempty" xml:"ProcessData,omitempty" type:"Repeated"`
	// The path to the process.
	ProcessPath *string `json:"ProcessPath,omitempty" xml:"ProcessPath,omitempty"`
	// The application status.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeGuestApplicationsResponseBodyApplications) String() string {
	return tea.Prettify(s)
}

func (s DescribeGuestApplicationsResponseBodyApplications) GoString() string {
	return s.String()
}

func (s *DescribeGuestApplicationsResponseBodyApplications) SetApplicationName(v string) *DescribeGuestApplicationsResponseBodyApplications {
	s.ApplicationName = &v
	return s
}

func (s *DescribeGuestApplicationsResponseBodyApplications) SetApplicationVersion(v string) *DescribeGuestApplicationsResponseBodyApplications {
	s.ApplicationVersion = &v
	return s
}

func (s *DescribeGuestApplicationsResponseBodyApplications) SetCpuPercent(v float64) *DescribeGuestApplicationsResponseBodyApplications {
	s.CpuPercent = &v
	return s
}

func (s *DescribeGuestApplicationsResponseBodyApplications) SetGpuPercent(v float64) *DescribeGuestApplicationsResponseBodyApplications {
	s.GpuPercent = &v
	return s
}

func (s *DescribeGuestApplicationsResponseBodyApplications) SetIconUrl(v string) *DescribeGuestApplicationsResponseBodyApplications {
	s.IconUrl = &v
	return s
}

func (s *DescribeGuestApplicationsResponseBodyApplications) SetIoSpeed(v float64) *DescribeGuestApplicationsResponseBodyApplications {
	s.IoSpeed = &v
	return s
}

func (s *DescribeGuestApplicationsResponseBodyApplications) SetMemPercent(v float64) *DescribeGuestApplicationsResponseBodyApplications {
	s.MemPercent = &v
	return s
}

func (s *DescribeGuestApplicationsResponseBodyApplications) SetPid(v int32) *DescribeGuestApplicationsResponseBodyApplications {
	s.Pid = &v
	return s
}

func (s *DescribeGuestApplicationsResponseBodyApplications) SetProcessData(v []*DescribeGuestApplicationsResponseBodyApplicationsProcessData) *DescribeGuestApplicationsResponseBodyApplications {
	s.ProcessData = v
	return s
}

func (s *DescribeGuestApplicationsResponseBodyApplications) SetProcessPath(v string) *DescribeGuestApplicationsResponseBodyApplications {
	s.ProcessPath = &v
	return s
}

func (s *DescribeGuestApplicationsResponseBodyApplications) SetStatus(v string) *DescribeGuestApplicationsResponseBodyApplications {
	s.Status = &v
	return s
}

type DescribeGuestApplicationsResponseBodyApplicationsProcessData struct {
	// The application name.
	ApplicationName *string `json:"ApplicationName,omitempty" xml:"ApplicationName,omitempty"`
	// The application version.
	ApplicationVersion *string `json:"ApplicationVersion,omitempty" xml:"ApplicationVersion,omitempty"`
	// The CPU usage.
	CpuPercent *float64 `json:"CpuPercent,omitempty" xml:"CpuPercent,omitempty"`
	// The GPU usage.
	GpuPercent *float64 `json:"GpuPercent,omitempty" xml:"GpuPercent,omitempty"`
	// The I/O read and write performance.
	Iospeed *float64 `json:"Iospeed,omitempty" xml:"Iospeed,omitempty"`
	// The memory usage.
	MemPercent *float64 `json:"MemPercent,omitempty" xml:"MemPercent,omitempty"`
	// The process ID.
	Pid *int32 `json:"Pid,omitempty" xml:"Pid,omitempty"`
	// The path to the process.
	ProcessPath *string `json:"ProcessPath,omitempty" xml:"ProcessPath,omitempty"`
}

func (s DescribeGuestApplicationsResponseBodyApplicationsProcessData) String() string {
	return tea.Prettify(s)
}

func (s DescribeGuestApplicationsResponseBodyApplicationsProcessData) GoString() string {
	return s.String()
}

func (s *DescribeGuestApplicationsResponseBodyApplicationsProcessData) SetApplicationName(v string) *DescribeGuestApplicationsResponseBodyApplicationsProcessData {
	s.ApplicationName = &v
	return s
}

func (s *DescribeGuestApplicationsResponseBodyApplicationsProcessData) SetApplicationVersion(v string) *DescribeGuestApplicationsResponseBodyApplicationsProcessData {
	s.ApplicationVersion = &v
	return s
}

func (s *DescribeGuestApplicationsResponseBodyApplicationsProcessData) SetCpuPercent(v float64) *DescribeGuestApplicationsResponseBodyApplicationsProcessData {
	s.CpuPercent = &v
	return s
}

func (s *DescribeGuestApplicationsResponseBodyApplicationsProcessData) SetGpuPercent(v float64) *DescribeGuestApplicationsResponseBodyApplicationsProcessData {
	s.GpuPercent = &v
	return s
}

func (s *DescribeGuestApplicationsResponseBodyApplicationsProcessData) SetIospeed(v float64) *DescribeGuestApplicationsResponseBodyApplicationsProcessData {
	s.Iospeed = &v
	return s
}

func (s *DescribeGuestApplicationsResponseBodyApplicationsProcessData) SetMemPercent(v float64) *DescribeGuestApplicationsResponseBodyApplicationsProcessData {
	s.MemPercent = &v
	return s
}

func (s *DescribeGuestApplicationsResponseBodyApplicationsProcessData) SetPid(v int32) *DescribeGuestApplicationsResponseBodyApplicationsProcessData {
	s.Pid = &v
	return s
}

func (s *DescribeGuestApplicationsResponseBodyApplicationsProcessData) SetProcessPath(v string) *DescribeGuestApplicationsResponseBodyApplicationsProcessData {
	s.ProcessPath = &v
	return s
}

type DescribeGuestApplicationsResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeGuestApplicationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeGuestApplicationsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeGuestApplicationsResponse) GoString() string {
	return s.String()
}

func (s *DescribeGuestApplicationsResponse) SetHeaders(v map[string]*string) *DescribeGuestApplicationsResponse {
	s.Headers = v
	return s
}

func (s *DescribeGuestApplicationsResponse) SetStatusCode(v int32) *DescribeGuestApplicationsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeGuestApplicationsResponse) SetBody(v *DescribeGuestApplicationsResponseBody) *DescribeGuestApplicationsResponse {
	s.Body = v
	return s
}

type DescribeImageModifiedRecordsRequest struct {
	// The ID of the cloud desktop.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The maximum number of entries to return on each page.
	//
	// *   Maximum value: 100.
	// *   Default value: 10.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the next query. If this parameter is left empty, all results are returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeImageModifiedRecordsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeImageModifiedRecordsRequest) GoString() string {
	return s.String()
}

func (s *DescribeImageModifiedRecordsRequest) SetDesktopId(v string) *DescribeImageModifiedRecordsRequest {
	s.DesktopId = &v
	return s
}

func (s *DescribeImageModifiedRecordsRequest) SetMaxResults(v int32) *DescribeImageModifiedRecordsRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeImageModifiedRecordsRequest) SetNextToken(v string) *DescribeImageModifiedRecordsRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeImageModifiedRecordsRequest) SetRegionId(v string) *DescribeImageModifiedRecordsRequest {
	s.RegionId = &v
	return s
}

type DescribeImageModifiedRecordsResponseBody struct {
	// The image modification record collection.
	ImageModifiedRecords []*DescribeImageModifiedRecordsResponseBodyImageModifiedRecords `json:"ImageModifiedRecords,omitempty" xml:"ImageModifiedRecords,omitempty" type:"Repeated"`
	// If the NextToken parameter is empty, no next page exists.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of image modification records.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeImageModifiedRecordsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeImageModifiedRecordsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeImageModifiedRecordsResponseBody) SetImageModifiedRecords(v []*DescribeImageModifiedRecordsResponseBodyImageModifiedRecords) *DescribeImageModifiedRecordsResponseBody {
	s.ImageModifiedRecords = v
	return s
}

func (s *DescribeImageModifiedRecordsResponseBody) SetNextToken(v string) *DescribeImageModifiedRecordsResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeImageModifiedRecordsResponseBody) SetRequestId(v string) *DescribeImageModifiedRecordsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeImageModifiedRecordsResponseBody) SetTotalCount(v int32) *DescribeImageModifiedRecordsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeImageModifiedRecordsResponseBodyImageModifiedRecords struct {
	// The ID of the image before the change.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The name of the image before the change.
	ImageName *string `json:"ImageName,omitempty" xml:"ImageName,omitempty"`
	// The ID of the new image.
	NewImageId *string `json:"NewImageId,omitempty" xml:"NewImageId,omitempty"`
	// Add the image name.
	NewImageName *string `json:"NewImageName,omitempty" xml:"NewImageName,omitempty"`
	// The status of the workspace.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The last time when the disaster recovery plan was updated.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s DescribeImageModifiedRecordsResponseBodyImageModifiedRecords) String() string {
	return tea.Prettify(s)
}

func (s DescribeImageModifiedRecordsResponseBodyImageModifiedRecords) GoString() string {
	return s.String()
}

func (s *DescribeImageModifiedRecordsResponseBodyImageModifiedRecords) SetImageId(v string) *DescribeImageModifiedRecordsResponseBodyImageModifiedRecords {
	s.ImageId = &v
	return s
}

func (s *DescribeImageModifiedRecordsResponseBodyImageModifiedRecords) SetImageName(v string) *DescribeImageModifiedRecordsResponseBodyImageModifiedRecords {
	s.ImageName = &v
	return s
}

func (s *DescribeImageModifiedRecordsResponseBodyImageModifiedRecords) SetNewImageId(v string) *DescribeImageModifiedRecordsResponseBodyImageModifiedRecords {
	s.NewImageId = &v
	return s
}

func (s *DescribeImageModifiedRecordsResponseBodyImageModifiedRecords) SetNewImageName(v string) *DescribeImageModifiedRecordsResponseBodyImageModifiedRecords {
	s.NewImageName = &v
	return s
}

func (s *DescribeImageModifiedRecordsResponseBodyImageModifiedRecords) SetStatus(v int32) *DescribeImageModifiedRecordsResponseBodyImageModifiedRecords {
	s.Status = &v
	return s
}

func (s *DescribeImageModifiedRecordsResponseBodyImageModifiedRecords) SetUpdateTime(v string) *DescribeImageModifiedRecordsResponseBodyImageModifiedRecords {
	s.UpdateTime = &v
	return s
}

type DescribeImageModifiedRecordsResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeImageModifiedRecordsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeImageModifiedRecordsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeImageModifiedRecordsResponse) GoString() string {
	return s.String()
}

func (s *DescribeImageModifiedRecordsResponse) SetHeaders(v map[string]*string) *DescribeImageModifiedRecordsResponse {
	s.Headers = v
	return s
}

func (s *DescribeImageModifiedRecordsResponse) SetStatusCode(v int32) *DescribeImageModifiedRecordsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeImageModifiedRecordsResponse) SetBody(v *DescribeImageModifiedRecordsResponseBody) *DescribeImageModifiedRecordsResponse {
	s.Body = v
	return s
}

type DescribeImagePermissionRequest struct {
	// The image ID.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeImagePermissionRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeImagePermissionRequest) GoString() string {
	return s.String()
}

func (s *DescribeImagePermissionRequest) SetImageId(v string) *DescribeImagePermissionRequest {
	s.ImageId = &v
	return s
}

func (s *DescribeImagePermissionRequest) SetRegionId(v string) *DescribeImagePermissionRequest {
	s.RegionId = &v
	return s
}

type DescribeImagePermissionResponseBody struct {
	// The IDs of the recipient Alibaba Cloud accounts. You can share an image with up to 50 Alibaba Cloud accounts.
	AliUids []*string `json:"AliUids,omitempty" xml:"AliUids,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeImagePermissionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeImagePermissionResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeImagePermissionResponseBody) SetAliUids(v []*string) *DescribeImagePermissionResponseBody {
	s.AliUids = v
	return s
}

func (s *DescribeImagePermissionResponseBody) SetRequestId(v string) *DescribeImagePermissionResponseBody {
	s.RequestId = &v
	return s
}

type DescribeImagePermissionResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeImagePermissionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeImagePermissionResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeImagePermissionResponse) GoString() string {
	return s.String()
}

func (s *DescribeImagePermissionResponse) SetHeaders(v map[string]*string) *DescribeImagePermissionResponse {
	s.Headers = v
	return s
}

func (s *DescribeImagePermissionResponse) SetStatusCode(v int32) *DescribeImagePermissionResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeImagePermissionResponse) SetBody(v *DescribeImagePermissionResponseBody) *DescribeImagePermissionResponse {
	s.Body = v
	return s
}

type DescribeImagesRequest struct {
	// The cloud desktop type. You can call the [DescribeBundles](~~188884~~) operation to query the available cloud desktop types.
	DesktopInstanceType *string `json:"DesktopInstanceType,omitempty" xml:"DesktopInstanceType,omitempty"`
	// The image version.
	FotaVersion *string `json:"FotaVersion,omitempty" xml:"FotaVersion,omitempty"`
	// Specifies whether the image is a GPU-accelerated image.
	GpuCategory *bool `json:"GpuCategory,omitempty" xml:"GpuCategory,omitempty"`
	// The version of the GPU driver.
	GpuDriverVersion *string `json:"GpuDriverVersion,omitempty" xml:"GpuDriverVersion,omitempty"`
	// The IDs of the images. You can specify one or more image IDs.
	ImageId []*string `json:"ImageId,omitempty" xml:"ImageId,omitempty" type:"Repeated"`
	// The image name.
	ImageName *string `json:"ImageName,omitempty" xml:"ImageName,omitempty"`
	// The state of the image.
	ImageStatus *string `json:"ImageStatus,omitempty" xml:"ImageStatus,omitempty"`
	// The type of the image.
	ImageType *string `json:"ImageType,omitempty" xml:"ImageType,omitempty"`
	// The language of the OS.
	LanguageType *string `json:"LanguageType,omitempty" xml:"LanguageType,omitempty"`
	// The maximum number of entries to return on each page.
	//
	// *   Maximum value: 100.
	// *   Default value: 10.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the next query. If you do not specify this parameter, all results are returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The type of the OS. Default value: `null`.
	OsType *string `json:"OsType,omitempty" xml:"OsType,omitempty"`
	// The type of the protocol.
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The session type.
	SessionType *string `json:"SessionType,omitempty" xml:"SessionType,omitempty"`
}

func (s DescribeImagesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeImagesRequest) GoString() string {
	return s.String()
}

func (s *DescribeImagesRequest) SetDesktopInstanceType(v string) *DescribeImagesRequest {
	s.DesktopInstanceType = &v
	return s
}

func (s *DescribeImagesRequest) SetFotaVersion(v string) *DescribeImagesRequest {
	s.FotaVersion = &v
	return s
}

func (s *DescribeImagesRequest) SetGpuCategory(v bool) *DescribeImagesRequest {
	s.GpuCategory = &v
	return s
}

func (s *DescribeImagesRequest) SetGpuDriverVersion(v string) *DescribeImagesRequest {
	s.GpuDriverVersion = &v
	return s
}

func (s *DescribeImagesRequest) SetImageId(v []*string) *DescribeImagesRequest {
	s.ImageId = v
	return s
}

func (s *DescribeImagesRequest) SetImageName(v string) *DescribeImagesRequest {
	s.ImageName = &v
	return s
}

func (s *DescribeImagesRequest) SetImageStatus(v string) *DescribeImagesRequest {
	s.ImageStatus = &v
	return s
}

func (s *DescribeImagesRequest) SetImageType(v string) *DescribeImagesRequest {
	s.ImageType = &v
	return s
}

func (s *DescribeImagesRequest) SetLanguageType(v string) *DescribeImagesRequest {
	s.LanguageType = &v
	return s
}

func (s *DescribeImagesRequest) SetMaxResults(v int32) *DescribeImagesRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeImagesRequest) SetNextToken(v string) *DescribeImagesRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeImagesRequest) SetOsType(v string) *DescribeImagesRequest {
	s.OsType = &v
	return s
}

func (s *DescribeImagesRequest) SetProtocolType(v string) *DescribeImagesRequest {
	s.ProtocolType = &v
	return s
}

func (s *DescribeImagesRequest) SetRegionId(v string) *DescribeImagesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeImagesRequest) SetSessionType(v string) *DescribeImagesRequest {
	s.SessionType = &v
	return s
}

type DescribeImagesResponseBody struct {
	// The details of the images.
	Images []*DescribeImagesResponseBodyImages `json:"Images,omitempty" xml:"Images,omitempty" type:"Repeated"`
	// The token that determines the start point of the next query. If this parameter is empty, all results are returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeImagesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeImagesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeImagesResponseBody) SetImages(v []*DescribeImagesResponseBodyImages) *DescribeImagesResponseBody {
	s.Images = v
	return s
}

func (s *DescribeImagesResponseBody) SetNextToken(v string) *DescribeImagesResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeImagesResponseBody) SetRequestId(v string) *DescribeImagesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeImagesResponseBodyImages struct {
	// The version of the image.
	AppVersion *string `json:"AppVersion,omitempty" xml:"AppVersion,omitempty"`
	// The time when the image was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The size of the data disk. Unit: GiB.
	DataDiskSize *int32 `json:"DataDiskSize,omitempty" xml:"DataDiskSize,omitempty"`
	// The description of the image.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the image is a GPU-accelerated image.
	GpuCategory *bool `json:"GpuCategory,omitempty" xml:"GpuCategory,omitempty"`
	// The version of the GPU driver.
	GpuDriverVersion *string `json:"GpuDriverVersion,omitempty" xml:"GpuDriverVersion,omitempty"`
	// The ID of the image.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The type of the image.
	ImageType *string `json:"ImageType,omitempty" xml:"ImageType,omitempty"`
	// The name of the image.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The OS type of the image.
	OsType *string `json:"OsType,omitempty" xml:"OsType,omitempty"`
	// The OS type of the image.
	Platform *string `json:"Platform,omitempty" xml:"Platform,omitempty"`
	// The progress of image creation. Unit: percentage (%).
	Progress *string `json:"Progress,omitempty" xml:"Progress,omitempty"`
	// The type of the protocol.
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The session type of the image. Valid values:
	//
	// *   SINGLE_SESSION: single-session images
	// *   MULTIPLE_SESSION: multi-session images
	SessionType *string `json:"SessionType,omitempty" xml:"SessionType,omitempty"`
	// The number of shared images.
	SharedCount *int32 `json:"SharedCount,omitempty" xml:"SharedCount,omitempty"`
	// The size of the image. Unit: GiB.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The state of the image.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The languages of the OS.
	SupportedLanguages []*string `json:"SupportedLanguages,omitempty" xml:"SupportedLanguages,omitempty" type:"Repeated"`
	// The time when the image was last modified.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// Indicates whether disk encryption is enabled.
	VolumeEncryptionEnabled *bool `json:"VolumeEncryptionEnabled,omitempty" xml:"VolumeEncryptionEnabled,omitempty"`
	// The ID of the Key Management Service (KMS) key that is used when disk encryption is enabled. You can call the [ListKeys](~~28951~~) operation to obtain the list of KMS keys.
	VolumeEncryptionKey *string `json:"VolumeEncryptionKey,omitempty" xml:"VolumeEncryptionKey,omitempty"`
}

func (s DescribeImagesResponseBodyImages) String() string {
	return tea.Prettify(s)
}

func (s DescribeImagesResponseBodyImages) GoString() string {
	return s.String()
}

func (s *DescribeImagesResponseBodyImages) SetAppVersion(v string) *DescribeImagesResponseBodyImages {
	s.AppVersion = &v
	return s
}

func (s *DescribeImagesResponseBodyImages) SetCreationTime(v string) *DescribeImagesResponseBodyImages {
	s.CreationTime = &v
	return s
}

func (s *DescribeImagesResponseBodyImages) SetDataDiskSize(v int32) *DescribeImagesResponseBodyImages {
	s.DataDiskSize = &v
	return s
}

func (s *DescribeImagesResponseBodyImages) SetDescription(v string) *DescribeImagesResponseBodyImages {
	s.Description = &v
	return s
}

func (s *DescribeImagesResponseBodyImages) SetGpuCategory(v bool) *DescribeImagesResponseBodyImages {
	s.GpuCategory = &v
	return s
}

func (s *DescribeImagesResponseBodyImages) SetGpuDriverVersion(v string) *DescribeImagesResponseBodyImages {
	s.GpuDriverVersion = &v
	return s
}

func (s *DescribeImagesResponseBodyImages) SetImageId(v string) *DescribeImagesResponseBodyImages {
	s.ImageId = &v
	return s
}

func (s *DescribeImagesResponseBodyImages) SetImageType(v string) *DescribeImagesResponseBodyImages {
	s.ImageType = &v
	return s
}

func (s *DescribeImagesResponseBodyImages) SetName(v string) *DescribeImagesResponseBodyImages {
	s.Name = &v
	return s
}

func (s *DescribeImagesResponseBodyImages) SetOsType(v string) *DescribeImagesResponseBodyImages {
	s.OsType = &v
	return s
}

func (s *DescribeImagesResponseBodyImages) SetPlatform(v string) *DescribeImagesResponseBodyImages {
	s.Platform = &v
	return s
}

func (s *DescribeImagesResponseBodyImages) SetProgress(v string) *DescribeImagesResponseBodyImages {
	s.Progress = &v
	return s
}

func (s *DescribeImagesResponseBodyImages) SetProtocolType(v string) *DescribeImagesResponseBodyImages {
	s.ProtocolType = &v
	return s
}

func (s *DescribeImagesResponseBodyImages) SetSessionType(v string) *DescribeImagesResponseBodyImages {
	s.SessionType = &v
	return s
}

func (s *DescribeImagesResponseBodyImages) SetSharedCount(v int32) *DescribeImagesResponseBodyImages {
	s.SharedCount = &v
	return s
}

func (s *DescribeImagesResponseBodyImages) SetSize(v int32) *DescribeImagesResponseBodyImages {
	s.Size = &v
	return s
}

func (s *DescribeImagesResponseBodyImages) SetStatus(v string) *DescribeImagesResponseBodyImages {
	s.Status = &v
	return s
}

func (s *DescribeImagesResponseBodyImages) SetSupportedLanguages(v []*string) *DescribeImagesResponseBodyImages {
	s.SupportedLanguages = v
	return s
}

func (s *DescribeImagesResponseBodyImages) SetUpdateTime(v string) *DescribeImagesResponseBodyImages {
	s.UpdateTime = &v
	return s
}

func (s *DescribeImagesResponseBodyImages) SetVolumeEncryptionEnabled(v bool) *DescribeImagesResponseBodyImages {
	s.VolumeEncryptionEnabled = &v
	return s
}

func (s *DescribeImagesResponseBodyImages) SetVolumeEncryptionKey(v string) *DescribeImagesResponseBodyImages {
	s.VolumeEncryptionKey = &v
	return s
}

type DescribeImagesResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeImagesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeImagesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeImagesResponse) GoString() string {
	return s.String()
}

func (s *DescribeImagesResponse) SetHeaders(v map[string]*string) *DescribeImagesResponse {
	s.Headers = v
	return s
}

func (s *DescribeImagesResponse) SetStatusCode(v int32) *DescribeImagesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeImagesResponse) SetBody(v *DescribeImagesResponseBody) *DescribeImagesResponse {
	s.Body = v
	return s
}

type DescribeInvocationsRequest struct {
	// The type of the command. Valid values:
	//
	// *   RunBatScript
	// *   RunPowerShellScript
	CommandType *string `json:"CommandType,omitempty" xml:"CommandType,omitempty"`
	// The encoding method of the command content and output. Valid values:
	//
	// *   PlainText
	// *   Base64
	//
	// Default value: Base64.
	ContentEncoding *string `json:"ContentEncoding,omitempty" xml:"ContentEncoding,omitempty"`
	// The ID of the cloud desktop. If you specify a cloud desktop, all the execution records of Cloud Assistant commands on the cloud desktop are queried.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The IDs of the cloud desktops.
	DesktopIds []*string `json:"DesktopIds,omitempty" xml:"DesktopIds,omitempty" type:"Repeated"`
	// The ID of the end user.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// Specifies whether to return command outputs in the response. Valid values:
	//
	// *   true: returns command outputs.
	// *   false: does not return command outputs.
	//
	// Default value: false.
	IncludeOutput *bool `json:"IncludeOutput,omitempty" xml:"IncludeOutput,omitempty"`
	// The ID of the execution.
	InvokeId *string `json:"InvokeId,omitempty" xml:"InvokeId,omitempty"`
	// The overall execution status of a command. The overall execution status is determined by the execution status of the command on one or more cloud desktops. Valid values:
	//
	// *   Running: The execution is in progress on one or more cloud desktops.
	// *   Finished: The execution is finished on all cloud desktops, or the execution is manually stopped on some cloud desktops and the execution is finished on others.
	// *   Failed: The execution failed on all cloud desktops.
	// *   PartialFailed: The execution failed on some cloud desktops.
	// *   Stopped: The execution is stopped.
	//
	// Default value: Running.
	InvokeStatus *string `json:"InvokeStatus,omitempty" xml:"InvokeStatus,omitempty"`
	// The number of entries to return on each page.
	//
	// Default value: 100.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The query token. Set the value to the NextToken value that is returned from the last call to the previous DescribeInvocations operation.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeInvocationsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeInvocationsRequest) GoString() string {
	return s.String()
}

func (s *DescribeInvocationsRequest) SetCommandType(v string) *DescribeInvocationsRequest {
	s.CommandType = &v
	return s
}

func (s *DescribeInvocationsRequest) SetContentEncoding(v string) *DescribeInvocationsRequest {
	s.ContentEncoding = &v
	return s
}

func (s *DescribeInvocationsRequest) SetDesktopId(v string) *DescribeInvocationsRequest {
	s.DesktopId = &v
	return s
}

func (s *DescribeInvocationsRequest) SetDesktopIds(v []*string) *DescribeInvocationsRequest {
	s.DesktopIds = v
	return s
}

func (s *DescribeInvocationsRequest) SetEndUserId(v string) *DescribeInvocationsRequest {
	s.EndUserId = &v
	return s
}

func (s *DescribeInvocationsRequest) SetIncludeOutput(v bool) *DescribeInvocationsRequest {
	s.IncludeOutput = &v
	return s
}

func (s *DescribeInvocationsRequest) SetInvokeId(v string) *DescribeInvocationsRequest {
	s.InvokeId = &v
	return s
}

func (s *DescribeInvocationsRequest) SetInvokeStatus(v string) *DescribeInvocationsRequest {
	s.InvokeStatus = &v
	return s
}

func (s *DescribeInvocationsRequest) SetMaxResults(v int32) *DescribeInvocationsRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeInvocationsRequest) SetNextToken(v string) *DescribeInvocationsRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeInvocationsRequest) SetRegionId(v string) *DescribeInvocationsRequest {
	s.RegionId = &v
	return s
}

type DescribeInvocationsResponseBody struct {
	// Details about execution records of the command.
	Invocations []*DescribeInvocationsResponseBodyInvocations `json:"Invocations,omitempty" xml:"Invocations,omitempty" type:"Repeated"`
	// The query token that is returned from this call.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeInvocationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeInvocationsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeInvocationsResponseBody) SetInvocations(v []*DescribeInvocationsResponseBodyInvocations) *DescribeInvocationsResponseBody {
	s.Invocations = v
	return s
}

func (s *DescribeInvocationsResponseBody) SetNextToken(v string) *DescribeInvocationsResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeInvocationsResponseBody) SetRequestId(v string) *DescribeInvocationsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeInvocationsResponseBodyInvocations struct {
	// The Base64-encoded command content.
	CommandContent *string `json:"CommandContent,omitempty" xml:"CommandContent,omitempty"`
	// The type of the command.
	CommandType *string `json:"CommandType,omitempty" xml:"CommandType,omitempty"`
	// The time when the execution task is created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	EndUserId    *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The overall execution status of the command. The overall execution status is determined by the execution status on all involved cloud desktops. The valid values include:
	//
	// *   Pending: The system is verifying or sending the command. If the execution status on at least one cloud desktop is Pending, the overall execution status is Pending.
	//
	// *   Running: The execution is in progress on cloud desktops. If the execution status on at least one cloud desktop is Running, the overall execution status is Running.
	//
	// *   Success: If the execution status on all cloud desktops is Success or Stopped, or the execution status on at least one cloud desktop is Success, the overall execution status is Success.
	//
	// *   Failed: If the execution status on all cloud desktops is Stopped or Failed, the overall execution status is Failed. If one or more execution status of a cloud desktop is one of the following values, Failed is returned:
	//
	//     *   Invalid: The command is invalid.
	//     *   Aborted: The command fails to be sent.
	//     *   Failed: The command is executed, but the exit code is not 0.
	//     *   Timeout: The command times out.
	//     *   Error: An error occurs in the command.
	//
	// *   Stopping: The execution is being stopped. If the execution status on at least one cloud desktop is Stopping, the overall execution state is Stopping.
	//
	// *   Stopped: The execution is stopped. If the execution status on all cloud desktops is Stopped, the overall execution state is Stopped. If the execution status on a cloud desktop is one of the following values, Stopped is returned:
	//
	//     *   Cancelled: The execution is canceled.
	//     *   Terminated: The execution is terminated.
	//
	// *   PartialFailed: The execution succeeded on some cloud desktops and failed on others. If the execution status on different cloud desktops is Success, Failed, or Stopped, the overall execution state is PartialFailed.
	InvocationStatus *string `json:"InvocationStatus,omitempty" xml:"InvocationStatus,omitempty"`
	// The cloud desktops on which the command is executed.
	InvokeDesktops []*DescribeInvocationsResponseBodyInvocationsInvokeDesktops `json:"InvokeDesktops,omitempty" xml:"InvokeDesktops,omitempty" type:"Repeated"`
	// The ID of the execution.
	InvokeId *string `json:"InvokeId,omitempty" xml:"InvokeId,omitempty"`
}

func (s DescribeInvocationsResponseBodyInvocations) String() string {
	return tea.Prettify(s)
}

func (s DescribeInvocationsResponseBodyInvocations) GoString() string {
	return s.String()
}

func (s *DescribeInvocationsResponseBodyInvocations) SetCommandContent(v string) *DescribeInvocationsResponseBodyInvocations {
	s.CommandContent = &v
	return s
}

func (s *DescribeInvocationsResponseBodyInvocations) SetCommandType(v string) *DescribeInvocationsResponseBodyInvocations {
	s.CommandType = &v
	return s
}

func (s *DescribeInvocationsResponseBodyInvocations) SetCreationTime(v string) *DescribeInvocationsResponseBodyInvocations {
	s.CreationTime = &v
	return s
}

func (s *DescribeInvocationsResponseBodyInvocations) SetEndUserId(v string) *DescribeInvocationsResponseBodyInvocations {
	s.EndUserId = &v
	return s
}

func (s *DescribeInvocationsResponseBodyInvocations) SetInvocationStatus(v string) *DescribeInvocationsResponseBodyInvocations {
	s.InvocationStatus = &v
	return s
}

func (s *DescribeInvocationsResponseBodyInvocations) SetInvokeDesktops(v []*DescribeInvocationsResponseBodyInvocationsInvokeDesktops) *DescribeInvocationsResponseBodyInvocations {
	s.InvokeDesktops = v
	return s
}

func (s *DescribeInvocationsResponseBodyInvocations) SetInvokeId(v string) *DescribeInvocationsResponseBodyInvocations {
	s.InvokeId = &v
	return s
}

type DescribeInvocationsResponseBodyInvocationsInvokeDesktops struct {
	// The time when the command execution was performed.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The ID of the cloud desktop.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The name of the cloud desktop.
	DesktopName *string `json:"DesktopName,omitempty" xml:"DesktopName,omitempty"`
	// The size of the text that is truncated and discarded when the Output value exceeds 24 KB in size.
	Dropped *int32 `json:"Dropped,omitempty" xml:"Dropped,omitempty"`
	// The code that indicates the reason why a command failed to be sent or executed. The valid values include:
	//
	// *   If this parameter is empty, the execution is normal.
	// *   InstanceNotExists: The specified cloud desktop does not exist or is released.
	// *   InstanceReleased: The cloud desktop is released during the execution.
	// *   InstanceNotRunning: The cloud desktop is not running during the execution.
	// *   CommandNotApplicable: The command cannot be used on the cloud desktop.
	// *   ClientNotRunning: The Cloud Assistant client is not running.
	// *   ClientNotResponse: The Cloud Assistant client does not respond.
	// *   ClientIsUpgrading: The Cloud Assistant client is being upgraded.
	// *   ClientNeedUpgrade: The Cloud Assistant client needs to be upgraded.
	// *   DeliveryTimeout: The time to send the command in the request times out.
	// *   ExecutionTimeout: The execution times out.
	// *   ExecutionException: An exception occurs during the execution.
	// *   ExecutionInterrupted: The execution is interrupted.
	// *   ExitCodeNonzero: The execution finishes, but the exit code is not 0.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Details about the reason why the command failed to be sent or executed. The valid values include:
	//
	// *   If this parameter is empty, the execution is normal.
	// *   the specified instance does not exists: The cloud desktop does not exist or is released.
	// *   the instance has released when create task: The cloud desktop is released during execution.
	// *   the instance is not running when create task: The cloud desktop is not running when the execution is being performed.
	// *   the command is not applicable: The command cannot be used on the specified cloud desktop.
	// *   the aliyun service is not running on the instance: The Cloud Assistance client is not running.
	// *   the aliyun service in the instance does not response: The Cloud Assistant client is not responding.
	// *   the aliyun service in the instance is upgrading now: The Cloud Assistant client is being upgraded.
	// *   the aliyun service in the instance need upgrade: The Cloud Assistant client needs to be upgraded.
	// *   the command delivery has been timeout: The command that is sent in the request times out.
	// *   the command execution has been timeout: The execution times out.
	// *   the command execution got an exception: An exception occurs when the command is running.
	// *   the command execution has been interrupted: The execution is interrupted.
	// *   the command execution exit code is not zero: The execution finishes, but the exit code is not 0.
	ErrorInfo *string `json:"ErrorInfo,omitempty" xml:"ErrorInfo,omitempty"`
	// The exit code of the execution.
	ExitCode *int64 `json:"ExitCode,omitempty" xml:"ExitCode,omitempty"`
	// The time when the command execution ended.
	FinishTime *string `json:"FinishTime,omitempty" xml:"FinishTime,omitempty"`
	// The execution status on the cloud desktop.
	InvocationStatus *string `json:"InvocationStatus,omitempty" xml:"InvocationStatus,omitempty"`
	// The command output.
	//
	// *   If the IncludeOutput parameter is set to false, Output is not returned.
	// *   If the ContentEncoding parameter is set to Base64, the value of Output is the output information that is encoded in Base64.
	Output *string `json:"Output,omitempty" xml:"Output,omitempty"`
	// The number of times that the command is executed on the cloud desktop.
	Repeats *int32 `json:"Repeats,omitempty" xml:"Repeats,omitempty"`
	// The start time of the execution on the cloud desktop.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The time when you called the [StopInvocation](~~196957#doc-api-ecd-StopInvocation~~ "You can call this operation to stop a Cloud Assistant command that is running on one or cloud desktops.") operation to manually stop the command.
	StopTime *string `json:"StopTime,omitempty" xml:"StopTime,omitempty"`
	// The time when the execution status was updated.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s DescribeInvocationsResponseBodyInvocationsInvokeDesktops) String() string {
	return tea.Prettify(s)
}

func (s DescribeInvocationsResponseBodyInvocationsInvokeDesktops) GoString() string {
	return s.String()
}

func (s *DescribeInvocationsResponseBodyInvocationsInvokeDesktops) SetCreationTime(v string) *DescribeInvocationsResponseBodyInvocationsInvokeDesktops {
	s.CreationTime = &v
	return s
}

func (s *DescribeInvocationsResponseBodyInvocationsInvokeDesktops) SetDesktopId(v string) *DescribeInvocationsResponseBodyInvocationsInvokeDesktops {
	s.DesktopId = &v
	return s
}

func (s *DescribeInvocationsResponseBodyInvocationsInvokeDesktops) SetDesktopName(v string) *DescribeInvocationsResponseBodyInvocationsInvokeDesktops {
	s.DesktopName = &v
	return s
}

func (s *DescribeInvocationsResponseBodyInvocationsInvokeDesktops) SetDropped(v int32) *DescribeInvocationsResponseBodyInvocationsInvokeDesktops {
	s.Dropped = &v
	return s
}

func (s *DescribeInvocationsResponseBodyInvocationsInvokeDesktops) SetErrorCode(v string) *DescribeInvocationsResponseBodyInvocationsInvokeDesktops {
	s.ErrorCode = &v
	return s
}

func (s *DescribeInvocationsResponseBodyInvocationsInvokeDesktops) SetErrorInfo(v string) *DescribeInvocationsResponseBodyInvocationsInvokeDesktops {
	s.ErrorInfo = &v
	return s
}

func (s *DescribeInvocationsResponseBodyInvocationsInvokeDesktops) SetExitCode(v int64) *DescribeInvocationsResponseBodyInvocationsInvokeDesktops {
	s.ExitCode = &v
	return s
}

func (s *DescribeInvocationsResponseBodyInvocationsInvokeDesktops) SetFinishTime(v string) *DescribeInvocationsResponseBodyInvocationsInvokeDesktops {
	s.FinishTime = &v
	return s
}

func (s *DescribeInvocationsResponseBodyInvocationsInvokeDesktops) SetInvocationStatus(v string) *DescribeInvocationsResponseBodyInvocationsInvokeDesktops {
	s.InvocationStatus = &v
	return s
}

func (s *DescribeInvocationsResponseBodyInvocationsInvokeDesktops) SetOutput(v string) *DescribeInvocationsResponseBodyInvocationsInvokeDesktops {
	s.Output = &v
	return s
}

func (s *DescribeInvocationsResponseBodyInvocationsInvokeDesktops) SetRepeats(v int32) *DescribeInvocationsResponseBodyInvocationsInvokeDesktops {
	s.Repeats = &v
	return s
}

func (s *DescribeInvocationsResponseBodyInvocationsInvokeDesktops) SetStartTime(v string) *DescribeInvocationsResponseBodyInvocationsInvokeDesktops {
	s.StartTime = &v
	return s
}

func (s *DescribeInvocationsResponseBodyInvocationsInvokeDesktops) SetStopTime(v string) *DescribeInvocationsResponseBodyInvocationsInvokeDesktops {
	s.StopTime = &v
	return s
}

func (s *DescribeInvocationsResponseBodyInvocationsInvokeDesktops) SetUpdateTime(v string) *DescribeInvocationsResponseBodyInvocationsInvokeDesktops {
	s.UpdateTime = &v
	return s
}

type DescribeInvocationsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeInvocationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeInvocationsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeInvocationsResponse) GoString() string {
	return s.String()
}

func (s *DescribeInvocationsResponse) SetHeaders(v map[string]*string) *DescribeInvocationsResponse {
	s.Headers = v
	return s
}

func (s *DescribeInvocationsResponse) SetStatusCode(v int32) *DescribeInvocationsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeInvocationsResponse) SetBody(v *DescribeInvocationsResponseBody) *DescribeInvocationsResponse {
	s.Body = v
	return s
}

type DescribeKmsKeysRequest struct {
	// The ID of the region. You can call the [DescribeRegions](~~DescribeRegions~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeKmsKeysRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeKmsKeysRequest) GoString() string {
	return s.String()
}

func (s *DescribeKmsKeysRequest) SetRegionId(v string) *DescribeKmsKeysRequest {
	s.RegionId = &v
	return s
}

type DescribeKmsKeysResponseBody struct {
	// The authorization status.
	AuthorizeStatus *string `json:"AuthorizeStatus,omitempty" xml:"AuthorizeStatus,omitempty"`
	// Details about the customer master keys (CMKs).
	Keys []*DescribeKmsKeysResponseBodyKeys `json:"Keys,omitempty" xml:"Keys,omitempty" type:"Repeated"`
	// Indicates whether KMS is activated.
	KmsServiceStatus *string `json:"KmsServiceStatus,omitempty" xml:"KmsServiceStatus,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeKmsKeysResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeKmsKeysResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeKmsKeysResponseBody) SetAuthorizeStatus(v string) *DescribeKmsKeysResponseBody {
	s.AuthorizeStatus = &v
	return s
}

func (s *DescribeKmsKeysResponseBody) SetKeys(v []*DescribeKmsKeysResponseBodyKeys) *DescribeKmsKeysResponseBody {
	s.Keys = v
	return s
}

func (s *DescribeKmsKeysResponseBody) SetKmsServiceStatus(v string) *DescribeKmsKeysResponseBody {
	s.KmsServiceStatus = &v
	return s
}

func (s *DescribeKmsKeysResponseBody) SetRequestId(v string) *DescribeKmsKeysResponseBody {
	s.RequestId = &v
	return s
}

type DescribeKmsKeysResponseBodyKeys struct {
	// The alias of the key.
	Alias *string `json:"Alias,omitempty" xml:"Alias,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the key in KMS.
	Arn *string `json:"Arn,omitempty" xml:"Arn,omitempty"`
	// The ID of the key.
	KeyId *string `json:"KeyId,omitempty" xml:"KeyId,omitempty"`
	// The type of the key.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeKmsKeysResponseBodyKeys) String() string {
	return tea.Prettify(s)
}

func (s DescribeKmsKeysResponseBodyKeys) GoString() string {
	return s.String()
}

func (s *DescribeKmsKeysResponseBodyKeys) SetAlias(v string) *DescribeKmsKeysResponseBodyKeys {
	s.Alias = &v
	return s
}

func (s *DescribeKmsKeysResponseBodyKeys) SetArn(v string) *DescribeKmsKeysResponseBodyKeys {
	s.Arn = &v
	return s
}

func (s *DescribeKmsKeysResponseBodyKeys) SetKeyId(v string) *DescribeKmsKeysResponseBodyKeys {
	s.KeyId = &v
	return s
}

func (s *DescribeKmsKeysResponseBodyKeys) SetType(v string) *DescribeKmsKeysResponseBodyKeys {
	s.Type = &v
	return s
}

type DescribeKmsKeysResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeKmsKeysResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeKmsKeysResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeKmsKeysResponse) GoString() string {
	return s.String()
}

func (s *DescribeKmsKeysResponse) SetHeaders(v map[string]*string) *DescribeKmsKeysResponse {
	s.Headers = v
	return s
}

func (s *DescribeKmsKeysResponse) SetStatusCode(v int32) *DescribeKmsKeysResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeKmsKeysResponse) SetBody(v *DescribeKmsKeysResponseBody) *DescribeKmsKeysResponse {
	s.Body = v
	return s
}

type DescribeNASFileSystemsRequest struct {
	// The IDs of the NAS file system.
	FileSystemId []*string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty" type:"Repeated"`
	// Specifies whether to filter NAS file systems that only support the user profile management (UPM) feature.
	MatchCompatibleProfile *bool `json:"MatchCompatibleProfile,omitempty" xml:"MatchCompatibleProfile,omitempty"`
	// The number of entries to return on each page.
	//
	// Maximum value: 100.
	//
	// Default value: 10.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeNASFileSystemsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeNASFileSystemsRequest) GoString() string {
	return s.String()
}

func (s *DescribeNASFileSystemsRequest) SetFileSystemId(v []*string) *DescribeNASFileSystemsRequest {
	s.FileSystemId = v
	return s
}

func (s *DescribeNASFileSystemsRequest) SetMatchCompatibleProfile(v bool) *DescribeNASFileSystemsRequest {
	s.MatchCompatibleProfile = &v
	return s
}

func (s *DescribeNASFileSystemsRequest) SetMaxResults(v int32) *DescribeNASFileSystemsRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeNASFileSystemsRequest) SetNextToken(v string) *DescribeNASFileSystemsRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeNASFileSystemsRequest) SetOfficeSiteId(v string) *DescribeNASFileSystemsRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *DescribeNASFileSystemsRequest) SetRegionId(v string) *DescribeNASFileSystemsRequest {
	s.RegionId = &v
	return s
}

type DescribeNASFileSystemsResponseBody struct {
	// Details about the NAS file systems.
	FileSystems []*DescribeNASFileSystemsResponseBodyFileSystems `json:"FileSystems,omitempty" xml:"FileSystems,omitempty" type:"Repeated"`
	// The token that determines the start point of the next query. This parameter is empty if no additional results exist.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeNASFileSystemsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeNASFileSystemsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeNASFileSystemsResponseBody) SetFileSystems(v []*DescribeNASFileSystemsResponseBodyFileSystems) *DescribeNASFileSystemsResponseBody {
	s.FileSystems = v
	return s
}

func (s *DescribeNASFileSystemsResponseBody) SetNextToken(v string) *DescribeNASFileSystemsResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeNASFileSystemsResponseBody) SetRequestId(v string) *DescribeNASFileSystemsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeNASFileSystemsResponseBodyFileSystems struct {
	// The total capacity of the NAS file system. Unit: GiB.
	//
	// *   The Capacity type has 10 PiB of storage, which is equal to 10,485,760 GiB.
	// *   The Performance type has 1 PiB of storage, which is equal to 1,048,576 GiB.
	Capacity *int64 `json:"Capacity,omitempty" xml:"Capacity,omitempty"`
	// The time when the NAS file system was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the NAS file system.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The desktop groups that are associated with the NAS file systems that support the UPM feature.
	DesktopGroups []*DescribeNASFileSystemsResponseBodyFileSystemsDesktopGroups `json:"DesktopGroups,omitempty" xml:"DesktopGroups,omitempty" type:"Repeated"`
	// Indicates whether disk encryption is enabled.
	EncryptionEnabled *bool `json:"EncryptionEnabled,omitempty" xml:"EncryptionEnabled,omitempty"`
	// The ID of the NAS file system.
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The name of the NAS file system.
	FileSystemName *string `json:"FileSystemName,omitempty" xml:"FileSystemName,omitempty"`
	// The status of the NAS file system. The possible values include:
	//
	// *   Pending: The NAS file system is being created.
	// *   Running: The NAS file system is running.
	// *   Stopped: The NAS file system is stopped.
	// *   Deleting: The NAS file system is being deleted.
	// *   Deleted: The NAS file system is deleted.
	// *   Invalid: The NAS file system is invalid.
	FileSystemStatus *string `json:"FileSystemStatus,omitempty" xml:"FileSystemStatus,omitempty"`
	// The type of the NAS file system. Valid value: Universal NAS. This value indicates that the NAS file system is a General-purpose one.
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	// The used storage of the NAS file system. Unit: byte.
	MeteredSize *int64 `json:"MeteredSize,omitempty" xml:"MeteredSize,omitempty"`
	// The domain name of the mount target.
	MountTargetDomain *string `json:"MountTargetDomain,omitempty" xml:"MountTargetDomain,omitempty"`
	// The status of the mount target. The possible values include:
	//
	// *   Pending: The mount target is being created.
	// *   Active: The mount target is enabled.
	// *   Inactive: The mount target is disabled.
	// *   Deleting: The mount target is being deleted.
	// *   Invalid: The mount target is invalid.
	MountTargetStatus *string `json:"MountTargetStatus,omitempty" xml:"MountTargetStatus,omitempty"`
	// The ID of the workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The name of the workspace.
	OfficeSiteName *string `json:"OfficeSiteName,omitempty" xml:"OfficeSiteName,omitempty"`
	// Indicates whether the User Profile Management (UPM) feature is supported.
	ProfileCompatible *bool `json:"ProfileCompatible,omitempty" xml:"ProfileCompatible,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The storage type of the NAS file system. Valid values:
	//
	// *   Capacity
	// *   Performance
	StorageType *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
	// Indicates whether the Server Message Block (SMB) access control list (ACL) feature was enabled.
	SupportAcl *bool `json:"SupportAcl,omitempty" xml:"SupportAcl,omitempty"`
	// The ID of the zone where the NAS file system resides.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeNASFileSystemsResponseBodyFileSystems) String() string {
	return tea.Prettify(s)
}

func (s DescribeNASFileSystemsResponseBodyFileSystems) GoString() string {
	return s.String()
}

func (s *DescribeNASFileSystemsResponseBodyFileSystems) SetCapacity(v int64) *DescribeNASFileSystemsResponseBodyFileSystems {
	s.Capacity = &v
	return s
}

func (s *DescribeNASFileSystemsResponseBodyFileSystems) SetCreateTime(v string) *DescribeNASFileSystemsResponseBodyFileSystems {
	s.CreateTime = &v
	return s
}

func (s *DescribeNASFileSystemsResponseBodyFileSystems) SetDescription(v string) *DescribeNASFileSystemsResponseBodyFileSystems {
	s.Description = &v
	return s
}

func (s *DescribeNASFileSystemsResponseBodyFileSystems) SetDesktopGroups(v []*DescribeNASFileSystemsResponseBodyFileSystemsDesktopGroups) *DescribeNASFileSystemsResponseBodyFileSystems {
	s.DesktopGroups = v
	return s
}

func (s *DescribeNASFileSystemsResponseBodyFileSystems) SetEncryptionEnabled(v bool) *DescribeNASFileSystemsResponseBodyFileSystems {
	s.EncryptionEnabled = &v
	return s
}

func (s *DescribeNASFileSystemsResponseBodyFileSystems) SetFileSystemId(v string) *DescribeNASFileSystemsResponseBodyFileSystems {
	s.FileSystemId = &v
	return s
}

func (s *DescribeNASFileSystemsResponseBodyFileSystems) SetFileSystemName(v string) *DescribeNASFileSystemsResponseBodyFileSystems {
	s.FileSystemName = &v
	return s
}

func (s *DescribeNASFileSystemsResponseBodyFileSystems) SetFileSystemStatus(v string) *DescribeNASFileSystemsResponseBodyFileSystems {
	s.FileSystemStatus = &v
	return s
}

func (s *DescribeNASFileSystemsResponseBodyFileSystems) SetFileSystemType(v string) *DescribeNASFileSystemsResponseBodyFileSystems {
	s.FileSystemType = &v
	return s
}

func (s *DescribeNASFileSystemsResponseBodyFileSystems) SetMeteredSize(v int64) *DescribeNASFileSystemsResponseBodyFileSystems {
	s.MeteredSize = &v
	return s
}

func (s *DescribeNASFileSystemsResponseBodyFileSystems) SetMountTargetDomain(v string) *DescribeNASFileSystemsResponseBodyFileSystems {
	s.MountTargetDomain = &v
	return s
}

func (s *DescribeNASFileSystemsResponseBodyFileSystems) SetMountTargetStatus(v string) *DescribeNASFileSystemsResponseBodyFileSystems {
	s.MountTargetStatus = &v
	return s
}

func (s *DescribeNASFileSystemsResponseBodyFileSystems) SetOfficeSiteId(v string) *DescribeNASFileSystemsResponseBodyFileSystems {
	s.OfficeSiteId = &v
	return s
}

func (s *DescribeNASFileSystemsResponseBodyFileSystems) SetOfficeSiteName(v string) *DescribeNASFileSystemsResponseBodyFileSystems {
	s.OfficeSiteName = &v
	return s
}

func (s *DescribeNASFileSystemsResponseBodyFileSystems) SetProfileCompatible(v bool) *DescribeNASFileSystemsResponseBodyFileSystems {
	s.ProfileCompatible = &v
	return s
}

func (s *DescribeNASFileSystemsResponseBodyFileSystems) SetRegionId(v string) *DescribeNASFileSystemsResponseBodyFileSystems {
	s.RegionId = &v
	return s
}

func (s *DescribeNASFileSystemsResponseBodyFileSystems) SetStorageType(v string) *DescribeNASFileSystemsResponseBodyFileSystems {
	s.StorageType = &v
	return s
}

func (s *DescribeNASFileSystemsResponseBodyFileSystems) SetSupportAcl(v bool) *DescribeNASFileSystemsResponseBodyFileSystems {
	s.SupportAcl = &v
	return s
}

func (s *DescribeNASFileSystemsResponseBodyFileSystems) SetZoneId(v string) *DescribeNASFileSystemsResponseBodyFileSystems {
	s.ZoneId = &v
	return s
}

type DescribeNASFileSystemsResponseBodyFileSystemsDesktopGroups struct {
	// The ID of the desktop group.
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// The name of the desktop group.
	DesktopGroupName *string `json:"DesktopGroupName,omitempty" xml:"DesktopGroupName,omitempty"`
}

func (s DescribeNASFileSystemsResponseBodyFileSystemsDesktopGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribeNASFileSystemsResponseBodyFileSystemsDesktopGroups) GoString() string {
	return s.String()
}

func (s *DescribeNASFileSystemsResponseBodyFileSystemsDesktopGroups) SetDesktopGroupId(v string) *DescribeNASFileSystemsResponseBodyFileSystemsDesktopGroups {
	s.DesktopGroupId = &v
	return s
}

func (s *DescribeNASFileSystemsResponseBodyFileSystemsDesktopGroups) SetDesktopGroupName(v string) *DescribeNASFileSystemsResponseBodyFileSystemsDesktopGroups {
	s.DesktopGroupName = &v
	return s
}

type DescribeNASFileSystemsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeNASFileSystemsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeNASFileSystemsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeNASFileSystemsResponse) GoString() string {
	return s.String()
}

func (s *DescribeNASFileSystemsResponse) SetHeaders(v map[string]*string) *DescribeNASFileSystemsResponse {
	s.Headers = v
	return s
}

func (s *DescribeNASFileSystemsResponse) SetStatusCode(v int32) *DescribeNASFileSystemsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeNASFileSystemsResponse) SetBody(v *DescribeNASFileSystemsResponseBody) *DescribeNASFileSystemsResponse {
	s.Body = v
	return s
}

type DescribeNetworkPackagesRequest struct {
	// The billing method of the Internet access package. Valid values:
	//
	// *   PayByTraffic: pay-by-data-transfer
	// *   PayByBandwidth: pay-by-bandwidth
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The number of entries to return on each page.
	//
	// *   Maximum value: 100
	// *   Default value: 10
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The IDs of the Internet access packages. You can specify 1 to 100 IDs of Internet access packages.
	NetworkPackageId []*string `json:"NetworkPackageId,omitempty" xml:"NetworkPackageId,omitempty" type:"Repeated"`
	// The token that determines the start point of the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeNetworkPackagesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkPackagesRequest) GoString() string {
	return s.String()
}

func (s *DescribeNetworkPackagesRequest) SetInternetChargeType(v string) *DescribeNetworkPackagesRequest {
	s.InternetChargeType = &v
	return s
}

func (s *DescribeNetworkPackagesRequest) SetMaxResults(v int32) *DescribeNetworkPackagesRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeNetworkPackagesRequest) SetNetworkPackageId(v []*string) *DescribeNetworkPackagesRequest {
	s.NetworkPackageId = v
	return s
}

func (s *DescribeNetworkPackagesRequest) SetNextToken(v string) *DescribeNetworkPackagesRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeNetworkPackagesRequest) SetRegionId(v string) *DescribeNetworkPackagesRequest {
	s.RegionId = &v
	return s
}

type DescribeNetworkPackagesResponseBody struct {
	// Details of the Internet access packages.
	NetworkPackages []*DescribeNetworkPackagesResponseBodyNetworkPackages `json:"NetworkPackages,omitempty" xml:"NetworkPackages,omitempty" type:"Repeated"`
	// The token that is used to start the next query. If the value of this parameter is empty, all results are returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeNetworkPackagesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkPackagesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeNetworkPackagesResponseBody) SetNetworkPackages(v []*DescribeNetworkPackagesResponseBodyNetworkPackages) *DescribeNetworkPackagesResponseBody {
	s.NetworkPackages = v
	return s
}

func (s *DescribeNetworkPackagesResponseBody) SetNextToken(v string) *DescribeNetworkPackagesResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeNetworkPackagesResponseBody) SetRequestId(v string) *DescribeNetworkPackagesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeNetworkPackagesResponseBodyNetworkPackages struct {
	// The maximum public bandwidth of the Internet access package. Unit: Mbit/s.
	Bandwidth      *int32  `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	BusinessStatus *string `json:"BusinessStatus,omitempty" xml:"BusinessStatus,omitempty"`
	// The time when the Internet access package was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The elastic IP addresses (EIPs) of the Internet access package for outbound traffic.
	EipAddresses []*string `json:"EipAddresses,omitempty" xml:"EipAddresses,omitempty" type:"Repeated"`
	// The time when the Internet access package expires.
	//
	// *   If the Internet access package is metered on a pay-by-bandwidth basis, the actual expiration time is returned.
	// *   If the Internet access package is metered on a pay-by-data-transfer basis, 2099-12-31T15:59:59Z is returned.
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The billing method of the network bandwidth.
	//
	// *   PayByTraffic: pay-by-data-transfer
	// *   PayByBandwidth: pay-by-bandwidth
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The ID of the Internet access package.
	NetworkPackageId *string `json:"NetworkPackageId,omitempty" xml:"NetworkPackageId,omitempty"`
	// The state of the Internet access package. Valid values:
	//
	// *   Creating
	// *   InUse
	// *   Releasing
	// *   Released
	NetworkPackageStatus *string `json:"NetworkPackageStatus,omitempty" xml:"NetworkPackageStatus,omitempty"`
	// The ID of the workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The name of the workspace.
	OfficeSiteName *string `json:"OfficeSiteName,omitempty" xml:"OfficeSiteName,omitempty"`
	// The type of the workspace. Valid values:
	//
	// *   basic
	// *   standard
	// *   customized
	OfficeSiteVpcType *string `json:"OfficeSiteVpcType,omitempty" xml:"OfficeSiteVpcType,omitempty"`
	// The billing method for the network.
	//
	// *   PrePaid: subscription
	// *   PostPaid: pay-as-you-go
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The time when the reserved network bandwidth takes effect.
	ReservationActiveTime *string `json:"ReservationActiveTime,omitempty" xml:"ReservationActiveTime,omitempty"`
	// The peak bandwidth of the reserved network bandwidth. Unit: Mbit/s.
	ReservationBandwidth *int32 `json:"ReservationBandwidth,omitempty" xml:"ReservationBandwidth,omitempty"`
	// The billing method of the reserved network bandwidth.
	//
	// *   PayByTraffic: pay-by-data-transfer
	// *   PayByBandwidth: pay-by-bandwidth
	ReservationInternetChargeType *string `json:"ReservationInternetChargeType,omitempty" xml:"ReservationInternetChargeType,omitempty"`
}

func (s DescribeNetworkPackagesResponseBodyNetworkPackages) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkPackagesResponseBodyNetworkPackages) GoString() string {
	return s.String()
}

func (s *DescribeNetworkPackagesResponseBodyNetworkPackages) SetBandwidth(v int32) *DescribeNetworkPackagesResponseBodyNetworkPackages {
	s.Bandwidth = &v
	return s
}

func (s *DescribeNetworkPackagesResponseBodyNetworkPackages) SetBusinessStatus(v string) *DescribeNetworkPackagesResponseBodyNetworkPackages {
	s.BusinessStatus = &v
	return s
}

func (s *DescribeNetworkPackagesResponseBodyNetworkPackages) SetCreateTime(v string) *DescribeNetworkPackagesResponseBodyNetworkPackages {
	s.CreateTime = &v
	return s
}

func (s *DescribeNetworkPackagesResponseBodyNetworkPackages) SetEipAddresses(v []*string) *DescribeNetworkPackagesResponseBodyNetworkPackages {
	s.EipAddresses = v
	return s
}

func (s *DescribeNetworkPackagesResponseBodyNetworkPackages) SetExpiredTime(v string) *DescribeNetworkPackagesResponseBodyNetworkPackages {
	s.ExpiredTime = &v
	return s
}

func (s *DescribeNetworkPackagesResponseBodyNetworkPackages) SetInternetChargeType(v string) *DescribeNetworkPackagesResponseBodyNetworkPackages {
	s.InternetChargeType = &v
	return s
}

func (s *DescribeNetworkPackagesResponseBodyNetworkPackages) SetNetworkPackageId(v string) *DescribeNetworkPackagesResponseBodyNetworkPackages {
	s.NetworkPackageId = &v
	return s
}

func (s *DescribeNetworkPackagesResponseBodyNetworkPackages) SetNetworkPackageStatus(v string) *DescribeNetworkPackagesResponseBodyNetworkPackages {
	s.NetworkPackageStatus = &v
	return s
}

func (s *DescribeNetworkPackagesResponseBodyNetworkPackages) SetOfficeSiteId(v string) *DescribeNetworkPackagesResponseBodyNetworkPackages {
	s.OfficeSiteId = &v
	return s
}

func (s *DescribeNetworkPackagesResponseBodyNetworkPackages) SetOfficeSiteName(v string) *DescribeNetworkPackagesResponseBodyNetworkPackages {
	s.OfficeSiteName = &v
	return s
}

func (s *DescribeNetworkPackagesResponseBodyNetworkPackages) SetOfficeSiteVpcType(v string) *DescribeNetworkPackagesResponseBodyNetworkPackages {
	s.OfficeSiteVpcType = &v
	return s
}

func (s *DescribeNetworkPackagesResponseBodyNetworkPackages) SetPayType(v string) *DescribeNetworkPackagesResponseBodyNetworkPackages {
	s.PayType = &v
	return s
}

func (s *DescribeNetworkPackagesResponseBodyNetworkPackages) SetReservationActiveTime(v string) *DescribeNetworkPackagesResponseBodyNetworkPackages {
	s.ReservationActiveTime = &v
	return s
}

func (s *DescribeNetworkPackagesResponseBodyNetworkPackages) SetReservationBandwidth(v int32) *DescribeNetworkPackagesResponseBodyNetworkPackages {
	s.ReservationBandwidth = &v
	return s
}

func (s *DescribeNetworkPackagesResponseBodyNetworkPackages) SetReservationInternetChargeType(v string) *DescribeNetworkPackagesResponseBodyNetworkPackages {
	s.ReservationInternetChargeType = &v
	return s
}

type DescribeNetworkPackagesResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeNetworkPackagesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeNetworkPackagesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkPackagesResponse) GoString() string {
	return s.String()
}

func (s *DescribeNetworkPackagesResponse) SetHeaders(v map[string]*string) *DescribeNetworkPackagesResponse {
	s.Headers = v
	return s
}

func (s *DescribeNetworkPackagesResponse) SetStatusCode(v int32) *DescribeNetworkPackagesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeNetworkPackagesResponse) SetBody(v *DescribeNetworkPackagesResponseBody) *DescribeNetworkPackagesResponse {
	s.Body = v
	return s
}

type DescribeOfficeSitesRequest struct {
	// The number of entries to return on each page.
	//
	// *   Maximum value: 100.
	// *   Default value: 10.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The IDs of the workspaces. You can specify 1 to 100 IDs of workspaces.
	OfficeSiteId []*string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty" type:"Repeated"`
	// The account type of the workspace.
	OfficeSiteType *string `json:"OfficeSiteType,omitempty" xml:"OfficeSiteType,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The state of the workspace.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeOfficeSitesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeOfficeSitesRequest) GoString() string {
	return s.String()
}

func (s *DescribeOfficeSitesRequest) SetMaxResults(v int32) *DescribeOfficeSitesRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeOfficeSitesRequest) SetNextToken(v string) *DescribeOfficeSitesRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeOfficeSitesRequest) SetOfficeSiteId(v []*string) *DescribeOfficeSitesRequest {
	s.OfficeSiteId = v
	return s
}

func (s *DescribeOfficeSitesRequest) SetOfficeSiteType(v string) *DescribeOfficeSitesRequest {
	s.OfficeSiteType = &v
	return s
}

func (s *DescribeOfficeSitesRequest) SetRegionId(v string) *DescribeOfficeSitesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeOfficeSitesRequest) SetStatus(v string) *DescribeOfficeSitesRequest {
	s.Status = &v
	return s
}

type DescribeOfficeSitesResponseBody struct {
	// The token that determines the start point of the next query. If this parameter is empty, all results are returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// Details about the workspaces.
	OfficeSites []*DescribeOfficeSitesResponseBodyOfficeSites `json:"OfficeSites,omitempty" xml:"OfficeSites,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeOfficeSitesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeOfficeSitesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeOfficeSitesResponseBody) SetNextToken(v string) *DescribeOfficeSitesResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeOfficeSitesResponseBody) SetOfficeSites(v []*DescribeOfficeSitesResponseBodyOfficeSites) *DescribeOfficeSitesResponseBody {
	s.OfficeSites = v
	return s
}

func (s *DescribeOfficeSitesResponseBody) SetRequestId(v string) *DescribeOfficeSitesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeOfficeSitesResponseBodyOfficeSites struct {
	// Details about AD connectors.
	ADConnectors []*DescribeOfficeSitesResponseBodyOfficeSitesADConnectors `json:"ADConnectors,omitempty" xml:"ADConnectors,omitempty" type:"Repeated"`
	// The hostname of the domain controller. The hostname must comply with the naming conventions for Windows hosts.
	AdHostname *string `json:"AdHostname,omitempty" xml:"AdHostname,omitempty"`
	// The maximum public bandwidth value. Valid values: 0 to 1000.\
	// If the value of this parameter is 0, Internet access is disabled.
	Bandwidth       *int32  `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	CenAttachStatus *string `json:"CenAttachStatus,omitempty" xml:"CenAttachStatus,omitempty"`
	// The ID of the Cloud Enterprise Network (CEN) instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The IPv4 CIDR block that is included in the secure office network of the workspace.
	CidrBlock *string `json:"CidrBlock,omitempty" xml:"CidrBlock,omitempty"`
	// Specifies whether the workspace is a cloud box-based workspace.
	//
	// Valid values:
	//
	// *   True: a cloud box-based workspace
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   False: an Internet-based workspace
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	CloudBoxOfficeSite *bool `json:"CloudBoxOfficeSite,omitempty" xml:"CloudBoxOfficeSite,omitempty"`
	// The time when the workspace was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The ID of the security group.
	CustomSecurityGroupId *string `json:"CustomSecurityGroupId,omitempty" xml:"CustomSecurityGroupId,omitempty"`
	// The method that is used to connect an Alibaba Cloud Workspace client to cloud desktops.
	//
	// Valid values:
	//
	// *   INTERNET: allows clients to connect to cloud desktops only over the Internet.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   VPC: allows only clients in VPCs to connect to a cloud desktop.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   ANY: connects the client to cloud desktops over the Internet or a VPC.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     Configure the Connection Method parameter based on your business requirements.
	//
	//     <!-- -->
	DesktopAccessType *string `json:"DesktopAccessType,omitempty" xml:"DesktopAccessType,omitempty"`
	// The number of cloud desktops that are created.
	DesktopCount *int64 `json:"DesktopCount,omitempty" xml:"DesktopCount,omitempty"`
	// The endpoint that is used to connect to cloud desktops over a VPC.
	DesktopVpcEndpoint *string `json:"DesktopVpcEndpoint,omitempty" xml:"DesktopVpcEndpoint,omitempty"`
	// The DNS addresses of the AD domains.
	DnsAddress []*string `json:"DnsAddress,omitempty" xml:"DnsAddress,omitempty" type:"Repeated"`
	// The username of the Domain Name System (DNS) user.
	DnsUserName *string `json:"DnsUserName,omitempty" xml:"DnsUserName,omitempty"`
	// The domain name of the enterprise Active Directory (AD) system.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The password of the domain administrator.
	DomainPassword *string `json:"DomainPassword,omitempty" xml:"DomainPassword,omitempty"`
	// The username of the domain administrator.
	DomainUserName *string `json:"DomainUserName,omitempty" xml:"DomainUserName,omitempty"`
	// Indicates whether the Local Administrator permissions are granted for users of the cloud desktop.
	EnableAdminAccess *bool `json:"EnableAdminAccess,omitempty" xml:"EnableAdminAccess,omitempty"`
	// Indicates whether the cross-desktop access feature is enabled for cloud desktops in the same workspace. If the feature is enabled, cloud desktops in the same workspace can access each other.
	EnableCrossDesktopAccess *bool `json:"EnableCrossDesktopAccess,omitempty" xml:"EnableCrossDesktopAccess,omitempty"`
	// Indicates whether Internet access is enabled.
	EnableInternetAccess *bool `json:"EnableInternetAccess,omitempty" xml:"EnableInternetAccess,omitempty"`
	// The IDs of the Apsara File Storage NAS (NAS) file systems.
	FileSystemIds []*string `json:"FileSystemIds,omitempty" xml:"FileSystemIds,omitempty" type:"Repeated"`
	// Details about registration logs.
	Logs []*DescribeOfficeSitesResponseBodyOfficeSitesLogs `json:"Logs,omitempty" xml:"Logs,omitempty" type:"Repeated"`
	// Specifies whether to enable multi-factor authentication (MFA).
	MfaEnabled *bool `json:"MfaEnabled,omitempty" xml:"MfaEnabled,omitempty"`
	// The name of the workspace. The name is unique in the same region.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Indicates whether two-step verification for logons is enabled. This parameter is returned only for workspaces of the convenience account type.\
	// If two-factor verification is enabled, the system checks whether security risks exist within the logon account when a convenience user logs on to an Alibaba Cloud Workspace client. If risks are detected, the system sends a verification code to the email address that is associated with the account. Then, the convenience user can log on to the client only after the user enters the correct verification code.
	NeedVerifyLoginRisk *bool `json:"NeedVerifyLoginRisk,omitempty" xml:"NeedVerifyLoginRisk,omitempty"`
	// Specifies whether to enable trusted device verification.
	//
	// Valid values:
	//
	// *   true: enables device verification.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   false: disables device verification.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	NeedVerifyZeroDevice *bool `json:"NeedVerifyZeroDevice,omitempty" xml:"NeedVerifyZeroDevice,omitempty"`
	// The ID of the Internet access package.
	NetworkPackageId *string `json:"NetworkPackageId,omitempty" xml:"NetworkPackageId,omitempty"`
	// The workspace ID.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The account type of the workspace.
	//
	// Valid values:
	//
	// *   SIMPLE: the convenience account
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   AD_CONNECTOR: the enterprise AD account
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	OfficeSiteType *string `json:"OfficeSiteType,omitempty" xml:"OfficeSiteType,omitempty"`
	// The name of the organizational unit (OU) that is connected to the AD domain.
	OuName *string `json:"OuName,omitempty" xml:"OuName,omitempty"`
	// The workspace protocol.
	//
	// Valid values:
	//
	// *   HDX: the third-party protocol
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   ASP: the protocol developed by Alibaba Cloud
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	ProtocolType         *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	RdsLicenseAddress    *string `json:"RdsLicenseAddress,omitempty" xml:"RdsLicenseAddress,omitempty"`
	RdsLicenseDomainName *string `json:"RdsLicenseDomainName,omitempty" xml:"RdsLicenseDomainName,omitempty"`
	RdsLicenseStatus     *string `json:"RdsLicenseStatus,omitempty" xml:"RdsLicenseStatus,omitempty"`
	// Indicates whether single sign-on (SSO) is enabled.
	SsoEnabled *bool `json:"SsoEnabled,omitempty" xml:"SsoEnabled,omitempty"`
	// The type of SSO.
	SsoType *string `json:"SsoType,omitempty" xml:"SsoType,omitempty"`
	// The state of the workspace.
	//
	// Valid values:
	//
	// *   REGISTERING: The workspace is being registered.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   DEREGISTERING: The workspace is being deregistered.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   REGISTERED: The workspace is registered.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   NEEDCONFIGTRUST: A trust relationship needs to be configured.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   CONFIGTRUSTFAILED: A trust relationship fails to be configured.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   DEREGISTERED: The workspace is deregistered.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   ERROR: The configurations of the workspace are invalid.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   CONFIGTRUSTING: A trust relationship is being configured.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   NEEDCONFIGUSER: Users need to be configured.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The DNS addresses of the AD subdomains.
	SubDnsAddress []*string `json:"SubDnsAddress,omitempty" xml:"SubDnsAddress,omitempty" type:"Repeated"`
	// The username of a Domain Name System (DNS) account in the AD subdomain.
	SubDomainName         *string `json:"SubDomainName,omitempty" xml:"SubDomainName,omitempty"`
	TotalEdsCount         *int64  `json:"TotalEdsCount,omitempty" xml:"TotalEdsCount,omitempty"`
	TotalEdsCountForGroup *int64  `json:"TotalEdsCountForGroup,omitempty" xml:"TotalEdsCountForGroup,omitempty"`
	// > This parameter is unavailable.
	TrustPassword *string `json:"TrustPassword,omitempty" xml:"TrustPassword,omitempty"`
	// The IDs of the vSwitches.
	VSwitchIds []*string `json:"VSwitchIds,omitempty" xml:"VSwitchIds,omitempty" type:"Repeated"`
	// The ID of the secure office network of the workspace. The ID is also the ID of the virtual private cloud (VPC) used by the workspace.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The VPC type.
	//
	// Valid values:
	//
	// *   Basic
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Customized
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Standard
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	VpcType *string `json:"VpcType,omitempty" xml:"VpcType,omitempty"`
}

func (s DescribeOfficeSitesResponseBodyOfficeSites) String() string {
	return tea.Prettify(s)
}

func (s DescribeOfficeSitesResponseBodyOfficeSites) GoString() string {
	return s.String()
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetADConnectors(v []*DescribeOfficeSitesResponseBodyOfficeSitesADConnectors) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.ADConnectors = v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetAdHostname(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.AdHostname = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetBandwidth(v int32) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.Bandwidth = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetCenAttachStatus(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.CenAttachStatus = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetCenId(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.CenId = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetCidrBlock(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.CidrBlock = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetCloudBoxOfficeSite(v bool) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.CloudBoxOfficeSite = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetCreationTime(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.CreationTime = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetCustomSecurityGroupId(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.CustomSecurityGroupId = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetDesktopAccessType(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.DesktopAccessType = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetDesktopCount(v int64) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.DesktopCount = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetDesktopVpcEndpoint(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.DesktopVpcEndpoint = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetDnsAddress(v []*string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.DnsAddress = v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetDnsUserName(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.DnsUserName = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetDomainName(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.DomainName = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetDomainPassword(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.DomainPassword = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetDomainUserName(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.DomainUserName = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetEnableAdminAccess(v bool) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.EnableAdminAccess = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetEnableCrossDesktopAccess(v bool) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.EnableCrossDesktopAccess = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetEnableInternetAccess(v bool) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.EnableInternetAccess = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetFileSystemIds(v []*string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.FileSystemIds = v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetLogs(v []*DescribeOfficeSitesResponseBodyOfficeSitesLogs) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.Logs = v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetMfaEnabled(v bool) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.MfaEnabled = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetName(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.Name = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetNeedVerifyLoginRisk(v bool) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.NeedVerifyLoginRisk = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetNeedVerifyZeroDevice(v bool) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.NeedVerifyZeroDevice = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetNetworkPackageId(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.NetworkPackageId = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetOfficeSiteId(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.OfficeSiteId = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetOfficeSiteType(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.OfficeSiteType = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetOuName(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.OuName = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetProtocolType(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.ProtocolType = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetRdsLicenseAddress(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.RdsLicenseAddress = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetRdsLicenseDomainName(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.RdsLicenseDomainName = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetRdsLicenseStatus(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.RdsLicenseStatus = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetSsoEnabled(v bool) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.SsoEnabled = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetSsoType(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.SsoType = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetStatus(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.Status = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetSubDnsAddress(v []*string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.SubDnsAddress = v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetSubDomainName(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.SubDomainName = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetTotalEdsCount(v int64) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.TotalEdsCount = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetTotalEdsCountForGroup(v int64) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.TotalEdsCountForGroup = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetTrustPassword(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.TrustPassword = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetVSwitchIds(v []*string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.VSwitchIds = v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetVpcId(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.VpcId = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSites) SetVpcType(v string) *DescribeOfficeSitesResponseBodyOfficeSites {
	s.VpcType = &v
	return s
}

type DescribeOfficeSitesResponseBodyOfficeSitesADConnectors struct {
	// The IP address of the AD connector.
	ADConnectorAddress *string `json:"ADConnectorAddress,omitempty" xml:"ADConnectorAddress,omitempty"`
	// The state of the AD connector.
	//
	// Valid values:
	//
	// *   CONNECT_ERROR: A connection error occurs.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   RUNNING: The AD connector is running
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     .
	//
	// *   CONNECTING: The AD connector is being connected.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     The AD domain for the connector needs to be configured.
	//
	//     <!-- -->
	//
	// *   EXPIRED: The AD connector expired due to overdue payments.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   CREATING: The consumer group is being created
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     .
	ConnectorStatus *string `json:"ConnectorStatus,omitempty" xml:"ConnectorStatus,omitempty"`
	// The ID of the network interface controller (NIC) that is associated with the AD connector.
	NetworkInterfaceId *string `json:"NetworkInterfaceId,omitempty" xml:"NetworkInterfaceId,omitempty"`
	// The AD connector type.
	//
	// Valid values:
	//
	// *   1: General
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   2: Advanced
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Specification *string `json:"Specification,omitempty" xml:"Specification,omitempty"`
	// The trust password that is specified when you configured the AD trust relationship.
	TrustKey *string `json:"TrustKey,omitempty" xml:"TrustKey,omitempty"`
	// The ID of the vSwitch that corresponds to the network of the AD connector.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
}

func (s DescribeOfficeSitesResponseBodyOfficeSitesADConnectors) String() string {
	return tea.Prettify(s)
}

func (s DescribeOfficeSitesResponseBodyOfficeSitesADConnectors) GoString() string {
	return s.String()
}

func (s *DescribeOfficeSitesResponseBodyOfficeSitesADConnectors) SetADConnectorAddress(v string) *DescribeOfficeSitesResponseBodyOfficeSitesADConnectors {
	s.ADConnectorAddress = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSitesADConnectors) SetConnectorStatus(v string) *DescribeOfficeSitesResponseBodyOfficeSitesADConnectors {
	s.ConnectorStatus = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSitesADConnectors) SetNetworkInterfaceId(v string) *DescribeOfficeSitesResponseBodyOfficeSitesADConnectors {
	s.NetworkInterfaceId = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSitesADConnectors) SetSpecification(v string) *DescribeOfficeSitesResponseBodyOfficeSitesADConnectors {
	s.Specification = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSitesADConnectors) SetTrustKey(v string) *DescribeOfficeSitesResponseBodyOfficeSitesADConnectors {
	s.TrustKey = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSitesADConnectors) SetVSwitchId(v string) *DescribeOfficeSitesResponseBodyOfficeSitesADConnectors {
	s.VSwitchId = &v
	return s
}

type DescribeOfficeSitesResponseBodyOfficeSitesLogs struct {
	// The log level.
	//
	// Valid values:
	//
	// *   ERROR: errors
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   INFO: information
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   WARN: warnings
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Level *string `json:"Level,omitempty" xml:"Level,omitempty"`
	// Details of the log entry.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The step that corresponds to the log entry.
	Step *string `json:"Step,omitempty" xml:"Step,omitempty"`
	// The time when the log entry was printed.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeOfficeSitesResponseBodyOfficeSitesLogs) String() string {
	return tea.Prettify(s)
}

func (s DescribeOfficeSitesResponseBodyOfficeSitesLogs) GoString() string {
	return s.String()
}

func (s *DescribeOfficeSitesResponseBodyOfficeSitesLogs) SetLevel(v string) *DescribeOfficeSitesResponseBodyOfficeSitesLogs {
	s.Level = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSitesLogs) SetMessage(v string) *DescribeOfficeSitesResponseBodyOfficeSitesLogs {
	s.Message = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSitesLogs) SetStep(v string) *DescribeOfficeSitesResponseBodyOfficeSitesLogs {
	s.Step = &v
	return s
}

func (s *DescribeOfficeSitesResponseBodyOfficeSitesLogs) SetTimeStamp(v string) *DescribeOfficeSitesResponseBodyOfficeSitesLogs {
	s.TimeStamp = &v
	return s
}

type DescribeOfficeSitesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeOfficeSitesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeOfficeSitesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeOfficeSitesResponse) GoString() string {
	return s.String()
}

func (s *DescribeOfficeSitesResponse) SetHeaders(v map[string]*string) *DescribeOfficeSitesResponse {
	s.Headers = v
	return s
}

func (s *DescribeOfficeSitesResponse) SetStatusCode(v int32) *DescribeOfficeSitesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeOfficeSitesResponse) SetBody(v *DescribeOfficeSitesResponseBody) *DescribeOfficeSitesResponse {
	s.Body = v
	return s
}

type DescribePolicyGroupsRequest struct {
	// The number of entries per page.
	//
	// *   Valid values: 1 to 100
	// *   Default value: 10
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The policy IDs. You can specify one or more policy IDs.
	PolicyGroupId []*string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty" type:"Repeated"`
	// The region ID. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The effective scope of the policy. Valid values:
	//
	// *   GLOBAL: The policy takes effect globally.
	// *   IP: The policy takes effect based on the IP address.
	// *   ALL: The policy takes effect without limits.
	//
	// Default value: GLOBAL.
	Scope *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
}

func (s DescribePolicyGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePolicyGroupsRequest) GoString() string {
	return s.String()
}

func (s *DescribePolicyGroupsRequest) SetMaxResults(v int32) *DescribePolicyGroupsRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribePolicyGroupsRequest) SetNextToken(v string) *DescribePolicyGroupsRequest {
	s.NextToken = &v
	return s
}

func (s *DescribePolicyGroupsRequest) SetPolicyGroupId(v []*string) *DescribePolicyGroupsRequest {
	s.PolicyGroupId = v
	return s
}

func (s *DescribePolicyGroupsRequest) SetRegionId(v string) *DescribePolicyGroupsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribePolicyGroupsRequest) SetScope(v string) *DescribePolicyGroupsRequest {
	s.Scope = &v
	return s
}

type DescribePolicyGroupsResponseBody struct {
	// Details of the policies.
	DescribePolicyGroups []*DescribePolicyGroupsResponseBodyDescribePolicyGroups `json:"DescribePolicyGroups,omitempty" xml:"DescribePolicyGroups,omitempty" type:"Repeated"`
	// A pagination token. It can be used in the next request to retrieve a new page of results. If NextToken is empty, no next page exists.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribePolicyGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePolicyGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePolicyGroupsResponseBody) SetDescribePolicyGroups(v []*DescribePolicyGroupsResponseBodyDescribePolicyGroups) *DescribePolicyGroupsResponseBody {
	s.DescribePolicyGroups = v
	return s
}

func (s *DescribePolicyGroupsResponseBody) SetNextToken(v string) *DescribePolicyGroupsResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribePolicyGroupsResponseBody) SetRequestId(v string) *DescribePolicyGroupsResponseBody {
	s.RequestId = &v
	return s
}

type DescribePolicyGroupsResponseBodyDescribePolicyGroups struct {
	AdminAccess *string `json:"AdminAccess,omitempty" xml:"AdminAccess,omitempty"`
	// Indicates whether the anti-screenshot feature is enabled. Valid values:
	//
	// *   on: This feature is enabled.
	// *   off: This feature is disabled.
	//
	// Default value: off.
	AppContentProtection *string `json:"AppContentProtection,omitempty" xml:"AppContentProtection,omitempty"`
	// The client CIDR blocks in the whitelist.
	AuthorizeAccessPolicyRules []*DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules `json:"AuthorizeAccessPolicyRules,omitempty" xml:"AuthorizeAccessPolicyRules,omitempty" type:"Repeated"`
	// The security group rules.
	AuthorizeSecurityPolicyRules []*DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules `json:"AuthorizeSecurityPolicyRules,omitempty" xml:"AuthorizeSecurityPolicyRules,omitempty" type:"Repeated"`
	// Indicates whether the webcam redirection feature is enabled.
	//
	// Valid values:
	//
	// *   off: The feature is disabled.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   on (default): The feature is enabled.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	CameraRedirect *string `json:"CameraRedirect,omitempty" xml:"CameraRedirect,omitempty"`
	// The logon methods.
	ClientTypes []*DescribePolicyGroupsResponseBodyDescribePolicyGroupsClientTypes `json:"ClientTypes,omitempty" xml:"ClientTypes,omitempty" type:"Repeated"`
	// The permissions on the clipboard.
	//
	// Valid values:
	//
	// *   read: One-way transfer is allowed.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   readwrite: Two-way transfer is allowed.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   off: Two-way transfer is not allowed.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Clipboard            *string   `json:"Clipboard,omitempty" xml:"Clipboard,omitempty"`
	CpuDownGradeDuration *int32    `json:"CpuDownGradeDuration,omitempty" xml:"CpuDownGradeDuration,omitempty"`
	CpuProcessors        []*string `json:"CpuProcessors,omitempty" xml:"CpuProcessors,omitempty" type:"Repeated"`
	CpuProtectedMode     *string   `json:"CpuProtectedMode,omitempty" xml:"CpuProtectedMode,omitempty"`
	CpuRateLimit         *int32    `json:"CpuRateLimit,omitempty" xml:"CpuRateLimit,omitempty"`
	CpuSampleDuration    *int32    `json:"CpuSampleDuration,omitempty" xml:"CpuSampleDuration,omitempty"`
	CpuSingleRateLimit   *int32    `json:"CpuSingleRateLimit,omitempty" xml:"CpuSingleRateLimit,omitempty"`
	// The access control for domain names. The domain names can contain the wildcard character (\*). Multiple domain names are separated by commas (,). Valid values:
	//
	// *   off: This feature is disabled.
	// *   on: This feature is enabled.
	DomainList *string `json:"DomainList,omitempty" xml:"DomainList,omitempty"`
	// The resolution of domain names.
	DomainResolveRule []*DescribePolicyGroupsResponseBodyDescribePolicyGroupsDomainResolveRule `json:"DomainResolveRule,omitempty" xml:"DomainResolveRule,omitempty" type:"Repeated"`
	// Indicates whether the switch for domain name resolution is turned on.
	//
	// Valid values:
	//
	// *   off
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   on
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	DomainResolveRuleType *string `json:"DomainResolveRuleType,omitempty" xml:"DomainResolveRuleType,omitempty"`
	// The number of cloud desktops that are associated with the policy.\
	// This parameter is returned only if PolicyGroupType is set to CUSTOM.
	EdsCount *int32 `json:"EdsCount,omitempty" xml:"EdsCount,omitempty"`
	// Indicates whether the switch for end users to ask for assistance from the administrator is turned on. Valid values: on off
	EndUserApplyAdminCoordinate *string `json:"EndUserApplyAdminCoordinate,omitempty" xml:"EndUserApplyAdminCoordinate,omitempty"`
	// The switch for stream collaboration between end users. Valid values: on off
	EndUserGroupCoordinate *string `json:"EndUserGroupCoordinate,omitempty" xml:"EndUserGroupCoordinate,omitempty"`
	// Indicates whether the image quality policy is enabled for Graphics cloud desktops. If you have high requirements for desktop performance and user experience, we recommend that you enable this feature. For example, you can enable this feature in professional design scenarios.
	//
	// Valid values:
	//
	// *   off: The feature is disabled.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   on: This feature is enabled.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	GpuAcceleration *string `json:"GpuAcceleration,omitempty" xml:"GpuAcceleration,omitempty"`
	// The HTML5 client access feature.
	//
	// Valid values:
	//
	// *   off (default)
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     disabled
	//
	//     <!-- -->
	//
	// *   on
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     enabled
	//
	//     <!-- -->
	Html5Access *string `json:"Html5Access,omitempty" xml:"Html5Access,omitempty"`
	// The file transfer feature for the HTML5 client.
	//
	// Valid values:
	//
	// *   all: Files can be uploaded and downloaded between your computer and HTML5 clients.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   download: Files on HTML5 clients can be downloaded to your computer.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   upload: Files on your computer can be uploaded to HTML5 clients.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   off (default): File transfer between HTML5 clients and your computer is disabled.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Html5FileTransfer *string `json:"Html5FileTransfer,omitempty" xml:"Html5FileTransfer,omitempty"`
	// The protocol that is used for network communication. Valid values:
	//
	// *   TCP: Only the TCP protocol is used.
	// *   BOTH: The automatic switchover between the TCP protocol and the UDP protocol is supported.
	//
	// Default value: TCP.
	InternetCommunicationProtocol *string `json:"InternetCommunicationProtocol,omitempty" xml:"InternetCommunicationProtocol,omitempty"`
	// The permissions on local disk mapping.
	//
	// Valid values:
	//
	// *   read: read-only
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   readwrite: read and write
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   off: no permissions
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	LocalDrive              *string   `json:"LocalDrive,omitempty" xml:"LocalDrive,omitempty"`
	MemoryDownGradeDuration *int32    `json:"MemoryDownGradeDuration,omitempty" xml:"MemoryDownGradeDuration,omitempty"`
	MemoryProcessors        []*string `json:"MemoryProcessors,omitempty" xml:"MemoryProcessors,omitempty" type:"Repeated"`
	MemoryProtectedMode     *string   `json:"MemoryProtectedMode,omitempty" xml:"MemoryProtectedMode,omitempty"`
	MemoryRateLimit         *int32    `json:"MemoryRateLimit,omitempty" xml:"MemoryRateLimit,omitempty"`
	MemorySampleDuration    *int32    `json:"MemorySampleDuration,omitempty" xml:"MemorySampleDuration,omitempty"`
	MemorySingleRateLimit   *int32    `json:"MemorySingleRateLimit,omitempty" xml:"MemorySingleRateLimit,omitempty"`
	// The policy name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Indicates whether the network redirection feature is enabled. Valid values:
	//
	// *   on: This feature is enabled.
	// *   off: The feature is disabled.
	//
	// Default value: off.
	NetRedirect *string `json:"NetRedirect,omitempty" xml:"NetRedirect,omitempty"`
	// The network redirection rules.
	NetRedirectRule []*DescribePolicyGroupsResponseBodyDescribePolicyGroupsNetRedirectRule `json:"NetRedirectRule,omitempty" xml:"NetRedirectRule,omitempty" type:"Repeated"`
	// The policy ID.
	PolicyGroupId *string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty"`
	// The rule type.
	//
	// Valid values:
	//
	// *   SYSTEM
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   CUSTOM
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	PolicyGroupType *string `json:"PolicyGroupType,omitempty" xml:"PolicyGroupType,omitempty"`
	// The state of the policy.
	//
	// Valid values:
	//
	// *   AVAILABLE
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   CREATING
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	PolicyStatus *string `json:"PolicyStatus,omitempty" xml:"PolicyStatus,omitempty"`
	// Indicates whether user preemption is allowed. The value is fixed to `off`, which indicates that user preemption is not allowed.
	PreemptLogin *string `json:"PreemptLogin,omitempty" xml:"PreemptLogin,omitempty"`
	// The names of the users that are allowed to connect to the cloud desktop to which another user is logged on.
	PreemptLoginUsers []*string `json:"PreemptLoginUsers,omitempty" xml:"PreemptLoginUsers,omitempty" type:"Repeated"`
	// The printer redirection feature.
	//
	// Valid values:
	//
	// *   off
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The feature is disabled
	//
	//     <!-- -->
	//
	//     .
	//
	// *   on
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The feature is enabled
	//
	//     <!-- -->
	//
	//     .
	PrinterRedirection *string `json:"PrinterRedirection,omitempty" xml:"PrinterRedirection,omitempty"`
	// Indicates whether the custom screen recording feature is enabled. Valid values:
	//
	// *   on: This feature is enabled.
	// *   off: This feature is disabled.
	//
	// Default value: off.
	RecordContent *string `json:"RecordContent,omitempty" xml:"RecordContent,omitempty"`
	// The duration in which the custom screen recording is valid. Default value: 30. Unit: days.
	RecordContentExpires *int64 `json:"RecordContentExpires,omitempty" xml:"RecordContentExpires,omitempty"`
	// Indicates whether screen recording is enabled.
	//
	// Valid values:
	//
	// *   ALLTIME: All operations that are performed by end users on cloud desktops are recorded. The recording starts immediately when end users connect to cloud desktops and ends after the end users disconnect from the cloud desktops.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   PERIOD: The operations that are performed by end users on cloud desktops during a specified period of time are recorded. You must specify the start time and the end time of the recording.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   OFF: Screen recording is disabled.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Recording *string `json:"Recording,omitempty" xml:"Recording,omitempty"`
	// Indicates whether the sound that is generated on the cloud desktop is recorded during screen recording. Valid values:
	//
	// *   on: records audio and video data.
	// *   off: records only video data.
	RecordingAudio *string `json:"RecordingAudio,omitempty" xml:"RecordingAudio,omitempty"`
	// This parameter is used together with Recording. After the specified period of the recording reaches, a screen recording file is generated.
	RecordingDuration *int32 `json:"RecordingDuration,omitempty" xml:"RecordingDuration,omitempty"`
	// The time when the screen recording ended. The value is in the HH:MM:SS format. The value of this parameter is valid only if Recording is set to PERIOD.
	RecordingEndTime *string `json:"RecordingEndTime,omitempty" xml:"RecordingEndTime,omitempty"`
	// The period in which the screen recording audit is valid. Valid values: 15 to 180. Unit: days.
	RecordingExpires *int64 `json:"RecordingExpires,omitempty" xml:"RecordingExpires,omitempty"`
	// The frame rate of screen recording. Unit: fps. Valid values:
	//
	// *   2
	// *   5
	// *   10
	// *   15
	RecordingFps *int64 `json:"RecordingFps,omitempty" xml:"RecordingFps,omitempty"`
	// The time when the screen recording was started. The value is in the HH:MM:SS format. The value of this parameter is valid only if Recording is set to PERIOD.
	RecordingStartTime *string `json:"RecordingStartTime,omitempty" xml:"RecordingStartTime,omitempty"`
	// The permissions on the keyboard and mouse to control the cloud desktop during remote assistance. Valid values:
	//
	// *   fullControl: The keyboard and mouse are fully controlled.
	// *   optionalControl: By default, you do not have the permissions on the keyboard or mouse to control the cloud desktop during remote assistance. You can apply for the permissions.
	// *   disableControl: The keyboard and mouse are not controlled.
	RemoteCoordinate *string `json:"RemoteCoordinate,omitempty" xml:"RemoteCoordinate,omitempty"`
	// The effective scope of the policy. Valid values:
	//
	// *   GLOBAL: The policy takes effect globally.
	// *   IP: The policy takes effect based on the IP address.
	Scope *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
	// This parameter is specified if Scope is set to IP.
	ScopeValue []*string `json:"ScopeValue,omitempty" xml:"ScopeValue,omitempty" type:"Repeated"`
	// Indicates whether the USB redirection feature is enabled.
	//
	// Valid values:
	//
	// *   off: The feature is disabled.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   on: This feature is enabled.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	UsbRedirect *string `json:"UsbRedirect,omitempty" xml:"UsbRedirect,omitempty"`
	// The USB redirection rules.
	UsbSupplyRedirectRule []*DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule `json:"UsbSupplyRedirectRule,omitempty" xml:"UsbSupplyRedirectRule,omitempty" type:"Repeated"`
	// Indicates whether the multimedia redirection feature is enabled. Valid values: on: The feature is enabled. off: The feature is disabled.
	VideoRedirect *string `json:"VideoRedirect,omitempty" xml:"VideoRedirect,omitempty"`
	// The image display quality feature.
	//
	// Valid values:
	//
	// *   high
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     high-definition (HD)
	//
	//     <!-- -->
	//
	// *   low
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     fluent
	//
	//     <!-- -->
	//
	// *   medium (default)
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     adaptive
	//
	//     <!-- -->
	//
	// *   lossless
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     no quality loss
	//
	//     <!-- -->
	VisualQuality *string `json:"VisualQuality,omitempty" xml:"VisualQuality,omitempty"`
	// Indicates whether the watermark feature is enabled.
	//
	// Valid values:
	//
	// *   off: The feature is disabled.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   on: This feature is enabled.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Watermark *string `json:"Watermark,omitempty" xml:"Watermark,omitempty"`
	// The font color of the watermark. Valid values: 0 to 16777215.
	WatermarkColor *int32 `json:"WatermarkColor,omitempty" xml:"WatermarkColor,omitempty"`
	// This parameter is unavailable for public use.
	WatermarkCustomText *string `json:"WatermarkCustomText,omitempty" xml:"WatermarkCustomText,omitempty"`
	// The inclination angle of the watermark. Valid values: -10 to -30.
	WatermarkDegree *float64 `json:"WatermarkDegree,omitempty" xml:"WatermarkDegree,omitempty"`
	// The font size of the watermark. Valid values: 10 to 20.
	WatermarkFontSize *int32 `json:"WatermarkFontSize,omitempty" xml:"WatermarkFontSize,omitempty"`
	// The font style of the watermark. Valid values:
	//
	// *   plain
	// *   bold
	WatermarkFontStyle *string `json:"WatermarkFontStyle,omitempty" xml:"WatermarkFontStyle,omitempty"`
	// The number of watermark rows. This parameter is now invalid.
	WatermarkRowAmount *int32  `json:"WatermarkRowAmount,omitempty" xml:"WatermarkRowAmount,omitempty"`
	WatermarkSecurity  *string `json:"WatermarkSecurity,omitempty" xml:"WatermarkSecurity,omitempty"`
	// The watermark transparency.
	//
	// Valid values:
	//
	// *   LIGHT
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   DARK
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   MIDDLE
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	WatermarkTransparency *string `json:"WatermarkTransparency,omitempty" xml:"WatermarkTransparency,omitempty"`
	// The watermark transparency. A larger value indicates that the watermark is less transparent. Valid values: 10 to 100.
	WatermarkTransparencyValue *int32 `json:"WatermarkTransparencyValue,omitempty" xml:"WatermarkTransparencyValue,omitempty"`
	// The watermark type.
	//
	// Valid values:
	//
	// *   HostName,EndUserId: The watermark is displayed in the following format: Rightmost 15 characters of the cloud desktop ID,Username.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   EndUserId: The username is displayed.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   EndUserId,HostName: The watermark is displayed in the following format: Username,Rightmost 15 characters of the cloud desktop ID.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   HostName: The rightmost 15 characters of the cloud desktop ID are displayed.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	WatermarkType *string `json:"WatermarkType,omitempty" xml:"WatermarkType,omitempty"`
}

func (s DescribePolicyGroupsResponseBodyDescribePolicyGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribePolicyGroupsResponseBodyDescribePolicyGroups) GoString() string {
	return s.String()
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetAdminAccess(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.AdminAccess = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetAppContentProtection(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.AppContentProtection = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetAuthorizeAccessPolicyRules(v []*DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.AuthorizeAccessPolicyRules = v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetAuthorizeSecurityPolicyRules(v []*DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.AuthorizeSecurityPolicyRules = v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetCameraRedirect(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.CameraRedirect = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetClientTypes(v []*DescribePolicyGroupsResponseBodyDescribePolicyGroupsClientTypes) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.ClientTypes = v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetClipboard(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.Clipboard = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetCpuDownGradeDuration(v int32) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.CpuDownGradeDuration = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetCpuProcessors(v []*string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.CpuProcessors = v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetCpuProtectedMode(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.CpuProtectedMode = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetCpuRateLimit(v int32) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.CpuRateLimit = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetCpuSampleDuration(v int32) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.CpuSampleDuration = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetCpuSingleRateLimit(v int32) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.CpuSingleRateLimit = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetDomainList(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.DomainList = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetDomainResolveRule(v []*DescribePolicyGroupsResponseBodyDescribePolicyGroupsDomainResolveRule) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.DomainResolveRule = v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetDomainResolveRuleType(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.DomainResolveRuleType = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetEdsCount(v int32) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.EdsCount = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetEndUserApplyAdminCoordinate(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.EndUserApplyAdminCoordinate = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetEndUserGroupCoordinate(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.EndUserGroupCoordinate = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetGpuAcceleration(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.GpuAcceleration = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetHtml5Access(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.Html5Access = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetHtml5FileTransfer(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.Html5FileTransfer = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetInternetCommunicationProtocol(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.InternetCommunicationProtocol = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetLocalDrive(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.LocalDrive = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetMemoryDownGradeDuration(v int32) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.MemoryDownGradeDuration = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetMemoryProcessors(v []*string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.MemoryProcessors = v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetMemoryProtectedMode(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.MemoryProtectedMode = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetMemoryRateLimit(v int32) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.MemoryRateLimit = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetMemorySampleDuration(v int32) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.MemorySampleDuration = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetMemorySingleRateLimit(v int32) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.MemorySingleRateLimit = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetName(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.Name = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetNetRedirect(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.NetRedirect = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetNetRedirectRule(v []*DescribePolicyGroupsResponseBodyDescribePolicyGroupsNetRedirectRule) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.NetRedirectRule = v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetPolicyGroupId(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.PolicyGroupId = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetPolicyGroupType(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.PolicyGroupType = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetPolicyStatus(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.PolicyStatus = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetPreemptLogin(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.PreemptLogin = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetPreemptLoginUsers(v []*string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.PreemptLoginUsers = v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetPrinterRedirection(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.PrinterRedirection = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetRecordContent(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.RecordContent = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetRecordContentExpires(v int64) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.RecordContentExpires = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetRecording(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.Recording = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetRecordingAudio(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.RecordingAudio = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetRecordingDuration(v int32) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.RecordingDuration = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetRecordingEndTime(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.RecordingEndTime = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetRecordingExpires(v int64) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.RecordingExpires = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetRecordingFps(v int64) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.RecordingFps = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetRecordingStartTime(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.RecordingStartTime = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetRemoteCoordinate(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.RemoteCoordinate = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetScope(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.Scope = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetScopeValue(v []*string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.ScopeValue = v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetUsbRedirect(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.UsbRedirect = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetUsbSupplyRedirectRule(v []*DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.UsbSupplyRedirectRule = v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetVideoRedirect(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.VideoRedirect = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetVisualQuality(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.VisualQuality = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetWatermark(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.Watermark = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetWatermarkColor(v int32) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.WatermarkColor = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetWatermarkCustomText(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.WatermarkCustomText = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetWatermarkDegree(v float64) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.WatermarkDegree = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetWatermarkFontSize(v int32) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.WatermarkFontSize = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetWatermarkFontStyle(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.WatermarkFontStyle = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetWatermarkRowAmount(v int32) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.WatermarkRowAmount = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetWatermarkSecurity(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.WatermarkSecurity = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetWatermarkTransparency(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.WatermarkTransparency = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetWatermarkTransparencyValue(v int32) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.WatermarkTransparencyValue = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroups) SetWatermarkType(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroups {
	s.WatermarkType = &v
	return s
}

type DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules struct {
	// The CIDR block that you access from the client. The value is an IPv4 CIDR block.
	CidrIp *string `json:"CidrIp,omitempty" xml:"CidrIp,omitempty"`
	// The description of the IPv4 CIDR block.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
}

func (s DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules) String() string {
	return tea.Prettify(s)
}

func (s DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules) GoString() string {
	return s.String()
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules) SetCidrIp(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules {
	s.CidrIp = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules) SetDescription(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules {
	s.Description = &v
	return s
}

type DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules struct {
	// The IPv4 CIDR block of the security group rule.
	CidrIp *string `json:"CidrIp,omitempty" xml:"CidrIp,omitempty"`
	// The description of the security group rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The protocol type of the security group rule.
	//
	// Valid values:
	//
	// *   tcp: Transmission Control Protocol (TCP)
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   udp: User Datagram Protocol (UDP)
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   all: all protocols
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   gre: Generic Routing Encapsulation (GRE)
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   icmp: ICMP (IPv4)
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	IpProtocol *string `json:"IpProtocol,omitempty" xml:"IpProtocol,omitempty"`
	// The authorization policy of the security group rule.
	//
	// Valid values:
	//
	// *   drop: denies all access requests.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   accept: accepts all access requests.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	// The port range of the security group rule.
	PortRange *string `json:"PortRange,omitempty" xml:"PortRange,omitempty"`
	// The priority of the security group rule. A smaller value indicates a higher priority.
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The direction of the security group rule.
	//
	// Valid values:
	//
	// *   outflow: outbound
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   inflow: inbound
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules) String() string {
	return tea.Prettify(s)
}

func (s DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules) GoString() string {
	return s.String()
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules) SetCidrIp(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules {
	s.CidrIp = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules) SetDescription(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules {
	s.Description = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules) SetIpProtocol(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules {
	s.IpProtocol = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules) SetPolicy(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules {
	s.Policy = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules) SetPortRange(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules {
	s.PortRange = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules) SetPriority(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules {
	s.Priority = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules) SetType(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules {
	s.Type = &v
	return s
}

type DescribePolicyGroupsResponseBodyDescribePolicyGroupsClientTypes struct {
	// The client type.
	//
	// Valid values:
	//
	// *   html5: web client
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   linux
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     WUYING hardware client
	//
	//     <!-- -->
	//
	// *   android
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     Android client
	//
	//     <!-- -->
	//
	// *   windows
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     Windows client
	//
	//     <!-- -->
	//
	// *   ios
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     iOS client
	//
	//     <!-- -->
	//
	// *   macos
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     macOS client
	//
	//     <!-- -->
	ClientType *string `json:"ClientType,omitempty" xml:"ClientType,omitempty"`
	// Indicates whether a specific type of client is allowed to connect to the cloud desktop.
	//
	// Valid values:
	//
	// *   OFF
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     not allowed
	//
	//     <!-- -->
	//
	// *   ON
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     allowed
	//
	//     <!-- -->
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribePolicyGroupsResponseBodyDescribePolicyGroupsClientTypes) String() string {
	return tea.Prettify(s)
}

func (s DescribePolicyGroupsResponseBodyDescribePolicyGroupsClientTypes) GoString() string {
	return s.String()
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsClientTypes) SetClientType(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsClientTypes {
	s.ClientType = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsClientTypes) SetStatus(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsClientTypes {
	s.Status = &v
	return s
}

type DescribePolicyGroupsResponseBodyDescribePolicyGroupsDomainResolveRule struct {
	// The policy description.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The domain name.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// Indicates whether the resolution feature is allowed.
	//
	// *   allow: The feature is allowed.
	// *   block: The feature is not allowed.
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
}

func (s DescribePolicyGroupsResponseBodyDescribePolicyGroupsDomainResolveRule) String() string {
	return tea.Prettify(s)
}

func (s DescribePolicyGroupsResponseBodyDescribePolicyGroupsDomainResolveRule) GoString() string {
	return s.String()
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsDomainResolveRule) SetDescription(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsDomainResolveRule {
	s.Description = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsDomainResolveRule) SetDomain(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsDomainResolveRule {
	s.Domain = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsDomainResolveRule) SetPolicy(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsDomainResolveRule {
	s.Policy = &v
	return s
}

type DescribePolicyGroupsResponseBodyDescribePolicyGroupsNetRedirectRule struct {
	// The content of the rule.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	// The rule type.
	//
	// Valid values:
	//
	// *   prc
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     process
	//
	//     <!-- -->
	//
	// *   domain
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     domain name
	//
	//     <!-- -->
	RuleType *string `json:"RuleType,omitempty" xml:"RuleType,omitempty"`
}

func (s DescribePolicyGroupsResponseBodyDescribePolicyGroupsNetRedirectRule) String() string {
	return tea.Prettify(s)
}

func (s DescribePolicyGroupsResponseBodyDescribePolicyGroupsNetRedirectRule) GoString() string {
	return s.String()
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsNetRedirectRule) SetDomain(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsNetRedirectRule {
	s.Domain = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsNetRedirectRule) SetPolicy(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsNetRedirectRule {
	s.Policy = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsNetRedirectRule) SetRuleType(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsNetRedirectRule {
	s.RuleType = &v
	return s
}

type DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule struct {
	// The rule description.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The device class. If you set `UsbRuleType` to 1, you must specify this parameter. For more information, see [Defined Class Codes](https://www.usb.org/defined-class-codes).
	DeviceClass *string `json:"DeviceClass,omitempty" xml:"DeviceClass,omitempty"`
	// The device subclass. This parameter is required if `UsbRuleType` is set to 1. For more information, see [Defined Class Codes](https://www.usb.org/defined-class-codes).
	DeviceSubclass *string `json:"DeviceSubclass,omitempty" xml:"DeviceSubclass,omitempty"`
	// The product ID.
	ProductId *string `json:"ProductId,omitempty" xml:"ProductId,omitempty"`
	// The USB redirection type.
	//
	// Valid values:
	//
	// *   1: allows USB redirection.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   2: forbids USB redirection.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	UsbRedirectType *int64 `json:"UsbRedirectType,omitempty" xml:"UsbRedirectType,omitempty"`
	// The type of the USB redirection rule.
	//
	// Valid values:
	//
	// *   1: by device class
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   2: by device vendor
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	UsbRuleType *int64 `json:"UsbRuleType,omitempty" xml:"UsbRuleType,omitempty"`
	// The vendor ID. For more information, see [Valid USB Vendor IDs (VIDs)](https://www.usb.org/sites/default/files/vendor_ids032322.pdf\_1.pdf).
	VendorId *string `json:"VendorId,omitempty" xml:"VendorId,omitempty"`
}

func (s DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule) String() string {
	return tea.Prettify(s)
}

func (s DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule) GoString() string {
	return s.String()
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule) SetDescription(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule {
	s.Description = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule) SetDeviceClass(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule {
	s.DeviceClass = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule) SetDeviceSubclass(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule {
	s.DeviceSubclass = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule) SetProductId(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule {
	s.ProductId = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule) SetUsbRedirectType(v int64) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule {
	s.UsbRedirectType = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule) SetUsbRuleType(v int64) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule {
	s.UsbRuleType = &v
	return s
}

func (s *DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule) SetVendorId(v string) *DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule {
	s.VendorId = &v
	return s
}

type DescribePolicyGroupsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePolicyGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePolicyGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePolicyGroupsResponse) GoString() string {
	return s.String()
}

func (s *DescribePolicyGroupsResponse) SetHeaders(v map[string]*string) *DescribePolicyGroupsResponse {
	s.Headers = v
	return s
}

func (s *DescribePolicyGroupsResponse) SetStatusCode(v int32) *DescribePolicyGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePolicyGroupsResponse) SetBody(v *DescribePolicyGroupsResponseBody) *DescribePolicyGroupsResponse {
	s.Body = v
	return s
}

type DescribePriceRequest struct {
	// The number of the resources. Default value: 1.
	Amount *int32 `json:"Amount,omitempty" xml:"Amount,omitempty"`
	// The maximum public bandwidth. Unit: Mbit/s.
	//
	// *   Valid values if the PayByTraffic parameter is set to PayByBandwidth: 10 to 1000
	// *   Valid values if the PayByTraffic parameter is set to PayByTraffic: 10 to 200
	Bandwidth          *int32                              `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	BundleModels       []*DescribePriceRequestBundleModels `json:"BundleModels,omitempty" xml:"BundleModels,omitempty" type:"Repeated"`
	EduCdsEnable       *string                             `json:"EduCdsEnable,omitempty" xml:"EduCdsEnable,omitempty"`
	EduCdsSize         *int32                              `json:"EduCdsSize,omitempty" xml:"EduCdsSize,omitempty"`
	EduCommittedTime   *int32                              `json:"EduCommittedTime,omitempty" xml:"EduCommittedTime,omitempty"`
	EduDesktopBundleId *string                             `json:"EduDesktopBundleId,omitempty" xml:"EduDesktopBundleId,omitempty"`
	EduDesktopNum      *int32                              `json:"EduDesktopNum,omitempty" xml:"EduDesktopNum,omitempty"`
	EduRoomClassify    *string                             `json:"EduRoomClassify,omitempty" xml:"EduRoomClassify,omitempty"`
	EduStudentBundleId *string                             `json:"EduStudentBundleId,omitempty" xml:"EduStudentBundleId,omitempty"`
	EduStudentNum      *int32                              `json:"EduStudentNum,omitempty" xml:"EduStudentNum,omitempty"`
	EduTeacherBundleId *string                             `json:"EduTeacherBundleId,omitempty" xml:"EduTeacherBundleId,omitempty"`
	EduTeacherNum      *int32                              `json:"EduTeacherNum,omitempty" xml:"EduTeacherNum,omitempty"`
	GroupDesktopCount  *int32                              `json:"GroupDesktopCount,omitempty" xml:"GroupDesktopCount,omitempty"`
	// The model of the WUYING hardware client.
	HardwareVersion *string `json:"HardwareVersion,omitempty" xml:"HardwareVersion,omitempty"`
	// The resource specifications.
	//
	// *   If you set ResourceType to Desktop, set this parameter to one of the following values:
	//
	//     *   ecd.basic.small
	//     *   ecd.basic.large
	//     *   ecd.advanced.large
	//     *   ecd.advanced.xlarge
	//     *   ecd.performance.2xlarge
	//     *   ecd.graphics.xlarge
	//     *   ecd.graphics.2xlarge
	//     *   ecd.advanced.xlarge_s8d2
	//     *   ecd.advanced.xlarge_s8d7
	//     *   ecd.graphics.1g72c
	//     *   eds.general.2c2g
	//     *   eds.general.2c4g
	//     *   eds.general.2c8g
	//     *   eds.general.4c8g
	//     *   eds.general.4c16g
	//     *   eds.general.8c16g
	//     *   eds.general.8c32g
	//     *   eds.general.16c32g
	//
	// *   If you set ResourceType to OfficeSite, set this parameter to large.
	//
	// *   If you set ResourceType to Bandwidth, leave this parameter empty.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The metering method of the Internet access package. Valid values:
	//
	// *   PayByBandwidth: pay-by-bandwidth
	// *   PayByTraffic: pay-by-data-transfer
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	NetworkType        *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	// The OS. Valid values:
	//
	// *   Windows
	// *   Linux
	//
	// Default value: Windows.
	OsType      *string `json:"OsType,omitempty" xml:"OsType,omitempty"`
	PackageSize *int32  `json:"PackageSize,omitempty" xml:"PackageSize,omitempty"`
	// The subscription duration. Default value: 1.
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The unit of the billing cycle. Valid values:
	//
	// *   Hour
	// *   Month
	// *   Year
	//
	// Default value: Hour.
	PeriodUnit *string `json:"PeriodUnit,omitempty" xml:"PeriodUnit,omitempty"`
	// The promotion ID.
	PromotionId *string `json:"PromotionId,omitempty" xml:"PromotionId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource type. Valid values:
	//
	// *   Desktop: cloud desktop
	// *   OfficeSite: workspace
	// *   Bandwidth: network bandwidth
	//
	// Default value: Desktop.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The performance level (PL) of the system disk. Valid values:
	//
	// *   PL0
	// *   PL1
	// *   PL2
	// *   PL3
	RootDiskPerformanceLevel *string `json:"RootDiskPerformanceLevel,omitempty" xml:"RootDiskPerformanceLevel,omitempty"`
	// The system disk size. Unit: GiB.
	RootDiskSizeGib *int32  `json:"RootDiskSizeGib,omitempty" xml:"RootDiskSizeGib,omitempty"`
	SpPeriodInfo    *string `json:"SpPeriodInfo,omitempty" xml:"SpPeriodInfo,omitempty"`
	SpPrice         *bool   `json:"SpPrice,omitempty" xml:"SpPrice,omitempty"`
	SpType          *string `json:"SpType,omitempty" xml:"SpType,omitempty"`
	// The PL of the data disk. Valid values:
	//
	// *   PL0
	// *   PL1
	// *   PL2
	// *   PL3
	UserDiskPerformanceLevel *string `json:"UserDiskPerformanceLevel,omitempty" xml:"UserDiskPerformanceLevel,omitempty"`
	// The data disk size. Unit: GiB.
	UserDiskSizeGib *int32 `json:"UserDiskSizeGib,omitempty" xml:"UserDiskSizeGib,omitempty"`
}

func (s DescribePriceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceRequest) GoString() string {
	return s.String()
}

func (s *DescribePriceRequest) SetAmount(v int32) *DescribePriceRequest {
	s.Amount = &v
	return s
}

func (s *DescribePriceRequest) SetBandwidth(v int32) *DescribePriceRequest {
	s.Bandwidth = &v
	return s
}

func (s *DescribePriceRequest) SetBundleModels(v []*DescribePriceRequestBundleModels) *DescribePriceRequest {
	s.BundleModels = v
	return s
}

func (s *DescribePriceRequest) SetEduCdsEnable(v string) *DescribePriceRequest {
	s.EduCdsEnable = &v
	return s
}

func (s *DescribePriceRequest) SetEduCdsSize(v int32) *DescribePriceRequest {
	s.EduCdsSize = &v
	return s
}

func (s *DescribePriceRequest) SetEduCommittedTime(v int32) *DescribePriceRequest {
	s.EduCommittedTime = &v
	return s
}

func (s *DescribePriceRequest) SetEduDesktopBundleId(v string) *DescribePriceRequest {
	s.EduDesktopBundleId = &v
	return s
}

func (s *DescribePriceRequest) SetEduDesktopNum(v int32) *DescribePriceRequest {
	s.EduDesktopNum = &v
	return s
}

func (s *DescribePriceRequest) SetEduRoomClassify(v string) *DescribePriceRequest {
	s.EduRoomClassify = &v
	return s
}

func (s *DescribePriceRequest) SetEduStudentBundleId(v string) *DescribePriceRequest {
	s.EduStudentBundleId = &v
	return s
}

func (s *DescribePriceRequest) SetEduStudentNum(v int32) *DescribePriceRequest {
	s.EduStudentNum = &v
	return s
}

func (s *DescribePriceRequest) SetEduTeacherBundleId(v string) *DescribePriceRequest {
	s.EduTeacherBundleId = &v
	return s
}

func (s *DescribePriceRequest) SetEduTeacherNum(v int32) *DescribePriceRequest {
	s.EduTeacherNum = &v
	return s
}

func (s *DescribePriceRequest) SetGroupDesktopCount(v int32) *DescribePriceRequest {
	s.GroupDesktopCount = &v
	return s
}

func (s *DescribePriceRequest) SetHardwareVersion(v string) *DescribePriceRequest {
	s.HardwareVersion = &v
	return s
}

func (s *DescribePriceRequest) SetInstanceType(v string) *DescribePriceRequest {
	s.InstanceType = &v
	return s
}

func (s *DescribePriceRequest) SetInternetChargeType(v string) *DescribePriceRequest {
	s.InternetChargeType = &v
	return s
}

func (s *DescribePriceRequest) SetNetworkType(v string) *DescribePriceRequest {
	s.NetworkType = &v
	return s
}

func (s *DescribePriceRequest) SetOsType(v string) *DescribePriceRequest {
	s.OsType = &v
	return s
}

func (s *DescribePriceRequest) SetPackageSize(v int32) *DescribePriceRequest {
	s.PackageSize = &v
	return s
}

func (s *DescribePriceRequest) SetPeriod(v int32) *DescribePriceRequest {
	s.Period = &v
	return s
}

func (s *DescribePriceRequest) SetPeriodUnit(v string) *DescribePriceRequest {
	s.PeriodUnit = &v
	return s
}

func (s *DescribePriceRequest) SetPromotionId(v string) *DescribePriceRequest {
	s.PromotionId = &v
	return s
}

func (s *DescribePriceRequest) SetRegionId(v string) *DescribePriceRequest {
	s.RegionId = &v
	return s
}

func (s *DescribePriceRequest) SetResourceType(v string) *DescribePriceRequest {
	s.ResourceType = &v
	return s
}

func (s *DescribePriceRequest) SetRootDiskPerformanceLevel(v string) *DescribePriceRequest {
	s.RootDiskPerformanceLevel = &v
	return s
}

func (s *DescribePriceRequest) SetRootDiskSizeGib(v int32) *DescribePriceRequest {
	s.RootDiskSizeGib = &v
	return s
}

func (s *DescribePriceRequest) SetSpPeriodInfo(v string) *DescribePriceRequest {
	s.SpPeriodInfo = &v
	return s
}

func (s *DescribePriceRequest) SetSpPrice(v bool) *DescribePriceRequest {
	s.SpPrice = &v
	return s
}

func (s *DescribePriceRequest) SetSpType(v string) *DescribePriceRequest {
	s.SpType = &v
	return s
}

func (s *DescribePriceRequest) SetUserDiskPerformanceLevel(v string) *DescribePriceRequest {
	s.UserDiskPerformanceLevel = &v
	return s
}

func (s *DescribePriceRequest) SetUserDiskSizeGib(v int32) *DescribePriceRequest {
	s.UserDiskSizeGib = &v
	return s
}

type DescribePriceRequestBundleModels struct {
	Amount   *int32  `json:"Amount,omitempty" xml:"Amount,omitempty"`
	BundleId *string `json:"BundleId,omitempty" xml:"BundleId,omitempty"`
	Duration *int32  `json:"Duration,omitempty" xml:"Duration,omitempty"`
}

func (s DescribePriceRequestBundleModels) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceRequestBundleModels) GoString() string {
	return s.String()
}

func (s *DescribePriceRequestBundleModels) SetAmount(v int32) *DescribePriceRequestBundleModels {
	s.Amount = &v
	return s
}

func (s *DescribePriceRequestBundleModels) SetBundleId(v string) *DescribePriceRequestBundleModels {
	s.BundleId = &v
	return s
}

func (s *DescribePriceRequestBundleModels) SetDuration(v int32) *DescribePriceRequestBundleModels {
	s.Duration = &v
	return s
}

type DescribePriceResponseBody struct {
	// The price details.
	PriceInfo *DescribePriceResponseBodyPriceInfo `json:"PriceInfo,omitempty" xml:"PriceInfo,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribePriceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePriceResponseBody) SetPriceInfo(v *DescribePriceResponseBodyPriceInfo) *DescribePriceResponseBody {
	s.PriceInfo = v
	return s
}

func (s *DescribePriceResponseBody) SetRequestId(v string) *DescribePriceResponseBody {
	s.RequestId = &v
	return s
}

type DescribePriceResponseBodyPriceInfo struct {
	FreeCdsQuota *bool  `json:"FreeCdsQuota,omitempty" xml:"FreeCdsQuota,omitempty"`
	FreeCdsSize  *int64 `json:"FreeCdsSize,omitempty" xml:"FreeCdsSize,omitempty"`
	// The information about the price.
	Price *DescribePriceResponseBodyPriceInfoPrice `json:"Price,omitempty" xml:"Price,omitempty" type:"Struct"`
	// The details of the promotion rules.
	Rules []*DescribePriceResponseBodyPriceInfoRules `json:"Rules,omitempty" xml:"Rules,omitempty" type:"Repeated"`
}

func (s DescribePriceResponseBodyPriceInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceResponseBodyPriceInfo) GoString() string {
	return s.String()
}

func (s *DescribePriceResponseBodyPriceInfo) SetFreeCdsQuota(v bool) *DescribePriceResponseBodyPriceInfo {
	s.FreeCdsQuota = &v
	return s
}

func (s *DescribePriceResponseBodyPriceInfo) SetFreeCdsSize(v int64) *DescribePriceResponseBodyPriceInfo {
	s.FreeCdsSize = &v
	return s
}

func (s *DescribePriceResponseBodyPriceInfo) SetPrice(v *DescribePriceResponseBodyPriceInfoPrice) *DescribePriceResponseBodyPriceInfo {
	s.Price = v
	return s
}

func (s *DescribePriceResponseBodyPriceInfo) SetRules(v []*DescribePriceResponseBodyPriceInfoRules) *DescribePriceResponseBodyPriceInfo {
	s.Rules = v
	return s
}

type DescribePriceResponseBodyPriceInfoPrice struct {
	// The unit of the currency.
	Currency *string `json:"Currency,omitempty" xml:"Currency,omitempty"`
	// The discounted price.
	DiscountPrice *float32           `json:"DiscountPrice,omitempty" xml:"DiscountPrice,omitempty"`
	OrderLines    map[string]*string `json:"OrderLines,omitempty" xml:"OrderLines,omitempty"`
	// The original price.
	OriginalPrice *float32 `json:"OriginalPrice,omitempty" xml:"OriginalPrice,omitempty"`
	// The details of the promotion.
	Promotions []*DescribePriceResponseBodyPriceInfoPricePromotions `json:"Promotions,omitempty" xml:"Promotions,omitempty" type:"Repeated"`
	SpPrice    *int64                                               `json:"SpPrice,omitempty" xml:"SpPrice,omitempty"`
	// The actual price that is paid. The original price minus the discounted part equals the actual price.
	TradePrice *float32 `json:"TradePrice,omitempty" xml:"TradePrice,omitempty"`
}

func (s DescribePriceResponseBodyPriceInfoPrice) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceResponseBodyPriceInfoPrice) GoString() string {
	return s.String()
}

func (s *DescribePriceResponseBodyPriceInfoPrice) SetCurrency(v string) *DescribePriceResponseBodyPriceInfoPrice {
	s.Currency = &v
	return s
}

func (s *DescribePriceResponseBodyPriceInfoPrice) SetDiscountPrice(v float32) *DescribePriceResponseBodyPriceInfoPrice {
	s.DiscountPrice = &v
	return s
}

func (s *DescribePriceResponseBodyPriceInfoPrice) SetOrderLines(v map[string]*string) *DescribePriceResponseBodyPriceInfoPrice {
	s.OrderLines = v
	return s
}

func (s *DescribePriceResponseBodyPriceInfoPrice) SetOriginalPrice(v float32) *DescribePriceResponseBodyPriceInfoPrice {
	s.OriginalPrice = &v
	return s
}

func (s *DescribePriceResponseBodyPriceInfoPrice) SetPromotions(v []*DescribePriceResponseBodyPriceInfoPricePromotions) *DescribePriceResponseBodyPriceInfoPrice {
	s.Promotions = v
	return s
}

func (s *DescribePriceResponseBodyPriceInfoPrice) SetSpPrice(v int64) *DescribePriceResponseBodyPriceInfoPrice {
	s.SpPrice = &v
	return s
}

func (s *DescribePriceResponseBodyPriceInfoPrice) SetTradePrice(v float32) *DescribePriceResponseBodyPriceInfoPrice {
	s.TradePrice = &v
	return s
}

type DescribePriceResponseBodyPriceInfoPricePromotions struct {
	// The description of the promotion rule.
	OptionCode *string `json:"OptionCode,omitempty" xml:"OptionCode,omitempty"`
	// The description of the promotion.
	PromotionDesc *string `json:"PromotionDesc,omitempty" xml:"PromotionDesc,omitempty"`
	// The promotion ID.
	PromotionId *string `json:"PromotionId,omitempty" xml:"PromotionId,omitempty"`
	// The promotion name.
	PromotionName *string `json:"PromotionName,omitempty" xml:"PromotionName,omitempty"`
	// Indicates whether an item is selected.
	Selected *bool `json:"Selected,omitempty" xml:"Selected,omitempty"`
}

func (s DescribePriceResponseBodyPriceInfoPricePromotions) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceResponseBodyPriceInfoPricePromotions) GoString() string {
	return s.String()
}

func (s *DescribePriceResponseBodyPriceInfoPricePromotions) SetOptionCode(v string) *DescribePriceResponseBodyPriceInfoPricePromotions {
	s.OptionCode = &v
	return s
}

func (s *DescribePriceResponseBodyPriceInfoPricePromotions) SetPromotionDesc(v string) *DescribePriceResponseBodyPriceInfoPricePromotions {
	s.PromotionDesc = &v
	return s
}

func (s *DescribePriceResponseBodyPriceInfoPricePromotions) SetPromotionId(v string) *DescribePriceResponseBodyPriceInfoPricePromotions {
	s.PromotionId = &v
	return s
}

func (s *DescribePriceResponseBodyPriceInfoPricePromotions) SetPromotionName(v string) *DescribePriceResponseBodyPriceInfoPricePromotions {
	s.PromotionName = &v
	return s
}

func (s *DescribePriceResponseBodyPriceInfoPricePromotions) SetSelected(v bool) *DescribePriceResponseBodyPriceInfoPricePromotions {
	s.Selected = &v
	return s
}

type DescribePriceResponseBodyPriceInfoRules struct {
	// The description of the rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The rule ID.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
}

func (s DescribePriceResponseBodyPriceInfoRules) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceResponseBodyPriceInfoRules) GoString() string {
	return s.String()
}

func (s *DescribePriceResponseBodyPriceInfoRules) SetDescription(v string) *DescribePriceResponseBodyPriceInfoRules {
	s.Description = &v
	return s
}

func (s *DescribePriceResponseBodyPriceInfoRules) SetRuleId(v int64) *DescribePriceResponseBodyPriceInfoRules {
	s.RuleId = &v
	return s
}

type DescribePriceResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePriceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePriceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceResponse) GoString() string {
	return s.String()
}

func (s *DescribePriceResponse) SetHeaders(v map[string]*string) *DescribePriceResponse {
	s.Headers = v
	return s
}

func (s *DescribePriceResponse) SetStatusCode(v int32) *DescribePriceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePriceResponse) SetBody(v *DescribePriceResponseBody) *DescribePriceResponse {
	s.Body = v
	return s
}

type DescribePriceForCreateDesktopOversoldGroupRequest struct {
	ConcurrenceCount  *int32  `json:"ConcurrenceCount,omitempty" xml:"ConcurrenceCount,omitempty"`
	DataDiskSize      *int32  `json:"DataDiskSize,omitempty" xml:"DataDiskSize,omitempty"`
	DesktopType       *string `json:"DesktopType,omitempty" xml:"DesktopType,omitempty"`
	OversoldUserCount *int32  `json:"OversoldUserCount,omitempty" xml:"OversoldUserCount,omitempty"`
	Period            *int32  `json:"Period,omitempty" xml:"Period,omitempty"`
	PeriodUnit        *string `json:"PeriodUnit,omitempty" xml:"PeriodUnit,omitempty"`
	SystemDiskSize    *int32  `json:"SystemDiskSize,omitempty" xml:"SystemDiskSize,omitempty"`
}

func (s DescribePriceForCreateDesktopOversoldGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceForCreateDesktopOversoldGroupRequest) GoString() string {
	return s.String()
}

func (s *DescribePriceForCreateDesktopOversoldGroupRequest) SetConcurrenceCount(v int32) *DescribePriceForCreateDesktopOversoldGroupRequest {
	s.ConcurrenceCount = &v
	return s
}

func (s *DescribePriceForCreateDesktopOversoldGroupRequest) SetDataDiskSize(v int32) *DescribePriceForCreateDesktopOversoldGroupRequest {
	s.DataDiskSize = &v
	return s
}

func (s *DescribePriceForCreateDesktopOversoldGroupRequest) SetDesktopType(v string) *DescribePriceForCreateDesktopOversoldGroupRequest {
	s.DesktopType = &v
	return s
}

func (s *DescribePriceForCreateDesktopOversoldGroupRequest) SetOversoldUserCount(v int32) *DescribePriceForCreateDesktopOversoldGroupRequest {
	s.OversoldUserCount = &v
	return s
}

func (s *DescribePriceForCreateDesktopOversoldGroupRequest) SetPeriod(v int32) *DescribePriceForCreateDesktopOversoldGroupRequest {
	s.Period = &v
	return s
}

func (s *DescribePriceForCreateDesktopOversoldGroupRequest) SetPeriodUnit(v string) *DescribePriceForCreateDesktopOversoldGroupRequest {
	s.PeriodUnit = &v
	return s
}

func (s *DescribePriceForCreateDesktopOversoldGroupRequest) SetSystemDiskSize(v int32) *DescribePriceForCreateDesktopOversoldGroupRequest {
	s.SystemDiskSize = &v
	return s
}

type DescribePriceForCreateDesktopOversoldGroupResponseBody struct {
	Data      *DescribePriceForCreateDesktopOversoldGroupResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	RequestId *string                                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribePriceForCreateDesktopOversoldGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceForCreateDesktopOversoldGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePriceForCreateDesktopOversoldGroupResponseBody) SetData(v *DescribePriceForCreateDesktopOversoldGroupResponseBodyData) *DescribePriceForCreateDesktopOversoldGroupResponseBody {
	s.Data = v
	return s
}

func (s *DescribePriceForCreateDesktopOversoldGroupResponseBody) SetRequestId(v string) *DescribePriceForCreateDesktopOversoldGroupResponseBody {
	s.RequestId = &v
	return s
}

type DescribePriceForCreateDesktopOversoldGroupResponseBodyData struct {
	Price *string `json:"Price,omitempty" xml:"Price,omitempty"`
}

func (s DescribePriceForCreateDesktopOversoldGroupResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceForCreateDesktopOversoldGroupResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribePriceForCreateDesktopOversoldGroupResponseBodyData) SetPrice(v string) *DescribePriceForCreateDesktopOversoldGroupResponseBodyData {
	s.Price = &v
	return s
}

type DescribePriceForCreateDesktopOversoldGroupResponse struct {
	Headers    map[string]*string                                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePriceForCreateDesktopOversoldGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePriceForCreateDesktopOversoldGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceForCreateDesktopOversoldGroupResponse) GoString() string {
	return s.String()
}

func (s *DescribePriceForCreateDesktopOversoldGroupResponse) SetHeaders(v map[string]*string) *DescribePriceForCreateDesktopOversoldGroupResponse {
	s.Headers = v
	return s
}

func (s *DescribePriceForCreateDesktopOversoldGroupResponse) SetStatusCode(v int32) *DescribePriceForCreateDesktopOversoldGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePriceForCreateDesktopOversoldGroupResponse) SetBody(v *DescribePriceForCreateDesktopOversoldGroupResponseBody) *DescribePriceForCreateDesktopOversoldGroupResponse {
	s.Body = v
	return s
}

type DescribePriceForModifyDesktopOversoldGroupSaleRequest struct {
	ConcurrenceCount  *int32  `json:"ConcurrenceCount,omitempty" xml:"ConcurrenceCount,omitempty"`
	OversoldGroupId   *string `json:"OversoldGroupId,omitempty" xml:"OversoldGroupId,omitempty"`
	OversoldUserCount *int32  `json:"OversoldUserCount,omitempty" xml:"OversoldUserCount,omitempty"`
}

func (s DescribePriceForModifyDesktopOversoldGroupSaleRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceForModifyDesktopOversoldGroupSaleRequest) GoString() string {
	return s.String()
}

func (s *DescribePriceForModifyDesktopOversoldGroupSaleRequest) SetConcurrenceCount(v int32) *DescribePriceForModifyDesktopOversoldGroupSaleRequest {
	s.ConcurrenceCount = &v
	return s
}

func (s *DescribePriceForModifyDesktopOversoldGroupSaleRequest) SetOversoldGroupId(v string) *DescribePriceForModifyDesktopOversoldGroupSaleRequest {
	s.OversoldGroupId = &v
	return s
}

func (s *DescribePriceForModifyDesktopOversoldGroupSaleRequest) SetOversoldUserCount(v int32) *DescribePriceForModifyDesktopOversoldGroupSaleRequest {
	s.OversoldUserCount = &v
	return s
}

type DescribePriceForModifyDesktopOversoldGroupSaleResponseBody struct {
	Data      *DescribePriceForModifyDesktopOversoldGroupSaleResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	RequestId *string                                                         `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribePriceForModifyDesktopOversoldGroupSaleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceForModifyDesktopOversoldGroupSaleResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePriceForModifyDesktopOversoldGroupSaleResponseBody) SetData(v *DescribePriceForModifyDesktopOversoldGroupSaleResponseBodyData) *DescribePriceForModifyDesktopOversoldGroupSaleResponseBody {
	s.Data = v
	return s
}

func (s *DescribePriceForModifyDesktopOversoldGroupSaleResponseBody) SetRequestId(v string) *DescribePriceForModifyDesktopOversoldGroupSaleResponseBody {
	s.RequestId = &v
	return s
}

type DescribePriceForModifyDesktopOversoldGroupSaleResponseBodyData struct {
	Price *string `json:"Price,omitempty" xml:"Price,omitempty"`
}

func (s DescribePriceForModifyDesktopOversoldGroupSaleResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceForModifyDesktopOversoldGroupSaleResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribePriceForModifyDesktopOversoldGroupSaleResponseBodyData) SetPrice(v string) *DescribePriceForModifyDesktopOversoldGroupSaleResponseBodyData {
	s.Price = &v
	return s
}

type DescribePriceForModifyDesktopOversoldGroupSaleResponse struct {
	Headers    map[string]*string                                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePriceForModifyDesktopOversoldGroupSaleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePriceForModifyDesktopOversoldGroupSaleResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceForModifyDesktopOversoldGroupSaleResponse) GoString() string {
	return s.String()
}

func (s *DescribePriceForModifyDesktopOversoldGroupSaleResponse) SetHeaders(v map[string]*string) *DescribePriceForModifyDesktopOversoldGroupSaleResponse {
	s.Headers = v
	return s
}

func (s *DescribePriceForModifyDesktopOversoldGroupSaleResponse) SetStatusCode(v int32) *DescribePriceForModifyDesktopOversoldGroupSaleResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePriceForModifyDesktopOversoldGroupSaleResponse) SetBody(v *DescribePriceForModifyDesktopOversoldGroupSaleResponseBody) *DescribePriceForModifyDesktopOversoldGroupSaleResponse {
	s.Body = v
	return s
}

type DescribePriceForRenewDesktopOversoldGroupRequest struct {
	OversoldGroupId *string `json:"OversoldGroupId,omitempty" xml:"OversoldGroupId,omitempty"`
	Period          *int32  `json:"Period,omitempty" xml:"Period,omitempty"`
	PeriodUnit      *string `json:"PeriodUnit,omitempty" xml:"PeriodUnit,omitempty"`
}

func (s DescribePriceForRenewDesktopOversoldGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceForRenewDesktopOversoldGroupRequest) GoString() string {
	return s.String()
}

func (s *DescribePriceForRenewDesktopOversoldGroupRequest) SetOversoldGroupId(v string) *DescribePriceForRenewDesktopOversoldGroupRequest {
	s.OversoldGroupId = &v
	return s
}

func (s *DescribePriceForRenewDesktopOversoldGroupRequest) SetPeriod(v int32) *DescribePriceForRenewDesktopOversoldGroupRequest {
	s.Period = &v
	return s
}

func (s *DescribePriceForRenewDesktopOversoldGroupRequest) SetPeriodUnit(v string) *DescribePriceForRenewDesktopOversoldGroupRequest {
	s.PeriodUnit = &v
	return s
}

type DescribePriceForRenewDesktopOversoldGroupResponseBody struct {
	Data      *DescribePriceForRenewDesktopOversoldGroupResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	RequestId *string                                                    `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribePriceForRenewDesktopOversoldGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceForRenewDesktopOversoldGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePriceForRenewDesktopOversoldGroupResponseBody) SetData(v *DescribePriceForRenewDesktopOversoldGroupResponseBodyData) *DescribePriceForRenewDesktopOversoldGroupResponseBody {
	s.Data = v
	return s
}

func (s *DescribePriceForRenewDesktopOversoldGroupResponseBody) SetRequestId(v string) *DescribePriceForRenewDesktopOversoldGroupResponseBody {
	s.RequestId = &v
	return s
}

type DescribePriceForRenewDesktopOversoldGroupResponseBodyData struct {
	Price *string `json:"Price,omitempty" xml:"Price,omitempty"`
}

func (s DescribePriceForRenewDesktopOversoldGroupResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceForRenewDesktopOversoldGroupResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribePriceForRenewDesktopOversoldGroupResponseBodyData) SetPrice(v string) *DescribePriceForRenewDesktopOversoldGroupResponseBodyData {
	s.Price = &v
	return s
}

type DescribePriceForRenewDesktopOversoldGroupResponse struct {
	Headers    map[string]*string                                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePriceForRenewDesktopOversoldGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePriceForRenewDesktopOversoldGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePriceForRenewDesktopOversoldGroupResponse) GoString() string {
	return s.String()
}

func (s *DescribePriceForRenewDesktopOversoldGroupResponse) SetHeaders(v map[string]*string) *DescribePriceForRenewDesktopOversoldGroupResponse {
	s.Headers = v
	return s
}

func (s *DescribePriceForRenewDesktopOversoldGroupResponse) SetStatusCode(v int32) *DescribePriceForRenewDesktopOversoldGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePriceForRenewDesktopOversoldGroupResponse) SetBody(v *DescribePriceForRenewDesktopOversoldGroupResponseBody) *DescribePriceForRenewDesktopOversoldGroupResponse {
	s.Body = v
	return s
}

type DescribeRegionsRequest struct {
	// The ID of the region.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	// The list of regions.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeRegionsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsRequest) GoString() string {
	return s.String()
}

func (s *DescribeRegionsRequest) SetAcceptLanguage(v string) *DescribeRegionsRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DescribeRegionsRequest) SetRegionId(v string) *DescribeRegionsRequest {
	s.RegionId = &v
	return s
}

type DescribeRegionsResponseBody struct {
	// DescribeRegions
	Regions []*DescribeRegionsResponseBodyRegions `json:"Regions,omitempty" xml:"Regions,omitempty" type:"Repeated"`
	// The operation that you want to perform. Set the value to DescribeRegions.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeRegionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBody) SetRegions(v []*DescribeRegionsResponseBodyRegions) *DescribeRegionsResponseBody {
	s.Regions = v
	return s
}

func (s *DescribeRegionsResponseBody) SetRequestId(v string) *DescribeRegionsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeRegionsResponseBodyRegions struct {
	LocalName      *string `json:"LocalName,omitempty" xml:"LocalName,omitempty"`
	RegionEndpoint *string `json:"RegionEndpoint,omitempty" xml:"RegionEndpoint,omitempty"`
	RegionId       *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeRegionsResponseBodyRegions) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponseBodyRegions) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBodyRegions) SetLocalName(v string) *DescribeRegionsResponseBodyRegions {
	s.LocalName = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegions) SetRegionEndpoint(v string) *DescribeRegionsResponseBodyRegions {
	s.RegionEndpoint = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegions) SetRegionId(v string) *DescribeRegionsResponseBodyRegions {
	s.RegionId = &v
	return s
}

type DescribeRegionsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRegionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRegionsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponse) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponse) SetHeaders(v map[string]*string) *DescribeRegionsResponse {
	s.Headers = v
	return s
}

func (s *DescribeRegionsResponse) SetStatusCode(v int32) *DescribeRegionsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRegionsResponse) SetBody(v *DescribeRegionsResponseBody) *DescribeRegionsResponse {
	s.Body = v
	return s
}

type DescribeSessionStatisticRequest struct {
	// The end of the time range to query.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The workspace ID.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The query interval. Unit: seconds. Valid values:
	//
	// *   60
	// *   120
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Specifies to search for session information by region ID. This parameter is used to filter desktop information of a specific region.
	SearchRegionId *string `json:"SearchRegionId,omitempty" xml:"SearchRegionId,omitempty"`
	// The beginning of the time range to query.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeSessionStatisticRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSessionStatisticRequest) GoString() string {
	return s.String()
}

func (s *DescribeSessionStatisticRequest) SetEndTime(v string) *DescribeSessionStatisticRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeSessionStatisticRequest) SetOfficeSiteId(v string) *DescribeSessionStatisticRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *DescribeSessionStatisticRequest) SetPeriod(v int32) *DescribeSessionStatisticRequest {
	s.Period = &v
	return s
}

func (s *DescribeSessionStatisticRequest) SetRegionId(v string) *DescribeSessionStatisticRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeSessionStatisticRequest) SetSearchRegionId(v string) *DescribeSessionStatisticRequest {
	s.SearchRegionId = &v
	return s
}

func (s *DescribeSessionStatisticRequest) SetStartTime(v string) *DescribeSessionStatisticRequest {
	s.StartTime = &v
	return s
}

type DescribeSessionStatisticResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The statistics.
	Statistic []*DescribeSessionStatisticResponseBodyStatistic `json:"Statistic,omitempty" xml:"Statistic,omitempty" type:"Repeated"`
	// The total number of sessions returned.
	TotalCount *string `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeSessionStatisticResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSessionStatisticResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSessionStatisticResponseBody) SetRequestId(v string) *DescribeSessionStatisticResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSessionStatisticResponseBody) SetStatistic(v []*DescribeSessionStatisticResponseBodyStatistic) *DescribeSessionStatisticResponseBody {
	s.Statistic = v
	return s
}

func (s *DescribeSessionStatisticResponseBody) SetTotalCount(v string) *DescribeSessionStatisticResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeSessionStatisticResponseBodyStatistic struct {
	// The total number of sessions in the time range.
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The point in time.
	TimePoint *int64 `json:"TimePoint,omitempty" xml:"TimePoint,omitempty"`
}

func (s DescribeSessionStatisticResponseBodyStatistic) String() string {
	return tea.Prettify(s)
}

func (s DescribeSessionStatisticResponseBodyStatistic) GoString() string {
	return s.String()
}

func (s *DescribeSessionStatisticResponseBodyStatistic) SetCount(v int64) *DescribeSessionStatisticResponseBodyStatistic {
	s.Count = &v
	return s
}

func (s *DescribeSessionStatisticResponseBodyStatistic) SetTimePoint(v int64) *DescribeSessionStatisticResponseBodyStatistic {
	s.TimePoint = &v
	return s
}

type DescribeSessionStatisticResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeSessionStatisticResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeSessionStatisticResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSessionStatisticResponse) GoString() string {
	return s.String()
}

func (s *DescribeSessionStatisticResponse) SetHeaders(v map[string]*string) *DescribeSessionStatisticResponse {
	s.Headers = v
	return s
}

func (s *DescribeSessionStatisticResponse) SetStatusCode(v int32) *DescribeSessionStatisticResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSessionStatisticResponse) SetBody(v *DescribeSessionStatisticResponseBody) *DescribeSessionStatisticResponse {
	s.Body = v
	return s
}

type DescribeSnapshotsRequest struct {
	// The user who creates the snapshot.
	Creator *string `json:"Creator,omitempty" xml:"Creator,omitempty"`
	// The cloud desktop ID.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The cloud desktop name.
	DesktopName *string `json:"DesktopName,omitempty" xml:"DesktopName,omitempty"`
	// The end of the time range to query. The query is performed based on the time when the system stopped creating a snapshot. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-mm-ddthh:mm:ssz format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The maximum number of entries to return on each page.
	//
	// *   Valid values: 1 to 100
	// *   Default value: 10
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. You must specify the token that is obtained from the previous query as the value of NextToken.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The snapshot ID.
	SnapshotId *string `json:"SnapshotId,omitempty" xml:"SnapshotId,omitempty"`
	// The snapshot name. The name must be 2 to 128 characters in length and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
	//
	// The name cannot start with `auto` because snapshots whose names start with auto are recognized as automatic snapshots.
	SnapshotName *string `json:"SnapshotName,omitempty" xml:"SnapshotName,omitempty"`
	// The snapshot type.
	//
	// Valid values:
	//
	// *   auto: automatic snapshot
	// *   user: manual snapshot
	// *   all (default): all types of snapshots
	SnapshotType *string `json:"SnapshotType,omitempty" xml:"SnapshotType,omitempty"`
	// The type of the source disk of which you want to query snapshots. Valid values:
	//
	// *   System: system disk
	// *   Data: data disk
	//
	// > The value of this parameter is not case-sensitive.
	SourceDiskType *string `json:"SourceDiskType,omitempty" xml:"SourceDiskType,omitempty"`
	// The beginning of the time range to query. The query is performed based on the time when the system created a snapshot. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-mm-ddthh:mm:ssz format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeSnapshotsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSnapshotsRequest) GoString() string {
	return s.String()
}

func (s *DescribeSnapshotsRequest) SetCreator(v string) *DescribeSnapshotsRequest {
	s.Creator = &v
	return s
}

func (s *DescribeSnapshotsRequest) SetDesktopId(v string) *DescribeSnapshotsRequest {
	s.DesktopId = &v
	return s
}

func (s *DescribeSnapshotsRequest) SetDesktopName(v string) *DescribeSnapshotsRequest {
	s.DesktopName = &v
	return s
}

func (s *DescribeSnapshotsRequest) SetEndTime(v string) *DescribeSnapshotsRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeSnapshotsRequest) SetMaxResults(v int32) *DescribeSnapshotsRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeSnapshotsRequest) SetNextToken(v string) *DescribeSnapshotsRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeSnapshotsRequest) SetRegionId(v string) *DescribeSnapshotsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeSnapshotsRequest) SetSnapshotId(v string) *DescribeSnapshotsRequest {
	s.SnapshotId = &v
	return s
}

func (s *DescribeSnapshotsRequest) SetSnapshotName(v string) *DescribeSnapshotsRequest {
	s.SnapshotName = &v
	return s
}

func (s *DescribeSnapshotsRequest) SetSnapshotType(v string) *DescribeSnapshotsRequest {
	s.SnapshotType = &v
	return s
}

func (s *DescribeSnapshotsRequest) SetSourceDiskType(v string) *DescribeSnapshotsRequest {
	s.SourceDiskType = &v
	return s
}

func (s *DescribeSnapshotsRequest) SetStartTime(v string) *DescribeSnapshotsRequest {
	s.StartTime = &v
	return s
}

type DescribeSnapshotsResponseBody struct {
	// If the NextToken parameter is empty, no next page exists.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The queried snapshots.
	Snapshots []*DescribeSnapshotsResponseBodySnapshots `json:"Snapshots,omitempty" xml:"Snapshots,omitempty" type:"Repeated"`
}

func (s DescribeSnapshotsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSnapshotsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSnapshotsResponseBody) SetNextToken(v string) *DescribeSnapshotsResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeSnapshotsResponseBody) SetRequestId(v string) *DescribeSnapshotsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSnapshotsResponseBody) SetSnapshots(v []*DescribeSnapshotsResponseBodySnapshots) *DescribeSnapshotsResponseBody {
	s.Snapshots = v
	return s
}

type DescribeSnapshotsResponseBodySnapshots struct {
	// The time when the snapshot was created. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The user that creates the cloud desktop.
	Creator *string `json:"Creator,omitempty" xml:"Creator,omitempty"`
	// The time when the snapshot was deleted. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-mm-ddthh:mm:ssz format. The time is displayed in UTC.
	DeletionTime *string `json:"DeletionTime,omitempty" xml:"DeletionTime,omitempty"`
	// The snapshot description.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the cloud desktop to which the snapshot belongs.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The cloud desktop name.
	DesktopName *string `json:"DesktopName,omitempty" xml:"DesktopName,omitempty"`
	// The cloud desktop state. Valid values:
	//
	// *   Pending: The cloud desktop is pending.
	// *   Starting: The cloud desktop is being started.
	// *   Running: The cloud desktop is running.
	// *   Stopping: The cloud desktop is being stopped.
	// *   Rebuilding: The cloud desktop is being recreated.
	// *   Stopped: The cloud desktop is stopped.
	// *   Expired: The cloud desktop expired.
	// *   Deleted: The cloud desktop is deleted.
	DesktopStatus *string `json:"DesktopStatus,omitempty" xml:"DesktopStatus,omitempty"`
	// The progress of creating the snapshot. Unit: percentage (%).
	Progress *string `json:"Progress,omitempty" xml:"Progress,omitempty"`
	// The protocol. Valid values:
	//
	// *   ASP
	// *   HDX
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The remaining time required to create the snapshot. Unit: seconds.
	//
	// > If the value of the `Status` parameter is `PROGRESSING` and the value of the `RemainTime` parameter is `-1`, the system is calculating the remaining time required to create the snapshot.
	RemainTime *int32 `json:"RemainTime,omitempty" xml:"RemainTime,omitempty"`
	// The snapshot ID.
	SnapshotId *string `json:"SnapshotId,omitempty" xml:"SnapshotId,omitempty"`
	// The snapshot name.
	SnapshotName *string `json:"SnapshotName,omitempty" xml:"SnapshotName,omitempty"`
	// The snapshot type. Valid values:
	//
	// *   AUTO: automatic snapshot
	// *   USER: manual snapshot
	SnapshotType *string `json:"SnapshotType,omitempty" xml:"SnapshotType,omitempty"`
	// The size of the source disk. Unit: GiB.
	SourceDiskSize *string `json:"SourceDiskSize,omitempty" xml:"SourceDiskSize,omitempty"`
	// The type of the source disk. Valid values:
	//
	// *   SYSTEM: system disk
	// *   DATA: data disk
	SourceDiskType *string `json:"SourceDiskType,omitempty" xml:"SourceDiskType,omitempty"`
	// The state of the snapshot. Valid values:
	//
	// *   PROGRESSING: The snapshot is being created.
	// *   FAILED: The snapshot failed to be created.
	// *   ACCOMPLISHED: The snapshot is created.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// Indicates whether disk encryption is enabled.
	VolumeEncryptionEnabled *bool `json:"VolumeEncryptionEnabled,omitempty" xml:"VolumeEncryptionEnabled,omitempty"`
	// The ID of the Key Management Service (KMS) key that is used when disk encryption is enabled. You can call the [ListKeys](~~28951~~) operation to obtain a list of KMS keys.
	VolumeEncryptionKey *string `json:"VolumeEncryptionKey,omitempty" xml:"VolumeEncryptionKey,omitempty"`
}

func (s DescribeSnapshotsResponseBodySnapshots) String() string {
	return tea.Prettify(s)
}

func (s DescribeSnapshotsResponseBodySnapshots) GoString() string {
	return s.String()
}

func (s *DescribeSnapshotsResponseBodySnapshots) SetCreationTime(v string) *DescribeSnapshotsResponseBodySnapshots {
	s.CreationTime = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshots) SetCreator(v string) *DescribeSnapshotsResponseBodySnapshots {
	s.Creator = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshots) SetDeletionTime(v string) *DescribeSnapshotsResponseBodySnapshots {
	s.DeletionTime = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshots) SetDescription(v string) *DescribeSnapshotsResponseBodySnapshots {
	s.Description = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshots) SetDesktopId(v string) *DescribeSnapshotsResponseBodySnapshots {
	s.DesktopId = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshots) SetDesktopName(v string) *DescribeSnapshotsResponseBodySnapshots {
	s.DesktopName = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshots) SetDesktopStatus(v string) *DescribeSnapshotsResponseBodySnapshots {
	s.DesktopStatus = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshots) SetProgress(v string) *DescribeSnapshotsResponseBodySnapshots {
	s.Progress = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshots) SetProtocolType(v string) *DescribeSnapshotsResponseBodySnapshots {
	s.ProtocolType = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshots) SetRemainTime(v int32) *DescribeSnapshotsResponseBodySnapshots {
	s.RemainTime = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshots) SetSnapshotId(v string) *DescribeSnapshotsResponseBodySnapshots {
	s.SnapshotId = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshots) SetSnapshotName(v string) *DescribeSnapshotsResponseBodySnapshots {
	s.SnapshotName = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshots) SetSnapshotType(v string) *DescribeSnapshotsResponseBodySnapshots {
	s.SnapshotType = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshots) SetSourceDiskSize(v string) *DescribeSnapshotsResponseBodySnapshots {
	s.SourceDiskSize = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshots) SetSourceDiskType(v string) *DescribeSnapshotsResponseBodySnapshots {
	s.SourceDiskType = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshots) SetStatus(v string) *DescribeSnapshotsResponseBodySnapshots {
	s.Status = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshots) SetVolumeEncryptionEnabled(v bool) *DescribeSnapshotsResponseBodySnapshots {
	s.VolumeEncryptionEnabled = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshots) SetVolumeEncryptionKey(v string) *DescribeSnapshotsResponseBodySnapshots {
	s.VolumeEncryptionKey = &v
	return s
}

type DescribeSnapshotsResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeSnapshotsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeSnapshotsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSnapshotsResponse) GoString() string {
	return s.String()
}

func (s *DescribeSnapshotsResponse) SetHeaders(v map[string]*string) *DescribeSnapshotsResponse {
	s.Headers = v
	return s
}

func (s *DescribeSnapshotsResponse) SetStatusCode(v int32) *DescribeSnapshotsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSnapshotsResponse) SetBody(v *DescribeSnapshotsResponseBody) *DescribeSnapshotsResponse {
	s.Body = v
	return s
}

type DescribeUserConnectTimeRequest struct {
	EndTime         *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	EndUserId       *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	MaxResults      *int32  `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	NextToken       *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OversoldGroupId *string `json:"OversoldGroupId,omitempty" xml:"OversoldGroupId,omitempty"`
	StartTime       *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	UserDesktopId   *string `json:"UserDesktopId,omitempty" xml:"UserDesktopId,omitempty"`
	UserGroupId     *string `json:"UserGroupId,omitempty" xml:"UserGroupId,omitempty"`
}

func (s DescribeUserConnectTimeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserConnectTimeRequest) GoString() string {
	return s.String()
}

func (s *DescribeUserConnectTimeRequest) SetEndTime(v string) *DescribeUserConnectTimeRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeUserConnectTimeRequest) SetEndUserId(v string) *DescribeUserConnectTimeRequest {
	s.EndUserId = &v
	return s
}

func (s *DescribeUserConnectTimeRequest) SetMaxResults(v int32) *DescribeUserConnectTimeRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeUserConnectTimeRequest) SetNextToken(v string) *DescribeUserConnectTimeRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeUserConnectTimeRequest) SetOversoldGroupId(v string) *DescribeUserConnectTimeRequest {
	s.OversoldGroupId = &v
	return s
}

func (s *DescribeUserConnectTimeRequest) SetStartTime(v string) *DescribeUserConnectTimeRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeUserConnectTimeRequest) SetUserDesktopId(v string) *DescribeUserConnectTimeRequest {
	s.UserDesktopId = &v
	return s
}

func (s *DescribeUserConnectTimeRequest) SetUserGroupId(v string) *DescribeUserConnectTimeRequest {
	s.UserGroupId = &v
	return s
}

type DescribeUserConnectTimeResponseBody struct {
	Count     *int32                                     `json:"Count,omitempty" xml:"Count,omitempty"`
	Data      []*DescribeUserConnectTimeResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	NextToken *string                                    `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	RequestId *string                                    `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeUserConnectTimeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserConnectTimeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeUserConnectTimeResponseBody) SetCount(v int32) *DescribeUserConnectTimeResponseBody {
	s.Count = &v
	return s
}

func (s *DescribeUserConnectTimeResponseBody) SetData(v []*DescribeUserConnectTimeResponseBodyData) *DescribeUserConnectTimeResponseBody {
	s.Data = v
	return s
}

func (s *DescribeUserConnectTimeResponseBody) SetNextToken(v string) *DescribeUserConnectTimeResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeUserConnectTimeResponseBody) SetRequestId(v string) *DescribeUserConnectTimeResponseBody {
	s.RequestId = &v
	return s
}

type DescribeUserConnectTimeResponseBodyData struct {
	EndConnectTime   *string `json:"EndConnectTime,omitempty" xml:"EndConnectTime,omitempty"`
	EndUserId        *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	OversoldGroupId  *string `json:"OversoldGroupId,omitempty" xml:"OversoldGroupId,omitempty"`
	StartConnectTime *string `json:"StartConnectTime,omitempty" xml:"StartConnectTime,omitempty"`
	UserDesktopId    *string `json:"UserDesktopId,omitempty" xml:"UserDesktopId,omitempty"`
	UserGroupId      *string `json:"UserGroupId,omitempty" xml:"UserGroupId,omitempty"`
}

func (s DescribeUserConnectTimeResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserConnectTimeResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeUserConnectTimeResponseBodyData) SetEndConnectTime(v string) *DescribeUserConnectTimeResponseBodyData {
	s.EndConnectTime = &v
	return s
}

func (s *DescribeUserConnectTimeResponseBodyData) SetEndUserId(v string) *DescribeUserConnectTimeResponseBodyData {
	s.EndUserId = &v
	return s
}

func (s *DescribeUserConnectTimeResponseBodyData) SetOversoldGroupId(v string) *DescribeUserConnectTimeResponseBodyData {
	s.OversoldGroupId = &v
	return s
}

func (s *DescribeUserConnectTimeResponseBodyData) SetStartConnectTime(v string) *DescribeUserConnectTimeResponseBodyData {
	s.StartConnectTime = &v
	return s
}

func (s *DescribeUserConnectTimeResponseBodyData) SetUserDesktopId(v string) *DescribeUserConnectTimeResponseBodyData {
	s.UserDesktopId = &v
	return s
}

func (s *DescribeUserConnectTimeResponseBodyData) SetUserGroupId(v string) *DescribeUserConnectTimeResponseBodyData {
	s.UserGroupId = &v
	return s
}

type DescribeUserConnectTimeResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeUserConnectTimeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeUserConnectTimeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserConnectTimeResponse) GoString() string {
	return s.String()
}

func (s *DescribeUserConnectTimeResponse) SetHeaders(v map[string]*string) *DescribeUserConnectTimeResponse {
	s.Headers = v
	return s
}

func (s *DescribeUserConnectTimeResponse) SetStatusCode(v int32) *DescribeUserConnectTimeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeUserConnectTimeResponse) SetBody(v *DescribeUserConnectTimeResponseBody) *DescribeUserConnectTimeResponse {
	s.Body = v
	return s
}

type DescribeUserConnectionRecordsRequest struct {
	// The duration when the cloud desktop is connected, which is the minimum value for condition filtering.
	ConnectDurationFrom *int64 `json:"ConnectDurationFrom,omitempty" xml:"ConnectDurationFrom,omitempty"`
	// The duration when the cloud desktop is connected, which is the maximum value for condition filtering.
	ConnectDurationTo *int64 `json:"ConnectDurationTo,omitempty" xml:"ConnectDurationTo,omitempty"`
	// The time when the cloud desktop stops to be connected, which is the minimum value for condition filtering. The value is a UNIX timestamp. Unit: milliseconds.
	ConnectEndTimeFrom *int64 `json:"ConnectEndTimeFrom,omitempty" xml:"ConnectEndTimeFrom,omitempty"`
	// The time when the cloud desktop stops to be connected, which is the maximum value for condition filtering. The value is a UNIX timestamp. Unit: milliseconds.
	ConnectEndTimeTo *int64 `json:"ConnectEndTimeTo,omitempty" xml:"ConnectEndTimeTo,omitempty"`
	// The time when the cloud desktop starts to be connected, which is the minimum value for condition filtering. The value is a UNIX timestamp. Unit: milliseconds.
	ConnectStartTimeFrom *int64 `json:"ConnectStartTimeFrom,omitempty" xml:"ConnectStartTimeFrom,omitempty"`
	// The time when the cloud desktop starts to be connected, which is the maximum value for condition filtering. The value is a UNIX timestamp. Unit: milliseconds.
	ConnectStartTimeTo *int64 `json:"ConnectStartTimeTo,omitempty" xml:"ConnectStartTimeTo,omitempty"`
	// The ID of the desktop group.
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// The ID of the cloud desktop.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The user that you want to authorize to use the desktop group.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The account type of the user. Valid values:
	//
	// *   SIMPLE: the convenience account type
	// *   AD_CONNECTOR: the enterprise Active Directory (AD) account type
	EndUserType *string `json:"EndUserType,omitempty" xml:"EndUserType,omitempty"`
	// The number of entries to return on each page. Maximum value: 100. Default value: 10.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the next query. If this parameter is empty, all results are returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeUserConnectionRecordsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserConnectionRecordsRequest) GoString() string {
	return s.String()
}

func (s *DescribeUserConnectionRecordsRequest) SetConnectDurationFrom(v int64) *DescribeUserConnectionRecordsRequest {
	s.ConnectDurationFrom = &v
	return s
}

func (s *DescribeUserConnectionRecordsRequest) SetConnectDurationTo(v int64) *DescribeUserConnectionRecordsRequest {
	s.ConnectDurationTo = &v
	return s
}

func (s *DescribeUserConnectionRecordsRequest) SetConnectEndTimeFrom(v int64) *DescribeUserConnectionRecordsRequest {
	s.ConnectEndTimeFrom = &v
	return s
}

func (s *DescribeUserConnectionRecordsRequest) SetConnectEndTimeTo(v int64) *DescribeUserConnectionRecordsRequest {
	s.ConnectEndTimeTo = &v
	return s
}

func (s *DescribeUserConnectionRecordsRequest) SetConnectStartTimeFrom(v int64) *DescribeUserConnectionRecordsRequest {
	s.ConnectStartTimeFrom = &v
	return s
}

func (s *DescribeUserConnectionRecordsRequest) SetConnectStartTimeTo(v int64) *DescribeUserConnectionRecordsRequest {
	s.ConnectStartTimeTo = &v
	return s
}

func (s *DescribeUserConnectionRecordsRequest) SetDesktopGroupId(v string) *DescribeUserConnectionRecordsRequest {
	s.DesktopGroupId = &v
	return s
}

func (s *DescribeUserConnectionRecordsRequest) SetDesktopId(v string) *DescribeUserConnectionRecordsRequest {
	s.DesktopId = &v
	return s
}

func (s *DescribeUserConnectionRecordsRequest) SetEndUserId(v string) *DescribeUserConnectionRecordsRequest {
	s.EndUserId = &v
	return s
}

func (s *DescribeUserConnectionRecordsRequest) SetEndUserType(v string) *DescribeUserConnectionRecordsRequest {
	s.EndUserType = &v
	return s
}

func (s *DescribeUserConnectionRecordsRequest) SetMaxResults(v int32) *DescribeUserConnectionRecordsRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeUserConnectionRecordsRequest) SetNextToken(v string) *DescribeUserConnectionRecordsRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeUserConnectionRecordsRequest) SetRegionId(v string) *DescribeUserConnectionRecordsRequest {
	s.RegionId = &v
	return s
}

type DescribeUserConnectionRecordsResponseBody struct {
	// Details about connection records.
	ConnectionRecords []*DescribeUserConnectionRecordsResponseBodyConnectionRecords `json:"ConnectionRecords,omitempty" xml:"ConnectionRecords,omitempty" type:"Repeated"`
	// The token that is used to start the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeUserConnectionRecordsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserConnectionRecordsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeUserConnectionRecordsResponseBody) SetConnectionRecords(v []*DescribeUserConnectionRecordsResponseBodyConnectionRecords) *DescribeUserConnectionRecordsResponseBody {
	s.ConnectionRecords = v
	return s
}

func (s *DescribeUserConnectionRecordsResponseBody) SetNextToken(v string) *DescribeUserConnectionRecordsResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeUserConnectionRecordsResponseBody) SetRequestId(v string) *DescribeUserConnectionRecordsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeUserConnectionRecordsResponseBodyConnectionRecords struct {
	// The duration of the desktop connection. Unit: seconds.
	ConnectDuration *string `json:"ConnectDuration,omitempty" xml:"ConnectDuration,omitempty"`
	// The time when the cloud desktop was disconnected.
	ConnectEndTime *string `json:"ConnectEndTime,omitempty" xml:"ConnectEndTime,omitempty"`
	// The time when the cloud desktop was connected.
	ConnectStartTime *string `json:"ConnectStartTime,omitempty" xml:"ConnectStartTime,omitempty"`
	// The ID of the connection record.
	ConnectionRecordId *string `json:"ConnectionRecordId,omitempty" xml:"ConnectionRecordId,omitempty"`
	// The ID of the cloud desktop that is connected.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The name of the cloud desktop that is connected.
	DesktopName *string `json:"DesktopName,omitempty" xml:"DesktopName,omitempty"`
}

func (s DescribeUserConnectionRecordsResponseBodyConnectionRecords) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserConnectionRecordsResponseBodyConnectionRecords) GoString() string {
	return s.String()
}

func (s *DescribeUserConnectionRecordsResponseBodyConnectionRecords) SetConnectDuration(v string) *DescribeUserConnectionRecordsResponseBodyConnectionRecords {
	s.ConnectDuration = &v
	return s
}

func (s *DescribeUserConnectionRecordsResponseBodyConnectionRecords) SetConnectEndTime(v string) *DescribeUserConnectionRecordsResponseBodyConnectionRecords {
	s.ConnectEndTime = &v
	return s
}

func (s *DescribeUserConnectionRecordsResponseBodyConnectionRecords) SetConnectStartTime(v string) *DescribeUserConnectionRecordsResponseBodyConnectionRecords {
	s.ConnectStartTime = &v
	return s
}

func (s *DescribeUserConnectionRecordsResponseBodyConnectionRecords) SetConnectionRecordId(v string) *DescribeUserConnectionRecordsResponseBodyConnectionRecords {
	s.ConnectionRecordId = &v
	return s
}

func (s *DescribeUserConnectionRecordsResponseBodyConnectionRecords) SetDesktopId(v string) *DescribeUserConnectionRecordsResponseBodyConnectionRecords {
	s.DesktopId = &v
	return s
}

func (s *DescribeUserConnectionRecordsResponseBodyConnectionRecords) SetDesktopName(v string) *DescribeUserConnectionRecordsResponseBodyConnectionRecords {
	s.DesktopName = &v
	return s
}

type DescribeUserConnectionRecordsResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeUserConnectionRecordsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeUserConnectionRecordsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserConnectionRecordsResponse) GoString() string {
	return s.String()
}

func (s *DescribeUserConnectionRecordsResponse) SetHeaders(v map[string]*string) *DescribeUserConnectionRecordsResponse {
	s.Headers = v
	return s
}

func (s *DescribeUserConnectionRecordsResponse) SetStatusCode(v int32) *DescribeUserConnectionRecordsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeUserConnectionRecordsResponse) SetBody(v *DescribeUserConnectionRecordsResponseBody) *DescribeUserConnectionRecordsResponse {
	s.Body = v
	return s
}

type DescribeUserProfilePathRulesRequest struct {
	// The desktop group ID. This parameter is required when you set RuleType parameter to DesktopGroup.
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The rule type that you want to configure for the directory.
	//
	// Valid values:
	//
	// *   DesktopGroup
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Default
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	RuleType *string `json:"RuleType,omitempty" xml:"RuleType,omitempty"`
}

func (s DescribeUserProfilePathRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserProfilePathRulesRequest) GoString() string {
	return s.String()
}

func (s *DescribeUserProfilePathRulesRequest) SetDesktopGroupId(v string) *DescribeUserProfilePathRulesRequest {
	s.DesktopGroupId = &v
	return s
}

func (s *DescribeUserProfilePathRulesRequest) SetRegionId(v string) *DescribeUserProfilePathRulesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeUserProfilePathRulesRequest) SetRuleType(v string) *DescribeUserProfilePathRulesRequest {
	s.RuleType = &v
	return s
}

type DescribeUserProfilePathRulesResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The directory blacklist and whitelist.
	UserProfilePathRule *DescribeUserProfilePathRulesResponseBodyUserProfilePathRule `json:"UserProfilePathRule,omitempty" xml:"UserProfilePathRule,omitempty" type:"Struct"`
}

func (s DescribeUserProfilePathRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserProfilePathRulesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeUserProfilePathRulesResponseBody) SetRequestId(v string) *DescribeUserProfilePathRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeUserProfilePathRulesResponseBody) SetUserProfilePathRule(v *DescribeUserProfilePathRulesResponseBodyUserProfilePathRule) *DescribeUserProfilePathRulesResponseBody {
	s.UserProfilePathRule = v
	return s
}

type DescribeUserProfilePathRulesResponseBodyUserProfilePathRule struct {
	// The desktop group ID.
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// The directory rules.
	Rules []*DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRules `json:"Rules,omitempty" xml:"Rules,omitempty" type:"Repeated"`
	// The directory type that is configured for the directory.
	//
	// Valid values:
	//
	// *   DesktopGroup
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Default
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	UserProfileRuleType *string `json:"UserProfileRuleType,omitempty" xml:"UserProfileRuleType,omitempty"`
}

func (s DescribeUserProfilePathRulesResponseBodyUserProfilePathRule) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserProfilePathRulesResponseBodyUserProfilePathRule) GoString() string {
	return s.String()
}

func (s *DescribeUserProfilePathRulesResponseBodyUserProfilePathRule) SetDesktopGroupId(v string) *DescribeUserProfilePathRulesResponseBodyUserProfilePathRule {
	s.DesktopGroupId = &v
	return s
}

func (s *DescribeUserProfilePathRulesResponseBodyUserProfilePathRule) SetRules(v []*DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRules) *DescribeUserProfilePathRulesResponseBodyUserProfilePathRule {
	s.Rules = v
	return s
}

func (s *DescribeUserProfilePathRulesResponseBodyUserProfilePathRule) SetUserProfileRuleType(v string) *DescribeUserProfilePathRulesResponseBodyUserProfilePathRule {
	s.UserProfileRuleType = &v
	return s
}

type DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRules struct {
	// The blacklist that is configured.
	BlackPath *DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesBlackPath `json:"BlackPath,omitempty" xml:"BlackPath,omitempty" type:"Struct"`
	// The directories in the whitelist.
	WhitePaths []*DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesWhitePaths `json:"WhitePaths,omitempty" xml:"WhitePaths,omitempty" type:"Repeated"`
}

func (s DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRules) GoString() string {
	return s.String()
}

func (s *DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRules) SetBlackPath(v *DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesBlackPath) *DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRules {
	s.BlackPath = v
	return s
}

func (s *DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRules) SetWhitePaths(v []*DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesWhitePaths) *DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRules {
	s.WhitePaths = v
	return s
}

type DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesBlackPath struct {
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The path type.
	//
	// Valid values:
	//
	// *   file
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   folder
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesBlackPath) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesBlackPath) GoString() string {
	return s.String()
}

func (s *DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesBlackPath) SetPath(v string) *DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesBlackPath {
	s.Path = &v
	return s
}

func (s *DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesBlackPath) SetType(v string) *DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesBlackPath {
	s.Type = &v
	return s
}

type DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesWhitePaths struct {
	// The path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The path type.
	//
	// Valid values:
	//
	// *   file
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   folder
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesWhitePaths) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesWhitePaths) GoString() string {
	return s.String()
}

func (s *DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesWhitePaths) SetPath(v string) *DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesWhitePaths {
	s.Path = &v
	return s
}

func (s *DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesWhitePaths) SetType(v string) *DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesWhitePaths {
	s.Type = &v
	return s
}

type DescribeUserProfilePathRulesResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeUserProfilePathRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeUserProfilePathRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeUserProfilePathRulesResponse) GoString() string {
	return s.String()
}

func (s *DescribeUserProfilePathRulesResponse) SetHeaders(v map[string]*string) *DescribeUserProfilePathRulesResponse {
	s.Headers = v
	return s
}

func (s *DescribeUserProfilePathRulesResponse) SetStatusCode(v int32) *DescribeUserProfilePathRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeUserProfilePathRulesResponse) SetBody(v *DescribeUserProfilePathRulesResponseBody) *DescribeUserProfilePathRulesResponse {
	s.Body = v
	return s
}

type DescribeUsersInGroupRequest struct {
	// The status of the desktop connection for the end user.
	ConnectState *int32 `json:"ConnectState,omitempty" xml:"ConnectState,omitempty"`
	// The ID of the desktop group.
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// The ID of the authorized user.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The IDs of the end users.
	EndUserIds []*string `json:"EndUserIds,omitempty" xml:"EndUserIds,omitempty" type:"Repeated"`
	// The query string for fuzzy match. If you specify this parameter, the system returns all results that contain the string.
	Filter *string `json:"Filter,omitempty" xml:"Filter,omitempty"`
	// The number of entries to return on each page.
	//
	// *   Maximum value: 100.
	// *   Default value: 10.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the next query. If this parameter is left empty, all results are returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the organization to which the end user belongs.
	OrgId *string `json:"OrgId,omitempty" xml:"OrgId,omitempty"`
	// Specifies whether to query the details about the end user.
	QueryUserDetail *bool `json:"QueryUserDetail,omitempty" xml:"QueryUserDetail,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeUsersInGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeUsersInGroupRequest) GoString() string {
	return s.String()
}

func (s *DescribeUsersInGroupRequest) SetConnectState(v int32) *DescribeUsersInGroupRequest {
	s.ConnectState = &v
	return s
}

func (s *DescribeUsersInGroupRequest) SetDesktopGroupId(v string) *DescribeUsersInGroupRequest {
	s.DesktopGroupId = &v
	return s
}

func (s *DescribeUsersInGroupRequest) SetEndUserId(v string) *DescribeUsersInGroupRequest {
	s.EndUserId = &v
	return s
}

func (s *DescribeUsersInGroupRequest) SetEndUserIds(v []*string) *DescribeUsersInGroupRequest {
	s.EndUserIds = v
	return s
}

func (s *DescribeUsersInGroupRequest) SetFilter(v string) *DescribeUsersInGroupRequest {
	s.Filter = &v
	return s
}

func (s *DescribeUsersInGroupRequest) SetMaxResults(v int32) *DescribeUsersInGroupRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeUsersInGroupRequest) SetNextToken(v string) *DescribeUsersInGroupRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeUsersInGroupRequest) SetOrgId(v string) *DescribeUsersInGroupRequest {
	s.OrgId = &v
	return s
}

func (s *DescribeUsersInGroupRequest) SetQueryUserDetail(v bool) *DescribeUsersInGroupRequest {
	s.QueryUserDetail = &v
	return s
}

func (s *DescribeUsersInGroupRequest) SetRegionId(v string) *DescribeUsersInGroupRequest {
	s.RegionId = &v
	return s
}

type DescribeUsersInGroupResponseBody struct {
	// Details about the end users.
	EndUsers []*DescribeUsersInGroupResponseBodyEndUsers `json:"EndUsers,omitempty" xml:"EndUsers,omitempty" type:"Repeated"`
	// The token that is used to start the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The number of authorized users that are connecting to cloud desktops.
	OnlineUsersCount *int32 `json:"OnlineUsersCount,omitempty" xml:"OnlineUsersCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of authorized users of the desktop group.
	UsersCount *int32 `json:"UsersCount,omitempty" xml:"UsersCount,omitempty"`
}

func (s DescribeUsersInGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeUsersInGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeUsersInGroupResponseBody) SetEndUsers(v []*DescribeUsersInGroupResponseBodyEndUsers) *DescribeUsersInGroupResponseBody {
	s.EndUsers = v
	return s
}

func (s *DescribeUsersInGroupResponseBody) SetNextToken(v string) *DescribeUsersInGroupResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeUsersInGroupResponseBody) SetOnlineUsersCount(v int32) *DescribeUsersInGroupResponseBody {
	s.OnlineUsersCount = &v
	return s
}

func (s *DescribeUsersInGroupResponseBody) SetRequestId(v string) *DescribeUsersInGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeUsersInGroupResponseBody) SetUsersCount(v int32) *DescribeUsersInGroupResponseBody {
	s.UsersCount = &v
	return s
}

type DescribeUsersInGroupResponseBodyEndUsers struct {
	// The status of the desktop connection for the end user.
	ConnectionStatus *string `json:"ConnectionStatus,omitempty" xml:"ConnectionStatus,omitempty"`
	// The ID of the cloud desktop.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The name of the cloud desktop.
	DesktopName *string `json:"DesktopName,omitempty" xml:"DesktopName,omitempty"`
	// The display name of the enterprise AD account.
	DisplayName *string `json:"DisplayName,omitempty" xml:"DisplayName,omitempty"`
	// The email address of the end user.
	EndUserEmail *string `json:"EndUserEmail,omitempty" xml:"EndUserEmail,omitempty"`
	// The name of the end user.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The name of the end user.
	EndUserName *string `json:"EndUserName,omitempty" xml:"EndUserName,omitempty"`
	// The mobile number of the end user.
	EndUserPhone *string `json:"EndUserPhone,omitempty" xml:"EndUserPhone,omitempty"`
	// The remarks of the end user.
	EndUserRemark *string `json:"EndUserRemark,omitempty" xml:"EndUserRemark,omitempty"`
	// The account type of the end user.
	EndUserType *string `json:"EndUserType,omitempty" xml:"EndUserType,omitempty"`
	// The appended information.
	ExternalInfo *DescribeUsersInGroupResponseBodyEndUsersExternalInfo `json:"ExternalInfo,omitempty" xml:"ExternalInfo,omitempty" type:"Struct"`
	// The ID of the desktop of the end user.
	UserDesktopId *string `json:"UserDesktopId,omitempty" xml:"UserDesktopId,omitempty"`
	// Details about the seats of end users.
	UserSetPropertiesModels []*DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels `json:"UserSetPropertiesModels,omitempty" xml:"UserSetPropertiesModels,omitempty" type:"Repeated"`
}

func (s DescribeUsersInGroupResponseBodyEndUsers) String() string {
	return tea.Prettify(s)
}

func (s DescribeUsersInGroupResponseBodyEndUsers) GoString() string {
	return s.String()
}

func (s *DescribeUsersInGroupResponseBodyEndUsers) SetConnectionStatus(v string) *DescribeUsersInGroupResponseBodyEndUsers {
	s.ConnectionStatus = &v
	return s
}

func (s *DescribeUsersInGroupResponseBodyEndUsers) SetDesktopId(v string) *DescribeUsersInGroupResponseBodyEndUsers {
	s.DesktopId = &v
	return s
}

func (s *DescribeUsersInGroupResponseBodyEndUsers) SetDesktopName(v string) *DescribeUsersInGroupResponseBodyEndUsers {
	s.DesktopName = &v
	return s
}

func (s *DescribeUsersInGroupResponseBodyEndUsers) SetDisplayName(v string) *DescribeUsersInGroupResponseBodyEndUsers {
	s.DisplayName = &v
	return s
}

func (s *DescribeUsersInGroupResponseBodyEndUsers) SetEndUserEmail(v string) *DescribeUsersInGroupResponseBodyEndUsers {
	s.EndUserEmail = &v
	return s
}

func (s *DescribeUsersInGroupResponseBodyEndUsers) SetEndUserId(v string) *DescribeUsersInGroupResponseBodyEndUsers {
	s.EndUserId = &v
	return s
}

func (s *DescribeUsersInGroupResponseBodyEndUsers) SetEndUserName(v string) *DescribeUsersInGroupResponseBodyEndUsers {
	s.EndUserName = &v
	return s
}

func (s *DescribeUsersInGroupResponseBodyEndUsers) SetEndUserPhone(v string) *DescribeUsersInGroupResponseBodyEndUsers {
	s.EndUserPhone = &v
	return s
}

func (s *DescribeUsersInGroupResponseBodyEndUsers) SetEndUserRemark(v string) *DescribeUsersInGroupResponseBodyEndUsers {
	s.EndUserRemark = &v
	return s
}

func (s *DescribeUsersInGroupResponseBodyEndUsers) SetEndUserType(v string) *DescribeUsersInGroupResponseBodyEndUsers {
	s.EndUserType = &v
	return s
}

func (s *DescribeUsersInGroupResponseBodyEndUsers) SetExternalInfo(v *DescribeUsersInGroupResponseBodyEndUsersExternalInfo) *DescribeUsersInGroupResponseBodyEndUsers {
	s.ExternalInfo = v
	return s
}

func (s *DescribeUsersInGroupResponseBodyEndUsers) SetUserDesktopId(v string) *DescribeUsersInGroupResponseBodyEndUsers {
	s.UserDesktopId = &v
	return s
}

func (s *DescribeUsersInGroupResponseBodyEndUsers) SetUserSetPropertiesModels(v []*DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels) *DescribeUsersInGroupResponseBodyEndUsers {
	s.UserSetPropertiesModels = v
	return s
}

type DescribeUsersInGroupResponseBodyEndUsersExternalInfo struct {
	// The external name.
	ExternalName *string `json:"ExternalName,omitempty" xml:"ExternalName,omitempty"`
	// The employee ID.
	JobNumber *string `json:"JobNumber,omitempty" xml:"JobNumber,omitempty"`
}

func (s DescribeUsersInGroupResponseBodyEndUsersExternalInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeUsersInGroupResponseBodyEndUsersExternalInfo) GoString() string {
	return s.String()
}

func (s *DescribeUsersInGroupResponseBodyEndUsersExternalInfo) SetExternalName(v string) *DescribeUsersInGroupResponseBodyEndUsersExternalInfo {
	s.ExternalName = &v
	return s
}

func (s *DescribeUsersInGroupResponseBodyEndUsersExternalInfo) SetJobNumber(v string) *DescribeUsersInGroupResponseBodyEndUsersExternalInfo {
	s.JobNumber = &v
	return s
}

type DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels struct {
	// The ID of the property.
	PropertyId *int64 `json:"PropertyId,omitempty" xml:"PropertyId,omitempty"`
	// The name of the property.
	PropertyKey *string `json:"PropertyKey,omitempty" xml:"PropertyKey,omitempty"`
	// The type of the property.
	PropertyType *int32 `json:"PropertyType,omitempty" xml:"PropertyType,omitempty"`
	// Details about property values.
	PropertyValues []*DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModelsPropertyValues `json:"PropertyValues,omitempty" xml:"PropertyValues,omitempty" type:"Repeated"`
	// The ID of the end user.
	UserId *int64 `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The name of the end user.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
}

func (s DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels) String() string {
	return tea.Prettify(s)
}

func (s DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels) GoString() string {
	return s.String()
}

func (s *DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels) SetPropertyId(v int64) *DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels {
	s.PropertyId = &v
	return s
}

func (s *DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels) SetPropertyKey(v string) *DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels {
	s.PropertyKey = &v
	return s
}

func (s *DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels) SetPropertyType(v int32) *DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels {
	s.PropertyType = &v
	return s
}

func (s *DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels) SetPropertyValues(v []*DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModelsPropertyValues) *DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels {
	s.PropertyValues = v
	return s
}

func (s *DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels) SetUserId(v int64) *DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels {
	s.UserId = &v
	return s
}

func (s *DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels) SetUserName(v string) *DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels {
	s.UserName = &v
	return s
}

type DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModelsPropertyValues struct {
	// The property value.
	PropertyValue *string `json:"PropertyValue,omitempty" xml:"PropertyValue,omitempty"`
	// The ID of the property value.
	PropertyValueId *int64 `json:"PropertyValueId,omitempty" xml:"PropertyValueId,omitempty"`
}

func (s DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModelsPropertyValues) String() string {
	return tea.Prettify(s)
}

func (s DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModelsPropertyValues) GoString() string {
	return s.String()
}

func (s *DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModelsPropertyValues) SetPropertyValue(v string) *DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModelsPropertyValues {
	s.PropertyValue = &v
	return s
}

func (s *DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModelsPropertyValues) SetPropertyValueId(v int64) *DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModelsPropertyValues {
	s.PropertyValueId = &v
	return s
}

type DescribeUsersInGroupResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeUsersInGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeUsersInGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeUsersInGroupResponse) GoString() string {
	return s.String()
}

func (s *DescribeUsersInGroupResponse) SetHeaders(v map[string]*string) *DescribeUsersInGroupResponse {
	s.Headers = v
	return s
}

func (s *DescribeUsersInGroupResponse) SetStatusCode(v int32) *DescribeUsersInGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeUsersInGroupResponse) SetBody(v *DescribeUsersInGroupResponseBody) *DescribeUsersInGroupResponse {
	s.Body = v
	return s
}

type DescribeUsersPasswordRequest struct {
	// The ID of the cloud desktop.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeUsersPasswordRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeUsersPasswordRequest) GoString() string {
	return s.String()
}

func (s *DescribeUsersPasswordRequest) SetDesktopId(v string) *DescribeUsersPasswordRequest {
	s.DesktopId = &v
	return s
}

func (s *DescribeUsersPasswordRequest) SetRegionId(v string) *DescribeUsersPasswordRequest {
	s.RegionId = &v
	return s
}

type DescribeUsersPasswordResponseBody struct {
	// The users that are associated with cloud desktop.
	DesktopUsers []*DescribeUsersPasswordResponseBodyDesktopUsers `json:"DesktopUsers,omitempty" xml:"DesktopUsers,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeUsersPasswordResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeUsersPasswordResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeUsersPasswordResponseBody) SetDesktopUsers(v []*DescribeUsersPasswordResponseBodyDesktopUsers) *DescribeUsersPasswordResponseBody {
	s.DesktopUsers = v
	return s
}

func (s *DescribeUsersPasswordResponseBody) SetRequestId(v string) *DescribeUsersPasswordResponseBody {
	s.RequestId = &v
	return s
}

type DescribeUsersPasswordResponseBodyDesktopUsers struct {
	// The display name of the user.
	DisplayName *string `json:"DisplayName,omitempty" xml:"DisplayName,omitempty"`
	// The ID of the end user.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The password of the user.
	Password *string `json:"Password,omitempty" xml:"Password,omitempty"`
}

func (s DescribeUsersPasswordResponseBodyDesktopUsers) String() string {
	return tea.Prettify(s)
}

func (s DescribeUsersPasswordResponseBodyDesktopUsers) GoString() string {
	return s.String()
}

func (s *DescribeUsersPasswordResponseBodyDesktopUsers) SetDisplayName(v string) *DescribeUsersPasswordResponseBodyDesktopUsers {
	s.DisplayName = &v
	return s
}

func (s *DescribeUsersPasswordResponseBodyDesktopUsers) SetEndUserId(v string) *DescribeUsersPasswordResponseBodyDesktopUsers {
	s.EndUserId = &v
	return s
}

func (s *DescribeUsersPasswordResponseBodyDesktopUsers) SetPassword(v string) *DescribeUsersPasswordResponseBodyDesktopUsers {
	s.Password = &v
	return s
}

type DescribeUsersPasswordResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeUsersPasswordResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeUsersPasswordResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeUsersPasswordResponse) GoString() string {
	return s.String()
}

func (s *DescribeUsersPasswordResponse) SetHeaders(v map[string]*string) *DescribeUsersPasswordResponse {
	s.Headers = v
	return s
}

func (s *DescribeUsersPasswordResponse) SetStatusCode(v int32) *DescribeUsersPasswordResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeUsersPasswordResponse) SetBody(v *DescribeUsersPasswordResponseBody) *DescribeUsersPasswordResponse {
	s.Body = v
	return s
}

type DescribeVirtualMFADevicesRequest struct {
	// The names of the AD users.
	EndUserId []*string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty" type:"Repeated"`
	// The number of entries per page. Valid values: 1 to 500. Default value: 100.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. You must specify the token that is obtained from the previous query as the value of NextToken.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeVirtualMFADevicesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVirtualMFADevicesRequest) GoString() string {
	return s.String()
}

func (s *DescribeVirtualMFADevicesRequest) SetEndUserId(v []*string) *DescribeVirtualMFADevicesRequest {
	s.EndUserId = v
	return s
}

func (s *DescribeVirtualMFADevicesRequest) SetMaxResults(v int32) *DescribeVirtualMFADevicesRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeVirtualMFADevicesRequest) SetNextToken(v string) *DescribeVirtualMFADevicesRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeVirtualMFADevicesRequest) SetOfficeSiteId(v string) *DescribeVirtualMFADevicesRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *DescribeVirtualMFADevicesRequest) SetRegionId(v string) *DescribeVirtualMFADevicesRequest {
	s.RegionId = &v
	return s
}

type DescribeVirtualMFADevicesResponseBody struct {
	// A pagination token. It can be used in the next request to retrieve a new page of results.If NextToken is empty, no next page exists.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Details of the virtual MFA devices.
	VirtualMFADevices []*DescribeVirtualMFADevicesResponseBodyVirtualMFADevices `json:"VirtualMFADevices,omitempty" xml:"VirtualMFADevices,omitempty" type:"Repeated"`
}

func (s DescribeVirtualMFADevicesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVirtualMFADevicesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVirtualMFADevicesResponseBody) SetNextToken(v string) *DescribeVirtualMFADevicesResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeVirtualMFADevicesResponseBody) SetRequestId(v string) *DescribeVirtualMFADevicesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVirtualMFADevicesResponseBody) SetVirtualMFADevices(v []*DescribeVirtualMFADevicesResponseBodyVirtualMFADevices) *DescribeVirtualMFADevicesResponseBody {
	s.VirtualMFADevices = v
	return s
}

type DescribeVirtualMFADevicesResponseBodyVirtualMFADevices struct {
	// The number of consecutive failures to bind the virtual MFA device, or the number of failures on the verification of the virtual MFA device.
	ConsecutiveFails *int32 `json:"ConsecutiveFails,omitempty" xml:"ConsecutiveFails,omitempty"`
	// > This parameter is in invitational preview and is not publicly available.
	DirectoryId *string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	// The name of the AD user who uses the virtual MFA device.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The time when the virtual MFA device was started. The time follows the [ISO 8601](~~25696~~) standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.
	GmtEnabled *string `json:"GmtEnabled,omitempty" xml:"GmtEnabled,omitempty"`
	// The time when a locked virtual MFA device was automatically unlocked. The time follows the [ISO 8601](~~25696~~) standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.
	GmtUnlock *string `json:"GmtUnlock,omitempty" xml:"GmtUnlock,omitempty"`
	// The ID of the workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The serial number of the virtual MFA device, which is a unique identifier.
	SerialNumber *string `json:"SerialNumber,omitempty" xml:"SerialNumber,omitempty"`
	// The status of the virtual MFA device.
	//
	// Valid values:
	//
	// *   LOCKED
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   UNBOUND
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   NORMAL
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s DescribeVirtualMFADevicesResponseBodyVirtualMFADevices) String() string {
	return tea.Prettify(s)
}

func (s DescribeVirtualMFADevicesResponseBodyVirtualMFADevices) GoString() string {
	return s.String()
}

func (s *DescribeVirtualMFADevicesResponseBodyVirtualMFADevices) SetConsecutiveFails(v int32) *DescribeVirtualMFADevicesResponseBodyVirtualMFADevices {
	s.ConsecutiveFails = &v
	return s
}

func (s *DescribeVirtualMFADevicesResponseBodyVirtualMFADevices) SetDirectoryId(v string) *DescribeVirtualMFADevicesResponseBodyVirtualMFADevices {
	s.DirectoryId = &v
	return s
}

func (s *DescribeVirtualMFADevicesResponseBodyVirtualMFADevices) SetEndUserId(v string) *DescribeVirtualMFADevicesResponseBodyVirtualMFADevices {
	s.EndUserId = &v
	return s
}

func (s *DescribeVirtualMFADevicesResponseBodyVirtualMFADevices) SetGmtEnabled(v string) *DescribeVirtualMFADevicesResponseBodyVirtualMFADevices {
	s.GmtEnabled = &v
	return s
}

func (s *DescribeVirtualMFADevicesResponseBodyVirtualMFADevices) SetGmtUnlock(v string) *DescribeVirtualMFADevicesResponseBodyVirtualMFADevices {
	s.GmtUnlock = &v
	return s
}

func (s *DescribeVirtualMFADevicesResponseBodyVirtualMFADevices) SetOfficeSiteId(v string) *DescribeVirtualMFADevicesResponseBodyVirtualMFADevices {
	s.OfficeSiteId = &v
	return s
}

func (s *DescribeVirtualMFADevicesResponseBodyVirtualMFADevices) SetSerialNumber(v string) *DescribeVirtualMFADevicesResponseBodyVirtualMFADevices {
	s.SerialNumber = &v
	return s
}

func (s *DescribeVirtualMFADevicesResponseBodyVirtualMFADevices) SetStatus(v string) *DescribeVirtualMFADevicesResponseBodyVirtualMFADevices {
	s.Status = &v
	return s
}

type DescribeVirtualMFADevicesResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVirtualMFADevicesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVirtualMFADevicesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVirtualMFADevicesResponse) GoString() string {
	return s.String()
}

func (s *DescribeVirtualMFADevicesResponse) SetHeaders(v map[string]*string) *DescribeVirtualMFADevicesResponse {
	s.Headers = v
	return s
}

func (s *DescribeVirtualMFADevicesResponse) SetStatusCode(v int32) *DescribeVirtualMFADevicesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVirtualMFADevicesResponse) SetBody(v *DescribeVirtualMFADevicesResponseBody) *DescribeVirtualMFADevicesResponse {
	s.Body = v
	return s
}

type DescribeZonesRequest struct {
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The zone type. Default value: **AvailabilityZone**. This value specifies Alibaba Cloud zones.
	ZoneType *string `json:"ZoneType,omitempty" xml:"ZoneType,omitempty"`
}

func (s DescribeZonesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeZonesRequest) GoString() string {
	return s.String()
}

func (s *DescribeZonesRequest) SetRegionId(v string) *DescribeZonesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeZonesRequest) SetZoneType(v string) *DescribeZonesRequest {
	s.ZoneType = &v
	return s
}

type DescribeZonesResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Details of zones.
	Zones []*DescribeZonesResponseBodyZones `json:"Zones,omitempty" xml:"Zones,omitempty" type:"Repeated"`
}

func (s DescribeZonesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeZonesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeZonesResponseBody) SetRequestId(v string) *DescribeZonesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeZonesResponseBody) SetZones(v []*DescribeZonesResponseBodyZones) *DescribeZonesResponseBody {
	s.Zones = v
	return s
}

type DescribeZonesResponseBodyZones struct {
	// The zone ID.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeZonesResponseBodyZones) String() string {
	return tea.Prettify(s)
}

func (s DescribeZonesResponseBodyZones) GoString() string {
	return s.String()
}

func (s *DescribeZonesResponseBodyZones) SetZoneId(v string) *DescribeZonesResponseBodyZones {
	s.ZoneId = &v
	return s
}

type DescribeZonesResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeZonesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeZonesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeZonesResponse) GoString() string {
	return s.String()
}

func (s *DescribeZonesResponse) SetHeaders(v map[string]*string) *DescribeZonesResponse {
	s.Headers = v
	return s
}

func (s *DescribeZonesResponse) SetStatusCode(v int32) *DescribeZonesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeZonesResponse) SetBody(v *DescribeZonesResponseBody) *DescribeZonesResponse {
	s.Body = v
	return s
}

type DetachCenRequest struct {
	// The workspace ID.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DetachCenRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachCenRequest) GoString() string {
	return s.String()
}

func (s *DetachCenRequest) SetOfficeSiteId(v string) *DetachCenRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *DetachCenRequest) SetRegionId(v string) *DetachCenRequest {
	s.RegionId = &v
	return s
}

type DetachCenResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DetachCenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachCenResponseBody) GoString() string {
	return s.String()
}

func (s *DetachCenResponseBody) SetRequestId(v string) *DetachCenResponseBody {
	s.RequestId = &v
	return s
}

type DetachCenResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachCenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachCenResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachCenResponse) GoString() string {
	return s.String()
}

func (s *DetachCenResponse) SetHeaders(v map[string]*string) *DetachCenResponse {
	s.Headers = v
	return s
}

func (s *DetachCenResponse) SetStatusCode(v int32) *DetachCenResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachCenResponse) SetBody(v *DetachCenResponseBody) *DetachCenResponse {
	s.Body = v
	return s
}

type DetachEndUserRequest struct {
	// The address of the Active Directory (AD) workspace.
	AdDomain *string `json:"AdDomain,omitempty" xml:"AdDomain,omitempty"`
	// The type of the Alibaba Cloud Workspace client. 1: the hardware client 2: the software client
	ClientType *string `json:"ClientType,omitempty" xml:"ClientType,omitempty"`
	// The ID of the device.
	DeviceId *string `json:"DeviceId,omitempty" xml:"DeviceId,omitempty"`
	// The ID of the workspace.
	DirectoryId *string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	// The ID of the user that is bound to the client.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The ID of the region.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
}

func (s DetachEndUserRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachEndUserRequest) GoString() string {
	return s.String()
}

func (s *DetachEndUserRequest) SetAdDomain(v string) *DetachEndUserRequest {
	s.AdDomain = &v
	return s
}

func (s *DetachEndUserRequest) SetClientType(v string) *DetachEndUserRequest {
	s.ClientType = &v
	return s
}

func (s *DetachEndUserRequest) SetDeviceId(v string) *DetachEndUserRequest {
	s.DeviceId = &v
	return s
}

func (s *DetachEndUserRequest) SetDirectoryId(v string) *DetachEndUserRequest {
	s.DirectoryId = &v
	return s
}

func (s *DetachEndUserRequest) SetEndUserId(v string) *DetachEndUserRequest {
	s.EndUserId = &v
	return s
}

func (s *DetachEndUserRequest) SetRegion(v string) *DetachEndUserRequest {
	s.Region = &v
	return s
}

type DetachEndUserResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DetachEndUserResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachEndUserResponseBody) GoString() string {
	return s.String()
}

func (s *DetachEndUserResponseBody) SetRequestId(v string) *DetachEndUserResponseBody {
	s.RequestId = &v
	return s
}

type DetachEndUserResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachEndUserResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachEndUserResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachEndUserResponse) GoString() string {
	return s.String()
}

func (s *DetachEndUserResponse) SetHeaders(v map[string]*string) *DetachEndUserResponse {
	s.Headers = v
	return s
}

func (s *DetachEndUserResponse) SetStatusCode(v int32) *DetachEndUserResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachEndUserResponse) SetBody(v *DetachEndUserResponseBody) *DetachEndUserResponse {
	s.Body = v
	return s
}

type DisableDesktopsInGroupRequest struct {
	// The ID of the desktop group.
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// The IDs of the cloud desktops.
	DesktopIds []*string `json:"DesktopIds,omitempty" xml:"DesktopIds,omitempty" type:"Repeated"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DisableDesktopsInGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DisableDesktopsInGroupRequest) GoString() string {
	return s.String()
}

func (s *DisableDesktopsInGroupRequest) SetDesktopGroupId(v string) *DisableDesktopsInGroupRequest {
	s.DesktopGroupId = &v
	return s
}

func (s *DisableDesktopsInGroupRequest) SetDesktopIds(v []*string) *DisableDesktopsInGroupRequest {
	s.DesktopIds = v
	return s
}

func (s *DisableDesktopsInGroupRequest) SetRegionId(v string) *DisableDesktopsInGroupRequest {
	s.RegionId = &v
	return s
}

type DisableDesktopsInGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DisableDesktopsInGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DisableDesktopsInGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DisableDesktopsInGroupResponseBody) SetRequestId(v string) *DisableDesktopsInGroupResponseBody {
	s.RequestId = &v
	return s
}

type DisableDesktopsInGroupResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DisableDesktopsInGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DisableDesktopsInGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableDesktopsInGroupResponse) GoString() string {
	return s.String()
}

func (s *DisableDesktopsInGroupResponse) SetHeaders(v map[string]*string) *DisableDesktopsInGroupResponse {
	s.Headers = v
	return s
}

func (s *DisableDesktopsInGroupResponse) SetStatusCode(v int32) *DisableDesktopsInGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableDesktopsInGroupResponse) SetBody(v *DisableDesktopsInGroupResponseBody) *DisableDesktopsInGroupResponse {
	s.Body = v
	return s
}

type DissociateNetworkPackageRequest struct {
	// The ID of the Internet access package. You can call the [DescribeNetworkPackages](~~216079~~) operation to query the ID of the Internet access package.
	NetworkPackageId *string `json:"NetworkPackageId,omitempty" xml:"NetworkPackageId,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DissociateNetworkPackageRequest) String() string {
	return tea.Prettify(s)
}

func (s DissociateNetworkPackageRequest) GoString() string {
	return s.String()
}

func (s *DissociateNetworkPackageRequest) SetNetworkPackageId(v string) *DissociateNetworkPackageRequest {
	s.NetworkPackageId = &v
	return s
}

func (s *DissociateNetworkPackageRequest) SetRegionId(v string) *DissociateNetworkPackageRequest {
	s.RegionId = &v
	return s
}

type DissociateNetworkPackageResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DissociateNetworkPackageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DissociateNetworkPackageResponseBody) GoString() string {
	return s.String()
}

func (s *DissociateNetworkPackageResponseBody) SetRequestId(v string) *DissociateNetworkPackageResponseBody {
	s.RequestId = &v
	return s
}

type DissociateNetworkPackageResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DissociateNetworkPackageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DissociateNetworkPackageResponse) String() string {
	return tea.Prettify(s)
}

func (s DissociateNetworkPackageResponse) GoString() string {
	return s.String()
}

func (s *DissociateNetworkPackageResponse) SetHeaders(v map[string]*string) *DissociateNetworkPackageResponse {
	s.Headers = v
	return s
}

func (s *DissociateNetworkPackageResponse) SetStatusCode(v int32) *DissociateNetworkPackageResponse {
	s.StatusCode = &v
	return s
}

func (s *DissociateNetworkPackageResponse) SetBody(v *DissociateNetworkPackageResponseBody) *DissociateNetworkPackageResponse {
	s.Body = v
	return s
}

type ExportClientEventsRequest struct {
	// The ID of the cloud desktop.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The name of the cloud desktop.
	DesktopName *string `json:"DesktopName,omitempty" xml:"DesktopName,omitempty"`
	// The end of the time range to query. Specify the time in the [ISO 8601](~~25696~~) standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.
	//
	// If you do not specify a value for this parameter, the current time is used.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the endpoint user.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The type of event that you want to query. Valid values:
	//
	// *   DESKTOP_CONNECT: The desktop session is established.
	// *   DESKTOP_DISCONNECT: The desktop session is disconnected.
	// *   DESKTOP_REBOOT: The cloud desktop is restarted.
	// *   CLIENT_AD_LOGIN: The AD user logs on to the client.
	// *   GET_CONNECTION_TICKET: The request to connect to the cloud desktop is sent.
	// *   DESKTOP_START: The cloud desktop is started.
	// *   DESKTOP_STOP: The cloud desktop is stopped.
	//
	// If you do not specify a value for this parameter, events of all types are queried.
	EventType *string `json:"EventType,omitempty" xml:"EventType,omitempty"`
	// The types of event.
	EventTypes []*string `json:"EventTypes,omitempty" xml:"EventTypes,omitempty" type:"Repeated"`
	// The language in which the cloud desktop is displayed in the console UI. You can export the list of cloud desktops in the specified language. Valid values:
	//
	// *   `zh-CN`: Simplified Chinese
	// *   `en-GB`: English (United Kingdom)
	//
	// Default value: `zh-CN`.
	LangType *string `json:"LangType,omitempty" xml:"LangType,omitempty"`
	// The number of entries to return on each page.
	//
	// *   Maximum value: 5000.
	// *   Default value: 5000.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The ID of the workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The name of the workspace.
	OfficeSiteName *string `json:"OfficeSiteName,omitempty" xml:"OfficeSiteName,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The beginning of the time range to query. Specify the time in the [ISO 8601](~~25696~~) standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.
	//
	// If you do not specify a value for this parameter, all events that occurred before the point in time that you specify for `EndTime` are queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s ExportClientEventsRequest) String() string {
	return tea.Prettify(s)
}

func (s ExportClientEventsRequest) GoString() string {
	return s.String()
}

func (s *ExportClientEventsRequest) SetDesktopId(v string) *ExportClientEventsRequest {
	s.DesktopId = &v
	return s
}

func (s *ExportClientEventsRequest) SetDesktopName(v string) *ExportClientEventsRequest {
	s.DesktopName = &v
	return s
}

func (s *ExportClientEventsRequest) SetEndTime(v string) *ExportClientEventsRequest {
	s.EndTime = &v
	return s
}

func (s *ExportClientEventsRequest) SetEndUserId(v string) *ExportClientEventsRequest {
	s.EndUserId = &v
	return s
}

func (s *ExportClientEventsRequest) SetEventType(v string) *ExportClientEventsRequest {
	s.EventType = &v
	return s
}

func (s *ExportClientEventsRequest) SetEventTypes(v []*string) *ExportClientEventsRequest {
	s.EventTypes = v
	return s
}

func (s *ExportClientEventsRequest) SetLangType(v string) *ExportClientEventsRequest {
	s.LangType = &v
	return s
}

func (s *ExportClientEventsRequest) SetMaxResults(v int32) *ExportClientEventsRequest {
	s.MaxResults = &v
	return s
}

func (s *ExportClientEventsRequest) SetOfficeSiteId(v string) *ExportClientEventsRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *ExportClientEventsRequest) SetOfficeSiteName(v string) *ExportClientEventsRequest {
	s.OfficeSiteName = &v
	return s
}

func (s *ExportClientEventsRequest) SetRegionId(v string) *ExportClientEventsRequest {
	s.RegionId = &v
	return s
}

func (s *ExportClientEventsRequest) SetStartTime(v string) *ExportClientEventsRequest {
	s.StartTime = &v
	return s
}

type ExportClientEventsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The download address from which you can export desktop groups.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s ExportClientEventsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ExportClientEventsResponseBody) GoString() string {
	return s.String()
}

func (s *ExportClientEventsResponseBody) SetRequestId(v string) *ExportClientEventsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ExportClientEventsResponseBody) SetUrl(v string) *ExportClientEventsResponseBody {
	s.Url = &v
	return s
}

type ExportClientEventsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ExportClientEventsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ExportClientEventsResponse) String() string {
	return tea.Prettify(s)
}

func (s ExportClientEventsResponse) GoString() string {
	return s.String()
}

func (s *ExportClientEventsResponse) SetHeaders(v map[string]*string) *ExportClientEventsResponse {
	s.Headers = v
	return s
}

func (s *ExportClientEventsResponse) SetStatusCode(v int32) *ExportClientEventsResponse {
	s.StatusCode = &v
	return s
}

func (s *ExportClientEventsResponse) SetBody(v *ExportClientEventsResponseBody) *ExportClientEventsResponse {
	s.Body = v
	return s
}

type ExportDesktopGroupInfoRequest struct {
	// The billing method of the cloud desktop. Valid values:
	//
	// *   PostPaid: pay-as-you-go
	// *   PrePaid: subscription
	//
	// Default value: PostPaid.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The ID of the desktop group. You can set 1 to 100.
	DesktopGroupId []*string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty" type:"Repeated"`
	// The name of the desktop group.
	DesktopGroupName *string `json:"DesktopGroupName,omitempty" xml:"DesktopGroupName,omitempty"`
	// The ID of the user who is authorized to use the desktop group. You can set 1 to 100.
	EndUserId []*string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty" type:"Repeated"`
	// The time when the subscription cloud desktop expires.
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The language of the response.
	LangType *string `json:"LangType,omitempty" xml:"LangType,omitempty"`
	// The number of entries to return on each page.
	//
	// Maximum value: 100.
	//
	// Default value: 10.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the next query. If this parameter is left empty, all results are returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The ID of the policy that is associated with the cloud desktop.
	PolicyGroupId *string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ExportDesktopGroupInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s ExportDesktopGroupInfoRequest) GoString() string {
	return s.String()
}

func (s *ExportDesktopGroupInfoRequest) SetChargeType(v string) *ExportDesktopGroupInfoRequest {
	s.ChargeType = &v
	return s
}

func (s *ExportDesktopGroupInfoRequest) SetDesktopGroupId(v []*string) *ExportDesktopGroupInfoRequest {
	s.DesktopGroupId = v
	return s
}

func (s *ExportDesktopGroupInfoRequest) SetDesktopGroupName(v string) *ExportDesktopGroupInfoRequest {
	s.DesktopGroupName = &v
	return s
}

func (s *ExportDesktopGroupInfoRequest) SetEndUserId(v []*string) *ExportDesktopGroupInfoRequest {
	s.EndUserId = v
	return s
}

func (s *ExportDesktopGroupInfoRequest) SetExpiredTime(v string) *ExportDesktopGroupInfoRequest {
	s.ExpiredTime = &v
	return s
}

func (s *ExportDesktopGroupInfoRequest) SetLangType(v string) *ExportDesktopGroupInfoRequest {
	s.LangType = &v
	return s
}

func (s *ExportDesktopGroupInfoRequest) SetMaxResults(v int32) *ExportDesktopGroupInfoRequest {
	s.MaxResults = &v
	return s
}

func (s *ExportDesktopGroupInfoRequest) SetNextToken(v string) *ExportDesktopGroupInfoRequest {
	s.NextToken = &v
	return s
}

func (s *ExportDesktopGroupInfoRequest) SetOfficeSiteId(v string) *ExportDesktopGroupInfoRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *ExportDesktopGroupInfoRequest) SetPolicyGroupId(v string) *ExportDesktopGroupInfoRequest {
	s.PolicyGroupId = &v
	return s
}

func (s *ExportDesktopGroupInfoRequest) SetRegionId(v string) *ExportDesktopGroupInfoRequest {
	s.RegionId = &v
	return s
}

type ExportDesktopGroupInfoResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The download URL of the exported file that contains the monitoring data of sessions in the desktop group.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s ExportDesktopGroupInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ExportDesktopGroupInfoResponseBody) GoString() string {
	return s.String()
}

func (s *ExportDesktopGroupInfoResponseBody) SetRequestId(v string) *ExportDesktopGroupInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *ExportDesktopGroupInfoResponseBody) SetUrl(v string) *ExportDesktopGroupInfoResponseBody {
	s.Url = &v
	return s
}

type ExportDesktopGroupInfoResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ExportDesktopGroupInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ExportDesktopGroupInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s ExportDesktopGroupInfoResponse) GoString() string {
	return s.String()
}

func (s *ExportDesktopGroupInfoResponse) SetHeaders(v map[string]*string) *ExportDesktopGroupInfoResponse {
	s.Headers = v
	return s
}

func (s *ExportDesktopGroupInfoResponse) SetStatusCode(v int32) *ExportDesktopGroupInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *ExportDesktopGroupInfoResponse) SetBody(v *ExportDesktopGroupInfoResponseBody) *ExportDesktopGroupInfoResponse {
	s.Body = v
	return s
}

type ExportDesktopListInfoRequest struct {
	// The billing method of the cloud desktop. Valid values:
	//
	// *   PostPaid: pay-as-you-go
	// *   PrePaid: subscription
	//
	// Default value: PostPaid.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The ID of the cloud desktop.
	DesktopId []*string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty" type:"Repeated"`
	// The name of the cloud desktop.
	DesktopName *string `json:"DesktopName,omitempty" xml:"DesktopName,omitempty"`
	// The status of the cloud desktop. Valid values:
	//
	// *   Pending
	// *   Starting
	// *   Running
	// *   Stopping
	// *   Rebuilding
	// *   Stopped
	// *   Expired
	// *   Deleted
	DesktopStatus *string   `json:"DesktopStatus,omitempty" xml:"DesktopStatus,omitempty"`
	EndUserId     []*string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty" type:"Repeated"`
	// The time when the subscription cloud desktop expires.
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The ID of the group to which the cloud desktop belongs.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The language that you want to use.
	LangType *string `json:"LangType,omitempty" xml:"LangType,omitempty"`
	// The maximum number of entries to return on each page.
	//
	// Maximum value: 100.
	//
	// Default value: 10.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used for the next query. If this parameter is empty, all results are returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The ID of the policy that is associated with the cloud desktop.
	PolicyGroupId *string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The tags that you want to add to the cloud desktop.
	Tag []*ExportDesktopListInfoRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The username of the current user of the cloud desktop.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
}

func (s ExportDesktopListInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s ExportDesktopListInfoRequest) GoString() string {
	return s.String()
}

func (s *ExportDesktopListInfoRequest) SetChargeType(v string) *ExportDesktopListInfoRequest {
	s.ChargeType = &v
	return s
}

func (s *ExportDesktopListInfoRequest) SetDesktopId(v []*string) *ExportDesktopListInfoRequest {
	s.DesktopId = v
	return s
}

func (s *ExportDesktopListInfoRequest) SetDesktopName(v string) *ExportDesktopListInfoRequest {
	s.DesktopName = &v
	return s
}

func (s *ExportDesktopListInfoRequest) SetDesktopStatus(v string) *ExportDesktopListInfoRequest {
	s.DesktopStatus = &v
	return s
}

func (s *ExportDesktopListInfoRequest) SetEndUserId(v []*string) *ExportDesktopListInfoRequest {
	s.EndUserId = v
	return s
}

func (s *ExportDesktopListInfoRequest) SetExpiredTime(v string) *ExportDesktopListInfoRequest {
	s.ExpiredTime = &v
	return s
}

func (s *ExportDesktopListInfoRequest) SetGroupId(v string) *ExportDesktopListInfoRequest {
	s.GroupId = &v
	return s
}

func (s *ExportDesktopListInfoRequest) SetLangType(v string) *ExportDesktopListInfoRequest {
	s.LangType = &v
	return s
}

func (s *ExportDesktopListInfoRequest) SetMaxResults(v int32) *ExportDesktopListInfoRequest {
	s.MaxResults = &v
	return s
}

func (s *ExportDesktopListInfoRequest) SetNextToken(v string) *ExportDesktopListInfoRequest {
	s.NextToken = &v
	return s
}

func (s *ExportDesktopListInfoRequest) SetOfficeSiteId(v string) *ExportDesktopListInfoRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *ExportDesktopListInfoRequest) SetPolicyGroupId(v string) *ExportDesktopListInfoRequest {
	s.PolicyGroupId = &v
	return s
}

func (s *ExportDesktopListInfoRequest) SetRegionId(v string) *ExportDesktopListInfoRequest {
	s.RegionId = &v
	return s
}

func (s *ExportDesktopListInfoRequest) SetTag(v []*ExportDesktopListInfoRequestTag) *ExportDesktopListInfoRequest {
	s.Tag = v
	return s
}

func (s *ExportDesktopListInfoRequest) SetUserName(v string) *ExportDesktopListInfoRequest {
	s.UserName = &v
	return s
}

type ExportDesktopListInfoRequestTag struct {
	// The key of the tag. You can specify 1 to 20 keys for a tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag. You can specify 1 to 20 values for a tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ExportDesktopListInfoRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ExportDesktopListInfoRequestTag) GoString() string {
	return s.String()
}

func (s *ExportDesktopListInfoRequestTag) SetKey(v string) *ExportDesktopListInfoRequestTag {
	s.Key = &v
	return s
}

func (s *ExportDesktopListInfoRequestTag) SetValue(v string) *ExportDesktopListInfoRequestTag {
	s.Value = &v
	return s
}

type ExportDesktopListInfoResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The URL from which you can download the file that contains information about exported cloud desktops.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s ExportDesktopListInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ExportDesktopListInfoResponseBody) GoString() string {
	return s.String()
}

func (s *ExportDesktopListInfoResponseBody) SetRequestId(v string) *ExportDesktopListInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *ExportDesktopListInfoResponseBody) SetUrl(v string) *ExportDesktopListInfoResponseBody {
	s.Url = &v
	return s
}

type ExportDesktopListInfoResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ExportDesktopListInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ExportDesktopListInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s ExportDesktopListInfoResponse) GoString() string {
	return s.String()
}

func (s *ExportDesktopListInfoResponse) SetHeaders(v map[string]*string) *ExportDesktopListInfoResponse {
	s.Headers = v
	return s
}

func (s *ExportDesktopListInfoResponse) SetStatusCode(v int32) *ExportDesktopListInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *ExportDesktopListInfoResponse) SetBody(v *ExportDesktopListInfoResponseBody) *ExportDesktopListInfoResponse {
	s.Body = v
	return s
}

type GetAsyncTaskRequest struct {
	// The asynchronous task ID. This parameter is not returned if you copy files. This parameter is returned if you copy folders in the backend in an asynchronous manner. You can call the GetAsyncTask operation to obtain the ID and information about an asynchronous task.
	AsyncTaskId *string `json:"AsyncTaskId,omitempty" xml:"AsyncTaskId,omitempty"`
	// The ID of the cloud disk.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
}

func (s GetAsyncTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAsyncTaskRequest) GoString() string {
	return s.String()
}

func (s *GetAsyncTaskRequest) SetAsyncTaskId(v string) *GetAsyncTaskRequest {
	s.AsyncTaskId = &v
	return s
}

func (s *GetAsyncTaskRequest) SetCdsId(v string) *GetAsyncTaskRequest {
	s.CdsId = &v
	return s
}

type GetAsyncTaskResponseBody struct {
	// The operation result. If the request was successful, a success message is returned. If the request failed, an error message is returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data information.
	Data *GetAsyncTaskResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetAsyncTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAsyncTaskResponseBody) GoString() string {
	return s.String()
}

func (s *GetAsyncTaskResponseBody) SetCode(v string) *GetAsyncTaskResponseBody {
	s.Code = &v
	return s
}

func (s *GetAsyncTaskResponseBody) SetData(v *GetAsyncTaskResponseBodyData) *GetAsyncTaskResponseBody {
	s.Data = v
	return s
}

func (s *GetAsyncTaskResponseBody) SetRequestId(v string) *GetAsyncTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetAsyncTaskResponseBody) SetSuccess(v string) *GetAsyncTaskResponseBody {
	s.Success = &v
	return s
}

type GetAsyncTaskResponseBodyData struct {
	// The asynchronous task ID.
	AsyncTaskId *string `json:"AsyncTaskId,omitempty" xml:"AsyncTaskId,omitempty"`
	// The total number of asynchronous tasks that are processed. Example: the number of files that are packaged and downloaded on the server.
	ConsumedProcess *string `json:"ConsumedProcess,omitempty" xml:"ConsumedProcess,omitempty"`
	// The error code of the asynchronous task.
	ErrCode *int64 `json:"ErrCode,omitempty" xml:"ErrCode,omitempty"`
	// The error message of the asynchronous task.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The task status.
	//
	// Valid values:
	//
	// *   Failed: The task failed.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Running: The task was running.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   PartialSucceed: The task did not completely succeed.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Succeed: The task succeeded.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The total number of asynchronous tasks to be processed, such as the amount of files to be downloaded and packaged on the server.
	TotalProcess *int64 `json:"TotalProcess,omitempty" xml:"TotalProcess,omitempty"`
	// The URL to download data generated by the asynchronous task. Example: the URL to package and download tasks on the server.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetAsyncTaskResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetAsyncTaskResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetAsyncTaskResponseBodyData) SetAsyncTaskId(v string) *GetAsyncTaskResponseBodyData {
	s.AsyncTaskId = &v
	return s
}

func (s *GetAsyncTaskResponseBodyData) SetConsumedProcess(v string) *GetAsyncTaskResponseBodyData {
	s.ConsumedProcess = &v
	return s
}

func (s *GetAsyncTaskResponseBodyData) SetErrCode(v int64) *GetAsyncTaskResponseBodyData {
	s.ErrCode = &v
	return s
}

func (s *GetAsyncTaskResponseBodyData) SetMessage(v string) *GetAsyncTaskResponseBodyData {
	s.Message = &v
	return s
}

func (s *GetAsyncTaskResponseBodyData) SetStatus(v string) *GetAsyncTaskResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetAsyncTaskResponseBodyData) SetTotalProcess(v int64) *GetAsyncTaskResponseBodyData {
	s.TotalProcess = &v
	return s
}

func (s *GetAsyncTaskResponseBodyData) SetUrl(v string) *GetAsyncTaskResponseBodyData {
	s.Url = &v
	return s
}

type GetAsyncTaskResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAsyncTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAsyncTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAsyncTaskResponse) GoString() string {
	return s.String()
}

func (s *GetAsyncTaskResponse) SetHeaders(v map[string]*string) *GetAsyncTaskResponse {
	s.Headers = v
	return s
}

func (s *GetAsyncTaskResponse) SetStatusCode(v int32) *GetAsyncTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAsyncTaskResponse) SetBody(v *GetAsyncTaskResponseBody) *GetAsyncTaskResponse {
	s.Body = v
	return s
}

type GetConnectionTicketRequest struct {
	// The command that you want to run to configure a custom application in user mode. After you obtain the credentials, the application automatically starts.
	//
	// *   appPath: the path of the application startup file. Example: C:\\\Program Files (x86)\\\000\\\000.exe. Use double slashes as delimiters.
	// *   appParameter: the startup parameters of the application. The value must be of the String type. Separate multiple parameters with spaces. Example: meetingid 000 meetingname aaa.
	CommandContent *string `json:"CommandContent,omitempty" xml:"CommandContent,omitempty"`
	// The ID of the cloud desktop.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The ID of the end user.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	OwnerId   *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The password for the username.
	Password *string `json:"Password,omitempty" xml:"Password,omitempty"`
	// The region ID of the cloud desktop.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the desktop connection task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The unique identifier of the client. If you use an Alibaba Cloud Workspace client, click **About** on the client logon page to view the identifier of the client.
	Uuid *string `json:"Uuid,omitempty" xml:"Uuid,omitempty"`
}

func (s GetConnectionTicketRequest) String() string {
	return tea.Prettify(s)
}

func (s GetConnectionTicketRequest) GoString() string {
	return s.String()
}

func (s *GetConnectionTicketRequest) SetCommandContent(v string) *GetConnectionTicketRequest {
	s.CommandContent = &v
	return s
}

func (s *GetConnectionTicketRequest) SetDesktopId(v string) *GetConnectionTicketRequest {
	s.DesktopId = &v
	return s
}

func (s *GetConnectionTicketRequest) SetEndUserId(v string) *GetConnectionTicketRequest {
	s.EndUserId = &v
	return s
}

func (s *GetConnectionTicketRequest) SetOwnerId(v int64) *GetConnectionTicketRequest {
	s.OwnerId = &v
	return s
}

func (s *GetConnectionTicketRequest) SetPassword(v string) *GetConnectionTicketRequest {
	s.Password = &v
	return s
}

func (s *GetConnectionTicketRequest) SetRegionId(v string) *GetConnectionTicketRequest {
	s.RegionId = &v
	return s
}

func (s *GetConnectionTicketRequest) SetResourceOwnerAccount(v string) *GetConnectionTicketRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetConnectionTicketRequest) SetResourceOwnerId(v int64) *GetConnectionTicketRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *GetConnectionTicketRequest) SetTaskId(v string) *GetConnectionTicketRequest {
	s.TaskId = &v
	return s
}

func (s *GetConnectionTicketRequest) SetUuid(v string) *GetConnectionTicketRequest {
	s.Uuid = &v
	return s
}

type GetConnectionTicketResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the desktop connection task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The status of the task.
	//
	// Valid values:
	//
	// *   FAILED
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     Failed to obtain the token
	//
	//     <!-- -->
	//
	//     .
	//
	// *   RUNNING
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The token is being obtained
	//
	//     <!-- -->
	//
	//     .
	//
	// *   FINISHED
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The token-based logon is successful
	//
	//     <!-- -->
	//
	//     .
	TaskStatus *string `json:"TaskStatus,omitempty" xml:"TaskStatus,omitempty"`
	// The credentials that are used to connect to the cloud desktop. To use the credentials, you must decode the credentials in Base64, save the credentials as a xxx.ica file, and then open the file. Sample Python code:
	//
	//     import base64
	//     response = {
	//         "Ticket": "XXXX",
	//         "RequestId": "XXX-XXX",
	//     }
	//     f = open (\"xxx.ica\", \"w\")
	//     out = base64.b64decode(response[\"Ticket\"])
	//     f.write(out)
	//     f.close()
	Ticket *string `json:"Ticket,omitempty" xml:"Ticket,omitempty"`
}

func (s GetConnectionTicketResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetConnectionTicketResponseBody) GoString() string {
	return s.String()
}

func (s *GetConnectionTicketResponseBody) SetRequestId(v string) *GetConnectionTicketResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetConnectionTicketResponseBody) SetTaskId(v string) *GetConnectionTicketResponseBody {
	s.TaskId = &v
	return s
}

func (s *GetConnectionTicketResponseBody) SetTaskStatus(v string) *GetConnectionTicketResponseBody {
	s.TaskStatus = &v
	return s
}

func (s *GetConnectionTicketResponseBody) SetTicket(v string) *GetConnectionTicketResponseBody {
	s.Ticket = &v
	return s
}

type GetConnectionTicketResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetConnectionTicketResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetConnectionTicketResponse) String() string {
	return tea.Prettify(s)
}

func (s GetConnectionTicketResponse) GoString() string {
	return s.String()
}

func (s *GetConnectionTicketResponse) SetHeaders(v map[string]*string) *GetConnectionTicketResponse {
	s.Headers = v
	return s
}

func (s *GetConnectionTicketResponse) SetStatusCode(v int32) *GetConnectionTicketResponse {
	s.StatusCode = &v
	return s
}

func (s *GetConnectionTicketResponse) SetBody(v *GetConnectionTicketResponseBody) *GetConnectionTicketResponse {
	s.Body = v
	return s
}

type GetCoordinateTicketRequest struct {
	// The ID of the stream collaboration. You can obtain the value of this parameter based on the value of `Coid` that is returned by the `ApplyCoordinationForMonitoring` operation.
	CoId *string `json:"CoId,omitempty" xml:"CoId,omitempty"`
	// The name of the convenience user account. If you initiate the request as an administrator, you do not need to specify this parameter.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~436773~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the cloud computer connection task. The first time you initiate the request, you do not need to specify the ID of the cloud computer connection task. If no ticket is returned after you initiate the first request, you must specify the value of taskId that is returned for the first request in the subsequent request.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The type of the user.
	//
	// Set the value to TENANT_ADMIN.
	//
	// *   The value of
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     TENANT_ADMIN
	//
	//     <!-- -->
	//
	//     specifies an administrator.
	UserType *string `json:"UserType,omitempty" xml:"UserType,omitempty"`
}

func (s GetCoordinateTicketRequest) String() string {
	return tea.Prettify(s)
}

func (s GetCoordinateTicketRequest) GoString() string {
	return s.String()
}

func (s *GetCoordinateTicketRequest) SetCoId(v string) *GetCoordinateTicketRequest {
	s.CoId = &v
	return s
}

func (s *GetCoordinateTicketRequest) SetEndUserId(v string) *GetCoordinateTicketRequest {
	s.EndUserId = &v
	return s
}

func (s *GetCoordinateTicketRequest) SetRegionId(v string) *GetCoordinateTicketRequest {
	s.RegionId = &v
	return s
}

func (s *GetCoordinateTicketRequest) SetTaskId(v string) *GetCoordinateTicketRequest {
	s.TaskId = &v
	return s
}

func (s *GetCoordinateTicketRequest) SetUserType(v string) *GetCoordinateTicketRequest {
	s.UserType = &v
	return s
}

type GetCoordinateTicketResponseBody struct {
	// The ID of the stream collaboration.
	CoId *string `json:"CoId,omitempty" xml:"CoId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the cloud computer connection task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The task status.
	//
	// Possible values:
	//
	// *   Finished
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Failed
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Running
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	TaskStatus *string `json:"TaskStatus,omitempty" xml:"TaskStatus,omitempty"`
	// The credentials of the stream collaboration.
	Ticket *string `json:"Ticket,omitempty" xml:"Ticket,omitempty"`
}

func (s GetCoordinateTicketResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetCoordinateTicketResponseBody) GoString() string {
	return s.String()
}

func (s *GetCoordinateTicketResponseBody) SetCoId(v string) *GetCoordinateTicketResponseBody {
	s.CoId = &v
	return s
}

func (s *GetCoordinateTicketResponseBody) SetRequestId(v string) *GetCoordinateTicketResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetCoordinateTicketResponseBody) SetTaskId(v string) *GetCoordinateTicketResponseBody {
	s.TaskId = &v
	return s
}

func (s *GetCoordinateTicketResponseBody) SetTaskStatus(v string) *GetCoordinateTicketResponseBody {
	s.TaskStatus = &v
	return s
}

func (s *GetCoordinateTicketResponseBody) SetTicket(v string) *GetCoordinateTicketResponseBody {
	s.Ticket = &v
	return s
}

type GetCoordinateTicketResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetCoordinateTicketResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetCoordinateTicketResponse) String() string {
	return tea.Prettify(s)
}

func (s GetCoordinateTicketResponse) GoString() string {
	return s.String()
}

func (s *GetCoordinateTicketResponse) SetHeaders(v map[string]*string) *GetCoordinateTicketResponse {
	s.Headers = v
	return s
}

func (s *GetCoordinateTicketResponse) SetStatusCode(v int32) *GetCoordinateTicketResponse {
	s.StatusCode = &v
	return s
}

func (s *GetCoordinateTicketResponse) SetBody(v *GetCoordinateTicketResponseBody) *GetCoordinateTicketResponse {
	s.Body = v
	return s
}

type GetDesktopGroupDetailRequest struct {
	// The ID of the desktop group.
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// The region ID of the desktop group.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetDesktopGroupDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDesktopGroupDetailRequest) GoString() string {
	return s.String()
}

func (s *GetDesktopGroupDetailRequest) SetDesktopGroupId(v string) *GetDesktopGroupDetailRequest {
	s.DesktopGroupId = &v
	return s
}

func (s *GetDesktopGroupDetailRequest) SetRegionId(v string) *GetDesktopGroupDetailRequest {
	s.RegionId = &v
	return s
}

type GetDesktopGroupDetailResponseBody struct {
	// Details of the desktop group.
	Desktops *GetDesktopGroupDetailResponseBodyDesktops `json:"Desktops,omitempty" xml:"Desktops,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetDesktopGroupDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDesktopGroupDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetDesktopGroupDetailResponseBody) SetDesktops(v *GetDesktopGroupDetailResponseBodyDesktops) *GetDesktopGroupDetailResponseBody {
	s.Desktops = v
	return s
}

func (s *GetDesktopGroupDetailResponseBody) SetRequestId(v string) *GetDesktopGroupDetailResponseBody {
	s.RequestId = &v
	return s
}

type GetDesktopGroupDetailResponseBodyDesktops struct {
	// Indicates whether the auto scale-out feature is enabled for the desktop group.
	AllowAutoSetup *int32 `json:"AllowAutoSetup,omitempty" xml:"AllowAutoSetup,omitempty"`
	// The number of reserved cloud desktops in the desktop group.
	AllowBufferCount *int32 `json:"AllowBufferCount,omitempty" xml:"AllowBufferCount,omitempty"`
	// The number of sessions that are allowed for each cloud desktop in the multi-session desktop group.
	BindAmount *int32 `json:"BindAmount,omitempty" xml:"BindAmount,omitempty"`
	// The number of purchased cloud desktops. Valid values: 0 to 200.
	BuyDesktopsCount *int32 `json:"BuyDesktopsCount,omitempty" xml:"BuyDesktopsCount,omitempty"`
	// The remarks on the desktop group.
	Comments *string `json:"Comments,omitempty" xml:"Comments,omitempty"`
	// The maximum period of time for which a session is effective. Unit: milliseconds.
	ConnectDuration *int64 `json:"ConnectDuration,omitempty" xml:"ConnectDuration,omitempty"`
	// The number of vCPUs.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The time when the desktop group was created. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The user who creates the desktop group.
	Creator *string `json:"Creator,omitempty" xml:"Creator,omitempty"`
	// The category of the data disk.
	DataDiskCategory *string `json:"DataDiskCategory,omitempty" xml:"DataDiskCategory,omitempty"`
	// The size of the data disk.
	DataDiskSize *string `json:"DataDiskSize,omitempty" xml:"DataDiskSize,omitempty"`
	// The ID of the desktop group.
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// The name of the desktop group.
	DesktopGroupName *string `json:"DesktopGroupName,omitempty" xml:"DesktopGroupName,omitempty"`
	// The ID of the directory, which is the same as the ID of the workspace.
	DirectoryId *string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	// The type of the directory.
	DirectoryType *string `json:"DirectoryType,omitempty" xml:"DirectoryType,omitempty"`
	// The time when the desktop group expires.
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The number of vGPUs.
	GpuCount *float32 `json:"GpuCount,omitempty" xml:"GpuCount,omitempty"`
	// The GPU specifications.
	GpuSpec *string `json:"GpuSpec,omitempty" xml:"GpuSpec,omitempty"`
	// The maximum period of time for which a session remains idle. Unit: milliseconds.
	IdleDisconnectDuration *int64 `json:"IdleDisconnectDuration,omitempty" xml:"IdleDisconnectDuration,omitempty"`
	// The ID of the image.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The retention period of a cloud desktop in the desktop group after the cloud desktop is disconnected. Unit: milliseconds.
	KeepDuration *int64 `json:"KeepDuration,omitempty" xml:"KeepDuration,omitempty"`
	// The load balancing policy for the multi-session desktop group.
	//
	// Valid values:
	//
	// *   0
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     depth first
	//
	//     <!-- -->
	//
	//     .
	//
	// *   1
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     breadth first
	//
	//     <!-- -->
	//
	//     .
	LoadPolicy *int32 `json:"LoadPolicy,omitempty" xml:"LoadPolicy,omitempty"`
	// The maximum number of cloud desktops that the desktop group can contain.
	MaxDesktopsCount *int32 `json:"MaxDesktopsCount,omitempty" xml:"MaxDesktopsCount,omitempty"`
	// The memory size.
	Memory *int64 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The minimum number of cloud desktops that the desktop group must retain.
	MinDesktopsCount *int32 `json:"MinDesktopsCount,omitempty" xml:"MinDesktopsCount,omitempty"`
	// The ID of the Apsara File Storage NAS (NAS) file system.
	NasFileSystemID *string `json:"NasFileSystemID,omitempty" xml:"NasFileSystemID,omitempty"`
	// The name of the NAS file system.
	NasFileSystemName *string `json:"NasFileSystemName,omitempty" xml:"NasFileSystemName,omitempty"`
	// The ID of the workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The name of the workspace.
	OfficeSiteName *string `json:"OfficeSiteName,omitempty" xml:"OfficeSiteName,omitempty"`
	// The type of the workspace.
	OfficeSiteType *string `json:"OfficeSiteType,omitempty" xml:"OfficeSiteType,omitempty"`
	// The ID of the desktop template.
	OwnBundleId *string `json:"OwnBundleId,omitempty" xml:"OwnBundleId,omitempty"`
	// The name of the desktop template.
	OwnBundleName *string `json:"OwnBundleName,omitempty" xml:"OwnBundleName,omitempty"`
	// The type of the desktop group.
	//
	// Valid values:
	//
	// *   0
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     personal desktop group
	//
	//     <!-- -->
	//
	//     .
	//
	// *   1
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     shared desktop group (multi-session)
	//
	//     <!-- -->
	//
	//     .
	OwnType *int32 `json:"OwnType,omitempty" xml:"OwnType,omitempty"`
	// The billing method.
	//
	// Valid values:
	//
	// *   PostPaid
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     pay-as-you-go
	//
	//     <!-- -->
	//
	//     .
	//
	// *   PrePaid
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     subscription
	//
	//     <!-- -->
	//
	//     .
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The ID of the security policy group.
	PolicyGroupId *string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty"`
	// The IDs of the policies with which the desktop group is associated.
	PolicyGroupIds []*string `json:"PolicyGroupIds,omitempty" xml:"PolicyGroupIds,omitempty" type:"Repeated"`
	// The name of the security policy group.
	PolicyGroupName *string `json:"PolicyGroupName,omitempty" xml:"PolicyGroupName,omitempty"`
	// The names of the policies.
	PolicyGroupNames []*string `json:"PolicyGroupNames,omitempty" xml:"PolicyGroupNames,omitempty" type:"Repeated"`
	// Indicates whether data roaming is enabled.
	ProfileFollowSwitch *bool `json:"ProfileFollowSwitch,omitempty" xml:"ProfileFollowSwitch,omitempty"`
	// The session usage threshold for the multi-session desktop group that has an auto scaling policy in effect.
	RatioThreshold *float32 `json:"RatioThreshold,omitempty" xml:"RatioThreshold,omitempty"`
	// The type of the resource. Only Elastic Compute Service (ECS) instances are supported.
	//
	// Valid values:
	//
	// *   0
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     ECS
	//
	//     <!-- -->
	//
	//     .
	ResType *int32 `json:"ResType,omitempty" xml:"ResType,omitempty"`
	// Indicates which type of disk is reset for cloud desktops in the desktop group.
	//
	// Valid values:
	//
	// *   0
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     No disks are reset
	//
	//     <!-- -->
	//
	//     .
	//
	// *   1
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     Only the system disk is reset
	//
	//     <!-- -->
	//
	//     .
	//
	// *   2
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     Only the data disk is reset
	//
	//     <!-- -->
	//
	//     .
	//
	// *   3
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     Both the system disk and data disk are reset
	//
	//     <!-- -->
	//
	//     .
	ResetType *int32 `json:"ResetType,omitempty" xml:"ResetType,omitempty"`
	// Details of the scheduled tasks.
	ScaleTimerInfos []*GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos `json:"ScaleTimerInfos,omitempty" xml:"ScaleTimerInfos,omitempty" type:"Repeated"`
	// The status of the desktop group.
	//
	// Valid values:
	//
	// *   0
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The desktop group is unpaid
	//
	//     <!-- -->
	//
	//     .
	//
	// *   1
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The desktop group is paid
	//
	//     <!-- -->
	//
	//     .
	//
	// *   2
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The desktop group has an overdue payment or expired
	//
	//     <!-- -->
	//
	//     .
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The period of time before an idle cloud desktop enters the Stopped state. When the specified period of time is reached, the idle cloud desktop automatically stops. If an end user connects to a stopped cloud desktop, the cloud desktop automatically starts. Unit: milliseconds.
	StopDuration *int64 `json:"StopDuration,omitempty" xml:"StopDuration,omitempty"`
	// The category of the system disk.
	SystemDiskCategory *string `json:"SystemDiskCategory,omitempty" xml:"SystemDiskCategory,omitempty"`
	// The size of the system disk.
	SystemDiskSize *int32 `json:"SystemDiskSize,omitempty" xml:"SystemDiskSize,omitempty"`
	// The list of scheduled points in time for desktop group tasks.
	TimerInfos []*GetDesktopGroupDetailResponseBodyDesktopsTimerInfos `json:"TimerInfos,omitempty" xml:"TimerInfos,omitempty" type:"Repeated"`
	// The information about the scheduling policy.
	TimingStrategyInfo *string `json:"TimingStrategyInfo,omitempty" xml:"TimingStrategyInfo,omitempty"`
	// The version number of the desktop group.
	Version *int64 `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s GetDesktopGroupDetailResponseBodyDesktops) String() string {
	return tea.Prettify(s)
}

func (s GetDesktopGroupDetailResponseBodyDesktops) GoString() string {
	return s.String()
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetAllowAutoSetup(v int32) *GetDesktopGroupDetailResponseBodyDesktops {
	s.AllowAutoSetup = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetAllowBufferCount(v int32) *GetDesktopGroupDetailResponseBodyDesktops {
	s.AllowBufferCount = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetBindAmount(v int32) *GetDesktopGroupDetailResponseBodyDesktops {
	s.BindAmount = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetBuyDesktopsCount(v int32) *GetDesktopGroupDetailResponseBodyDesktops {
	s.BuyDesktopsCount = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetComments(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.Comments = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetConnectDuration(v int64) *GetDesktopGroupDetailResponseBodyDesktops {
	s.ConnectDuration = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetCpu(v int32) *GetDesktopGroupDetailResponseBodyDesktops {
	s.Cpu = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetCreationTime(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.CreationTime = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetCreator(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.Creator = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetDataDiskCategory(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.DataDiskCategory = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetDataDiskSize(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.DataDiskSize = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetDesktopGroupId(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.DesktopGroupId = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetDesktopGroupName(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.DesktopGroupName = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetDirectoryId(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.DirectoryId = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetDirectoryType(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.DirectoryType = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetExpiredTime(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.ExpiredTime = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetGpuCount(v float32) *GetDesktopGroupDetailResponseBodyDesktops {
	s.GpuCount = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetGpuSpec(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.GpuSpec = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetIdleDisconnectDuration(v int64) *GetDesktopGroupDetailResponseBodyDesktops {
	s.IdleDisconnectDuration = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetImageId(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.ImageId = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetKeepDuration(v int64) *GetDesktopGroupDetailResponseBodyDesktops {
	s.KeepDuration = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetLoadPolicy(v int32) *GetDesktopGroupDetailResponseBodyDesktops {
	s.LoadPolicy = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetMaxDesktopsCount(v int32) *GetDesktopGroupDetailResponseBodyDesktops {
	s.MaxDesktopsCount = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetMemory(v int64) *GetDesktopGroupDetailResponseBodyDesktops {
	s.Memory = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetMinDesktopsCount(v int32) *GetDesktopGroupDetailResponseBodyDesktops {
	s.MinDesktopsCount = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetNasFileSystemID(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.NasFileSystemID = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetNasFileSystemName(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.NasFileSystemName = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetOfficeSiteId(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.OfficeSiteId = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetOfficeSiteName(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.OfficeSiteName = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetOfficeSiteType(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.OfficeSiteType = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetOwnBundleId(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.OwnBundleId = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetOwnBundleName(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.OwnBundleName = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetOwnType(v int32) *GetDesktopGroupDetailResponseBodyDesktops {
	s.OwnType = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetPayType(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.PayType = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetPolicyGroupId(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.PolicyGroupId = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetPolicyGroupIds(v []*string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.PolicyGroupIds = v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetPolicyGroupName(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.PolicyGroupName = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetPolicyGroupNames(v []*string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.PolicyGroupNames = v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetProfileFollowSwitch(v bool) *GetDesktopGroupDetailResponseBodyDesktops {
	s.ProfileFollowSwitch = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetRatioThreshold(v float32) *GetDesktopGroupDetailResponseBodyDesktops {
	s.RatioThreshold = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetResType(v int32) *GetDesktopGroupDetailResponseBodyDesktops {
	s.ResType = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetResetType(v int32) *GetDesktopGroupDetailResponseBodyDesktops {
	s.ResetType = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetScaleTimerInfos(v []*GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos) *GetDesktopGroupDetailResponseBodyDesktops {
	s.ScaleTimerInfos = v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetStatus(v int32) *GetDesktopGroupDetailResponseBodyDesktops {
	s.Status = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetStopDuration(v int64) *GetDesktopGroupDetailResponseBodyDesktops {
	s.StopDuration = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetSystemDiskCategory(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.SystemDiskCategory = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetSystemDiskSize(v int32) *GetDesktopGroupDetailResponseBodyDesktops {
	s.SystemDiskSize = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetTimerInfos(v []*GetDesktopGroupDetailResponseBodyDesktopsTimerInfos) *GetDesktopGroupDetailResponseBodyDesktops {
	s.TimerInfos = v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetTimingStrategyInfo(v string) *GetDesktopGroupDetailResponseBodyDesktops {
	s.TimingStrategyInfo = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktops) SetVersion(v int64) *GetDesktopGroupDetailResponseBodyDesktops {
	s.Version = &v
	return s
}

type GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos struct {
	// The number of purchased cloud desktops during the scaling event. Valid values: 0 to 200.
	BuyResAmount *int32 `json:"BuyResAmount,omitempty" xml:"BuyResAmount,omitempty"`
	// The type of the CRON expression that is specified for the scheduled task.
	Cron *string `json:"Cron,omitempty" xml:"Cron,omitempty"`
	// The retention period of a cloud desktop in the desktop group after the cloud desktop is disconnected. Unit: milliseconds.
	KeepDuration *int64 `json:"KeepDuration,omitempty" xml:"KeepDuration,omitempty"`
	// The load balancing policy for the multi-session desktop group.
	LoadPolicy *int32 `json:"LoadPolicy,omitempty" xml:"LoadPolicy,omitempty"`
	// The maximum number of cloud desktops that the system can scale. Valid values: 0 to 200.
	MaxResAmount *int32 `json:"MaxResAmount,omitempty" xml:"MaxResAmount,omitempty"`
	// The minimum number of cloud desktops that the system must scale. Valid values: 0 to 200.
	MinResAmount *int32 `json:"MinResAmount,omitempty" xml:"MinResAmount,omitempty"`
	// The threshold for the ratio of connected sessions. This parameter is the condition that triggers auto scaling in a multi-session desktop group. `Ratio of connected sessions = Number of connected sessions/(Total number of cloud desktops  Maximum number of sessions allowed for each cloud desktop)  100%`. If the specified threshold is reached, new cloud desktops are automatically created. If the specified threshold is not reached, idle cloud desktops are released.
	RatioThreshold *float32 `json:"RatioThreshold,omitempty" xml:"RatioThreshold,omitempty"`
	// The type of the scheduled task.
	//
	// Valid values:
	//
	// *   drop
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     decline policy
	//
	//     <!-- -->
	//
	//     .
	//
	// *   normal
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     normal policy
	//
	//     <!-- -->
	//
	//     .
	//
	// *   peak
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     peak hour policy
	//
	//     <!-- -->
	//
	//     .
	//
	// *   rise
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     rise policy
	//
	//     <!-- -->
	//
	//     .
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos) String() string {
	return tea.Prettify(s)
}

func (s GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos) GoString() string {
	return s.String()
}

func (s *GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos) SetBuyResAmount(v int32) *GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos {
	s.BuyResAmount = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos) SetCron(v string) *GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos {
	s.Cron = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos) SetKeepDuration(v int64) *GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos {
	s.KeepDuration = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos) SetLoadPolicy(v int32) *GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos {
	s.LoadPolicy = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos) SetMaxResAmount(v int32) *GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos {
	s.MaxResAmount = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos) SetMinResAmount(v int32) *GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos {
	s.MinResAmount = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos) SetRatioThreshold(v float32) *GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos {
	s.RatioThreshold = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos) SetType(v string) *GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos {
	s.Type = &v
	return s
}

type GetDesktopGroupDetailResponseBodyDesktopsTimerInfos struct {
	// The CRON expression of the scheduled task.
	CronExpression *string `json:"CronExpression,omitempty" xml:"CronExpression,omitempty"`
	// Indicates whether the scheduled task is forcibly executed.
	Forced *bool `json:"Forced,omitempty" xml:"Forced,omitempty"`
	// The status of the scheduled task.
	//
	// Valid values:
	//
	// *   1
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The scheduled task is enabled
	//
	//     <!-- -->
	//
	//     .
	//
	// *   2
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The scheduled task is disabled
	//
	//     <!-- -->
	//
	//     .
	//
	// *   3
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     The scheduled task is deleted
	//
	//     <!-- -->
	//
	//     .
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the scheduled task.
	//
	// Valid values:
	//
	// *   1
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     scheduled reset
	//
	//     <!-- -->
	//
	//     .
	//
	// *   2
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     scheduled startup
	//
	//     <!-- -->
	//
	//     .
	//
	// *   3
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     scheduled stop
	//
	//     <!-- -->
	//
	//     .
	//
	// *   4
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     scheduled restart
	//
	//     <!-- -->
	//
	//     .
	TimerType *int32 `json:"TimerType,omitempty" xml:"TimerType,omitempty"`
}

func (s GetDesktopGroupDetailResponseBodyDesktopsTimerInfos) String() string {
	return tea.Prettify(s)
}

func (s GetDesktopGroupDetailResponseBodyDesktopsTimerInfos) GoString() string {
	return s.String()
}

func (s *GetDesktopGroupDetailResponseBodyDesktopsTimerInfos) SetCronExpression(v string) *GetDesktopGroupDetailResponseBodyDesktopsTimerInfos {
	s.CronExpression = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktopsTimerInfos) SetForced(v bool) *GetDesktopGroupDetailResponseBodyDesktopsTimerInfos {
	s.Forced = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktopsTimerInfos) SetStatus(v int32) *GetDesktopGroupDetailResponseBodyDesktopsTimerInfos {
	s.Status = &v
	return s
}

func (s *GetDesktopGroupDetailResponseBodyDesktopsTimerInfos) SetTimerType(v int32) *GetDesktopGroupDetailResponseBodyDesktopsTimerInfos {
	s.TimerType = &v
	return s
}

type GetDesktopGroupDetailResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDesktopGroupDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDesktopGroupDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDesktopGroupDetailResponse) GoString() string {
	return s.String()
}

func (s *GetDesktopGroupDetailResponse) SetHeaders(v map[string]*string) *GetDesktopGroupDetailResponse {
	s.Headers = v
	return s
}

func (s *GetDesktopGroupDetailResponse) SetStatusCode(v int32) *GetDesktopGroupDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDesktopGroupDetailResponse) SetBody(v *GetDesktopGroupDetailResponseBody) *GetDesktopGroupDetailResponse {
	s.Body = v
	return s
}

type GetOfficeSiteSsoStatusRequest struct {
	// The workspace ID.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetOfficeSiteSsoStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s GetOfficeSiteSsoStatusRequest) GoString() string {
	return s.String()
}

func (s *GetOfficeSiteSsoStatusRequest) SetOfficeSiteId(v string) *GetOfficeSiteSsoStatusRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *GetOfficeSiteSsoStatusRequest) SetRegionId(v string) *GetOfficeSiteSsoStatusRequest {
	s.RegionId = &v
	return s
}

type GetOfficeSiteSsoStatusResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether SSO is enabled.
	SsoStatus *bool `json:"SsoStatus,omitempty" xml:"SsoStatus,omitempty"`
}

func (s GetOfficeSiteSsoStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetOfficeSiteSsoStatusResponseBody) GoString() string {
	return s.String()
}

func (s *GetOfficeSiteSsoStatusResponseBody) SetRequestId(v string) *GetOfficeSiteSsoStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetOfficeSiteSsoStatusResponseBody) SetSsoStatus(v bool) *GetOfficeSiteSsoStatusResponseBody {
	s.SsoStatus = &v
	return s
}

type GetOfficeSiteSsoStatusResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetOfficeSiteSsoStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetOfficeSiteSsoStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s GetOfficeSiteSsoStatusResponse) GoString() string {
	return s.String()
}

func (s *GetOfficeSiteSsoStatusResponse) SetHeaders(v map[string]*string) *GetOfficeSiteSsoStatusResponse {
	s.Headers = v
	return s
}

func (s *GetOfficeSiteSsoStatusResponse) SetStatusCode(v int32) *GetOfficeSiteSsoStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *GetOfficeSiteSsoStatusResponse) SetBody(v *GetOfficeSiteSsoStatusResponseBody) *GetOfficeSiteSsoStatusResponse {
	s.Body = v
	return s
}

type GetSpMetadataRequest struct {
	// The workspace ID. This parameter is the same as `OfficeSiteId`. We recommend that you use `OfficeSiteId` to replace `DirectoryId`. You can specify only `DirectoryId` or `OfficeSiteId`.
	DirectoryId *string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	// The workspace ID.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetSpMetadataRequest) String() string {
	return tea.Prettify(s)
}

func (s GetSpMetadataRequest) GoString() string {
	return s.String()
}

func (s *GetSpMetadataRequest) SetDirectoryId(v string) *GetSpMetadataRequest {
	s.DirectoryId = &v
	return s
}

func (s *GetSpMetadataRequest) SetOfficeSiteId(v string) *GetSpMetadataRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *GetSpMetadataRequest) SetRegionId(v string) *GetSpMetadataRequest {
	s.RegionId = &v
	return s
}

type GetSpMetadataResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The metadata of the SP.
	SpMetadata *string `json:"SpMetadata,omitempty" xml:"SpMetadata,omitempty"`
}

func (s GetSpMetadataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetSpMetadataResponseBody) GoString() string {
	return s.String()
}

func (s *GetSpMetadataResponseBody) SetRequestId(v string) *GetSpMetadataResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetSpMetadataResponseBody) SetSpMetadata(v string) *GetSpMetadataResponseBody {
	s.SpMetadata = &v
	return s
}

type GetSpMetadataResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetSpMetadataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetSpMetadataResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSpMetadataResponse) GoString() string {
	return s.String()
}

func (s *GetSpMetadataResponse) SetHeaders(v map[string]*string) *GetSpMetadataResponse {
	s.Headers = v
	return s
}

func (s *GetSpMetadataResponse) SetStatusCode(v int32) *GetSpMetadataResponse {
	s.StatusCode = &v
	return s
}

func (s *GetSpMetadataResponse) SetBody(v *GetSpMetadataResponseBody) *GetSpMetadataResponse {
	s.Body = v
	return s
}

type HibernateDesktopsRequest struct {
	// The IDs of the cloud desktops. You can specify 1 to 20 cloud desktop IDs.
	DesktopId []*string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty" type:"Repeated"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s HibernateDesktopsRequest) String() string {
	return tea.Prettify(s)
}

func (s HibernateDesktopsRequest) GoString() string {
	return s.String()
}

func (s *HibernateDesktopsRequest) SetDesktopId(v []*string) *HibernateDesktopsRequest {
	s.DesktopId = v
	return s
}

func (s *HibernateDesktopsRequest) SetRegionId(v string) *HibernateDesktopsRequest {
	s.RegionId = &v
	return s
}

type HibernateDesktopsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s HibernateDesktopsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s HibernateDesktopsResponseBody) GoString() string {
	return s.String()
}

func (s *HibernateDesktopsResponseBody) SetRequestId(v string) *HibernateDesktopsResponseBody {
	s.RequestId = &v
	return s
}

type HibernateDesktopsResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *HibernateDesktopsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s HibernateDesktopsResponse) String() string {
	return tea.Prettify(s)
}

func (s HibernateDesktopsResponse) GoString() string {
	return s.String()
}

func (s *HibernateDesktopsResponse) SetHeaders(v map[string]*string) *HibernateDesktopsResponse {
	s.Headers = v
	return s
}

func (s *HibernateDesktopsResponse) SetStatusCode(v int32) *HibernateDesktopsResponse {
	s.StatusCode = &v
	return s
}

func (s *HibernateDesktopsResponse) SetBody(v *HibernateDesktopsResponseBody) *HibernateDesktopsResponse {
	s.Body = v
	return s
}

type ListCdsFilesRequest struct {
	// The ID of the cloud disk.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	// The ID of the user to whom the cloud disk is allocated.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The IDs of the files to be queried.
	FileIds []*string `json:"FileIds,omitempty" xml:"FileIds,omitempty" type:"Repeated"`
	GroupId *string   `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The number of entries to return on each page. Default value: 100.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token used for the next query. If this parameter is empty, all results are returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The sorting method of the files.
	//
	// Valid values:
	//
	// *   CreateTimeDesc
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     sorts files in descending order based on the time when they are created.
	//
	//     <!-- -->
	//
	// *   ModifiedTimeAsc
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     sorts files in ascending order based on the time when they are modified.
	//
	//     <!-- -->
	//
	// *   NameDesc
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     sorts files in descending order based on their names.
	//
	//     <!-- -->
	//
	// *   SizeAsc
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     sorts files in ascending order based on their sizes.
	//
	//     <!-- -->
	//
	// *   ModifiedTimeDesc
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     sorts files in descending order based on the time when they are modified.
	//
	//     <!-- -->
	//
	// *   CreateTimeAsc
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     sorts files in ascending order based on the time when they are created.
	//
	//     <!-- -->
	//
	// *   SizeDesc
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     sorts files in descending order based on their sizes.
	//
	//     <!-- -->
	//
	// *   NameAsc
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     sorts files in ascending order based on their names.
	//
	//     <!-- -->
	OrderType *string `json:"OrderType,omitempty" xml:"OrderType,omitempty"`
	// The ID of the parent file.
	ParentFileId *string `json:"ParentFileId,omitempty" xml:"ParentFileId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The file status.
	//
	// Valid values:
	//
	// *   available
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     returns only normal files.
	//
	//     <!-- -->
	//
	// *   uploading
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     returns only the files that are being uploaded.
	//
	//     <!-- -->
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListCdsFilesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListCdsFilesRequest) GoString() string {
	return s.String()
}

func (s *ListCdsFilesRequest) SetCdsId(v string) *ListCdsFilesRequest {
	s.CdsId = &v
	return s
}

func (s *ListCdsFilesRequest) SetEndUserId(v string) *ListCdsFilesRequest {
	s.EndUserId = &v
	return s
}

func (s *ListCdsFilesRequest) SetFileIds(v []*string) *ListCdsFilesRequest {
	s.FileIds = v
	return s
}

func (s *ListCdsFilesRequest) SetGroupId(v string) *ListCdsFilesRequest {
	s.GroupId = &v
	return s
}

func (s *ListCdsFilesRequest) SetMaxResults(v int32) *ListCdsFilesRequest {
	s.MaxResults = &v
	return s
}

func (s *ListCdsFilesRequest) SetNextToken(v string) *ListCdsFilesRequest {
	s.NextToken = &v
	return s
}

func (s *ListCdsFilesRequest) SetOrderType(v string) *ListCdsFilesRequest {
	s.OrderType = &v
	return s
}

func (s *ListCdsFilesRequest) SetParentFileId(v string) *ListCdsFilesRequest {
	s.ParentFileId = &v
	return s
}

func (s *ListCdsFilesRequest) SetRegionId(v string) *ListCdsFilesRequest {
	s.RegionId = &v
	return s
}

func (s *ListCdsFilesRequest) SetStatus(v string) *ListCdsFilesRequest {
	s.Status = &v
	return s
}

type ListCdsFilesShrinkRequest struct {
	// The ID of the cloud disk.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	// The ID of the user to whom the cloud disk is allocated.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The IDs of the files to be queried.
	FileIdsShrink *string `json:"FileIds,omitempty" xml:"FileIds,omitempty"`
	GroupId       *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The number of entries to return on each page. Default value: 100.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token used for the next query. If this parameter is empty, all results are returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The sorting method of the files.
	//
	// Valid values:
	//
	// *   CreateTimeDesc
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     sorts files in descending order based on the time when they are created.
	//
	//     <!-- -->
	//
	// *   ModifiedTimeAsc
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     sorts files in ascending order based on the time when they are modified.
	//
	//     <!-- -->
	//
	// *   NameDesc
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     sorts files in descending order based on their names.
	//
	//     <!-- -->
	//
	// *   SizeAsc
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     sorts files in ascending order based on their sizes.
	//
	//     <!-- -->
	//
	// *   ModifiedTimeDesc
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     sorts files in descending order based on the time when they are modified.
	//
	//     <!-- -->
	//
	// *   CreateTimeAsc
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     sorts files in ascending order based on the time when they are created.
	//
	//     <!-- -->
	//
	// *   SizeDesc
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     sorts files in descending order based on their sizes.
	//
	//     <!-- -->
	//
	// *   NameAsc
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     sorts files in ascending order based on their names.
	//
	//     <!-- -->
	OrderType *string `json:"OrderType,omitempty" xml:"OrderType,omitempty"`
	// The ID of the parent file.
	ParentFileId *string `json:"ParentFileId,omitempty" xml:"ParentFileId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The file status.
	//
	// Valid values:
	//
	// *   available
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     returns only normal files.
	//
	//     <!-- -->
	//
	// *   uploading
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     returns only the files that are being uploaded.
	//
	//     <!-- -->
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListCdsFilesShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListCdsFilesShrinkRequest) GoString() string {
	return s.String()
}

func (s *ListCdsFilesShrinkRequest) SetCdsId(v string) *ListCdsFilesShrinkRequest {
	s.CdsId = &v
	return s
}

func (s *ListCdsFilesShrinkRequest) SetEndUserId(v string) *ListCdsFilesShrinkRequest {
	s.EndUserId = &v
	return s
}

func (s *ListCdsFilesShrinkRequest) SetFileIdsShrink(v string) *ListCdsFilesShrinkRequest {
	s.FileIdsShrink = &v
	return s
}

func (s *ListCdsFilesShrinkRequest) SetGroupId(v string) *ListCdsFilesShrinkRequest {
	s.GroupId = &v
	return s
}

func (s *ListCdsFilesShrinkRequest) SetMaxResults(v int32) *ListCdsFilesShrinkRequest {
	s.MaxResults = &v
	return s
}

func (s *ListCdsFilesShrinkRequest) SetNextToken(v string) *ListCdsFilesShrinkRequest {
	s.NextToken = &v
	return s
}

func (s *ListCdsFilesShrinkRequest) SetOrderType(v string) *ListCdsFilesShrinkRequest {
	s.OrderType = &v
	return s
}

func (s *ListCdsFilesShrinkRequest) SetParentFileId(v string) *ListCdsFilesShrinkRequest {
	s.ParentFileId = &v
	return s
}

func (s *ListCdsFilesShrinkRequest) SetRegionId(v string) *ListCdsFilesShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *ListCdsFilesShrinkRequest) SetStatus(v string) *ListCdsFilesShrinkRequest {
	s.Status = &v
	return s
}

type ListCdsFilesResponseBody struct {
	// The result of the operation. A value of success indicates that the operation is successful. If the operation failed, an error message is returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The total number of entries.
	Count *string `json:"Count,omitempty" xml:"Count,omitempty"`
	// The files.
	FileModels []*ListCdsFilesResponseBodyFileModels `json:"FileModels,omitempty" xml:"FileModels,omitempty" type:"Repeated"`
	// The error message returned if the request failed. This parameter is empty if the value of Code is success.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The token used for the next query. If this parameter is empty, all results have been returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID. An ID is the unique identifier of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   <!-- -->
	//
	//     false
	//
	//     <!-- -->
	//
	//     <!-- -->
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListCdsFilesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListCdsFilesResponseBody) GoString() string {
	return s.String()
}

func (s *ListCdsFilesResponseBody) SetCode(v string) *ListCdsFilesResponseBody {
	s.Code = &v
	return s
}

func (s *ListCdsFilesResponseBody) SetCount(v string) *ListCdsFilesResponseBody {
	s.Count = &v
	return s
}

func (s *ListCdsFilesResponseBody) SetFileModels(v []*ListCdsFilesResponseBodyFileModels) *ListCdsFilesResponseBody {
	s.FileModels = v
	return s
}

func (s *ListCdsFilesResponseBody) SetMessage(v string) *ListCdsFilesResponseBody {
	s.Message = &v
	return s
}

func (s *ListCdsFilesResponseBody) SetNextToken(v string) *ListCdsFilesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListCdsFilesResponseBody) SetRequestId(v string) *ListCdsFilesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListCdsFilesResponseBody) SetSuccess(v bool) *ListCdsFilesResponseBody {
	s.Success = &v
	return s
}

type ListCdsFilesResponseBodyFileModels struct {
	// The file category. PDS categorizes files based on their suffixes and MIME types. The following major categories are included: doc, image, audio, and video.
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The content type of the file.
	ContentType *string `json:"ContentType,omitempty" xml:"ContentType,omitempty"`
	// The time when the file was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The file creator.
	Creator *string `json:"Creator,omitempty" xml:"Creator,omitempty"`
	// The file description.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The URL that is used to download the file. The download URL is valid for only 15 minutes. If the URL is expired, you can call the GetFile operation to obtain the file.
	DownloadUrl *string `json:"DownloadUrl,omitempty" xml:"DownloadUrl,omitempty"`
	// The filename extension.
	FileExtension *string `json:"FileExtension,omitempty" xml:"FileExtension,omitempty"`
	// The file ID.
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The file path.
	FilePath *string `json:"FilePath,omitempty" xml:"FilePath,omitempty"`
	// The file type.
	FileType *string `json:"FileType,omitempty" xml:"FileType,omitempty"`
	// The MD5 value of the file.
	Md5 *string `json:"Md5,omitempty" xml:"Md5,omitempty"`
	// The time when the file was last modified.
	ModifiedTime *string `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	// The user who modified the file.
	Modifier *string `json:"Modifier,omitempty" xml:"Modifier,omitempty"`
	// The file name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The time when the file was last opened.
	OpenTime *string `json:"OpenTime,omitempty" xml:"OpenTime,omitempty"`
	// The timestamp that indicates the time when the file was last opened.
	OpenTimeStamp *int64 `json:"OpenTimeStamp,omitempty" xml:"OpenTimeStamp,omitempty"`
	// The ID of the parent folder.
	ParentId *string `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The region ID You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The SHA 1 file.
	Sha1 *string `json:"Sha1,omitempty" xml:"Sha1,omitempty"`
	// The file size. Unit: bits.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The URL of the thumbnail.
	Thumbnail *string `json:"Thumbnail,omitempty" xml:"Thumbnail,omitempty"`
}

func (s ListCdsFilesResponseBodyFileModels) String() string {
	return tea.Prettify(s)
}

func (s ListCdsFilesResponseBodyFileModels) GoString() string {
	return s.String()
}

func (s *ListCdsFilesResponseBodyFileModels) SetCategory(v string) *ListCdsFilesResponseBodyFileModels {
	s.Category = &v
	return s
}

func (s *ListCdsFilesResponseBodyFileModels) SetContentType(v string) *ListCdsFilesResponseBodyFileModels {
	s.ContentType = &v
	return s
}

func (s *ListCdsFilesResponseBodyFileModels) SetCreateTime(v string) *ListCdsFilesResponseBodyFileModels {
	s.CreateTime = &v
	return s
}

func (s *ListCdsFilesResponseBodyFileModels) SetCreator(v string) *ListCdsFilesResponseBodyFileModels {
	s.Creator = &v
	return s
}

func (s *ListCdsFilesResponseBodyFileModels) SetDescription(v string) *ListCdsFilesResponseBodyFileModels {
	s.Description = &v
	return s
}

func (s *ListCdsFilesResponseBodyFileModels) SetDownloadUrl(v string) *ListCdsFilesResponseBodyFileModels {
	s.DownloadUrl = &v
	return s
}

func (s *ListCdsFilesResponseBodyFileModels) SetFileExtension(v string) *ListCdsFilesResponseBodyFileModels {
	s.FileExtension = &v
	return s
}

func (s *ListCdsFilesResponseBodyFileModels) SetFileId(v string) *ListCdsFilesResponseBodyFileModels {
	s.FileId = &v
	return s
}

func (s *ListCdsFilesResponseBodyFileModels) SetFilePath(v string) *ListCdsFilesResponseBodyFileModels {
	s.FilePath = &v
	return s
}

func (s *ListCdsFilesResponseBodyFileModels) SetFileType(v string) *ListCdsFilesResponseBodyFileModels {
	s.FileType = &v
	return s
}

func (s *ListCdsFilesResponseBodyFileModels) SetMd5(v string) *ListCdsFilesResponseBodyFileModels {
	s.Md5 = &v
	return s
}

func (s *ListCdsFilesResponseBodyFileModels) SetModifiedTime(v string) *ListCdsFilesResponseBodyFileModels {
	s.ModifiedTime = &v
	return s
}

func (s *ListCdsFilesResponseBodyFileModels) SetModifier(v string) *ListCdsFilesResponseBodyFileModels {
	s.Modifier = &v
	return s
}

func (s *ListCdsFilesResponseBodyFileModels) SetName(v string) *ListCdsFilesResponseBodyFileModels {
	s.Name = &v
	return s
}

func (s *ListCdsFilesResponseBodyFileModels) SetOpenTime(v string) *ListCdsFilesResponseBodyFileModels {
	s.OpenTime = &v
	return s
}

func (s *ListCdsFilesResponseBodyFileModels) SetOpenTimeStamp(v int64) *ListCdsFilesResponseBodyFileModels {
	s.OpenTimeStamp = &v
	return s
}

func (s *ListCdsFilesResponseBodyFileModels) SetParentId(v string) *ListCdsFilesResponseBodyFileModels {
	s.ParentId = &v
	return s
}

func (s *ListCdsFilesResponseBodyFileModels) SetRegionId(v string) *ListCdsFilesResponseBodyFileModels {
	s.RegionId = &v
	return s
}

func (s *ListCdsFilesResponseBodyFileModels) SetSha1(v string) *ListCdsFilesResponseBodyFileModels {
	s.Sha1 = &v
	return s
}

func (s *ListCdsFilesResponseBodyFileModels) SetSize(v int64) *ListCdsFilesResponseBodyFileModels {
	s.Size = &v
	return s
}

func (s *ListCdsFilesResponseBodyFileModels) SetThumbnail(v string) *ListCdsFilesResponseBodyFileModels {
	s.Thumbnail = &v
	return s
}

type ListCdsFilesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListCdsFilesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListCdsFilesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListCdsFilesResponse) GoString() string {
	return s.String()
}

func (s *ListCdsFilesResponse) SetHeaders(v map[string]*string) *ListCdsFilesResponse {
	s.Headers = v
	return s
}

func (s *ListCdsFilesResponse) SetStatusCode(v int32) *ListCdsFilesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListCdsFilesResponse) SetBody(v *ListCdsFilesResponseBody) *ListCdsFilesResponse {
	s.Body = v
	return s
}

type ListDirectoryUsersRequest struct {
	// The ID of the AD directory.
	DirectoryId *string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	// The query string for fuzzy match. If you specify this parameter, the system returns all results that contain the string.
	Filter *string `json:"Filter,omitempty" xml:"Filter,omitempty"`
	// The number of entries to return on each page.
	//
	// Valid values: 1 to 100.
	//
	// Default value: 10.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token used to start the next query. If the value of this parameter is empty, all results are returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The organizational unit (OU) in the specified AD domain.
	OUPath *string `json:"OUPath,omitempty" xml:"OUPath,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListDirectoryUsersRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDirectoryUsersRequest) GoString() string {
	return s.String()
}

func (s *ListDirectoryUsersRequest) SetDirectoryId(v string) *ListDirectoryUsersRequest {
	s.DirectoryId = &v
	return s
}

func (s *ListDirectoryUsersRequest) SetFilter(v string) *ListDirectoryUsersRequest {
	s.Filter = &v
	return s
}

func (s *ListDirectoryUsersRequest) SetMaxResults(v int32) *ListDirectoryUsersRequest {
	s.MaxResults = &v
	return s
}

func (s *ListDirectoryUsersRequest) SetNextToken(v string) *ListDirectoryUsersRequest {
	s.NextToken = &v
	return s
}

func (s *ListDirectoryUsersRequest) SetOUPath(v string) *ListDirectoryUsersRequest {
	s.OUPath = &v
	return s
}

func (s *ListDirectoryUsersRequest) SetRegionId(v string) *ListDirectoryUsersRequest {
	s.RegionId = &v
	return s
}

type ListDirectoryUsersResponseBody struct {
	// The token used to start the next query. If the value of this parameter is empty, all results are returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The names of users corresponding to the AD directory. If the AD directory corresponds only to the `Administrator` and `Guest` users, the returned `Users` value is empty.
	Users []*ListDirectoryUsersResponseBodyUsers `json:"Users,omitempty" xml:"Users,omitempty" type:"Repeated"`
}

func (s ListDirectoryUsersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDirectoryUsersResponseBody) GoString() string {
	return s.String()
}

func (s *ListDirectoryUsersResponseBody) SetNextToken(v string) *ListDirectoryUsersResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListDirectoryUsersResponseBody) SetRequestId(v string) *ListDirectoryUsersResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDirectoryUsersResponseBody) SetUsers(v []*ListDirectoryUsersResponseBodyUsers) *ListDirectoryUsersResponseBody {
	s.Users = v
	return s
}

type ListDirectoryUsersResponseBodyUsers struct {
	// The display name.
	DisplayName *string `json:"DisplayName,omitempty" xml:"DisplayName,omitempty"`
	// The name of the user.
	EndUser *string `json:"EndUser,omitempty" xml:"EndUser,omitempty"`
}

func (s ListDirectoryUsersResponseBodyUsers) String() string {
	return tea.Prettify(s)
}

func (s ListDirectoryUsersResponseBodyUsers) GoString() string {
	return s.String()
}

func (s *ListDirectoryUsersResponseBodyUsers) SetDisplayName(v string) *ListDirectoryUsersResponseBodyUsers {
	s.DisplayName = &v
	return s
}

func (s *ListDirectoryUsersResponseBodyUsers) SetEndUser(v string) *ListDirectoryUsersResponseBodyUsers {
	s.EndUser = &v
	return s
}

type ListDirectoryUsersResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDirectoryUsersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDirectoryUsersResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDirectoryUsersResponse) GoString() string {
	return s.String()
}

func (s *ListDirectoryUsersResponse) SetHeaders(v map[string]*string) *ListDirectoryUsersResponse {
	s.Headers = v
	return s
}

func (s *ListDirectoryUsersResponse) SetStatusCode(v int32) *ListDirectoryUsersResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDirectoryUsersResponse) SetBody(v *ListDirectoryUsersResponseBody) *ListDirectoryUsersResponse {
	s.Body = v
	return s
}

type ListFilePermissionRequest struct {
	// The ID of the cloud disk.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	// The ID of the end user who uses the cloud disk.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The ID of the shared file.
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The group ID.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The region ID of the cloud disk. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListFilePermissionRequest) String() string {
	return tea.Prettify(s)
}

func (s ListFilePermissionRequest) GoString() string {
	return s.String()
}

func (s *ListFilePermissionRequest) SetCdsId(v string) *ListFilePermissionRequest {
	s.CdsId = &v
	return s
}

func (s *ListFilePermissionRequest) SetEndUserId(v string) *ListFilePermissionRequest {
	s.EndUserId = &v
	return s
}

func (s *ListFilePermissionRequest) SetFileId(v string) *ListFilePermissionRequest {
	s.FileId = &v
	return s
}

func (s *ListFilePermissionRequest) SetGroupId(v string) *ListFilePermissionRequest {
	s.GroupId = &v
	return s
}

func (s *ListFilePermissionRequest) SetRegionId(v string) *ListFilePermissionRequest {
	s.RegionId = &v
	return s
}

type ListFilePermissionResponseBody struct {
	// The permissions on the shared file.
	FilePermissions []*FilePermissionMember `json:"FilePermissions,omitempty" xml:"FilePermissions,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListFilePermissionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListFilePermissionResponseBody) GoString() string {
	return s.String()
}

func (s *ListFilePermissionResponseBody) SetFilePermissions(v []*FilePermissionMember) *ListFilePermissionResponseBody {
	s.FilePermissions = v
	return s
}

func (s *ListFilePermissionResponseBody) SetRequestId(v string) *ListFilePermissionResponseBody {
	s.RequestId = &v
	return s
}

type ListFilePermissionResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListFilePermissionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListFilePermissionResponse) String() string {
	return tea.Prettify(s)
}

func (s ListFilePermissionResponse) GoString() string {
	return s.String()
}

func (s *ListFilePermissionResponse) SetHeaders(v map[string]*string) *ListFilePermissionResponse {
	s.Headers = v
	return s
}

func (s *ListFilePermissionResponse) SetStatusCode(v int32) *ListFilePermissionResponse {
	s.StatusCode = &v
	return s
}

func (s *ListFilePermissionResponse) SetBody(v *ListFilePermissionResponseBody) *ListFilePermissionResponse {
	s.Body = v
	return s
}

type ListOfficeSiteOverviewRequest struct {
	// Specifies whether to refresh the cache.
	ForceRefresh *bool `json:"ForceRefresh,omitempty" xml:"ForceRefresh,omitempty"`
	// The number of entries to return on each page.
	//
	// *   Valid values: 1 to 100
	// *   Default value: 10
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the next query. If this is your first query or no next query is to be sent, skip this parameter. If a next query is to be sent, set the parameter to the value of NextToken that is returned from the last call.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// Details about the IDs of the workspaces. You can specify 1 to 100 workspace IDs.
	OfficeSiteId []*string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty" type:"Repeated"`
	// The query scope. Default value: 1.
	QueryRange *int32 `json:"QueryRange,omitempty" xml:"QueryRange,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListOfficeSiteOverviewRequest) String() string {
	return tea.Prettify(s)
}

func (s ListOfficeSiteOverviewRequest) GoString() string {
	return s.String()
}

func (s *ListOfficeSiteOverviewRequest) SetForceRefresh(v bool) *ListOfficeSiteOverviewRequest {
	s.ForceRefresh = &v
	return s
}

func (s *ListOfficeSiteOverviewRequest) SetMaxResults(v int32) *ListOfficeSiteOverviewRequest {
	s.MaxResults = &v
	return s
}

func (s *ListOfficeSiteOverviewRequest) SetNextToken(v string) *ListOfficeSiteOverviewRequest {
	s.NextToken = &v
	return s
}

func (s *ListOfficeSiteOverviewRequest) SetOfficeSiteId(v []*string) *ListOfficeSiteOverviewRequest {
	s.OfficeSiteId = v
	return s
}

func (s *ListOfficeSiteOverviewRequest) SetQueryRange(v int32) *ListOfficeSiteOverviewRequest {
	s.QueryRange = &v
	return s
}

func (s *ListOfficeSiteOverviewRequest) SetRegionId(v string) *ListOfficeSiteOverviewRequest {
	s.RegionId = &v
	return s
}

type ListOfficeSiteOverviewResponseBody struct {
	// The token that is used to start the next query. If this parameter is empty, all results are returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// Details of the workspaces.
	OfficeSiteOverviewResults []*ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults `json:"OfficeSiteOverviewResults,omitempty" xml:"OfficeSiteOverviewResults,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListOfficeSiteOverviewResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListOfficeSiteOverviewResponseBody) GoString() string {
	return s.String()
}

func (s *ListOfficeSiteOverviewResponseBody) SetNextToken(v string) *ListOfficeSiteOverviewResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListOfficeSiteOverviewResponseBody) SetOfficeSiteOverviewResults(v []*ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults) *ListOfficeSiteOverviewResponseBody {
	s.OfficeSiteOverviewResults = v
	return s
}

func (s *ListOfficeSiteOverviewResponseBody) SetRequestId(v string) *ListOfficeSiteOverviewResponseBody {
	s.RequestId = &v
	return s
}

type ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults struct {
	// The number of expired cloud desktops in the workspace.
	HasExpiredEdsCount *int32 `json:"HasExpiredEdsCount,omitempty" xml:"HasExpiredEdsCount,omitempty"`
	// The number of expired cloud desktops in the desktop group.
	HasExpiredEdsCountForGroup *int32 `json:"HasExpiredEdsCountForGroup,omitempty" xml:"HasExpiredEdsCountForGroup,omitempty"`
	// The ID of the workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The name of the workspace.
	OfficeSiteName *string `json:"OfficeSiteName,omitempty" xml:"OfficeSiteName,omitempty"`
	// The status of the workspace.
	OfficeSiteStatus *string `json:"OfficeSiteStatus,omitempty" xml:"OfficeSiteStatus,omitempty"`
	// The region ID of the workspace.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The number of running cloud desktops in the workspace.
	RunningEdsCount *int32 `json:"RunningEdsCount,omitempty" xml:"RunningEdsCount,omitempty"`
	// The number of running cloud desktops in the desktop group.
	RunningEdsCountForGroup *int32 `json:"RunningEdsCountForGroup,omitempty" xml:"RunningEdsCountForGroup,omitempty"`
	// The total number of cloud desktops in the workspace.
	TotalEdsCount *int32 `json:"TotalEdsCount,omitempty" xml:"TotalEdsCount,omitempty"`
	// The total number of cloud desktops in the desktop group.
	TotalEdsCountForGroup *int32 `json:"TotalEdsCountForGroup,omitempty" xml:"TotalEdsCountForGroup,omitempty"`
	// The virtual private cloud (VPC) type of the workspace.
	VpcType *string `json:"VpcType,omitempty" xml:"VpcType,omitempty"`
	// The number of cloud desktops that are about to expire in the workspace.
	WillExpiredEdsCount *int32 `json:"WillExpiredEdsCount,omitempty" xml:"WillExpiredEdsCount,omitempty"`
	// The number of cloud desktops that are about to expire in the desktop group.
	WillExpiredEdsCountForGroup *int32 `json:"WillExpiredEdsCountForGroup,omitempty" xml:"WillExpiredEdsCountForGroup,omitempty"`
}

func (s ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults) String() string {
	return tea.Prettify(s)
}

func (s ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults) GoString() string {
	return s.String()
}

func (s *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults) SetHasExpiredEdsCount(v int32) *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults {
	s.HasExpiredEdsCount = &v
	return s
}

func (s *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults) SetHasExpiredEdsCountForGroup(v int32) *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults {
	s.HasExpiredEdsCountForGroup = &v
	return s
}

func (s *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults) SetOfficeSiteId(v string) *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults {
	s.OfficeSiteId = &v
	return s
}

func (s *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults) SetOfficeSiteName(v string) *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults {
	s.OfficeSiteName = &v
	return s
}

func (s *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults) SetOfficeSiteStatus(v string) *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults {
	s.OfficeSiteStatus = &v
	return s
}

func (s *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults) SetRegionId(v string) *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults {
	s.RegionId = &v
	return s
}

func (s *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults) SetRunningEdsCount(v int32) *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults {
	s.RunningEdsCount = &v
	return s
}

func (s *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults) SetRunningEdsCountForGroup(v int32) *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults {
	s.RunningEdsCountForGroup = &v
	return s
}

func (s *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults) SetTotalEdsCount(v int32) *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults {
	s.TotalEdsCount = &v
	return s
}

func (s *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults) SetTotalEdsCountForGroup(v int32) *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults {
	s.TotalEdsCountForGroup = &v
	return s
}

func (s *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults) SetVpcType(v string) *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults {
	s.VpcType = &v
	return s
}

func (s *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults) SetWillExpiredEdsCount(v int32) *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults {
	s.WillExpiredEdsCount = &v
	return s
}

func (s *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults) SetWillExpiredEdsCountForGroup(v int32) *ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults {
	s.WillExpiredEdsCountForGroup = &v
	return s
}

type ListOfficeSiteOverviewResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListOfficeSiteOverviewResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListOfficeSiteOverviewResponse) String() string {
	return tea.Prettify(s)
}

func (s ListOfficeSiteOverviewResponse) GoString() string {
	return s.String()
}

func (s *ListOfficeSiteOverviewResponse) SetHeaders(v map[string]*string) *ListOfficeSiteOverviewResponse {
	s.Headers = v
	return s
}

func (s *ListOfficeSiteOverviewResponse) SetStatusCode(v int32) *ListOfficeSiteOverviewResponse {
	s.StatusCode = &v
	return s
}

func (s *ListOfficeSiteOverviewResponse) SetBody(v *ListOfficeSiteOverviewResponseBody) *ListOfficeSiteOverviewResponse {
	s.Body = v
	return s
}

type ListOfficeSiteUsersRequest struct {
	// The query string for fuzzy query.
	Filter *string `json:"Filter,omitempty" xml:"Filter,omitempty"`
	// The number of entries per page.
	//
	// *   Valid values: 1 to 100.
	// *   Default value: 10.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request or if no next query exists. You must specify the token that is obtained from the previous query as the value of NextToken.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The organizational unit (OU) of the specified AD domain.
	OUPath *string `json:"OUPath,omitempty" xml:"OUPath,omitempty"`
	// The workspace ID. Only workspaces of the enterprise AD account type are supported.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~196646~~) to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListOfficeSiteUsersRequest) String() string {
	return tea.Prettify(s)
}

func (s ListOfficeSiteUsersRequest) GoString() string {
	return s.String()
}

func (s *ListOfficeSiteUsersRequest) SetFilter(v string) *ListOfficeSiteUsersRequest {
	s.Filter = &v
	return s
}

func (s *ListOfficeSiteUsersRequest) SetMaxResults(v int32) *ListOfficeSiteUsersRequest {
	s.MaxResults = &v
	return s
}

func (s *ListOfficeSiteUsersRequest) SetNextToken(v string) *ListOfficeSiteUsersRequest {
	s.NextToken = &v
	return s
}

func (s *ListOfficeSiteUsersRequest) SetOUPath(v string) *ListOfficeSiteUsersRequest {
	s.OUPath = &v
	return s
}

func (s *ListOfficeSiteUsersRequest) SetOfficeSiteId(v string) *ListOfficeSiteUsersRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *ListOfficeSiteUsersRequest) SetRegionId(v string) *ListOfficeSiteUsersRequest {
	s.RegionId = &v
	return s
}

type ListOfficeSiteUsersResponseBody struct {
	// A pagination token. It can be used in the next request to retrieve a new page of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The usernames of AD users.\
	// If the only Administrator and Guest users exist in the enterprise AD, an empty User array is returned.
	Users []*ListOfficeSiteUsersResponseBodyUsers `json:"Users,omitempty" xml:"Users,omitempty" type:"Repeated"`
}

func (s ListOfficeSiteUsersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListOfficeSiteUsersResponseBody) GoString() string {
	return s.String()
}

func (s *ListOfficeSiteUsersResponseBody) SetNextToken(v string) *ListOfficeSiteUsersResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListOfficeSiteUsersResponseBody) SetRequestId(v string) *ListOfficeSiteUsersResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListOfficeSiteUsersResponseBody) SetUsers(v []*ListOfficeSiteUsersResponseBodyUsers) *ListOfficeSiteUsersResponseBody {
	s.Users = v
	return s
}

type ListOfficeSiteUsersResponseBodyUsers struct {
	// The display name of the user.
	DisplayName *string `json:"DisplayName,omitempty" xml:"DisplayName,omitempty"`
	// The name of the AD user.
	EndUser *string `json:"EndUser,omitempty" xml:"EndUser,omitempty"`
}

func (s ListOfficeSiteUsersResponseBodyUsers) String() string {
	return tea.Prettify(s)
}

func (s ListOfficeSiteUsersResponseBodyUsers) GoString() string {
	return s.String()
}

func (s *ListOfficeSiteUsersResponseBodyUsers) SetDisplayName(v string) *ListOfficeSiteUsersResponseBodyUsers {
	s.DisplayName = &v
	return s
}

func (s *ListOfficeSiteUsersResponseBodyUsers) SetEndUser(v string) *ListOfficeSiteUsersResponseBodyUsers {
	s.EndUser = &v
	return s
}

type ListOfficeSiteUsersResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListOfficeSiteUsersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListOfficeSiteUsersResponse) String() string {
	return tea.Prettify(s)
}

func (s ListOfficeSiteUsersResponse) GoString() string {
	return s.String()
}

func (s *ListOfficeSiteUsersResponse) SetHeaders(v map[string]*string) *ListOfficeSiteUsersResponse {
	s.Headers = v
	return s
}

func (s *ListOfficeSiteUsersResponse) SetStatusCode(v int32) *ListOfficeSiteUsersResponse {
	s.StatusCode = &v
	return s
}

func (s *ListOfficeSiteUsersResponse) SetBody(v *ListOfficeSiteUsersResponseBody) *ListOfficeSiteUsersResponse {
	s.Body = v
	return s
}

type ListTagResourcesRequest struct {
	// The number of entries per page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource IDs, namely the cloud desktop IDs. You can specify 1 to 50 IDs of cloud desktops.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The resource type. Valid value: ALIYUN::GWS::INSTANCE.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tags.
	Tag []*ListTagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s ListTagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequest) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequest) SetMaxResults(v int32) *ListTagResourcesRequest {
	s.MaxResults = &v
	return s
}

func (s *ListTagResourcesRequest) SetNextToken(v string) *ListTagResourcesRequest {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesRequest) SetRegionId(v string) *ListTagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceId(v []*string) *ListTagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *ListTagResourcesRequest) SetResourceType(v string) *ListTagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesRequest) SetTag(v []*ListTagResourcesRequestTag) *ListTagResourcesRequest {
	s.Tag = v
	return s
}

type ListTagResourcesRequestTag struct {
	// The tag key. You can specify 1 to 20 keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value. You can specify 1 to 20 values.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequestTag) SetKey(v string) *ListTagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *ListTagResourcesRequestTag) SetValue(v string) *ListTagResourcesRequestTag {
	s.Value = &v
	return s
}

type ListTagResourcesResponseBody struct {
	// A pagination token. If NextToken is empty, no next page exists.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The resources and their tags.
	TagResources []*ListTagResourcesResponseBodyTagResources `json:"TagResources,omitempty" xml:"TagResources,omitempty" type:"Repeated"`
}

func (s ListTagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBody) SetNextToken(v string) *ListTagResourcesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetRequestId(v string) *ListTagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetTagResources(v []*ListTagResourcesResponseBodyTagResources) *ListTagResourcesResponseBody {
	s.TagResources = v
	return s
}

type ListTagResourcesResponseBodyTagResources struct {
	// The resource ID, namely the cloud desktop ID.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The resource type. Valid value: ALIYUN::GWS::INSTANCE.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tag key.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The tag value.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s ListTagResourcesResponseBodyTagResources) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResources) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResources) SetResourceId(v string) *ListTagResourcesResponseBodyTagResources {
	s.ResourceId = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResources) SetResourceType(v string) *ListTagResourcesResponseBodyTagResources {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResources) SetTagKey(v string) *ListTagResourcesResponseBodyTagResources {
	s.TagKey = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResources) SetTagValue(v string) *ListTagResourcesResponseBodyTagResources {
	s.TagValue = &v
	return s
}

type ListTagResourcesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponse) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponse) SetHeaders(v map[string]*string) *ListTagResourcesResponse {
	s.Headers = v
	return s
}

func (s *ListTagResourcesResponse) SetStatusCode(v int32) *ListTagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTagResourcesResponse) SetBody(v *ListTagResourcesResponseBody) *ListTagResourcesResponse {
	s.Body = v
	return s
}

type ListUserAdOrganizationUnitsRequest struct {
	// The string that you enter for fuzzy search.
	Filter *string `json:"Filter,omitempty" xml:"Filter,omitempty"`
	// The maximum number of entries to return on each page. Valid values: 1 to 500. Default value: 500.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the query. Set the value to the NextToken value that is returned from the last call.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the AD workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListUserAdOrganizationUnitsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListUserAdOrganizationUnitsRequest) GoString() string {
	return s.String()
}

func (s *ListUserAdOrganizationUnitsRequest) SetFilter(v string) *ListUserAdOrganizationUnitsRequest {
	s.Filter = &v
	return s
}

func (s *ListUserAdOrganizationUnitsRequest) SetMaxResults(v int32) *ListUserAdOrganizationUnitsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListUserAdOrganizationUnitsRequest) SetNextToken(v string) *ListUserAdOrganizationUnitsRequest {
	s.NextToken = &v
	return s
}

func (s *ListUserAdOrganizationUnitsRequest) SetOfficeSiteId(v string) *ListUserAdOrganizationUnitsRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *ListUserAdOrganizationUnitsRequest) SetRegionId(v string) *ListUserAdOrganizationUnitsRequest {
	s.RegionId = &v
	return s
}

type ListUserAdOrganizationUnitsResponseBody struct {
	// The token that is used to start the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The names of the OUs in the AD domain.
	OUNames []*ListUserAdOrganizationUnitsResponseBodyOUNames `json:"OUNames,omitempty" xml:"OUNames,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListUserAdOrganizationUnitsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListUserAdOrganizationUnitsResponseBody) GoString() string {
	return s.String()
}

func (s *ListUserAdOrganizationUnitsResponseBody) SetNextToken(v string) *ListUserAdOrganizationUnitsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListUserAdOrganizationUnitsResponseBody) SetOUNames(v []*ListUserAdOrganizationUnitsResponseBodyOUNames) *ListUserAdOrganizationUnitsResponseBody {
	s.OUNames = v
	return s
}

func (s *ListUserAdOrganizationUnitsResponseBody) SetRequestId(v string) *ListUserAdOrganizationUnitsResponseBody {
	s.RequestId = &v
	return s
}

type ListUserAdOrganizationUnitsResponseBodyOUNames struct {
	// The display name of the OU.
	DisplayOUName *string `json:"DisplayOUName,omitempty" xml:"DisplayOUName,omitempty"`
	// The name of the OU of the AD domain controller.
	OUName *string `json:"OUName,omitempty" xml:"OUName,omitempty"`
	// The ID of the AD workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
}

func (s ListUserAdOrganizationUnitsResponseBodyOUNames) String() string {
	return tea.Prettify(s)
}

func (s ListUserAdOrganizationUnitsResponseBodyOUNames) GoString() string {
	return s.String()
}

func (s *ListUserAdOrganizationUnitsResponseBodyOUNames) SetDisplayOUName(v string) *ListUserAdOrganizationUnitsResponseBodyOUNames {
	s.DisplayOUName = &v
	return s
}

func (s *ListUserAdOrganizationUnitsResponseBodyOUNames) SetOUName(v string) *ListUserAdOrganizationUnitsResponseBodyOUNames {
	s.OUName = &v
	return s
}

func (s *ListUserAdOrganizationUnitsResponseBodyOUNames) SetOfficeSiteId(v string) *ListUserAdOrganizationUnitsResponseBodyOUNames {
	s.OfficeSiteId = &v
	return s
}

type ListUserAdOrganizationUnitsResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListUserAdOrganizationUnitsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListUserAdOrganizationUnitsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListUserAdOrganizationUnitsResponse) GoString() string {
	return s.String()
}

func (s *ListUserAdOrganizationUnitsResponse) SetHeaders(v map[string]*string) *ListUserAdOrganizationUnitsResponse {
	s.Headers = v
	return s
}

func (s *ListUserAdOrganizationUnitsResponse) SetStatusCode(v int32) *ListUserAdOrganizationUnitsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListUserAdOrganizationUnitsResponse) SetBody(v *ListUserAdOrganizationUnitsResponseBody) *ListUserAdOrganizationUnitsResponse {
	s.Body = v
	return s
}

type LockVirtualMFADeviceRequest struct {
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The serial number of the virtual MFA device, which is a unique identifier.
	//
	// You can call the [DescribeVirtualMFADevices](~~206210~~) operation to query the serial number of the virtual MFA device bound by AD users.
	SerialNumber *string `json:"SerialNumber,omitempty" xml:"SerialNumber,omitempty"`
}

func (s LockVirtualMFADeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s LockVirtualMFADeviceRequest) GoString() string {
	return s.String()
}

func (s *LockVirtualMFADeviceRequest) SetRegionId(v string) *LockVirtualMFADeviceRequest {
	s.RegionId = &v
	return s
}

func (s *LockVirtualMFADeviceRequest) SetSerialNumber(v string) *LockVirtualMFADeviceRequest {
	s.SerialNumber = &v
	return s
}

type LockVirtualMFADeviceResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s LockVirtualMFADeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s LockVirtualMFADeviceResponseBody) GoString() string {
	return s.String()
}

func (s *LockVirtualMFADeviceResponseBody) SetRequestId(v string) *LockVirtualMFADeviceResponseBody {
	s.RequestId = &v
	return s
}

type LockVirtualMFADeviceResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *LockVirtualMFADeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s LockVirtualMFADeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s LockVirtualMFADeviceResponse) GoString() string {
	return s.String()
}

func (s *LockVirtualMFADeviceResponse) SetHeaders(v map[string]*string) *LockVirtualMFADeviceResponse {
	s.Headers = v
	return s
}

func (s *LockVirtualMFADeviceResponse) SetStatusCode(v int32) *LockVirtualMFADeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *LockVirtualMFADeviceResponse) SetBody(v *LockVirtualMFADeviceResponseBody) *LockVirtualMFADeviceResponse {
	s.Body = v
	return s
}

type MigrateDesktopsRequest struct {
	// The IDs of the cloud desktops. You can specify one or more cloud desktops. Valid values of N: 1 to 100.
	DesktopId []*string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty" type:"Repeated"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the destination workspace.
	TargetOfficeSiteId *string `json:"TargetOfficeSiteId,omitempty" xml:"TargetOfficeSiteId,omitempty"`
}

func (s MigrateDesktopsRequest) String() string {
	return tea.Prettify(s)
}

func (s MigrateDesktopsRequest) GoString() string {
	return s.String()
}

func (s *MigrateDesktopsRequest) SetDesktopId(v []*string) *MigrateDesktopsRequest {
	s.DesktopId = v
	return s
}

func (s *MigrateDesktopsRequest) SetRegionId(v string) *MigrateDesktopsRequest {
	s.RegionId = &v
	return s
}

func (s *MigrateDesktopsRequest) SetTargetOfficeSiteId(v string) *MigrateDesktopsRequest {
	s.TargetOfficeSiteId = &v
	return s
}

type MigrateDesktopsResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s MigrateDesktopsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s MigrateDesktopsResponseBody) GoString() string {
	return s.String()
}

func (s *MigrateDesktopsResponseBody) SetRequestId(v string) *MigrateDesktopsResponseBody {
	s.RequestId = &v
	return s
}

type MigrateDesktopsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *MigrateDesktopsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s MigrateDesktopsResponse) String() string {
	return tea.Prettify(s)
}

func (s MigrateDesktopsResponse) GoString() string {
	return s.String()
}

func (s *MigrateDesktopsResponse) SetHeaders(v map[string]*string) *MigrateDesktopsResponse {
	s.Headers = v
	return s
}

func (s *MigrateDesktopsResponse) SetStatusCode(v int32) *MigrateDesktopsResponse {
	s.StatusCode = &v
	return s
}

func (s *MigrateDesktopsResponse) SetBody(v *MigrateDesktopsResponseBody) *MigrateDesktopsResponse {
	s.Body = v
	return s
}

type MigrateImageProtocolRequest struct {
	ImageId            []*string `json:"ImageId,omitempty" xml:"ImageId,omitempty" type:"Repeated"`
	RegionId           *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	TargetProtocolType *string   `json:"TargetProtocolType,omitempty" xml:"TargetProtocolType,omitempty"`
}

func (s MigrateImageProtocolRequest) String() string {
	return tea.Prettify(s)
}

func (s MigrateImageProtocolRequest) GoString() string {
	return s.String()
}

func (s *MigrateImageProtocolRequest) SetImageId(v []*string) *MigrateImageProtocolRequest {
	s.ImageId = v
	return s
}

func (s *MigrateImageProtocolRequest) SetRegionId(v string) *MigrateImageProtocolRequest {
	s.RegionId = &v
	return s
}

func (s *MigrateImageProtocolRequest) SetTargetProtocolType(v string) *MigrateImageProtocolRequest {
	s.TargetProtocolType = &v
	return s
}

type MigrateImageProtocolResponseBody struct {
	FailedIds []*string `json:"FailedIds,omitempty" xml:"FailedIds,omitempty" type:"Repeated"`
	RequestId *string   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s MigrateImageProtocolResponseBody) String() string {
	return tea.Prettify(s)
}

func (s MigrateImageProtocolResponseBody) GoString() string {
	return s.String()
}

func (s *MigrateImageProtocolResponseBody) SetFailedIds(v []*string) *MigrateImageProtocolResponseBody {
	s.FailedIds = v
	return s
}

func (s *MigrateImageProtocolResponseBody) SetRequestId(v string) *MigrateImageProtocolResponseBody {
	s.RequestId = &v
	return s
}

type MigrateImageProtocolResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *MigrateImageProtocolResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s MigrateImageProtocolResponse) String() string {
	return tea.Prettify(s)
}

func (s MigrateImageProtocolResponse) GoString() string {
	return s.String()
}

func (s *MigrateImageProtocolResponse) SetHeaders(v map[string]*string) *MigrateImageProtocolResponse {
	s.Headers = v
	return s
}

func (s *MigrateImageProtocolResponse) SetStatusCode(v int32) *MigrateImageProtocolResponse {
	s.StatusCode = &v
	return s
}

func (s *MigrateImageProtocolResponse) SetBody(v *MigrateImageProtocolResponseBody) *MigrateImageProtocolResponse {
	s.Body = v
	return s
}

type ModifyADConnectorDirectoryRequest struct {
	AdHostname          *string   `json:"AdHostname,omitempty" xml:"AdHostname,omitempty"`
	DirectoryId         *string   `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	DirectoryName       *string   `json:"DirectoryName,omitempty" xml:"DirectoryName,omitempty"`
	DnsAddress          []*string `json:"DnsAddress,omitempty" xml:"DnsAddress,omitempty" type:"Repeated"`
	DomainName          *string   `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	DomainPassword      *string   `json:"DomainPassword,omitempty" xml:"DomainPassword,omitempty"`
	DomainUserName      *string   `json:"DomainUserName,omitempty" xml:"DomainUserName,omitempty"`
	MfaEnabled          *bool     `json:"MfaEnabled,omitempty" xml:"MfaEnabled,omitempty"`
	OUName              *string   `json:"OUName,omitempty" xml:"OUName,omitempty"`
	RegionId            *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	SubDomainDnsAddress []*string `json:"SubDomainDnsAddress,omitempty" xml:"SubDomainDnsAddress,omitempty" type:"Repeated"`
	SubDomainName       *string   `json:"SubDomainName,omitempty" xml:"SubDomainName,omitempty"`
}

func (s ModifyADConnectorDirectoryRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyADConnectorDirectoryRequest) GoString() string {
	return s.String()
}

func (s *ModifyADConnectorDirectoryRequest) SetAdHostname(v string) *ModifyADConnectorDirectoryRequest {
	s.AdHostname = &v
	return s
}

func (s *ModifyADConnectorDirectoryRequest) SetDirectoryId(v string) *ModifyADConnectorDirectoryRequest {
	s.DirectoryId = &v
	return s
}

func (s *ModifyADConnectorDirectoryRequest) SetDirectoryName(v string) *ModifyADConnectorDirectoryRequest {
	s.DirectoryName = &v
	return s
}

func (s *ModifyADConnectorDirectoryRequest) SetDnsAddress(v []*string) *ModifyADConnectorDirectoryRequest {
	s.DnsAddress = v
	return s
}

func (s *ModifyADConnectorDirectoryRequest) SetDomainName(v string) *ModifyADConnectorDirectoryRequest {
	s.DomainName = &v
	return s
}

func (s *ModifyADConnectorDirectoryRequest) SetDomainPassword(v string) *ModifyADConnectorDirectoryRequest {
	s.DomainPassword = &v
	return s
}

func (s *ModifyADConnectorDirectoryRequest) SetDomainUserName(v string) *ModifyADConnectorDirectoryRequest {
	s.DomainUserName = &v
	return s
}

func (s *ModifyADConnectorDirectoryRequest) SetMfaEnabled(v bool) *ModifyADConnectorDirectoryRequest {
	s.MfaEnabled = &v
	return s
}

func (s *ModifyADConnectorDirectoryRequest) SetOUName(v string) *ModifyADConnectorDirectoryRequest {
	s.OUName = &v
	return s
}

func (s *ModifyADConnectorDirectoryRequest) SetRegionId(v string) *ModifyADConnectorDirectoryRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyADConnectorDirectoryRequest) SetSubDomainDnsAddress(v []*string) *ModifyADConnectorDirectoryRequest {
	s.SubDomainDnsAddress = v
	return s
}

func (s *ModifyADConnectorDirectoryRequest) SetSubDomainName(v string) *ModifyADConnectorDirectoryRequest {
	s.SubDomainName = &v
	return s
}

type ModifyADConnectorDirectoryResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyADConnectorDirectoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyADConnectorDirectoryResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyADConnectorDirectoryResponseBody) SetRequestId(v string) *ModifyADConnectorDirectoryResponseBody {
	s.RequestId = &v
	return s
}

type ModifyADConnectorDirectoryResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyADConnectorDirectoryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyADConnectorDirectoryResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyADConnectorDirectoryResponse) GoString() string {
	return s.String()
}

func (s *ModifyADConnectorDirectoryResponse) SetHeaders(v map[string]*string) *ModifyADConnectorDirectoryResponse {
	s.Headers = v
	return s
}

func (s *ModifyADConnectorDirectoryResponse) SetStatusCode(v int32) *ModifyADConnectorDirectoryResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyADConnectorDirectoryResponse) SetBody(v *ModifyADConnectorDirectoryResponseBody) *ModifyADConnectorDirectoryResponse {
	s.Body = v
	return s
}

type ModifyADConnectorOfficeSiteRequest struct {
	AdHostname          *string   `json:"AdHostname,omitempty" xml:"AdHostname,omitempty"`
	DnsAddress          []*string `json:"DnsAddress,omitempty" xml:"DnsAddress,omitempty" type:"Repeated"`
	DomainName          *string   `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	DomainPassword      *string   `json:"DomainPassword,omitempty" xml:"DomainPassword,omitempty"`
	DomainUserName      *string   `json:"DomainUserName,omitempty" xml:"DomainUserName,omitempty"`
	MfaEnabled          *bool     `json:"MfaEnabled,omitempty" xml:"MfaEnabled,omitempty"`
	OUName              *string   `json:"OUName,omitempty" xml:"OUName,omitempty"`
	OfficeSiteId        *string   `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	OfficeSiteName      *string   `json:"OfficeSiteName,omitempty" xml:"OfficeSiteName,omitempty"`
	RegionId            *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	SubDomainDnsAddress []*string `json:"SubDomainDnsAddress,omitempty" xml:"SubDomainDnsAddress,omitempty" type:"Repeated"`
	SubDomainName       *string   `json:"SubDomainName,omitempty" xml:"SubDomainName,omitempty"`
}

func (s ModifyADConnectorOfficeSiteRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyADConnectorOfficeSiteRequest) GoString() string {
	return s.String()
}

func (s *ModifyADConnectorOfficeSiteRequest) SetAdHostname(v string) *ModifyADConnectorOfficeSiteRequest {
	s.AdHostname = &v
	return s
}

func (s *ModifyADConnectorOfficeSiteRequest) SetDnsAddress(v []*string) *ModifyADConnectorOfficeSiteRequest {
	s.DnsAddress = v
	return s
}

func (s *ModifyADConnectorOfficeSiteRequest) SetDomainName(v string) *ModifyADConnectorOfficeSiteRequest {
	s.DomainName = &v
	return s
}

func (s *ModifyADConnectorOfficeSiteRequest) SetDomainPassword(v string) *ModifyADConnectorOfficeSiteRequest {
	s.DomainPassword = &v
	return s
}

func (s *ModifyADConnectorOfficeSiteRequest) SetDomainUserName(v string) *ModifyADConnectorOfficeSiteRequest {
	s.DomainUserName = &v
	return s
}

func (s *ModifyADConnectorOfficeSiteRequest) SetMfaEnabled(v bool) *ModifyADConnectorOfficeSiteRequest {
	s.MfaEnabled = &v
	return s
}

func (s *ModifyADConnectorOfficeSiteRequest) SetOUName(v string) *ModifyADConnectorOfficeSiteRequest {
	s.OUName = &v
	return s
}

func (s *ModifyADConnectorOfficeSiteRequest) SetOfficeSiteId(v string) *ModifyADConnectorOfficeSiteRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *ModifyADConnectorOfficeSiteRequest) SetOfficeSiteName(v string) *ModifyADConnectorOfficeSiteRequest {
	s.OfficeSiteName = &v
	return s
}

func (s *ModifyADConnectorOfficeSiteRequest) SetRegionId(v string) *ModifyADConnectorOfficeSiteRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyADConnectorOfficeSiteRequest) SetSubDomainDnsAddress(v []*string) *ModifyADConnectorOfficeSiteRequest {
	s.SubDomainDnsAddress = v
	return s
}

func (s *ModifyADConnectorOfficeSiteRequest) SetSubDomainName(v string) *ModifyADConnectorOfficeSiteRequest {
	s.SubDomainName = &v
	return s
}

type ModifyADConnectorOfficeSiteResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyADConnectorOfficeSiteResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyADConnectorOfficeSiteResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyADConnectorOfficeSiteResponseBody) SetRequestId(v string) *ModifyADConnectorOfficeSiteResponseBody {
	s.RequestId = &v
	return s
}

type ModifyADConnectorOfficeSiteResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyADConnectorOfficeSiteResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyADConnectorOfficeSiteResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyADConnectorOfficeSiteResponse) GoString() string {
	return s.String()
}

func (s *ModifyADConnectorOfficeSiteResponse) SetHeaders(v map[string]*string) *ModifyADConnectorOfficeSiteResponse {
	s.Headers = v
	return s
}

func (s *ModifyADConnectorOfficeSiteResponse) SetStatusCode(v int32) *ModifyADConnectorOfficeSiteResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyADConnectorOfficeSiteResponse) SetBody(v *ModifyADConnectorOfficeSiteResponseBody) *ModifyADConnectorOfficeSiteResponse {
	s.Body = v
	return s
}

type ModifyAclEntriesRequest struct {
	// The ACL policy.
	//
	// Valid values:
	//
	// *   allow
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   deny
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The IDs of instances that correspond to the ACL granularity.
	SourceId []*string `json:"SourceId,omitempty" xml:"SourceId,omitempty" type:"Repeated"`
	// The network granularity that corresponds to the access control list (ACL) policy.
	//
	// Valid values:
	//
	// *   desktop
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     cloud desktop
	//
	//     <!-- -->
	//
	// *   vpc
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     workspace
	//
	//     <!-- -->
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
}

func (s ModifyAclEntriesRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyAclEntriesRequest) GoString() string {
	return s.String()
}

func (s *ModifyAclEntriesRequest) SetPolicy(v string) *ModifyAclEntriesRequest {
	s.Policy = &v
	return s
}

func (s *ModifyAclEntriesRequest) SetRegionId(v string) *ModifyAclEntriesRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyAclEntriesRequest) SetSourceId(v []*string) *ModifyAclEntriesRequest {
	s.SourceId = v
	return s
}

func (s *ModifyAclEntriesRequest) SetSourceType(v string) *ModifyAclEntriesRequest {
	s.SourceType = &v
	return s
}

type ModifyAclEntriesResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyAclEntriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyAclEntriesResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyAclEntriesResponseBody) SetRequestId(v string) *ModifyAclEntriesResponseBody {
	s.RequestId = &v
	return s
}

type ModifyAclEntriesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyAclEntriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyAclEntriesResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyAclEntriesResponse) GoString() string {
	return s.String()
}

func (s *ModifyAclEntriesResponse) SetHeaders(v map[string]*string) *ModifyAclEntriesResponse {
	s.Headers = v
	return s
}

func (s *ModifyAclEntriesResponse) SetStatusCode(v int32) *ModifyAclEntriesResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyAclEntriesResponse) SetBody(v *ModifyAclEntriesResponseBody) *ModifyAclEntriesResponse {
	s.Body = v
	return s
}

type ModifyAutoSnapshotPolicyRequest struct {
	// The CRON expression.
	CronExpression *string `json:"CronExpression,omitempty" xml:"CronExpression,omitempty"`
	// The ID of the automatic snapshot policy.
	PolicyId *string `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The name of the automatic snapshot policy. The name must be 2 to 128 characters in length. The name can contain letters, digits, colons (:), underscores (\_), and hyphens (-). It must start with a letter but cannot start with [http:// or https://. The name can contain letters, digits, colons (:), underscores (\_), and hyphens (-). Default value: null.](http://https://:\_-)
	PolicyName *string `json:"PolicyName,omitempty" xml:"PolicyName,omitempty"`
	// The ID of the region where the automatic snapshot policy is created.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The retention period of automatic snapshots. Unit: days. Valid values:
	//
	// *   1 (default): The automatic snapshots are permanently retained.
	// *   1 to 65536: The automatic snapshots are retained for the specified number of days.
	RetentionDays *int32 `json:"RetentionDays,omitempty" xml:"RetentionDays,omitempty"`
}

func (s ModifyAutoSnapshotPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyAutoSnapshotPolicyRequest) GoString() string {
	return s.String()
}

func (s *ModifyAutoSnapshotPolicyRequest) SetCronExpression(v string) *ModifyAutoSnapshotPolicyRequest {
	s.CronExpression = &v
	return s
}

func (s *ModifyAutoSnapshotPolicyRequest) SetPolicyId(v string) *ModifyAutoSnapshotPolicyRequest {
	s.PolicyId = &v
	return s
}

func (s *ModifyAutoSnapshotPolicyRequest) SetPolicyName(v string) *ModifyAutoSnapshotPolicyRequest {
	s.PolicyName = &v
	return s
}

func (s *ModifyAutoSnapshotPolicyRequest) SetRegionId(v string) *ModifyAutoSnapshotPolicyRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyAutoSnapshotPolicyRequest) SetRetentionDays(v int32) *ModifyAutoSnapshotPolicyRequest {
	s.RetentionDays = &v
	return s
}

type ModifyAutoSnapshotPolicyResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyAutoSnapshotPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyAutoSnapshotPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyAutoSnapshotPolicyResponseBody) SetRequestId(v string) *ModifyAutoSnapshotPolicyResponseBody {
	s.RequestId = &v
	return s
}

type ModifyAutoSnapshotPolicyResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyAutoSnapshotPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyAutoSnapshotPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyAutoSnapshotPolicyResponse) GoString() string {
	return s.String()
}

func (s *ModifyAutoSnapshotPolicyResponse) SetHeaders(v map[string]*string) *ModifyAutoSnapshotPolicyResponse {
	s.Headers = v
	return s
}

func (s *ModifyAutoSnapshotPolicyResponse) SetStatusCode(v int32) *ModifyAutoSnapshotPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyAutoSnapshotPolicyResponse) SetBody(v *ModifyAutoSnapshotPolicyResponseBody) *ModifyAutoSnapshotPolicyResponse {
	s.Body = v
	return s
}

type ModifyBundleRequest struct {
	// The desktop template ID.
	BundleId *string `json:"BundleId,omitempty" xml:"BundleId,omitempty"`
	// The name of the new desktop template.
	BundleName *string `json:"BundleName,omitempty" xml:"BundleName,omitempty"`
	// The description of the new desktop template.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The new image ID. The new image must meet the following conditions:
	//
	// *   The new image must be in the Available state.
	// *   The operating system of the new image must be the same as that of the original image.
	// *   The required disk size for the new image cannot be greater than that for the original image.
	// *   The GPU type of the new image must be the same as that of the original image.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The language of the OS. This parameter is available only for system images. Valid values:
	//
	// *   zh-CN: Simplified Chinese
	// *   zh-HK: Traditional Chinese (Hong Kong)
	// *   en-US: English
	// *   ja-JP: Japanese
	Language *string `json:"Language,omitempty" xml:"Language,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ModifyBundleRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyBundleRequest) GoString() string {
	return s.String()
}

func (s *ModifyBundleRequest) SetBundleId(v string) *ModifyBundleRequest {
	s.BundleId = &v
	return s
}

func (s *ModifyBundleRequest) SetBundleName(v string) *ModifyBundleRequest {
	s.BundleName = &v
	return s
}

func (s *ModifyBundleRequest) SetDescription(v string) *ModifyBundleRequest {
	s.Description = &v
	return s
}

func (s *ModifyBundleRequest) SetImageId(v string) *ModifyBundleRequest {
	s.ImageId = &v
	return s
}

func (s *ModifyBundleRequest) SetLanguage(v string) *ModifyBundleRequest {
	s.Language = &v
	return s
}

func (s *ModifyBundleRequest) SetRegionId(v string) *ModifyBundleRequest {
	s.RegionId = &v
	return s
}

type ModifyBundleResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyBundleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyBundleResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyBundleResponseBody) SetRequestId(v string) *ModifyBundleResponseBody {
	s.RequestId = &v
	return s
}

type ModifyBundleResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyBundleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyBundleResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyBundleResponse) GoString() string {
	return s.String()
}

func (s *ModifyBundleResponse) SetHeaders(v map[string]*string) *ModifyBundleResponse {
	s.Headers = v
	return s
}

func (s *ModifyBundleResponse) SetStatusCode(v int32) *ModifyBundleResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyBundleResponse) SetBody(v *ModifyBundleResponseBody) *ModifyBundleResponse {
	s.Body = v
	return s
}

type ModifyCdsFileRequest struct {
	// The cloud disk ID.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	// The processing mode of files that have the same name.
	//
	// Valid values:
	//
	// *   refuse
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     refuses to create a file that has the same name as the file in the cloud.
	//
	//     <!-- -->
	//
	// *   auto_rename
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     automatically renames a file if the file has the same name as another file. By default, the current point in time is appended. Example: xxx20060102\_150405.
	//
	//     <!-- -->
	//
	// *   ignore
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     allows files with the same name.
	//
	//     <!-- -->
	ConflictPolicy *string `json:"ConflictPolicy,omitempty" xml:"ConflictPolicy,omitempty"`
	// The ID of the end user who uses the cloud disk.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The file ID.
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The file name.
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The group ID.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ModifyCdsFileRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyCdsFileRequest) GoString() string {
	return s.String()
}

func (s *ModifyCdsFileRequest) SetCdsId(v string) *ModifyCdsFileRequest {
	s.CdsId = &v
	return s
}

func (s *ModifyCdsFileRequest) SetConflictPolicy(v string) *ModifyCdsFileRequest {
	s.ConflictPolicy = &v
	return s
}

func (s *ModifyCdsFileRequest) SetEndUserId(v string) *ModifyCdsFileRequest {
	s.EndUserId = &v
	return s
}

func (s *ModifyCdsFileRequest) SetFileId(v string) *ModifyCdsFileRequest {
	s.FileId = &v
	return s
}

func (s *ModifyCdsFileRequest) SetFileName(v string) *ModifyCdsFileRequest {
	s.FileName = &v
	return s
}

func (s *ModifyCdsFileRequest) SetGroupId(v string) *ModifyCdsFileRequest {
	s.GroupId = &v
	return s
}

func (s *ModifyCdsFileRequest) SetRegionId(v string) *ModifyCdsFileRequest {
	s.RegionId = &v
	return s
}

type ModifyCdsFileResponseBody struct {
	// The modification result. The value success indicates that the modification is successful. If the modification failed, an error message is returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// Specifies whether data is returned.
	//
	// Valid values:
	//
	// *   false: Data fails to be returned.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   true
	//
	//     <!-- -->
	//
	//     : Data is returned.
	//
	//     <!-- -->
	//
	//     <!-- -->
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error message returned if the request failed.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	//
	// Valid values:
	//
	// *   true: The request is successful.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   false: The request fails.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ModifyCdsFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyCdsFileResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyCdsFileResponseBody) SetCode(v string) *ModifyCdsFileResponseBody {
	s.Code = &v
	return s
}

func (s *ModifyCdsFileResponseBody) SetData(v string) *ModifyCdsFileResponseBody {
	s.Data = &v
	return s
}

func (s *ModifyCdsFileResponseBody) SetMessage(v string) *ModifyCdsFileResponseBody {
	s.Message = &v
	return s
}

func (s *ModifyCdsFileResponseBody) SetRequestId(v string) *ModifyCdsFileResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyCdsFileResponseBody) SetSuccess(v bool) *ModifyCdsFileResponseBody {
	s.Success = &v
	return s
}

type ModifyCdsFileResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyCdsFileResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyCdsFileResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyCdsFileResponse) GoString() string {
	return s.String()
}

func (s *ModifyCdsFileResponse) SetHeaders(v map[string]*string) *ModifyCdsFileResponse {
	s.Headers = v
	return s
}

func (s *ModifyCdsFileResponse) SetStatusCode(v int32) *ModifyCdsFileResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyCdsFileResponse) SetBody(v *ModifyCdsFileResponseBody) *ModifyCdsFileResponse {
	s.Body = v
	return s
}

type ModifyCdsFileShareLinkRequest struct {
	// The ID of the cloud disk.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	// The description of the file sharing task. The description must be 0 to 1,024 characters in length.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to prohibit the download of the files that are being shared.
	//
	// Valid values:
	//
	// *   false
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	DisableDownload *bool `json:"DisableDownload,omitempty" xml:"DisableDownload,omitempty"`
	// Specifies whether to prohibit the preview of the files that are being shared.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   false
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	DisablePreview *bool `json:"DisablePreview,omitempty" xml:"DisablePreview,omitempty"`
	// Specifies whether to prohibit the dump of the files that are being shared.
	//
	// Valid values:
	//
	// *   false
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	DisableSave *bool `json:"DisableSave,omitempty" xml:"DisableSave,omitempty"`
	// The number of times that the shared files are downloaded. The value of this parameter must be equal to or greater than 0.
	DownloadCount *int64 `json:"DownloadCount,omitempty" xml:"DownloadCount,omitempty"`
	// The limit on the number of times that the shared files can be downloaded. The value of this parameter must be equal to or greater than 0. The value 0 specifies that no limit is imposed on the number of times that the shared files can be downloaded.
	DownloadLimit *int64 `json:"DownloadLimit,omitempty" xml:"DownloadLimit,omitempty"`
	// The time when the file sharing link expires. The value of this parameter follows the RFC 3339 standard. Example: "2020-06-28T11:33:00.000+08:00". If this parameter is set to "", the file sharing link never expires.
	Expiration *string `json:"Expiration,omitempty" xml:"Expiration,omitempty"`
	// The number of times that the shared files are previewed. The value of this parameter must be equal to or greater than 0.
	PreviewCount *int64 `json:"PreviewCount,omitempty" xml:"PreviewCount,omitempty"`
	// The limit on the number of times that the shared files can be previewed. The value of this parameter must be equal to or greater than 0. The value 0 specifies that no limit is imposed on the number of times that the shared files can be downloaded.
	PreviewLimit *int64 `json:"PreviewLimit,omitempty" xml:"PreviewLimit,omitempty"`
	// The number of times that the shared files are reported. The value of this parameter must be equal to or greater than 0.
	ReportCount *int64 `json:"ReportCount,omitempty" xml:"ReportCount,omitempty"`
	// The number of times that the shared files are dumped. The value of this parameter must be equal to or greater than 0.
	SaveCount *int64 `json:"SaveCount,omitempty" xml:"SaveCount,omitempty"`
	// The limit on the number of times that the shared files can be dumped. The value of this parameter must be equal to or greater than 0. The value 0 specifies that no limit is imposed on the number of times that the shared files can be downloaded.
	SaveLimit *int64 `json:"SaveLimit,omitempty" xml:"SaveLimit,omitempty"`
	// The ID of the file sharing task.
	ShareId *string `json:"ShareId,omitempty" xml:"ShareId,omitempty"`
	// The name of the file sharing task. If you do not configure this parameter, the sharing task name is the first ID that is returned in the file_id_list value.
	//
	// >  The sharing task name must be 0 to 128 characters in length.
	ShareName *string `json:"ShareName,omitempty" xml:"ShareName,omitempty"`
	// The length of the access code. Valid values: 6 to 8. Unit: bytes. If you leave this parameter empty or set it to null, no access code is required. If you use a token to share files, you do not need to configure this parameter. The access code can contain only visible ASCII characters.
	SharePwd *string `json:"SharePwd,omitempty" xml:"SharePwd,omitempty"`
	// The sharing status.
	//
	// Valid values:
	//
	// *   disabled: The sharing task is canceled.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   enabled: The sharing task is valid.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The number of times that the videos are previewed in the shared files. The value of this parameter must be equal to or greater than 0.
	VideoPreviewCount *int64 `json:"VideoPreviewCount,omitempty" xml:"VideoPreviewCount,omitempty"`
}

func (s ModifyCdsFileShareLinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyCdsFileShareLinkRequest) GoString() string {
	return s.String()
}

func (s *ModifyCdsFileShareLinkRequest) SetCdsId(v string) *ModifyCdsFileShareLinkRequest {
	s.CdsId = &v
	return s
}

func (s *ModifyCdsFileShareLinkRequest) SetDescription(v string) *ModifyCdsFileShareLinkRequest {
	s.Description = &v
	return s
}

func (s *ModifyCdsFileShareLinkRequest) SetDisableDownload(v bool) *ModifyCdsFileShareLinkRequest {
	s.DisableDownload = &v
	return s
}

func (s *ModifyCdsFileShareLinkRequest) SetDisablePreview(v bool) *ModifyCdsFileShareLinkRequest {
	s.DisablePreview = &v
	return s
}

func (s *ModifyCdsFileShareLinkRequest) SetDisableSave(v bool) *ModifyCdsFileShareLinkRequest {
	s.DisableSave = &v
	return s
}

func (s *ModifyCdsFileShareLinkRequest) SetDownloadCount(v int64) *ModifyCdsFileShareLinkRequest {
	s.DownloadCount = &v
	return s
}

func (s *ModifyCdsFileShareLinkRequest) SetDownloadLimit(v int64) *ModifyCdsFileShareLinkRequest {
	s.DownloadLimit = &v
	return s
}

func (s *ModifyCdsFileShareLinkRequest) SetExpiration(v string) *ModifyCdsFileShareLinkRequest {
	s.Expiration = &v
	return s
}

func (s *ModifyCdsFileShareLinkRequest) SetPreviewCount(v int64) *ModifyCdsFileShareLinkRequest {
	s.PreviewCount = &v
	return s
}

func (s *ModifyCdsFileShareLinkRequest) SetPreviewLimit(v int64) *ModifyCdsFileShareLinkRequest {
	s.PreviewLimit = &v
	return s
}

func (s *ModifyCdsFileShareLinkRequest) SetReportCount(v int64) *ModifyCdsFileShareLinkRequest {
	s.ReportCount = &v
	return s
}

func (s *ModifyCdsFileShareLinkRequest) SetSaveCount(v int64) *ModifyCdsFileShareLinkRequest {
	s.SaveCount = &v
	return s
}

func (s *ModifyCdsFileShareLinkRequest) SetSaveLimit(v int64) *ModifyCdsFileShareLinkRequest {
	s.SaveLimit = &v
	return s
}

func (s *ModifyCdsFileShareLinkRequest) SetShareId(v string) *ModifyCdsFileShareLinkRequest {
	s.ShareId = &v
	return s
}

func (s *ModifyCdsFileShareLinkRequest) SetShareName(v string) *ModifyCdsFileShareLinkRequest {
	s.ShareName = &v
	return s
}

func (s *ModifyCdsFileShareLinkRequest) SetSharePwd(v string) *ModifyCdsFileShareLinkRequest {
	s.SharePwd = &v
	return s
}

func (s *ModifyCdsFileShareLinkRequest) SetStatus(v string) *ModifyCdsFileShareLinkRequest {
	s.Status = &v
	return s
}

func (s *ModifyCdsFileShareLinkRequest) SetVideoPreviewCount(v int64) *ModifyCdsFileShareLinkRequest {
	s.VideoPreviewCount = &v
	return s
}

type ModifyCdsFileShareLinkResponseBody struct {
	// The modification result. The value success indicates that the modification is successful. If the modification failed, an error message is returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data information.
	Data *CdsFileShareLinkModel `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error message that is returned. This parameter is not returned if the value of Code is success.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The request status.
	//
	// Valid values:
	//
	// *   true: The request is successful.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   false: The request fails.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ModifyCdsFileShareLinkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyCdsFileShareLinkResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyCdsFileShareLinkResponseBody) SetCode(v string) *ModifyCdsFileShareLinkResponseBody {
	s.Code = &v
	return s
}

func (s *ModifyCdsFileShareLinkResponseBody) SetData(v *CdsFileShareLinkModel) *ModifyCdsFileShareLinkResponseBody {
	s.Data = v
	return s
}

func (s *ModifyCdsFileShareLinkResponseBody) SetMessage(v string) *ModifyCdsFileShareLinkResponseBody {
	s.Message = &v
	return s
}

func (s *ModifyCdsFileShareLinkResponseBody) SetRequestId(v string) *ModifyCdsFileShareLinkResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyCdsFileShareLinkResponseBody) SetSuccess(v bool) *ModifyCdsFileShareLinkResponseBody {
	s.Success = &v
	return s
}

type ModifyCdsFileShareLinkResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyCdsFileShareLinkResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyCdsFileShareLinkResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyCdsFileShareLinkResponse) GoString() string {
	return s.String()
}

func (s *ModifyCdsFileShareLinkResponse) SetHeaders(v map[string]*string) *ModifyCdsFileShareLinkResponse {
	s.Headers = v
	return s
}

func (s *ModifyCdsFileShareLinkResponse) SetStatusCode(v int32) *ModifyCdsFileShareLinkResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyCdsFileShareLinkResponse) SetBody(v *ModifyCdsFileShareLinkResponseBody) *ModifyCdsFileShareLinkResponse {
	s.Body = v
	return s
}

type ModifyCloudDriveGroupsRequest struct {
	// The ID of the cloud disk in Cloud Drive Service.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	// The IDs of the teams.
	GroupId []*string `json:"GroupId,omitempty" xml:"GroupId,omitempty" type:"Repeated"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The status of the team space. Valid values:
	//
	// *   enabled
	// *   disabled
	//
	// Default value: enabled.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The total capacity of the team space.
	TotalSize *int64 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s ModifyCloudDriveGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyCloudDriveGroupsRequest) GoString() string {
	return s.String()
}

func (s *ModifyCloudDriveGroupsRequest) SetCdsId(v string) *ModifyCloudDriveGroupsRequest {
	s.CdsId = &v
	return s
}

func (s *ModifyCloudDriveGroupsRequest) SetGroupId(v []*string) *ModifyCloudDriveGroupsRequest {
	s.GroupId = v
	return s
}

func (s *ModifyCloudDriveGroupsRequest) SetRegionId(v string) *ModifyCloudDriveGroupsRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyCloudDriveGroupsRequest) SetStatus(v string) *ModifyCloudDriveGroupsRequest {
	s.Status = &v
	return s
}

func (s *ModifyCloudDriveGroupsRequest) SetTotalSize(v int64) *ModifyCloudDriveGroupsRequest {
	s.TotalSize = &v
	return s
}

type ModifyCloudDriveGroupsResponseBody struct {
	// The returned results. A value of success indicates that the operation is successful. If the operation failed, an error message is returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data information.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The message returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values: true and false.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ModifyCloudDriveGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyCloudDriveGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyCloudDriveGroupsResponseBody) SetCode(v string) *ModifyCloudDriveGroupsResponseBody {
	s.Code = &v
	return s
}

func (s *ModifyCloudDriveGroupsResponseBody) SetData(v string) *ModifyCloudDriveGroupsResponseBody {
	s.Data = &v
	return s
}

func (s *ModifyCloudDriveGroupsResponseBody) SetMessage(v string) *ModifyCloudDriveGroupsResponseBody {
	s.Message = &v
	return s
}

func (s *ModifyCloudDriveGroupsResponseBody) SetRequestId(v string) *ModifyCloudDriveGroupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyCloudDriveGroupsResponseBody) SetSuccess(v bool) *ModifyCloudDriveGroupsResponseBody {
	s.Success = &v
	return s
}

type ModifyCloudDriveGroupsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyCloudDriveGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyCloudDriveGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyCloudDriveGroupsResponse) GoString() string {
	return s.String()
}

func (s *ModifyCloudDriveGroupsResponse) SetHeaders(v map[string]*string) *ModifyCloudDriveGroupsResponse {
	s.Headers = v
	return s
}

func (s *ModifyCloudDriveGroupsResponse) SetStatusCode(v int32) *ModifyCloudDriveGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyCloudDriveGroupsResponse) SetBody(v *ModifyCloudDriveGroupsResponseBody) *ModifyCloudDriveGroupsResponse {
	s.Body = v
	return s
}

type ModifyCloudDrivePermissionRequest struct {
	// The ID of the cloud disk in Cloud Drive Service.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	// The IDs of the users who have the download permissions.
	DownloadEndUserIds []*string `json:"DownloadEndUserIds,omitempty" xml:"DownloadEndUserIds,omitempty" type:"Repeated"`
	// The IDs of the users who have the upload and download permissions.
	DownloadUploadEndUserIds []*string `json:"DownloadUploadEndUserIds,omitempty" xml:"DownloadUploadEndUserIds,omitempty" type:"Repeated"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ModifyCloudDrivePermissionRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyCloudDrivePermissionRequest) GoString() string {
	return s.String()
}

func (s *ModifyCloudDrivePermissionRequest) SetCdsId(v string) *ModifyCloudDrivePermissionRequest {
	s.CdsId = &v
	return s
}

func (s *ModifyCloudDrivePermissionRequest) SetDownloadEndUserIds(v []*string) *ModifyCloudDrivePermissionRequest {
	s.DownloadEndUserIds = v
	return s
}

func (s *ModifyCloudDrivePermissionRequest) SetDownloadUploadEndUserIds(v []*string) *ModifyCloudDrivePermissionRequest {
	s.DownloadUploadEndUserIds = v
	return s
}

func (s *ModifyCloudDrivePermissionRequest) SetRegionId(v string) *ModifyCloudDrivePermissionRequest {
	s.RegionId = &v
	return s
}

type ModifyCloudDrivePermissionResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyCloudDrivePermissionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyCloudDrivePermissionResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyCloudDrivePermissionResponseBody) SetRequestId(v string) *ModifyCloudDrivePermissionResponseBody {
	s.RequestId = &v
	return s
}

type ModifyCloudDrivePermissionResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyCloudDrivePermissionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyCloudDrivePermissionResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyCloudDrivePermissionResponse) GoString() string {
	return s.String()
}

func (s *ModifyCloudDrivePermissionResponse) SetHeaders(v map[string]*string) *ModifyCloudDrivePermissionResponse {
	s.Headers = v
	return s
}

func (s *ModifyCloudDrivePermissionResponse) SetStatusCode(v int32) *ModifyCloudDrivePermissionResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyCloudDrivePermissionResponse) SetBody(v *ModifyCloudDrivePermissionResponseBody) *ModifyCloudDrivePermissionResponse {
	s.Body = v
	return s
}

type ModifyCloudDriveUsersRequest struct {
	CdsId     *string   `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	EndUserId []*string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty" type:"Repeated"`
	RegionId  *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The status of Cloud Drive Service users.
	//
	// Valid values:
	//
	// *   disabled
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     unavailable
	//
	//     <!-- -->
	//
	// *   enabled
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     available
	//
	//     <!-- -->
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The maximum storage space of a user. Unit: bytes.
	UserMaxSize *int64 `json:"UserMaxSize,omitempty" xml:"UserMaxSize,omitempty"`
}

func (s ModifyCloudDriveUsersRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyCloudDriveUsersRequest) GoString() string {
	return s.String()
}

func (s *ModifyCloudDriveUsersRequest) SetCdsId(v string) *ModifyCloudDriveUsersRequest {
	s.CdsId = &v
	return s
}

func (s *ModifyCloudDriveUsersRequest) SetEndUserId(v []*string) *ModifyCloudDriveUsersRequest {
	s.EndUserId = v
	return s
}

func (s *ModifyCloudDriveUsersRequest) SetRegionId(v string) *ModifyCloudDriveUsersRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyCloudDriveUsersRequest) SetStatus(v string) *ModifyCloudDriveUsersRequest {
	s.Status = &v
	return s
}

func (s *ModifyCloudDriveUsersRequest) SetUserMaxSize(v int64) *ModifyCloudDriveUsersRequest {
	s.UserMaxSize = &v
	return s
}

type ModifyCloudDriveUsersResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyCloudDriveUsersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyCloudDriveUsersResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyCloudDriveUsersResponseBody) SetRequestId(v string) *ModifyCloudDriveUsersResponseBody {
	s.RequestId = &v
	return s
}

type ModifyCloudDriveUsersResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyCloudDriveUsersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyCloudDriveUsersResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyCloudDriveUsersResponse) GoString() string {
	return s.String()
}

func (s *ModifyCloudDriveUsersResponse) SetHeaders(v map[string]*string) *ModifyCloudDriveUsersResponse {
	s.Headers = v
	return s
}

func (s *ModifyCloudDriveUsersResponse) SetStatusCode(v int32) *ModifyCloudDriveUsersResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyCloudDriveUsersResponse) SetBody(v *ModifyCloudDriveUsersResponseBody) *ModifyCloudDriveUsersResponse {
	s.Body = v
	return s
}

type ModifyCustomizedListHeadersRequest struct {
	// The header of the response.
	Headers []*ModifyCustomizedListHeadersRequestHeaders `json:"Headers,omitempty" xml:"Headers,omitempty" type:"Repeated"`
	// The type of the list.
	ListType *string `json:"ListType,omitempty" xml:"ListType,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ModifyCustomizedListHeadersRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyCustomizedListHeadersRequest) GoString() string {
	return s.String()
}

func (s *ModifyCustomizedListHeadersRequest) SetHeaders(v []*ModifyCustomizedListHeadersRequestHeaders) *ModifyCustomizedListHeadersRequest {
	s.Headers = v
	return s
}

func (s *ModifyCustomizedListHeadersRequest) SetListType(v string) *ModifyCustomizedListHeadersRequest {
	s.ListType = &v
	return s
}

func (s *ModifyCustomizedListHeadersRequest) SetRegionId(v string) *ModifyCustomizedListHeadersRequest {
	s.RegionId = &v
	return s
}

type ModifyCustomizedListHeadersRequestHeaders struct {
	// The display type of the header. You can call the `ModifyCustomizedListHeaders` operation to modify the display type of the header.
	DisplayType *string `json:"DisplayType,omitempty" xml:"DisplayType,omitempty"`
	// The key of the header.
	HeaderKey *string `json:"HeaderKey,omitempty" xml:"HeaderKey,omitempty"`
}

func (s ModifyCustomizedListHeadersRequestHeaders) String() string {
	return tea.Prettify(s)
}

func (s ModifyCustomizedListHeadersRequestHeaders) GoString() string {
	return s.String()
}

func (s *ModifyCustomizedListHeadersRequestHeaders) SetDisplayType(v string) *ModifyCustomizedListHeadersRequestHeaders {
	s.DisplayType = &v
	return s
}

func (s *ModifyCustomizedListHeadersRequestHeaders) SetHeaderKey(v string) *ModifyCustomizedListHeadersRequestHeaders {
	s.HeaderKey = &v
	return s
}

type ModifyCustomizedListHeadersResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyCustomizedListHeadersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyCustomizedListHeadersResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyCustomizedListHeadersResponseBody) SetRequestId(v string) *ModifyCustomizedListHeadersResponseBody {
	s.RequestId = &v
	return s
}

type ModifyCustomizedListHeadersResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyCustomizedListHeadersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyCustomizedListHeadersResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyCustomizedListHeadersResponse) GoString() string {
	return s.String()
}

func (s *ModifyCustomizedListHeadersResponse) SetHeaders(v map[string]*string) *ModifyCustomizedListHeadersResponse {
	s.Headers = v
	return s
}

func (s *ModifyCustomizedListHeadersResponse) SetStatusCode(v int32) *ModifyCustomizedListHeadersResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyCustomizedListHeadersResponse) SetBody(v *ModifyCustomizedListHeadersResponseBody) *ModifyCustomizedListHeadersResponse {
	s.Body = v
	return s
}

type ModifyDesktopChargeTypeRequest struct {
	// The IDs of the cloud desktops. You can specify 1 to 20 IDs.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The ID of the sales promotion.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	DesktopId []*string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty" type:"Repeated"`
	// Specifies whether to enable automatic payment if you specify subscription as the new billing method for the cloud desktop.
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The IDs of the desktop groups. If multiple cloud desktops are created at a time, multiple cloud desktop IDs are returned.
	PeriodUnit *string `json:"PeriodUnit,omitempty" xml:"PeriodUnit,omitempty"`
	// The unit of the subscription duration if you specify subscription as the new billing method for the cloud desktop.
	PromotionId *string `json:"PromotionId,omitempty" xml:"PromotionId,omitempty"`
	// The subscription duration if you specify subscription as the new billing method for the cloud desktop. The unit of the value is specified by the `PeriodUnit` parameter. This parameter takes effect only when the `ChargeType` parameter is set to `PrePaid`.
	//
	// *   If the `PeriodUnit` parameter is set to `Week`, the valid value of the Period parameter is 1.
	// *   If the `PeriodUnit` parameter is set to `Month`, the valid values of the Period parameter are 1, 2, 3, and 6.
	// *   If the `PeriodUnit` parameter is set to `Year`, the valid values of the Period parameter are 1, 2, 3, 4, and 5.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// >  This parameter is in invitational preview and not available to the public.
	UseDuration *int32 `json:"UseDuration,omitempty" xml:"UseDuration,omitempty"`
}

func (s ModifyDesktopChargeTypeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopChargeTypeRequest) GoString() string {
	return s.String()
}

func (s *ModifyDesktopChargeTypeRequest) SetAutoPay(v bool) *ModifyDesktopChargeTypeRequest {
	s.AutoPay = &v
	return s
}

func (s *ModifyDesktopChargeTypeRequest) SetChargeType(v string) *ModifyDesktopChargeTypeRequest {
	s.ChargeType = &v
	return s
}

func (s *ModifyDesktopChargeTypeRequest) SetDesktopId(v []*string) *ModifyDesktopChargeTypeRequest {
	s.DesktopId = v
	return s
}

func (s *ModifyDesktopChargeTypeRequest) SetPeriod(v int32) *ModifyDesktopChargeTypeRequest {
	s.Period = &v
	return s
}

func (s *ModifyDesktopChargeTypeRequest) SetPeriodUnit(v string) *ModifyDesktopChargeTypeRequest {
	s.PeriodUnit = &v
	return s
}

func (s *ModifyDesktopChargeTypeRequest) SetPromotionId(v string) *ModifyDesktopChargeTypeRequest {
	s.PromotionId = &v
	return s
}

func (s *ModifyDesktopChargeTypeRequest) SetRegionId(v string) *ModifyDesktopChargeTypeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyDesktopChargeTypeRequest) SetUseDuration(v int32) *ModifyDesktopChargeTypeRequest {
	s.UseDuration = &v
	return s
}

type ModifyDesktopChargeTypeResponseBody struct {
	DesktopId []*string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty" type:"Repeated"`
	// The ID of the cloud desktop.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// Change the billing method of a cloud desktop
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDesktopChargeTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopChargeTypeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDesktopChargeTypeResponseBody) SetDesktopId(v []*string) *ModifyDesktopChargeTypeResponseBody {
	s.DesktopId = v
	return s
}

func (s *ModifyDesktopChargeTypeResponseBody) SetOrderId(v string) *ModifyDesktopChargeTypeResponseBody {
	s.OrderId = &v
	return s
}

func (s *ModifyDesktopChargeTypeResponseBody) SetRequestId(v string) *ModifyDesktopChargeTypeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDesktopChargeTypeResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDesktopChargeTypeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDesktopChargeTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopChargeTypeResponse) GoString() string {
	return s.String()
}

func (s *ModifyDesktopChargeTypeResponse) SetHeaders(v map[string]*string) *ModifyDesktopChargeTypeResponse {
	s.Headers = v
	return s
}

func (s *ModifyDesktopChargeTypeResponse) SetStatusCode(v int32) *ModifyDesktopChargeTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDesktopChargeTypeResponse) SetBody(v *ModifyDesktopChargeTypeResponseBody) *ModifyDesktopChargeTypeResponse {
	s.Body = v
	return s
}

type ModifyDesktopGroupRequest struct {
	// Specifies whether to automatically create cloud desktops in the desktop group if you set the billing method to subscription. If you set the ChargeType parameter to PrePaid, this parameter is required. Valid values:
	//
	// *   0: does not create cloud desktops in the desktop group.
	// *   1: creates cloud desktops in the desktop group.
	AllowAutoSetup *int32 `json:"AllowAutoSetup,omitempty" xml:"AllowAutoSetup,omitempty"`
	// Specifies whether to reserve cloud desktops if you set the billing method to pay-as-you-go. If you set the ChargeType parameter to PostPaid, this parameter is required. Valid values: 0: does not reserve cloud desktops. N: reserves N cloud desktops. Valid values of N: 1 to the value of the MaxDesktopsCount parameter.
	AllowBufferCount *int32 `json:"AllowBufferCount,omitempty" xml:"AllowBufferCount,omitempty"`
	// The maximum number of sessions per cloud desktop in the multi-session desktop group.
	BindAmount *int64 `json:"BindAmount,omitempty" xml:"BindAmount,omitempty"`
	// The number of cloud desktops to purchase. Valid values: 0 to 200.
	BuyDesktopsCount *int32 `json:"BuyDesktopsCount,omitempty" xml:"BuyDesktopsCount,omitempty"`
	// The classification of the cloud desktop pool.
	Classify *string `json:"Classify,omitempty" xml:"Classify,omitempty"`
	// The remarks on the desktop group.
	Comments *string `json:"Comments,omitempty" xml:"Comments,omitempty"`
	// The maximum duration of the session. Unit: milliseconds.
	ConnectDuration *int64 `json:"ConnectDuration,omitempty" xml:"ConnectDuration,omitempty"`
	// The ID of the desktop group.
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// The name of the desktop group.
	DesktopGroupName *string `json:"DesktopGroupName,omitempty" xml:"DesktopGroupName,omitempty"`
	// Specifies whether to disable session management.
	DisableSessionConfig *bool `json:"DisableSessionConfig,omitempty" xml:"DisableSessionConfig,omitempty"`
	// The ID of the Apsara File Storage NAS (NAS) file system.
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The maximum duration of the idle session. Unit: milliseconds.
	IdleDisconnectDuration *int64 `json:"IdleDisconnectDuration,omitempty" xml:"IdleDisconnectDuration,omitempty"`
	// The IDs of the images.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The retention period of cloud desktops in the desktop group after end users disconnect from the desktops. Unit: ms.
	KeepDuration *int64 `json:"KeepDuration,omitempty" xml:"KeepDuration,omitempty"`
	// The load balancing policy of the multi-session desktop group.
	LoadPolicy *int64 `json:"LoadPolicy,omitempty" xml:"LoadPolicy,omitempty"`
	// The maximum number of cloud desktops that the desktop group can contain. Valid values: 0 to 200.
	MaxDesktopsCount *int32 `json:"MaxDesktopsCount,omitempty" xml:"MaxDesktopsCount,omitempty"`
	// The minimum number of cloud desktops that must be contained in the desktop group if you set the billing method to subscription. If you set the ChargeType parameter to PrePaid, this parameter is required. Valid values: 0 to the value of MaxDesktopsCount. Default value: 1.
	MinDesktopsCount *int32 `json:"MinDesktopsCount,omitempty" xml:"MinDesktopsCount,omitempty"`
	// The ID of the cloud desktop template.
	OwnBundleId *string `json:"OwnBundleId,omitempty" xml:"OwnBundleId,omitempty"`
	// The ID of the security policy.
	PolicyGroupId *string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty"`
	// The IDs of policy groups.
	PolicyGroupIds []*string `json:"PolicyGroupIds,omitempty" xml:"PolicyGroupIds,omitempty" type:"Repeated"`
	// Specifies whether to enable data roaming.
	ProfileFollowSwitch *bool `json:"ProfileFollowSwitch,omitempty" xml:"ProfileFollowSwitch,omitempty"`
	// The session usage threshold for the multi-session desktop group that has an auto scaling policy in effect.
	RatioThreshold *float32 `json:"RatioThreshold,omitempty" xml:"RatioThreshold,omitempty"`
	// The region ID of the desktop group.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Specifies which type of disk to reset for cloud desktops in the desktop group.
	ResetType *int64 `json:"ResetType,omitempty" xml:"ResetType,omitempty"`
	// The ID of the scaling policy group.
	//
	// >  This parameter is unavailable.
	ScaleStrategyId *string `json:"ScaleStrategyId,omitempty" xml:"ScaleStrategyId,omitempty"`
	// The duration before an idle cloud desktop is stopped. Unit: milliseconds.
	StopDuration *int64 `json:"StopDuration,omitempty" xml:"StopDuration,omitempty"`
}

func (s ModifyDesktopGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopGroupRequest) GoString() string {
	return s.String()
}

func (s *ModifyDesktopGroupRequest) SetAllowAutoSetup(v int32) *ModifyDesktopGroupRequest {
	s.AllowAutoSetup = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetAllowBufferCount(v int32) *ModifyDesktopGroupRequest {
	s.AllowBufferCount = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetBindAmount(v int64) *ModifyDesktopGroupRequest {
	s.BindAmount = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetBuyDesktopsCount(v int32) *ModifyDesktopGroupRequest {
	s.BuyDesktopsCount = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetClassify(v string) *ModifyDesktopGroupRequest {
	s.Classify = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetComments(v string) *ModifyDesktopGroupRequest {
	s.Comments = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetConnectDuration(v int64) *ModifyDesktopGroupRequest {
	s.ConnectDuration = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetDesktopGroupId(v string) *ModifyDesktopGroupRequest {
	s.DesktopGroupId = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetDesktopGroupName(v string) *ModifyDesktopGroupRequest {
	s.DesktopGroupName = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetDisableSessionConfig(v bool) *ModifyDesktopGroupRequest {
	s.DisableSessionConfig = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetFileSystemId(v string) *ModifyDesktopGroupRequest {
	s.FileSystemId = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetIdleDisconnectDuration(v int64) *ModifyDesktopGroupRequest {
	s.IdleDisconnectDuration = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetImageId(v string) *ModifyDesktopGroupRequest {
	s.ImageId = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetKeepDuration(v int64) *ModifyDesktopGroupRequest {
	s.KeepDuration = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetLoadPolicy(v int64) *ModifyDesktopGroupRequest {
	s.LoadPolicy = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetMaxDesktopsCount(v int32) *ModifyDesktopGroupRequest {
	s.MaxDesktopsCount = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetMinDesktopsCount(v int32) *ModifyDesktopGroupRequest {
	s.MinDesktopsCount = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetOwnBundleId(v string) *ModifyDesktopGroupRequest {
	s.OwnBundleId = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetPolicyGroupId(v string) *ModifyDesktopGroupRequest {
	s.PolicyGroupId = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetPolicyGroupIds(v []*string) *ModifyDesktopGroupRequest {
	s.PolicyGroupIds = v
	return s
}

func (s *ModifyDesktopGroupRequest) SetProfileFollowSwitch(v bool) *ModifyDesktopGroupRequest {
	s.ProfileFollowSwitch = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetRatioThreshold(v float32) *ModifyDesktopGroupRequest {
	s.RatioThreshold = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetRegionId(v string) *ModifyDesktopGroupRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetResetType(v int64) *ModifyDesktopGroupRequest {
	s.ResetType = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetScaleStrategyId(v string) *ModifyDesktopGroupRequest {
	s.ScaleStrategyId = &v
	return s
}

func (s *ModifyDesktopGroupRequest) SetStopDuration(v int64) *ModifyDesktopGroupRequest {
	s.StopDuration = &v
	return s
}

type ModifyDesktopGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDesktopGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDesktopGroupResponseBody) SetRequestId(v string) *ModifyDesktopGroupResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDesktopGroupResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDesktopGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDesktopGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopGroupResponse) GoString() string {
	return s.String()
}

func (s *ModifyDesktopGroupResponse) SetHeaders(v map[string]*string) *ModifyDesktopGroupResponse {
	s.Headers = v
	return s
}

func (s *ModifyDesktopGroupResponse) SetStatusCode(v int32) *ModifyDesktopGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDesktopGroupResponse) SetBody(v *ModifyDesktopGroupResponseBody) *ModifyDesktopGroupResponse {
	s.Body = v
	return s
}

type ModifyDesktopHostNameRequest struct {
	// The cloud desktop ID.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The new hostname of the cloud desktop. The hostname must meet the following requirements:
	//
	// *   It must be 2 to 15 characters in length.
	// *   It can contain letters, digits, and hyphens (-). The hostname cannot start or end with a hyphen (-), contain consecutive hyphens (-), or contain only digits.
	NewHostName *string `json:"NewHostName,omitempty" xml:"NewHostName,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ModifyDesktopHostNameRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopHostNameRequest) GoString() string {
	return s.String()
}

func (s *ModifyDesktopHostNameRequest) SetDesktopId(v string) *ModifyDesktopHostNameRequest {
	s.DesktopId = &v
	return s
}

func (s *ModifyDesktopHostNameRequest) SetNewHostName(v string) *ModifyDesktopHostNameRequest {
	s.NewHostName = &v
	return s
}

func (s *ModifyDesktopHostNameRequest) SetRegionId(v string) *ModifyDesktopHostNameRequest {
	s.RegionId = &v
	return s
}

type ModifyDesktopHostNameResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDesktopHostNameResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopHostNameResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDesktopHostNameResponseBody) SetRequestId(v string) *ModifyDesktopHostNameResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDesktopHostNameResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDesktopHostNameResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDesktopHostNameResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopHostNameResponse) GoString() string {
	return s.String()
}

func (s *ModifyDesktopHostNameResponse) SetHeaders(v map[string]*string) *ModifyDesktopHostNameResponse {
	s.Headers = v
	return s
}

func (s *ModifyDesktopHostNameResponse) SetStatusCode(v int32) *ModifyDesktopHostNameResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDesktopHostNameResponse) SetBody(v *ModifyDesktopHostNameResponseBody) *ModifyDesktopHostNameResponse {
	s.Body = v
	return s
}

type ModifyDesktopNameRequest struct {
	// The cloud computer ID.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The new name of the cloud desktop. The name of the cloud desktop must meet the following requirements:
	//
	// *   The name must be 1 to 64 characters in length.
	// *   The name must start with a letter but cannot start with `http://` or `https://`.
	// *   It can contain letters, digits, colons (:), underscores (\_), periods (.), and hyphens (-).
	NewDesktopName *string `json:"NewDesktopName,omitempty" xml:"NewDesktopName,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ModifyDesktopNameRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopNameRequest) GoString() string {
	return s.String()
}

func (s *ModifyDesktopNameRequest) SetDesktopId(v string) *ModifyDesktopNameRequest {
	s.DesktopId = &v
	return s
}

func (s *ModifyDesktopNameRequest) SetNewDesktopName(v string) *ModifyDesktopNameRequest {
	s.NewDesktopName = &v
	return s
}

func (s *ModifyDesktopNameRequest) SetRegionId(v string) *ModifyDesktopNameRequest {
	s.RegionId = &v
	return s
}

type ModifyDesktopNameResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDesktopNameResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopNameResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDesktopNameResponseBody) SetRequestId(v string) *ModifyDesktopNameResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDesktopNameResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDesktopNameResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDesktopNameResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopNameResponse) GoString() string {
	return s.String()
}

func (s *ModifyDesktopNameResponse) SetHeaders(v map[string]*string) *ModifyDesktopNameResponse {
	s.Headers = v
	return s
}

func (s *ModifyDesktopNameResponse) SetStatusCode(v int32) *ModifyDesktopNameResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDesktopNameResponse) SetBody(v *ModifyDesktopNameResponseBody) *ModifyDesktopNameResponse {
	s.Body = v
	return s
}

type ModifyDesktopOversoldGroupRequest struct {
	ConcurrenceCount  *int32  `json:"ConcurrenceCount,omitempty" xml:"ConcurrenceCount,omitempty"`
	Description       *string `json:"Description,omitempty" xml:"Description,omitempty"`
	ImageId           *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	Name              *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OversoldGroupId   *string `json:"OversoldGroupId,omitempty" xml:"OversoldGroupId,omitempty"`
	OversoldUserCount *int32  `json:"OversoldUserCount,omitempty" xml:"OversoldUserCount,omitempty"`
	OversoldWarn      *int32  `json:"OversoldWarn,omitempty" xml:"OversoldWarn,omitempty"`
	PolicyGroupId     *string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty"`
	StopDuration      *int32  `json:"StopDuration,omitempty" xml:"StopDuration,omitempty"`
}

func (s ModifyDesktopOversoldGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopOversoldGroupRequest) GoString() string {
	return s.String()
}

func (s *ModifyDesktopOversoldGroupRequest) SetConcurrenceCount(v int32) *ModifyDesktopOversoldGroupRequest {
	s.ConcurrenceCount = &v
	return s
}

func (s *ModifyDesktopOversoldGroupRequest) SetDescription(v string) *ModifyDesktopOversoldGroupRequest {
	s.Description = &v
	return s
}

func (s *ModifyDesktopOversoldGroupRequest) SetImageId(v string) *ModifyDesktopOversoldGroupRequest {
	s.ImageId = &v
	return s
}

func (s *ModifyDesktopOversoldGroupRequest) SetName(v string) *ModifyDesktopOversoldGroupRequest {
	s.Name = &v
	return s
}

func (s *ModifyDesktopOversoldGroupRequest) SetOversoldGroupId(v string) *ModifyDesktopOversoldGroupRequest {
	s.OversoldGroupId = &v
	return s
}

func (s *ModifyDesktopOversoldGroupRequest) SetOversoldUserCount(v int32) *ModifyDesktopOversoldGroupRequest {
	s.OversoldUserCount = &v
	return s
}

func (s *ModifyDesktopOversoldGroupRequest) SetOversoldWarn(v int32) *ModifyDesktopOversoldGroupRequest {
	s.OversoldWarn = &v
	return s
}

func (s *ModifyDesktopOversoldGroupRequest) SetPolicyGroupId(v string) *ModifyDesktopOversoldGroupRequest {
	s.PolicyGroupId = &v
	return s
}

func (s *ModifyDesktopOversoldGroupRequest) SetStopDuration(v int32) *ModifyDesktopOversoldGroupRequest {
	s.StopDuration = &v
	return s
}

type ModifyDesktopOversoldGroupResponseBody struct {
	Data      *ModifyDesktopOversoldGroupResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	RequestId *string                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDesktopOversoldGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopOversoldGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDesktopOversoldGroupResponseBody) SetData(v *ModifyDesktopOversoldGroupResponseBodyData) *ModifyDesktopOversoldGroupResponseBody {
	s.Data = v
	return s
}

func (s *ModifyDesktopOversoldGroupResponseBody) SetRequestId(v string) *ModifyDesktopOversoldGroupResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDesktopOversoldGroupResponseBodyData struct {
	OversoldGroupId *string `json:"OversoldGroupId,omitempty" xml:"OversoldGroupId,omitempty"`
}

func (s ModifyDesktopOversoldGroupResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopOversoldGroupResponseBodyData) GoString() string {
	return s.String()
}

func (s *ModifyDesktopOversoldGroupResponseBodyData) SetOversoldGroupId(v string) *ModifyDesktopOversoldGroupResponseBodyData {
	s.OversoldGroupId = &v
	return s
}

type ModifyDesktopOversoldGroupResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDesktopOversoldGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDesktopOversoldGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopOversoldGroupResponse) GoString() string {
	return s.String()
}

func (s *ModifyDesktopOversoldGroupResponse) SetHeaders(v map[string]*string) *ModifyDesktopOversoldGroupResponse {
	s.Headers = v
	return s
}

func (s *ModifyDesktopOversoldGroupResponse) SetStatusCode(v int32) *ModifyDesktopOversoldGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDesktopOversoldGroupResponse) SetBody(v *ModifyDesktopOversoldGroupResponseBody) *ModifyDesktopOversoldGroupResponse {
	s.Body = v
	return s
}

type ModifyDesktopOversoldGroupSaleRequest struct {
	ConcurrenceCount  *int32  `json:"ConcurrenceCount,omitempty" xml:"ConcurrenceCount,omitempty"`
	OversoldGroupId   *string `json:"OversoldGroupId,omitempty" xml:"OversoldGroupId,omitempty"`
	OversoldUserCount *int32  `json:"OversoldUserCount,omitempty" xml:"OversoldUserCount,omitempty"`
}

func (s ModifyDesktopOversoldGroupSaleRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopOversoldGroupSaleRequest) GoString() string {
	return s.String()
}

func (s *ModifyDesktopOversoldGroupSaleRequest) SetConcurrenceCount(v int32) *ModifyDesktopOversoldGroupSaleRequest {
	s.ConcurrenceCount = &v
	return s
}

func (s *ModifyDesktopOversoldGroupSaleRequest) SetOversoldGroupId(v string) *ModifyDesktopOversoldGroupSaleRequest {
	s.OversoldGroupId = &v
	return s
}

func (s *ModifyDesktopOversoldGroupSaleRequest) SetOversoldUserCount(v int32) *ModifyDesktopOversoldGroupSaleRequest {
	s.OversoldUserCount = &v
	return s
}

type ModifyDesktopOversoldGroupSaleResponseBody struct {
	Data      *ModifyDesktopOversoldGroupSaleResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	RequestId *string                                         `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDesktopOversoldGroupSaleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopOversoldGroupSaleResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDesktopOversoldGroupSaleResponseBody) SetData(v *ModifyDesktopOversoldGroupSaleResponseBodyData) *ModifyDesktopOversoldGroupSaleResponseBody {
	s.Data = v
	return s
}

func (s *ModifyDesktopOversoldGroupSaleResponseBody) SetRequestId(v string) *ModifyDesktopOversoldGroupSaleResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDesktopOversoldGroupSaleResponseBodyData struct {
	OrderId         *int64  `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	OversoldGroupId *string `json:"OversoldGroupId,omitempty" xml:"OversoldGroupId,omitempty"`
}

func (s ModifyDesktopOversoldGroupSaleResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopOversoldGroupSaleResponseBodyData) GoString() string {
	return s.String()
}

func (s *ModifyDesktopOversoldGroupSaleResponseBodyData) SetOrderId(v int64) *ModifyDesktopOversoldGroupSaleResponseBodyData {
	s.OrderId = &v
	return s
}

func (s *ModifyDesktopOversoldGroupSaleResponseBodyData) SetOversoldGroupId(v string) *ModifyDesktopOversoldGroupSaleResponseBodyData {
	s.OversoldGroupId = &v
	return s
}

type ModifyDesktopOversoldGroupSaleResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDesktopOversoldGroupSaleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDesktopOversoldGroupSaleResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopOversoldGroupSaleResponse) GoString() string {
	return s.String()
}

func (s *ModifyDesktopOversoldGroupSaleResponse) SetHeaders(v map[string]*string) *ModifyDesktopOversoldGroupSaleResponse {
	s.Headers = v
	return s
}

func (s *ModifyDesktopOversoldGroupSaleResponse) SetStatusCode(v int32) *ModifyDesktopOversoldGroupSaleResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDesktopOversoldGroupSaleResponse) SetBody(v *ModifyDesktopOversoldGroupSaleResponseBody) *ModifyDesktopOversoldGroupSaleResponse {
	s.Body = v
	return s
}

type ModifyDesktopOversoldUserGroupRequest struct {
	ImageId         *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	Name            *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OversoldGroupId *string `json:"OversoldGroupId,omitempty" xml:"OversoldGroupId,omitempty"`
	PolicyGroupId   *string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty"`
	UserGroupId     *string `json:"UserGroupId,omitempty" xml:"UserGroupId,omitempty"`
}

func (s ModifyDesktopOversoldUserGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopOversoldUserGroupRequest) GoString() string {
	return s.String()
}

func (s *ModifyDesktopOversoldUserGroupRequest) SetImageId(v string) *ModifyDesktopOversoldUserGroupRequest {
	s.ImageId = &v
	return s
}

func (s *ModifyDesktopOversoldUserGroupRequest) SetName(v string) *ModifyDesktopOversoldUserGroupRequest {
	s.Name = &v
	return s
}

func (s *ModifyDesktopOversoldUserGroupRequest) SetOversoldGroupId(v string) *ModifyDesktopOversoldUserGroupRequest {
	s.OversoldGroupId = &v
	return s
}

func (s *ModifyDesktopOversoldUserGroupRequest) SetPolicyGroupId(v string) *ModifyDesktopOversoldUserGroupRequest {
	s.PolicyGroupId = &v
	return s
}

func (s *ModifyDesktopOversoldUserGroupRequest) SetUserGroupId(v string) *ModifyDesktopOversoldUserGroupRequest {
	s.UserGroupId = &v
	return s
}

type ModifyDesktopOversoldUserGroupResponseBody struct {
	Data      *ModifyDesktopOversoldUserGroupResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	RequestId *string                                         `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDesktopOversoldUserGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopOversoldUserGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDesktopOversoldUserGroupResponseBody) SetData(v *ModifyDesktopOversoldUserGroupResponseBodyData) *ModifyDesktopOversoldUserGroupResponseBody {
	s.Data = v
	return s
}

func (s *ModifyDesktopOversoldUserGroupResponseBody) SetRequestId(v string) *ModifyDesktopOversoldUserGroupResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDesktopOversoldUserGroupResponseBodyData struct {
	UserGroupId *string `json:"UserGroupId,omitempty" xml:"UserGroupId,omitempty"`
}

func (s ModifyDesktopOversoldUserGroupResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopOversoldUserGroupResponseBodyData) GoString() string {
	return s.String()
}

func (s *ModifyDesktopOversoldUserGroupResponseBodyData) SetUserGroupId(v string) *ModifyDesktopOversoldUserGroupResponseBodyData {
	s.UserGroupId = &v
	return s
}

type ModifyDesktopOversoldUserGroupResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDesktopOversoldUserGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDesktopOversoldUserGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopOversoldUserGroupResponse) GoString() string {
	return s.String()
}

func (s *ModifyDesktopOversoldUserGroupResponse) SetHeaders(v map[string]*string) *ModifyDesktopOversoldUserGroupResponse {
	s.Headers = v
	return s
}

func (s *ModifyDesktopOversoldUserGroupResponse) SetStatusCode(v int32) *ModifyDesktopOversoldUserGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDesktopOversoldUserGroupResponse) SetBody(v *ModifyDesktopOversoldUserGroupResponseBody) *ModifyDesktopOversoldUserGroupResponse {
	s.Body = v
	return s
}

type ModifyDesktopSpecRequest struct {
	// Specifies whether to automatically complete the payment. Valid values:
	//
	// *   `true`: automatically completes the payment. Make sure that your Alibaba Cloud account has sufficient balance. If your Alibaba Cloud account does not have sufficient balance, abnormal orders are generated.
	// *   `false`: does not automatically complete the payment. In this case, an order is generated, but no payment is made. You can log on to the EDS console and complete the payment based on the order ID on the **Orders** page.
	//
	// Default value: `true`.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The ID of the cloud desktop.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The new cloud desktop type. You can call the [DescribeDesktopTypes](~~188882~~) operation to query the IDs of supported cloud desktop types.
	DesktopType *string `json:"DesktopType,omitempty" xml:"DesktopType,omitempty"`
	// The ID of the sales promotion.
	PromotionId *string `json:"PromotionId,omitempty" xml:"PromotionId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The size of the new system disk. Unit: GiB. Valid values: 80 to 500 GiB. The value must be a multiple of 10.
	RootDiskSizeGib *int32 `json:"RootDiskSizeGib,omitempty" xml:"RootDiskSizeGib,omitempty"`
	// The performance level (PL) of the data disk. Valid values:
	//
	// *   PL0
	// *   PL1
	// *   PL2
	// *   PL3
	//
	// Default value: PL0.
	UserDiskPerformanceLevel *string `json:"UserDiskPerformanceLevel,omitempty" xml:"UserDiskPerformanceLevel,omitempty"`
	// The size of the new data disk. Unit: GiB.
	//
	// *   The data disk size of a non-Graphics cloud desktop can be within the range of 20 to 1,020 GiB. The value must be a multiple of 10.
	// *   The data disk size of the Graphics cloud desktop can be within the range of 40 to 1,020 GiB. The value must be a multiple of 10.
	UserDiskSizeGib *int32 `json:"UserDiskSizeGib,omitempty" xml:"UserDiskSizeGib,omitempty"`
}

func (s ModifyDesktopSpecRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopSpecRequest) GoString() string {
	return s.String()
}

func (s *ModifyDesktopSpecRequest) SetAutoPay(v bool) *ModifyDesktopSpecRequest {
	s.AutoPay = &v
	return s
}

func (s *ModifyDesktopSpecRequest) SetDesktopId(v string) *ModifyDesktopSpecRequest {
	s.DesktopId = &v
	return s
}

func (s *ModifyDesktopSpecRequest) SetDesktopType(v string) *ModifyDesktopSpecRequest {
	s.DesktopType = &v
	return s
}

func (s *ModifyDesktopSpecRequest) SetPromotionId(v string) *ModifyDesktopSpecRequest {
	s.PromotionId = &v
	return s
}

func (s *ModifyDesktopSpecRequest) SetRegionId(v string) *ModifyDesktopSpecRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyDesktopSpecRequest) SetRootDiskSizeGib(v int32) *ModifyDesktopSpecRequest {
	s.RootDiskSizeGib = &v
	return s
}

func (s *ModifyDesktopSpecRequest) SetUserDiskPerformanceLevel(v string) *ModifyDesktopSpecRequest {
	s.UserDiskPerformanceLevel = &v
	return s
}

func (s *ModifyDesktopSpecRequest) SetUserDiskSizeGib(v int32) *ModifyDesktopSpecRequest {
	s.UserDiskSizeGib = &v
	return s
}

type ModifyDesktopSpecResponseBody struct {
	// The ID of the order.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDesktopSpecResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopSpecResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDesktopSpecResponseBody) SetOrderId(v string) *ModifyDesktopSpecResponseBody {
	s.OrderId = &v
	return s
}

func (s *ModifyDesktopSpecResponseBody) SetRequestId(v string) *ModifyDesktopSpecResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDesktopSpecResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDesktopSpecResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDesktopSpecResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopSpecResponse) GoString() string {
	return s.String()
}

func (s *ModifyDesktopSpecResponse) SetHeaders(v map[string]*string) *ModifyDesktopSpecResponse {
	s.Headers = v
	return s
}

func (s *ModifyDesktopSpecResponse) SetStatusCode(v int32) *ModifyDesktopSpecResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDesktopSpecResponse) SetBody(v *ModifyDesktopSpecResponseBody) *ModifyDesktopSpecResponse {
	s.Body = v
	return s
}

type ModifyDesktopTimerRequest struct {
	// The cloud computer ID. You can specify 1 to 20 IDs.
	DesktopId []*string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty" type:"Repeated"`
	// The details of the scheduled task for the cloud desktops.
	DesktopTimers []*ModifyDesktopTimerRequestDesktopTimers `json:"DesktopTimers,omitempty" xml:"DesktopTimers,omitempty" type:"Repeated"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Specifies whether to use DesktopTimers. If you want to use a timer, **set this parameter to true**.
	UseDesktopTimers *bool `json:"UseDesktopTimers,omitempty" xml:"UseDesktopTimers,omitempty"`
}

func (s ModifyDesktopTimerRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopTimerRequest) GoString() string {
	return s.String()
}

func (s *ModifyDesktopTimerRequest) SetDesktopId(v []*string) *ModifyDesktopTimerRequest {
	s.DesktopId = v
	return s
}

func (s *ModifyDesktopTimerRequest) SetDesktopTimers(v []*ModifyDesktopTimerRequestDesktopTimers) *ModifyDesktopTimerRequest {
	s.DesktopTimers = v
	return s
}

func (s *ModifyDesktopTimerRequest) SetRegionId(v string) *ModifyDesktopTimerRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyDesktopTimerRequest) SetUseDesktopTimers(v bool) *ModifyDesktopTimerRequest {
	s.UseDesktopTimers = &v
	return s
}

type ModifyDesktopTimerRequestDesktopTimers struct {
	// Specifies whether to allow end users to configure scheduled tasks on an Alibaba Cloud Workspace client.
	AllowClientSetting *bool `json:"AllowClientSetting,omitempty" xml:"AllowClientSetting,omitempty"`
	// The cron expression of the scheduled task.
	//
	// >  You must specify the time in UTC format. For example, if you want to specify 00:00 of UTC+8, use the following cron expression: 0 0 16. \* 1,2,3,4,5,6,7
	CronExpression *string `json:"CronExpression,omitempty" xml:"CronExpression,omitempty"`
	// Specifies whether to forcefully execute the scheduled task. A value of true indicates that the system forcefully executes the scheduled task regardless of the connection status of the cloud desktop.
	Enforce *bool `json:"Enforce,omitempty" xml:"Enforce,omitempty"`
	// The interval. Unit: minutes.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The type of the scheduled operation. This parameter is valid only when TimerType is set to NoConnect.
	//
	// Valid values:
	//
	// *   Hibernate
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     hibernates the cloud desktops
	//
	//     <!-- -->
	//
	//     .
	//
	// *   Shutdown
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     stops the cloud desktops
	//
	//     <!-- -->
	//
	//     .
	OperationType *string `json:"OperationType,omitempty" xml:"OperationType,omitempty"`
	// Indicates which type of disk that is used by the cloud desktop is reset.
	//
	// Valid values:
	//
	// *   RESET_TYPE_SYSTEM
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     resets the system disks
	//
	//     <!-- -->
	//
	//     .
	//
	// *   RESET_TYPE_BOTH
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     resets the data disks and system disks.
	//
	//     <!-- -->
	ResetType *string `json:"ResetType,omitempty" xml:"ResetType,omitempty"`
	// The type of the scheduled task.
	//
	// Valid values:
	//
	// *   NoOperationDisconnect: Disconnects the cloud desktops when no operations are performed on the cloud desktops.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   LogoutShutdown: Stops the cloud desktops when end users log out of Alibaba Cloud Workspace clients.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   NoConnect: Disconnets the cloud desktops when end users perform one of the actions that is specified by the OperationType parameter.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   TimerBoot: Starts the cloud desktops at a scheduled point in time.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   TimerReset: Resets the cloud desktops at a scheduled point in time.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   LoginAutoConnect: automatically connects to cloud desktops when end users log on to Alibaba Cloud Workspace clients.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   NoOperationShutdown: Stops the cloud desktops when no operations are performed on the cloud desktops.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   TimerShutdown: Stops the cloud desktops at a scheduled point in time.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   NoOperationReboot: Restarts the cloud desktops when no operations are performed on the cloud desktops.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   TimerReboot: Restarts the cloud desktops at a scheduled point in time.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	TimerType *string `json:"TimerType,omitempty" xml:"TimerType,omitempty"`
}

func (s ModifyDesktopTimerRequestDesktopTimers) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopTimerRequestDesktopTimers) GoString() string {
	return s.String()
}

func (s *ModifyDesktopTimerRequestDesktopTimers) SetAllowClientSetting(v bool) *ModifyDesktopTimerRequestDesktopTimers {
	s.AllowClientSetting = &v
	return s
}

func (s *ModifyDesktopTimerRequestDesktopTimers) SetCronExpression(v string) *ModifyDesktopTimerRequestDesktopTimers {
	s.CronExpression = &v
	return s
}

func (s *ModifyDesktopTimerRequestDesktopTimers) SetEnforce(v bool) *ModifyDesktopTimerRequestDesktopTimers {
	s.Enforce = &v
	return s
}

func (s *ModifyDesktopTimerRequestDesktopTimers) SetInterval(v int32) *ModifyDesktopTimerRequestDesktopTimers {
	s.Interval = &v
	return s
}

func (s *ModifyDesktopTimerRequestDesktopTimers) SetOperationType(v string) *ModifyDesktopTimerRequestDesktopTimers {
	s.OperationType = &v
	return s
}

func (s *ModifyDesktopTimerRequestDesktopTimers) SetResetType(v string) *ModifyDesktopTimerRequestDesktopTimers {
	s.ResetType = &v
	return s
}

func (s *ModifyDesktopTimerRequestDesktopTimers) SetTimerType(v string) *ModifyDesktopTimerRequestDesktopTimers {
	s.TimerType = &v
	return s
}

type ModifyDesktopTimerResponseBody struct {
	// The IDs of cloud desktops whose scheduled tasks are configured.
	DesktopIds []*string `json:"DesktopIds,omitempty" xml:"DesktopIds,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDesktopTimerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopTimerResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDesktopTimerResponseBody) SetDesktopIds(v []*string) *ModifyDesktopTimerResponseBody {
	s.DesktopIds = v
	return s
}

func (s *ModifyDesktopTimerResponseBody) SetRequestId(v string) *ModifyDesktopTimerResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDesktopTimerResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDesktopTimerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDesktopTimerResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopTimerResponse) GoString() string {
	return s.String()
}

func (s *ModifyDesktopTimerResponse) SetHeaders(v map[string]*string) *ModifyDesktopTimerResponse {
	s.Headers = v
	return s
}

func (s *ModifyDesktopTimerResponse) SetStatusCode(v int32) *ModifyDesktopTimerResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDesktopTimerResponse) SetBody(v *ModifyDesktopTimerResponseBody) *ModifyDesktopTimerResponse {
	s.Body = v
	return s
}

type ModifyDesktopsPolicyGroupRequest struct {
	// The ID of the cloud desktop.
	DesktopId []*string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty" type:"Repeated"`
	// The ID of the policy.
	PolicyGroupId *string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty"`
	// The IDs of policy groups.
	PolicyGroupIds []*string `json:"PolicyGroupIds,omitempty" xml:"PolicyGroupIds,omitempty" type:"Repeated"`
	// The region ID of the cloud desktop.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ModifyDesktopsPolicyGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopsPolicyGroupRequest) GoString() string {
	return s.String()
}

func (s *ModifyDesktopsPolicyGroupRequest) SetDesktopId(v []*string) *ModifyDesktopsPolicyGroupRequest {
	s.DesktopId = v
	return s
}

func (s *ModifyDesktopsPolicyGroupRequest) SetPolicyGroupId(v string) *ModifyDesktopsPolicyGroupRequest {
	s.PolicyGroupId = &v
	return s
}

func (s *ModifyDesktopsPolicyGroupRequest) SetPolicyGroupIds(v []*string) *ModifyDesktopsPolicyGroupRequest {
	s.PolicyGroupIds = v
	return s
}

func (s *ModifyDesktopsPolicyGroupRequest) SetRegionId(v string) *ModifyDesktopsPolicyGroupRequest {
	s.RegionId = &v
	return s
}

type ModifyDesktopsPolicyGroupResponseBody struct {
	// The change results.
	ModifyResults []*ModifyDesktopsPolicyGroupResponseBodyModifyResults `json:"ModifyResults,omitempty" xml:"ModifyResults,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDesktopsPolicyGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopsPolicyGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDesktopsPolicyGroupResponseBody) SetModifyResults(v []*ModifyDesktopsPolicyGroupResponseBodyModifyResults) *ModifyDesktopsPolicyGroupResponseBody {
	s.ModifyResults = v
	return s
}

func (s *ModifyDesktopsPolicyGroupResponseBody) SetRequestId(v string) *ModifyDesktopsPolicyGroupResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDesktopsPolicyGroupResponseBodyModifyResults struct {
	// The change result. A value of success indicates that the policy is changed. If the policy is not changed, an error message is returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the cloud desktop.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The error message. This parameter is empty if the Code value is success.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
}

func (s ModifyDesktopsPolicyGroupResponseBodyModifyResults) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopsPolicyGroupResponseBodyModifyResults) GoString() string {
	return s.String()
}

func (s *ModifyDesktopsPolicyGroupResponseBodyModifyResults) SetCode(v string) *ModifyDesktopsPolicyGroupResponseBodyModifyResults {
	s.Code = &v
	return s
}

func (s *ModifyDesktopsPolicyGroupResponseBodyModifyResults) SetDesktopId(v string) *ModifyDesktopsPolicyGroupResponseBodyModifyResults {
	s.DesktopId = &v
	return s
}

func (s *ModifyDesktopsPolicyGroupResponseBodyModifyResults) SetMessage(v string) *ModifyDesktopsPolicyGroupResponseBodyModifyResults {
	s.Message = &v
	return s
}

type ModifyDesktopsPolicyGroupResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDesktopsPolicyGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDesktopsPolicyGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesktopsPolicyGroupResponse) GoString() string {
	return s.String()
}

func (s *ModifyDesktopsPolicyGroupResponse) SetHeaders(v map[string]*string) *ModifyDesktopsPolicyGroupResponse {
	s.Headers = v
	return s
}

func (s *ModifyDesktopsPolicyGroupResponse) SetStatusCode(v int32) *ModifyDesktopsPolicyGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDesktopsPolicyGroupResponse) SetBody(v *ModifyDesktopsPolicyGroupResponseBody) *ModifyDesktopsPolicyGroupResponse {
	s.Body = v
	return s
}

type ModifyDiskSpecRequest struct {
	// Specifies whether to automatically complete the payment. Valid values:
	//
	// *   `true`: automatically completes the payment. Make sure that your Alibaba Cloud account has sufficient balance. If your Alibaba Cloud account does not have sufficient balance, abnormal orders are generated.
	// *   `false`: does not complete the payment. In this case, an order is generated, but no payment is made. You can log on to the Elastic Desktop Service (EDS) console and complete the payment based on the order ID on the **Orders** page.
	//
	// Default value: `true`.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The ID of the cloud desktop.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The ID of the sales promotion activity. You can call the DescribePrice operation to obtain the IDs of matching sales promotion activities.
	PromotionId *string `json:"PromotionId,omitempty" xml:"PromotionId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The performance level (PL) of the system disk. If the cloud desktop type is Graphics or High Frequency, you can set the PL of the system disk. Valid values:
	//
	// *   PL0
	// *   PL1
	// *   PL2
	// *   PL3
	RootDiskPerformanceLevel *string `json:"RootDiskPerformanceLevel,omitempty" xml:"RootDiskPerformanceLevel,omitempty"`
	// The PL of the data disk. If the cloud desktop type is Graphics or High Frequency, you can set the PL of the data disk. Valid values:
	//
	// *   PL0
	// *   PL1
	// *   PL2
	// *   PL3
	UserDiskPerformanceLevel *string `json:"UserDiskPerformanceLevel,omitempty" xml:"UserDiskPerformanceLevel,omitempty"`
}

func (s ModifyDiskSpecRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDiskSpecRequest) GoString() string {
	return s.String()
}

func (s *ModifyDiskSpecRequest) SetAutoPay(v bool) *ModifyDiskSpecRequest {
	s.AutoPay = &v
	return s
}

func (s *ModifyDiskSpecRequest) SetDesktopId(v string) *ModifyDiskSpecRequest {
	s.DesktopId = &v
	return s
}

func (s *ModifyDiskSpecRequest) SetPromotionId(v string) *ModifyDiskSpecRequest {
	s.PromotionId = &v
	return s
}

func (s *ModifyDiskSpecRequest) SetRegionId(v string) *ModifyDiskSpecRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyDiskSpecRequest) SetRootDiskPerformanceLevel(v string) *ModifyDiskSpecRequest {
	s.RootDiskPerformanceLevel = &v
	return s
}

func (s *ModifyDiskSpecRequest) SetUserDiskPerformanceLevel(v string) *ModifyDiskSpecRequest {
	s.UserDiskPerformanceLevel = &v
	return s
}

type ModifyDiskSpecResponseBody struct {
	// The ID of the order. You can obtain the order ID on the [Orders](https://usercenter2-intl.aliyun.com/order/list?pageIndex=1\&pageSize=20\&spm=5176.12818093.top-nav.ditem-ord.36f016d0OQFmJa) page in Alibaba Cloud User Center.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDiskSpecResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDiskSpecResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDiskSpecResponseBody) SetOrderId(v string) *ModifyDiskSpecResponseBody {
	s.OrderId = &v
	return s
}

func (s *ModifyDiskSpecResponseBody) SetRequestId(v string) *ModifyDiskSpecResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDiskSpecResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDiskSpecResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDiskSpecResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDiskSpecResponse) GoString() string {
	return s.String()
}

func (s *ModifyDiskSpecResponse) SetHeaders(v map[string]*string) *ModifyDiskSpecResponse {
	s.Headers = v
	return s
}

func (s *ModifyDiskSpecResponse) SetStatusCode(v int32) *ModifyDiskSpecResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDiskSpecResponse) SetBody(v *ModifyDiskSpecResponseBody) *ModifyDiskSpecResponse {
	s.Body = v
	return s
}

type ModifyEntitlementRequest struct {
	// The cloud desktop ID.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The usernames. You can specify 1 to 100 usernames.
	EndUserId []*string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty" type:"Repeated"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ModifyEntitlementRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyEntitlementRequest) GoString() string {
	return s.String()
}

func (s *ModifyEntitlementRequest) SetDesktopId(v string) *ModifyEntitlementRequest {
	s.DesktopId = &v
	return s
}

func (s *ModifyEntitlementRequest) SetEndUserId(v []*string) *ModifyEntitlementRequest {
	s.EndUserId = v
	return s
}

func (s *ModifyEntitlementRequest) SetRegionId(v string) *ModifyEntitlementRequest {
	s.RegionId = &v
	return s
}

type ModifyEntitlementResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyEntitlementResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyEntitlementResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyEntitlementResponseBody) SetRequestId(v string) *ModifyEntitlementResponseBody {
	s.RequestId = &v
	return s
}

type ModifyEntitlementResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyEntitlementResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyEntitlementResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyEntitlementResponse) GoString() string {
	return s.String()
}

func (s *ModifyEntitlementResponse) SetHeaders(v map[string]*string) *ModifyEntitlementResponse {
	s.Headers = v
	return s
}

func (s *ModifyEntitlementResponse) SetStatusCode(v int32) *ModifyEntitlementResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyEntitlementResponse) SetBody(v *ModifyEntitlementResponseBody) *ModifyEntitlementResponse {
	s.Body = v
	return s
}

type ModifyImageAttributeRequest struct {
	// The image description. The description must be 2 to 256 characters in length. It cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The image ID.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The name of the image. The name must be 2 to 128 characters in length, and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). It must start with a letter but cannot start with `http://` or `https://`.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ModifyImageAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyImageAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyImageAttributeRequest) SetDescription(v string) *ModifyImageAttributeRequest {
	s.Description = &v
	return s
}

func (s *ModifyImageAttributeRequest) SetImageId(v string) *ModifyImageAttributeRequest {
	s.ImageId = &v
	return s
}

func (s *ModifyImageAttributeRequest) SetName(v string) *ModifyImageAttributeRequest {
	s.Name = &v
	return s
}

func (s *ModifyImageAttributeRequest) SetRegionId(v string) *ModifyImageAttributeRequest {
	s.RegionId = &v
	return s
}

type ModifyImageAttributeResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyImageAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyImageAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyImageAttributeResponseBody) SetRequestId(v string) *ModifyImageAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyImageAttributeResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyImageAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyImageAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyImageAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyImageAttributeResponse) SetHeaders(v map[string]*string) *ModifyImageAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyImageAttributeResponse) SetStatusCode(v int32) *ModifyImageAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyImageAttributeResponse) SetBody(v *ModifyImageAttributeResponseBody) *ModifyImageAttributeResponse {
	s.Body = v
	return s
}

type ModifyImagePermissionRequest struct {
	// The IDs of Alibaba Cloud accounts to which to share the image that will be created based on the image template. You can specify up to 20 account IDs.
	AddAccount []*int64 `json:"AddAccount,omitempty" xml:"AddAccount,omitempty" type:"Repeated"`
	// The IDs of the images.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of Alibaba Cloud account N from which you want to unshare the custom image. Valid values of N: 1 to 10. If the value of N is greater than 10, this parameter is ignored.
	RemoveAccount []*int64 `json:"RemoveAccount,omitempty" xml:"RemoveAccount,omitempty" type:"Repeated"`
}

func (s ModifyImagePermissionRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyImagePermissionRequest) GoString() string {
	return s.String()
}

func (s *ModifyImagePermissionRequest) SetAddAccount(v []*int64) *ModifyImagePermissionRequest {
	s.AddAccount = v
	return s
}

func (s *ModifyImagePermissionRequest) SetImageId(v string) *ModifyImagePermissionRequest {
	s.ImageId = &v
	return s
}

func (s *ModifyImagePermissionRequest) SetRegionId(v string) *ModifyImagePermissionRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyImagePermissionRequest) SetRemoveAccount(v []*int64) *ModifyImagePermissionRequest {
	s.RemoveAccount = v
	return s
}

type ModifyImagePermissionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyImagePermissionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyImagePermissionResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyImagePermissionResponseBody) SetRequestId(v string) *ModifyImagePermissionResponseBody {
	s.RequestId = &v
	return s
}

type ModifyImagePermissionResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyImagePermissionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyImagePermissionResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyImagePermissionResponse) GoString() string {
	return s.String()
}

func (s *ModifyImagePermissionResponse) SetHeaders(v map[string]*string) *ModifyImagePermissionResponse {
	s.Headers = v
	return s
}

func (s *ModifyImagePermissionResponse) SetStatusCode(v int32) *ModifyImagePermissionResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyImagePermissionResponse) SetBody(v *ModifyImagePermissionResponseBody) *ModifyImagePermissionResponse {
	s.Body = v
	return s
}

type ModifyNASDefaultMountTargetRequest struct {
	// The ID of the NAS file system.
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The domain name of the mount target.
	MountTargetDomain *string `json:"MountTargetDomain,omitempty" xml:"MountTargetDomain,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ModifyNASDefaultMountTargetRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyNASDefaultMountTargetRequest) GoString() string {
	return s.String()
}

func (s *ModifyNASDefaultMountTargetRequest) SetFileSystemId(v string) *ModifyNASDefaultMountTargetRequest {
	s.FileSystemId = &v
	return s
}

func (s *ModifyNASDefaultMountTargetRequest) SetMountTargetDomain(v string) *ModifyNASDefaultMountTargetRequest {
	s.MountTargetDomain = &v
	return s
}

func (s *ModifyNASDefaultMountTargetRequest) SetRegionId(v string) *ModifyNASDefaultMountTargetRequest {
	s.RegionId = &v
	return s
}

type ModifyNASDefaultMountTargetResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyNASDefaultMountTargetResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyNASDefaultMountTargetResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyNASDefaultMountTargetResponseBody) SetRequestId(v string) *ModifyNASDefaultMountTargetResponseBody {
	s.RequestId = &v
	return s
}

type ModifyNASDefaultMountTargetResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyNASDefaultMountTargetResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyNASDefaultMountTargetResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyNASDefaultMountTargetResponse) GoString() string {
	return s.String()
}

func (s *ModifyNASDefaultMountTargetResponse) SetHeaders(v map[string]*string) *ModifyNASDefaultMountTargetResponse {
	s.Headers = v
	return s
}

func (s *ModifyNASDefaultMountTargetResponse) SetStatusCode(v int32) *ModifyNASDefaultMountTargetResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyNASDefaultMountTargetResponse) SetBody(v *ModifyNASDefaultMountTargetResponseBody) *ModifyNASDefaultMountTargetResponse {
	s.Body = v
	return s
}

type ModifyNetworkPackageBandwidthRequest struct {
	// Specifies whether to automatically complete the payment. Valid values:
	//
	// *   `true`: automatically completes the payment. Make sure that your Alibaba Cloud account has sufficient balance. If your Alibaba Cloud account does not have sufficient balance, abnormal orders are generated.
	// *   `false`: does not complete the payment. In this case, an order is generated, but no payment is made. You can log on to the Elastic Desktop Service (EDS) console and complete the payment based on the order ID on the **Orders** page.
	//
	// Default value: `true`.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The bandwidth of the network packet. Unit: Mbps. Value range: 10 to 1000.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The ID of the Internet access package.
	NetworkPackageId *string `json:"NetworkPackageId,omitempty" xml:"NetworkPackageId,omitempty"`
	// The ID of the promotion. You can call the `GetResourcePrice` operation to query the promotion ID.
	PromotionId *string `json:"PromotionId,omitempty" xml:"PromotionId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ModifyNetworkPackageBandwidthRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyNetworkPackageBandwidthRequest) GoString() string {
	return s.String()
}

func (s *ModifyNetworkPackageBandwidthRequest) SetAutoPay(v bool) *ModifyNetworkPackageBandwidthRequest {
	s.AutoPay = &v
	return s
}

func (s *ModifyNetworkPackageBandwidthRequest) SetBandwidth(v int32) *ModifyNetworkPackageBandwidthRequest {
	s.Bandwidth = &v
	return s
}

func (s *ModifyNetworkPackageBandwidthRequest) SetNetworkPackageId(v string) *ModifyNetworkPackageBandwidthRequest {
	s.NetworkPackageId = &v
	return s
}

func (s *ModifyNetworkPackageBandwidthRequest) SetPromotionId(v string) *ModifyNetworkPackageBandwidthRequest {
	s.PromotionId = &v
	return s
}

func (s *ModifyNetworkPackageBandwidthRequest) SetRegionId(v string) *ModifyNetworkPackageBandwidthRequest {
	s.RegionId = &v
	return s
}

type ModifyNetworkPackageBandwidthResponseBody struct {
	// The ID of the order.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyNetworkPackageBandwidthResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyNetworkPackageBandwidthResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyNetworkPackageBandwidthResponseBody) SetOrderId(v string) *ModifyNetworkPackageBandwidthResponseBody {
	s.OrderId = &v
	return s
}

func (s *ModifyNetworkPackageBandwidthResponseBody) SetRequestId(v string) *ModifyNetworkPackageBandwidthResponseBody {
	s.RequestId = &v
	return s
}

type ModifyNetworkPackageBandwidthResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyNetworkPackageBandwidthResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyNetworkPackageBandwidthResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyNetworkPackageBandwidthResponse) GoString() string {
	return s.String()
}

func (s *ModifyNetworkPackageBandwidthResponse) SetHeaders(v map[string]*string) *ModifyNetworkPackageBandwidthResponse {
	s.Headers = v
	return s
}

func (s *ModifyNetworkPackageBandwidthResponse) SetStatusCode(v int32) *ModifyNetworkPackageBandwidthResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyNetworkPackageBandwidthResponse) SetBody(v *ModifyNetworkPackageBandwidthResponseBody) *ModifyNetworkPackageBandwidthResponse {
	s.Body = v
	return s
}

type ModifyNetworkPackageEnabledRequest struct {
	// Specifies whether to restore or disable Internet access for the cloud desktop. Valid values:
	//
	// *   true: restores Internet access.
	// *   false: disables Internet access.
	Enabled *bool `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// The ID of the Internet access package.
	NetworkPackageId *string `json:"NetworkPackageId,omitempty" xml:"NetworkPackageId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ModifyNetworkPackageEnabledRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyNetworkPackageEnabledRequest) GoString() string {
	return s.String()
}

func (s *ModifyNetworkPackageEnabledRequest) SetEnabled(v bool) *ModifyNetworkPackageEnabledRequest {
	s.Enabled = &v
	return s
}

func (s *ModifyNetworkPackageEnabledRequest) SetNetworkPackageId(v string) *ModifyNetworkPackageEnabledRequest {
	s.NetworkPackageId = &v
	return s
}

func (s *ModifyNetworkPackageEnabledRequest) SetRegionId(v string) *ModifyNetworkPackageEnabledRequest {
	s.RegionId = &v
	return s
}

type ModifyNetworkPackageEnabledResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyNetworkPackageEnabledResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyNetworkPackageEnabledResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyNetworkPackageEnabledResponseBody) SetRequestId(v string) *ModifyNetworkPackageEnabledResponseBody {
	s.RequestId = &v
	return s
}

type ModifyNetworkPackageEnabledResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyNetworkPackageEnabledResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyNetworkPackageEnabledResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyNetworkPackageEnabledResponse) GoString() string {
	return s.String()
}

func (s *ModifyNetworkPackageEnabledResponse) SetHeaders(v map[string]*string) *ModifyNetworkPackageEnabledResponse {
	s.Headers = v
	return s
}

func (s *ModifyNetworkPackageEnabledResponse) SetStatusCode(v int32) *ModifyNetworkPackageEnabledResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyNetworkPackageEnabledResponse) SetBody(v *ModifyNetworkPackageEnabledResponseBody) *ModifyNetworkPackageEnabledResponse {
	s.Body = v
	return s
}

type ModifyOfficeSiteAttributeRequest struct {
	// The method that you want to use to connect the Alibaba Cloud Workspace client to cloud desktops. Valid values:
	//
	// *   INTERNET: connects the client to cloud desktops only over the Internet.
	// *   VPC: connects the client to cloud desktops only over a VPC.
	// *   Any: connects clients to cloud desktops over the Internet or a VPC. You can select a connection method based on your business requirements when you connect to a cloud desktop from the client.
	//
	// Default value: INTERNET.
	//
	// > VPC connections are established by using Alibaba Cloud PrivateLink. You can use PrivateLink for free. When you set this parameter to VPC or Any, PrivateLink is automatically activated.
	DesktopAccessType *string `json:"DesktopAccessType,omitempty" xml:"DesktopAccessType,omitempty"`
	// Specifies whether to grant the local administrator permissions to end users.
	EnableAdminAccess *bool `json:"EnableAdminAccess,omitempty" xml:"EnableAdminAccess,omitempty"`
	// This parameter is only applicable to a workspace of the convenience account type, which indicates whether to require two-factor verification when you log on to the client. If two-factor verification is enabled, the system checks whether security risks exist within the logon account when a convenience user logs on to the client. If risks are detected, the system sends a verification code to the email address that is associated with the account. Then, the convenience user can log on to the client only after the verification code is correctly entered.
	NeedVerifyLoginRisk *bool `json:"NeedVerifyLoginRisk,omitempty" xml:"NeedVerifyLoginRisk,omitempty"`
	// This parameter is only applicable to a workspace of the convenience account type, which indicates whether to require device verification when you log on to the client. For a workspace of the enterprise Active Directory (AD) account type, the value of this parameter is empty.
	NeedVerifyZeroDevice *bool `json:"NeedVerifyZeroDevice,omitempty" xml:"NeedVerifyZeroDevice,omitempty"`
	// The ID of the workspace.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The name of the workspace. We recommend that you specify a name that is easy to identify. The name must be 2 to 255 characters in length. The name can contain letters, digits, colons (:), underscores (\_), and hyphens (-). It must start with a letter but cannot start with http:// or https://.
	OfficeSiteName *string `json:"OfficeSiteName,omitempty" xml:"OfficeSiteName,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ModifyOfficeSiteAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyOfficeSiteAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyOfficeSiteAttributeRequest) SetDesktopAccessType(v string) *ModifyOfficeSiteAttributeRequest {
	s.DesktopAccessType = &v
	return s
}

func (s *ModifyOfficeSiteAttributeRequest) SetEnableAdminAccess(v bool) *ModifyOfficeSiteAttributeRequest {
	s.EnableAdminAccess = &v
	return s
}

func (s *ModifyOfficeSiteAttributeRequest) SetNeedVerifyLoginRisk(v bool) *ModifyOfficeSiteAttributeRequest {
	s.NeedVerifyLoginRisk = &v
	return s
}

func (s *ModifyOfficeSiteAttributeRequest) SetNeedVerifyZeroDevice(v bool) *ModifyOfficeSiteAttributeRequest {
	s.NeedVerifyZeroDevice = &v
	return s
}

func (s *ModifyOfficeSiteAttributeRequest) SetOfficeSiteId(v string) *ModifyOfficeSiteAttributeRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *ModifyOfficeSiteAttributeRequest) SetOfficeSiteName(v string) *ModifyOfficeSiteAttributeRequest {
	s.OfficeSiteName = &v
	return s
}

func (s *ModifyOfficeSiteAttributeRequest) SetRegionId(v string) *ModifyOfficeSiteAttributeRequest {
	s.RegionId = &v
	return s
}

type ModifyOfficeSiteAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyOfficeSiteAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyOfficeSiteAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyOfficeSiteAttributeResponseBody) SetRequestId(v string) *ModifyOfficeSiteAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyOfficeSiteAttributeResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyOfficeSiteAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyOfficeSiteAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyOfficeSiteAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyOfficeSiteAttributeResponse) SetHeaders(v map[string]*string) *ModifyOfficeSiteAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyOfficeSiteAttributeResponse) SetStatusCode(v int32) *ModifyOfficeSiteAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyOfficeSiteAttributeResponse) SetBody(v *ModifyOfficeSiteAttributeResponseBody) *ModifyOfficeSiteAttributeResponse {
	s.Body = v
	return s
}

type ModifyOfficeSiteCrossDesktopAccessRequest struct {
	// Specifies whether to enable the cross-desktop access feature for the workspace.
	//
	// *   true: enable
	// *   false: disable
	EnableCrossDesktopAccess *bool `json:"EnableCrossDesktopAccess,omitempty" xml:"EnableCrossDesktopAccess,omitempty"`
	// The workspace ID.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ModifyOfficeSiteCrossDesktopAccessRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyOfficeSiteCrossDesktopAccessRequest) GoString() string {
	return s.String()
}

func (s *ModifyOfficeSiteCrossDesktopAccessRequest) SetEnableCrossDesktopAccess(v bool) *ModifyOfficeSiteCrossDesktopAccessRequest {
	s.EnableCrossDesktopAccess = &v
	return s
}

func (s *ModifyOfficeSiteCrossDesktopAccessRequest) SetOfficeSiteId(v string) *ModifyOfficeSiteCrossDesktopAccessRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *ModifyOfficeSiteCrossDesktopAccessRequest) SetRegionId(v string) *ModifyOfficeSiteCrossDesktopAccessRequest {
	s.RegionId = &v
	return s
}

type ModifyOfficeSiteCrossDesktopAccessResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyOfficeSiteCrossDesktopAccessResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyOfficeSiteCrossDesktopAccessResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyOfficeSiteCrossDesktopAccessResponseBody) SetRequestId(v string) *ModifyOfficeSiteCrossDesktopAccessResponseBody {
	s.RequestId = &v
	return s
}

type ModifyOfficeSiteCrossDesktopAccessResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyOfficeSiteCrossDesktopAccessResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyOfficeSiteCrossDesktopAccessResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyOfficeSiteCrossDesktopAccessResponse) GoString() string {
	return s.String()
}

func (s *ModifyOfficeSiteCrossDesktopAccessResponse) SetHeaders(v map[string]*string) *ModifyOfficeSiteCrossDesktopAccessResponse {
	s.Headers = v
	return s
}

func (s *ModifyOfficeSiteCrossDesktopAccessResponse) SetStatusCode(v int32) *ModifyOfficeSiteCrossDesktopAccessResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyOfficeSiteCrossDesktopAccessResponse) SetBody(v *ModifyOfficeSiteCrossDesktopAccessResponseBody) *ModifyOfficeSiteCrossDesktopAccessResponse {
	s.Body = v
	return s
}

type ModifyOfficeSiteMfaEnabledRequest struct {
	// Specifies whether to enable MFA. Valid values:
	//
	// *   true
	// *   false
	MfaEnabled *bool `json:"MfaEnabled,omitempty" xml:"MfaEnabled,omitempty"`
	// The workspace ID.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ModifyOfficeSiteMfaEnabledRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyOfficeSiteMfaEnabledRequest) GoString() string {
	return s.String()
}

func (s *ModifyOfficeSiteMfaEnabledRequest) SetMfaEnabled(v bool) *ModifyOfficeSiteMfaEnabledRequest {
	s.MfaEnabled = &v
	return s
}

func (s *ModifyOfficeSiteMfaEnabledRequest) SetOfficeSiteId(v string) *ModifyOfficeSiteMfaEnabledRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *ModifyOfficeSiteMfaEnabledRequest) SetRegionId(v string) *ModifyOfficeSiteMfaEnabledRequest {
	s.RegionId = &v
	return s
}

type ModifyOfficeSiteMfaEnabledResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyOfficeSiteMfaEnabledResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyOfficeSiteMfaEnabledResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyOfficeSiteMfaEnabledResponseBody) SetRequestId(v string) *ModifyOfficeSiteMfaEnabledResponseBody {
	s.RequestId = &v
	return s
}

type ModifyOfficeSiteMfaEnabledResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyOfficeSiteMfaEnabledResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyOfficeSiteMfaEnabledResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyOfficeSiteMfaEnabledResponse) GoString() string {
	return s.String()
}

func (s *ModifyOfficeSiteMfaEnabledResponse) SetHeaders(v map[string]*string) *ModifyOfficeSiteMfaEnabledResponse {
	s.Headers = v
	return s
}

func (s *ModifyOfficeSiteMfaEnabledResponse) SetStatusCode(v int32) *ModifyOfficeSiteMfaEnabledResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyOfficeSiteMfaEnabledResponse) SetBody(v *ModifyOfficeSiteMfaEnabledResponseBody) *ModifyOfficeSiteMfaEnabledResponse {
	s.Body = v
	return s
}

type ModifyPolicyGroupRequest struct {
	AdminAccess *string `json:"AdminAccess,omitempty" xml:"AdminAccess,omitempty"`
	// Specifies whether to enable the anti-screenshot feature. Valid values:
	//
	// * on
	// * off
	//
	// Default value: off.
	AppContentProtection *string `json:"AppContentProtection,omitempty" xml:"AppContentProtection,omitempty"`
	// The client CIDR blocks in the whitelist.
	AuthorizeAccessPolicyRule []*ModifyPolicyGroupRequestAuthorizeAccessPolicyRule `json:"AuthorizeAccessPolicyRule,omitempty" xml:"AuthorizeAccessPolicyRule,omitempty" type:"Repeated"`
	// The security group rules.
	AuthorizeSecurityPolicyRule []*ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule `json:"AuthorizeSecurityPolicyRule,omitempty" xml:"AuthorizeSecurityPolicyRule,omitempty" type:"Repeated"`
	// Specifies whether to enable the webcam redirection feature. Valid values:
	//
	// * on
	// * off
	//
	// Default value: on.
	CameraRedirect *string `json:"CameraRedirect,omitempty" xml:"CameraRedirect,omitempty"`
	// The logon methods.
	ClientType []*ModifyPolicyGroupRequestClientType `json:"ClientType,omitempty" xml:"ClientType,omitempty" type:"Repeated"`
	// The permissions on clipboards. Valid values:
	//
	// *   read: specifies one-way transfer. You can copy data from your computer to cloud desktops, but cannot copy data from cloud desktops to your computer.
	// *   readwrite: specifies two-way transfer. You can copy data between your computer and cloud desktops.
	// *   off: specifies that the two-way transfer is disabled. You cannot copy data between your computer and cloud desktops.
	Clipboard *string `json:"Clipboard,omitempty" xml:"Clipboard,omitempty"`
	// The domain blacklist or whitelist. Wildcard domains are supported. Separate domain names with commas (,). Valid values:
	//
	// *   \[black:],example1.com,example2.com: the domain name blacklist.
	// *   \[white:],example1.com,example2.com: the domain name whitelist.
	DomainList *string `json:"DomainList,omitempty" xml:"DomainList,omitempty"`
	// The details of the DNS rule.
	DomainResolveRule []*ModifyPolicyGroupRequestDomainResolveRule `json:"DomainResolveRule,omitempty" xml:"DomainResolveRule,omitempty" type:"Repeated"`
	// The DNS rule type.
	DomainResolveRuleType *string `json:"DomainResolveRuleType,omitempty" xml:"DomainResolveRuleType,omitempty"`
	// The user applies for the administrator assistance switch. Value range:
	// * on
	// * off
	EndUserApplyAdminCoordinate *string `json:"EndUserApplyAdminCoordinate,omitempty" xml:"EndUserApplyAdminCoordinate,omitempty"`
	// The flow collaboration switch between users. Value range:
	// * on
	// * off
	EndUserGroupCoordinate *string `json:"EndUserGroupCoordinate,omitempty" xml:"EndUserGroupCoordinate,omitempty"`
	// Specifies whether to enable the image display quality feature for the Graphics cloud desktop. If your business requires high desktop performance and optimal user experience, we recommend that you enable this feature. For example, you can enable this policy in professional design scenarios. Valid values:
	//
	// * on
	// * off
	GpuAcceleration *string `json:"GpuAcceleration,omitempty" xml:"GpuAcceleration,omitempty"`
	// Specifies whether to allow the access from HTM5 clients to a cloud desktop. Valid values:
	//
	// *   on: allows the access.
	// *   off: denies the access.
	//
	// Default value: off.
	//
	// >  We recommend that you use the ClientType-related parameters to control the EDS client type for cloud desktop logon.
	Html5Access *string `json:"Html5Access,omitempty" xml:"Html5Access,omitempty"`
	// The file transfer policy for HTML5 clients. Valid values:
	//
	// *   off: Files cannot be uploaded from or downloaded to HTML5 clients.
	// *   upload: Files can be uploaded from HTML5 clients.
	// *   download: Files can be downloaded to HTML5 clients.
	// *   all: Files can be uploaded from and downloaded to HTML5 clients.
	//
	// Default value: off.
	Html5FileTransfer *string `json:"Html5FileTransfer,omitempty" xml:"Html5FileTransfer,omitempty"`
	// The protocol that you want to use for network communication. Valid values:
	//
	// * TCP: Only the TCP protocol is used.
	// * BOTH: allows automatic switchover between the TCP protocol and the UDP protocol.
	//
	// Default value: TCP.
	InternetCommunicationProtocol *string `json:"InternetCommunicationProtocol,omitempty" xml:"InternetCommunicationProtocol,omitempty"`
	// The permissions on local disk mapping. Valid values:
	//
	// *   read: read-only permissions. Local disks are mapped to cloud desktops. You can only read (copy) local files but cannot modify them.
	// *   readwrite: read and write permissions. Local disks are mapped to cloud desktops. You can read (copy) and modify local files.
	// *   off: no permissions. Local disks are not mapped to cloud desktops.
	LocalDrive *string `json:"LocalDrive,omitempty" xml:"LocalDrive,omitempty"`
	// The name of the policy.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The network redirection feature. Valid values:
	//
	// * on
	// * off
	//
	// Default value: off.
	NetRedirect *string `json:"NetRedirect,omitempty" xml:"NetRedirect,omitempty"`
	// The ID of the policy.
	PolicyGroupId *string `json:"PolicyGroupId,omitempty" xml:"PolicyGroupId,omitempty"`
	// Specifies whether to allow user preemption. Default value: off. You cannot change the value.
	PreemptLogin *string `json:"PreemptLogin,omitempty" xml:"PreemptLogin,omitempty"`
	// The names of the users that are allowed to connect to the same cloud desktop at the same time. You can specify up to five usernames.
	//
	// > To improve user experience and ensure data security, multiple end users cannot connect to the same cloud desktop at the same time.
	PreemptLoginUser []*string `json:"PreemptLoginUser,omitempty" xml:"PreemptLoginUser,omitempty" type:"Repeated"`
	// Specifies whether to enable printer redirection. Valid values:
	//
	// *   off: disables printer redirection.
	// *   on: enables printer redirection.
	PrinterRedirection *string `json:"PrinterRedirection,omitempty" xml:"PrinterRedirection,omitempty"`
	// Specifies whether to enable the custom screen recording feature. Valid values:
	//
	// * on
	// * off
	//
	// Default value: off.
	RecordContent *string `json:"RecordContent,omitempty" xml:"RecordContent,omitempty"`
	// The duration in which the custom screen recording is valid. Default value: 30. Unit: days.
	RecordContentExpires *int64 `json:"RecordContentExpires,omitempty" xml:"RecordContentExpires,omitempty"`
	// Specifies whether to enable screen recording. Valid values:
	//
	// * OFF: disabled.
	// * ALLTIME: All operations that are performed by an end user on the cloud desktop are recorded. The recording immediately starts when the end user connects to the cloud desktop and ends after the end user disconnects from the cloud desktop.
	// * PERIOD: The operations that are performed by an end user on the cloud desktop during a specific period of time are recorded. You must specify the start time and the end time of the recording.
	Recording *string `json:"Recording,omitempty" xml:"Recording,omitempty"`
	// Specifies whether to record the sound that is generated on the cloud desktop during screen recording. Valid values:
	//
	// * on
	// * off
	RecordingAudio *string `json:"RecordingAudio,omitempty" xml:"RecordingAudio,omitempty"`
	// This parameter takes effect based on the Recording-related parameters. You can specify a time range for screen recording, and recording files are generated after the specified end time is reached.
	RecordingDuration *int32 `json:"RecordingDuration,omitempty" xml:"RecordingDuration,omitempty"`
	// The time when the screen recording ends. Specify the value in the HH:MM:SS format. The value is valid only when you set the Recording parameter to PERIOD.
	RecordingEndTime *string `json:"RecordingEndTime,omitempty" xml:"RecordingEndTime,omitempty"`
	// The period in which the screen recording audit is valid. Valid values: 15 to 180. Unit: days.
	RecordingExpires *int64 `json:"RecordingExpires,omitempty" xml:"RecordingExpires,omitempty"`
	// The frame rate of screen recording. Unit: fps. Valid values:
	//
	// * 2
	// * 5
	// * 10
	// * 15
	RecordingFps *int64 `json:"RecordingFps,omitempty" xml:"RecordingFps,omitempty"`
	// The time when the screen recording starts. Specify the value in the HH:MM:SS format. The value is valid only when you set the Recording parameter to PERIOD.
	RecordingStartTime *string `json:"RecordingStartTime,omitempty" xml:"RecordingStartTime,omitempty"`
	// The ID of the region where the cloud desktop resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The permissions on the keyboard and mouse to control the cloud desktop during remote assistance. Valid values:
	//
	// * fullControl: The keyboard and mouse can be fully controlled.
	// * optionalControl: By default, this feature is disabled. You can apply for permissions to enable the feature.
	// * disableControl: The keyboard and mouse cannot be controlled.
	RemoteCoordinate *string `json:"RemoteCoordinate,omitempty" xml:"RemoteCoordinate,omitempty"`
	// The security group rules that you want to delete.
	RevokeAccessPolicyRule []*ModifyPolicyGroupRequestRevokeAccessPolicyRule `json:"RevokeAccessPolicyRule,omitempty" xml:"RevokeAccessPolicyRule,omitempty" type:"Repeated"`
	// The security group rules that you want to delete.
	RevokeSecurityPolicyRule []*ModifyPolicyGroupRequestRevokeSecurityPolicyRule `json:"RevokeSecurityPolicyRule,omitempty" xml:"RevokeSecurityPolicyRule,omitempty" type:"Repeated"`
	// The effective scope of the policy. Valid values:
	//
	// * GLOBAL: takes effect globally.
	// * IP: takes effect based on the IP address.
	Scope *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
	// This parameter is required when the Scope parameter is set to IP.
	ScopeValue []*string `json:"ScopeValue,omitempty" xml:"ScopeValue,omitempty" type:"Repeated"`
	// Specifies whether to enable USB redirection. Valid values:
	//
	// *   on: enables USB redirection.
	// *   off: disables USB redirection.
	UsbRedirect *string `json:"UsbRedirect,omitempty" xml:"UsbRedirect,omitempty"`
	// The USB redirection rules.
	UsbSupplyRedirectRule []*ModifyPolicyGroupRequestUsbSupplyRedirectRule `json:"UsbSupplyRedirectRule,omitempty" xml:"UsbSupplyRedirectRule,omitempty" type:"Repeated"`
	// The multimedia redirection feature.
	VideoRedirect *string `json:"VideoRedirect,omitempty" xml:"VideoRedirect,omitempty"`
	// Specify whether to enable the policy of image display quality. Valid values:
	//
	// *   on: enables the policy of image display quality.
	// *   off: disables the policy of image display quality.
	//
	// Default value: off.
	VisualQuality *string `json:"VisualQuality,omitempty" xml:"VisualQuality,omitempty"`
	// Specifies whether to enable watermarking. Valid values:
	//
	// *   on: enables watermarking.
	// *   off: disables watermarking.
	Watermark *string `json:"Watermark,omitempty" xml:"Watermark,omitempty"`
	// The font color of the watermark. Valid values: 0 to 16777215.
	WatermarkColor *int32 `json:"WatermarkColor,omitempty" xml:"WatermarkColor,omitempty"`
	// The inclination angle of the watermark. Value values: -10 to -30.
	WatermarkDegree *float64 `json:"WatermarkDegree,omitempty" xml:"WatermarkDegree,omitempty"`
	// The font size of the watermark. Valid values: 10 to 50
	WatermarkFontSize *int32 `json:"WatermarkFontSize,omitempty" xml:"WatermarkFontSize,omitempty"`
	// The font style of the watermark. Valid values:
	//
	// * plain
	// * bold
	WatermarkFontStyle *string `json:"WatermarkFontStyle,omitempty" xml:"WatermarkFontStyle,omitempty"`
	// The number of watermark rows. This parameter is not in use.
	WatermarkRowAmount *int32 `json:"WatermarkRowAmount,omitempty" xml:"WatermarkRowAmount,omitempty"`
	// The security priority rule for invisible watermarks. Valid values: on and off.
	WatermarkSecurity *string `json:"WatermarkSecurity,omitempty" xml:"WatermarkSecurity,omitempty"`
	// The transparency of the watermark. The valid values include:
	//
	// *   LIGHT
	// *   MIDDLE
	// *   DARK
	WatermarkTransparency *string `json:"WatermarkTransparency,omitempty" xml:"WatermarkTransparency,omitempty"`
	// The transparency of the watermark. A larger value indicates a less transparent watermark. Valid values: 10 to 100.
	WatermarkTransparencyValue *int32 `json:"WatermarkTransparencyValue,omitempty" xml:"WatermarkTransparencyValue,omitempty"`
	// The type of the watermark. You can specify multiple watermark types at a time. Separate watermark types with commas (,). Valid values:
	//
	// *   EndUserId: the username
	// *   HostName: the last 15 characters of the cloud desktop ID
	WatermarkType *string `json:"WatermarkType,omitempty" xml:"WatermarkType,omitempty"`
}

func (s ModifyPolicyGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyPolicyGroupRequest) GoString() string {
	return s.String()
}

func (s *ModifyPolicyGroupRequest) SetAdminAccess(v string) *ModifyPolicyGroupRequest {
	s.AdminAccess = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetAppContentProtection(v string) *ModifyPolicyGroupRequest {
	s.AppContentProtection = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetAuthorizeAccessPolicyRule(v []*ModifyPolicyGroupRequestAuthorizeAccessPolicyRule) *ModifyPolicyGroupRequest {
	s.AuthorizeAccessPolicyRule = v
	return s
}

func (s *ModifyPolicyGroupRequest) SetAuthorizeSecurityPolicyRule(v []*ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule) *ModifyPolicyGroupRequest {
	s.AuthorizeSecurityPolicyRule = v
	return s
}

func (s *ModifyPolicyGroupRequest) SetCameraRedirect(v string) *ModifyPolicyGroupRequest {
	s.CameraRedirect = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetClientType(v []*ModifyPolicyGroupRequestClientType) *ModifyPolicyGroupRequest {
	s.ClientType = v
	return s
}

func (s *ModifyPolicyGroupRequest) SetClipboard(v string) *ModifyPolicyGroupRequest {
	s.Clipboard = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetDomainList(v string) *ModifyPolicyGroupRequest {
	s.DomainList = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetDomainResolveRule(v []*ModifyPolicyGroupRequestDomainResolveRule) *ModifyPolicyGroupRequest {
	s.DomainResolveRule = v
	return s
}

func (s *ModifyPolicyGroupRequest) SetDomainResolveRuleType(v string) *ModifyPolicyGroupRequest {
	s.DomainResolveRuleType = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetEndUserApplyAdminCoordinate(v string) *ModifyPolicyGroupRequest {
	s.EndUserApplyAdminCoordinate = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetEndUserGroupCoordinate(v string) *ModifyPolicyGroupRequest {
	s.EndUserGroupCoordinate = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetGpuAcceleration(v string) *ModifyPolicyGroupRequest {
	s.GpuAcceleration = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetHtml5Access(v string) *ModifyPolicyGroupRequest {
	s.Html5Access = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetHtml5FileTransfer(v string) *ModifyPolicyGroupRequest {
	s.Html5FileTransfer = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetInternetCommunicationProtocol(v string) *ModifyPolicyGroupRequest {
	s.InternetCommunicationProtocol = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetLocalDrive(v string) *ModifyPolicyGroupRequest {
	s.LocalDrive = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetName(v string) *ModifyPolicyGroupRequest {
	s.Name = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetNetRedirect(v string) *ModifyPolicyGroupRequest {
	s.NetRedirect = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetPolicyGroupId(v string) *ModifyPolicyGroupRequest {
	s.PolicyGroupId = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetPreemptLogin(v string) *ModifyPolicyGroupRequest {
	s.PreemptLogin = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetPreemptLoginUser(v []*string) *ModifyPolicyGroupRequest {
	s.PreemptLoginUser = v
	return s
}

func (s *ModifyPolicyGroupRequest) SetPrinterRedirection(v string) *ModifyPolicyGroupRequest {
	s.PrinterRedirection = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetRecordContent(v string) *ModifyPolicyGroupRequest {
	s.RecordContent = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetRecordContentExpires(v int64) *ModifyPolicyGroupRequest {
	s.RecordContentExpires = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetRecording(v string) *ModifyPolicyGroupRequest {
	s.Recording = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetRecordingAudio(v string) *ModifyPolicyGroupRequest {
	s.RecordingAudio = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetRecordingDuration(v int32) *ModifyPolicyGroupRequest {
	s.RecordingDuration = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetRecordingEndTime(v string) *ModifyPolicyGroupRequest {
	s.RecordingEndTime = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetRecordingExpires(v int64) *ModifyPolicyGroupRequest {
	s.RecordingExpires = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetRecordingFps(v int64) *ModifyPolicyGroupRequest {
	s.RecordingFps = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetRecordingStartTime(v string) *ModifyPolicyGroupRequest {
	s.RecordingStartTime = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetRegionId(v string) *ModifyPolicyGroupRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetRemoteCoordinate(v string) *ModifyPolicyGroupRequest {
	s.RemoteCoordinate = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetRevokeAccessPolicyRule(v []*ModifyPolicyGroupRequestRevokeAccessPolicyRule) *ModifyPolicyGroupRequest {
	s.RevokeAccessPolicyRule = v
	return s
}

func (s *ModifyPolicyGroupRequest) SetRevokeSecurityPolicyRule(v []*ModifyPolicyGroupRequestRevokeSecurityPolicyRule) *ModifyPolicyGroupRequest {
	s.RevokeSecurityPolicyRule = v
	return s
}

func (s *ModifyPolicyGroupRequest) SetScope(v string) *ModifyPolicyGroupRequest {
	s.Scope = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetScopeValue(v []*string) *ModifyPolicyGroupRequest {
	s.ScopeValue = v
	return s
}

func (s *ModifyPolicyGroupRequest) SetUsbRedirect(v string) *ModifyPolicyGroupRequest {
	s.UsbRedirect = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetUsbSupplyRedirectRule(v []*ModifyPolicyGroupRequestUsbSupplyRedirectRule) *ModifyPolicyGroupRequest {
	s.UsbSupplyRedirectRule = v
	return s
}

func (s *ModifyPolicyGroupRequest) SetVideoRedirect(v string) *ModifyPolicyGroupRequest {
	s.VideoRedirect = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetVisualQuality(v string) *ModifyPolicyGroupRequest {
	s.VisualQuality = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetWatermark(v string) *ModifyPolicyGroupRequest {
	s.Watermark = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetWatermarkColor(v int32) *ModifyPolicyGroupRequest {
	s.WatermarkColor = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetWatermarkDegree(v float64) *ModifyPolicyGroupRequest {
	s.WatermarkDegree = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetWatermarkFontSize(v int32) *ModifyPolicyGroupRequest {
	s.WatermarkFontSize = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetWatermarkFontStyle(v string) *ModifyPolicyGroupRequest {
	s.WatermarkFontStyle = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetWatermarkRowAmount(v int32) *ModifyPolicyGroupRequest {
	s.WatermarkRowAmount = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetWatermarkSecurity(v string) *ModifyPolicyGroupRequest {
	s.WatermarkSecurity = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetWatermarkTransparency(v string) *ModifyPolicyGroupRequest {
	s.WatermarkTransparency = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetWatermarkTransparencyValue(v int32) *ModifyPolicyGroupRequest {
	s.WatermarkTransparencyValue = &v
	return s
}

func (s *ModifyPolicyGroupRequest) SetWatermarkType(v string) *ModifyPolicyGroupRequest {
	s.WatermarkType = &v
	return s
}

type ModifyPolicyGroupRequestAuthorizeAccessPolicyRule struct {
	// The CIDR block that the client can access.
	CidrIp *string `json:"CidrIp,omitempty" xml:"CidrIp,omitempty"`
	// The description of the client IP address whitelist.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
}

func (s ModifyPolicyGroupRequestAuthorizeAccessPolicyRule) String() string {
	return tea.Prettify(s)
}

func (s ModifyPolicyGroupRequestAuthorizeAccessPolicyRule) GoString() string {
	return s.String()
}

func (s *ModifyPolicyGroupRequestAuthorizeAccessPolicyRule) SetCidrIp(v string) *ModifyPolicyGroupRequestAuthorizeAccessPolicyRule {
	s.CidrIp = &v
	return s
}

func (s *ModifyPolicyGroupRequestAuthorizeAccessPolicyRule) SetDescription(v string) *ModifyPolicyGroupRequestAuthorizeAccessPolicyRule {
	s.Description = &v
	return s
}

type ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule struct {
	// The object to which the security group rule applies. The value is an IPv4 CIDR block.
	CidrIp *string `json:"CidrIp,omitempty" xml:"CidrIp,omitempty"`
	// The description of security group rule N.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The protocol type of security group rule N. Valid values:
	//
	// *   tcp: TCP
	// *   udp: UDP
	// *   icmp: ICMP (IPv4)
	// *   gre: GRE
	// *   all: all protocols
	IpProtocol *string `json:"IpProtocol,omitempty" xml:"IpProtocol,omitempty"`
	// The authorization policy of security group rule N. Valid values:
	//
	// *   accept: specifies the Allow policy that allows all access requests.
	// *   drop: specifies the Deny policy that denies all access requests. If no messages of access denied are returned, the requests time out or failed.
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	// The port range of security group rule N. The value of the port range is determined by the protocol type specified by the AuthorizeSecurityPolicyRule.N.IpProtocol parameter.
	//
	// *   When the AuthorizeSecurityPolicyRule.N.IpProtocol parameter is set to tcp or udp, the port range is 1 to 65535. Separate the start port number and the end port number with a forward slash (/). Example: 1/200.
	// *   When AuthorizeSecurityPolicyRule.N.IpProtocol is set to icmp, set the value to -1/-1.
	// *   When AuthorizeSecurityPolicyRule.N.IpProtocol is set to gre, set the value to -1/-1.
	// *   When AuthorizeSecurityPolicyRule.N.IpProtocol is set to all, set the value to -1/-1.
	//
	// For more information about the common ports of typical applications, see [Common ports](~~40724~~).
	PortRange *string `json:"PortRange,omitempty" xml:"PortRange,omitempty"`
	// The priority of security group rule N. A smaller value indicates a higher priority.
	//
	// Valid values: 1 to 60.
	//
	// Default value: 1.
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The direction of security group rule N. Valid values:
	//
	// *   inflow: inbound
	// *   outflow: outbound
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule) String() string {
	return tea.Prettify(s)
}

func (s ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule) GoString() string {
	return s.String()
}

func (s *ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule) SetCidrIp(v string) *ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule {
	s.CidrIp = &v
	return s
}

func (s *ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule) SetDescription(v string) *ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule {
	s.Description = &v
	return s
}

func (s *ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule) SetIpProtocol(v string) *ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule {
	s.IpProtocol = &v
	return s
}

func (s *ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule) SetPolicy(v string) *ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule {
	s.Policy = &v
	return s
}

func (s *ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule) SetPortRange(v string) *ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule {
	s.PortRange = &v
	return s
}

func (s *ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule) SetPriority(v string) *ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule {
	s.Priority = &v
	return s
}

func (s *ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule) SetType(v string) *ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule {
	s.Type = &v
	return s
}

type ModifyPolicyGroupRequestClientType struct {
	// The type of client that you want to use to connect to the cloud desktop. Valid values:
	//
	// * windows: the Windows client
	// * linux: C-Key Series Cloud Computer TC and A Series Cloud Computer TC
	// * macos: the macOS client
	// * ios: the iOS client
	// * android: the Android client
	// * html5: the web client
	//
	// > By default, if you do not configure the ClientType-related parameters, all types of clients are allowed to connect to the cloud desktop.
	ClientType *string `json:"ClientType,omitempty" xml:"ClientType,omitempty"`
	// The logon method. This parameter specifies whether a specific type of the client is allowed to connect to the cloud desktop. Valid values:
	//
	// * on: allowed.
	// * off: disallowed.
	//
	// > By default, if you do not configure the ClientType-related parameters, all types of clients are allowed to log on to cloud desktops.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ModifyPolicyGroupRequestClientType) String() string {
	return tea.Prettify(s)
}

func (s ModifyPolicyGroupRequestClientType) GoString() string {
	return s.String()
}

func (s *ModifyPolicyGroupRequestClientType) SetClientType(v string) *ModifyPolicyGroupRequestClientType {
	s.ClientType = &v
	return s
}

func (s *ModifyPolicyGroupRequestClientType) SetStatus(v string) *ModifyPolicyGroupRequestClientType {
	s.Status = &v
	return s
}

type ModifyPolicyGroupRequestDomainResolveRule struct {
	// The description of the DNS rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The domain name.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// Specifies whether to allow the DNS rule.
	//
	// Valid values:
	//
	// *   allow
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   block
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
}

func (s ModifyPolicyGroupRequestDomainResolveRule) String() string {
	return tea.Prettify(s)
}

func (s ModifyPolicyGroupRequestDomainResolveRule) GoString() string {
	return s.String()
}

func (s *ModifyPolicyGroupRequestDomainResolveRule) SetDescription(v string) *ModifyPolicyGroupRequestDomainResolveRule {
	s.Description = &v
	return s
}

func (s *ModifyPolicyGroupRequestDomainResolveRule) SetDomain(v string) *ModifyPolicyGroupRequestDomainResolveRule {
	s.Domain = &v
	return s
}

func (s *ModifyPolicyGroupRequestDomainResolveRule) SetPolicy(v string) *ModifyPolicyGroupRequestDomainResolveRule {
	s.Policy = &v
	return s
}

type ModifyPolicyGroupRequestRevokeAccessPolicyRule struct {
	// The IPv4 CIDR block that can be accessed from the client.
	CidrIp *string `json:"CidrIp,omitempty" xml:"CidrIp,omitempty"`
	// The description of the client IP address whitelist that you want to delete.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
}

func (s ModifyPolicyGroupRequestRevokeAccessPolicyRule) String() string {
	return tea.Prettify(s)
}

func (s ModifyPolicyGroupRequestRevokeAccessPolicyRule) GoString() string {
	return s.String()
}

func (s *ModifyPolicyGroupRequestRevokeAccessPolicyRule) SetCidrIp(v string) *ModifyPolicyGroupRequestRevokeAccessPolicyRule {
	s.CidrIp = &v
	return s
}

func (s *ModifyPolicyGroupRequestRevokeAccessPolicyRule) SetDescription(v string) *ModifyPolicyGroupRequestRevokeAccessPolicyRule {
	s.Description = &v
	return s
}

type ModifyPolicyGroupRequestRevokeSecurityPolicyRule struct {
	// The IPv4 CIDR block of the security group rule.
	CidrIp *string `json:"CidrIp,omitempty" xml:"CidrIp,omitempty"`
	// The description of the security group rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The protocol type of the security group rule. Valid values:
	//
	// * TCP
	// * UDP
	// * ICMP: ICMP (IPv4)
	// * GRE
	// * ALL
	IpProtocol *string `json:"IpProtocol,omitempty" xml:"IpProtocol,omitempty"`
	// The authorization policy of the security group rule that you want to delete. Valid values:
	//
	// * accept: allows all access requests.
	// * drop: disallows all access requests. If no denied messages are returned, the requests timed out or failed.
	//
	// Default value: accept.
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	// The port range of the security group rule that you want to delete. The value of the port range is determined by the protocol type specified by the IpProtocol parameter.
	//
	// * If the IpProtocol parameter is set to TCP or UDP, the port range is 1 to 65535. The start port number and the end port number are separated by a forward slash (/). Example: 1/200.
	// * If the IpProtocol parameter is set to ICMP, the port range is -1/-1.
	// * If the IpProtocol parameter is set to GRE, the port range is -1/-1.
	// * If the IpProtocol parameter is set to ALL, the port range is -1/-1.
	//
	// For more information about the common ports of typical applications, see [Common ports](https://www.alibabacloud.com/help/en/ecs/user-guide/common-ports?spm=a2c63.p38356.0.0.56b87f2c2SJTAw).
	PortRange *string `json:"PortRange,omitempty" xml:"PortRange,omitempty"`
	// The priority of the security group rule. A smaller value indicates a higher priority.
	//
	// Valid values: 1 to 60.
	//
	// Default value: 1.
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The direction of the security group rule that you want to delete. Valid values:
	//
	// * inflow: inbound
	// * outflow: outbound
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ModifyPolicyGroupRequestRevokeSecurityPolicyRule) String() string {
	return tea.Prettify(s)
}

func (s ModifyPolicyGroupRequestRevokeSecurityPolicyRule) GoString() string {
	return s.String()
}

func (s *ModifyPolicyGroupRequestRevokeSecurityPolicyRule) SetCidrIp(v string) *ModifyPolicyGroupRequestRevokeSecurityPolicyRule {
	s.CidrIp = &v
	return s
}

func (s *ModifyPolicyGroupRequestRevokeSecurityPolicyRule) SetDescription(v string) *ModifyPolicyGroupRequestRevokeSecurityPolicyRule {
	s.Description = &v
	return s
}

func (s *ModifyPolicyGroupRequestRevokeSecurityPolicyRule) SetIpProtocol(v string) *ModifyPolicyGroupRequestRevokeSecurityPolicyRule {
	s.IpProtocol = &v
	return s
}

func (s *ModifyPolicyGroupRequestRevokeSecurityPolicyRule) SetPolicy(v string) *ModifyPolicyGroupRequestRevokeSecurityPolicyRule {
	s.Policy = &v
	return s
}

func (s *ModifyPolicyGroupRequestRevokeSecurityPolicyRule) SetPortRange(v string) *ModifyPolicyGroupRequestRevokeSecurityPolicyRule {
	s.PortRange = &v
	return s
}

func (s *ModifyPolicyGroupRequestRevokeSecurityPolicyRule) SetPriority(v string) *ModifyPolicyGroupRequestRevokeSecurityPolicyRule {
	s.Priority = &v
	return s
}

func (s *ModifyPolicyGroupRequestRevokeSecurityPolicyRule) SetType(v string) *ModifyPolicyGroupRequestRevokeSecurityPolicyRule {
	s.Type = &v
	return s
}

type ModifyPolicyGroupRequestUsbSupplyRedirectRule struct {
	// The description of the rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The class of the device. This parameter is required when you set the usbRuleType parameter to 1. For more information, see [Defined Class Codes](https://www.usb.org/defined-class-codes?spm=a2c63.p38356.0.0.56b84b03GUn4kJ).
	DeviceClass *string `json:"DeviceClass,omitempty" xml:"DeviceClass,omitempty"`
	// The subclass of the device. This parameter is required when you set the usbRuleType parameter to 1. For more information, see [Defined Class Codes](https://www.usb.org/defined-class-codes?spm=a2c63.p38356.0.0.56b84b03GUn4kJ).
	DeviceSubclass *string `json:"DeviceSubclass,omitempty" xml:"DeviceSubclass,omitempty"`
	// The ID of the service.
	ProductId *string `json:"ProductId,omitempty" xml:"ProductId,omitempty"`
	// Specifies whether to allow USB redirection. Valid values:
	//
	// * 1: allowed.
	// * 2: disallowed.
	UsbRedirectType *int64 `json:"UsbRedirectType,omitempty" xml:"UsbRedirectType,omitempty"`
	// The type of the USB redirection rule. Valid values:
	//
	// * 1: device class.
	// * 2: device vendor.
	UsbRuleType *int64 `json:"UsbRuleType,omitempty" xml:"UsbRuleType,omitempty"`
	// The ID of the vendor. For more information, see[ Valid USB Vendor IDs (VIDs)](https://www.usb.org/sites/default/files/vendor_ids032322.pdf_1.pdf?spm=a2c63.p38356.0.0.56b84b03GUn4kJ&file=vendor_ids032322.pdf_1.pdf).
	VendorId *string `json:"VendorId,omitempty" xml:"VendorId,omitempty"`
}

func (s ModifyPolicyGroupRequestUsbSupplyRedirectRule) String() string {
	return tea.Prettify(s)
}

func (s ModifyPolicyGroupRequestUsbSupplyRedirectRule) GoString() string {
	return s.String()
}

func (s *ModifyPolicyGroupRequestUsbSupplyRedirectRule) SetDescription(v string) *ModifyPolicyGroupRequestUsbSupplyRedirectRule {
	s.Description = &v
	return s
}

func (s *ModifyPolicyGroupRequestUsbSupplyRedirectRule) SetDeviceClass(v string) *ModifyPolicyGroupRequestUsbSupplyRedirectRule {
	s.DeviceClass = &v
	return s
}

func (s *ModifyPolicyGroupRequestUsbSupplyRedirectRule) SetDeviceSubclass(v string) *ModifyPolicyGroupRequestUsbSupplyRedirectRule {
	s.DeviceSubclass = &v
	return s
}

func (s *ModifyPolicyGroupRequestUsbSupplyRedirectRule) SetProductId(v string) *ModifyPolicyGroupRequestUsbSupplyRedirectRule {
	s.ProductId = &v
	return s
}

func (s *ModifyPolicyGroupRequestUsbSupplyRedirectRule) SetUsbRedirectType(v int64) *ModifyPolicyGroupRequestUsbSupplyRedirectRule {
	s.UsbRedirectType = &v
	return s
}

func (s *ModifyPolicyGroupRequestUsbSupplyRedirectRule) SetUsbRuleType(v int64) *ModifyPolicyGroupRequestUsbSupplyRedirectRule {
	s.UsbRuleType = &v
	return s
}

func (s *ModifyPolicyGroupRequestUsbSupplyRedirectRule) SetVendorId(v string) *ModifyPolicyGroupRequestUsbSupplyRedirectRule {
	s.VendorId = &v
	return s
}

type ModifyPolicyGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyPolicyGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyPolicyGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyPolicyGroupResponseBody) SetRequestId(v string) *ModifyPolicyGroupResponseBody {
	s.RequestId = &v
	return s
}

type ModifyPolicyGroupResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyPolicyGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyPolicyGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyPolicyGroupResponse) GoString() string {
	return s.String()
}

func (s *ModifyPolicyGroupResponse) SetHeaders(v map[string]*string) *ModifyPolicyGroupResponse {
	s.Headers = v
	return s
}

func (s *ModifyPolicyGroupResponse) SetStatusCode(v int32) *ModifyPolicyGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyPolicyGroupResponse) SetBody(v *ModifyPolicyGroupResponseBody) *ModifyPolicyGroupResponse {
	s.Body = v
	return s
}

type ModifyUserEntitlementRequest struct {
	// The IDs of the cloud desktops on which you want to grant permissions to users.
	AuthorizeDesktopId []*string `json:"AuthorizeDesktopId,omitempty" xml:"AuthorizeDesktopId,omitempty" type:"Repeated"`
	// The ID of the users.
	EndUserId []*string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty" type:"Repeated"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The IDs of the cloud desktops on which you want to revoke permissions from users.
	RevokeDesktopId []*string `json:"RevokeDesktopId,omitempty" xml:"RevokeDesktopId,omitempty" type:"Repeated"`
}

func (s ModifyUserEntitlementRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyUserEntitlementRequest) GoString() string {
	return s.String()
}

func (s *ModifyUserEntitlementRequest) SetAuthorizeDesktopId(v []*string) *ModifyUserEntitlementRequest {
	s.AuthorizeDesktopId = v
	return s
}

func (s *ModifyUserEntitlementRequest) SetEndUserId(v []*string) *ModifyUserEntitlementRequest {
	s.EndUserId = v
	return s
}

func (s *ModifyUserEntitlementRequest) SetRegionId(v string) *ModifyUserEntitlementRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyUserEntitlementRequest) SetRevokeDesktopId(v []*string) *ModifyUserEntitlementRequest {
	s.RevokeDesktopId = v
	return s
}

type ModifyUserEntitlementResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyUserEntitlementResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyUserEntitlementResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyUserEntitlementResponseBody) SetRequestId(v string) *ModifyUserEntitlementResponseBody {
	s.RequestId = &v
	return s
}

type ModifyUserEntitlementResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyUserEntitlementResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyUserEntitlementResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyUserEntitlementResponse) GoString() string {
	return s.String()
}

func (s *ModifyUserEntitlementResponse) SetHeaders(v map[string]*string) *ModifyUserEntitlementResponse {
	s.Headers = v
	return s
}

func (s *ModifyUserEntitlementResponse) SetStatusCode(v int32) *ModifyUserEntitlementResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyUserEntitlementResponse) SetBody(v *ModifyUserEntitlementResponseBody) *ModifyUserEntitlementResponse {
	s.Body = v
	return s
}

type ModifyUserToDesktopGroupRequest struct {
	// The ID of the desktop group that you want to assign to users.
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// The IDs of the regular users to whom you want to grant the permissions on the cloud desktop.
	NewEndUserIds []*string `json:"NewEndUserIds,omitempty" xml:"NewEndUserIds,omitempty" type:"Repeated"`
	// The IDs of the original regular users who have the permissions on the cloud desktop.
	OldEndUserIds []*string `json:"OldEndUserIds,omitempty" xml:"OldEndUserIds,omitempty" type:"Repeated"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ModifyUserToDesktopGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyUserToDesktopGroupRequest) GoString() string {
	return s.String()
}

func (s *ModifyUserToDesktopGroupRequest) SetDesktopGroupId(v string) *ModifyUserToDesktopGroupRequest {
	s.DesktopGroupId = &v
	return s
}

func (s *ModifyUserToDesktopGroupRequest) SetNewEndUserIds(v []*string) *ModifyUserToDesktopGroupRequest {
	s.NewEndUserIds = v
	return s
}

func (s *ModifyUserToDesktopGroupRequest) SetOldEndUserIds(v []*string) *ModifyUserToDesktopGroupRequest {
	s.OldEndUserIds = v
	return s
}

func (s *ModifyUserToDesktopGroupRequest) SetRegionId(v string) *ModifyUserToDesktopGroupRequest {
	s.RegionId = &v
	return s
}

type ModifyUserToDesktopGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyUserToDesktopGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyUserToDesktopGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyUserToDesktopGroupResponseBody) SetRequestId(v string) *ModifyUserToDesktopGroupResponseBody {
	s.RequestId = &v
	return s
}

type ModifyUserToDesktopGroupResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyUserToDesktopGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyUserToDesktopGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyUserToDesktopGroupResponse) GoString() string {
	return s.String()
}

func (s *ModifyUserToDesktopGroupResponse) SetHeaders(v map[string]*string) *ModifyUserToDesktopGroupResponse {
	s.Headers = v
	return s
}

func (s *ModifyUserToDesktopGroupResponse) SetStatusCode(v int32) *ModifyUserToDesktopGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyUserToDesktopGroupResponse) SetBody(v *ModifyUserToDesktopGroupResponseBody) *ModifyUserToDesktopGroupResponse {
	s.Body = v
	return s
}

type MoveCdsFileRequest struct {
	// The ID of the cloud disk.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	// The processing mode of files that have the same name.
	//
	// Valid values:
	//
	// *   <!-- -->
	//
	//     refuse
	//
	//     <!-- -->
	//
	//     : If you want to create a file that uses the same name as an existing file in the cloud, the system denies your request and returns the details of the existing file.
	//
	//     <!-- -->
	//
	// *   <!-- -->
	//
	//     auto_rename
	//
	//     <!-- -->
	//
	//     : If you want to create a file that uses the same name as an existing file in the cloud, the system renames the file that you want to create by appending the current time point.
	//
	//     <!-- -->
	//
	// *   <!-- -->
	//
	//     ignore
	//
	//     <!-- -->
	//
	//     : The system allows you to create a file that uses the same name as an existing file in the cloud.
	//
	//     <!-- -->
	//
	// *   <!-- -->
	//
	//     over_write
	//
	//     <!-- -->
	//
	//     : After you create a file that uses the same name as an existing file in the cloud, the new file overwrites the existing file.
	//
	//     <!-- -->
	ConflictPolicy *string `json:"ConflictPolicy,omitempty" xml:"ConflictPolicy,omitempty"`
	// The user ID that you want to use to access the cloud disk.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The ID of the file.
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The group ID.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the parent folder that you want to move. If you want to remove the root folder, set the value to root.
	ParentFolderId *string `json:"ParentFolderId,omitempty" xml:"ParentFolderId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s MoveCdsFileRequest) String() string {
	return tea.Prettify(s)
}

func (s MoveCdsFileRequest) GoString() string {
	return s.String()
}

func (s *MoveCdsFileRequest) SetCdsId(v string) *MoveCdsFileRequest {
	s.CdsId = &v
	return s
}

func (s *MoveCdsFileRequest) SetConflictPolicy(v string) *MoveCdsFileRequest {
	s.ConflictPolicy = &v
	return s
}

func (s *MoveCdsFileRequest) SetEndUserId(v string) *MoveCdsFileRequest {
	s.EndUserId = &v
	return s
}

func (s *MoveCdsFileRequest) SetFileId(v string) *MoveCdsFileRequest {
	s.FileId = &v
	return s
}

func (s *MoveCdsFileRequest) SetGroupId(v string) *MoveCdsFileRequest {
	s.GroupId = &v
	return s
}

func (s *MoveCdsFileRequest) SetParentFolderId(v string) *MoveCdsFileRequest {
	s.ParentFolderId = &v
	return s
}

func (s *MoveCdsFileRequest) SetRegionId(v string) *MoveCdsFileRequest {
	s.RegionId = &v
	return s
}

type MoveCdsFileResponseBody struct {
	// The result of the modification. A value of success indicates that the modification is successful. If the modification failed, an error message is returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message that is returned. This parameter is not returned if the value of Code is success.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The response object when you move a file.
	MoveCdsFileModel *MoveCdsFileResponseBodyMoveCdsFileModel `json:"MoveCdsFileModel,omitempty" xml:"MoveCdsFileModel,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	//
	// Valid values:
	//
	// *   <!-- -->
	//
	//     true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   <!-- -->
	//
	//     false
	//
	//     <!-- -->
	//
	//     <!-- -->
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s MoveCdsFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s MoveCdsFileResponseBody) GoString() string {
	return s.String()
}

func (s *MoveCdsFileResponseBody) SetCode(v string) *MoveCdsFileResponseBody {
	s.Code = &v
	return s
}

func (s *MoveCdsFileResponseBody) SetMessage(v string) *MoveCdsFileResponseBody {
	s.Message = &v
	return s
}

func (s *MoveCdsFileResponseBody) SetMoveCdsFileModel(v *MoveCdsFileResponseBodyMoveCdsFileModel) *MoveCdsFileResponseBody {
	s.MoveCdsFileModel = v
	return s
}

func (s *MoveCdsFileResponseBody) SetRequestId(v string) *MoveCdsFileResponseBody {
	s.RequestId = &v
	return s
}

func (s *MoveCdsFileResponseBody) SetSuccess(v bool) *MoveCdsFileResponseBody {
	s.Success = &v
	return s
}

type MoveCdsFileResponseBodyMoveCdsFileModel struct {
	// The ID of the asynchronous task. This parameter is not returned if you copy files. This parameter is returned if you copy folders in the backend in an asynchronous manner. You can call the GetAsyncTask operation to obtain the ID and details of an asynchronous task.
	AsyncTaskId *string `json:"AsyncTaskId,omitempty" xml:"AsyncTaskId,omitempty"`
	// Indicates whether the file exists.
	//
	// Valid values:
	//
	// *   <!-- -->
	//
	//     true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   <!-- -->
	//
	//     false
	//
	//     <!-- -->
	//
	//     <!-- -->
	Exist *bool `json:"Exist,omitempty" xml:"Exist,omitempty"`
	// The ID of the file.
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
}

func (s MoveCdsFileResponseBodyMoveCdsFileModel) String() string {
	return tea.Prettify(s)
}

func (s MoveCdsFileResponseBodyMoveCdsFileModel) GoString() string {
	return s.String()
}

func (s *MoveCdsFileResponseBodyMoveCdsFileModel) SetAsyncTaskId(v string) *MoveCdsFileResponseBodyMoveCdsFileModel {
	s.AsyncTaskId = &v
	return s
}

func (s *MoveCdsFileResponseBodyMoveCdsFileModel) SetExist(v bool) *MoveCdsFileResponseBodyMoveCdsFileModel {
	s.Exist = &v
	return s
}

func (s *MoveCdsFileResponseBodyMoveCdsFileModel) SetFileId(v string) *MoveCdsFileResponseBodyMoveCdsFileModel {
	s.FileId = &v
	return s
}

type MoveCdsFileResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *MoveCdsFileResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s MoveCdsFileResponse) String() string {
	return tea.Prettify(s)
}

func (s MoveCdsFileResponse) GoString() string {
	return s.String()
}

func (s *MoveCdsFileResponse) SetHeaders(v map[string]*string) *MoveCdsFileResponse {
	s.Headers = v
	return s
}

func (s *MoveCdsFileResponse) SetStatusCode(v int32) *MoveCdsFileResponse {
	s.StatusCode = &v
	return s
}

func (s *MoveCdsFileResponse) SetBody(v *MoveCdsFileResponseBody) *MoveCdsFileResponse {
	s.Body = v
	return s
}

type RebootDesktopsRequest struct {
	// The cloud desktop ID. You can specify one or more desktop IDs. Valid values of N: 1 to 100.
	DesktopId []*string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty" type:"Repeated"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s RebootDesktopsRequest) String() string {
	return tea.Prettify(s)
}

func (s RebootDesktopsRequest) GoString() string {
	return s.String()
}

func (s *RebootDesktopsRequest) SetDesktopId(v []*string) *RebootDesktopsRequest {
	s.DesktopId = v
	return s
}

func (s *RebootDesktopsRequest) SetRegionId(v string) *RebootDesktopsRequest {
	s.RegionId = &v
	return s
}

type RebootDesktopsResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RebootDesktopsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RebootDesktopsResponseBody) GoString() string {
	return s.String()
}

func (s *RebootDesktopsResponseBody) SetRequestId(v string) *RebootDesktopsResponseBody {
	s.RequestId = &v
	return s
}

type RebootDesktopsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RebootDesktopsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RebootDesktopsResponse) String() string {
	return tea.Prettify(s)
}

func (s RebootDesktopsResponse) GoString() string {
	return s.String()
}

func (s *RebootDesktopsResponse) SetHeaders(v map[string]*string) *RebootDesktopsResponse {
	s.Headers = v
	return s
}

func (s *RebootDesktopsResponse) SetStatusCode(v int32) *RebootDesktopsResponse {
	s.StatusCode = &v
	return s
}

func (s *RebootDesktopsResponse) SetBody(v *RebootDesktopsResponseBody) *RebootDesktopsResponse {
	s.Body = v
	return s
}

type RebuildDesktopsRequest struct {
	// The IDs of the cloud desktops.
	DesktopId []*string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty" type:"Repeated"`
	// The ID of the new image.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The operation type on the data disk.
	//
	// > For cloud desktops that do not have data disks, when you call this operation, you do not need to configure this parameter.
	//
	// *   Cloud desktops do not have data disks\
	//     The values that you configured have no impacts.
	//
	// *   Cloud desktops have data disks
	//
	//     1.  If the OS of the cloud desktop is the same as the OS of a destination image:
	//
	//         *   The value replace indicates that the data disk of the cloud desktop is replaced.
	//         *   If you do not specify this parameter, the data disk of the cloud desktop is retained.
	//
	//     2.  If the OS of the cloud desktop is the different from the OS of a destination image:
	//
	//         *   The value replace indicates that the data disk of the cloud desktop is replaced.
	//         *   If you do not specify this parameter, the data disk of the cloud desktop is cleared.
	OperateType *string `json:"OperateType,omitempty" xml:"OperateType,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s RebuildDesktopsRequest) String() string {
	return tea.Prettify(s)
}

func (s RebuildDesktopsRequest) GoString() string {
	return s.String()
}

func (s *RebuildDesktopsRequest) SetDesktopId(v []*string) *RebuildDesktopsRequest {
	s.DesktopId = v
	return s
}

func (s *RebuildDesktopsRequest) SetImageId(v string) *RebuildDesktopsRequest {
	s.ImageId = &v
	return s
}

func (s *RebuildDesktopsRequest) SetOperateType(v string) *RebuildDesktopsRequest {
	s.OperateType = &v
	return s
}

func (s *RebuildDesktopsRequest) SetRegionId(v string) *RebuildDesktopsRequest {
	s.RegionId = &v
	return s
}

type RebuildDesktopsResponseBody struct {
	// The recreation results of cloud desktops by changing images.
	RebuildResults []*RebuildDesktopsResponseBodyRebuildResults `json:"RebuildResults,omitempty" xml:"RebuildResults,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RebuildDesktopsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RebuildDesktopsResponseBody) GoString() string {
	return s.String()
}

func (s *RebuildDesktopsResponseBody) SetRebuildResults(v []*RebuildDesktopsResponseBodyRebuildResults) *RebuildDesktopsResponseBody {
	s.RebuildResults = v
	return s
}

func (s *RebuildDesktopsResponseBody) SetRequestId(v string) *RebuildDesktopsResponseBody {
	s.RequestId = &v
	return s
}

type RebuildDesktopsResponseBodyRebuildResults struct {
	// The recreation result of the cloud desktop by changing the image. A value of success indicates that the image of the cloud desktop is changed. If the image of the cloud desktop failed to be changed, an error message is returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the cloud desktop.
	DesktopId *string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty"`
	// The error message. This parameter is not returned if the value of Code is success.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
}

func (s RebuildDesktopsResponseBodyRebuildResults) String() string {
	return tea.Prettify(s)
}

func (s RebuildDesktopsResponseBodyRebuildResults) GoString() string {
	return s.String()
}

func (s *RebuildDesktopsResponseBodyRebuildResults) SetCode(v string) *RebuildDesktopsResponseBodyRebuildResults {
	s.Code = &v
	return s
}

func (s *RebuildDesktopsResponseBodyRebuildResults) SetDesktopId(v string) *RebuildDesktopsResponseBodyRebuildResults {
	s.DesktopId = &v
	return s
}

func (s *RebuildDesktopsResponseBodyRebuildResults) SetMessage(v string) *RebuildDesktopsResponseBodyRebuildResults {
	s.Message = &v
	return s
}

type RebuildDesktopsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RebuildDesktopsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RebuildDesktopsResponse) String() string {
	return tea.Prettify(s)
}

func (s RebuildDesktopsResponse) GoString() string {
	return s.String()
}

func (s *RebuildDesktopsResponse) SetHeaders(v map[string]*string) *RebuildDesktopsResponse {
	s.Headers = v
	return s
}

func (s *RebuildDesktopsResponse) SetStatusCode(v int32) *RebuildDesktopsResponse {
	s.StatusCode = &v
	return s
}

func (s *RebuildDesktopsResponse) SetBody(v *RebuildDesktopsResponseBody) *RebuildDesktopsResponse {
	s.Body = v
	return s
}

type RemoveFilePermissionRequest struct {
	// The ID of the cloud disk in Cloud Drive Service.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	// The user ID.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The file ID. The ID is a unique identifier for the file.
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The group ID.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The users that you want to authorize.
	MemberList []*RemoveFilePermissionRequestMemberList `json:"MemberList,omitempty" xml:"MemberList,omitempty" type:"Repeated"`
	// The region ID. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s RemoveFilePermissionRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveFilePermissionRequest) GoString() string {
	return s.String()
}

func (s *RemoveFilePermissionRequest) SetCdsId(v string) *RemoveFilePermissionRequest {
	s.CdsId = &v
	return s
}

func (s *RemoveFilePermissionRequest) SetEndUserId(v string) *RemoveFilePermissionRequest {
	s.EndUserId = &v
	return s
}

func (s *RemoveFilePermissionRequest) SetFileId(v string) *RemoveFilePermissionRequest {
	s.FileId = &v
	return s
}

func (s *RemoveFilePermissionRequest) SetGroupId(v string) *RemoveFilePermissionRequest {
	s.GroupId = &v
	return s
}

func (s *RemoveFilePermissionRequest) SetMemberList(v []*RemoveFilePermissionRequestMemberList) *RemoveFilePermissionRequest {
	s.MemberList = v
	return s
}

func (s *RemoveFilePermissionRequest) SetRegionId(v string) *RemoveFilePermissionRequest {
	s.RegionId = &v
	return s
}

type RemoveFilePermissionRequestMemberList struct {
	// The permission information.
	CdsIdentity *RemoveFilePermissionRequestMemberListCdsIdentity `json:"CdsIdentity,omitempty" xml:"CdsIdentity,omitempty" type:"Struct"`
	// The role ID. You can configure permissions on roles or actions. This parameter is used to specify the permissions on roles, which conflicts with the ActionList parameter. When you configure both the parameters, this parameter shall prevail.
	//
	// Valid values:
	//
	// *   SystemFileEditorWithoutShareLink
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     the role that has the permissions to edit files but cannot share files
	//
	//     <!-- -->
	//
	// *   SystemFileUploaderAndDownloaderWithShareLink
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     the role that has the permissions to upload, download, and share files
	//
	//     <!-- -->
	//
	// *   SystemFileDownloader
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     the role that has the permissions to download files
	//
	//     <!-- -->
	//
	// *   SystemFileEditorWithoutDelete
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     the role that has the permissions to edit files but cannot delete files
	//
	//     <!-- -->
	//
	// *   SystemFileOwner
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     the role that has the permissions to collaborate with others
	//
	//     <!-- -->
	//
	// *   SystemFileDownloaderWithShareLink
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     the role that has the permissions to download and share files
	//
	//     <!-- -->
	//
	// *   SystemFileUploaderAndViewer
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     the role that has the permissions to preview or upload files
	//
	//     <!-- -->
	//
	// *   SystemFileViewer
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     the role that has the permissions to preview files
	//
	//     <!-- -->
	//
	// *   SystemFileEditor
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     the role that has the permissions to edit files
	//
	//     <!-- -->
	//
	// *   SystemFileUploaderWithShareLink
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     the role that has the permissions to upload or share files
	//
	//     <!-- -->
	//
	// *   SystemFileUploader
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     the role that has the permission to upload files
	//
	//     <!-- -->
	//
	// *   SystemFileUploaderAndDownloader
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     the role that has the permissions to upload or download files
	//
	//     <!-- -->
	//
	// *   SystemFileMetaViewer
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     the role that has the permissions to view files
	//
	//     <!-- -->
	RoleId *string `json:"RoleId,omitempty" xml:"RoleId,omitempty"`
}

func (s RemoveFilePermissionRequestMemberList) String() string {
	return tea.Prettify(s)
}

func (s RemoveFilePermissionRequestMemberList) GoString() string {
	return s.String()
}

func (s *RemoveFilePermissionRequestMemberList) SetCdsIdentity(v *RemoveFilePermissionRequestMemberListCdsIdentity) *RemoveFilePermissionRequestMemberList {
	s.CdsIdentity = v
	return s
}

func (s *RemoveFilePermissionRequestMemberList) SetRoleId(v string) *RemoveFilePermissionRequestMemberList {
	s.RoleId = &v
	return s
}

type RemoveFilePermissionRequestMemberListCdsIdentity struct {
	// The user ID or group ID.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The object type.
	//
	// Valid values:
	//
	// *   IT_Group
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     group
	//
	//     <!-- -->
	//
	// *   IT_User
	//
	//     <!-- -->
	//
	//     :
	//
	//     <!-- -->
	//
	//     user
	//
	//     <!-- -->
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s RemoveFilePermissionRequestMemberListCdsIdentity) String() string {
	return tea.Prettify(s)
}

func (s RemoveFilePermissionRequestMemberListCdsIdentity) GoString() string {
	return s.String()
}

func (s *RemoveFilePermissionRequestMemberListCdsIdentity) SetId(v string) *RemoveFilePermissionRequestMemberListCdsIdentity {
	s.Id = &v
	return s
}

func (s *RemoveFilePermissionRequestMemberListCdsIdentity) SetType(v string) *RemoveFilePermissionRequestMemberListCdsIdentity {
	s.Type = &v
	return s
}

type RemoveFilePermissionShrinkRequest struct {
	// The ID of the cloud disk in Cloud Drive Service.
	CdsId *string `json:"CdsId,omitempty" xml:"CdsId,omitempty"`
	// The user ID.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The file ID. The ID is a unique identifier for the file.
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The group ID.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The users that you want to authorize.
	MemberListShrink *string `json:"MemberList,omitempty" xml:"MemberList,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s RemoveFilePermissionShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveFilePermissionShrinkRequest) GoString() string {
	return s.String()
}

func (s *RemoveFilePermissionShrinkRequest) SetCdsId(v string) *RemoveFilePermissionShrinkRequest {
	s.CdsId = &v
	return s
}

func (s *RemoveFilePermissionShrinkRequest) SetEndUserId(v string) *RemoveFilePermissionShrinkRequest {
	s.EndUserId = &v
	return s
}

func (s *RemoveFilePermissionShrinkRequest) SetFileId(v string) *RemoveFilePermissionShrinkRequest {
	s.FileId = &v
	return s
}

func (s *RemoveFilePermissionShrinkRequest) SetGroupId(v string) *RemoveFilePermissionShrinkRequest {
	s.GroupId = &v
	return s
}

func (s *RemoveFilePermissionShrinkRequest) SetMemberListShrink(v string) *RemoveFilePermissionShrinkRequest {
	s.MemberListShrink = &v
	return s
}

func (s *RemoveFilePermissionShrinkRequest) SetRegionId(v string) *RemoveFilePermissionShrinkRequest {
	s.RegionId = &v
	return s
}

type RemoveFilePermissionResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RemoveFilePermissionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveFilePermissionResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveFilePermissionResponseBody) SetRequestId(v string) *RemoveFilePermissionResponseBody {
	s.RequestId = &v
	return s
}

type RemoveFilePermissionResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemoveFilePermissionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemoveFilePermissionResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveFilePermissionResponse) GoString() string {
	return s.String()
}

func (s *RemoveFilePermissionResponse) SetHeaders(v map[string]*string) *RemoveFilePermissionResponse {
	s.Headers = v
	return s
}

func (s *RemoveFilePermissionResponse) SetStatusCode(v int32) *RemoveFilePermissionResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveFilePermissionResponse) SetBody(v *RemoveFilePermissionResponseBody) *RemoveFilePermissionResponse {
	s.Body = v
	return s
}

type RemoveUserFromDesktopGroupRequest struct {
	// The ID of the desktop group.
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// The IDs of the desktop groups.
	DesktopGroupIds []*string `json:"DesktopGroupIds,omitempty" xml:"DesktopGroupIds,omitempty" type:"Repeated"`
	// The authorized user to be removed.
	EndUserIds []*string `json:"EndUserIds,omitempty" xml:"EndUserIds,omitempty" type:"Repeated"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s RemoveUserFromDesktopGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveUserFromDesktopGroupRequest) GoString() string {
	return s.String()
}

func (s *RemoveUserFromDesktopGroupRequest) SetDesktopGroupId(v string) *RemoveUserFromDesktopGroupRequest {
	s.DesktopGroupId = &v
	return s
}

func (s *RemoveUserFromDesktopGroupRequest) SetDesktopGroupIds(v []*string) *RemoveUserFromDesktopGroupRequest {
	s.DesktopGroupIds = v
	return s
}

func (s *RemoveUserFromDesktopGroupRequest) SetEndUserIds(v []*string) *RemoveUserFromDesktopGroupRequest {
	s.EndUserIds = v
	return s
}

func (s *RemoveUserFromDesktopGroupRequest) SetRegionId(v string) *RemoveUserFromDesktopGroupRequest {
	s.RegionId = &v
	return s
}

type RemoveUserFromDesktopGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RemoveUserFromDesktopGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveUserFromDesktopGroupResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveUserFromDesktopGroupResponseBody) SetRequestId(v string) *RemoveUserFromDesktopGroupResponseBody {
	s.RequestId = &v
	return s
}

type RemoveUserFromDesktopGroupResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemoveUserFromDesktopGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemoveUserFromDesktopGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveUserFromDesktopGroupResponse) GoString() string {
	return s.String()
}

func (s *RemoveUserFromDesktopGroupResponse) SetHeaders(v map[string]*string) *RemoveUserFromDesktopGroupResponse {
	s.Headers = v
	return s
}

func (s *RemoveUserFromDesktopGroupResponse) SetStatusCode(v int32) *RemoveUserFromDesktopGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveUserFromDesktopGroupResponse) SetBody(v *RemoveUserFromDesktopGroupResponseBody) *RemoveUserFromDesktopGroupResponse {
	s.Body = v
	return s
}

type RemoveUserFromDesktopOversoldUserGroupRequest struct {
	EndUserId       *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	OversoldGroupId *string `json:"OversoldGroupId,omitempty" xml:"OversoldGroupId,omitempty"`
	UserDesktopId   *string `json:"UserDesktopId,omitempty" xml:"UserDesktopId,omitempty"`
	UserGroupId     *string `json:"UserGroupId,omitempty" xml:"UserGroupId,omitempty"`
}

func (s RemoveUserFromDesktopOversoldUserGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveUserFromDesktopOversoldUserGroupRequest) GoString() string {
	return s.String()
}

func (s *RemoveUserFromDesktopOversoldUserGroupRequest) SetEndUserId(v string) *RemoveUserFromDesktopOversoldUserGroupRequest {
	s.EndUserId = &v
	return s
}

func (s *RemoveUserFromDesktopOversoldUserGroupRequest) SetOversoldGroupId(v string) *RemoveUserFromDesktopOversoldUserGroupRequest {
	s.OversoldGroupId = &v
	return s
}

func (s *RemoveUserFromDesktopOversoldUserGroupRequest) SetUserDesktopId(v string) *RemoveUserFromDesktopOversoldUserGroupRequest {
	s.UserDesktopId = &v
	return s
}

func (s *RemoveUserFromDesktopOversoldUserGroupRequest) SetUserGroupId(v string) *RemoveUserFromDesktopOversoldUserGroupRequest {
	s.UserGroupId = &v
	return s
}

type RemoveUserFromDesktopOversoldUserGroupResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RemoveUserFromDesktopOversoldUserGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveUserFromDesktopOversoldUserGroupResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveUserFromDesktopOversoldUserGroupResponseBody) SetRequestId(v string) *RemoveUserFromDesktopOversoldUserGroupResponseBody {
	s.RequestId = &v
	return s
}

type RemoveUserFromDesktopOversoldUserGroupResponse struct {
	Headers    map[string]*string                                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemoveUserFromDesktopOversoldUserGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemoveUserFromDesktopOversoldUserGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveUserFromDesktopOversoldUserGroupResponse) GoString() string {
	return s.String()
}

func (s *RemoveUserFromDesktopOversoldUserGroupResponse) SetHeaders(v map[string]*string) *RemoveUserFromDesktopOversoldUserGroupResponse {
	s.Headers = v
	return s
}

func (s *RemoveUserFromDesktopOversoldUserGroupResponse) SetStatusCode(v int32) *RemoveUserFromDesktopOversoldUserGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveUserFromDesktopOversoldUserGroupResponse) SetBody(v *RemoveUserFromDesktopOversoldUserGroupResponseBody) *RemoveUserFromDesktopOversoldUserGroupResponse {
	s.Body = v
	return s
}

type RenewDesktopOversoldGroupRequest struct {
	OversoldGroupId *string `json:"OversoldGroupId,omitempty" xml:"OversoldGroupId,omitempty"`
	Period          *int32  `json:"Period,omitempty" xml:"Period,omitempty"`
	PeriodUnit      *string `json:"PeriodUnit,omitempty" xml:"PeriodUnit,omitempty"`
}

func (s RenewDesktopOversoldGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s RenewDesktopOversoldGroupRequest) GoString() string {
	return s.String()
}

func (s *RenewDesktopOversoldGroupRequest) SetOversoldGroupId(v string) *RenewDesktopOversoldGroupRequest {
	s.OversoldGroupId = &v
	return s
}

func (s *RenewDesktopOversoldGroupRequest) SetPeriod(v int32) *RenewDesktopOversoldGroupRequest {
	s.Period = &v
	return s
}

func (s *RenewDesktopOversoldGroupRequest) SetPeriodUnit(v string) *RenewDesktopOversoldGroupRequest {
	s.PeriodUnit = &v
	return s
}

type RenewDesktopOversoldGroupResponseBody struct {
	Data      *RenewDesktopOversoldGroupResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	RequestId *string                                    `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RenewDesktopOversoldGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RenewDesktopOversoldGroupResponseBody) GoString() string {
	return s.String()
}

func (s *RenewDesktopOversoldGroupResponseBody) SetData(v *RenewDesktopOversoldGroupResponseBodyData) *RenewDesktopOversoldGroupResponseBody {
	s.Data = v
	return s
}

func (s *RenewDesktopOversoldGroupResponseBody) SetRequestId(v string) *RenewDesktopOversoldGroupResponseBody {
	s.RequestId = &v
	return s
}

type RenewDesktopOversoldGroupResponseBodyData struct {
	OrderId         *int64  `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	OversoldGroupId *string `json:"OversoldGroupId,omitempty" xml:"OversoldGroupId,omitempty"`
}

func (s RenewDesktopOversoldGroupResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s RenewDesktopOversoldGroupResponseBodyData) GoString() string {
	return s.String()
}

func (s *RenewDesktopOversoldGroupResponseBodyData) SetOrderId(v int64) *RenewDesktopOversoldGroupResponseBodyData {
	s.OrderId = &v
	return s
}

func (s *RenewDesktopOversoldGroupResponseBodyData) SetOversoldGroupId(v string) *RenewDesktopOversoldGroupResponseBodyData {
	s.OversoldGroupId = &v
	return s
}

type RenewDesktopOversoldGroupResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RenewDesktopOversoldGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RenewDesktopOversoldGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s RenewDesktopOversoldGroupResponse) GoString() string {
	return s.String()
}

func (s *RenewDesktopOversoldGroupResponse) SetHeaders(v map[string]*string) *RenewDesktopOversoldGroupResponse {
	s.Headers = v
	return s
}

func (s *RenewDesktopOversoldGroupResponse) SetStatusCode(v int32) *RenewDesktopOversoldGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *RenewDesktopOversoldGroupResponse) SetBody(v *RenewDesktopOversoldGroupResponseBody) *RenewDesktopOversoldGroupResponse {
	s.Body = v
	return s
}

type RenewDesktopsRequest struct {
	// Specifies whether to enable the automatic payment feature.
	//
	// Valid values:
	//
	// *   true (default): enables the auto-payment feature.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     Make sure that your account has sufficient balance. Otherwise, no order is generated.
	//
	//     <!-- -->
	//
	// *   false: disables the auto-payment feature. In this case, an order is generated, and no payment is automatically made.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     You can log on to the EDS console and complete the payment based on the order number.
	//
	//     <!-- -->
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The cloud desktop ID. Only subscription cloud desktops can be renewed.
	DesktopId []*string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty" type:"Repeated"`
	// The renewal duration. Valid values of this parameter are determined by the value of the `PeriodUnit` parameter.
	//
	// *   Valid values if you set the `PeriodUnit` parameter to `Month`: 1, 2, 3, and 6
	// *   Valid values if you set the `PeriodUnit` parameter to `Year`: 1, 2, 3, 4, 5, and 6
	//
	// Default value: 1.
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The unit of the renewal duration that is specified by the Period parameter.
	//
	// Valid values:
	//
	// *   Month (default)
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Year
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	PeriodUnit *string `json:"PeriodUnit,omitempty" xml:"PeriodUnit,omitempty"`
	// The ID of the sales promotion.
	PromotionId *string `json:"PromotionId,omitempty" xml:"PromotionId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~196646~~) to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s RenewDesktopsRequest) String() string {
	return tea.Prettify(s)
}

func (s RenewDesktopsRequest) GoString() string {
	return s.String()
}

func (s *RenewDesktopsRequest) SetAutoPay(v bool) *RenewDesktopsRequest {
	s.AutoPay = &v
	return s
}

func (s *RenewDesktopsRequest) SetDesktopId(v []*string) *RenewDesktopsRequest {
	s.DesktopId = v
	return s
}

func (s *RenewDesktopsRequest) SetPeriod(v int32) *RenewDesktopsRequest {
	s.Period = &v
	return s
}

func (s *RenewDesktopsRequest) SetPeriodUnit(v string) *RenewDesktopsRequest {
	s.PeriodUnit = &v
	return s
}

func (s *RenewDesktopsRequest) SetPromotionId(v string) *RenewDesktopsRequest {
	s.PromotionId = &v
	return s
}

func (s *RenewDesktopsRequest) SetRegionId(v string) *RenewDesktopsRequest {
	s.RegionId = &v
	return s
}

type RenewDesktopsResponseBody struct {
	// The order ID.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RenewDesktopsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RenewDesktopsResponseBody) GoString() string {
	return s.String()
}

func (s *RenewDesktopsResponseBody) SetOrderId(v string) *RenewDesktopsResponseBody {
	s.OrderId = &v
	return s
}

func (s *RenewDesktopsResponseBody) SetRequestId(v string) *RenewDesktopsResponseBody {
	s.RequestId = &v
	return s
}

type RenewDesktopsResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RenewDesktopsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RenewDesktopsResponse) String() string {
	return tea.Prettify(s)
}

func (s RenewDesktopsResponse) GoString() string {
	return s.String()
}

func (s *RenewDesktopsResponse) SetHeaders(v map[string]*string) *RenewDesktopsResponse {
	s.Headers = v
	return s
}

func (s *RenewDesktopsResponse) SetStatusCode(v int32) *RenewDesktopsResponse {
	s.StatusCode = &v
	return s
}

func (s *RenewDesktopsResponse) SetBody(v *RenewDesktopsResponseBody) *RenewDesktopsResponse {
	s.Body = v
	return s
}

type RenewNetworkPackagesRequest struct {
	// Specifies whether to enable automatic payment. Valid values:
	//
	// *   true: enables automatic payment. Make sure that you have sufficient balance in your account. Otherwise, abnormal orders are generated.
	// *   false: generates the order with no payment made. You can log on to the EDS console and complete the payment based on the order number.
	//
	// Default value: true.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The IDs of Internet access packages.
	NetworkPackageId []*string `json:"NetworkPackageId,omitempty" xml:"NetworkPackageId,omitempty" type:"Repeated"`
	// The subscription duration if you specify subscription as the new billing method for the cloud desktop. The unit of the value is specified by the `PeriodUnit` parameter. This parameter takes effect only when the `ChargeType` parameter is set to `PrePaid`.
	//
	// *   If the `PeriodUnit` parameter is set to `Week`, the valid value of the Period parameter is 1.
	// *   If the `PeriodUnit` parameter is set to `Month`, the valid values of the Period parameter are 1, 2, 3, and 6.
	// *   If the `PeriodUnit` parameter is set to `Year`, the valid values of the Period parameter are 1, 2, 3, 4, and 5.
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The unit of the renewal duration specified by the Period parameter. Valid values:
	//
	// *   Month
	// *   Year
	//
	// Default value: Month.
	PeriodUnit *string `json:"PeriodUnit,omitempty" xml:"PeriodUnit,omitempty"`
	// The ID of the promotion. You can call the `GetResourcePrice` operation to obtain the ID of the promotion.
	PromotionId *string `json:"PromotionId,omitempty" xml:"PromotionId,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~DescribeRegions~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s RenewNetworkPackagesRequest) String() string {
	return tea.Prettify(s)
}

func (s RenewNetworkPackagesRequest) GoString() string {
	return s.String()
}

func (s *RenewNetworkPackagesRequest) SetAutoPay(v bool) *RenewNetworkPackagesRequest {
	s.AutoPay = &v
	return s
}

func (s *RenewNetworkPackagesRequest) SetNetworkPackageId(v []*string) *RenewNetworkPackagesRequest {
	s.NetworkPackageId = v
	return s
}

func (s *RenewNetworkPackagesRequest) SetPeriod(v int32) *RenewNetworkPackagesRequest {
	s.Period = &v
	return s
}

func (s *RenewNetworkPackagesRequest) SetPeriodUnit(v string) *RenewNetworkPackagesRequest {
	s.PeriodUnit = &v
	return s
}

func (s *RenewNetworkPackagesRequest) SetPromotionId(v string) *RenewNetworkPackagesRequest {
	s.PromotionId = &v
	return s
}

func (s *RenewNetworkPackagesRequest) SetRegionId(v string) *RenewNetworkPackagesRequest {
	s.RegionId = &v
	return s
}

type RenewNetworkPackagesResponseBody struct {
	// The ID of the order.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RenewNetworkPackagesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RenewNetworkPackagesResponseBody) GoString() string {
	return s.String()
}

func (s *RenewNetworkPackagesResponseBody) SetOrderId(v string) *RenewNetworkPackagesResponseBody {
	s.OrderId = &v
	return s
}

func (s *RenewNetworkPackagesResponseBody) SetRequestId(v string) *RenewNetworkPackagesResponseBody {
	s.RequestId = &v
	return s
}

type RenewNetworkPackagesResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RenewNetworkPackagesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RenewNetworkPackagesResponse) String() string {
	return tea.Prettify(s)
}

func (s RenewNetworkPackagesResponse) GoString() string {
	return s.String()
}

func (s *RenewNetworkPackagesResponse) SetHeaders(v map[string]*string) *RenewNetworkPackagesResponse {
	s.Headers = v
	return s
}

func (s *RenewNetworkPackagesResponse) SetStatusCode(v int32) *RenewNetworkPackagesResponse {
	s.StatusCode = &v
	return s
}

func (s *RenewNetworkPackagesResponse) SetBody(v *RenewNetworkPackagesResponseBody) *RenewNetworkPackagesResponse {
	s.Body = v
	return s
}

type ResetDesktopsRequest struct {
	// The ID of the desktop group. If you specify the `DesktopId` parameter, ignore the `DesktopGroupId` parameter. If you do not specify the `DesktopId` parameter, specify the `DesktopGroupId` parameter in the call to request all IDs of the cloud desktops in the specified desktop group.``
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// The IDs of the cloud desktops. You can specify 1 to 100 cloud desktop IDs.
	DesktopId []*string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty" type:"Repeated"`
	// The ID of the image.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The billing method.
	//
	// > This parameter is available only when you reset desktop groups. If you leave this parameter empty, all cloud desktops in the specified desktop group are reset, regardless of how the cloud desktops are billed.
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~436773~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The type of the disk that you want to reset.
	ResetType *string `json:"ResetType,omitempty" xml:"ResetType,omitempty"`
}

func (s ResetDesktopsRequest) String() string {
	return tea.Prettify(s)
}

func (s ResetDesktopsRequest) GoString() string {
	return s.String()
}

func (s *ResetDesktopsRequest) SetDesktopGroupId(v string) *ResetDesktopsRequest {
	s.DesktopGroupId = &v
	return s
}

func (s *ResetDesktopsRequest) SetDesktopId(v []*string) *ResetDesktopsRequest {
	s.DesktopId = v
	return s
}

func (s *ResetDesktopsRequest) SetImageId(v string) *ResetDesktopsRequest {
	s.ImageId = &v
	return s
}

func (s *ResetDesktopsRequest) SetPayType(v string) *ResetDesktopsRequest {
	s.PayType = &v
	return s
}

func (s *ResetDesktopsRequest) SetRegionId(v string) *ResetDesktopsRequest {
	s.RegionId = &v
	return s
}

func (s *ResetDesktopsRequest) SetResetType(v string) *ResetDesktopsRequest {
	s.ResetType = &v
	return s
}

type ResetDesktopsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ResetDesktopsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ResetDesktopsResponseBody) GoString() string {
	return s.String()
}

func (s *ResetDesktopsResponseBody) SetRequestId(v string) *ResetDesktopsResponseBody {
	s.RequestId = &v
	return s
}

type ResetDesktopsResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ResetDesktopsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ResetDesktopsResponse) String() string {
	return tea.Prettify(s)
}

func (s ResetDesktopsResponse) GoString() string {
	return s.String()
}

func (s *ResetDesktopsResponse) SetHeaders(v map[string]*string) *ResetDesktopsResponse {
	s.Headers = v
	return s
}

func (s *ResetDesktopsResponse) SetStatusCode(v int32) *ResetDesktopsResponse {
	s.StatusCode = &v
	return s
}

func (s *ResetDesktopsResponse) SetBody(v *ResetDesktopsResponseBody) *ResetDesktopsResponse {
	s.Body = v
	return s
}

type ResetNASDefaultMountTargetRequest struct {
	// The ID of the NAS file system.
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ResetNASDefaultMountTargetRequest) String() string {
	return tea.Prettify(s)
}

func (s ResetNASDefaultMountTargetRequest) GoString() string {
	return s.String()
}

func (s *ResetNASDefaultMountTargetRequest) SetFileSystemId(v string) *ResetNASDefaultMountTargetRequest {
	s.FileSystemId = &v
	return s
}

func (s *ResetNASDefaultMountTargetRequest) SetRegionId(v string) *ResetNASDefaultMountTargetRequest {
	s.RegionId = &v
	return s
}

type ResetNASDefaultMountTargetResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ResetNASDefaultMountTargetResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ResetNASDefaultMountTargetResponseBody) GoString() string {
	return s.String()
}

func (s *ResetNASDefaultMountTargetResponseBody) SetRequestId(v string) *ResetNASDefaultMountTargetResponseBody {
	s.RequestId = &v
	return s
}

type ResetNASDefaultMountTargetResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ResetNASDefaultMountTargetResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ResetNASDefaultMountTargetResponse) String() string {
	return tea.Prettify(s)
}

func (s ResetNASDefaultMountTargetResponse) GoString() string {
	return s.String()
}

func (s *ResetNASDefaultMountTargetResponse) SetHeaders(v map[string]*string) *ResetNASDefaultMountTargetResponse {
	s.Headers = v
	return s
}

func (s *ResetNASDefaultMountTargetResponse) SetStatusCode(v int32) *ResetNASDefaultMountTargetResponse {
	s.StatusCode = &v
	return s
}

func (s *ResetNASDefaultMountTargetResponse) SetBody(v *ResetNASDefaultMountTargetResponseBody) *ResetNASDefaultMountTargetResponse {
	s.Body = v
	return s
}

type ResetSnapshotRequest struct {
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the snapshot.
	SnapshotId *string `json:"SnapshotId,omitempty" xml:"SnapshotId,omitempty"`
}

func (s ResetSnapshotRequest) String() string {
	return tea.Prettify(s)
}

func (s ResetSnapshotRequest) GoString() string {
	return s.String()
}

func (s *ResetSnapshotRequest) SetRegionId(v string) *ResetSnapshotRequest {
	s.RegionId = &v
	return s
}

func (s *ResetSnapshotRequest) SetSnapshotId(v string) *ResetSnapshotRequest {
	s.SnapshotId = &v
	return s
}

type ResetSnapshotResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ResetSnapshotResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ResetSnapshotResponseBody) GoString() string {
	return s.String()
}

func (s *ResetSnapshotResponseBody) SetRequestId(v string) *ResetSnapshotResponseBody {
	s.RequestId = &v
	return s
}

type ResetSnapshotResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ResetSnapshotResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ResetSnapshotResponse) String() string {
	return tea.Prettify(s)
}

func (s ResetSnapshotResponse) GoString() string {
	return s.String()
}

func (s *ResetSnapshotResponse) SetHeaders(v map[string]*string) *ResetSnapshotResponse {
	s.Headers = v
	return s
}

func (s *ResetSnapshotResponse) SetStatusCode(v int32) *ResetSnapshotResponse {
	s.StatusCode = &v
	return s
}

func (s *ResetSnapshotResponse) SetBody(v *ResetSnapshotResponseBody) *ResetSnapshotResponse {
	s.Body = v
	return s
}

type RevokeCoordinatePrivilegeRequest struct {
	// The ID of the stream coordination task.
	CoId *string `json:"CoId,omitempty" xml:"CoId,omitempty"`
	// The ID of the end user.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The type of user who requires the coordinate permissions.
	//
	// Set the value to TENANT_ADMIN. Only tenant administrators can be granted with the coordinate permissions.
	UserType *string `json:"UserType,omitempty" xml:"UserType,omitempty"`
	// The unique identifier of the client. If you use an Alibaba Cloud Workspace client, click **About** on the client logon page to view the identifier of the client.
	Uuid *string `json:"Uuid,omitempty" xml:"Uuid,omitempty"`
}

func (s RevokeCoordinatePrivilegeRequest) String() string {
	return tea.Prettify(s)
}

func (s RevokeCoordinatePrivilegeRequest) GoString() string {
	return s.String()
}

func (s *RevokeCoordinatePrivilegeRequest) SetCoId(v string) *RevokeCoordinatePrivilegeRequest {
	s.CoId = &v
	return s
}

func (s *RevokeCoordinatePrivilegeRequest) SetEndUserId(v string) *RevokeCoordinatePrivilegeRequest {
	s.EndUserId = &v
	return s
}

func (s *RevokeCoordinatePrivilegeRequest) SetRegionId(v string) *RevokeCoordinatePrivilegeRequest {
	s.RegionId = &v
	return s
}

func (s *RevokeCoordinatePrivilegeRequest) SetUserType(v string) *RevokeCoordinatePrivilegeRequest {
	s.UserType = &v
	return s
}

func (s *RevokeCoordinatePrivilegeRequest) SetUuid(v string) *RevokeCoordinatePrivilegeRequest {
	s.Uuid = &v
	return s
}

type RevokeCoordinatePrivilegeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RevokeCoordinatePrivilegeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RevokeCoordinatePrivilegeResponseBody) GoString() string {
	return s.String()
}

func (s *RevokeCoordinatePrivilegeResponseBody) SetRequestId(v string) *RevokeCoordinatePrivilegeResponseBody {
	s.RequestId = &v
	return s
}

type RevokeCoordinatePrivilegeResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RevokeCoordinatePrivilegeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RevokeCoordinatePrivilegeResponse) String() string {
	return tea.Prettify(s)
}

func (s RevokeCoordinatePrivilegeResponse) GoString() string {
	return s.String()
}

func (s *RevokeCoordinatePrivilegeResponse) SetHeaders(v map[string]*string) *RevokeCoordinatePrivilegeResponse {
	s.Headers = v
	return s
}

func (s *RevokeCoordinatePrivilegeResponse) SetStatusCode(v int32) *RevokeCoordinatePrivilegeResponse {
	s.StatusCode = &v
	return s
}

func (s *RevokeCoordinatePrivilegeResponse) SetBody(v *RevokeCoordinatePrivilegeResponseBody) *RevokeCoordinatePrivilegeResponse {
	s.Body = v
	return s
}

type RunCommandRequest struct {
	// The content of the command. The command content can be plaintext or Base64-encoded.\
	// The Base64-encoded command content cannot exceed 16 KB in size.
	//
	// > If the command content is Base64-encoded, you must set the ContentEncoding parameter to Base64.
	CommandContent *string `json:"CommandContent,omitempty" xml:"CommandContent,omitempty"`
	// The encoding mode of the command content. Valid values:
	//
	// *   PlainText: The command content is not encoded.
	// *   Base64: The command content is Base64-encoded.
	//
	// Default value: PlainText. If the specified value of this parameter is invalid, PlainText is used by default.
	ContentEncoding *string `json:"ContentEncoding,omitempty" xml:"ContentEncoding,omitempty"`
	// The ID of cloud desktop N. Valid values of N: 1 to 50.\
	// If multiple cloud desktops are specified and the command execution succeeds on at least one of the cloud desktops, the operation is considered successful. If multiple cloud desktops are specified and the command execution fails on all the cloud desktops, verify the value of the parameter and try again.
	DesktopId []*string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty" type:"Repeated"`
	// The ID of the end user.
	EndUserId *string `json:"EndUserId,omitempty" xml:"EndUserId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The timeout period for the command to run. Unit: seconds. Default value: 60.\
	// A timeout error occurs if the command cannot be run because the process slows down or because a specific module or the Cloud Assistant client does not exist. When a timeout error occurs, the command process is forcibly terminated.
	Timeout *int64 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	// The language of the O\&M command. Valid values:
	//
	// *   RunBatScript
	// *   RunPowerShellScript
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s RunCommandRequest) String() string {
	return tea.Prettify(s)
}

func (s RunCommandRequest) GoString() string {
	return s.String()
}

func (s *RunCommandRequest) SetCommandContent(v string) *RunCommandRequest {
	s.CommandContent = &v
	return s
}

func (s *RunCommandRequest) SetContentEncoding(v string) *RunCommandRequest {
	s.ContentEncoding = &v
	return s
}

func (s *RunCommandRequest) SetDesktopId(v []*string) *RunCommandRequest {
	s.DesktopId = v
	return s
}

func (s *RunCommandRequest) SetEndUserId(v string) *RunCommandRequest {
	s.EndUserId = &v
	return s
}

func (s *RunCommandRequest) SetRegionId(v string) *RunCommandRequest {
	s.RegionId = &v
	return s
}

func (s *RunCommandRequest) SetTimeout(v int64) *RunCommandRequest {
	s.Timeout = &v
	return s
}

func (s *RunCommandRequest) SetType(v string) *RunCommandRequest {
	s.Type = &v
	return s
}

type RunCommandResponseBody struct {
	// The ID of the command execution.
	InvokeId *string `json:"InvokeId,omitempty" xml:"InvokeId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RunCommandResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RunCommandResponseBody) GoString() string {
	return s.String()
}

func (s *RunCommandResponseBody) SetInvokeId(v string) *RunCommandResponseBody {
	s.InvokeId = &v
	return s
}

func (s *RunCommandResponseBody) SetRequestId(v string) *RunCommandResponseBody {
	s.RequestId = &v
	return s
}

type RunCommandResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RunCommandResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RunCommandResponse) String() string {
	return tea.Prettify(s)
}

func (s RunCommandResponse) GoString() string {
	return s.String()
}

func (s *RunCommandResponse) SetHeaders(v map[string]*string) *RunCommandResponse {
	s.Headers = v
	return s
}

func (s *RunCommandResponse) SetStatusCode(v int32) *RunCommandResponse {
	s.StatusCode = &v
	return s
}

func (s *RunCommandResponse) SetBody(v *RunCommandResponseBody) *RunCommandResponse {
	s.Body = v
	return s
}

type SendVerifyCodeRequest struct {
	// The information in JSON format that is required for sending the verification code. To verify the security of CEN, you must provide the ID of the CEN instance and the ID of the Alibaba Cloud account to which the instance belongs.
	//
	// *   CenId: the ID of the CEN instance
	// *   CenOwnerId: the ID of the Alibaba Cloud account to which the CEN instance belongs.
	//
	// Note: If you specify the CenId parameter and the CEN instance that you specify for the CenId parameter belongs to the Alibaba Cloud account, skip this parameter. If you specify the CenId parameter and the CEN instance that you specify for the CenId parameter belongs to another Alibaba Cloud account, enter the ID of the exact Alibaba Cloud account. Example: {"cenOwnerId": 1234567890\*\*\*\*\*\*,"cenId": "cen-3weq30r6t0s7t4\*\*\*\*"}.
	ExtraInfo *string `json:"ExtraInfo,omitempty" xml:"ExtraInfo,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The action that indicates what the verification code is used for. The parameter is only used to verify the security of CEN. Valid value: eds_cenID_securityverification.
	VerifyCodeAction *string `json:"VerifyCodeAction,omitempty" xml:"VerifyCodeAction,omitempty"`
}

func (s SendVerifyCodeRequest) String() string {
	return tea.Prettify(s)
}

func (s SendVerifyCodeRequest) GoString() string {
	return s.String()
}

func (s *SendVerifyCodeRequest) SetExtraInfo(v string) *SendVerifyCodeRequest {
	s.ExtraInfo = &v
	return s
}

func (s *SendVerifyCodeRequest) SetRegionId(v string) *SendVerifyCodeRequest {
	s.RegionId = &v
	return s
}

func (s *SendVerifyCodeRequest) SetVerifyCodeAction(v string) *SendVerifyCodeRequest {
	s.VerifyCodeAction = &v
	return s
}

type SendVerifyCodeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SendVerifyCodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SendVerifyCodeResponseBody) GoString() string {
	return s.String()
}

func (s *SendVerifyCodeResponseBody) SetRequestId(v string) *SendVerifyCodeResponseBody {
	s.RequestId = &v
	return s
}

type SendVerifyCodeResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SendVerifyCodeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SendVerifyCodeResponse) String() string {
	return tea.Prettify(s)
}

func (s SendVerifyCodeResponse) GoString() string {
	return s.String()
}

func (s *SendVerifyCodeResponse) SetHeaders(v map[string]*string) *SendVerifyCodeResponse {
	s.Headers = v
	return s
}

func (s *SendVerifyCodeResponse) SetStatusCode(v int32) *SendVerifyCodeResponse {
	s.StatusCode = &v
	return s
}

func (s *SendVerifyCodeResponse) SetBody(v *SendVerifyCodeResponseBody) *SendVerifyCodeResponse {
	s.Body = v
	return s
}

type SetDesktopGroupScaleTimerRequest struct {
	// The ID of the desktop group.
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The information about the scheduled auto scaling tasks.
	ScaleTimerInfos []*SetDesktopGroupScaleTimerRequestScaleTimerInfos `json:"ScaleTimerInfos,omitempty" xml:"ScaleTimerInfos,omitempty" type:"Repeated"`
}

func (s SetDesktopGroupScaleTimerRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDesktopGroupScaleTimerRequest) GoString() string {
	return s.String()
}

func (s *SetDesktopGroupScaleTimerRequest) SetDesktopGroupId(v string) *SetDesktopGroupScaleTimerRequest {
	s.DesktopGroupId = &v
	return s
}

func (s *SetDesktopGroupScaleTimerRequest) SetRegionId(v string) *SetDesktopGroupScaleTimerRequest {
	s.RegionId = &v
	return s
}

func (s *SetDesktopGroupScaleTimerRequest) SetScaleTimerInfos(v []*SetDesktopGroupScaleTimerRequestScaleTimerInfos) *SetDesktopGroupScaleTimerRequest {
	s.ScaleTimerInfos = v
	return s
}

type SetDesktopGroupScaleTimerRequestScaleTimerInfos struct {
	// The number of cloud desktops that you want to create in the desktop group. Valid values: 0 to 200. You must configure this parameter for the scaling policy.
	BuyResAmount *int32 `json:"BuyResAmount,omitempty" xml:"BuyResAmount,omitempty"`
	// The CRON expression that is used when an auto scaling task is triggered.
	Cron *string `json:"Cron,omitempty" xml:"Cron,omitempty"`
	// The keep-alive duration after the cloud desktop is disconnected. Unit: milliseconds.
	KeepDuration *int64 `json:"KeepDuration,omitempty" xml:"KeepDuration,omitempty"`
	// The load balancing policy of the multi-session desktop group.
	LoadPolicy *int32 `json:"LoadPolicy,omitempty" xml:"LoadPolicy,omitempty"`
	// The maximum number of cloud desktops in the workspace after scaling. Valid values: 0 to 200. You must configure this parameter for the scaling policy.
	MaxResAmount *int32 `json:"MaxResAmount,omitempty" xml:"MaxResAmount,omitempty"`
	// The minimum number of cloud desktops that can be connected. Valid values: 0 to 200.
	MinResAmount *int32 `json:"MinResAmount,omitempty" xml:"MinResAmount,omitempty"`
	// The threshold for the ratio of connected sessions. This parameter is the condition that triggers auto scaling in a multi-session desktop group. `Ratio of connected sessions = Number of connected sessions/(Total number of cloud desktops  Maximum number of sessions supported by each cloud desktop)  100%`. When the ratio of connected sessions is greater than the specified threshold, desktop scale-out is automatically triggered. When the ratio of connected sessions is smaller than the specified threshold, desktop scale-in is automatically triggered under a specific condition.
	RatioThreshold *float32 `json:"RatioThreshold,omitempty" xml:"RatioThreshold,omitempty"`
	// The type of the policy.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s SetDesktopGroupScaleTimerRequestScaleTimerInfos) String() string {
	return tea.Prettify(s)
}

func (s SetDesktopGroupScaleTimerRequestScaleTimerInfos) GoString() string {
	return s.String()
}

func (s *SetDesktopGroupScaleTimerRequestScaleTimerInfos) SetBuyResAmount(v int32) *SetDesktopGroupScaleTimerRequestScaleTimerInfos {
	s.BuyResAmount = &v
	return s
}

func (s *SetDesktopGroupScaleTimerRequestScaleTimerInfos) SetCron(v string) *SetDesktopGroupScaleTimerRequestScaleTimerInfos {
	s.Cron = &v
	return s
}

func (s *SetDesktopGroupScaleTimerRequestScaleTimerInfos) SetKeepDuration(v int64) *SetDesktopGroupScaleTimerRequestScaleTimerInfos {
	s.KeepDuration = &v
	return s
}

func (s *SetDesktopGroupScaleTimerRequestScaleTimerInfos) SetLoadPolicy(v int32) *SetDesktopGroupScaleTimerRequestScaleTimerInfos {
	s.LoadPolicy = &v
	return s
}

func (s *SetDesktopGroupScaleTimerRequestScaleTimerInfos) SetMaxResAmount(v int32) *SetDesktopGroupScaleTimerRequestScaleTimerInfos {
	s.MaxResAmount = &v
	return s
}

func (s *SetDesktopGroupScaleTimerRequestScaleTimerInfos) SetMinResAmount(v int32) *SetDesktopGroupScaleTimerRequestScaleTimerInfos {
	s.MinResAmount = &v
	return s
}

func (s *SetDesktopGroupScaleTimerRequestScaleTimerInfos) SetRatioThreshold(v float32) *SetDesktopGroupScaleTimerRequestScaleTimerInfos {
	s.RatioThreshold = &v
	return s
}

func (s *SetDesktopGroupScaleTimerRequestScaleTimerInfos) SetType(v string) *SetDesktopGroupScaleTimerRequestScaleTimerInfos {
	s.Type = &v
	return s
}

type SetDesktopGroupScaleTimerResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetDesktopGroupScaleTimerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDesktopGroupScaleTimerResponseBody) GoString() string {
	return s.String()
}

func (s *SetDesktopGroupScaleTimerResponseBody) SetRequestId(v string) *SetDesktopGroupScaleTimerResponseBody {
	s.RequestId = &v
	return s
}

type SetDesktopGroupScaleTimerResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDesktopGroupScaleTimerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDesktopGroupScaleTimerResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDesktopGroupScaleTimerResponse) GoString() string {
	return s.String()
}

func (s *SetDesktopGroupScaleTimerResponse) SetHeaders(v map[string]*string) *SetDesktopGroupScaleTimerResponse {
	s.Headers = v
	return s
}

func (s *SetDesktopGroupScaleTimerResponse) SetStatusCode(v int32) *SetDesktopGroupScaleTimerResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDesktopGroupScaleTimerResponse) SetBody(v *SetDesktopGroupScaleTimerResponseBody) *SetDesktopGroupScaleTimerResponse {
	s.Body = v
	return s
}

type SetDesktopGroupTimerRequest struct {
	// The CRON expression for the scheduled task.
	CronExpression *string `json:"CronExpression,omitempty" xml:"CronExpression,omitempty"`
	// The ID of the desktop group.
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// Specifies whether to forcefully execute the scheduled task.
	Force *bool `json:"Force,omitempty" xml:"Force,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The type of the disk that you want to reset.
	ResetType *int32 `json:"ResetType,omitempty" xml:"ResetType,omitempty"`
	// The type of the scheduled task.
	TimerType *int32 `json:"TimerType,omitempty" xml:"TimerType,omitempty"`
}

func (s SetDesktopGroupTimerRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDesktopGroupTimerRequest) GoString() string {
	return s.String()
}

func (s *SetDesktopGroupTimerRequest) SetCronExpression(v string) *SetDesktopGroupTimerRequest {
	s.CronExpression = &v
	return s
}

func (s *SetDesktopGroupTimerRequest) SetDesktopGroupId(v string) *SetDesktopGroupTimerRequest {
	s.DesktopGroupId = &v
	return s
}

func (s *SetDesktopGroupTimerRequest) SetForce(v bool) *SetDesktopGroupTimerRequest {
	s.Force = &v
	return s
}

func (s *SetDesktopGroupTimerRequest) SetRegionId(v string) *SetDesktopGroupTimerRequest {
	s.RegionId = &v
	return s
}

func (s *SetDesktopGroupTimerRequest) SetResetType(v int32) *SetDesktopGroupTimerRequest {
	s.ResetType = &v
	return s
}

func (s *SetDesktopGroupTimerRequest) SetTimerType(v int32) *SetDesktopGroupTimerRequest {
	s.TimerType = &v
	return s
}

type SetDesktopGroupTimerResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetDesktopGroupTimerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDesktopGroupTimerResponseBody) GoString() string {
	return s.String()
}

func (s *SetDesktopGroupTimerResponseBody) SetRequestId(v string) *SetDesktopGroupTimerResponseBody {
	s.RequestId = &v
	return s
}

type SetDesktopGroupTimerResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDesktopGroupTimerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDesktopGroupTimerResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDesktopGroupTimerResponse) GoString() string {
	return s.String()
}

func (s *SetDesktopGroupTimerResponse) SetHeaders(v map[string]*string) *SetDesktopGroupTimerResponse {
	s.Headers = v
	return s
}

func (s *SetDesktopGroupTimerResponse) SetStatusCode(v int32) *SetDesktopGroupTimerResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDesktopGroupTimerResponse) SetBody(v *SetDesktopGroupTimerResponseBody) *SetDesktopGroupTimerResponse {
	s.Body = v
	return s
}

type SetDesktopGroupTimerStatusRequest struct {
	// The ID of the desktop group.
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The status of the scheduled task.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the scheduled task.
	TimerType *int32 `json:"TimerType,omitempty" xml:"TimerType,omitempty"`
}

func (s SetDesktopGroupTimerStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDesktopGroupTimerStatusRequest) GoString() string {
	return s.String()
}

func (s *SetDesktopGroupTimerStatusRequest) SetDesktopGroupId(v string) *SetDesktopGroupTimerStatusRequest {
	s.DesktopGroupId = &v
	return s
}

func (s *SetDesktopGroupTimerStatusRequest) SetRegionId(v string) *SetDesktopGroupTimerStatusRequest {
	s.RegionId = &v
	return s
}

func (s *SetDesktopGroupTimerStatusRequest) SetStatus(v int32) *SetDesktopGroupTimerStatusRequest {
	s.Status = &v
	return s
}

func (s *SetDesktopGroupTimerStatusRequest) SetTimerType(v int32) *SetDesktopGroupTimerStatusRequest {
	s.TimerType = &v
	return s
}

type SetDesktopGroupTimerStatusResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetDesktopGroupTimerStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDesktopGroupTimerStatusResponseBody) GoString() string {
	return s.String()
}

func (s *SetDesktopGroupTimerStatusResponseBody) SetRequestId(v string) *SetDesktopGroupTimerStatusResponseBody {
	s.RequestId = &v
	return s
}

type SetDesktopGroupTimerStatusResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDesktopGroupTimerStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDesktopGroupTimerStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDesktopGroupTimerStatusResponse) GoString() string {
	return s.String()
}

func (s *SetDesktopGroupTimerStatusResponse) SetHeaders(v map[string]*string) *SetDesktopGroupTimerStatusResponse {
	s.Headers = v
	return s
}

func (s *SetDesktopGroupTimerStatusResponse) SetStatusCode(v int32) *SetDesktopGroupTimerStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDesktopGroupTimerStatusResponse) SetBody(v *SetDesktopGroupTimerStatusResponseBody) *SetDesktopGroupTimerStatusResponse {
	s.Body = v
	return s
}

type SetDirectorySsoStatusRequest struct {
	// The AD directory ID.
	DirectoryId *string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	// Specifies whether to enable SSO. Valid values:
	//
	// *   true: enables SSO.
	// *   false: disables SSO.
	EnableSso *bool `json:"EnableSso,omitempty" xml:"EnableSso,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s SetDirectorySsoStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDirectorySsoStatusRequest) GoString() string {
	return s.String()
}

func (s *SetDirectorySsoStatusRequest) SetDirectoryId(v string) *SetDirectorySsoStatusRequest {
	s.DirectoryId = &v
	return s
}

func (s *SetDirectorySsoStatusRequest) SetEnableSso(v bool) *SetDirectorySsoStatusRequest {
	s.EnableSso = &v
	return s
}

func (s *SetDirectorySsoStatusRequest) SetRegionId(v string) *SetDirectorySsoStatusRequest {
	s.RegionId = &v
	return s
}

type SetDirectorySsoStatusResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetDirectorySsoStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDirectorySsoStatusResponseBody) GoString() string {
	return s.String()
}

func (s *SetDirectorySsoStatusResponseBody) SetRequestId(v string) *SetDirectorySsoStatusResponseBody {
	s.RequestId = &v
	return s
}

type SetDirectorySsoStatusResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDirectorySsoStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDirectorySsoStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDirectorySsoStatusResponse) GoString() string {
	return s.String()
}

func (s *SetDirectorySsoStatusResponse) SetHeaders(v map[string]*string) *SetDirectorySsoStatusResponse {
	s.Headers = v
	return s
}

func (s *SetDirectorySsoStatusResponse) SetStatusCode(v int32) *SetDirectorySsoStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDirectorySsoStatusResponse) SetBody(v *SetDirectorySsoStatusResponseBody) *SetDirectorySsoStatusResponse {
	s.Body = v
	return s
}

type SetIdpMetadataRequest struct {
	// The workspace ID. This parameter is the same as `OfficeSiteId`. We recommend that you use `OfficeSiteId` to replace `DirectoryId`. You can specify only `DirectoryId` or `OfficeSiteId`.
	DirectoryId *string `json:"DirectoryId,omitempty" xml:"DirectoryId,omitempty"`
	// The metadata of the IdP.
	IdpMetadata *string `json:"IdpMetadata,omitempty" xml:"IdpMetadata,omitempty"`
	// The workspace ID.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s SetIdpMetadataRequest) String() string {
	return tea.Prettify(s)
}

func (s SetIdpMetadataRequest) GoString() string {
	return s.String()
}

func (s *SetIdpMetadataRequest) SetDirectoryId(v string) *SetIdpMetadataRequest {
	s.DirectoryId = &v
	return s
}

func (s *SetIdpMetadataRequest) SetIdpMetadata(v string) *SetIdpMetadataRequest {
	s.IdpMetadata = &v
	return s
}

func (s *SetIdpMetadataRequest) SetOfficeSiteId(v string) *SetIdpMetadataRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *SetIdpMetadataRequest) SetRegionId(v string) *SetIdpMetadataRequest {
	s.RegionId = &v
	return s
}

type SetIdpMetadataResponseBody struct {
	// The entity ID obtained after the IdP metadata file is parsed.
	IdpEntityId *string `json:"IdpEntityId,omitempty" xml:"IdpEntityId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetIdpMetadataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetIdpMetadataResponseBody) GoString() string {
	return s.String()
}

func (s *SetIdpMetadataResponseBody) SetIdpEntityId(v string) *SetIdpMetadataResponseBody {
	s.IdpEntityId = &v
	return s
}

func (s *SetIdpMetadataResponseBody) SetRequestId(v string) *SetIdpMetadataResponseBody {
	s.RequestId = &v
	return s
}

type SetIdpMetadataResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetIdpMetadataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetIdpMetadataResponse) String() string {
	return tea.Prettify(s)
}

func (s SetIdpMetadataResponse) GoString() string {
	return s.String()
}

func (s *SetIdpMetadataResponse) SetHeaders(v map[string]*string) *SetIdpMetadataResponse {
	s.Headers = v
	return s
}

func (s *SetIdpMetadataResponse) SetStatusCode(v int32) *SetIdpMetadataResponse {
	s.StatusCode = &v
	return s
}

func (s *SetIdpMetadataResponse) SetBody(v *SetIdpMetadataResponseBody) *SetIdpMetadataResponse {
	s.Body = v
	return s
}

type SetOfficeSiteSsoStatusRequest struct {
	// Specifies whether to enable SSO.
	//
	// Valid values:
	//
	// *   true
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   false
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	EnableSso *bool `json:"EnableSso,omitempty" xml:"EnableSso,omitempty"`
	// The workspace ID.
	OfficeSiteId *string `json:"OfficeSiteId,omitempty" xml:"OfficeSiteId,omitempty"`
	// The region ID. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s SetOfficeSiteSsoStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s SetOfficeSiteSsoStatusRequest) GoString() string {
	return s.String()
}

func (s *SetOfficeSiteSsoStatusRequest) SetEnableSso(v bool) *SetOfficeSiteSsoStatusRequest {
	s.EnableSso = &v
	return s
}

func (s *SetOfficeSiteSsoStatusRequest) SetOfficeSiteId(v string) *SetOfficeSiteSsoStatusRequest {
	s.OfficeSiteId = &v
	return s
}

func (s *SetOfficeSiteSsoStatusRequest) SetRegionId(v string) *SetOfficeSiteSsoStatusRequest {
	s.RegionId = &v
	return s
}

type SetOfficeSiteSsoStatusResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetOfficeSiteSsoStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetOfficeSiteSsoStatusResponseBody) GoString() string {
	return s.String()
}

func (s *SetOfficeSiteSsoStatusResponseBody) SetRequestId(v string) *SetOfficeSiteSsoStatusResponseBody {
	s.RequestId = &v
	return s
}

type SetOfficeSiteSsoStatusResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetOfficeSiteSsoStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetOfficeSiteSsoStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s SetOfficeSiteSsoStatusResponse) GoString() string {
	return s.String()
}

func (s *SetOfficeSiteSsoStatusResponse) SetHeaders(v map[string]*string) *SetOfficeSiteSsoStatusResponse {
	s.Headers = v
	return s
}

func (s *SetOfficeSiteSsoStatusResponse) SetStatusCode(v int32) *SetOfficeSiteSsoStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *SetOfficeSiteSsoStatusResponse) SetBody(v *SetOfficeSiteSsoStatusResponseBody) *SetOfficeSiteSsoStatusResponse {
	s.Body = v
	return s
}

type SetUserProfilePathRulesRequest struct {
	// The desktop group ID.
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The directories that you want to configure in the blacklist and whitelist.
	UserProfilePathRule []*SetUserProfilePathRulesRequestUserProfilePathRule `json:"UserProfilePathRule,omitempty" xml:"UserProfilePathRule,omitempty" type:"Repeated"`
	// The directory type that you want to configure.
	//
	// Valid values:
	//
	// *   Both_Default_DesktopGroup
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   DesktopGroup
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Default
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	UserProfileRuleType *string `json:"UserProfileRuleType,omitempty" xml:"UserProfileRuleType,omitempty"`
}

func (s SetUserProfilePathRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s SetUserProfilePathRulesRequest) GoString() string {
	return s.String()
}

func (s *SetUserProfilePathRulesRequest) SetDesktopGroupId(v string) *SetUserProfilePathRulesRequest {
	s.DesktopGroupId = &v
	return s
}

func (s *SetUserProfilePathRulesRequest) SetRegionId(v string) *SetUserProfilePathRulesRequest {
	s.RegionId = &v
	return s
}

func (s *SetUserProfilePathRulesRequest) SetUserProfilePathRule(v []*SetUserProfilePathRulesRequestUserProfilePathRule) *SetUserProfilePathRulesRequest {
	s.UserProfilePathRule = v
	return s
}

func (s *SetUserProfilePathRulesRequest) SetUserProfileRuleType(v string) *SetUserProfilePathRulesRequest {
	s.UserProfileRuleType = &v
	return s
}

type SetUserProfilePathRulesRequestUserProfilePathRule struct {
	// The directory in the blacklist.
	BlackPath *SetUserProfilePathRulesRequestUserProfilePathRuleBlackPath `json:"BlackPath,omitempty" xml:"BlackPath,omitempty" type:"Struct"`
	// The directories that you want to configure in the whitelist.
	WhitePaths []*SetUserProfilePathRulesRequestUserProfilePathRuleWhitePaths `json:"WhitePaths,omitempty" xml:"WhitePaths,omitempty" type:"Repeated"`
}

func (s SetUserProfilePathRulesRequestUserProfilePathRule) String() string {
	return tea.Prettify(s)
}

func (s SetUserProfilePathRulesRequestUserProfilePathRule) GoString() string {
	return s.String()
}

func (s *SetUserProfilePathRulesRequestUserProfilePathRule) SetBlackPath(v *SetUserProfilePathRulesRequestUserProfilePathRuleBlackPath) *SetUserProfilePathRulesRequestUserProfilePathRule {
	s.BlackPath = v
	return s
}

func (s *SetUserProfilePathRulesRequestUserProfilePathRule) SetWhitePaths(v []*SetUserProfilePathRulesRequestUserProfilePathRuleWhitePaths) *SetUserProfilePathRulesRequestUserProfilePathRule {
	s.WhitePaths = v
	return s
}

type SetUserProfilePathRulesRequestUserProfilePathRuleBlackPath struct {
	// The blacklist path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The path type.
	//
	// Valid values:
	//
	// *   file
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   folder
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s SetUserProfilePathRulesRequestUserProfilePathRuleBlackPath) String() string {
	return tea.Prettify(s)
}

func (s SetUserProfilePathRulesRequestUserProfilePathRuleBlackPath) GoString() string {
	return s.String()
}

func (s *SetUserProfilePathRulesRequestUserProfilePathRuleBlackPath) SetPath(v string) *SetUserProfilePathRulesRequestUserProfilePathRuleBlackPath {
	s.Path = &v
	return s
}

func (s *SetUserProfilePathRulesRequestUserProfilePathRuleBlackPath) SetType(v string) *SetUserProfilePathRulesRequestUserProfilePathRuleBlackPath {
	s.Type = &v
	return s
}

type SetUserProfilePathRulesRequestUserProfilePathRuleWhitePaths struct {
	// The whitelist path.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The path type.
	//
	// Valid values:
	//
	// *   file
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   folder
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s SetUserProfilePathRulesRequestUserProfilePathRuleWhitePaths) String() string {
	return tea.Prettify(s)
}

func (s SetUserProfilePathRulesRequestUserProfilePathRuleWhitePaths) GoString() string {
	return s.String()
}

func (s *SetUserProfilePathRulesRequestUserProfilePathRuleWhitePaths) SetPath(v string) *SetUserProfilePathRulesRequestUserProfilePathRuleWhitePaths {
	s.Path = &v
	return s
}

func (s *SetUserProfilePathRulesRequestUserProfilePathRuleWhitePaths) SetType(v string) *SetUserProfilePathRulesRequestUserProfilePathRuleWhitePaths {
	s.Type = &v
	return s
}

type SetUserProfilePathRulesShrinkRequest struct {
	// The desktop group ID.
	DesktopGroupId *string `json:"DesktopGroupId,omitempty" xml:"DesktopGroupId,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The directories that you want to configure in the blacklist and whitelist.
	UserProfilePathRuleShrink *string `json:"UserProfilePathRule,omitempty" xml:"UserProfilePathRule,omitempty"`
	// The directory type that you want to configure.
	//
	// Valid values:
	//
	// *   Both_Default_DesktopGroup
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   DesktopGroup
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Default
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	UserProfileRuleType *string `json:"UserProfileRuleType,omitempty" xml:"UserProfileRuleType,omitempty"`
}

func (s SetUserProfilePathRulesShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s SetUserProfilePathRulesShrinkRequest) GoString() string {
	return s.String()
}

func (s *SetUserProfilePathRulesShrinkRequest) SetDesktopGroupId(v string) *SetUserProfilePathRulesShrinkRequest {
	s.DesktopGroupId = &v
	return s
}

func (s *SetUserProfilePathRulesShrinkRequest) SetRegionId(v string) *SetUserProfilePathRulesShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *SetUserProfilePathRulesShrinkRequest) SetUserProfilePathRuleShrink(v string) *SetUserProfilePathRulesShrinkRequest {
	s.UserProfilePathRuleShrink = &v
	return s
}

func (s *SetUserProfilePathRulesShrinkRequest) SetUserProfileRuleType(v string) *SetUserProfilePathRulesShrinkRequest {
	s.UserProfileRuleType = &v
	return s
}

type SetUserProfilePathRulesResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetUserProfilePathRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetUserProfilePathRulesResponseBody) GoString() string {
	return s.String()
}

func (s *SetUserProfilePathRulesResponseBody) SetRequestId(v string) *SetUserProfilePathRulesResponseBody {
	s.RequestId = &v
	return s
}

type SetUserProfilePathRulesResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetUserProfilePathRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetUserProfilePathRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s SetUserProfilePathRulesResponse) GoString() string {
	return s.String()
}

func (s *SetUserProfilePathRulesResponse) SetHeaders(v map[string]*string) *SetUserProfilePathRulesResponse {
	s.Headers = v
	return s
}

func (s *SetUserProfilePathRulesResponse) SetStatusCode(v int32) *SetUserProfilePathRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *SetUserProfilePathRulesResponse) SetBody(v *SetUserProfilePathRulesResponseBody) *SetUserProfilePathRulesResponse {
	s.Body = v
	return s
}

type StartDesktopsRequest struct {
	// The cloud desktop IDs. You can specify 1 to 20 IDs.
	DesktopId []*string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty" type:"Repeated"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s StartDesktopsRequest) String() string {
	return tea.Prettify(s)
}

func (s StartDesktopsRequest) GoString() string {
	return s.String()
}

func (s *StartDesktopsRequest) SetDesktopId(v []*string) *StartDesktopsRequest {
	s.DesktopId = v
	return s
}

func (s *StartDesktopsRequest) SetRegionId(v string) *StartDesktopsRequest {
	s.RegionId = &v
	return s
}

type StartDesktopsResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StartDesktopsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StartDesktopsResponseBody) GoString() string {
	return s.String()
}

func (s *StartDesktopsResponseBody) SetRequestId(v string) *StartDesktopsResponseBody {
	s.RequestId = &v
	return s
}

type StartDesktopsResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StartDesktopsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StartDesktopsResponse) String() string {
	return tea.Prettify(s)
}

func (s StartDesktopsResponse) GoString() string {
	return s.String()
}

func (s *StartDesktopsResponse) SetHeaders(v map[string]*string) *StartDesktopsResponse {
	s.Headers = v
	return s
}

func (s *StartDesktopsResponse) SetStatusCode(v int32) *StartDesktopsResponse {
	s.StatusCode = &v
	return s
}

func (s *StartDesktopsResponse) SetBody(v *StartDesktopsResponseBody) *StartDesktopsResponse {
	s.Body = v
	return s
}

type StopDesktopsRequest struct {
	// The cloud desktop IDs. You can specify one or more IDs of cloud desktops. Valid values of N: 1 to 20.
	DesktopId []*string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty" type:"Repeated"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The billing mode after you stop the cloud desktop.
	//
	// *   StopCharging: Computing resources are not billed after you stop the cloud desktop. After the cloud desktop is stopped, the system automatically reclaims computing resources. From this point on, you are no longer charged for computing resources. However, you are still charged for storage resources.
	// *   KeepCharging: The billing continues after you stop the cloud desktop. After the cloud desktop is stopped, the system does not reclaim resources to avoid startup failures due to insufficient resources. You are still charged for the resources.
	//
	// Default value: StopCharging
	StoppedMode *string `json:"StoppedMode,omitempty" xml:"StoppedMode,omitempty"`
}

func (s StopDesktopsRequest) String() string {
	return tea.Prettify(s)
}

func (s StopDesktopsRequest) GoString() string {
	return s.String()
}

func (s *StopDesktopsRequest) SetDesktopId(v []*string) *StopDesktopsRequest {
	s.DesktopId = v
	return s
}

func (s *StopDesktopsRequest) SetRegionId(v string) *StopDesktopsRequest {
	s.RegionId = &v
	return s
}

func (s *StopDesktopsRequest) SetStoppedMode(v string) *StopDesktopsRequest {
	s.StoppedMode = &v
	return s
}

type StopDesktopsResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StopDesktopsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StopDesktopsResponseBody) GoString() string {
	return s.String()
}

func (s *StopDesktopsResponseBody) SetRequestId(v string) *StopDesktopsResponseBody {
	s.RequestId = &v
	return s
}

type StopDesktopsResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StopDesktopsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StopDesktopsResponse) String() string {
	return tea.Prettify(s)
}

func (s StopDesktopsResponse) GoString() string {
	return s.String()
}

func (s *StopDesktopsResponse) SetHeaders(v map[string]*string) *StopDesktopsResponse {
	s.Headers = v
	return s
}

func (s *StopDesktopsResponse) SetStatusCode(v int32) *StopDesktopsResponse {
	s.StatusCode = &v
	return s
}

func (s *StopDesktopsResponse) SetBody(v *StopDesktopsResponseBody) *StopDesktopsResponse {
	s.Body = v
	return s
}

type StopInvocationRequest struct {
	// StopInvocation
	DesktopId []*string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty" type:"Repeated"`
	// The operation that you want to perform. Set the value to StopInvocation.
	InvokeId *string `json:"InvokeId,omitempty" xml:"InvokeId,omitempty"`
	// The ID of the request.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s StopInvocationRequest) String() string {
	return tea.Prettify(s)
}

func (s StopInvocationRequest) GoString() string {
	return s.String()
}

func (s *StopInvocationRequest) SetDesktopId(v []*string) *StopInvocationRequest {
	s.DesktopId = v
	return s
}

func (s *StopInvocationRequest) SetInvokeId(v string) *StopInvocationRequest {
	s.InvokeId = &v
	return s
}

func (s *StopInvocationRequest) SetRegionId(v string) *StopInvocationRequest {
	s.RegionId = &v
	return s
}

type StopInvocationResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StopInvocationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StopInvocationResponseBody) GoString() string {
	return s.String()
}

func (s *StopInvocationResponseBody) SetRequestId(v string) *StopInvocationResponseBody {
	s.RequestId = &v
	return s
}

type StopInvocationResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StopInvocationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StopInvocationResponse) String() string {
	return tea.Prettify(s)
}

func (s StopInvocationResponse) GoString() string {
	return s.String()
}

func (s *StopInvocationResponse) SetHeaders(v map[string]*string) *StopInvocationResponse {
	s.Headers = v
	return s
}

func (s *StopInvocationResponse) SetStatusCode(v int32) *StopInvocationResponse {
	s.StatusCode = &v
	return s
}

func (s *StopInvocationResponse) SetBody(v *StopInvocationResponseBody) *StopInvocationResponse {
	s.Body = v
	return s
}

type TagResourcesRequest struct {
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource ID, namely the cloud desktop ID. Valid values of N: 1 to 50.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The resource type. Valid value: ALIYUN::GWS::INSTANCE.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tags.
	Tag []*TagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s TagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequest) GoString() string {
	return s.String()
}

func (s *TagResourcesRequest) SetRegionId(v string) *TagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *TagResourcesRequest) SetResourceId(v []*string) *TagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *TagResourcesRequest) SetResourceType(v string) *TagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *TagResourcesRequest) SetTag(v []*TagResourcesRequestTag) *TagResourcesRequest {
	s.Tag = v
	return s
}

type TagResourcesRequestTag struct {
	// The keys of a tag. Valid values of N: 1 to 20.\
	// You cannot enter an empty string as the parameter value. The tag key can be up to 128 characters in length and cannot contain `http://` or `https://`. The key cannot start with `aliyun` and `acs:`.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value. Valid values of N: 1 to 20.\
	// You can enter an empty string as the parameter value. The tag value must be up to 128 characters in length and cannot contain `http://` or `https://`. The value cannot start with `acs:`.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s TagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *TagResourcesRequestTag) SetKey(v string) *TagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *TagResourcesRequestTag) SetValue(v string) *TagResourcesRequestTag {
	s.Value = &v
	return s
}

type TagResourcesResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *TagResourcesResponseBody) SetRequestId(v string) *TagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type TagResourcesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponse) GoString() string {
	return s.String()
}

func (s *TagResourcesResponse) SetHeaders(v map[string]*string) *TagResourcesResponse {
	s.Headers = v
	return s
}

func (s *TagResourcesResponse) SetStatusCode(v int32) *TagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *TagResourcesResponse) SetBody(v *TagResourcesResponseBody) *TagResourcesResponse {
	s.Body = v
	return s
}

type UnlockVirtualMFADeviceRequest struct {
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The serial number of the virtual MFA device, which is a unique identifier.
	//
	// You can call the [DescribeVirtualMFADevices](~~206210~~) operation to query the serial number of the virtual MFA device bound to AD users.
	SerialNumber *string `json:"SerialNumber,omitempty" xml:"SerialNumber,omitempty"`
}

func (s UnlockVirtualMFADeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s UnlockVirtualMFADeviceRequest) GoString() string {
	return s.String()
}

func (s *UnlockVirtualMFADeviceRequest) SetRegionId(v string) *UnlockVirtualMFADeviceRequest {
	s.RegionId = &v
	return s
}

func (s *UnlockVirtualMFADeviceRequest) SetSerialNumber(v string) *UnlockVirtualMFADeviceRequest {
	s.SerialNumber = &v
	return s
}

type UnlockVirtualMFADeviceResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UnlockVirtualMFADeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UnlockVirtualMFADeviceResponseBody) GoString() string {
	return s.String()
}

func (s *UnlockVirtualMFADeviceResponseBody) SetRequestId(v string) *UnlockVirtualMFADeviceResponseBody {
	s.RequestId = &v
	return s
}

type UnlockVirtualMFADeviceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UnlockVirtualMFADeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UnlockVirtualMFADeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s UnlockVirtualMFADeviceResponse) GoString() string {
	return s.String()
}

func (s *UnlockVirtualMFADeviceResponse) SetHeaders(v map[string]*string) *UnlockVirtualMFADeviceResponse {
	s.Headers = v
	return s
}

func (s *UnlockVirtualMFADeviceResponse) SetStatusCode(v int32) *UnlockVirtualMFADeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *UnlockVirtualMFADeviceResponse) SetBody(v *UnlockVirtualMFADeviceResponseBody) *UnlockVirtualMFADeviceResponse {
	s.Body = v
	return s
}

type UntagResourcesRequest struct {
	// Specifies whether to unbind all tags from the resource. This parameter takes effect only when TagKey.N is not specified. Default value: false.
	All *bool `json:"All,omitempty" xml:"All,omitempty"`
	// The region ID.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource IDs, namely the cloud desktop IDs. Valid values of N: 1 to 50.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The resource type. Valid value: ALIYUN::GWS::INSTANCE.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tag key. You can specify up to 20 tag keys.
	TagKey []*string `json:"TagKey,omitempty" xml:"TagKey,omitempty" type:"Repeated"`
}

func (s UntagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesRequest) GoString() string {
	return s.String()
}

func (s *UntagResourcesRequest) SetAll(v bool) *UntagResourcesRequest {
	s.All = &v
	return s
}

func (s *UntagResourcesRequest) SetRegionId(v string) *UntagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceId(v []*string) *UntagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *UntagResourcesRequest) SetResourceType(v string) *UntagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *UntagResourcesRequest) SetTagKey(v []*string) *UntagResourcesRequest {
	s.TagKey = v
	return s
}

type UntagResourcesResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UntagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponseBody) SetRequestId(v string) *UntagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type UntagResourcesResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UntagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UntagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponse) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponse) SetHeaders(v map[string]*string) *UntagResourcesResponse {
	s.Headers = v
	return s
}

func (s *UntagResourcesResponse) SetStatusCode(v int32) *UntagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *UntagResourcesResponse) SetBody(v *UntagResourcesResponseBody) *UntagResourcesResponse {
	s.Body = v
	return s
}

type UpdateFotaTaskRequest struct {
	RegionId   *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	TaskUid    *string `json:"TaskUid,omitempty" xml:"TaskUid,omitempty"`
	UserStatus *string `json:"UserStatus,omitempty" xml:"UserStatus,omitempty"`
}

func (s UpdateFotaTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateFotaTaskRequest) GoString() string {
	return s.String()
}

func (s *UpdateFotaTaskRequest) SetRegionId(v string) *UpdateFotaTaskRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateFotaTaskRequest) SetTaskUid(v string) *UpdateFotaTaskRequest {
	s.TaskUid = &v
	return s
}

func (s *UpdateFotaTaskRequest) SetUserStatus(v string) *UpdateFotaTaskRequest {
	s.UserStatus = &v
	return s
}

type UpdateFotaTaskResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateFotaTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateFotaTaskResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateFotaTaskResponseBody) SetRequestId(v string) *UpdateFotaTaskResponseBody {
	s.RequestId = &v
	return s
}

type UpdateFotaTaskResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateFotaTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateFotaTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateFotaTaskResponse) GoString() string {
	return s.String()
}

func (s *UpdateFotaTaskResponse) SetHeaders(v map[string]*string) *UpdateFotaTaskResponse {
	s.Headers = v
	return s
}

func (s *UpdateFotaTaskResponse) SetStatusCode(v int32) *UpdateFotaTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateFotaTaskResponse) SetBody(v *UpdateFotaTaskResponseBody) *UpdateFotaTaskResponse {
	s.Body = v
	return s
}

type UploadImageRequest struct {
	// The size of the data disk. Valid values: 80 to 500. Unit: GiB.
	DataDiskSize *int32 `json:"DataDiskSize,omitempty" xml:"DataDiskSize,omitempty"`
	// The description of the custom image. The description must be 2 to 256 characters in length. It cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to enable security check.
	EnableSecurityCheck *bool `json:"EnableSecurityCheck,omitempty" xml:"EnableSecurityCheck,omitempty"`
	// Specifies whether the image is a GPU-accelerated image.
	GpuCategory *bool `json:"GpuCategory,omitempty" xml:"GpuCategory,omitempty"`
	// The type of the pre-installed GPU driver. Valid values:
	//
	// *   gpu_grid9: This value is applicable to a Graphics cloud desktop that uses 4 vCores, 23 GB memory, and 4 GB GPU memory and a Graphics cloud desktop that uses 10 vCores, 46 GB memory, and 8 GB GPU memory
	// *   gpu_grid12: This value is applicable to a cloud desktop other than a Graphics cloud desktop that uses 4 vCores, 23 GB memory, and 4 GB GPU memory and a Graphics cloud desktop that uses 10 vCores, 46 GB memory, and 8 GB GPU memory.
	// *   gpu_custom: You can install a driver later.
	GpuDriverType *string `json:"GpuDriverType,omitempty" xml:"GpuDriverType,omitempty"`
	// The name of the custom image. The name must be 2 to 128 characters in length and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). The name can contain letters, digits, colons (:), underscores (\_), and hyphens (-). The name must start with a letter and cannot start with `http://` or `https://`.
	ImageName *string `json:"ImageName,omitempty" xml:"ImageName,omitempty"`
	// The type of the license that you want to use to activate the OS after the image is imported. Valid values:
	//
	// *   Auto: Elastic Desktop Service (EDS) checks the source OS of the image and allocates a license to the OS. EDS first checks whether the OS distribution that is specified by `Platform` has a license allocated by using an official Alibaba Cloud channel. If yes, the allocated license is used. If no, the license of the source OS is used.
	// *   Aliyun: The license allocated by using an official Alibaba Cloud channel is used for the OS distribution that is specified by `Platform`.
	// *   BYOL: The license of the source OS is used. In this case, make sure that your license key can be used in Alibaba Cloud.
	//
	// Default value: Auto.
	//
	// > Windows 10 cannot be activated by using a license that is allocated by using an official Alibaba Cloud channel. In this case, you must set `LicenseType` to BYOL.
	LicenseType *string `json:"LicenseType,omitempty" xml:"LicenseType,omitempty"`
	// The type of the OS. Valid values:
	//
	// *   Windows
	// *   Linux
	OsType *string `json:"OsType,omitempty" xml:"OsType,omitempty"`
	// The URL of the image object that you want to upload in Object Storage Service (OSS).
	OssObjectPath *string `json:"OssObjectPath,omitempty" xml:"OssObjectPath,omitempty"`
	// The type of the protocol. Valid value: ASP.
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s UploadImageRequest) String() string {
	return tea.Prettify(s)
}

func (s UploadImageRequest) GoString() string {
	return s.String()
}

func (s *UploadImageRequest) SetDataDiskSize(v int32) *UploadImageRequest {
	s.DataDiskSize = &v
	return s
}

func (s *UploadImageRequest) SetDescription(v string) *UploadImageRequest {
	s.Description = &v
	return s
}

func (s *UploadImageRequest) SetEnableSecurityCheck(v bool) *UploadImageRequest {
	s.EnableSecurityCheck = &v
	return s
}

func (s *UploadImageRequest) SetGpuCategory(v bool) *UploadImageRequest {
	s.GpuCategory = &v
	return s
}

func (s *UploadImageRequest) SetGpuDriverType(v string) *UploadImageRequest {
	s.GpuDriverType = &v
	return s
}

func (s *UploadImageRequest) SetImageName(v string) *UploadImageRequest {
	s.ImageName = &v
	return s
}

func (s *UploadImageRequest) SetLicenseType(v string) *UploadImageRequest {
	s.LicenseType = &v
	return s
}

func (s *UploadImageRequest) SetOsType(v string) *UploadImageRequest {
	s.OsType = &v
	return s
}

func (s *UploadImageRequest) SetOssObjectPath(v string) *UploadImageRequest {
	s.OssObjectPath = &v
	return s
}

func (s *UploadImageRequest) SetProtocolType(v string) *UploadImageRequest {
	s.ProtocolType = &v
	return s
}

func (s *UploadImageRequest) SetRegionId(v string) *UploadImageRequest {
	s.RegionId = &v
	return s
}

type UploadImageResponseBody struct {
	// The ID of the custom image.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UploadImageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UploadImageResponseBody) GoString() string {
	return s.String()
}

func (s *UploadImageResponseBody) SetImageId(v string) *UploadImageResponseBody {
	s.ImageId = &v
	return s
}

func (s *UploadImageResponseBody) SetRequestId(v string) *UploadImageResponseBody {
	s.RequestId = &v
	return s
}

type UploadImageResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UploadImageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UploadImageResponse) String() string {
	return tea.Prettify(s)
}

func (s UploadImageResponse) GoString() string {
	return s.String()
}

func (s *UploadImageResponse) SetHeaders(v map[string]*string) *UploadImageResponse {
	s.Headers = v
	return s
}

func (s *UploadImageResponse) SetStatusCode(v int32) *UploadImageResponse {
	s.StatusCode = &v
	return s
}

func (s *UploadImageResponse) SetBody(v *UploadImageResponseBody) *UploadImageResponse {
	s.Body = v
	return s
}

type VerifyCenRequest struct {
	// The ID of the CEN instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The ID of the Alibaba Cloud account to which the CEN instance belongs.
	//
	// *   If you specify the CenId parameter and the CEN instance that you specify for the CenId parameter belongs to the current Alibaba Cloud account, skip this parameter.
	// *   If you specify the CenId parameter and the CEN instance that you specify for the CenId parameter belongs to another Alibaba Cloud account, enter the ID of the exact Alibaba Cloud account.
	CenOwnerId *int64 `json:"CenOwnerId,omitempty" xml:"CenOwnerId,omitempty"`
	// The IPv4 CIDR block of the workspace.
	CidrBlock *string `json:"CidrBlock,omitempty" xml:"CidrBlock,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The verification code. If the CEN instance that you specify for the CenId parameter belongs to another Alibaba Cloud account, you must call the SendVerifyCode operation to obtain the verification code.
	VerifyCode *string `json:"VerifyCode,omitempty" xml:"VerifyCode,omitempty"`
}

func (s VerifyCenRequest) String() string {
	return tea.Prettify(s)
}

func (s VerifyCenRequest) GoString() string {
	return s.String()
}

func (s *VerifyCenRequest) SetCenId(v string) *VerifyCenRequest {
	s.CenId = &v
	return s
}

func (s *VerifyCenRequest) SetCenOwnerId(v int64) *VerifyCenRequest {
	s.CenOwnerId = &v
	return s
}

func (s *VerifyCenRequest) SetCidrBlock(v string) *VerifyCenRequest {
	s.CidrBlock = &v
	return s
}

func (s *VerifyCenRequest) SetRegionId(v string) *VerifyCenRequest {
	s.RegionId = &v
	return s
}

func (s *VerifyCenRequest) SetVerifyCode(v string) *VerifyCenRequest {
	s.VerifyCode = &v
	return s
}

type VerifyCenResponseBody struct {
	// The three random IPv4 CIDR blocks that are recommended. If the returned value of the Status parameter is Conflict, this parameter is returned.
	CidrBlocks []*string `json:"CidrBlocks,omitempty" xml:"CidrBlocks,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the routes of the CEN instance.
	RouteEntries []*VerifyCenResponseBodyRouteEntries `json:"RouteEntries,omitempty" xml:"RouteEntries,omitempty" type:"Repeated"`
	// The verification result. Valid values:
	//
	// *   Access: The route verification succeeds. If the verification result for all routes succeeds, Access is returned for this parameter.
	// *   Conflict: A CIDR block conflict exists. If the verification result of at least one route is Conflict, Conflict is returned for this parameter.
	// *   InvalidCen.ParameterCenInstanceId: The ID of the CEN instance and the ID of the Alibaba Cloud account are invalid. The CEN instance does not belong to the Alibaba Cloud account.
	// *   InvalidCen.CenUidInvalid: The ID of the Alibaba Cloud account is invalid or the Alibaba Cloud account is not granted the required permissions to access Elastic Desktop Service (EDS).
	// *   VerifyCode.InvalidTokenCode: The verification code is invalid.
	// *   VerifyCode.ReachTokenRetryTime: The retries of entering the verification code reaches the upper limit.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s VerifyCenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s VerifyCenResponseBody) GoString() string {
	return s.String()
}

func (s *VerifyCenResponseBody) SetCidrBlocks(v []*string) *VerifyCenResponseBody {
	s.CidrBlocks = v
	return s
}

func (s *VerifyCenResponseBody) SetRequestId(v string) *VerifyCenResponseBody {
	s.RequestId = &v
	return s
}

func (s *VerifyCenResponseBody) SetRouteEntries(v []*VerifyCenResponseBodyRouteEntries) *VerifyCenResponseBody {
	s.RouteEntries = v
	return s
}

func (s *VerifyCenResponseBody) SetStatus(v string) *VerifyCenResponseBody {
	s.Status = &v
	return s
}

type VerifyCenResponseBodyRouteEntries struct {
	// The CIDR block of the route.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// The ID of the network instance that is attached to the route.
	NextHopInstanceId *string `json:"NextHopInstanceId,omitempty" xml:"NextHopInstanceId,omitempty"`
	// The ID of the region where the route resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The verification result for a route. Valid values:
	//
	// *   Access: The route verification succeeds.
	// *   Conflict: A CIDR block conflict exists.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s VerifyCenResponseBodyRouteEntries) String() string {
	return tea.Prettify(s)
}

func (s VerifyCenResponseBodyRouteEntries) GoString() string {
	return s.String()
}

func (s *VerifyCenResponseBodyRouteEntries) SetDestinationCidrBlock(v string) *VerifyCenResponseBodyRouteEntries {
	s.DestinationCidrBlock = &v
	return s
}

func (s *VerifyCenResponseBodyRouteEntries) SetNextHopInstanceId(v string) *VerifyCenResponseBodyRouteEntries {
	s.NextHopInstanceId = &v
	return s
}

func (s *VerifyCenResponseBodyRouteEntries) SetRegionId(v string) *VerifyCenResponseBodyRouteEntries {
	s.RegionId = &v
	return s
}

func (s *VerifyCenResponseBodyRouteEntries) SetStatus(v string) *VerifyCenResponseBodyRouteEntries {
	s.Status = &v
	return s
}

type VerifyCenResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *VerifyCenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s VerifyCenResponse) String() string {
	return tea.Prettify(s)
}

func (s VerifyCenResponse) GoString() string {
	return s.String()
}

func (s *VerifyCenResponse) SetHeaders(v map[string]*string) *VerifyCenResponse {
	s.Headers = v
	return s
}

func (s *VerifyCenResponse) SetStatusCode(v int32) *VerifyCenResponse {
	s.StatusCode = &v
	return s
}

func (s *VerifyCenResponse) SetBody(v *VerifyCenResponseBody) *VerifyCenResponse {
	s.Body = v
	return s
}

type WakeupDesktopsRequest struct {
	DesktopId []*string `json:"DesktopId,omitempty" xml:"DesktopId,omitempty" type:"Repeated"`
	RegionId  *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s WakeupDesktopsRequest) String() string {
	return tea.Prettify(s)
}

func (s WakeupDesktopsRequest) GoString() string {
	return s.String()
}

func (s *WakeupDesktopsRequest) SetDesktopId(v []*string) *WakeupDesktopsRequest {
	s.DesktopId = v
	return s
}

func (s *WakeupDesktopsRequest) SetRegionId(v string) *WakeupDesktopsRequest {
	s.RegionId = &v
	return s
}

type WakeupDesktopsResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s WakeupDesktopsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s WakeupDesktopsResponseBody) GoString() string {
	return s.String()
}

func (s *WakeupDesktopsResponseBody) SetRequestId(v string) *WakeupDesktopsResponseBody {
	s.RequestId = &v
	return s
}

type WakeupDesktopsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *WakeupDesktopsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s WakeupDesktopsResponse) String() string {
	return tea.Prettify(s)
}

func (s WakeupDesktopsResponse) GoString() string {
	return s.String()
}

func (s *WakeupDesktopsResponse) SetHeaders(v map[string]*string) *WakeupDesktopsResponse {
	s.Headers = v
	return s
}

func (s *WakeupDesktopsResponse) SetStatusCode(v int32) *WakeupDesktopsResponse {
	s.StatusCode = &v
	return s
}

func (s *WakeupDesktopsResponse) SetBody(v *WakeupDesktopsResponseBody) *WakeupDesktopsResponse {
	s.Body = v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.EndpointRule = tea.String("regional")
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(tea.String("ecd"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !tea.BoolValue(util.Empty(endpoint)) {
		_result = endpoint
		return _result, _err
	}

	if !tea.BoolValue(util.IsUnset(endpointMap)) && !tea.BoolValue(util.Empty(endpointMap[tea.StringValue(regionId)])) {
		_result = endpointMap[tea.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := endpointutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * To improve resource utilization, the system automatically locks a workspace of the convenience account type to release virtual private cloud (VPC) resources, and the workspace has been no longer used for a long time. If you want to continue using the locked workspace, you can call this operation to activate it. When you activate the locked workspace, the system recreates VPC resources based on the original configurations.
 *
 * @param request ActivateOfficeSiteRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ActivateOfficeSiteResponse
 */
func (client *Client) ActivateOfficeSiteWithOptions(request *ActivateOfficeSiteRequest, runtime *util.RuntimeOptions) (_result *ActivateOfficeSiteResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ActivateOfficeSite"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ActivateOfficeSiteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * To improve resource utilization, the system automatically locks a workspace of the convenience account type to release virtual private cloud (VPC) resources, and the workspace has been no longer used for a long time. If you want to continue using the locked workspace, you can call this operation to activate it. When you activate the locked workspace, the system recreates VPC resources based on the original configurations.
 *
 * @param request ActivateOfficeSiteRequest
 * @return ActivateOfficeSiteResponse
 */
func (client *Client) ActivateOfficeSite(request *ActivateOfficeSiteRequest) (_result *ActivateOfficeSiteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ActivateOfficeSiteResponse{}
	_body, _err := client.ActivateOfficeSiteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddDesktopOversoldUserGroupWithOptions(request *AddDesktopOversoldUserGroupRequest, runtime *util.RuntimeOptions) (_result *AddDesktopOversoldUserGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OversoldGroupId)) {
		query["OversoldGroupId"] = request.OversoldGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyGroupId)) {
		query["PolicyGroupId"] = request.PolicyGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddDesktopOversoldUserGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddDesktopOversoldUserGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddDesktopOversoldUserGroup(request *AddDesktopOversoldUserGroupRequest) (_result *AddDesktopOversoldUserGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddDesktopOversoldUserGroupResponse{}
	_body, _err := client.AddDesktopOversoldUserGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can add only one device to a tenant.
 *
 * @param request AddDevicesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddDevicesResponse
 */
func (client *Client) AddDevicesWithOptions(request *AddDevicesRequest, runtime *util.RuntimeOptions) (_result *AddDevicesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientType)) {
		query["ClientType"] = request.ClientType
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceIds)) {
		query["DeviceIds"] = request.DeviceIds
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddDevices"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddDevicesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can add only one device to a tenant.
 *
 * @param request AddDevicesRequest
 * @return AddDevicesResponse
 */
func (client *Client) AddDevices(request *AddDevicesRequest) (_result *AddDevicesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddDevicesResponse{}
	_body, _err := client.AddDevicesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to share a specific folder with other users. You can also configure the folder permissions.
 *
 * @param tmpReq AddFilePermissionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddFilePermissionResponse
 */
func (client *Client) AddFilePermissionWithOptions(tmpReq *AddFilePermissionRequest, runtime *util.RuntimeOptions) (_result *AddFilePermissionResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &AddFilePermissionShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.MemberList)) {
		request.MemberListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.MemberList, tea.String("MemberList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		query["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.MemberListShrink)) {
		query["MemberList"] = request.MemberListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddFilePermission"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddFilePermissionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to share a specific folder with other users. You can also configure the folder permissions.
 *
 * @param request AddFilePermissionRequest
 * @return AddFilePermissionResponse
 */
func (client *Client) AddFilePermission(request *AddFilePermissionRequest) (_result *AddFilePermissionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddFilePermissionResponse{}
	_body, _err := client.AddFilePermissionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddUserToDesktopGroupWithOptions(request *AddUserToDesktopGroupRequest, runtime *util.RuntimeOptions) (_result *AddUserToDesktopGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopGroupId)) {
		query["DesktopGroupId"] = request.DesktopGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopGroupIds)) {
		query["DesktopGroupIds"] = request.DesktopGroupIds
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserIds)) {
		query["EndUserIds"] = request.EndUserIds
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddUserToDesktopGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddUserToDesktopGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddUserToDesktopGroup(request *AddUserToDesktopGroupRequest) (_result *AddUserToDesktopGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddUserToDesktopGroupResponse{}
	_body, _err := client.AddUserToDesktopGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddUserToDesktopOversoldUserGroupWithOptions(request *AddUserToDesktopOversoldUserGroupRequest, runtime *util.RuntimeOptions) (_result *AddUserToDesktopOversoldUserGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AddUserAmount)) {
		query["AddUserAmount"] = request.AddUserAmount
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.OversoldGroupId)) {
		query["OversoldGroupId"] = request.OversoldGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.UserGroupId)) {
		query["UserGroupId"] = request.UserGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddUserToDesktopOversoldUserGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddUserToDesktopOversoldUserGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddUserToDesktopOversoldUserGroup(request *AddUserToDesktopOversoldUserGroupRequest) (_result *AddUserToDesktopOversoldUserGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddUserToDesktopOversoldUserGroupResponse{}
	_body, _err := client.AddUserToDesktopOversoldUserGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can also associate an automatic snapshot policy with a cloud desktop in the Elastic Desktop Service (EDS) console. To do so, perform the following steps: 1. Log on to the EDS console. 2. Choose Desktops and Groups > Desktops in the left-side navigation pane. 3. Find the cloud desktop that you want to manage on the Cloud Desktops page and choose More > Change Automatic Snapshot Policy in the Actions column. 4. Configure a policy for the cloud desktop as prompted in the Change Automatic Snapshot Policy panel.
 * After you associate an automatic snapshot policy with the cloud desktop, the system creates snapshots for the cloud desktop based on the policy.
 *
 * @param request ApplyAutoSnapshotPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ApplyAutoSnapshotPolicyResponse
 */
func (client *Client) ApplyAutoSnapshotPolicyWithOptions(request *ApplyAutoSnapshotPolicyRequest, runtime *util.RuntimeOptions) (_result *ApplyAutoSnapshotPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyId)) {
		query["PolicyId"] = request.PolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ApplyAutoSnapshotPolicy"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ApplyAutoSnapshotPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can also associate an automatic snapshot policy with a cloud desktop in the Elastic Desktop Service (EDS) console. To do so, perform the following steps: 1. Log on to the EDS console. 2. Choose Desktops and Groups > Desktops in the left-side navigation pane. 3. Find the cloud desktop that you want to manage on the Cloud Desktops page and choose More > Change Automatic Snapshot Policy in the Actions column. 4. Configure a policy for the cloud desktop as prompted in the Change Automatic Snapshot Policy panel.
 * After you associate an automatic snapshot policy with the cloud desktop, the system creates snapshots for the cloud desktop based on the policy.
 *
 * @param request ApplyAutoSnapshotPolicyRequest
 * @return ApplyAutoSnapshotPolicyResponse
 */
func (client *Client) ApplyAutoSnapshotPolicy(request *ApplyAutoSnapshotPolicyRequest) (_result *ApplyAutoSnapshotPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ApplyAutoSnapshotPolicyResponse{}
	_body, _err := client.ApplyAutoSnapshotPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ApplyCoordinatePrivilegeWithOptions(request *ApplyCoordinatePrivilegeRequest, runtime *util.RuntimeOptions) (_result *ApplyCoordinatePrivilegeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CoId)) {
		query["CoId"] = request.CoId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.UserType)) {
		query["UserType"] = request.UserType
	}

	if !tea.BoolValue(util.IsUnset(request.Uuid)) {
		query["Uuid"] = request.Uuid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ApplyCoordinatePrivilege"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ApplyCoordinatePrivilegeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ApplyCoordinatePrivilege(request *ApplyCoordinatePrivilegeRequest) (_result *ApplyCoordinatePrivilegeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ApplyCoordinatePrivilegeResponse{}
	_body, _err := client.ApplyCoordinatePrivilegeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ApplyCoordinationForMonitoringWithOptions(request *ApplyCoordinationForMonitoringRequest, runtime *util.RuntimeOptions) (_result *ApplyCoordinationForMonitoringResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CoordinatePolicyType)) {
		query["CoordinatePolicyType"] = request.CoordinatePolicyType
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.InitiatorType)) {
		query["InitiatorType"] = request.InitiatorType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceCandidates)) {
		query["ResourceCandidates"] = request.ResourceCandidates
	}

	if !tea.BoolValue(util.IsUnset(request.Uuid)) {
		query["Uuid"] = request.Uuid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ApplyCoordinationForMonitoring"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ApplyCoordinationForMonitoringResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ApplyCoordinationForMonitoring(request *ApplyCoordinationForMonitoringRequest) (_result *ApplyCoordinationForMonitoringResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ApplyCoordinationForMonitoringResponse{}
	_body, _err := client.ApplyCoordinationForMonitoringWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ApproveFotaUpdateWithOptions(request *ApproveFotaUpdateRequest, runtime *util.RuntimeOptions) (_result *ApproveFotaUpdateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppVersion)) {
		query["AppVersion"] = request.AppVersion
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ApproveFotaUpdate"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ApproveFotaUpdateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ApproveFotaUpdate(request *ApproveFotaUpdateRequest) (_result *ApproveFotaUpdateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ApproveFotaUpdateResponse{}
	_body, _err := client.ApproveFotaUpdateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AssociateNetworkPackageWithOptions(request *AssociateNetworkPackageRequest, runtime *util.RuntimeOptions) (_result *AssociateNetworkPackageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NetworkPackageId)) {
		query["NetworkPackageId"] = request.NetworkPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AssociateNetworkPackage"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AssociateNetworkPackageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AssociateNetworkPackage(request *AssociateNetworkPackageRequest) (_result *AssociateNetworkPackageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AssociateNetworkPackageResponse{}
	_body, _err := client.AssociateNetworkPackageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Prerequisites
 * *   A CEN instance is created.
 * *   A workspace of the convenience account type is created.
 * > Workspaces of the Active Directory (AD) account type are automatically attached to CEN instances when you create the workspaces. You can attach the secure office network of a workspace to only one CEN instance.
 *
 * @param request AttachCenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachCenResponse
 */
func (client *Client) AttachCenWithOptions(request *AttachCenRequest, runtime *util.RuntimeOptions) (_result *AttachCenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.CenOwnerId)) {
		query["CenOwnerId"] = request.CenOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.VerifyCode)) {
		query["VerifyCode"] = request.VerifyCode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachCen"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachCenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Prerequisites
 * *   A CEN instance is created.
 * *   A workspace of the convenience account type is created.
 * > Workspaces of the Active Directory (AD) account type are automatically attached to CEN instances when you create the workspaces. You can attach the secure office network of a workspace to only one CEN instance.
 *
 * @param request AttachCenRequest
 * @return AttachCenResponse
 */
func (client *Client) AttachCen(request *AttachCenRequest) (_result *AttachCenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachCenResponse{}
	_body, _err := client.AttachCenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AttachEndUserWithOptions(request *AttachEndUserRequest, runtime *util.RuntimeOptions) (_result *AttachEndUserResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AdDomain)) {
		query["AdDomain"] = request.AdDomain
	}

	if !tea.BoolValue(util.IsUnset(request.ClientType)) {
		query["ClientType"] = request.ClientType
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceId)) {
		query["DeviceId"] = request.DeviceId
	}

	if !tea.BoolValue(util.IsUnset(request.DirectoryId)) {
		query["DirectoryId"] = request.DirectoryId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.UserType)) {
		query["UserType"] = request.UserType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachEndUser"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachEndUserResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AttachEndUser(request *AttachEndUserRequest) (_result *AttachEndUserResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachEndUserResponse{}
	_body, _err := client.AttachEndUserWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CancelAutoSnapshotPolicyWithOptions(request *CancelAutoSnapshotPolicyRequest, runtime *util.RuntimeOptions) (_result *CancelAutoSnapshotPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyId)) {
		query["PolicyId"] = request.PolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CancelAutoSnapshotPolicy"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CancelAutoSnapshotPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CancelAutoSnapshotPolicy(request *CancelAutoSnapshotPolicyRequest) (_result *CancelAutoSnapshotPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CancelAutoSnapshotPolicyResponse{}
	_body, _err := client.CancelAutoSnapshotPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CancelCdsFileShareLinkWithOptions(request *CancelCdsFileShareLinkRequest, runtime *util.RuntimeOptions) (_result *CancelCdsFileShareLinkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	if !tea.BoolValue(util.IsUnset(request.ShareId)) {
		query["ShareId"] = request.ShareId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CancelCdsFileShareLink"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CancelCdsFileShareLinkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CancelCdsFileShareLink(request *CancelCdsFileShareLinkRequest) (_result *CancelCdsFileShareLinkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CancelCdsFileShareLinkResponse{}
	_body, _err := client.CancelCdsFileShareLinkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CancelCoordinationForMonitoringWithOptions(request *CancelCoordinationForMonitoringRequest, runtime *util.RuntimeOptions) (_result *CancelCoordinationForMonitoringResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CoIds)) {
		query["CoIds"] = request.CoIds
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.UserType)) {
		query["UserType"] = request.UserType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CancelCoordinationForMonitoring"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CancelCoordinationForMonitoringResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CancelCoordinationForMonitoring(request *CancelCoordinationForMonitoringRequest) (_result *CancelCoordinationForMonitoringResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CancelCoordinationForMonitoringResponse{}
	_body, _err := client.CancelCoordinationForMonitoringWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CancelCopyImageWithOptions(request *CancelCopyImageRequest, runtime *util.RuntimeOptions) (_result *CancelCopyImageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CancelCopyImage"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CancelCopyImageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CancelCopyImage(request *CancelCopyImageRequest) (_result *CancelCopyImageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CancelCopyImageResponse{}
	_body, _err := client.CancelCopyImageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ClonePolicyGroupWithOptions(request *ClonePolicyGroupRequest, runtime *util.RuntimeOptions) (_result *ClonePolicyGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyGroupId)) {
		query["PolicyGroupId"] = request.PolicyGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ClonePolicyGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ClonePolicyGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ClonePolicyGroup(request *ClonePolicyGroupRequest) (_result *ClonePolicyGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ClonePolicyGroupResponse{}
	_body, _err := client.ClonePolicyGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CompleteCdsFileWithOptions(request *CompleteCdsFileRequest, runtime *util.RuntimeOptions) (_result *CompleteCdsFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		query["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.UploadId)) {
		query["UploadId"] = request.UploadId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CompleteCdsFile"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CompleteCdsFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CompleteCdsFile(request *CompleteCdsFileRequest) (_result *CompleteCdsFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CompleteCdsFileResponse{}
	_body, _err := client.CompleteCdsFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ConfigADConnectorTrustWithOptions(request *ConfigADConnectorTrustRequest, runtime *util.RuntimeOptions) (_result *ConfigADConnectorTrustResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.RdsLicenseDomain)) {
		query["RdsLicenseDomain"] = request.RdsLicenseDomain
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.TrustKey)) {
		query["TrustKey"] = request.TrustKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ConfigADConnectorTrust"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ConfigADConnectorTrustResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ConfigADConnectorTrust(request *ConfigADConnectorTrustRequest) (_result *ConfigADConnectorTrustResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ConfigADConnectorTrustResponse{}
	_body, _err := client.ConfigADConnectorTrustWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ConfigADConnectorUserWithOptions(request *ConfigADConnectorUserRequest, runtime *util.RuntimeOptions) (_result *ConfigADConnectorUserResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainPassword)) {
		query["DomainPassword"] = request.DomainPassword
	}

	if !tea.BoolValue(util.IsUnset(request.DomainUserName)) {
		query["DomainUserName"] = request.DomainUserName
	}

	if !tea.BoolValue(util.IsUnset(request.OUName)) {
		query["OUName"] = request.OUName
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ConfigADConnectorUser"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ConfigADConnectorUserResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ConfigADConnectorUser(request *ConfigADConnectorUserRequest) (_result *ConfigADConnectorUserResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ConfigADConnectorUserResponse{}
	_body, _err := client.ConfigADConnectorUserWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CopyCdsFileWithOptions(request *CopyCdsFileRequest, runtime *util.RuntimeOptions) (_result *CopyCdsFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoRename)) {
		query["AutoRename"] = request.AutoRename
	}

	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		query["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.FileReceiverId)) {
		query["FileReceiverId"] = request.FileReceiverId
	}

	if !tea.BoolValue(util.IsUnset(request.FileReceiverType)) {
		query["FileReceiverType"] = request.FileReceiverType
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ParentFolderId)) {
		query["ParentFolderId"] = request.ParentFolderId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CopyCdsFile"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CopyCdsFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CopyCdsFile(request *CopyCdsFileRequest) (_result *CopyCdsFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CopyCdsFileResponse{}
	_body, _err := client.CopyCdsFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CopyImageWithOptions(request *CopyImageRequest, runtime *util.RuntimeOptions) (_result *CopyImageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DestinationDescription)) {
		query["DestinationDescription"] = request.DestinationDescription
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationImageName)) {
		query["DestinationImageName"] = request.DestinationImageName
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationRegionId)) {
		query["DestinationRegionId"] = request.DestinationRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CopyImage"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CopyImageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CopyImage(request *CopyImageRequest) (_result *CopyImageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CopyImageResponse{}
	_body, _err := client.CopyImageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * AD directories are used to connect to enterprise AD systems and are suitable for large-scale desktop deployments. You are charged for AD directories that are used to connect to enterprise AD systems. For more information, see [Billing overview](~~188395~~).
 *
 * @param request CreateADConnectorDirectoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateADConnectorDirectoryResponse
 */
func (client *Client) CreateADConnectorDirectoryWithOptions(request *CreateADConnectorDirectoryRequest, runtime *util.RuntimeOptions) (_result *CreateADConnectorDirectoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopAccessType)) {
		query["DesktopAccessType"] = request.DesktopAccessType
	}

	if !tea.BoolValue(util.IsUnset(request.DirectoryName)) {
		query["DirectoryName"] = request.DirectoryName
	}

	if !tea.BoolValue(util.IsUnset(request.DnsAddress)) {
		query["DnsAddress"] = request.DnsAddress
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.DomainPassword)) {
		query["DomainPassword"] = request.DomainPassword
	}

	if !tea.BoolValue(util.IsUnset(request.DomainUserName)) {
		query["DomainUserName"] = request.DomainUserName
	}

	if !tea.BoolValue(util.IsUnset(request.EnableAdminAccess)) {
		query["EnableAdminAccess"] = request.EnableAdminAccess
	}

	if !tea.BoolValue(util.IsUnset(request.MfaEnabled)) {
		query["MfaEnabled"] = request.MfaEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Specification)) {
		query["Specification"] = request.Specification
	}

	if !tea.BoolValue(util.IsUnset(request.SubDomainDnsAddress)) {
		query["SubDomainDnsAddress"] = request.SubDomainDnsAddress
	}

	if !tea.BoolValue(util.IsUnset(request.SubDomainName)) {
		query["SubDomainName"] = request.SubDomainName
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateADConnectorDirectory"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateADConnectorDirectoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * AD directories are used to connect to enterprise AD systems and are suitable for large-scale desktop deployments. You are charged for AD directories that are used to connect to enterprise AD systems. For more information, see [Billing overview](~~188395~~).
 *
 * @param request CreateADConnectorDirectoryRequest
 * @return CreateADConnectorDirectoryResponse
 */
func (client *Client) CreateADConnectorDirectory(request *CreateADConnectorDirectoryRequest) (_result *CreateADConnectorDirectoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateADConnectorDirectoryResponse{}
	_body, _err := client.CreateADConnectorDirectoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   When you create a workspace of the enterprise AD account type, AD connectors are automatically created to allow you to connect to enterprise AD systems. You are charged for the AD connectors. For more information, see [Billing overview](~~188395~~).
 * *   After you call this operation to create a workspace of the enterprise AD account type, perform the following steps to configure the AD domain: 1. Configure the conditional forwarder in the Domain Name System (DNS) server. 2. Configure the trust relationship in the AD domain server, and call the [ConfigADConnectorTrust](~~311258~~) operation to configure the trust relationship for the workspace of the enterprise AD account type. 3. Call the [ListUserAdOrganizationUnits](~~311259~~) operation to obtain the organizational unit (OU) details of the AD domain. Then, call the [ConfigADConnectorUser](~~311262~~) operation to specify an OU and an administrator for the workspace of the enterprise AD account type.
 *     **
 *     **Note**If you specify DomainUserName and DomainPassword when you create a workspace of the enterprise AD account type, you must configure only the conditional forwarder. If you do not specify DomainUserName or DomainPassword, you must configure the conditional forwarder, trust relationship, and OU.
 * For more information, see [Create a workspace of the enterprise AD account type](~~214469~~).
 *
 * @param request CreateADConnectorOfficeSiteRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateADConnectorOfficeSiteResponse
 */
func (client *Client) CreateADConnectorOfficeSiteWithOptions(request *CreateADConnectorOfficeSiteRequest, runtime *util.RuntimeOptions) (_result *CreateADConnectorOfficeSiteResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AdHostname)) {
		query["AdHostname"] = request.AdHostname
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.CenOwnerId)) {
		query["CenOwnerId"] = request.CenOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.CidrBlock)) {
		query["CidrBlock"] = request.CidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopAccessType)) {
		query["DesktopAccessType"] = request.DesktopAccessType
	}

	if !tea.BoolValue(util.IsUnset(request.DnsAddress)) {
		query["DnsAddress"] = request.DnsAddress
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.DomainPassword)) {
		query["DomainPassword"] = request.DomainPassword
	}

	if !tea.BoolValue(util.IsUnset(request.DomainUserName)) {
		query["DomainUserName"] = request.DomainUserName
	}

	if !tea.BoolValue(util.IsUnset(request.EnableAdminAccess)) {
		query["EnableAdminAccess"] = request.EnableAdminAccess
	}

	if !tea.BoolValue(util.IsUnset(request.EnableInternetAccess)) {
		query["EnableInternetAccess"] = request.EnableInternetAccess
	}

	if !tea.BoolValue(util.IsUnset(request.MfaEnabled)) {
		query["MfaEnabled"] = request.MfaEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteName)) {
		query["OfficeSiteName"] = request.OfficeSiteName
	}

	if !tea.BoolValue(util.IsUnset(request.ProtocolType)) {
		query["ProtocolType"] = request.ProtocolType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Specification)) {
		query["Specification"] = request.Specification
	}

	if !tea.BoolValue(util.IsUnset(request.SubDomainDnsAddress)) {
		query["SubDomainDnsAddress"] = request.SubDomainDnsAddress
	}

	if !tea.BoolValue(util.IsUnset(request.SubDomainName)) {
		query["SubDomainName"] = request.SubDomainName
	}

	if !tea.BoolValue(util.IsUnset(request.VerifyCode)) {
		query["VerifyCode"] = request.VerifyCode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateADConnectorOfficeSite"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateADConnectorOfficeSiteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   When you create a workspace of the enterprise AD account type, AD connectors are automatically created to allow you to connect to enterprise AD systems. You are charged for the AD connectors. For more information, see [Billing overview](~~188395~~).
 * *   After you call this operation to create a workspace of the enterprise AD account type, perform the following steps to configure the AD domain: 1. Configure the conditional forwarder in the Domain Name System (DNS) server. 2. Configure the trust relationship in the AD domain server, and call the [ConfigADConnectorTrust](~~311258~~) operation to configure the trust relationship for the workspace of the enterprise AD account type. 3. Call the [ListUserAdOrganizationUnits](~~311259~~) operation to obtain the organizational unit (OU) details of the AD domain. Then, call the [ConfigADConnectorUser](~~311262~~) operation to specify an OU and an administrator for the workspace of the enterprise AD account type.
 *     **
 *     **Note**If you specify DomainUserName and DomainPassword when you create a workspace of the enterprise AD account type, you must configure only the conditional forwarder. If you do not specify DomainUserName or DomainPassword, you must configure the conditional forwarder, trust relationship, and OU.
 * For more information, see [Create a workspace of the enterprise AD account type](~~214469~~).
 *
 * @param request CreateADConnectorOfficeSiteRequest
 * @return CreateADConnectorOfficeSiteResponse
 */
func (client *Client) CreateADConnectorOfficeSite(request *CreateADConnectorOfficeSiteRequest) (_result *CreateADConnectorOfficeSiteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateADConnectorOfficeSiteResponse{}
	_body, _err := client.CreateADConnectorOfficeSiteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateAndBindNasFileSystemWithOptions(request *CreateAndBindNasFileSystemRequest, runtime *util.RuntimeOptions) (_result *CreateAndBindNasFileSystemResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopGroupId)) {
		query["DesktopGroupId"] = request.DesktopGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.EncryptType)) {
		query["EncryptType"] = request.EncryptType
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserIds)) {
		query["EndUserIds"] = request.EndUserIds
	}

	if !tea.BoolValue(util.IsUnset(request.FileSystemName)) {
		query["FileSystemName"] = request.FileSystemName
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.StorageType)) {
		query["StorageType"] = request.StorageType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAndBindNasFileSystem"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateAndBindNasFileSystemResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateAndBindNasFileSystem(request *CreateAndBindNasFileSystemRequest) (_result *CreateAndBindNasFileSystemResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateAndBindNasFileSystemResponse{}
	_body, _err := client.CreateAndBindNasFileSystemWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the operation to create an automatic snapshot policy based on a CRON expression. Then, the system automatically creates snapshots of a cloud desktop based on the policy.
 *
 * @param request CreateAutoSnapshotPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAutoSnapshotPolicyResponse
 */
func (client *Client) CreateAutoSnapshotPolicyWithOptions(request *CreateAutoSnapshotPolicyRequest, runtime *util.RuntimeOptions) (_result *CreateAutoSnapshotPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CronExpression)) {
		query["CronExpression"] = request.CronExpression
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyName)) {
		query["PolicyName"] = request.PolicyName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RetentionDays)) {
		query["RetentionDays"] = request.RetentionDays
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAutoSnapshotPolicy"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateAutoSnapshotPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the operation to create an automatic snapshot policy based on a CRON expression. Then, the system automatically creates snapshots of a cloud desktop based on the policy.
 *
 * @param request CreateAutoSnapshotPolicyRequest
 * @return CreateAutoSnapshotPolicyResponse
 */
func (client *Client) CreateAutoSnapshotPolicy(request *CreateAutoSnapshotPolicyRequest) (_result *CreateAutoSnapshotPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateAutoSnapshotPolicyResponse{}
	_body, _err := client.CreateAutoSnapshotPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Desktop templates are categorized into system templates and custom templates. System templates are the templates provided by Alibaba Cloud. You can call this operation to create a custom template.
 *
 * @param request CreateBundleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBundleResponse
 */
func (client *Client) CreateBundleWithOptions(request *CreateBundleRequest, runtime *util.RuntimeOptions) (_result *CreateBundleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BundleName)) {
		query["BundleName"] = request.BundleName
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopType)) {
		query["DesktopType"] = request.DesktopType
	}

	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.Language)) {
		query["Language"] = request.Language
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RootDiskPerformanceLevel)) {
		query["RootDiskPerformanceLevel"] = request.RootDiskPerformanceLevel
	}

	if !tea.BoolValue(util.IsUnset(request.RootDiskSizeGib)) {
		query["RootDiskSizeGib"] = request.RootDiskSizeGib
	}

	if !tea.BoolValue(util.IsUnset(request.UserDiskPerformanceLevel)) {
		query["UserDiskPerformanceLevel"] = request.UserDiskPerformanceLevel
	}

	if !tea.BoolValue(util.IsUnset(request.UserDiskSizeGib)) {
		query["UserDiskSizeGib"] = request.UserDiskSizeGib
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateBundle"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateBundleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Desktop templates are categorized into system templates and custom templates. System templates are the templates provided by Alibaba Cloud. You can call this operation to create a custom template.
 *
 * @param request CreateBundleRequest
 * @return CreateBundleResponse
 */
func (client *Client) CreateBundle(request *CreateBundleRequest) (_result *CreateBundleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateBundleResponse{}
	_body, _err := client.CreateBundleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After the RAM permissions are authenticated, you can call the CreateCdsFile operation to obtain the upload URL of a file and upload the file to a cloud disk.
 *
 * @param request CreateCdsFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCdsFileResponse
 */
func (client *Client) CreateCdsFileWithOptions(request *CreateCdsFileRequest, runtime *util.RuntimeOptions) (_result *CreateCdsFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	if !tea.BoolValue(util.IsUnset(request.ConflictPolicy)) {
		query["ConflictPolicy"] = request.ConflictPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.FileHash)) {
		query["FileHash"] = request.FileHash
	}

	if !tea.BoolValue(util.IsUnset(request.FileLength)) {
		query["FileLength"] = request.FileLength
	}

	if !tea.BoolValue(util.IsUnset(request.FileName)) {
		query["FileName"] = request.FileName
	}

	if !tea.BoolValue(util.IsUnset(request.FileType)) {
		query["FileType"] = request.FileType
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ParentFileId)) {
		query["ParentFileId"] = request.ParentFileId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCdsFile"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCdsFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After the RAM permissions are authenticated, you can call the CreateCdsFile operation to obtain the upload URL of a file and upload the file to a cloud disk.
 *
 * @param request CreateCdsFileRequest
 * @return CreateCdsFileResponse
 */
func (client *Client) CreateCdsFile(request *CreateCdsFileRequest) (_result *CreateCdsFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCdsFileResponse{}
	_body, _err := client.CreateCdsFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateCdsFileShareLinkWithOptions(request *CreateCdsFileShareLinkRequest, runtime *util.RuntimeOptions) (_result *CreateCdsFileShareLinkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DisableDownload)) {
		query["DisableDownload"] = request.DisableDownload
	}

	if !tea.BoolValue(util.IsUnset(request.DisablePreview)) {
		query["DisablePreview"] = request.DisablePreview
	}

	if !tea.BoolValue(util.IsUnset(request.DisableSave)) {
		query["DisableSave"] = request.DisableSave
	}

	if !tea.BoolValue(util.IsUnset(request.DownloadLimit)) {
		query["DownloadLimit"] = request.DownloadLimit
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.Expiration)) {
		query["Expiration"] = request.Expiration
	}

	if !tea.BoolValue(util.IsUnset(request.FileIds)) {
		query["FileIds"] = request.FileIds
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.PreviewLimit)) {
		query["PreviewLimit"] = request.PreviewLimit
	}

	if !tea.BoolValue(util.IsUnset(request.SaveLimit)) {
		query["SaveLimit"] = request.SaveLimit
	}

	if !tea.BoolValue(util.IsUnset(request.ShareName)) {
		query["ShareName"] = request.ShareName
	}

	if !tea.BoolValue(util.IsUnset(request.SharePwd)) {
		query["SharePwd"] = request.SharePwd
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCdsFileShareLink"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCdsFileShareLinkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateCdsFileShareLink(request *CreateCdsFileShareLinkRequest) (_result *CreateCdsFileShareLinkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCdsFileShareLinkResponse{}
	_body, _err := client.CreateCdsFileShareLinkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateCloudDriveServiceWithOptions(request *CreateCloudDriveServiceRequest, runtime *util.RuntimeOptions) (_result *CreateCloudDriveServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BizType)) {
		query["BizType"] = request.BizType
	}

	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxSize)) {
		query["MaxSize"] = request.MaxSize
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteType)) {
		query["OfficeSiteType"] = request.OfficeSiteType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SolutionId)) {
		query["SolutionId"] = request.SolutionId
	}

	if !tea.BoolValue(util.IsUnset(request.UserMaxSize)) {
		query["UserMaxSize"] = request.UserMaxSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCloudDriveService"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCloudDriveServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateCloudDriveService(request *CreateCloudDriveServiceRequest) (_result *CreateCloudDriveServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCloudDriveServiceResponse{}
	_body, _err := client.CreateCloudDriveServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateCloudDriveUsersWithOptions(request *CreateCloudDriveUsersRequest, runtime *util.RuntimeOptions) (_result *CreateCloudDriveUsersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.UserMaxSize)) {
		query["UserMaxSize"] = request.UserMaxSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCloudDriveUsers"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCloudDriveUsersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateCloudDriveUsers(request *CreateCloudDriveUsersRequest) (_result *CreateCloudDriveUsersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCloudDriveUsersResponse{}
	_body, _err := client.CreateCloudDriveUsersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * # Description
 * Before you call this operation to create a desktop group, make sure that the following operations are complete:
 * *   You are familiar with the features, usage limits, and scaling policies of desktop groups. For more information, see [Overview](~~290959~~) of desktop groups.
 * *   Resources, such as workspaces, users, desktop templates, and policies, are created.
 *
 * @param request CreateDesktopGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDesktopGroupResponse
 */
func (client *Client) CreateDesktopGroupWithOptions(request *CreateDesktopGroupRequest, runtime *util.RuntimeOptions) (_result *CreateDesktopGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AllClassifyUsers)) {
		query["AllClassifyUsers"] = request.AllClassifyUsers
	}

	if !tea.BoolValue(util.IsUnset(request.AllowAutoSetup)) {
		query["AllowAutoSetup"] = request.AllowAutoSetup
	}

	if !tea.BoolValue(util.IsUnset(request.AllowBufferCount)) {
		query["AllowBufferCount"] = request.AllowBufferCount
	}

	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRenew)) {
		query["AutoRenew"] = request.AutoRenew
	}

	if !tea.BoolValue(util.IsUnset(request.BindAmount)) {
		query["BindAmount"] = request.BindAmount
	}

	if !tea.BoolValue(util.IsUnset(request.BundleId)) {
		query["BundleId"] = request.BundleId
	}

	if !tea.BoolValue(util.IsUnset(request.BuyDesktopsCount)) {
		query["BuyDesktopsCount"] = request.BuyDesktopsCount
	}

	if !tea.BoolValue(util.IsUnset(request.ChargeType)) {
		query["ChargeType"] = request.ChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.Classify)) {
		query["Classify"] = request.Classify
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Comments)) {
		query["Comments"] = request.Comments
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectDuration)) {
		query["ConnectDuration"] = request.ConnectDuration
	}

	if !tea.BoolValue(util.IsUnset(request.DefaultInitDesktopCount)) {
		query["DefaultInitDesktopCount"] = request.DefaultInitDesktopCount
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopGroupName)) {
		query["DesktopGroupName"] = request.DesktopGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.DirectoryId)) {
		query["DirectoryId"] = request.DirectoryId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserIds)) {
		query["EndUserIds"] = request.EndUserIds
	}

	if !tea.BoolValue(util.IsUnset(request.FileSystemId)) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupVersion)) {
		query["GroupVersion"] = request.GroupVersion
	}

	if !tea.BoolValue(util.IsUnset(request.IdleDisconnectDuration)) {
		query["IdleDisconnectDuration"] = request.IdleDisconnectDuration
	}

	if !tea.BoolValue(util.IsUnset(request.KeepDuration)) {
		query["KeepDuration"] = request.KeepDuration
	}

	if !tea.BoolValue(util.IsUnset(request.LoadPolicy)) {
		query["LoadPolicy"] = request.LoadPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.MaxDesktopsCount)) {
		query["MaxDesktopsCount"] = request.MaxDesktopsCount
	}

	if !tea.BoolValue(util.IsUnset(request.MinDesktopsCount)) {
		query["MinDesktopsCount"] = request.MinDesktopsCount
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnType)) {
		query["OwnType"] = request.OwnType
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.PeriodUnit)) {
		query["PeriodUnit"] = request.PeriodUnit
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyGroupId)) {
		query["PolicyGroupId"] = request.PolicyGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ProfileFollowSwitch)) {
		query["ProfileFollowSwitch"] = request.ProfileFollowSwitch
	}

	if !tea.BoolValue(util.IsUnset(request.RatioThreshold)) {
		query["RatioThreshold"] = request.RatioThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResetType)) {
		query["ResetType"] = request.ResetType
	}

	if !tea.BoolValue(util.IsUnset(request.ScaleStrategyId)) {
		query["ScaleStrategyId"] = request.ScaleStrategyId
	}

	if !tea.BoolValue(util.IsUnset(request.StopDuration)) {
		query["StopDuration"] = request.StopDuration
	}

	if !tea.BoolValue(util.IsUnset(request.VolumeEncryptionEnabled)) {
		query["VolumeEncryptionEnabled"] = request.VolumeEncryptionEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.VolumeEncryptionKey)) {
		query["VolumeEncryptionKey"] = request.VolumeEncryptionKey
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDesktopGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDesktopGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * # Description
 * Before you call this operation to create a desktop group, make sure that the following operations are complete:
 * *   You are familiar with the features, usage limits, and scaling policies of desktop groups. For more information, see [Overview](~~290959~~) of desktop groups.
 * *   Resources, such as workspaces, users, desktop templates, and policies, are created.
 *
 * @param request CreateDesktopGroupRequest
 * @return CreateDesktopGroupResponse
 */
func (client *Client) CreateDesktopGroup(request *CreateDesktopGroupRequest) (_result *CreateDesktopGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDesktopGroupResponse{}
	_body, _err := client.CreateDesktopGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateDesktopOversoldGroupWithOptions(request *CreateDesktopOversoldGroupRequest, runtime *util.RuntimeOptions) (_result *CreateDesktopOversoldGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConcurrenceCount)) {
		query["ConcurrenceCount"] = request.ConcurrenceCount
	}

	if !tea.BoolValue(util.IsUnset(request.DataDiskSize)) {
		query["DataDiskSize"] = request.DataDiskSize
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopType)) {
		query["DesktopType"] = request.DesktopType
	}

	if !tea.BoolValue(util.IsUnset(request.DirectoryId)) {
		query["DirectoryId"] = request.DirectoryId
	}

	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OversoldUserCount)) {
		query["OversoldUserCount"] = request.OversoldUserCount
	}

	if !tea.BoolValue(util.IsUnset(request.OversoldWarn)) {
		query["OversoldWarn"] = request.OversoldWarn
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.PeriodUnit)) {
		query["PeriodUnit"] = request.PeriodUnit
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyGroupId)) {
		query["PolicyGroupId"] = request.PolicyGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StopDuration)) {
		query["StopDuration"] = request.StopDuration
	}

	if !tea.BoolValue(util.IsUnset(request.SystemDiskSize)) {
		query["SystemDiskSize"] = request.SystemDiskSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDesktopOversoldGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDesktopOversoldGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateDesktopOversoldGroup(request *CreateDesktopOversoldGroupRequest) (_result *CreateDesktopOversoldGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDesktopOversoldGroupResponse{}
	_body, _err := client.CreateDesktopOversoldGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * 1\\. Before you create a cloud desktop in Elastic Desktop Service (EDS), make sure that the following operations are complete:
 * *   A workspace and a user are created. For more information, see the following topics:
 *     *   Create a workspace of the convenience account type and a convenience user: [CreateSimpleOfficeSite](~~215416~~) and [Create a convenience user](~~214472~~)
 *     *   Create a workspace of the enterprise Active Directory (AD) account type and an enterprise AD user: [CreateADConnectorOfficeSite](~~215417~~) and [Create an enterprise AD user](~~188619~~)
 * *   A cloud desktop template is created by calling the [CreateBundle](~~188883~~) operation, or an existing cloud desktop template is used.
 * *   A policy is created by calling the [CreatePolicyGroup](~~188889~~) operation, or an existing policy is used.
 * 2\\. A custom command script that can be automatically executed after you create the cloud desktop is prepared. You can customize a command script by using the UserCommands parameter.
 *
 * @param request CreateDesktopsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDesktopsResponse
 */
func (client *Client) CreateDesktopsWithOptions(request *CreateDesktopsRequest, runtime *util.RuntimeOptions) (_result *CreateDesktopsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Amount)) {
		query["Amount"] = request.Amount
	}

	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRenew)) {
		query["AutoRenew"] = request.AutoRenew
	}

	if !tea.BoolValue(util.IsUnset(request.BundleId)) {
		query["BundleId"] = request.BundleId
	}

	if !tea.BoolValue(util.IsUnset(request.BundleModels)) {
		query["BundleModels"] = request.BundleModels
	}

	if !tea.BoolValue(util.IsUnset(request.ChargeType)) {
		query["ChargeType"] = request.ChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopMemberIp)) {
		query["DesktopMemberIp"] = request.DesktopMemberIp
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopName)) {
		query["DesktopName"] = request.DesktopName
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopNameSuffix)) {
		query["DesktopNameSuffix"] = request.DesktopNameSuffix
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopTimers)) {
		query["DesktopTimers"] = request.DesktopTimers
	}

	if !tea.BoolValue(util.IsUnset(request.DirectoryId)) {
		query["DirectoryId"] = request.DirectoryId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Hostname)) {
		query["Hostname"] = request.Hostname
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.PeriodUnit)) {
		query["PeriodUnit"] = request.PeriodUnit
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyGroupId)) {
		query["PolicyGroupId"] = request.PolicyGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.PromotionId)) {
		query["PromotionId"] = request.PromotionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.UserAssignMode)) {
		query["UserAssignMode"] = request.UserAssignMode
	}

	if !tea.BoolValue(util.IsUnset(request.UserCommands)) {
		query["UserCommands"] = request.UserCommands
	}

	if !tea.BoolValue(util.IsUnset(request.UserName)) {
		query["UserName"] = request.UserName
	}

	if !tea.BoolValue(util.IsUnset(request.VolumeEncryptionEnabled)) {
		query["VolumeEncryptionEnabled"] = request.VolumeEncryptionEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.VolumeEncryptionKey)) {
		query["VolumeEncryptionKey"] = request.VolumeEncryptionKey
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDesktops"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDesktopsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * 1\\. Before you create a cloud desktop in Elastic Desktop Service (EDS), make sure that the following operations are complete:
 * *   A workspace and a user are created. For more information, see the following topics:
 *     *   Create a workspace of the convenience account type and a convenience user: [CreateSimpleOfficeSite](~~215416~~) and [Create a convenience user](~~214472~~)
 *     *   Create a workspace of the enterprise Active Directory (AD) account type and an enterprise AD user: [CreateADConnectorOfficeSite](~~215417~~) and [Create an enterprise AD user](~~188619~~)
 * *   A cloud desktop template is created by calling the [CreateBundle](~~188883~~) operation, or an existing cloud desktop template is used.
 * *   A policy is created by calling the [CreatePolicyGroup](~~188889~~) operation, or an existing policy is used.
 * 2\\. A custom command script that can be automatically executed after you create the cloud desktop is prepared. You can customize a command script by using the UserCommands parameter.
 *
 * @param request CreateDesktopsRequest
 * @return CreateDesktopsResponse
 */
func (client *Client) CreateDesktops(request *CreateDesktopsRequest) (_result *CreateDesktopsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDesktopsResponse{}
	_body, _err := client.CreateDesktopsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateDiskEncryptionServiceWithOptions(request *CreateDiskEncryptionServiceRequest, runtime *util.RuntimeOptions) (_result *CreateDiskEncryptionServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDiskEncryptionService"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDiskEncryptionServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateDiskEncryptionService(request *CreateDiskEncryptionServiceRequest) (_result *CreateDiskEncryptionServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDiskEncryptionServiceResponse{}
	_body, _err := client.CreateDiskEncryptionServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateImageWithOptions(request *CreateImageRequest, runtime *util.RuntimeOptions) (_result *CreateImageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoCleanUserdata)) {
		query["AutoCleanUserdata"] = request.AutoCleanUserdata
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.DiskType)) {
		query["DiskType"] = request.DiskType
	}

	if !tea.BoolValue(util.IsUnset(request.ImageName)) {
		query["ImageName"] = request.ImageName
	}

	if !tea.BoolValue(util.IsUnset(request.ImageResourceType)) {
		query["ImageResourceType"] = request.ImageResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SnapshotId)) {
		query["SnapshotId"] = request.SnapshotId
	}

	if !tea.BoolValue(util.IsUnset(request.SnapshotIds)) {
		query["SnapshotIds"] = request.SnapshotIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateImage"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateImageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateImage(request *CreateImageRequest) (_result *CreateImageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateImageResponse{}
	_body, _err := client.CreateImageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateNASFileSystemWithOptions(request *CreateNASFileSystemRequest, runtime *util.RuntimeOptions) (_result *CreateNASFileSystemResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EncryptType)) {
		query["EncryptType"] = request.EncryptType
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.StorageType)) {
		query["StorageType"] = request.StorageType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateNASFileSystem"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateNASFileSystemResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateNASFileSystem(request *CreateNASFileSystemRequest) (_result *CreateNASFileSystemResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateNASFileSystemResponse{}
	_body, _err := client.CreateNASFileSystemWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateNetworkPackageWithOptions(request *CreateNetworkPackageRequest, runtime *util.RuntimeOptions) (_result *CreateNetworkPackageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRenew)) {
		query["AutoRenew"] = request.AutoRenew
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.InternetChargeType)) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.PayType)) {
		query["PayType"] = request.PayType
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.PeriodUnit)) {
		query["PeriodUnit"] = request.PeriodUnit
	}

	if !tea.BoolValue(util.IsUnset(request.PromotionId)) {
		query["PromotionId"] = request.PromotionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateNetworkPackage"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateNetworkPackageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateNetworkPackage(request *CreateNetworkPackageRequest) (_result *CreateNetworkPackageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateNetworkPackageResponse{}
	_body, _err := client.CreateNetworkPackageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * A policy is a set of security rules that are used to control security configurations when end users use cloud desktops. A policy contains basic features, such as USB redirection and watermarking, and other features, such as security group control. For more information, see [Policy overview](~~189345~~).
 *
 * @param request CreatePolicyGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePolicyGroupResponse
 */
func (client *Client) CreatePolicyGroupWithOptions(request *CreatePolicyGroupRequest, runtime *util.RuntimeOptions) (_result *CreatePolicyGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AdminAccess)) {
		query["AdminAccess"] = request.AdminAccess
	}

	if !tea.BoolValue(util.IsUnset(request.AppContentProtection)) {
		query["AppContentProtection"] = request.AppContentProtection
	}

	if !tea.BoolValue(util.IsUnset(request.AuthorizeAccessPolicyRule)) {
		query["AuthorizeAccessPolicyRule"] = request.AuthorizeAccessPolicyRule
	}

	if !tea.BoolValue(util.IsUnset(request.AuthorizeSecurityPolicyRule)) {
		query["AuthorizeSecurityPolicyRule"] = request.AuthorizeSecurityPolicyRule
	}

	if !tea.BoolValue(util.IsUnset(request.CameraRedirect)) {
		query["CameraRedirect"] = request.CameraRedirect
	}

	if !tea.BoolValue(util.IsUnset(request.ClientType)) {
		query["ClientType"] = request.ClientType
	}

	if !tea.BoolValue(util.IsUnset(request.Clipboard)) {
		query["Clipboard"] = request.Clipboard
	}

	if !tea.BoolValue(util.IsUnset(request.DomainList)) {
		query["DomainList"] = request.DomainList
	}

	if !tea.BoolValue(util.IsUnset(request.DomainResolveRule)) {
		query["DomainResolveRule"] = request.DomainResolveRule
	}

	if !tea.BoolValue(util.IsUnset(request.DomainResolveRuleType)) {
		query["DomainResolveRuleType"] = request.DomainResolveRuleType
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserApplyAdminCoordinate)) {
		query["EndUserApplyAdminCoordinate"] = request.EndUserApplyAdminCoordinate
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserGroupCoordinate)) {
		query["EndUserGroupCoordinate"] = request.EndUserGroupCoordinate
	}

	if !tea.BoolValue(util.IsUnset(request.GpuAcceleration)) {
		query["GpuAcceleration"] = request.GpuAcceleration
	}

	if !tea.BoolValue(util.IsUnset(request.Html5Access)) {
		query["Html5Access"] = request.Html5Access
	}

	if !tea.BoolValue(util.IsUnset(request.Html5FileTransfer)) {
		query["Html5FileTransfer"] = request.Html5FileTransfer
	}

	if !tea.BoolValue(util.IsUnset(request.InternetCommunicationProtocol)) {
		query["InternetCommunicationProtocol"] = request.InternetCommunicationProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.LocalDrive)) {
		query["LocalDrive"] = request.LocalDrive
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.NetRedirect)) {
		query["NetRedirect"] = request.NetRedirect
	}

	if !tea.BoolValue(util.IsUnset(request.PreemptLogin)) {
		query["PreemptLogin"] = request.PreemptLogin
	}

	if !tea.BoolValue(util.IsUnset(request.PreemptLoginUser)) {
		query["PreemptLoginUser"] = request.PreemptLoginUser
	}

	if !tea.BoolValue(util.IsUnset(request.PrinterRedirection)) {
		query["PrinterRedirection"] = request.PrinterRedirection
	}

	if !tea.BoolValue(util.IsUnset(request.RecordContent)) {
		query["RecordContent"] = request.RecordContent
	}

	if !tea.BoolValue(util.IsUnset(request.RecordContentExpires)) {
		query["RecordContentExpires"] = request.RecordContentExpires
	}

	if !tea.BoolValue(util.IsUnset(request.Recording)) {
		query["Recording"] = request.Recording
	}

	if !tea.BoolValue(util.IsUnset(request.RecordingAudio)) {
		query["RecordingAudio"] = request.RecordingAudio
	}

	if !tea.BoolValue(util.IsUnset(request.RecordingDuration)) {
		query["RecordingDuration"] = request.RecordingDuration
	}

	if !tea.BoolValue(util.IsUnset(request.RecordingEndTime)) {
		query["RecordingEndTime"] = request.RecordingEndTime
	}

	if !tea.BoolValue(util.IsUnset(request.RecordingExpires)) {
		query["RecordingExpires"] = request.RecordingExpires
	}

	if !tea.BoolValue(util.IsUnset(request.RecordingFps)) {
		query["RecordingFps"] = request.RecordingFps
	}

	if !tea.BoolValue(util.IsUnset(request.RecordingStartTime)) {
		query["RecordingStartTime"] = request.RecordingStartTime
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RemoteCoordinate)) {
		query["RemoteCoordinate"] = request.RemoteCoordinate
	}

	if !tea.BoolValue(util.IsUnset(request.Scope)) {
		query["Scope"] = request.Scope
	}

	if !tea.BoolValue(util.IsUnset(request.ScopeValue)) {
		query["ScopeValue"] = request.ScopeValue
	}

	if !tea.BoolValue(util.IsUnset(request.UsbRedirect)) {
		query["UsbRedirect"] = request.UsbRedirect
	}

	if !tea.BoolValue(util.IsUnset(request.UsbSupplyRedirectRule)) {
		query["UsbSupplyRedirectRule"] = request.UsbSupplyRedirectRule
	}

	if !tea.BoolValue(util.IsUnset(request.VideoRedirect)) {
		query["VideoRedirect"] = request.VideoRedirect
	}

	if !tea.BoolValue(util.IsUnset(request.VisualQuality)) {
		query["VisualQuality"] = request.VisualQuality
	}

	if !tea.BoolValue(util.IsUnset(request.Watermark)) {
		query["Watermark"] = request.Watermark
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkColor)) {
		query["WatermarkColor"] = request.WatermarkColor
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkDegree)) {
		query["WatermarkDegree"] = request.WatermarkDegree
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkFontSize)) {
		query["WatermarkFontSize"] = request.WatermarkFontSize
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkFontStyle)) {
		query["WatermarkFontStyle"] = request.WatermarkFontStyle
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkRowAmount)) {
		query["WatermarkRowAmount"] = request.WatermarkRowAmount
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkSecurity)) {
		query["WatermarkSecurity"] = request.WatermarkSecurity
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkTransparency)) {
		query["WatermarkTransparency"] = request.WatermarkTransparency
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkTransparencyValue)) {
		query["WatermarkTransparencyValue"] = request.WatermarkTransparencyValue
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkType)) {
		query["WatermarkType"] = request.WatermarkType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreatePolicyGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreatePolicyGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * A policy is a set of security rules that are used to control security configurations when end users use cloud desktops. A policy contains basic features, such as USB redirection and watermarking, and other features, such as security group control. For more information, see [Policy overview](~~189345~~).
 *
 * @param request CreatePolicyGroupRequest
 * @return CreatePolicyGroupResponse
 */
func (client *Client) CreatePolicyGroup(request *CreatePolicyGroupRequest) (_result *CreatePolicyGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreatePolicyGroupResponse{}
	_body, _err := client.CreatePolicyGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you create a RAM directory, make sure that you have completed the following operations:
 * *   You have created a virtual private cloud (VPC) by calling the [CreateVpc](~~35737~~) operation in a region where EDS is available.
 * *   You have created a vSwitch in the VPC by calling the [CreateVSwitch](~~35745~~) operation, and the vSwitch resides in a zone where EDS is available.
 *
 * @param request CreateRAMDirectoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRAMDirectoryResponse
 */
func (client *Client) CreateRAMDirectoryWithOptions(request *CreateRAMDirectoryRequest, runtime *util.RuntimeOptions) (_result *CreateRAMDirectoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopAccessType)) {
		query["DesktopAccessType"] = request.DesktopAccessType
	}

	if !tea.BoolValue(util.IsUnset(request.DirectoryName)) {
		query["DirectoryName"] = request.DirectoryName
	}

	if !tea.BoolValue(util.IsUnset(request.EnableAdminAccess)) {
		query["EnableAdminAccess"] = request.EnableAdminAccess
	}

	if !tea.BoolValue(util.IsUnset(request.EnableInternetAccess)) {
		query["EnableInternetAccess"] = request.EnableInternetAccess
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateRAMDirectory"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateRAMDirectoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you create a RAM directory, make sure that you have completed the following operations:
 * *   You have created a virtual private cloud (VPC) by calling the [CreateVpc](~~35737~~) operation in a region where EDS is available.
 * *   You have created a vSwitch in the VPC by calling the [CreateVSwitch](~~35745~~) operation, and the vSwitch resides in a zone where EDS is available.
 *
 * @param request CreateRAMDirectoryRequest
 * @return CreateRAMDirectoryResponse
 */
func (client *Client) CreateRAMDirectory(request *CreateRAMDirectoryRequest) (_result *CreateRAMDirectoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateRAMDirectoryResponse{}
	_body, _err := client.CreateRAMDirectoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateSimpleOfficeSiteWithOptions(request *CreateSimpleOfficeSiteRequest, runtime *util.RuntimeOptions) (_result *CreateSimpleOfficeSiteResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.CenOwnerId)) {
		query["CenOwnerId"] = request.CenOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.CidrBlock)) {
		query["CidrBlock"] = request.CidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.CloudBoxOfficeSite)) {
		query["CloudBoxOfficeSite"] = request.CloudBoxOfficeSite
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopAccessType)) {
		query["DesktopAccessType"] = request.DesktopAccessType
	}

	if !tea.BoolValue(util.IsUnset(request.EnableAdminAccess)) {
		query["EnableAdminAccess"] = request.EnableAdminAccess
	}

	if !tea.BoolValue(util.IsUnset(request.EnableInternetAccess)) {
		query["EnableInternetAccess"] = request.EnableInternetAccess
	}

	if !tea.BoolValue(util.IsUnset(request.NeedVerifyZeroDevice)) {
		query["NeedVerifyZeroDevice"] = request.NeedVerifyZeroDevice
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteName)) {
		query["OfficeSiteName"] = request.OfficeSiteName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.VerifyCode)) {
		query["VerifyCode"] = request.VerifyCode
	}

	if !tea.BoolValue(util.IsUnset(request.VpcType)) {
		query["VpcType"] = request.VpcType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSimpleOfficeSite"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateSimpleOfficeSiteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateSimpleOfficeSite(request *CreateSimpleOfficeSiteRequest) (_result *CreateSimpleOfficeSiteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateSimpleOfficeSiteResponse{}
	_body, _err := client.CreateSimpleOfficeSiteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The cloud desktop for which you want to create a snapshot must be in the **Running** state or **Stopped** state.
 *
 * @param request CreateSnapshotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSnapshotResponse
 */
func (client *Client) CreateSnapshotWithOptions(request *CreateSnapshotRequest, runtime *util.RuntimeOptions) (_result *CreateSnapshotResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SnapshotName)) {
		query["SnapshotName"] = request.SnapshotName
	}

	if !tea.BoolValue(util.IsUnset(request.SourceDiskType)) {
		query["SourceDiskType"] = request.SourceDiskType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSnapshot"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateSnapshotResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The cloud desktop for which you want to create a snapshot must be in the **Running** state or **Stopped** state.
 *
 * @param request CreateSnapshotRequest
 * @return CreateSnapshotResponse
 */
func (client *Client) CreateSnapshot(request *CreateSnapshotRequest) (_result *CreateSnapshotResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateSnapshotResponse{}
	_body, _err := client.CreateSnapshotWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteAutoSnapshotPolicyWithOptions(request *DeleteAutoSnapshotPolicyRequest, runtime *util.RuntimeOptions) (_result *DeleteAutoSnapshotPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PolicyId)) {
		query["PolicyId"] = request.PolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAutoSnapshotPolicy"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAutoSnapshotPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteAutoSnapshotPolicy(request *DeleteAutoSnapshotPolicyRequest) (_result *DeleteAutoSnapshotPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAutoSnapshotPolicyResponse{}
	_body, _err := client.DeleteAutoSnapshotPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteBundlesWithOptions(request *DeleteBundlesRequest, runtime *util.RuntimeOptions) (_result *DeleteBundlesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BundleId)) {
		query["BundleId"] = request.BundleId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteBundles"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteBundlesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteBundles(request *DeleteBundlesRequest) (_result *DeleteBundlesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteBundlesResponse{}
	_body, _err := client.DeleteBundlesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteCdsFileWithOptions(request *DeleteCdsFileRequest, runtime *util.RuntimeOptions) (_result *DeleteCdsFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		query["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCdsFile"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCdsFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteCdsFile(request *DeleteCdsFileRequest) (_result *DeleteCdsFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCdsFileResponse{}
	_body, _err := client.DeleteCdsFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteCloudDriveGroupsWithOptions(request *DeleteCloudDriveGroupsRequest, runtime *util.RuntimeOptions) (_result *DeleteCloudDriveGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCloudDriveGroups"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCloudDriveGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteCloudDriveGroups(request *DeleteCloudDriveGroupsRequest) (_result *DeleteCloudDriveGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCloudDriveGroupsResponse{}
	_body, _err := client.DeleteCloudDriveGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteCloudDriveUsersWithOptions(request *DeleteCloudDriveUsersRequest, runtime *util.RuntimeOptions) (_result *DeleteCloudDriveUsersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCloudDriveUsers"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCloudDriveUsersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteCloudDriveUsers(request *DeleteCloudDriveUsersRequest) (_result *DeleteCloudDriveUsersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCloudDriveUsersResponse{}
	_body, _err := client.DeleteCloudDriveUsersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDesktopGroupWithOptions(request *DeleteDesktopGroupRequest, runtime *util.RuntimeOptions) (_result *DeleteDesktopGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopGroupId)) {
		query["DesktopGroupId"] = request.DesktopGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDesktopGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDesktopGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDesktopGroup(request *DeleteDesktopGroupRequest) (_result *DeleteDesktopGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDesktopGroupResponse{}
	_body, _err := client.DeleteDesktopGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDesktopsWithOptions(request *DeleteDesktopsRequest, runtime *util.RuntimeOptions) (_result *DeleteDesktopsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDesktops"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDesktopsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDesktops(request *DeleteDesktopsRequest) (_result *DeleteDesktopsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDesktopsResponse{}
	_body, _err := client.DeleteDesktopsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the operation to manage client devices.
 *
 * @param request DeleteDevicesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDevicesResponse
 */
func (client *Client) DeleteDevicesWithOptions(request *DeleteDevicesRequest, runtime *util.RuntimeOptions) (_result *DeleteDevicesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientType)) {
		query["ClientType"] = request.ClientType
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceIds)) {
		query["DeviceIds"] = request.DeviceIds
	}

	if !tea.BoolValue(util.IsUnset(request.Force)) {
		query["Force"] = request.Force
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDevices"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDevicesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the operation to manage client devices.
 *
 * @param request DeleteDevicesRequest
 * @return DeleteDevicesResponse
 */
func (client *Client) DeleteDevices(request *DeleteDevicesRequest) (_result *DeleteDevicesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDevicesResponse{}
	_body, _err := client.DeleteDevicesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You cannot delete directories that are in use by cloud desktops.
 *
 * @param request DeleteDirectoriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDirectoriesResponse
 */
func (client *Client) DeleteDirectoriesWithOptions(request *DeleteDirectoriesRequest, runtime *util.RuntimeOptions) (_result *DeleteDirectoriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DirectoryId)) {
		query["DirectoryId"] = request.DirectoryId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDirectories"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDirectoriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You cannot delete directories that are in use by cloud desktops.
 *
 * @param request DeleteDirectoriesRequest
 * @return DeleteDirectoriesResponse
 */
func (client *Client) DeleteDirectories(request *DeleteDirectoriesRequest) (_result *DeleteDirectoriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDirectoriesResponse{}
	_body, _err := client.DeleteDirectoriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteEduRoomWithOptions(request *DeleteEduRoomRequest, runtime *util.RuntimeOptions) (_result *DeleteEduRoomResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EduRoomId)) {
		query["EduRoomId"] = request.EduRoomId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteEduRoom"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteEduRoomResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteEduRoom(request *DeleteEduRoomRequest) (_result *DeleteEduRoomResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteEduRoomResponse{}
	_body, _err := client.DeleteEduRoomWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   Images include system images and custom images. System images cannot be deleted.
 * *   If an image to delete is referenced by a desktop template, you must first delete the template by calling the DeleteBundles operation.
 *
 * @param request DeleteImagesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteImagesResponse
 */
func (client *Client) DeleteImagesWithOptions(request *DeleteImagesRequest, runtime *util.RuntimeOptions) (_result *DeleteImagesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeleteCascadedBundle)) {
		query["DeleteCascadedBundle"] = request.DeleteCascadedBundle
	}

	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteImages"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteImagesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   Images include system images and custom images. System images cannot be deleted.
 * *   If an image to delete is referenced by a desktop template, you must first delete the template by calling the DeleteBundles operation.
 *
 * @param request DeleteImagesRequest
 * @return DeleteImagesResponse
 */
func (client *Client) DeleteImages(request *DeleteImagesRequest) (_result *DeleteImagesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteImagesResponse{}
	_body, _err := client.DeleteImagesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you delete an Apsara File Storage NAS (NAS) file system, make sure that the data you want to retain is backed up.
 * **
 * **Warning** If a NAS file system is deleted, data stored in the NAS file system cannot be restored. Proceed with caution when you delete NAS file systems.
 *
 * @param request DeleteNASFileSystemsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNASFileSystemsResponse
 */
func (client *Client) DeleteNASFileSystemsWithOptions(request *DeleteNASFileSystemsRequest, runtime *util.RuntimeOptions) (_result *DeleteNASFileSystemsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FileSystemId)) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteNASFileSystems"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteNASFileSystemsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you delete an Apsara File Storage NAS (NAS) file system, make sure that the data you want to retain is backed up.
 * **
 * **Warning** If a NAS file system is deleted, data stored in the NAS file system cannot be restored. Proceed with caution when you delete NAS file systems.
 *
 * @param request DeleteNASFileSystemsRequest
 * @return DeleteNASFileSystemsResponse
 */
func (client *Client) DeleteNASFileSystems(request *DeleteNASFileSystemsRequest) (_result *DeleteNASFileSystemsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteNASFileSystemsResponse{}
	_body, _err := client.DeleteNASFileSystemsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteNetworkPackagesWithOptions(request *DeleteNetworkPackagesRequest, runtime *util.RuntimeOptions) (_result *DeleteNetworkPackagesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NetworkPackageId)) {
		query["NetworkPackageId"] = request.NetworkPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteNetworkPackages"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteNetworkPackagesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteNetworkPackages(request *DeleteNetworkPackagesRequest) (_result *DeleteNetworkPackagesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteNetworkPackagesResponse{}
	_body, _err := client.DeleteNetworkPackagesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you delete a workspace, make sure that the following requirements are met:
 * *   All cloud desktops in the workspace are released.
 * *   The data that you want to retain is backed up.
 * **
 * **Warning** After you delete a workspace, the resources and data of the workspace cannot be recovered. Exercise with caution.
 *
 * @param request DeleteOfficeSitesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteOfficeSitesResponse
 */
func (client *Client) DeleteOfficeSitesWithOptions(request *DeleteOfficeSitesRequest, runtime *util.RuntimeOptions) (_result *DeleteOfficeSitesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteOfficeSites"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteOfficeSitesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you delete a workspace, make sure that the following requirements are met:
 * *   All cloud desktops in the workspace are released.
 * *   The data that you want to retain is backed up.
 * **
 * **Warning** After you delete a workspace, the resources and data of the workspace cannot be recovered. Exercise with caution.
 *
 * @param request DeleteOfficeSitesRequest
 * @return DeleteOfficeSitesResponse
 */
func (client *Client) DeleteOfficeSites(request *DeleteOfficeSitesRequest) (_result *DeleteOfficeSitesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteOfficeSitesResponse{}
	_body, _err := client.DeleteOfficeSitesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeletePolicyGroupsWithOptions(request *DeletePolicyGroupsRequest, runtime *util.RuntimeOptions) (_result *DeletePolicyGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PolicyGroupId)) {
		query["PolicyGroupId"] = request.PolicyGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeletePolicyGroups"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeletePolicyGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeletePolicyGroups(request *DeletePolicyGroupsRequest) (_result *DeletePolicyGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeletePolicyGroupsResponse{}
	_body, _err := client.DeletePolicyGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If the IDs of the snapshots that you specify do not exist, requests are ignored.
 *
 * @param request DeleteSnapshotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSnapshotResponse
 */
func (client *Client) DeleteSnapshotWithOptions(request *DeleteSnapshotRequest, runtime *util.RuntimeOptions) (_result *DeleteSnapshotResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SnapshotId)) {
		query["SnapshotId"] = request.SnapshotId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSnapshot"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSnapshotResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If the IDs of the snapshots that you specify do not exist, requests are ignored.
 *
 * @param request DeleteSnapshotRequest
 * @return DeleteSnapshotResponse
 */
func (client *Client) DeleteSnapshot(request *DeleteSnapshotRequest) (_result *DeleteSnapshotResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSnapshotResponse{}
	_body, _err := client.DeleteSnapshotWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If an MFA device is deleted, the device is unbound, reset, and disabled. When the Active Directory (AD) user wants to log on to the cloud desktop, the AD user must bind a new MFA device.
 *
 * @param request DeleteVirtualMFADeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVirtualMFADeviceResponse
 */
func (client *Client) DeleteVirtualMFADeviceWithOptions(request *DeleteVirtualMFADeviceRequest, runtime *util.RuntimeOptions) (_result *DeleteVirtualMFADeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SerialNumber)) {
		query["SerialNumber"] = request.SerialNumber
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteVirtualMFADevice"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteVirtualMFADeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If an MFA device is deleted, the device is unbound, reset, and disabled. When the Active Directory (AD) user wants to log on to the cloud desktop, the AD user must bind a new MFA device.
 *
 * @param request DeleteVirtualMFADeviceRequest
 * @return DeleteVirtualMFADeviceResponse
 */
func (client *Client) DeleteVirtualMFADevice(request *DeleteVirtualMFADeviceRequest) (_result *DeleteVirtualMFADeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteVirtualMFADeviceResponse{}
	_body, _err := client.DeleteVirtualMFADeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeAclEntriesWithOptions(request *DescribeAclEntriesRequest, runtime *util.RuntimeOptions) (_result *DescribeAclEntriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceId)) {
		query["SourceId"] = request.SourceId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceType)) {
		query["SourceType"] = request.SourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAclEntries"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAclEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeAclEntries(request *DescribeAclEntriesRequest) (_result *DescribeAclEntriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAclEntriesResponse{}
	_body, _err := client.DescribeAclEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can view an automatic snapshot policy that is associated with a cloud desktop in the Elastic Desktop Service (EDS) console. To view the automatic snapshot policy, you can go to the EDS console, choose Deployment > Snapshots in the left-side navigation pane, and then view an automatic snapshot policy on the Snapshots page.
 *
 * @param request DescribeAutoSnapshotPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAutoSnapshotPolicyResponse
 */
func (client *Client) DescribeAutoSnapshotPolicyWithOptions(request *DescribeAutoSnapshotPolicyRequest, runtime *util.RuntimeOptions) (_result *DescribeAutoSnapshotPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyId)) {
		query["PolicyId"] = request.PolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyName)) {
		query["PolicyName"] = request.PolicyName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAutoSnapshotPolicy"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAutoSnapshotPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can view an automatic snapshot policy that is associated with a cloud desktop in the Elastic Desktop Service (EDS) console. To view the automatic snapshot policy, you can go to the EDS console, choose Deployment > Snapshots in the left-side navigation pane, and then view an automatic snapshot policy on the Snapshots page.
 *
 * @param request DescribeAutoSnapshotPolicyRequest
 * @return DescribeAutoSnapshotPolicyResponse
 */
func (client *Client) DescribeAutoSnapshotPolicy(request *DescribeAutoSnapshotPolicyRequest) (_result *DescribeAutoSnapshotPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAutoSnapshotPolicyResponse{}
	_body, _err := client.DescribeAutoSnapshotPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeBundlesWithOptions(request *DescribeBundlesRequest, runtime *util.RuntimeOptions) (_result *DescribeBundlesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BundleId)) {
		query["BundleId"] = request.BundleId
	}

	if !tea.BoolValue(util.IsUnset(request.BundleType)) {
		query["BundleType"] = request.BundleType
	}

	if !tea.BoolValue(util.IsUnset(request.CheckStock)) {
		query["CheckStock"] = request.CheckStock
	}

	if !tea.BoolValue(util.IsUnset(request.CpuCount)) {
		query["CpuCount"] = request.CpuCount
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopTypeFamily)) {
		query["DesktopTypeFamily"] = request.DesktopTypeFamily
	}

	if !tea.BoolValue(util.IsUnset(request.FotaChannel)) {
		query["FotaChannel"] = request.FotaChannel
	}

	if !tea.BoolValue(util.IsUnset(request.FromDesktopGroup)) {
		query["FromDesktopGroup"] = request.FromDesktopGroup
	}

	if !tea.BoolValue(util.IsUnset(request.GpuCount)) {
		query["GpuCount"] = request.GpuCount
	}

	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.MemorySize)) {
		query["MemorySize"] = request.MemorySize
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OsType)) {
		query["OsType"] = request.OsType
	}

	if !tea.BoolValue(util.IsUnset(request.ProtocolType)) {
		query["ProtocolType"] = request.ProtocolType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Scope)) {
		query["Scope"] = request.Scope
	}

	if !tea.BoolValue(util.IsUnset(request.SelectedBundle)) {
		query["SelectedBundle"] = request.SelectedBundle
	}

	if !tea.BoolValue(util.IsUnset(request.SessionType)) {
		query["SessionType"] = request.SessionType
	}

	if !tea.BoolValue(util.IsUnset(request.SupportMultiSession)) {
		query["SupportMultiSession"] = request.SupportMultiSession
	}

	if !tea.BoolValue(util.IsUnset(request.VolumeEncryptionEnabled)) {
		query["VolumeEncryptionEnabled"] = request.VolumeEncryptionEnabled
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeBundles"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeBundlesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeBundles(request *DescribeBundlesRequest) (_result *DescribeBundlesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeBundlesResponse{}
	_body, _err := client.DescribeBundlesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCdsFileShareLinksWithOptions(request *DescribeCdsFileShareLinksRequest, runtime *util.RuntimeOptions) (_result *DescribeCdsFileShareLinksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	if !tea.BoolValue(util.IsUnset(request.Creators)) {
		query["Creators"] = request.Creators
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.ShareId)) {
		query["ShareId"] = request.ShareId
	}

	if !tea.BoolValue(util.IsUnset(request.ShareName)) {
		query["ShareName"] = request.ShareName
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCdsFileShareLinks"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCdsFileShareLinksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCdsFileShareLinks(request *DescribeCdsFileShareLinksRequest) (_result *DescribeCdsFileShareLinksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCdsFileShareLinksResponse{}
	_body, _err := client.DescribeCdsFileShareLinksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCensWithOptions(request *DescribeCensRequest, runtime *util.RuntimeOptions) (_result *DescribeCensResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCens"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCensResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCens(request *DescribeCensRequest) (_result *DescribeCensResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCensResponse{}
	_body, _err := client.DescribeCensWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The version of the client.
 *
 * @param request DescribeClientEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeClientEventsResponse
 */
func (client *Client) DescribeClientEventsWithOptions(request *DescribeClientEventsRequest, runtime *util.RuntimeOptions) (_result *DescribeClientEventsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopIp)) {
		query["DesktopIp"] = request.DesktopIp
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopName)) {
		query["DesktopName"] = request.DesktopName
	}

	if !tea.BoolValue(util.IsUnset(request.DirectoryId)) {
		query["DirectoryId"] = request.DirectoryId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.EventType)) {
		query["EventType"] = request.EventType
	}

	if !tea.BoolValue(util.IsUnset(request.EventTypes)) {
		query["EventTypes"] = request.EventTypes
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteName)) {
		query["OfficeSiteName"] = request.OfficeSiteName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeClientEvents"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeClientEventsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The version of the client.
 *
 * @param request DescribeClientEventsRequest
 * @return DescribeClientEventsResponse
 */
func (client *Client) DescribeClientEvents(request *DescribeClientEventsRequest) (_result *DescribeClientEventsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeClientEventsResponse{}
	_body, _err := client.DescribeClientEventsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCloudDriveGroupsWithOptions(request *DescribeCloudDriveGroupsRequest, runtime *util.RuntimeOptions) (_result *DescribeCloudDriveGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	if !tea.BoolValue(util.IsUnset(request.DirectoryId)) {
		query["DirectoryId"] = request.DirectoryId
	}

	if !tea.BoolValue(util.IsUnset(request.DirectoryName)) {
		query["DirectoryName"] = request.DirectoryName
	}

	if !tea.BoolValue(util.IsUnset(request.DriveStatus)) {
		query["DriveStatus"] = request.DriveStatus
	}

	if !tea.BoolValue(util.IsUnset(request.DriveType)) {
		query["DriveType"] = request.DriveType
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.GroupType)) {
		query["GroupType"] = request.GroupType
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.ParentGroupId)) {
		query["ParentGroupId"] = request.ParentGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCloudDriveGroups"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCloudDriveGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCloudDriveGroups(request *DescribeCloudDriveGroupsRequest) (_result *DescribeCloudDriveGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCloudDriveGroupsResponse{}
	_body, _err := client.DescribeCloudDriveGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCloudDrivePermissionsWithOptions(request *DescribeCloudDrivePermissionsRequest, runtime *util.RuntimeOptions) (_result *DescribeCloudDrivePermissionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCloudDrivePermissions"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCloudDrivePermissionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCloudDrivePermissions(request *DescribeCloudDrivePermissionsRequest) (_result *DescribeCloudDrivePermissionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCloudDrivePermissionsResponse{}
	_body, _err := client.DescribeCloudDrivePermissionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCloudDriveUsersWithOptions(request *DescribeCloudDriveUsersRequest, runtime *util.RuntimeOptions) (_result *DescribeCloudDriveUsersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCloudDriveUsers"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCloudDriveUsersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCloudDriveUsers(request *DescribeCloudDriveUsersRequest) (_result *DescribeCloudDriveUsersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCloudDriveUsersResponse{}
	_body, _err := client.DescribeCloudDriveUsersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCustomizedListHeadersWithOptions(request *DescribeCustomizedListHeadersRequest, runtime *util.RuntimeOptions) (_result *DescribeCustomizedListHeadersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LangType)) {
		query["LangType"] = request.LangType
	}

	if !tea.BoolValue(util.IsUnset(request.ListType)) {
		query["ListType"] = request.ListType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCustomizedListHeaders"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCustomizedListHeadersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCustomizedListHeaders(request *DescribeCustomizedListHeadersRequest) (_result *DescribeCustomizedListHeadersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCustomizedListHeadersResponse{}
	_body, _err := client.DescribeCustomizedListHeadersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDesktopGroupsWithOptions(request *DescribeDesktopGroupsRequest, runtime *util.RuntimeOptions) (_result *DescribeDesktopGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BundleId)) {
		query["BundleId"] = request.BundleId
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopGroupId)) {
		query["DesktopGroupId"] = request.DesktopGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopGroupName)) {
		query["DesktopGroupName"] = request.DesktopGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserIds)) {
		query["EndUserIds"] = request.EndUserIds
	}

	if !tea.BoolValue(util.IsUnset(request.ExcludedEndUserIds)) {
		query["ExcludedEndUserIds"] = request.ExcludedEndUserIds
	}

	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnType)) {
		query["OwnType"] = request.OwnType
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.PeriodUnit)) {
		query["PeriodUnit"] = request.PeriodUnit
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyGroupId)) {
		query["PolicyGroupId"] = request.PolicyGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ProtocolType)) {
		query["ProtocolType"] = request.ProtocolType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDesktopGroups"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDesktopGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDesktopGroups(request *DescribeDesktopGroupsRequest) (_result *DescribeDesktopGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDesktopGroupsResponse{}
	_body, _err := client.DescribeDesktopGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDesktopInfoWithOptions(request *DescribeDesktopInfoRequest, runtime *util.RuntimeOptions) (_result *DescribeDesktopInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDesktopInfo"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDesktopInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDesktopInfo(request *DescribeDesktopInfoRequest) (_result *DescribeDesktopInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDesktopInfoResponse{}
	_body, _err := client.DescribeDesktopInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDesktopOversoldGroupWithOptions(request *DescribeDesktopOversoldGroupRequest, runtime *util.RuntimeOptions) (_result *DescribeDesktopOversoldGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OversoldGroupIds)) {
		query["OversoldGroupIds"] = request.OversoldGroupIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDesktopOversoldGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDesktopOversoldGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDesktopOversoldGroup(request *DescribeDesktopOversoldGroupRequest) (_result *DescribeDesktopOversoldGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDesktopOversoldGroupResponse{}
	_body, _err := client.DescribeDesktopOversoldGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDesktopOversoldUserWithOptions(request *DescribeDesktopOversoldUserRequest, runtime *util.RuntimeOptions) (_result *DescribeDesktopOversoldUserResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OversoldGroupId)) {
		query["OversoldGroupId"] = request.OversoldGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.UserDesktopIds)) {
		query["UserDesktopIds"] = request.UserDesktopIds
	}

	if !tea.BoolValue(util.IsUnset(request.UserGroupId)) {
		query["UserGroupId"] = request.UserGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDesktopOversoldUser"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDesktopOversoldUserResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDesktopOversoldUser(request *DescribeDesktopOversoldUserRequest) (_result *DescribeDesktopOversoldUserResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDesktopOversoldUserResponse{}
	_body, _err := client.DescribeDesktopOversoldUserWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDesktopOversoldUserGroupWithOptions(request *DescribeDesktopOversoldUserGroupRequest, runtime *util.RuntimeOptions) (_result *DescribeDesktopOversoldUserGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OversoldGroupId)) {
		query["OversoldGroupId"] = request.OversoldGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.UserGroupIds)) {
		query["UserGroupIds"] = request.UserGroupIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDesktopOversoldUserGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDesktopOversoldUserGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDesktopOversoldUserGroup(request *DescribeDesktopOversoldUserGroupRequest) (_result *DescribeDesktopOversoldUserGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDesktopOversoldUserGroupResponse{}
	_body, _err := client.DescribeDesktopOversoldUserGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can query data within the last 30 days.
 *
 * @param request DescribeDesktopSessionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDesktopSessionsResponse
 */
func (client *Client) DescribeDesktopSessionsWithOptions(request *DescribeDesktopSessionsRequest, runtime *util.RuntimeOptions) (_result *DescribeDesktopSessionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SessionStatus)) {
		query["SessionStatus"] = request.SessionStatus
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDesktopSessions"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDesktopSessionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can query data within the last 30 days.
 *
 * @param request DescribeDesktopSessionsRequest
 * @return DescribeDesktopSessionsResponse
 */
func (client *Client) DescribeDesktopSessions(request *DescribeDesktopSessionsRequest) (_result *DescribeDesktopSessionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDesktopSessionsResponse{}
	_body, _err := client.DescribeDesktopSessionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When no values are specified for the `InstanceTypeFamily` and `DesktopTypeId` parameters for a cloud desktop, all types of cloud desktops are queried.
 *
 * @param request DescribeDesktopTypesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDesktopTypesResponse
 */
func (client *Client) DescribeDesktopTypesWithOptions(request *DescribeDesktopTypesRequest, runtime *util.RuntimeOptions) (_result *DescribeDesktopTypesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppliedScope)) {
		query["AppliedScope"] = request.AppliedScope
	}

	if !tea.BoolValue(util.IsUnset(request.CpuCount)) {
		query["CpuCount"] = request.CpuCount
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopGroupIdForModify)) {
		query["DesktopGroupIdForModify"] = request.DesktopGroupIdForModify
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopIdForModify)) {
		query["DesktopIdForModify"] = request.DesktopIdForModify
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopTypeId)) {
		query["DesktopTypeId"] = request.DesktopTypeId
	}

	if !tea.BoolValue(util.IsUnset(request.GpuCount)) {
		query["GpuCount"] = request.GpuCount
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceTypeFamily)) {
		query["InstanceTypeFamily"] = request.InstanceTypeFamily
	}

	if !tea.BoolValue(util.IsUnset(request.MemorySize)) {
		query["MemorySize"] = request.MemorySize
	}

	if !tea.BoolValue(util.IsUnset(request.OrderType)) {
		query["OrderType"] = request.OrderType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDesktopTypes"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDesktopTypesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When no values are specified for the `InstanceTypeFamily` and `DesktopTypeId` parameters for a cloud desktop, all types of cloud desktops are queried.
 *
 * @param request DescribeDesktopTypesRequest
 * @return DescribeDesktopTypesResponse
 */
func (client *Client) DescribeDesktopTypes(request *DescribeDesktopTypesRequest) (_result *DescribeDesktopTypesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDesktopTypesResponse{}
	_body, _err := client.DescribeDesktopTypesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDesktopsWithOptions(request *DescribeDesktopsRequest, runtime *util.RuntimeOptions) (_result *DescribeDesktopsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ChargeType)) {
		query["ChargeType"] = request.ChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopGroupId)) {
		query["DesktopGroupId"] = request.DesktopGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopName)) {
		query["DesktopName"] = request.DesktopName
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopStatus)) {
		query["DesktopStatus"] = request.DesktopStatus
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopStatusList)) {
		query["DesktopStatusList"] = request.DesktopStatusList
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopType)) {
		query["DesktopType"] = request.DesktopType
	}

	if !tea.BoolValue(util.IsUnset(request.DirectoryId)) {
		query["DirectoryId"] = request.DirectoryId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.ExcludedEndUserId)) {
		query["ExcludedEndUserId"] = request.ExcludedEndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.ExpiredTime)) {
		query["ExpiredTime"] = request.ExpiredTime
	}

	if !tea.BoolValue(util.IsUnset(request.FilterDesktopGroup)) {
		query["FilterDesktopGroup"] = request.FilterDesktopGroup
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.ManagementFlag)) {
		query["ManagementFlag"] = request.ManagementFlag
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteName)) {
		query["OfficeSiteName"] = request.OfficeSiteName
	}

	if !tea.BoolValue(util.IsUnset(request.OnlyDesktopGroup)) {
		query["OnlyDesktopGroup"] = request.OnlyDesktopGroup
	}

	if !tea.BoolValue(util.IsUnset(request.OsTypes)) {
		query["OsTypes"] = request.OsTypes
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyGroupId)) {
		query["PolicyGroupId"] = request.PolicyGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ProtocolType)) {
		query["ProtocolType"] = request.ProtocolType
	}

	if !tea.BoolValue(util.IsUnset(request.QueryFotaUpdate)) {
		query["QueryFotaUpdate"] = request.QueryFotaUpdate
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SnapshotPolicyId)) {
		query["SnapshotPolicyId"] = request.SnapshotPolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.UserName)) {
		query["UserName"] = request.UserName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDesktops"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDesktopsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDesktops(request *DescribeDesktopsRequest) (_result *DescribeDesktopsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDesktopsResponse{}
	_body, _err := client.DescribeDesktopsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDesktopsInGroupWithOptions(request *DescribeDesktopsInGroupRequest, runtime *util.RuntimeOptions) (_result *DescribeDesktopsInGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopGroupId)) {
		query["DesktopGroupId"] = request.DesktopGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.IgnoreDeleted)) {
		query["IgnoreDeleted"] = request.IgnoreDeleted
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.PayType)) {
		query["PayType"] = request.PayType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDesktopsInGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDesktopsInGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDesktopsInGroup(request *DescribeDesktopsInGroupRequest) (_result *DescribeDesktopsInGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDesktopsInGroupResponse{}
	_body, _err := client.DescribeDesktopsInGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDevicesWithOptions(request *DescribeDevicesRequest, runtime *util.RuntimeOptions) (_result *DescribeDevicesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AdDomain)) {
		query["AdDomain"] = request.AdDomain
	}

	if !tea.BoolValue(util.IsUnset(request.ClientType)) {
		query["ClientType"] = request.ClientType
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceId)) {
		query["DeviceId"] = request.DeviceId
	}

	if !tea.BoolValue(util.IsUnset(request.DirectoryId)) {
		query["DirectoryId"] = request.DirectoryId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.UserType)) {
		query["UserType"] = request.UserType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDevices"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDevicesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDevices(request *DescribeDevicesRequest) (_result *DescribeDevicesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDevicesResponse{}
	_body, _err := client.DescribeDevicesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDirectoriesWithOptions(request *DescribeDirectoriesRequest, runtime *util.RuntimeOptions) (_result *DescribeDirectoriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DirectoryId)) {
		query["DirectoryId"] = request.DirectoryId
	}

	if !tea.BoolValue(util.IsUnset(request.DirectoryStatus)) {
		query["DirectoryStatus"] = request.DirectoryStatus
	}

	if !tea.BoolValue(util.IsUnset(request.DirectoryType)) {
		query["DirectoryType"] = request.DirectoryType
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDirectories"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDirectoriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDirectories(request *DescribeDirectoriesRequest) (_result *DescribeDirectoriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDirectoriesResponse{}
	_body, _err := client.DescribeDirectoriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeFlowMetricWithOptions(request *DescribeFlowMetricRequest, runtime *util.RuntimeOptions) (_result *DescribeFlowMetricResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.MetricType)) {
		query["MetricType"] = request.MetricType
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeFlowMetric"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeFlowMetricResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeFlowMetric(request *DescribeFlowMetricRequest) (_result *DescribeFlowMetricResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeFlowMetricResponse{}
	_body, _err := client.DescribeFlowMetricWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can query only the traffic data in the last 90 days.
 *
 * @param request DescribeFlowStatisticRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFlowStatisticResponse
 */
func (client *Client) DescribeFlowStatisticWithOptions(request *DescribeFlowStatisticRequest, runtime *util.RuntimeOptions) (_result *DescribeFlowStatisticResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeFlowStatistic"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeFlowStatisticResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can query only the traffic data in the last 90 days.
 *
 * @param request DescribeFlowStatisticRequest
 * @return DescribeFlowStatisticResponse
 */
func (client *Client) DescribeFlowStatistic(request *DescribeFlowStatisticRequest) (_result *DescribeFlowStatisticResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeFlowStatisticResponse{}
	_body, _err := client.DescribeFlowStatisticWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeFotaPendingDesktopsWithOptions(request *DescribeFotaPendingDesktopsRequest, runtime *util.RuntimeOptions) (_result *DescribeFotaPendingDesktopsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeFotaPendingDesktops"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeFotaPendingDesktopsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeFotaPendingDesktops(request *DescribeFotaPendingDesktopsRequest) (_result *DescribeFotaPendingDesktopsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeFotaPendingDesktopsResponse{}
	_body, _err := client.DescribeFotaPendingDesktopsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeFotaTasksWithOptions(request *DescribeFotaTasksRequest, runtime *util.RuntimeOptions) (_result *DescribeFotaTasksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FotaStatus)) {
		query["FotaStatus"] = request.FotaStatus
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskUid)) {
		query["TaskUid"] = request.TaskUid
	}

	if !tea.BoolValue(util.IsUnset(request.UserStatus)) {
		query["UserStatus"] = request.UserStatus
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeFotaTasks"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeFotaTasksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeFotaTasks(request *DescribeFotaTasksRequest) (_result *DescribeFotaTasksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeFotaTasksResponse{}
	_body, _err := client.DescribeFotaTasksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeGuestApplicationsWithOptions(request *DescribeGuestApplicationsRequest, runtime *util.RuntimeOptions) (_result *DescribeGuestApplicationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeGuestApplications"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeGuestApplicationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeGuestApplications(request *DescribeGuestApplicationsRequest) (_result *DescribeGuestApplicationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeGuestApplicationsResponse{}
	_body, _err := client.DescribeGuestApplicationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeImageModifiedRecordsWithOptions(request *DescribeImageModifiedRecordsRequest, runtime *util.RuntimeOptions) (_result *DescribeImageModifiedRecordsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeImageModifiedRecords"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeImageModifiedRecordsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeImageModifiedRecords(request *DescribeImageModifiedRecordsRequest) (_result *DescribeImageModifiedRecordsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeImageModifiedRecordsResponse{}
	_body, _err := client.DescribeImageModifiedRecordsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the ModifyImagePermission operation to share images with other Alibaba Cloud accounts or unshare images. You can call the DescribeImagePermission operation to obtain the list of Alibaba Cloud accounts that have received shared images.
 *
 * @param request DescribeImagePermissionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeImagePermissionResponse
 */
func (client *Client) DescribeImagePermissionWithOptions(request *DescribeImagePermissionRequest, runtime *util.RuntimeOptions) (_result *DescribeImagePermissionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeImagePermission"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeImagePermissionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the ModifyImagePermission operation to share images with other Alibaba Cloud accounts or unshare images. You can call the DescribeImagePermission operation to obtain the list of Alibaba Cloud accounts that have received shared images.
 *
 * @param request DescribeImagePermissionRequest
 * @return DescribeImagePermissionResponse
 */
func (client *Client) DescribeImagePermission(request *DescribeImagePermissionRequest) (_result *DescribeImagePermissionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeImagePermissionResponse{}
	_body, _err := client.DescribeImagePermissionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeImagesWithOptions(request *DescribeImagesRequest, runtime *util.RuntimeOptions) (_result *DescribeImagesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopInstanceType)) {
		query["DesktopInstanceType"] = request.DesktopInstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.FotaVersion)) {
		query["FotaVersion"] = request.FotaVersion
	}

	if !tea.BoolValue(util.IsUnset(request.GpuCategory)) {
		query["GpuCategory"] = request.GpuCategory
	}

	if !tea.BoolValue(util.IsUnset(request.GpuDriverVersion)) {
		query["GpuDriverVersion"] = request.GpuDriverVersion
	}

	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.ImageName)) {
		query["ImageName"] = request.ImageName
	}

	if !tea.BoolValue(util.IsUnset(request.ImageStatus)) {
		query["ImageStatus"] = request.ImageStatus
	}

	if !tea.BoolValue(util.IsUnset(request.ImageType)) {
		query["ImageType"] = request.ImageType
	}

	if !tea.BoolValue(util.IsUnset(request.LanguageType)) {
		query["LanguageType"] = request.LanguageType
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OsType)) {
		query["OsType"] = request.OsType
	}

	if !tea.BoolValue(util.IsUnset(request.ProtocolType)) {
		query["ProtocolType"] = request.ProtocolType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SessionType)) {
		query["SessionType"] = request.SessionType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeImages"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeImagesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeImages(request *DescribeImagesRequest) (_result *DescribeImagesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeImagesResponse{}
	_body, _err := client.DescribeImagesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   After you run a command, it may not succeed. You can call this operation to query the execution result.
 * *   You can query the information about execution in the last two weeks. A maximum of 100,000 lines of execution information can be retained.
 *
 * @param request DescribeInvocationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInvocationsResponse
 */
func (client *Client) DescribeInvocationsWithOptions(request *DescribeInvocationsRequest, runtime *util.RuntimeOptions) (_result *DescribeInvocationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CommandType)) {
		query["CommandType"] = request.CommandType
	}

	if !tea.BoolValue(util.IsUnset(request.ContentEncoding)) {
		query["ContentEncoding"] = request.ContentEncoding
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopIds)) {
		query["DesktopIds"] = request.DesktopIds
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.IncludeOutput)) {
		query["IncludeOutput"] = request.IncludeOutput
	}

	if !tea.BoolValue(util.IsUnset(request.InvokeId)) {
		query["InvokeId"] = request.InvokeId
	}

	if !tea.BoolValue(util.IsUnset(request.InvokeStatus)) {
		query["InvokeStatus"] = request.InvokeStatus
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeInvocations"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeInvocationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   After you run a command, it may not succeed. You can call this operation to query the execution result.
 * *   You can query the information about execution in the last two weeks. A maximum of 100,000 lines of execution information can be retained.
 *
 * @param request DescribeInvocationsRequest
 * @return DescribeInvocationsResponse
 */
func (client *Client) DescribeInvocations(request *DescribeInvocationsRequest) (_result *DescribeInvocationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeInvocationsResponse{}
	_body, _err := client.DescribeInvocationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeKmsKeysWithOptions(request *DescribeKmsKeysRequest, runtime *util.RuntimeOptions) (_result *DescribeKmsKeysResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeKmsKeys"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeKmsKeysResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeKmsKeys(request *DescribeKmsKeysRequest) (_result *DescribeKmsKeysResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeKmsKeysResponse{}
	_body, _err := client.DescribeKmsKeysWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeNASFileSystemsWithOptions(request *DescribeNASFileSystemsRequest, runtime *util.RuntimeOptions) (_result *DescribeNASFileSystemsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FileSystemId)) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !tea.BoolValue(util.IsUnset(request.MatchCompatibleProfile)) {
		query["MatchCompatibleProfile"] = request.MatchCompatibleProfile
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeNASFileSystems"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeNASFileSystemsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeNASFileSystems(request *DescribeNASFileSystemsRequest) (_result *DescribeNASFileSystemsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeNASFileSystemsResponse{}
	_body, _err := client.DescribeNASFileSystemsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeNetworkPackagesWithOptions(request *DescribeNetworkPackagesRequest, runtime *util.RuntimeOptions) (_result *DescribeNetworkPackagesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InternetChargeType)) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkPackageId)) {
		query["NetworkPackageId"] = request.NetworkPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeNetworkPackages"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeNetworkPackagesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeNetworkPackages(request *DescribeNetworkPackagesRequest) (_result *DescribeNetworkPackagesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeNetworkPackagesResponse{}
	_body, _err := client.DescribeNetworkPackagesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeOfficeSitesWithOptions(request *DescribeOfficeSitesRequest, runtime *util.RuntimeOptions) (_result *DescribeOfficeSitesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteType)) {
		query["OfficeSiteType"] = request.OfficeSiteType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeOfficeSites"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeOfficeSitesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeOfficeSites(request *DescribeOfficeSitesRequest) (_result *DescribeOfficeSitesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeOfficeSitesResponse{}
	_body, _err := client.DescribeOfficeSitesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePolicyGroupsWithOptions(request *DescribePolicyGroupsRequest, runtime *util.RuntimeOptions) (_result *DescribePolicyGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyGroupId)) {
		query["PolicyGroupId"] = request.PolicyGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Scope)) {
		query["Scope"] = request.Scope
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePolicyGroups"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePolicyGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePolicyGroups(request *DescribePolicyGroupsRequest) (_result *DescribePolicyGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePolicyGroupsResponse{}
	_body, _err := client.DescribePolicyGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Usage notes
 * The request parameters vary based on the type of desktop resources whose price you want to query. Take note of the following items:
 * *   If you set ResourceType to OfficeSite, you must specify InstanceType.
 * *   If you set ResourceType to Bandwidth, the pay-by-data-transfer metering method is used for network billing.
 * *   If you set ResourceType to Desktop, you must specify InstanceType, RootDiskSizeGib, and UserDiskSizeGib. You can specify OsType, PeriodUnit, Period, and Amount based on your business requirements.
 * > Before you call this operation to query the prices of cloud desktops by setting ResourceType to Desktop, you must know the desktop types and disk sizes that EDS provides. The disk sizes vary based on the desktop types. For more information, see [Cloud desktop types](~~188609~~).
 *
 * @param request DescribePriceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePriceResponse
 */
func (client *Client) DescribePriceWithOptions(request *DescribePriceRequest, runtime *util.RuntimeOptions) (_result *DescribePriceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Amount)) {
		query["Amount"] = request.Amount
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.BundleModels)) {
		query["BundleModels"] = request.BundleModels
	}

	if !tea.BoolValue(util.IsUnset(request.EduCdsEnable)) {
		query["EduCdsEnable"] = request.EduCdsEnable
	}

	if !tea.BoolValue(util.IsUnset(request.EduCdsSize)) {
		query["EduCdsSize"] = request.EduCdsSize
	}

	if !tea.BoolValue(util.IsUnset(request.EduCommittedTime)) {
		query["EduCommittedTime"] = request.EduCommittedTime
	}

	if !tea.BoolValue(util.IsUnset(request.EduDesktopBundleId)) {
		query["EduDesktopBundleId"] = request.EduDesktopBundleId
	}

	if !tea.BoolValue(util.IsUnset(request.EduDesktopNum)) {
		query["EduDesktopNum"] = request.EduDesktopNum
	}

	if !tea.BoolValue(util.IsUnset(request.EduRoomClassify)) {
		query["EduRoomClassify"] = request.EduRoomClassify
	}

	if !tea.BoolValue(util.IsUnset(request.EduStudentBundleId)) {
		query["EduStudentBundleId"] = request.EduStudentBundleId
	}

	if !tea.BoolValue(util.IsUnset(request.EduStudentNum)) {
		query["EduStudentNum"] = request.EduStudentNum
	}

	if !tea.BoolValue(util.IsUnset(request.EduTeacherBundleId)) {
		query["EduTeacherBundleId"] = request.EduTeacherBundleId
	}

	if !tea.BoolValue(util.IsUnset(request.EduTeacherNum)) {
		query["EduTeacherNum"] = request.EduTeacherNum
	}

	if !tea.BoolValue(util.IsUnset(request.GroupDesktopCount)) {
		query["GroupDesktopCount"] = request.GroupDesktopCount
	}

	if !tea.BoolValue(util.IsUnset(request.HardwareVersion)) {
		query["HardwareVersion"] = request.HardwareVersion
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.InternetChargeType)) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkType)) {
		query["NetworkType"] = request.NetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.OsType)) {
		query["OsType"] = request.OsType
	}

	if !tea.BoolValue(util.IsUnset(request.PackageSize)) {
		query["PackageSize"] = request.PackageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.PeriodUnit)) {
		query["PeriodUnit"] = request.PeriodUnit
	}

	if !tea.BoolValue(util.IsUnset(request.PromotionId)) {
		query["PromotionId"] = request.PromotionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.RootDiskPerformanceLevel)) {
		query["RootDiskPerformanceLevel"] = request.RootDiskPerformanceLevel
	}

	if !tea.BoolValue(util.IsUnset(request.RootDiskSizeGib)) {
		query["RootDiskSizeGib"] = request.RootDiskSizeGib
	}

	if !tea.BoolValue(util.IsUnset(request.SpPeriodInfo)) {
		query["SpPeriodInfo"] = request.SpPeriodInfo
	}

	if !tea.BoolValue(util.IsUnset(request.SpPrice)) {
		query["SpPrice"] = request.SpPrice
	}

	if !tea.BoolValue(util.IsUnset(request.SpType)) {
		query["SpType"] = request.SpType
	}

	if !tea.BoolValue(util.IsUnset(request.UserDiskPerformanceLevel)) {
		query["UserDiskPerformanceLevel"] = request.UserDiskPerformanceLevel
	}

	if !tea.BoolValue(util.IsUnset(request.UserDiskSizeGib)) {
		query["UserDiskSizeGib"] = request.UserDiskSizeGib
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePrice"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePriceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Usage notes
 * The request parameters vary based on the type of desktop resources whose price you want to query. Take note of the following items:
 * *   If you set ResourceType to OfficeSite, you must specify InstanceType.
 * *   If you set ResourceType to Bandwidth, the pay-by-data-transfer metering method is used for network billing.
 * *   If you set ResourceType to Desktop, you must specify InstanceType, RootDiskSizeGib, and UserDiskSizeGib. You can specify OsType, PeriodUnit, Period, and Amount based on your business requirements.
 * > Before you call this operation to query the prices of cloud desktops by setting ResourceType to Desktop, you must know the desktop types and disk sizes that EDS provides. The disk sizes vary based on the desktop types. For more information, see [Cloud desktop types](~~188609~~).
 *
 * @param request DescribePriceRequest
 * @return DescribePriceResponse
 */
func (client *Client) DescribePrice(request *DescribePriceRequest) (_result *DescribePriceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePriceResponse{}
	_body, _err := client.DescribePriceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePriceForCreateDesktopOversoldGroupWithOptions(request *DescribePriceForCreateDesktopOversoldGroupRequest, runtime *util.RuntimeOptions) (_result *DescribePriceForCreateDesktopOversoldGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConcurrenceCount)) {
		query["ConcurrenceCount"] = request.ConcurrenceCount
	}

	if !tea.BoolValue(util.IsUnset(request.DataDiskSize)) {
		query["DataDiskSize"] = request.DataDiskSize
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopType)) {
		query["DesktopType"] = request.DesktopType
	}

	if !tea.BoolValue(util.IsUnset(request.OversoldUserCount)) {
		query["OversoldUserCount"] = request.OversoldUserCount
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.PeriodUnit)) {
		query["PeriodUnit"] = request.PeriodUnit
	}

	if !tea.BoolValue(util.IsUnset(request.SystemDiskSize)) {
		query["SystemDiskSize"] = request.SystemDiskSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePriceForCreateDesktopOversoldGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePriceForCreateDesktopOversoldGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePriceForCreateDesktopOversoldGroup(request *DescribePriceForCreateDesktopOversoldGroupRequest) (_result *DescribePriceForCreateDesktopOversoldGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePriceForCreateDesktopOversoldGroupResponse{}
	_body, _err := client.DescribePriceForCreateDesktopOversoldGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePriceForModifyDesktopOversoldGroupSaleWithOptions(request *DescribePriceForModifyDesktopOversoldGroupSaleRequest, runtime *util.RuntimeOptions) (_result *DescribePriceForModifyDesktopOversoldGroupSaleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConcurrenceCount)) {
		query["ConcurrenceCount"] = request.ConcurrenceCount
	}

	if !tea.BoolValue(util.IsUnset(request.OversoldGroupId)) {
		query["OversoldGroupId"] = request.OversoldGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.OversoldUserCount)) {
		query["OversoldUserCount"] = request.OversoldUserCount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePriceForModifyDesktopOversoldGroupSale"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePriceForModifyDesktopOversoldGroupSaleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePriceForModifyDesktopOversoldGroupSale(request *DescribePriceForModifyDesktopOversoldGroupSaleRequest) (_result *DescribePriceForModifyDesktopOversoldGroupSaleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePriceForModifyDesktopOversoldGroupSaleResponse{}
	_body, _err := client.DescribePriceForModifyDesktopOversoldGroupSaleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePriceForRenewDesktopOversoldGroupWithOptions(request *DescribePriceForRenewDesktopOversoldGroupRequest, runtime *util.RuntimeOptions) (_result *DescribePriceForRenewDesktopOversoldGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OversoldGroupId)) {
		query["OversoldGroupId"] = request.OversoldGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.PeriodUnit)) {
		query["PeriodUnit"] = request.PeriodUnit
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePriceForRenewDesktopOversoldGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePriceForRenewDesktopOversoldGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePriceForRenewDesktopOversoldGroup(request *DescribePriceForRenewDesktopOversoldGroupRequest) (_result *DescribePriceForRenewDesktopOversoldGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePriceForRenewDesktopOversoldGroupResponse{}
	_body, _err := client.DescribePriceForRenewDesktopOversoldGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeRegionsWithOptions(request *DescribeRegionsRequest, runtime *util.RuntimeOptions) (_result *DescribeRegionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRegions"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRegionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeRegions(request *DescribeRegionsRequest) (_result *DescribeRegionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRegionsResponse{}
	_body, _err := client.DescribeRegionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   This is a central operation and can be called only by using services in the China (Shanghai) region.
 * *   You can query session statistics for the past hour.
 *
 * @param request DescribeSessionStatisticRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSessionStatisticResponse
 */
func (client *Client) DescribeSessionStatisticWithOptions(request *DescribeSessionStatisticRequest, runtime *util.RuntimeOptions) (_result *DescribeSessionStatisticResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SearchRegionId)) {
		query["SearchRegionId"] = request.SearchRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSessionStatistic"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSessionStatisticResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   This is a central operation and can be called only by using services in the China (Shanghai) region.
 * *   You can query session statistics for the past hour.
 *
 * @param request DescribeSessionStatisticRequest
 * @return DescribeSessionStatisticResponse
 */
func (client *Client) DescribeSessionStatistic(request *DescribeSessionStatisticRequest) (_result *DescribeSessionStatisticResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSessionStatisticResponse{}
	_body, _err := client.DescribeSessionStatisticWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeSnapshotsWithOptions(request *DescribeSnapshotsRequest, runtime *util.RuntimeOptions) (_result *DescribeSnapshotsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Creator)) {
		query["Creator"] = request.Creator
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopName)) {
		query["DesktopName"] = request.DesktopName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SnapshotId)) {
		query["SnapshotId"] = request.SnapshotId
	}

	if !tea.BoolValue(util.IsUnset(request.SnapshotName)) {
		query["SnapshotName"] = request.SnapshotName
	}

	if !tea.BoolValue(util.IsUnset(request.SnapshotType)) {
		query["SnapshotType"] = request.SnapshotType
	}

	if !tea.BoolValue(util.IsUnset(request.SourceDiskType)) {
		query["SourceDiskType"] = request.SourceDiskType
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSnapshots"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSnapshotsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeSnapshots(request *DescribeSnapshotsRequest) (_result *DescribeSnapshotsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSnapshotsResponse{}
	_body, _err := client.DescribeSnapshotsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeUserConnectTimeWithOptions(request *DescribeUserConnectTimeRequest, runtime *util.RuntimeOptions) (_result *DescribeUserConnectTimeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OversoldGroupId)) {
		query["OversoldGroupId"] = request.OversoldGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.UserDesktopId)) {
		query["UserDesktopId"] = request.UserDesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.UserGroupId)) {
		query["UserGroupId"] = request.UserGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeUserConnectTime"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeUserConnectTimeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeUserConnectTime(request *DescribeUserConnectTimeRequest) (_result *DescribeUserConnectTimeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeUserConnectTimeResponse{}
	_body, _err := client.DescribeUserConnectTimeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeUserConnectionRecordsWithOptions(request *DescribeUserConnectionRecordsRequest, runtime *util.RuntimeOptions) (_result *DescribeUserConnectionRecordsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConnectDurationFrom)) {
		query["ConnectDurationFrom"] = request.ConnectDurationFrom
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectDurationTo)) {
		query["ConnectDurationTo"] = request.ConnectDurationTo
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectEndTimeFrom)) {
		query["ConnectEndTimeFrom"] = request.ConnectEndTimeFrom
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectEndTimeTo)) {
		query["ConnectEndTimeTo"] = request.ConnectEndTimeTo
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectStartTimeFrom)) {
		query["ConnectStartTimeFrom"] = request.ConnectStartTimeFrom
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectStartTimeTo)) {
		query["ConnectStartTimeTo"] = request.ConnectStartTimeTo
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopGroupId)) {
		query["DesktopGroupId"] = request.DesktopGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserType)) {
		query["EndUserType"] = request.EndUserType
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeUserConnectionRecords"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeUserConnectionRecordsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeUserConnectionRecords(request *DescribeUserConnectionRecordsRequest) (_result *DescribeUserConnectionRecordsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeUserConnectionRecordsResponse{}
	_body, _err := client.DescribeUserConnectionRecordsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeUserProfilePathRulesWithOptions(request *DescribeUserProfilePathRulesRequest, runtime *util.RuntimeOptions) (_result *DescribeUserProfilePathRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopGroupId)) {
		query["DesktopGroupId"] = request.DesktopGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleType)) {
		query["RuleType"] = request.RuleType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeUserProfilePathRules"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeUserProfilePathRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeUserProfilePathRules(request *DescribeUserProfilePathRulesRequest) (_result *DescribeUserProfilePathRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeUserProfilePathRulesResponse{}
	_body, _err := client.DescribeUserProfilePathRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeUsersInGroupWithOptions(request *DescribeUsersInGroupRequest, runtime *util.RuntimeOptions) (_result *DescribeUsersInGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConnectState)) {
		query["ConnectState"] = request.ConnectState
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopGroupId)) {
		query["DesktopGroupId"] = request.DesktopGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserIds)) {
		query["EndUserIds"] = request.EndUserIds
	}

	if !tea.BoolValue(util.IsUnset(request.Filter)) {
		query["Filter"] = request.Filter
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OrgId)) {
		query["OrgId"] = request.OrgId
	}

	if !tea.BoolValue(util.IsUnset(request.QueryUserDetail)) {
		query["QueryUserDetail"] = request.QueryUserDetail
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeUsersInGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeUsersInGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeUsersInGroup(request *DescribeUsersInGroupRequest) (_result *DescribeUsersInGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeUsersInGroupResponse{}
	_body, _err := client.DescribeUsersInGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeUsersPasswordWithOptions(request *DescribeUsersPasswordRequest, runtime *util.RuntimeOptions) (_result *DescribeUsersPasswordResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeUsersPassword"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeUsersPasswordResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeUsersPassword(request *DescribeUsersPasswordRequest) (_result *DescribeUsersPasswordResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeUsersPasswordResponse{}
	_body, _err := client.DescribeUsersPasswordWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVirtualMFADevicesWithOptions(request *DescribeVirtualMFADevicesRequest, runtime *util.RuntimeOptions) (_result *DescribeVirtualMFADevicesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVirtualMFADevices"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVirtualMFADevicesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVirtualMFADevices(request *DescribeVirtualMFADevicesRequest) (_result *DescribeVirtualMFADevicesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVirtualMFADevicesResponse{}
	_body, _err := client.DescribeVirtualMFADevicesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeZonesWithOptions(request *DescribeZonesRequest, runtime *util.RuntimeOptions) (_result *DescribeZonesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneType)) {
		query["ZoneType"] = request.ZoneType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeZones"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeZonesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeZones(request *DescribeZonesRequest) (_result *DescribeZonesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeZonesResponse{}
	_body, _err := client.DescribeZonesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DetachCenWithOptions(request *DetachCenRequest, runtime *util.RuntimeOptions) (_result *DetachCenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachCen"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachCenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DetachCen(request *DetachCenRequest) (_result *DetachCenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachCenResponse{}
	_body, _err := client.DetachCenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DetachEndUserWithOptions(request *DetachEndUserRequest, runtime *util.RuntimeOptions) (_result *DetachEndUserResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AdDomain)) {
		query["AdDomain"] = request.AdDomain
	}

	if !tea.BoolValue(util.IsUnset(request.ClientType)) {
		query["ClientType"] = request.ClientType
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceId)) {
		query["DeviceId"] = request.DeviceId
	}

	if !tea.BoolValue(util.IsUnset(request.DirectoryId)) {
		query["DirectoryId"] = request.DirectoryId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachEndUser"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachEndUserResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DetachEndUser(request *DetachEndUserRequest) (_result *DetachEndUserResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachEndUserResponse{}
	_body, _err := client.DetachEndUserWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DisableDesktopsInGroupWithOptions(request *DisableDesktopsInGroupRequest, runtime *util.RuntimeOptions) (_result *DisableDesktopsInGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopGroupId)) {
		query["DesktopGroupId"] = request.DesktopGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopIds)) {
		query["DesktopIds"] = request.DesktopIds
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DisableDesktopsInGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DisableDesktopsInGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DisableDesktopsInGroup(request *DisableDesktopsInGroupRequest) (_result *DisableDesktopsInGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DisableDesktopsInGroupResponse{}
	_body, _err := client.DisableDesktopsInGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DissociateNetworkPackageWithOptions(request *DissociateNetworkPackageRequest, runtime *util.RuntimeOptions) (_result *DissociateNetworkPackageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NetworkPackageId)) {
		query["NetworkPackageId"] = request.NetworkPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DissociateNetworkPackage"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DissociateNetworkPackageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DissociateNetworkPackage(request *DissociateNetworkPackageRequest) (_result *DissociateNetworkPackageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DissociateNetworkPackageResponse{}
	_body, _err := client.DissociateNetworkPackageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ExportClientEventsWithOptions(request *ExportClientEventsRequest, runtime *util.RuntimeOptions) (_result *ExportClientEventsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopName)) {
		query["DesktopName"] = request.DesktopName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.EventType)) {
		query["EventType"] = request.EventType
	}

	if !tea.BoolValue(util.IsUnset(request.EventTypes)) {
		query["EventTypes"] = request.EventTypes
	}

	if !tea.BoolValue(util.IsUnset(request.LangType)) {
		query["LangType"] = request.LangType
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteName)) {
		query["OfficeSiteName"] = request.OfficeSiteName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ExportClientEvents"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ExportClientEventsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ExportClientEvents(request *ExportClientEventsRequest) (_result *ExportClientEventsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ExportClientEventsResponse{}
	_body, _err := client.ExportClientEventsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ExportDesktopGroupInfoWithOptions(request *ExportDesktopGroupInfoRequest, runtime *util.RuntimeOptions) (_result *ExportDesktopGroupInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ChargeType)) {
		query["ChargeType"] = request.ChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopGroupId)) {
		query["DesktopGroupId"] = request.DesktopGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopGroupName)) {
		query["DesktopGroupName"] = request.DesktopGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.ExpiredTime)) {
		query["ExpiredTime"] = request.ExpiredTime
	}

	if !tea.BoolValue(util.IsUnset(request.LangType)) {
		query["LangType"] = request.LangType
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyGroupId)) {
		query["PolicyGroupId"] = request.PolicyGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ExportDesktopGroupInfo"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ExportDesktopGroupInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ExportDesktopGroupInfo(request *ExportDesktopGroupInfoRequest) (_result *ExportDesktopGroupInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ExportDesktopGroupInfoResponse{}
	_body, _err := client.ExportDesktopGroupInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The list of cloud desktops that are exported by calling the ExportDesktopListInfo operation is saved in a CSV file. The CSV file contains the information about each cloud desktop, including the IDs and names of cloud desktops, IDs and names of workspaces, IDs and names of desktop groups, vCPUs, memory, protocols, system disk capacity, data disk capacity, OSs, running status, current user, tags, IP addresses, billing methods, and creation time.
 *
 * @param request ExportDesktopListInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExportDesktopListInfoResponse
 */
func (client *Client) ExportDesktopListInfoWithOptions(request *ExportDesktopListInfoRequest, runtime *util.RuntimeOptions) (_result *ExportDesktopListInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ChargeType)) {
		query["ChargeType"] = request.ChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopName)) {
		query["DesktopName"] = request.DesktopName
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopStatus)) {
		query["DesktopStatus"] = request.DesktopStatus
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.ExpiredTime)) {
		query["ExpiredTime"] = request.ExpiredTime
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.LangType)) {
		query["LangType"] = request.LangType
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyGroupId)) {
		query["PolicyGroupId"] = request.PolicyGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.UserName)) {
		query["UserName"] = request.UserName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ExportDesktopListInfo"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ExportDesktopListInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The list of cloud desktops that are exported by calling the ExportDesktopListInfo operation is saved in a CSV file. The CSV file contains the information about each cloud desktop, including the IDs and names of cloud desktops, IDs and names of workspaces, IDs and names of desktop groups, vCPUs, memory, protocols, system disk capacity, data disk capacity, OSs, running status, current user, tags, IP addresses, billing methods, and creation time.
 *
 * @param request ExportDesktopListInfoRequest
 * @return ExportDesktopListInfoResponse
 */
func (client *Client) ExportDesktopListInfo(request *ExportDesktopListInfoRequest) (_result *ExportDesktopListInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ExportDesktopListInfoResponse{}
	_body, _err := client.ExportDesktopListInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetAsyncTaskWithOptions(request *GetAsyncTaskRequest, runtime *util.RuntimeOptions) (_result *GetAsyncTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AsyncTaskId)) {
		query["AsyncTaskId"] = request.AsyncTaskId
	}

	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAsyncTask"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAsyncTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetAsyncTask(request *GetAsyncTaskRequest) (_result *GetAsyncTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAsyncTaskResponse{}
	_body, _err := client.GetAsyncTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetConnectionTicketWithOptions(request *GetConnectionTicketRequest, runtime *util.RuntimeOptions) (_result *GetConnectionTicketResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CommandContent)) {
		query["CommandContent"] = request.CommandContent
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Password)) {
		query["Password"] = request.Password
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	if !tea.BoolValue(util.IsUnset(request.Uuid)) {
		query["Uuid"] = request.Uuid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetConnectionTicket"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetConnectionTicketResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetConnectionTicket(request *GetConnectionTicketRequest) (_result *GetConnectionTicketResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetConnectionTicketResponse{}
	_body, _err := client.GetConnectionTicketWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetCoordinateTicketWithOptions(request *GetCoordinateTicketRequest, runtime *util.RuntimeOptions) (_result *GetCoordinateTicketResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CoId)) {
		query["CoId"] = request.CoId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	if !tea.BoolValue(util.IsUnset(request.UserType)) {
		query["UserType"] = request.UserType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetCoordinateTicket"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetCoordinateTicketResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetCoordinateTicket(request *GetCoordinateTicketRequest) (_result *GetCoordinateTicketResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetCoordinateTicketResponse{}
	_body, _err := client.GetCoordinateTicketWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDesktopGroupDetailWithOptions(request *GetDesktopGroupDetailRequest, runtime *util.RuntimeOptions) (_result *GetDesktopGroupDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopGroupId)) {
		query["DesktopGroupId"] = request.DesktopGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDesktopGroupDetail"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDesktopGroupDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDesktopGroupDetail(request *GetDesktopGroupDetailRequest) (_result *GetDesktopGroupDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDesktopGroupDetailResponse{}
	_body, _err := client.GetDesktopGroupDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetOfficeSiteSsoStatusWithOptions(request *GetOfficeSiteSsoStatusRequest, runtime *util.RuntimeOptions) (_result *GetOfficeSiteSsoStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetOfficeSiteSsoStatus"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetOfficeSiteSsoStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetOfficeSiteSsoStatus(request *GetOfficeSiteSsoStatusRequest) (_result *GetOfficeSiteSsoStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetOfficeSiteSsoStatusResponse{}
	_body, _err := client.GetOfficeSiteSsoStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation only for workspaces of the Active Directory (AD) and convenience account types.
 *
 * @param request GetSpMetadataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSpMetadataResponse
 */
func (client *Client) GetSpMetadataWithOptions(request *GetSpMetadataRequest, runtime *util.RuntimeOptions) (_result *GetSpMetadataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DirectoryId)) {
		query["DirectoryId"] = request.DirectoryId
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetSpMetadata"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetSpMetadataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation only for workspaces of the Active Directory (AD) and convenience account types.
 *
 * @param request GetSpMetadataRequest
 * @return GetSpMetadataResponse
 */
func (client *Client) GetSpMetadata(request *GetSpMetadataRequest) (_result *GetSpMetadataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetSpMetadataResponse{}
	_body, _err := client.GetSpMetadataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Hibernating a cloud desktop is in private preview. If you want to try this feature, submit a ticket.
 *
 * @param request HibernateDesktopsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return HibernateDesktopsResponse
 */
func (client *Client) HibernateDesktopsWithOptions(request *HibernateDesktopsRequest, runtime *util.RuntimeOptions) (_result *HibernateDesktopsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("HibernateDesktops"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &HibernateDesktopsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Hibernating a cloud desktop is in private preview. If you want to try this feature, submit a ticket.
 *
 * @param request HibernateDesktopsRequest
 * @return HibernateDesktopsResponse
 */
func (client *Client) HibernateDesktops(request *HibernateDesktopsRequest) (_result *HibernateDesktopsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &HibernateDesktopsResponse{}
	_body, _err := client.HibernateDesktopsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListCdsFilesWithOptions(tmpReq *ListCdsFilesRequest, runtime *util.RuntimeOptions) (_result *ListCdsFilesResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ListCdsFilesShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.FileIds)) {
		request.FileIdsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.FileIds, tea.String("FileIds"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.FileIdsShrink)) {
		query["FileIds"] = request.FileIdsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OrderType)) {
		query["OrderType"] = request.OrderType
	}

	if !tea.BoolValue(util.IsUnset(request.ParentFileId)) {
		query["ParentFileId"] = request.ParentFileId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListCdsFiles"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListCdsFilesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListCdsFiles(request *ListCdsFilesRequest) (_result *ListCdsFilesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListCdsFilesResponse{}
	_body, _err := client.ListCdsFilesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If you use an AD directory to connect to an AD system, you can call this operation to obtain the user information in the AD system.
 *
 * @param request ListDirectoryUsersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDirectoryUsersResponse
 */
func (client *Client) ListDirectoryUsersWithOptions(request *ListDirectoryUsersRequest, runtime *util.RuntimeOptions) (_result *ListDirectoryUsersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DirectoryId)) {
		query["DirectoryId"] = request.DirectoryId
	}

	if !tea.BoolValue(util.IsUnset(request.Filter)) {
		query["Filter"] = request.Filter
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OUPath)) {
		query["OUPath"] = request.OUPath
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDirectoryUsers"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDirectoryUsersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If you use an AD directory to connect to an AD system, you can call this operation to obtain the user information in the AD system.
 *
 * @param request ListDirectoryUsersRequest
 * @return ListDirectoryUsersResponse
 */
func (client *Client) ListDirectoryUsers(request *ListDirectoryUsersRequest) (_result *ListDirectoryUsersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDirectoryUsersResponse{}
	_body, _err := client.ListDirectoryUsersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListFilePermissionWithOptions(request *ListFilePermissionRequest, runtime *util.RuntimeOptions) (_result *ListFilePermissionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		query["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListFilePermission"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListFilePermissionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListFilePermission(request *ListFilePermissionRequest) (_result *ListFilePermissionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListFilePermissionResponse{}
	_body, _err := client.ListFilePermissionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListOfficeSiteOverviewWithOptions(request *ListOfficeSiteOverviewRequest, runtime *util.RuntimeOptions) (_result *ListOfficeSiteOverviewResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ForceRefresh)) {
		query["ForceRefresh"] = request.ForceRefresh
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.QueryRange)) {
		query["QueryRange"] = request.QueryRange
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListOfficeSiteOverview"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListOfficeSiteOverviewResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListOfficeSiteOverview(request *ListOfficeSiteOverviewRequest) (_result *ListOfficeSiteOverviewResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListOfficeSiteOverviewResponse{}
	_body, _err := client.ListOfficeSiteOverviewWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListOfficeSiteUsersWithOptions(request *ListOfficeSiteUsersRequest, runtime *util.RuntimeOptions) (_result *ListOfficeSiteUsersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Filter)) {
		query["Filter"] = request.Filter
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OUPath)) {
		query["OUPath"] = request.OUPath
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListOfficeSiteUsers"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListOfficeSiteUsersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListOfficeSiteUsers(request *ListOfficeSiteUsersRequest) (_result *ListOfficeSiteUsersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListOfficeSiteUsersResponse{}
	_body, _err := client.ListOfficeSiteUsersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You must specify at least one of the ResourceId.N, Tag.N.Key, and Tag.N.Value parameters in the request to specify the query objects.
 *
 * @param request ListTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesResponse
 */
func (client *Client) ListTagResourcesWithOptions(request *ListTagResourcesRequest, runtime *util.RuntimeOptions) (_result *ListTagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTagResources"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You must specify at least one of the ResourceId.N, Tag.N.Key, and Tag.N.Value parameters in the request to specify the query objects.
 *
 * @param request ListTagResourcesRequest
 * @return ListTagResourcesResponse
 */
func (client *Client) ListTagResources(request *ListTagResourcesRequest) (_result *ListTagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.ListTagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListUserAdOrganizationUnitsWithOptions(request *ListUserAdOrganizationUnitsRequest, runtime *util.RuntimeOptions) (_result *ListUserAdOrganizationUnitsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Filter)) {
		query["Filter"] = request.Filter
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListUserAdOrganizationUnits"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListUserAdOrganizationUnitsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListUserAdOrganizationUnits(request *ListUserAdOrganizationUnitsRequest) (_result *ListUserAdOrganizationUnitsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListUserAdOrganizationUnitsResponse{}
	_body, _err := client.ListUserAdOrganizationUnitsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After a virtual MFA device is locked, its status changes to LOCKED. The AD user who uses the virtual MFA device is unable to pass MFA and is therefore unable to log on to the client. You can call the [UnlockVirtualMFADevice](~~206212~~) operation to unlock the device.
 *
 * @param request LockVirtualMFADeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return LockVirtualMFADeviceResponse
 */
func (client *Client) LockVirtualMFADeviceWithOptions(request *LockVirtualMFADeviceRequest, runtime *util.RuntimeOptions) (_result *LockVirtualMFADeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SerialNumber)) {
		query["SerialNumber"] = request.SerialNumber
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("LockVirtualMFADevice"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &LockVirtualMFADeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After a virtual MFA device is locked, its status changes to LOCKED. The AD user who uses the virtual MFA device is unable to pass MFA and is therefore unable to log on to the client. You can call the [UnlockVirtualMFADevice](~~206212~~) operation to unlock the device.
 *
 * @param request LockVirtualMFADeviceRequest
 * @return LockVirtualMFADeviceResponse
 */
func (client *Client) LockVirtualMFADevice(request *LockVirtualMFADeviceRequest) (_result *LockVirtualMFADeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &LockVirtualMFADeviceResponse{}
	_body, _err := client.LockVirtualMFADeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) MigrateDesktopsWithOptions(request *MigrateDesktopsRequest, runtime *util.RuntimeOptions) (_result *MigrateDesktopsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetOfficeSiteId)) {
		query["TargetOfficeSiteId"] = request.TargetOfficeSiteId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("MigrateDesktops"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &MigrateDesktopsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) MigrateDesktops(request *MigrateDesktopsRequest) (_result *MigrateDesktopsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &MigrateDesktopsResponse{}
	_body, _err := client.MigrateDesktopsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) MigrateImageProtocolWithOptions(request *MigrateImageProtocolRequest, runtime *util.RuntimeOptions) (_result *MigrateImageProtocolResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetProtocolType)) {
		query["TargetProtocolType"] = request.TargetProtocolType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("MigrateImageProtocol"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &MigrateImageProtocolResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) MigrateImageProtocol(request *MigrateImageProtocolRequest) (_result *MigrateImageProtocolResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &MigrateImageProtocolResponse{}
	_body, _err := client.MigrateImageProtocolWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyADConnectorDirectoryWithOptions(request *ModifyADConnectorDirectoryRequest, runtime *util.RuntimeOptions) (_result *ModifyADConnectorDirectoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AdHostname)) {
		query["AdHostname"] = request.AdHostname
	}

	if !tea.BoolValue(util.IsUnset(request.DirectoryId)) {
		query["DirectoryId"] = request.DirectoryId
	}

	if !tea.BoolValue(util.IsUnset(request.DirectoryName)) {
		query["DirectoryName"] = request.DirectoryName
	}

	if !tea.BoolValue(util.IsUnset(request.DnsAddress)) {
		query["DnsAddress"] = request.DnsAddress
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.DomainPassword)) {
		query["DomainPassword"] = request.DomainPassword
	}

	if !tea.BoolValue(util.IsUnset(request.DomainUserName)) {
		query["DomainUserName"] = request.DomainUserName
	}

	if !tea.BoolValue(util.IsUnset(request.MfaEnabled)) {
		query["MfaEnabled"] = request.MfaEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.OUName)) {
		query["OUName"] = request.OUName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SubDomainDnsAddress)) {
		query["SubDomainDnsAddress"] = request.SubDomainDnsAddress
	}

	if !tea.BoolValue(util.IsUnset(request.SubDomainName)) {
		query["SubDomainName"] = request.SubDomainName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyADConnectorDirectory"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyADConnectorDirectoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyADConnectorDirectory(request *ModifyADConnectorDirectoryRequest) (_result *ModifyADConnectorDirectoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyADConnectorDirectoryResponse{}
	_body, _err := client.ModifyADConnectorDirectoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyADConnectorOfficeSiteWithOptions(request *ModifyADConnectorOfficeSiteRequest, runtime *util.RuntimeOptions) (_result *ModifyADConnectorOfficeSiteResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AdHostname)) {
		query["AdHostname"] = request.AdHostname
	}

	if !tea.BoolValue(util.IsUnset(request.DnsAddress)) {
		query["DnsAddress"] = request.DnsAddress
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.DomainPassword)) {
		query["DomainPassword"] = request.DomainPassword
	}

	if !tea.BoolValue(util.IsUnset(request.DomainUserName)) {
		query["DomainUserName"] = request.DomainUserName
	}

	if !tea.BoolValue(util.IsUnset(request.MfaEnabled)) {
		query["MfaEnabled"] = request.MfaEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.OUName)) {
		query["OUName"] = request.OUName
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteName)) {
		query["OfficeSiteName"] = request.OfficeSiteName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SubDomainDnsAddress)) {
		query["SubDomainDnsAddress"] = request.SubDomainDnsAddress
	}

	if !tea.BoolValue(util.IsUnset(request.SubDomainName)) {
		query["SubDomainName"] = request.SubDomainName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyADConnectorOfficeSite"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyADConnectorOfficeSiteResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyADConnectorOfficeSite(request *ModifyADConnectorOfficeSiteRequest) (_result *ModifyADConnectorOfficeSiteResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyADConnectorOfficeSiteResponse{}
	_body, _err := client.ModifyADConnectorOfficeSiteWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyAclEntriesWithOptions(request *ModifyAclEntriesRequest, runtime *util.RuntimeOptions) (_result *ModifyAclEntriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Policy)) {
		query["Policy"] = request.Policy
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceId)) {
		query["SourceId"] = request.SourceId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceType)) {
		query["SourceType"] = request.SourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyAclEntries"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyAclEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyAclEntries(request *ModifyAclEntriesRequest) (_result *ModifyAclEntriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyAclEntriesResponse{}
	_body, _err := client.ModifyAclEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyAutoSnapshotPolicyWithOptions(request *ModifyAutoSnapshotPolicyRequest, runtime *util.RuntimeOptions) (_result *ModifyAutoSnapshotPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CronExpression)) {
		query["CronExpression"] = request.CronExpression
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyId)) {
		query["PolicyId"] = request.PolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyName)) {
		query["PolicyName"] = request.PolicyName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RetentionDays)) {
		query["RetentionDays"] = request.RetentionDays
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyAutoSnapshotPolicy"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyAutoSnapshotPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyAutoSnapshotPolicy(request *ModifyAutoSnapshotPolicyRequest) (_result *ModifyAutoSnapshotPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyAutoSnapshotPolicyResponse{}
	_body, _err := client.ModifyAutoSnapshotPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Only custom desktop templates can be modified.
 *
 * @param request ModifyBundleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyBundleResponse
 */
func (client *Client) ModifyBundleWithOptions(request *ModifyBundleRequest, runtime *util.RuntimeOptions) (_result *ModifyBundleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BundleId)) {
		query["BundleId"] = request.BundleId
	}

	if !tea.BoolValue(util.IsUnset(request.BundleName)) {
		query["BundleName"] = request.BundleName
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.Language)) {
		query["Language"] = request.Language
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyBundle"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyBundleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Only custom desktop templates can be modified.
 *
 * @param request ModifyBundleRequest
 * @return ModifyBundleResponse
 */
func (client *Client) ModifyBundle(request *ModifyBundleRequest) (_result *ModifyBundleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyBundleResponse{}
	_body, _err := client.ModifyBundleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyCdsFileWithOptions(request *ModifyCdsFileRequest, runtime *util.RuntimeOptions) (_result *ModifyCdsFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	if !tea.BoolValue(util.IsUnset(request.ConflictPolicy)) {
		query["ConflictPolicy"] = request.ConflictPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		query["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.FileName)) {
		query["FileName"] = request.FileName
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyCdsFile"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyCdsFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyCdsFile(request *ModifyCdsFileRequest) (_result *ModifyCdsFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyCdsFileResponse{}
	_body, _err := client.ModifyCdsFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyCdsFileShareLinkWithOptions(request *ModifyCdsFileShareLinkRequest, runtime *util.RuntimeOptions) (_result *ModifyCdsFileShareLinkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DisableDownload)) {
		query["DisableDownload"] = request.DisableDownload
	}

	if !tea.BoolValue(util.IsUnset(request.DisablePreview)) {
		query["DisablePreview"] = request.DisablePreview
	}

	if !tea.BoolValue(util.IsUnset(request.DisableSave)) {
		query["DisableSave"] = request.DisableSave
	}

	if !tea.BoolValue(util.IsUnset(request.DownloadCount)) {
		query["DownloadCount"] = request.DownloadCount
	}

	if !tea.BoolValue(util.IsUnset(request.DownloadLimit)) {
		query["DownloadLimit"] = request.DownloadLimit
	}

	if !tea.BoolValue(util.IsUnset(request.Expiration)) {
		query["Expiration"] = request.Expiration
	}

	if !tea.BoolValue(util.IsUnset(request.PreviewCount)) {
		query["PreviewCount"] = request.PreviewCount
	}

	if !tea.BoolValue(util.IsUnset(request.PreviewLimit)) {
		query["PreviewLimit"] = request.PreviewLimit
	}

	if !tea.BoolValue(util.IsUnset(request.ReportCount)) {
		query["ReportCount"] = request.ReportCount
	}

	if !tea.BoolValue(util.IsUnset(request.SaveCount)) {
		query["SaveCount"] = request.SaveCount
	}

	if !tea.BoolValue(util.IsUnset(request.SaveLimit)) {
		query["SaveLimit"] = request.SaveLimit
	}

	if !tea.BoolValue(util.IsUnset(request.ShareId)) {
		query["ShareId"] = request.ShareId
	}

	if !tea.BoolValue(util.IsUnset(request.ShareName)) {
		query["ShareName"] = request.ShareName
	}

	if !tea.BoolValue(util.IsUnset(request.SharePwd)) {
		query["SharePwd"] = request.SharePwd
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.VideoPreviewCount)) {
		query["VideoPreviewCount"] = request.VideoPreviewCount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyCdsFileShareLink"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyCdsFileShareLinkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyCdsFileShareLink(request *ModifyCdsFileShareLinkRequest) (_result *ModifyCdsFileShareLinkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyCdsFileShareLinkResponse{}
	_body, _err := client.ModifyCdsFileShareLinkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyCloudDriveGroupsWithOptions(request *ModifyCloudDriveGroupsRequest, runtime *util.RuntimeOptions) (_result *ModifyCloudDriveGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.TotalSize)) {
		query["TotalSize"] = request.TotalSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyCloudDriveGroups"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyCloudDriveGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyCloudDriveGroups(request *ModifyCloudDriveGroupsRequest) (_result *ModifyCloudDriveGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyCloudDriveGroupsResponse{}
	_body, _err := client.ModifyCloudDriveGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyCloudDrivePermissionWithOptions(request *ModifyCloudDrivePermissionRequest, runtime *util.RuntimeOptions) (_result *ModifyCloudDrivePermissionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	if !tea.BoolValue(util.IsUnset(request.DownloadEndUserIds)) {
		query["DownloadEndUserIds"] = request.DownloadEndUserIds
	}

	if !tea.BoolValue(util.IsUnset(request.DownloadUploadEndUserIds)) {
		query["DownloadUploadEndUserIds"] = request.DownloadUploadEndUserIds
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyCloudDrivePermission"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyCloudDrivePermissionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyCloudDrivePermission(request *ModifyCloudDrivePermissionRequest) (_result *ModifyCloudDrivePermissionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyCloudDrivePermissionResponse{}
	_body, _err := client.ModifyCloudDrivePermissionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyCloudDriveUsersWithOptions(request *ModifyCloudDriveUsersRequest, runtime *util.RuntimeOptions) (_result *ModifyCloudDriveUsersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.UserMaxSize)) {
		query["UserMaxSize"] = request.UserMaxSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyCloudDriveUsers"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyCloudDriveUsersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyCloudDriveUsers(request *ModifyCloudDriveUsersRequest) (_result *ModifyCloudDriveUsersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyCloudDriveUsersResponse{}
	_body, _err := client.ModifyCloudDriveUsersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyCustomizedListHeadersWithOptions(request *ModifyCustomizedListHeadersRequest, runtime *util.RuntimeOptions) (_result *ModifyCustomizedListHeadersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Headers)) {
		query["Headers"] = request.Headers
	}

	if !tea.BoolValue(util.IsUnset(request.ListType)) {
		query["ListType"] = request.ListType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyCustomizedListHeaders"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyCustomizedListHeadersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyCustomizedListHeaders(request *ModifyCustomizedListHeadersRequest) (_result *ModifyCustomizedListHeadersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyCustomizedListHeadersResponse{}
	_body, _err := client.ModifyCustomizedListHeadersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   Before you call this operation, make sure that you are familiar with the billing methods of cloud desktops. For more information, see [Billing overview](~~188395~~).
 * *   Before you call this operation, make sure that the cloud desktop that you want to manage is in the Running or Stopped state and no overdue payments of the cloud desktop are generated.
 * *   After the order payment is completed, the system starts to change the billing method of the cloud desktop. During the change, you cannot perform operations, such as starting or stopping the cloud desktop, and changing configurations of the cloud desktop.
 *
 * @param request ModifyDesktopChargeTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDesktopChargeTypeResponse
 */
func (client *Client) ModifyDesktopChargeTypeWithOptions(request *ModifyDesktopChargeTypeRequest, runtime *util.RuntimeOptions) (_result *ModifyDesktopChargeTypeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.ChargeType)) {
		query["ChargeType"] = request.ChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.PeriodUnit)) {
		query["PeriodUnit"] = request.PeriodUnit
	}

	if !tea.BoolValue(util.IsUnset(request.PromotionId)) {
		query["PromotionId"] = request.PromotionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.UseDuration)) {
		query["UseDuration"] = request.UseDuration
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDesktopChargeType"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDesktopChargeTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   Before you call this operation, make sure that you are familiar with the billing methods of cloud desktops. For more information, see [Billing overview](~~188395~~).
 * *   Before you call this operation, make sure that the cloud desktop that you want to manage is in the Running or Stopped state and no overdue payments of the cloud desktop are generated.
 * *   After the order payment is completed, the system starts to change the billing method of the cloud desktop. During the change, you cannot perform operations, such as starting or stopping the cloud desktop, and changing configurations of the cloud desktop.
 *
 * @param request ModifyDesktopChargeTypeRequest
 * @return ModifyDesktopChargeTypeResponse
 */
func (client *Client) ModifyDesktopChargeType(request *ModifyDesktopChargeTypeRequest) (_result *ModifyDesktopChargeTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDesktopChargeTypeResponse{}
	_body, _err := client.ModifyDesktopChargeTypeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After you create a desktop group, the system creates a specific number of cloud desktops based on the scaling policy that you configure for the desktop group and the number of end users who request to connect to the cloud desktops. Cloud desktops in a desktop group are created by using the same desktop template and security policy. You can modify the configurations of the desktop group in different scenarios to manage cloud desktops in a centralized manner.
 * *   By default, a desktop group has the same name as all cloud desktops in the group. You can modify the desktop group name, which is specified by the DesktopGroupName parameter, to distinguish the desktop group from the cloud desktops.
 * *   If the number of vCPUs and memory size of the cloud desktop cannot meet your business requirements in high performance scenarios, you can change the desktop template that is used to create the cloud desktop to a desktop template (OwnBundleId) that has higher specifications.
 * *   If a security policy that is associated with the desktop group cannot meet your requirements on security, you can change the policy to another policy (PolicyGroupId) that provides higher security.
 * *   If the number of cloud desktops in the desktop group is insufficient to meet the business requirements of end users, you can modify the parameter settings in the scaling policy. The parameters include MinDesktopsCount, MaxDesktopsCount, and AllowBufferCount.
 *
 * @param request ModifyDesktopGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDesktopGroupResponse
 */
func (client *Client) ModifyDesktopGroupWithOptions(request *ModifyDesktopGroupRequest, runtime *util.RuntimeOptions) (_result *ModifyDesktopGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AllowAutoSetup)) {
		query["AllowAutoSetup"] = request.AllowAutoSetup
	}

	if !tea.BoolValue(util.IsUnset(request.AllowBufferCount)) {
		query["AllowBufferCount"] = request.AllowBufferCount
	}

	if !tea.BoolValue(util.IsUnset(request.BindAmount)) {
		query["BindAmount"] = request.BindAmount
	}

	if !tea.BoolValue(util.IsUnset(request.BuyDesktopsCount)) {
		query["BuyDesktopsCount"] = request.BuyDesktopsCount
	}

	if !tea.BoolValue(util.IsUnset(request.Classify)) {
		query["Classify"] = request.Classify
	}

	if !tea.BoolValue(util.IsUnset(request.Comments)) {
		query["Comments"] = request.Comments
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectDuration)) {
		query["ConnectDuration"] = request.ConnectDuration
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopGroupId)) {
		query["DesktopGroupId"] = request.DesktopGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopGroupName)) {
		query["DesktopGroupName"] = request.DesktopGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.DisableSessionConfig)) {
		query["DisableSessionConfig"] = request.DisableSessionConfig
	}

	if !tea.BoolValue(util.IsUnset(request.FileSystemId)) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !tea.BoolValue(util.IsUnset(request.IdleDisconnectDuration)) {
		query["IdleDisconnectDuration"] = request.IdleDisconnectDuration
	}

	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.KeepDuration)) {
		query["KeepDuration"] = request.KeepDuration
	}

	if !tea.BoolValue(util.IsUnset(request.LoadPolicy)) {
		query["LoadPolicy"] = request.LoadPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.MaxDesktopsCount)) {
		query["MaxDesktopsCount"] = request.MaxDesktopsCount
	}

	if !tea.BoolValue(util.IsUnset(request.MinDesktopsCount)) {
		query["MinDesktopsCount"] = request.MinDesktopsCount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnBundleId)) {
		query["OwnBundleId"] = request.OwnBundleId
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyGroupId)) {
		query["PolicyGroupId"] = request.PolicyGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyGroupIds)) {
		query["PolicyGroupIds"] = request.PolicyGroupIds
	}

	if !tea.BoolValue(util.IsUnset(request.ProfileFollowSwitch)) {
		query["ProfileFollowSwitch"] = request.ProfileFollowSwitch
	}

	if !tea.BoolValue(util.IsUnset(request.RatioThreshold)) {
		query["RatioThreshold"] = request.RatioThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResetType)) {
		query["ResetType"] = request.ResetType
	}

	if !tea.BoolValue(util.IsUnset(request.ScaleStrategyId)) {
		query["ScaleStrategyId"] = request.ScaleStrategyId
	}

	if !tea.BoolValue(util.IsUnset(request.StopDuration)) {
		query["StopDuration"] = request.StopDuration
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDesktopGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDesktopGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After you create a desktop group, the system creates a specific number of cloud desktops based on the scaling policy that you configure for the desktop group and the number of end users who request to connect to the cloud desktops. Cloud desktops in a desktop group are created by using the same desktop template and security policy. You can modify the configurations of the desktop group in different scenarios to manage cloud desktops in a centralized manner.
 * *   By default, a desktop group has the same name as all cloud desktops in the group. You can modify the desktop group name, which is specified by the DesktopGroupName parameter, to distinguish the desktop group from the cloud desktops.
 * *   If the number of vCPUs and memory size of the cloud desktop cannot meet your business requirements in high performance scenarios, you can change the desktop template that is used to create the cloud desktop to a desktop template (OwnBundleId) that has higher specifications.
 * *   If a security policy that is associated with the desktop group cannot meet your requirements on security, you can change the policy to another policy (PolicyGroupId) that provides higher security.
 * *   If the number of cloud desktops in the desktop group is insufficient to meet the business requirements of end users, you can modify the parameter settings in the scaling policy. The parameters include MinDesktopsCount, MaxDesktopsCount, and AllowBufferCount.
 *
 * @param request ModifyDesktopGroupRequest
 * @return ModifyDesktopGroupResponse
 */
func (client *Client) ModifyDesktopGroup(request *ModifyDesktopGroupRequest) (_result *ModifyDesktopGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDesktopGroupResponse{}
	_body, _err := client.ModifyDesktopGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can only change the hostname of a Windows cloud desktop in the Active Directory (AD) workspace. After the hostname is changed, the cloud desktop is recreated.
 *
 * @param request ModifyDesktopHostNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDesktopHostNameResponse
 */
func (client *Client) ModifyDesktopHostNameWithOptions(request *ModifyDesktopHostNameRequest, runtime *util.RuntimeOptions) (_result *ModifyDesktopHostNameResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.NewHostName)) {
		query["NewHostName"] = request.NewHostName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDesktopHostName"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDesktopHostNameResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can only change the hostname of a Windows cloud desktop in the Active Directory (AD) workspace. After the hostname is changed, the cloud desktop is recreated.
 *
 * @param request ModifyDesktopHostNameRequest
 * @return ModifyDesktopHostNameResponse
 */
func (client *Client) ModifyDesktopHostName(request *ModifyDesktopHostNameRequest) (_result *ModifyDesktopHostNameResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDesktopHostNameResponse{}
	_body, _err := client.ModifyDesktopHostNameWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyDesktopNameWithOptions(request *ModifyDesktopNameRequest, runtime *util.RuntimeOptions) (_result *ModifyDesktopNameResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.NewDesktopName)) {
		query["NewDesktopName"] = request.NewDesktopName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDesktopName"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDesktopNameResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyDesktopName(request *ModifyDesktopNameRequest) (_result *ModifyDesktopNameResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDesktopNameResponse{}
	_body, _err := client.ModifyDesktopNameWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyDesktopOversoldGroupWithOptions(request *ModifyDesktopOversoldGroupRequest, runtime *util.RuntimeOptions) (_result *ModifyDesktopOversoldGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConcurrenceCount)) {
		query["ConcurrenceCount"] = request.ConcurrenceCount
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OversoldGroupId)) {
		query["OversoldGroupId"] = request.OversoldGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.OversoldUserCount)) {
		query["OversoldUserCount"] = request.OversoldUserCount
	}

	if !tea.BoolValue(util.IsUnset(request.OversoldWarn)) {
		query["OversoldWarn"] = request.OversoldWarn
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyGroupId)) {
		query["PolicyGroupId"] = request.PolicyGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StopDuration)) {
		query["StopDuration"] = request.StopDuration
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDesktopOversoldGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDesktopOversoldGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyDesktopOversoldGroup(request *ModifyDesktopOversoldGroupRequest) (_result *ModifyDesktopOversoldGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDesktopOversoldGroupResponse{}
	_body, _err := client.ModifyDesktopOversoldGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyDesktopOversoldGroupSaleWithOptions(request *ModifyDesktopOversoldGroupSaleRequest, runtime *util.RuntimeOptions) (_result *ModifyDesktopOversoldGroupSaleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConcurrenceCount)) {
		query["ConcurrenceCount"] = request.ConcurrenceCount
	}

	if !tea.BoolValue(util.IsUnset(request.OversoldGroupId)) {
		query["OversoldGroupId"] = request.OversoldGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.OversoldUserCount)) {
		query["OversoldUserCount"] = request.OversoldUserCount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDesktopOversoldGroupSale"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDesktopOversoldGroupSaleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyDesktopOversoldGroupSale(request *ModifyDesktopOversoldGroupSaleRequest) (_result *ModifyDesktopOversoldGroupSaleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDesktopOversoldGroupSaleResponse{}
	_body, _err := client.ModifyDesktopOversoldGroupSaleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyDesktopOversoldUserGroupWithOptions(request *ModifyDesktopOversoldUserGroupRequest, runtime *util.RuntimeOptions) (_result *ModifyDesktopOversoldUserGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OversoldGroupId)) {
		query["OversoldGroupId"] = request.OversoldGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyGroupId)) {
		query["PolicyGroupId"] = request.PolicyGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.UserGroupId)) {
		query["UserGroupId"] = request.UserGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDesktopOversoldUserGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDesktopOversoldUserGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyDesktopOversoldUserGroup(request *ModifyDesktopOversoldUserGroupRequest) (_result *ModifyDesktopOversoldUserGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDesktopOversoldUserGroupResponse{}
	_body, _err := client.ModifyDesktopOversoldUserGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to change the configurations, such as the desktop type and disk size, of a cloud desktop.
 * *   Before you call this operation, take note of the cloud desktop types and the disk sizes for each type of cloud desktop that Elastic Desktop Service (EDS) provides. For more information, see [Cloud desktop types](~~188609~~).
 * *   When you change the configurations of a cloud desktop, you must change the desktop type or the size of the system disk or data disk. You must configure at least one of the following parameters: DesktopType, RootDiskSizeGib, and UserDiskSizeGib. You must take note of the following items:
 *     *   Each desktop type contains different desktop specifications, such as vCPUs, memory, and GPUs. When you change the desktop configurations, you can only change the desktop type from one to another. However, you cannot change only one of the specifications, such as vCPUs, memory, and GPUs.
 *     *   You cannot change a cloud desktop from the General Office type to a non-General Office type, or from a non-General Office type to the General Office type. You cannot change a cloud desktop from the Graphics type to a non-Graphics type, or from a non-Graphics type to the Graphics type.
 *     *   You can only increase the sizes of system and data disks.
 *     *   If your cloud desktop uses the subscription billing method, the price difference is calculated based on the price before and after configuration changes. You may receive a refund, or pay for the price difference.
 *     *   If you want to change the configurations of your cloud desktop for multiple times, we recommend that you wait at least 5 minutes the next time you change the configurations of the same cloud desktop.
 *     *   The cloud desktop for which you want to change configurations must be in the Stopped state.
 * *   The changes do not affect your personal data on the cloud desktop.
 *
 * @param request ModifyDesktopSpecRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDesktopSpecResponse
 */
func (client *Client) ModifyDesktopSpecWithOptions(request *ModifyDesktopSpecRequest, runtime *util.RuntimeOptions) (_result *ModifyDesktopSpecResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopType)) {
		query["DesktopType"] = request.DesktopType
	}

	if !tea.BoolValue(util.IsUnset(request.PromotionId)) {
		query["PromotionId"] = request.PromotionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RootDiskSizeGib)) {
		query["RootDiskSizeGib"] = request.RootDiskSizeGib
	}

	if !tea.BoolValue(util.IsUnset(request.UserDiskPerformanceLevel)) {
		query["UserDiskPerformanceLevel"] = request.UserDiskPerformanceLevel
	}

	if !tea.BoolValue(util.IsUnset(request.UserDiskSizeGib)) {
		query["UserDiskSizeGib"] = request.UserDiskSizeGib
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDesktopSpec"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDesktopSpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to change the configurations, such as the desktop type and disk size, of a cloud desktop.
 * *   Before you call this operation, take note of the cloud desktop types and the disk sizes for each type of cloud desktop that Elastic Desktop Service (EDS) provides. For more information, see [Cloud desktop types](~~188609~~).
 * *   When you change the configurations of a cloud desktop, you must change the desktop type or the size of the system disk or data disk. You must configure at least one of the following parameters: DesktopType, RootDiskSizeGib, and UserDiskSizeGib. You must take note of the following items:
 *     *   Each desktop type contains different desktop specifications, such as vCPUs, memory, and GPUs. When you change the desktop configurations, you can only change the desktop type from one to another. However, you cannot change only one of the specifications, such as vCPUs, memory, and GPUs.
 *     *   You cannot change a cloud desktop from the General Office type to a non-General Office type, or from a non-General Office type to the General Office type. You cannot change a cloud desktop from the Graphics type to a non-Graphics type, or from a non-Graphics type to the Graphics type.
 *     *   You can only increase the sizes of system and data disks.
 *     *   If your cloud desktop uses the subscription billing method, the price difference is calculated based on the price before and after configuration changes. You may receive a refund, or pay for the price difference.
 *     *   If you want to change the configurations of your cloud desktop for multiple times, we recommend that you wait at least 5 minutes the next time you change the configurations of the same cloud desktop.
 *     *   The cloud desktop for which you want to change configurations must be in the Stopped state.
 * *   The changes do not affect your personal data on the cloud desktop.
 *
 * @param request ModifyDesktopSpecRequest
 * @return ModifyDesktopSpecResponse
 */
func (client *Client) ModifyDesktopSpec(request *ModifyDesktopSpecRequest) (_result *ModifyDesktopSpecResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDesktopSpecResponse{}
	_body, _err := client.ModifyDesktopSpecWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyDesktopTimerWithOptions(request *ModifyDesktopTimerRequest, runtime *util.RuntimeOptions) (_result *ModifyDesktopTimerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopTimers)) {
		query["DesktopTimers"] = request.DesktopTimers
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.UseDesktopTimers)) {
		query["UseDesktopTimers"] = request.UseDesktopTimers
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDesktopTimer"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDesktopTimerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyDesktopTimer(request *ModifyDesktopTimerRequest) (_result *ModifyDesktopTimerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDesktopTimerResponse{}
	_body, _err := client.ModifyDesktopTimerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The cloud desktop must be in the Running (Running) state.
 *
 * @param request ModifyDesktopsPolicyGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDesktopsPolicyGroupResponse
 */
func (client *Client) ModifyDesktopsPolicyGroupWithOptions(request *ModifyDesktopsPolicyGroupRequest, runtime *util.RuntimeOptions) (_result *ModifyDesktopsPolicyGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyGroupId)) {
		query["PolicyGroupId"] = request.PolicyGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyGroupIds)) {
		query["PolicyGroupIds"] = request.PolicyGroupIds
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDesktopsPolicyGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDesktopsPolicyGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The cloud desktop must be in the Running (Running) state.
 *
 * @param request ModifyDesktopsPolicyGroupRequest
 * @return ModifyDesktopsPolicyGroupResponse
 */
func (client *Client) ModifyDesktopsPolicyGroup(request *ModifyDesktopsPolicyGroupRequest) (_result *ModifyDesktopsPolicyGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDesktopsPolicyGroupResponse{}
	_body, _err := client.ModifyDesktopsPolicyGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to change the configurations, such as the desktop type and disk size, of a cloud desktop.
 * *   Before you call this operation, you must know the cloud desktop types and the disk sizes for each type of cloud desktop that Elastic Desktop Service (EDS) provides.
 * *   When you change the configurations of a cloud desktop, you must change the desktop type or the size of the system disk or data disk. You must configure at least one of the following parameters: DesktopType, RootDiskSizeGib, and UserDiskSizeGib. Take note of the following items:
 * 1\\. Desktop types include the specifications of vCPUs, memory, and GPUs. You can change only the desktop type, instead of one of the specifications.
 * 2\\. You cannot change a cloud desktop from the General Office type to a non-General Office type, or from a non-General Office type to the General Office type. You cannot change a cloud desktop from the Graphics type to a non-Graphics type, or from a non-Graphics type to the Graphics type.
 * 3\\. You can only increase the sizes of system and data disks. You cannot decrease the sizes of system and data disks.
 * 4\\. If your cloud desktop uses the subscription billing method, the price difference is calculated based on the price before and after configuration changes. You may receive a refund, or must pay for the price difference.
 * 5\\. If you need to change the configurations of a cloud desktop multiple times, we recommend that you wait at least 5 minutes between consecutive operations on the cloud desktop.
 * 6\\. The cloud desktop for which you want to change the desktop type must be in the Stopped state.
 * *   The changes do not affect your personal data on the cloud desktop.
 *
 * @param request ModifyDiskSpecRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDiskSpecResponse
 */
func (client *Client) ModifyDiskSpecWithOptions(request *ModifyDiskSpecRequest, runtime *util.RuntimeOptions) (_result *ModifyDiskSpecResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.PromotionId)) {
		query["PromotionId"] = request.PromotionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RootDiskPerformanceLevel)) {
		query["RootDiskPerformanceLevel"] = request.RootDiskPerformanceLevel
	}

	if !tea.BoolValue(util.IsUnset(request.UserDiskPerformanceLevel)) {
		query["UserDiskPerformanceLevel"] = request.UserDiskPerformanceLevel
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDiskSpec"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDiskSpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to change the configurations, such as the desktop type and disk size, of a cloud desktop.
 * *   Before you call this operation, you must know the cloud desktop types and the disk sizes for each type of cloud desktop that Elastic Desktop Service (EDS) provides.
 * *   When you change the configurations of a cloud desktop, you must change the desktop type or the size of the system disk or data disk. You must configure at least one of the following parameters: DesktopType, RootDiskSizeGib, and UserDiskSizeGib. Take note of the following items:
 * 1\\. Desktop types include the specifications of vCPUs, memory, and GPUs. You can change only the desktop type, instead of one of the specifications.
 * 2\\. You cannot change a cloud desktop from the General Office type to a non-General Office type, or from a non-General Office type to the General Office type. You cannot change a cloud desktop from the Graphics type to a non-Graphics type, or from a non-Graphics type to the Graphics type.
 * 3\\. You can only increase the sizes of system and data disks. You cannot decrease the sizes of system and data disks.
 * 4\\. If your cloud desktop uses the subscription billing method, the price difference is calculated based on the price before and after configuration changes. You may receive a refund, or must pay for the price difference.
 * 5\\. If you need to change the configurations of a cloud desktop multiple times, we recommend that you wait at least 5 minutes between consecutive operations on the cloud desktop.
 * 6\\. The cloud desktop for which you want to change the desktop type must be in the Stopped state.
 * *   The changes do not affect your personal data on the cloud desktop.
 *
 * @param request ModifyDiskSpecRequest
 * @return ModifyDiskSpecResponse
 */
func (client *Client) ModifyDiskSpec(request *ModifyDiskSpecRequest) (_result *ModifyDiskSpecResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDiskSpecResponse{}
	_body, _err := client.ModifyDiskSpecWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The cloud desktops to which you want to assign users must be in the Running state.
 *
 * @param request ModifyEntitlementRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyEntitlementResponse
 */
func (client *Client) ModifyEntitlementWithOptions(request *ModifyEntitlementRequest, runtime *util.RuntimeOptions) (_result *ModifyEntitlementResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyEntitlement"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyEntitlementResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The cloud desktops to which you want to assign users must be in the Running state.
 *
 * @param request ModifyEntitlementRequest
 * @return ModifyEntitlementResponse
 */
func (client *Client) ModifyEntitlement(request *ModifyEntitlementRequest) (_result *ModifyEntitlementResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyEntitlementResponse{}
	_body, _err := client.ModifyEntitlementWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to modify the attributes of only custom images that are in the Available state.
 *
 * @param request ModifyImageAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyImageAttributeResponse
 */
func (client *Client) ModifyImageAttributeWithOptions(request *ModifyImageAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyImageAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyImageAttribute"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyImageAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to modify the attributes of only custom images that are in the Available state.
 *
 * @param request ModifyImageAttributeRequest
 * @return ModifyImageAttributeResponse
 */
func (client *Client) ModifyImageAttribute(request *ModifyImageAttributeRequest) (_result *ModifyImageAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyImageAttributeResponse{}
	_body, _err := client.ModifyImageAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyImagePermissionWithOptions(request *ModifyImagePermissionRequest, runtime *util.RuntimeOptions) (_result *ModifyImagePermissionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AddAccount)) {
		query["AddAccount"] = request.AddAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RemoveAccount)) {
		query["RemoveAccount"] = request.RemoveAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyImagePermission"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyImagePermissionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyImagePermission(request *ModifyImagePermissionRequest) (_result *ModifyImagePermissionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyImagePermissionResponse{}
	_body, _err := client.ModifyImagePermissionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you create a NAS file system, a mount target is automatically generated. By default, the mount target does not need to be changed. If the mount target is deleted by misoperation, you must specify a new mount target for the NAS file system in the workspace. You can call the [CreateMountTarget](~~62621~~) operation to create a mount target.
 *
 * @param request ModifyNASDefaultMountTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyNASDefaultMountTargetResponse
 */
func (client *Client) ModifyNASDefaultMountTargetWithOptions(request *ModifyNASDefaultMountTargetRequest, runtime *util.RuntimeOptions) (_result *ModifyNASDefaultMountTargetResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FileSystemId)) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !tea.BoolValue(util.IsUnset(request.MountTargetDomain)) {
		query["MountTargetDomain"] = request.MountTargetDomain
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyNASDefaultMountTarget"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyNASDefaultMountTargetResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you create a NAS file system, a mount target is automatically generated. By default, the mount target does not need to be changed. If the mount target is deleted by misoperation, you must specify a new mount target for the NAS file system in the workspace. You can call the [CreateMountTarget](~~62621~~) operation to create a mount target.
 *
 * @param request ModifyNASDefaultMountTargetRequest
 * @return ModifyNASDefaultMountTargetResponse
 */
func (client *Client) ModifyNASDefaultMountTarget(request *ModifyNASDefaultMountTargetRequest) (_result *ModifyNASDefaultMountTargetResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyNASDefaultMountTargetResponse{}
	_body, _err := client.ModifyNASDefaultMountTargetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyNetworkPackageBandwidthWithOptions(request *ModifyNetworkPackageBandwidthRequest, runtime *util.RuntimeOptions) (_result *ModifyNetworkPackageBandwidthResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkPackageId)) {
		query["NetworkPackageId"] = request.NetworkPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.PromotionId)) {
		query["PromotionId"] = request.PromotionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyNetworkPackageBandwidth"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyNetworkPackageBandwidthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyNetworkPackageBandwidth(request *ModifyNetworkPackageBandwidthRequest) (_result *ModifyNetworkPackageBandwidthResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyNetworkPackageBandwidthResponse{}
	_body, _err := client.ModifyNetworkPackageBandwidthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If you want to temporarily disable Internet access for a cloud desktop, you can disable the Internet access package. You can restore the package when you require Internet access for the cloud desktop.
 *
 * @param request ModifyNetworkPackageEnabledRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyNetworkPackageEnabledResponse
 */
func (client *Client) ModifyNetworkPackageEnabledWithOptions(request *ModifyNetworkPackageEnabledRequest, runtime *util.RuntimeOptions) (_result *ModifyNetworkPackageEnabledResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Enabled)) {
		query["Enabled"] = request.Enabled
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkPackageId)) {
		query["NetworkPackageId"] = request.NetworkPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyNetworkPackageEnabled"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyNetworkPackageEnabledResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If you want to temporarily disable Internet access for a cloud desktop, you can disable the Internet access package. You can restore the package when you require Internet access for the cloud desktop.
 *
 * @param request ModifyNetworkPackageEnabledRequest
 * @return ModifyNetworkPackageEnabledResponse
 */
func (client *Client) ModifyNetworkPackageEnabled(request *ModifyNetworkPackageEnabledRequest) (_result *ModifyNetworkPackageEnabledResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyNetworkPackageEnabledResponse{}
	_body, _err := client.ModifyNetworkPackageEnabledWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyOfficeSiteAttributeWithOptions(request *ModifyOfficeSiteAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyOfficeSiteAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopAccessType)) {
		query["DesktopAccessType"] = request.DesktopAccessType
	}

	if !tea.BoolValue(util.IsUnset(request.EnableAdminAccess)) {
		query["EnableAdminAccess"] = request.EnableAdminAccess
	}

	if !tea.BoolValue(util.IsUnset(request.NeedVerifyLoginRisk)) {
		query["NeedVerifyLoginRisk"] = request.NeedVerifyLoginRisk
	}

	if !tea.BoolValue(util.IsUnset(request.NeedVerifyZeroDevice)) {
		query["NeedVerifyZeroDevice"] = request.NeedVerifyZeroDevice
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteName)) {
		query["OfficeSiteName"] = request.OfficeSiteName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyOfficeSiteAttribute"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyOfficeSiteAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyOfficeSiteAttribute(request *ModifyOfficeSiteAttributeRequest) (_result *ModifyOfficeSiteAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyOfficeSiteAttributeResponse{}
	_body, _err := client.ModifyOfficeSiteAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyOfficeSiteCrossDesktopAccessWithOptions(request *ModifyOfficeSiteCrossDesktopAccessRequest, runtime *util.RuntimeOptions) (_result *ModifyOfficeSiteCrossDesktopAccessResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EnableCrossDesktopAccess)) {
		query["EnableCrossDesktopAccess"] = request.EnableCrossDesktopAccess
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyOfficeSiteCrossDesktopAccess"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyOfficeSiteCrossDesktopAccessResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyOfficeSiteCrossDesktopAccess(request *ModifyOfficeSiteCrossDesktopAccessRequest) (_result *ModifyOfficeSiteCrossDesktopAccessResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyOfficeSiteCrossDesktopAccessResponse{}
	_body, _err := client.ModifyOfficeSiteCrossDesktopAccessWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyOfficeSiteMfaEnabledWithOptions(request *ModifyOfficeSiteMfaEnabledRequest, runtime *util.RuntimeOptions) (_result *ModifyOfficeSiteMfaEnabledResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MfaEnabled)) {
		query["MfaEnabled"] = request.MfaEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyOfficeSiteMfaEnabled"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyOfficeSiteMfaEnabledResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyOfficeSiteMfaEnabled(request *ModifyOfficeSiteMfaEnabledRequest) (_result *ModifyOfficeSiteMfaEnabledResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyOfficeSiteMfaEnabledResponse{}
	_body, _err := client.ModifyOfficeSiteMfaEnabledWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyPolicyGroupWithOptions(request *ModifyPolicyGroupRequest, runtime *util.RuntimeOptions) (_result *ModifyPolicyGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AdminAccess)) {
		query["AdminAccess"] = request.AdminAccess
	}

	if !tea.BoolValue(util.IsUnset(request.AppContentProtection)) {
		query["AppContentProtection"] = request.AppContentProtection
	}

	if !tea.BoolValue(util.IsUnset(request.AuthorizeAccessPolicyRule)) {
		query["AuthorizeAccessPolicyRule"] = request.AuthorizeAccessPolicyRule
	}

	if !tea.BoolValue(util.IsUnset(request.AuthorizeSecurityPolicyRule)) {
		query["AuthorizeSecurityPolicyRule"] = request.AuthorizeSecurityPolicyRule
	}

	if !tea.BoolValue(util.IsUnset(request.CameraRedirect)) {
		query["CameraRedirect"] = request.CameraRedirect
	}

	if !tea.BoolValue(util.IsUnset(request.ClientType)) {
		query["ClientType"] = request.ClientType
	}

	if !tea.BoolValue(util.IsUnset(request.Clipboard)) {
		query["Clipboard"] = request.Clipboard
	}

	if !tea.BoolValue(util.IsUnset(request.DomainList)) {
		query["DomainList"] = request.DomainList
	}

	if !tea.BoolValue(util.IsUnset(request.DomainResolveRule)) {
		query["DomainResolveRule"] = request.DomainResolveRule
	}

	if !tea.BoolValue(util.IsUnset(request.DomainResolveRuleType)) {
		query["DomainResolveRuleType"] = request.DomainResolveRuleType
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserApplyAdminCoordinate)) {
		query["EndUserApplyAdminCoordinate"] = request.EndUserApplyAdminCoordinate
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserGroupCoordinate)) {
		query["EndUserGroupCoordinate"] = request.EndUserGroupCoordinate
	}

	if !tea.BoolValue(util.IsUnset(request.GpuAcceleration)) {
		query["GpuAcceleration"] = request.GpuAcceleration
	}

	if !tea.BoolValue(util.IsUnset(request.Html5Access)) {
		query["Html5Access"] = request.Html5Access
	}

	if !tea.BoolValue(util.IsUnset(request.Html5FileTransfer)) {
		query["Html5FileTransfer"] = request.Html5FileTransfer
	}

	if !tea.BoolValue(util.IsUnset(request.InternetCommunicationProtocol)) {
		query["InternetCommunicationProtocol"] = request.InternetCommunicationProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.LocalDrive)) {
		query["LocalDrive"] = request.LocalDrive
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.NetRedirect)) {
		query["NetRedirect"] = request.NetRedirect
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyGroupId)) {
		query["PolicyGroupId"] = request.PolicyGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.PreemptLogin)) {
		query["PreemptLogin"] = request.PreemptLogin
	}

	if !tea.BoolValue(util.IsUnset(request.PreemptLoginUser)) {
		query["PreemptLoginUser"] = request.PreemptLoginUser
	}

	if !tea.BoolValue(util.IsUnset(request.PrinterRedirection)) {
		query["PrinterRedirection"] = request.PrinterRedirection
	}

	if !tea.BoolValue(util.IsUnset(request.RecordContent)) {
		query["RecordContent"] = request.RecordContent
	}

	if !tea.BoolValue(util.IsUnset(request.RecordContentExpires)) {
		query["RecordContentExpires"] = request.RecordContentExpires
	}

	if !tea.BoolValue(util.IsUnset(request.Recording)) {
		query["Recording"] = request.Recording
	}

	if !tea.BoolValue(util.IsUnset(request.RecordingAudio)) {
		query["RecordingAudio"] = request.RecordingAudio
	}

	if !tea.BoolValue(util.IsUnset(request.RecordingDuration)) {
		query["RecordingDuration"] = request.RecordingDuration
	}

	if !tea.BoolValue(util.IsUnset(request.RecordingEndTime)) {
		query["RecordingEndTime"] = request.RecordingEndTime
	}

	if !tea.BoolValue(util.IsUnset(request.RecordingExpires)) {
		query["RecordingExpires"] = request.RecordingExpires
	}

	if !tea.BoolValue(util.IsUnset(request.RecordingFps)) {
		query["RecordingFps"] = request.RecordingFps
	}

	if !tea.BoolValue(util.IsUnset(request.RecordingStartTime)) {
		query["RecordingStartTime"] = request.RecordingStartTime
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RemoteCoordinate)) {
		query["RemoteCoordinate"] = request.RemoteCoordinate
	}

	if !tea.BoolValue(util.IsUnset(request.RevokeAccessPolicyRule)) {
		query["RevokeAccessPolicyRule"] = request.RevokeAccessPolicyRule
	}

	if !tea.BoolValue(util.IsUnset(request.RevokeSecurityPolicyRule)) {
		query["RevokeSecurityPolicyRule"] = request.RevokeSecurityPolicyRule
	}

	if !tea.BoolValue(util.IsUnset(request.Scope)) {
		query["Scope"] = request.Scope
	}

	if !tea.BoolValue(util.IsUnset(request.ScopeValue)) {
		query["ScopeValue"] = request.ScopeValue
	}

	if !tea.BoolValue(util.IsUnset(request.UsbRedirect)) {
		query["UsbRedirect"] = request.UsbRedirect
	}

	if !tea.BoolValue(util.IsUnset(request.UsbSupplyRedirectRule)) {
		query["UsbSupplyRedirectRule"] = request.UsbSupplyRedirectRule
	}

	if !tea.BoolValue(util.IsUnset(request.VideoRedirect)) {
		query["VideoRedirect"] = request.VideoRedirect
	}

	if !tea.BoolValue(util.IsUnset(request.VisualQuality)) {
		query["VisualQuality"] = request.VisualQuality
	}

	if !tea.BoolValue(util.IsUnset(request.Watermark)) {
		query["Watermark"] = request.Watermark
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkColor)) {
		query["WatermarkColor"] = request.WatermarkColor
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkDegree)) {
		query["WatermarkDegree"] = request.WatermarkDegree
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkFontSize)) {
		query["WatermarkFontSize"] = request.WatermarkFontSize
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkFontStyle)) {
		query["WatermarkFontStyle"] = request.WatermarkFontStyle
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkRowAmount)) {
		query["WatermarkRowAmount"] = request.WatermarkRowAmount
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkSecurity)) {
		query["WatermarkSecurity"] = request.WatermarkSecurity
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkTransparency)) {
		query["WatermarkTransparency"] = request.WatermarkTransparency
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkTransparencyValue)) {
		query["WatermarkTransparencyValue"] = request.WatermarkTransparencyValue
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkType)) {
		query["WatermarkType"] = request.WatermarkType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyPolicyGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyPolicyGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyPolicyGroup(request *ModifyPolicyGroupRequest) (_result *ModifyPolicyGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyPolicyGroupResponse{}
	_body, _err := client.ModifyPolicyGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can modify user permissions on cloud desktops that are only in the Running state.
 *
 * @param request ModifyUserEntitlementRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyUserEntitlementResponse
 */
func (client *Client) ModifyUserEntitlementWithOptions(request *ModifyUserEntitlementRequest, runtime *util.RuntimeOptions) (_result *ModifyUserEntitlementResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AuthorizeDesktopId)) {
		query["AuthorizeDesktopId"] = request.AuthorizeDesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RevokeDesktopId)) {
		query["RevokeDesktopId"] = request.RevokeDesktopId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyUserEntitlement"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyUserEntitlementResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can modify user permissions on cloud desktops that are only in the Running state.
 *
 * @param request ModifyUserEntitlementRequest
 * @return ModifyUserEntitlementResponse
 */
func (client *Client) ModifyUserEntitlement(request *ModifyUserEntitlementRequest) (_result *ModifyUserEntitlementResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyUserEntitlementResponse{}
	_body, _err := client.ModifyUserEntitlementWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyUserToDesktopGroupWithOptions(request *ModifyUserToDesktopGroupRequest, runtime *util.RuntimeOptions) (_result *ModifyUserToDesktopGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopGroupId)) {
		query["DesktopGroupId"] = request.DesktopGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.NewEndUserIds)) {
		query["NewEndUserIds"] = request.NewEndUserIds
	}

	if !tea.BoolValue(util.IsUnset(request.OldEndUserIds)) {
		query["OldEndUserIds"] = request.OldEndUserIds
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyUserToDesktopGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyUserToDesktopGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyUserToDesktopGroup(request *ModifyUserToDesktopGroupRequest) (_result *ModifyUserToDesktopGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyUserToDesktopGroupResponse{}
	_body, _err := client.ModifyUserToDesktopGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) MoveCdsFileWithOptions(request *MoveCdsFileRequest, runtime *util.RuntimeOptions) (_result *MoveCdsFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	if !tea.BoolValue(util.IsUnset(request.ConflictPolicy)) {
		query["ConflictPolicy"] = request.ConflictPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		query["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ParentFolderId)) {
		query["ParentFolderId"] = request.ParentFolderId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("MoveCdsFile"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &MoveCdsFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) MoveCdsFile(request *MoveCdsFileRequest) (_result *MoveCdsFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &MoveCdsFileResponse{}
	_body, _err := client.MoveCdsFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The cloud desktops that you want to restart by calling this operation must be in the Running state.
 *
 * @param request RebootDesktopsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RebootDesktopsResponse
 */
func (client *Client) RebootDesktopsWithOptions(request *RebootDesktopsRequest, runtime *util.RuntimeOptions) (_result *RebootDesktopsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RebootDesktops"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RebootDesktopsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The cloud desktops that you want to restart by calling this operation must be in the Running state.
 *
 * @param request RebootDesktopsRequest
 * @return RebootDesktopsResponse
 */
func (client *Client) RebootDesktops(request *RebootDesktopsRequest) (_result *RebootDesktopsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RebootDesktopsResponse{}
	_body, _err := client.RebootDesktopsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you change the image of a cloud desktop, take note of the following limits:
 * *   You can select the OS of an image during image change. However, this operation is unavailable in the following regions: China (Hong Kong), Australia (Sydney), Singapore (Singapore), and Japan (Tokyo).
 * *   Image change between GPU and non-GPU images is not supported. If a cloud desktop is of the Graphics type, you can use only a GPU image. If the cloud desktop is of a non-Graphics type, you can use only a non-GPU image.
 * After you change the image of the cloud desktop, the system uses the new image to initialize the system disk of the cloud desktop. Take note of the following impacts:
 * *   The system deletes data from the original system disk. The snapshots that are created from the original system disk of the cloud desktop become unavailable and are automatically deleted.
 * *   If you change the OS of the image, the system deletes data from the original data disk of the cloud desktop. The system also deletes snapshots that are created from the original data disk of the cloud desktop because original snapshots become unavailable. If you do not change the OS of the image, data on the original data disk is retained, and snapshots that are created from the data disk are still available.
 *
 * @param request RebuildDesktopsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RebuildDesktopsResponse
 */
func (client *Client) RebuildDesktopsWithOptions(request *RebuildDesktopsRequest, runtime *util.RuntimeOptions) (_result *RebuildDesktopsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.OperateType)) {
		query["OperateType"] = request.OperateType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RebuildDesktops"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RebuildDesktopsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you change the image of a cloud desktop, take note of the following limits:
 * *   You can select the OS of an image during image change. However, this operation is unavailable in the following regions: China (Hong Kong), Australia (Sydney), Singapore (Singapore), and Japan (Tokyo).
 * *   Image change between GPU and non-GPU images is not supported. If a cloud desktop is of the Graphics type, you can use only a GPU image. If the cloud desktop is of a non-Graphics type, you can use only a non-GPU image.
 * After you change the image of the cloud desktop, the system uses the new image to initialize the system disk of the cloud desktop. Take note of the following impacts:
 * *   The system deletes data from the original system disk. The snapshots that are created from the original system disk of the cloud desktop become unavailable and are automatically deleted.
 * *   If you change the OS of the image, the system deletes data from the original data disk of the cloud desktop. The system also deletes snapshots that are created from the original data disk of the cloud desktop because original snapshots become unavailable. If you do not change the OS of the image, data on the original data disk is retained, and snapshots that are created from the data disk are still available.
 *
 * @param request RebuildDesktopsRequest
 * @return RebuildDesktopsResponse
 */
func (client *Client) RebuildDesktops(request *RebuildDesktopsRequest) (_result *RebuildDesktopsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RebuildDesktopsResponse{}
	_body, _err := client.RebuildDesktopsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RemoveFilePermissionWithOptions(tmpReq *RemoveFilePermissionRequest, runtime *util.RuntimeOptions) (_result *RemoveFilePermissionResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &RemoveFilePermissionShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.MemberList)) {
		request.MemberListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.MemberList, tea.String("MemberList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CdsId)) {
		query["CdsId"] = request.CdsId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		query["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.MemberListShrink)) {
		query["MemberList"] = request.MemberListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveFilePermission"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveFilePermissionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RemoveFilePermission(request *RemoveFilePermissionRequest) (_result *RemoveFilePermissionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveFilePermissionResponse{}
	_body, _err := client.RemoveFilePermissionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RemoveUserFromDesktopGroupWithOptions(request *RemoveUserFromDesktopGroupRequest, runtime *util.RuntimeOptions) (_result *RemoveUserFromDesktopGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopGroupId)) {
		query["DesktopGroupId"] = request.DesktopGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopGroupIds)) {
		query["DesktopGroupIds"] = request.DesktopGroupIds
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserIds)) {
		query["EndUserIds"] = request.EndUserIds
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveUserFromDesktopGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveUserFromDesktopGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RemoveUserFromDesktopGroup(request *RemoveUserFromDesktopGroupRequest) (_result *RemoveUserFromDesktopGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveUserFromDesktopGroupResponse{}
	_body, _err := client.RemoveUserFromDesktopGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RemoveUserFromDesktopOversoldUserGroupWithOptions(request *RemoveUserFromDesktopOversoldUserGroupRequest, runtime *util.RuntimeOptions) (_result *RemoveUserFromDesktopOversoldUserGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.OversoldGroupId)) {
		query["OversoldGroupId"] = request.OversoldGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.UserDesktopId)) {
		query["UserDesktopId"] = request.UserDesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.UserGroupId)) {
		query["UserGroupId"] = request.UserGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveUserFromDesktopOversoldUserGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveUserFromDesktopOversoldUserGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RemoveUserFromDesktopOversoldUserGroup(request *RemoveUserFromDesktopOversoldUserGroupRequest) (_result *RemoveUserFromDesktopOversoldUserGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveUserFromDesktopOversoldUserGroupResponse{}
	_body, _err := client.RemoveUserFromDesktopOversoldUserGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RenewDesktopOversoldGroupWithOptions(request *RenewDesktopOversoldGroupRequest, runtime *util.RuntimeOptions) (_result *RenewDesktopOversoldGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OversoldGroupId)) {
		query["OversoldGroupId"] = request.OversoldGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.PeriodUnit)) {
		query["PeriodUnit"] = request.PeriodUnit
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RenewDesktopOversoldGroup"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RenewDesktopOversoldGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RenewDesktopOversoldGroup(request *RenewDesktopOversoldGroupRequest) (_result *RenewDesktopOversoldGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RenewDesktopOversoldGroupResponse{}
	_body, _err := client.RenewDesktopOversoldGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RenewDesktopsWithOptions(request *RenewDesktopsRequest, runtime *util.RuntimeOptions) (_result *RenewDesktopsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.PeriodUnit)) {
		query["PeriodUnit"] = request.PeriodUnit
	}

	if !tea.BoolValue(util.IsUnset(request.PromotionId)) {
		query["PromotionId"] = request.PromotionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RenewDesktops"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RenewDesktopsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RenewDesktops(request *RenewDesktopsRequest) (_result *RenewDesktopsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RenewDesktopsResponse{}
	_body, _err := client.RenewDesktopsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RenewNetworkPackagesWithOptions(request *RenewNetworkPackagesRequest, runtime *util.RuntimeOptions) (_result *RenewNetworkPackagesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkPackageId)) {
		query["NetworkPackageId"] = request.NetworkPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.PeriodUnit)) {
		query["PeriodUnit"] = request.PeriodUnit
	}

	if !tea.BoolValue(util.IsUnset(request.PromotionId)) {
		query["PromotionId"] = request.PromotionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RenewNetworkPackages"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RenewNetworkPackagesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RenewNetworkPackages(request *RenewNetworkPackagesRequest) (_result *RenewNetworkPackagesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RenewNetworkPackagesResponse{}
	_body, _err := client.RenewNetworkPackagesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation to reset only cloud desktops that are managed by a cloud desktop group. You cannot reset an independent cloud desktop.
 *
 * @param request ResetDesktopsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetDesktopsResponse
 */
func (client *Client) ResetDesktopsWithOptions(request *ResetDesktopsRequest, runtime *util.RuntimeOptions) (_result *ResetDesktopsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopGroupId)) {
		query["DesktopGroupId"] = request.DesktopGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.PayType)) {
		query["PayType"] = request.PayType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResetType)) {
		query["ResetType"] = request.ResetType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ResetDesktops"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ResetDesktopsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation to reset only cloud desktops that are managed by a cloud desktop group. You cannot reset an independent cloud desktop.
 *
 * @param request ResetDesktopsRequest
 * @return ResetDesktopsResponse
 */
func (client *Client) ResetDesktops(request *ResetDesktopsRequest) (_result *ResetDesktopsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ResetDesktopsResponse{}
	_body, _err := client.ResetDesktopsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you create a NAS file system, a mount target is automatically generated. By default, you do not need to modify the mount target of the NAS file system. If the mount target is disabled, you need to reset the mount target of the NAS file system.
 *
 * @param request ResetNASDefaultMountTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetNASDefaultMountTargetResponse
 */
func (client *Client) ResetNASDefaultMountTargetWithOptions(request *ResetNASDefaultMountTargetRequest, runtime *util.RuntimeOptions) (_result *ResetNASDefaultMountTargetResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FileSystemId)) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ResetNASDefaultMountTarget"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ResetNASDefaultMountTargetResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you create a NAS file system, a mount target is automatically generated. By default, you do not need to modify the mount target of the NAS file system. If the mount target is disabled, you need to reset the mount target of the NAS file system.
 *
 * @param request ResetNASDefaultMountTargetRequest
 * @return ResetNASDefaultMountTargetResponse
 */
func (client *Client) ResetNASDefaultMountTarget(request *ResetNASDefaultMountTargetRequest) (_result *ResetNASDefaultMountTargetResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ResetNASDefaultMountTargetResponse{}
	_body, _err := client.ResetNASDefaultMountTargetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this operation, make sure that the following operations are performed:
 * *   The data that you want to retain in the disk is backed up.
 *     **
 *     **Note**The disk restoration operation is irreversible. After you restore data on a disk, the disk is restored to the status at the point in time when the snapshot was created. Data that is generated between the snapshot creation time and the current time is lost. Before you restore a disk from a snapshot, make sure that you back up important data.
 * *   The cloud desktop whose disk you want to restore is stopped.
 *
 * @param request ResetSnapshotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetSnapshotResponse
 */
func (client *Client) ResetSnapshotWithOptions(request *ResetSnapshotRequest, runtime *util.RuntimeOptions) (_result *ResetSnapshotResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SnapshotId)) {
		query["SnapshotId"] = request.SnapshotId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ResetSnapshot"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ResetSnapshotResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this operation, make sure that the following operations are performed:
 * *   The data that you want to retain in the disk is backed up.
 *     **
 *     **Note**The disk restoration operation is irreversible. After you restore data on a disk, the disk is restored to the status at the point in time when the snapshot was created. Data that is generated between the snapshot creation time and the current time is lost. Before you restore a disk from a snapshot, make sure that you back up important data.
 * *   The cloud desktop whose disk you want to restore is stopped.
 *
 * @param request ResetSnapshotRequest
 * @return ResetSnapshotResponse
 */
func (client *Client) ResetSnapshot(request *ResetSnapshotRequest) (_result *ResetSnapshotResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ResetSnapshotResponse{}
	_body, _err := client.ResetSnapshotWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RevokeCoordinatePrivilegeWithOptions(request *RevokeCoordinatePrivilegeRequest, runtime *util.RuntimeOptions) (_result *RevokeCoordinatePrivilegeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CoId)) {
		query["CoId"] = request.CoId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.UserType)) {
		query["UserType"] = request.UserType
	}

	if !tea.BoolValue(util.IsUnset(request.Uuid)) {
		query["Uuid"] = request.Uuid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RevokeCoordinatePrivilege"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RevokeCoordinatePrivilegeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RevokeCoordinatePrivilege(request *RevokeCoordinatePrivilegeRequest) (_result *RevokeCoordinatePrivilegeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RevokeCoordinatePrivilegeResponse{}
	_body, _err := client.RevokeCoordinatePrivilegeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can use the RunCommand operation to run scripts only on Windows cloud desktops.
 *
 * @param request RunCommandRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RunCommandResponse
 */
func (client *Client) RunCommandWithOptions(request *RunCommandRequest, runtime *util.RuntimeOptions) (_result *RunCommandResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CommandContent)) {
		query["CommandContent"] = request.CommandContent
	}

	if !tea.BoolValue(util.IsUnset(request.ContentEncoding)) {
		query["ContentEncoding"] = request.ContentEncoding
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.EndUserId)) {
		query["EndUserId"] = request.EndUserId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Timeout)) {
		query["Timeout"] = request.Timeout
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RunCommand"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RunCommandResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can use the RunCommand operation to run scripts only on Windows cloud desktops.
 *
 * @param request RunCommandRequest
 * @return RunCommandResponse
 */
func (client *Client) RunCommand(request *RunCommandRequest) (_result *RunCommandResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RunCommandResponse{}
	_body, _err := client.RunCommandWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Description
 * When you attach your workspace network to a Cloud Enterprise Network (CEN) instance in another Alibaba Cloud account, you need to call this operation to obtain a verification code. After the call is successful, the system sends a verification code to the email address associated with the Alibaba Cloud account.
 *
 * @param request SendVerifyCodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SendVerifyCodeResponse
 */
func (client *Client) SendVerifyCodeWithOptions(request *SendVerifyCodeRequest, runtime *util.RuntimeOptions) (_result *SendVerifyCodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ExtraInfo)) {
		query["ExtraInfo"] = request.ExtraInfo
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.VerifyCodeAction)) {
		query["VerifyCodeAction"] = request.VerifyCodeAction
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SendVerifyCode"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SendVerifyCodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Description
 * When you attach your workspace network to a Cloud Enterprise Network (CEN) instance in another Alibaba Cloud account, you need to call this operation to obtain a verification code. After the call is successful, the system sends a verification code to the email address associated with the Alibaba Cloud account.
 *
 * @param request SendVerifyCodeRequest
 * @return SendVerifyCodeResponse
 */
func (client *Client) SendVerifyCode(request *SendVerifyCodeRequest) (_result *SendVerifyCodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SendVerifyCodeResponse{}
	_body, _err := client.SendVerifyCodeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetDesktopGroupScaleTimerWithOptions(request *SetDesktopGroupScaleTimerRequest, runtime *util.RuntimeOptions) (_result *SetDesktopGroupScaleTimerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopGroupId)) {
		query["DesktopGroupId"] = request.DesktopGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ScaleTimerInfos)) {
		query["ScaleTimerInfos"] = request.ScaleTimerInfos
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDesktopGroupScaleTimer"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDesktopGroupScaleTimerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetDesktopGroupScaleTimer(request *SetDesktopGroupScaleTimerRequest) (_result *SetDesktopGroupScaleTimerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDesktopGroupScaleTimerResponse{}
	_body, _err := client.SetDesktopGroupScaleTimerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetDesktopGroupTimerWithOptions(request *SetDesktopGroupTimerRequest, runtime *util.RuntimeOptions) (_result *SetDesktopGroupTimerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CronExpression)) {
		query["CronExpression"] = request.CronExpression
	}

	if !tea.BoolValue(util.IsUnset(request.DesktopGroupId)) {
		query["DesktopGroupId"] = request.DesktopGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Force)) {
		query["Force"] = request.Force
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResetType)) {
		query["ResetType"] = request.ResetType
	}

	if !tea.BoolValue(util.IsUnset(request.TimerType)) {
		query["TimerType"] = request.TimerType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDesktopGroupTimer"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDesktopGroupTimerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetDesktopGroupTimer(request *SetDesktopGroupTimerRequest) (_result *SetDesktopGroupTimerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDesktopGroupTimerResponse{}
	_body, _err := client.SetDesktopGroupTimerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetDesktopGroupTimerStatusWithOptions(request *SetDesktopGroupTimerStatusRequest, runtime *util.RuntimeOptions) (_result *SetDesktopGroupTimerStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopGroupId)) {
		query["DesktopGroupId"] = request.DesktopGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.TimerType)) {
		query["TimerType"] = request.TimerType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDesktopGroupTimerStatus"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDesktopGroupTimerStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetDesktopGroupTimerStatus(request *SetDesktopGroupTimerStatusRequest) (_result *SetDesktopGroupTimerStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDesktopGroupTimerStatusResponse{}
	_body, _err := client.SetDesktopGroupTimerStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is supported only for AD directories, not for RAM directories.
 *
 * @param request SetDirectorySsoStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDirectorySsoStatusResponse
 */
func (client *Client) SetDirectorySsoStatusWithOptions(request *SetDirectorySsoStatusRequest, runtime *util.RuntimeOptions) (_result *SetDirectorySsoStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DirectoryId)) {
		query["DirectoryId"] = request.DirectoryId
	}

	if !tea.BoolValue(util.IsUnset(request.EnableSso)) {
		query["EnableSso"] = request.EnableSso
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDirectorySsoStatus"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDirectorySsoStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is supported only for AD directories, not for RAM directories.
 *
 * @param request SetDirectorySsoStatusRequest
 * @return SetDirectorySsoStatusResponse
 */
func (client *Client) SetDirectorySsoStatus(request *SetDirectorySsoStatusRequest) (_result *SetDirectorySsoStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDirectorySsoStatusResponse{}
	_body, _err := client.SetDirectorySsoStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation only for workspaces of the Active Directory (AD) and convenience account types.
 *
 * @param request SetIdpMetadataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetIdpMetadataResponse
 */
func (client *Client) SetIdpMetadataWithOptions(request *SetIdpMetadataRequest, runtime *util.RuntimeOptions) (_result *SetIdpMetadataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DirectoryId)) {
		query["DirectoryId"] = request.DirectoryId
	}

	if !tea.BoolValue(util.IsUnset(request.IdpMetadata)) {
		query["IdpMetadata"] = request.IdpMetadata
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetIdpMetadata"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetIdpMetadataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation only for workspaces of the Active Directory (AD) and convenience account types.
 *
 * @param request SetIdpMetadataRequest
 * @return SetIdpMetadataResponse
 */
func (client *Client) SetIdpMetadata(request *SetIdpMetadataRequest) (_result *SetIdpMetadataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetIdpMetadataResponse{}
	_body, _err := client.SetIdpMetadataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetOfficeSiteSsoStatusWithOptions(request *SetOfficeSiteSsoStatusRequest, runtime *util.RuntimeOptions) (_result *SetOfficeSiteSsoStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EnableSso)) {
		query["EnableSso"] = request.EnableSso
	}

	if !tea.BoolValue(util.IsUnset(request.OfficeSiteId)) {
		query["OfficeSiteId"] = request.OfficeSiteId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetOfficeSiteSsoStatus"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetOfficeSiteSsoStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetOfficeSiteSsoStatus(request *SetOfficeSiteSsoStatusRequest) (_result *SetOfficeSiteSsoStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetOfficeSiteSsoStatusResponse{}
	_body, _err := client.SetOfficeSiteSsoStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetUserProfilePathRulesWithOptions(tmpReq *SetUserProfilePathRulesRequest, runtime *util.RuntimeOptions) (_result *SetUserProfilePathRulesResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &SetUserProfilePathRulesShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.UserProfilePathRule)) {
		request.UserProfilePathRuleShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.UserProfilePathRule, tea.String("UserProfilePathRule"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopGroupId)) {
		query["DesktopGroupId"] = request.DesktopGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.UserProfilePathRuleShrink)) {
		query["UserProfilePathRule"] = request.UserProfilePathRuleShrink
	}

	if !tea.BoolValue(util.IsUnset(request.UserProfileRuleType)) {
		query["UserProfileRuleType"] = request.UserProfileRuleType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetUserProfilePathRules"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetUserProfilePathRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetUserProfilePathRules(request *SetUserProfilePathRulesRequest) (_result *SetUserProfilePathRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetUserProfilePathRulesResponse{}
	_body, _err := client.SetUserProfilePathRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The cloud desktop that you want to start must be in the Stopped state.
 *
 * @param request StartDesktopsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartDesktopsResponse
 */
func (client *Client) StartDesktopsWithOptions(request *StartDesktopsRequest, runtime *util.RuntimeOptions) (_result *StartDesktopsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StartDesktops"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StartDesktopsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The cloud desktop that you want to start must be in the Stopped state.
 *
 * @param request StartDesktopsRequest
 * @return StartDesktopsResponse
 */
func (client *Client) StartDesktops(request *StartDesktopsRequest) (_result *StartDesktopsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StartDesktopsResponse{}
	_body, _err := client.StartDesktopsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The cloud desktops that you want to stop must be in the Running state.
 *
 * @param request StopDesktopsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopDesktopsResponse
 */
func (client *Client) StopDesktopsWithOptions(request *StopDesktopsRequest, runtime *util.RuntimeOptions) (_result *StopDesktopsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.StoppedMode)) {
		query["StoppedMode"] = request.StoppedMode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StopDesktops"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StopDesktopsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The cloud desktops that you want to stop must be in the Running state.
 *
 * @param request StopDesktopsRequest
 * @return StopDesktopsResponse
 */
func (client *Client) StopDesktops(request *StopDesktopsRequest) (_result *StopDesktopsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StopDesktopsResponse{}
	_body, _err := client.StopDesktopsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the execution.
 *
 * @param request StopInvocationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopInvocationResponse
 */
func (client *Client) StopInvocationWithOptions(request *StopInvocationRequest, runtime *util.RuntimeOptions) (_result *StopInvocationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.InvokeId)) {
		query["InvokeId"] = request.InvokeId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StopInvocation"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StopInvocationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the execution.
 *
 * @param request StopInvocationRequest
 * @return StopInvocationResponse
 */
func (client *Client) StopInvocation(request *StopInvocationRequest) (_result *StopInvocationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StopInvocationResponse{}
	_body, _err := client.StopInvocationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If TagKey is specified, the new TagValue value overrides the original TagValue value.
 *
 * @param request TagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesResponse
 */
func (client *Client) TagResourcesWithOptions(request *TagResourcesRequest, runtime *util.RuntimeOptions) (_result *TagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TagResources"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If TagKey is specified, the new TagValue value overrides the original TagValue value.
 *
 * @param request TagResourcesRequest
 * @return TagResourcesResponse
 */
func (client *Client) TagResources(request *TagResourcesRequest) (_result *TagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TagResourcesResponse{}
	_body, _err := client.TagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UnlockVirtualMFADeviceWithOptions(request *UnlockVirtualMFADeviceRequest, runtime *util.RuntimeOptions) (_result *UnlockVirtualMFADeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.SerialNumber)) {
		query["SerialNumber"] = request.SerialNumber
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UnlockVirtualMFADevice"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UnlockVirtualMFADeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UnlockVirtualMFADevice(request *UnlockVirtualMFADeviceRequest) (_result *UnlockVirtualMFADeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UnlockVirtualMFADeviceResponse{}
	_body, _err := client.UnlockVirtualMFADeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UntagResourcesWithOptions(request *UntagResourcesRequest, runtime *util.RuntimeOptions) (_result *UntagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.All)) {
		query["All"] = request.All
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TagKey)) {
		query["TagKey"] = request.TagKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UntagResources"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UntagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UntagResources(request *UntagResourcesRequest) (_result *UntagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UntagResourcesResponse{}
	_body, _err := client.UntagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateFotaTaskWithOptions(request *UpdateFotaTaskRequest, runtime *util.RuntimeOptions) (_result *UpdateFotaTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskUid)) {
		query["TaskUid"] = request.TaskUid
	}

	if !tea.BoolValue(util.IsUnset(request.UserStatus)) {
		query["UserStatus"] = request.UserStatus
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateFotaTask"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateFotaTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateFotaTask(request *UpdateFotaTaskRequest) (_result *UpdateFotaTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateFotaTaskResponse{}
	_body, _err := client.UpdateFotaTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation to upload custom Windows images.
 *
 * @param request UploadImageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UploadImageResponse
 */
func (client *Client) UploadImageWithOptions(request *UploadImageRequest, runtime *util.RuntimeOptions) (_result *UploadImageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DataDiskSize)) {
		query["DataDiskSize"] = request.DataDiskSize
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EnableSecurityCheck)) {
		query["EnableSecurityCheck"] = request.EnableSecurityCheck
	}

	if !tea.BoolValue(util.IsUnset(request.GpuCategory)) {
		query["GpuCategory"] = request.GpuCategory
	}

	if !tea.BoolValue(util.IsUnset(request.GpuDriverType)) {
		query["GpuDriverType"] = request.GpuDriverType
	}

	if !tea.BoolValue(util.IsUnset(request.ImageName)) {
		query["ImageName"] = request.ImageName
	}

	if !tea.BoolValue(util.IsUnset(request.LicenseType)) {
		query["LicenseType"] = request.LicenseType
	}

	if !tea.BoolValue(util.IsUnset(request.OsType)) {
		query["OsType"] = request.OsType
	}

	if !tea.BoolValue(util.IsUnset(request.OssObjectPath)) {
		query["OssObjectPath"] = request.OssObjectPath
	}

	if !tea.BoolValue(util.IsUnset(request.ProtocolType)) {
		query["ProtocolType"] = request.ProtocolType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UploadImage"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UploadImageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation to upload custom Windows images.
 *
 * @param request UploadImageRequest
 * @return UploadImageResponse
 */
func (client *Client) UploadImage(request *UploadImageRequest) (_result *UploadImageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UploadImageResponse{}
	_body, _err := client.UploadImageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) VerifyCenWithOptions(request *VerifyCenRequest, runtime *util.RuntimeOptions) (_result *VerifyCenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.CenOwnerId)) {
		query["CenOwnerId"] = request.CenOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.CidrBlock)) {
		query["CidrBlock"] = request.CidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.VerifyCode)) {
		query["VerifyCode"] = request.VerifyCode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("VerifyCen"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &VerifyCenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) VerifyCen(request *VerifyCenRequest) (_result *VerifyCenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &VerifyCenResponse{}
	_body, _err := client.VerifyCenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) WakeupDesktopsWithOptions(request *WakeupDesktopsRequest, runtime *util.RuntimeOptions) (_result *WakeupDesktopsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesktopId)) {
		query["DesktopId"] = request.DesktopId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("WakeupDesktops"),
		Version:     tea.String("2020-09-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &WakeupDesktopsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) WakeupDesktops(request *WakeupDesktopsRequest) (_result *WakeupDesktopsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &WakeupDesktopsResponse{}
	_body, _err := client.WakeupDesktopsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
