// This file is auto-generated, don't edit it. Thanks.
package client

import (
	gatewayclient "github.com/alibabacloud-go/alibabacloud-gateway-sls/client"
	httpclient "github.com/alibabacloud-go/alibabacloud-gateway-sls/http"
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
)

type Alert struct {
	// This parameter is required.
	Configuration *AlertConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty"`
	CreateTime    *int64              `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// example:
	//
	// Alert Desc
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// alertNameExample
	DisplayName      *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	LastModifiedTime *int64  `json:"lastModifiedTime,omitempty" xml:"lastModifiedTime,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// alert-123456
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// This parameter is required.
	Schedule *Schedule `json:"schedule,omitempty" xml:"schedule,omitempty"`
	// example:
	//
	// ENABLED/DISABLED
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s Alert) String() string {
	return tea.Prettify(s)
}

func (s Alert) GoString() string {
	return s.String()
}

func (s *Alert) SetConfiguration(v *AlertConfiguration) *Alert {
	s.Configuration = v
	return s
}

func (s *Alert) SetCreateTime(v int64) *Alert {
	s.CreateTime = &v
	return s
}

func (s *Alert) SetDescription(v string) *Alert {
	s.Description = &v
	return s
}

func (s *Alert) SetDisplayName(v string) *Alert {
	s.DisplayName = &v
	return s
}

func (s *Alert) SetLastModifiedTime(v int64) *Alert {
	s.LastModifiedTime = &v
	return s
}

func (s *Alert) SetName(v string) *Alert {
	s.Name = &v
	return s
}

func (s *Alert) SetSchedule(v *Schedule) *Alert {
	s.Schedule = v
	return s
}

func (s *Alert) SetStatus(v string) *Alert {
	s.Status = &v
	return s
}

type AlertConfiguration struct {
	Annotations []*AlertTag `json:"annotations,omitempty" xml:"annotations,omitempty" type:"Repeated"`
	// This parameter is required.
	//
	// example:
	//
	// false
	AutoAnnotation         *bool                   `json:"autoAnnotation,omitempty" xml:"autoAnnotation,omitempty"`
	ConditionConfiguration *ConditionConfiguration `json:"conditionConfiguration,omitempty" xml:"conditionConfiguration,omitempty"`
	// example:
	//
	// dasnboardExample
	Dashboard *string `json:"dashboard,omitempty" xml:"dashboard,omitempty"`
	// This parameter is required.
	GroupConfiguration *GroupConfiguration  `json:"groupConfiguration,omitempty" xml:"groupConfiguration,omitempty"`
	JoinConfigurations []*JoinConfiguration `json:"joinConfigurations,omitempty" xml:"joinConfigurations,omitempty" type:"Repeated"`
	Labels             []*AlertTag          `json:"labels,omitempty" xml:"labels,omitempty" type:"Repeated"`
	// example:
	//
	// 1698907508
	MuteUntil *int64 `json:"muteUntil,omitempty" xml:"muteUntil,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// false
	NoDataFire *bool `json:"noDataFire,omitempty" xml:"noDataFire,omitempty"`
	// example:
	//
	// 6
	NoDataSeverity      *int32               `json:"noDataSeverity,omitempty" xml:"noDataSeverity,omitempty"`
	PolicyConfiguration *PolicyConfiguration `json:"policyConfiguration,omitempty" xml:"policyConfiguration,omitempty"`
	// This parameter is required.
	QueryList []*AlertQuery `json:"queryList,omitempty" xml:"queryList,omitempty" type:"Repeated"`
	// This parameter is required.
	//
	// example:
	//
	// false
	SendResolved *bool `json:"sendResolved,omitempty" xml:"sendResolved,omitempty"`
	// This parameter is required.
	SeverityConfigurations []*SeverityConfiguration     `json:"severityConfigurations,omitempty" xml:"severityConfigurations,omitempty" type:"Repeated"`
	SinkAlerthub           *SinkAlerthubConfiguration   `json:"sinkAlerthub,omitempty" xml:"sinkAlerthub,omitempty"`
	SinkCms                *SinkCmsConfiguration        `json:"sinkCms,omitempty" xml:"sinkCms,omitempty"`
	SinkEventStore         *SinkEventStoreConfiguration `json:"sinkEventStore,omitempty" xml:"sinkEventStore,omitempty"`
	Tags                   []*string                    `json:"tags,omitempty" xml:"tags,omitempty" type:"Repeated"`
	TemplateConfiguration  *TemplateConfiguration       `json:"templateConfiguration,omitempty" xml:"templateConfiguration,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// 1
	Threshold *int32 `json:"threshold,omitempty" xml:"threshold,omitempty"`
	// example:
	//
	// default
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// 2.0
	Version *string `json:"version,omitempty" xml:"version,omitempty"`
}

func (s AlertConfiguration) String() string {
	return tea.Prettify(s)
}

func (s AlertConfiguration) GoString() string {
	return s.String()
}

func (s *AlertConfiguration) SetAnnotations(v []*AlertTag) *AlertConfiguration {
	s.Annotations = v
	return s
}

func (s *AlertConfiguration) SetAutoAnnotation(v bool) *AlertConfiguration {
	s.AutoAnnotation = &v
	return s
}

func (s *AlertConfiguration) SetConditionConfiguration(v *ConditionConfiguration) *AlertConfiguration {
	s.ConditionConfiguration = v
	return s
}

func (s *AlertConfiguration) SetDashboard(v string) *AlertConfiguration {
	s.Dashboard = &v
	return s
}

func (s *AlertConfiguration) SetGroupConfiguration(v *GroupConfiguration) *AlertConfiguration {
	s.GroupConfiguration = v
	return s
}

func (s *AlertConfiguration) SetJoinConfigurations(v []*JoinConfiguration) *AlertConfiguration {
	s.JoinConfigurations = v
	return s
}

func (s *AlertConfiguration) SetLabels(v []*AlertTag) *AlertConfiguration {
	s.Labels = v
	return s
}

func (s *AlertConfiguration) SetMuteUntil(v int64) *AlertConfiguration {
	s.MuteUntil = &v
	return s
}

func (s *AlertConfiguration) SetNoDataFire(v bool) *AlertConfiguration {
	s.NoDataFire = &v
	return s
}

func (s *AlertConfiguration) SetNoDataSeverity(v int32) *AlertConfiguration {
	s.NoDataSeverity = &v
	return s
}

func (s *AlertConfiguration) SetPolicyConfiguration(v *PolicyConfiguration) *AlertConfiguration {
	s.PolicyConfiguration = v
	return s
}

func (s *AlertConfiguration) SetQueryList(v []*AlertQuery) *AlertConfiguration {
	s.QueryList = v
	return s
}

func (s *AlertConfiguration) SetSendResolved(v bool) *AlertConfiguration {
	s.SendResolved = &v
	return s
}

func (s *AlertConfiguration) SetSeverityConfigurations(v []*SeverityConfiguration) *AlertConfiguration {
	s.SeverityConfigurations = v
	return s
}

func (s *AlertConfiguration) SetSinkAlerthub(v *SinkAlerthubConfiguration) *AlertConfiguration {
	s.SinkAlerthub = v
	return s
}

func (s *AlertConfiguration) SetSinkCms(v *SinkCmsConfiguration) *AlertConfiguration {
	s.SinkCms = v
	return s
}

func (s *AlertConfiguration) SetSinkEventStore(v *SinkEventStoreConfiguration) *AlertConfiguration {
	s.SinkEventStore = v
	return s
}

func (s *AlertConfiguration) SetTags(v []*string) *AlertConfiguration {
	s.Tags = v
	return s
}

func (s *AlertConfiguration) SetTemplateConfiguration(v *TemplateConfiguration) *AlertConfiguration {
	s.TemplateConfiguration = v
	return s
}

func (s *AlertConfiguration) SetThreshold(v int32) *AlertConfiguration {
	s.Threshold = &v
	return s
}

func (s *AlertConfiguration) SetType(v string) *AlertConfiguration {
	s.Type = &v
	return s
}

func (s *AlertConfiguration) SetVersion(v string) *AlertConfiguration {
	s.Version = &v
	return s
}

type AlertQuery struct {
	// example:
	//
	// chartExmaple
	ChartTitle *string `json:"chartTitle,omitempty" xml:"chartTitle,omitempty"`
	// example:
	//
	// dashboardExample
	DashboardId *string `json:"dashboardId,omitempty" xml:"dashboardId,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// now
	End *string `json:"end,omitempty" xml:"end,omitempty"`
	// example:
	//
	// auto
	PowerSqlMode *string `json:"powerSqlMode,omitempty" xml:"powerSqlMode,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// projectExample
	Project *string `json:"project,omitempty" xml:"project,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// 	- | select *
	Query *string `json:"query,omitempty" xml:"query,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// cn-hangzhou
	Region  *string `json:"region,omitempty" xml:"region,omitempty"`
	RoleArn *string `json:"roleArn,omitempty" xml:"roleArn,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// -5m
	Start *string `json:"start,omitempty" xml:"start,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// store Example
	Store *string `json:"store,omitempty" xml:"store,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// log
	StoreType *string `json:"storeType,omitempty" xml:"storeType,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// Relative
	TimeSpanType *string `json:"timeSpanType,omitempty" xml:"timeSpanType,omitempty"`
	Ui           *string `json:"ui,omitempty" xml:"ui,omitempty"`
}

func (s AlertQuery) String() string {
	return tea.Prettify(s)
}

func (s AlertQuery) GoString() string {
	return s.String()
}

func (s *AlertQuery) SetChartTitle(v string) *AlertQuery {
	s.ChartTitle = &v
	return s
}

func (s *AlertQuery) SetDashboardId(v string) *AlertQuery {
	s.DashboardId = &v
	return s
}

func (s *AlertQuery) SetEnd(v string) *AlertQuery {
	s.End = &v
	return s
}

func (s *AlertQuery) SetPowerSqlMode(v string) *AlertQuery {
	s.PowerSqlMode = &v
	return s
}

func (s *AlertQuery) SetProject(v string) *AlertQuery {
	s.Project = &v
	return s
}

func (s *AlertQuery) SetQuery(v string) *AlertQuery {
	s.Query = &v
	return s
}

func (s *AlertQuery) SetRegion(v string) *AlertQuery {
	s.Region = &v
	return s
}

func (s *AlertQuery) SetRoleArn(v string) *AlertQuery {
	s.RoleArn = &v
	return s
}

func (s *AlertQuery) SetStart(v string) *AlertQuery {
	s.Start = &v
	return s
}

func (s *AlertQuery) SetStore(v string) *AlertQuery {
	s.Store = &v
	return s
}

func (s *AlertQuery) SetStoreType(v string) *AlertQuery {
	s.StoreType = &v
	return s
}

func (s *AlertQuery) SetTimeSpanType(v string) *AlertQuery {
	s.TimeSpanType = &v
	return s
}

func (s *AlertQuery) SetUi(v string) *AlertQuery {
	s.Ui = &v
	return s
}

type AlertTag struct {
	// example:
	//
	// title
	Key *string `json:"key,omitempty" xml:"key,omitempty"`
	// example:
	//
	// example value
	Value *string `json:"value,omitempty" xml:"value,omitempty"`
}

func (s AlertTag) String() string {
	return tea.Prettify(s)
}

func (s AlertTag) GoString() string {
	return s.String()
}

func (s *AlertTag) SetKey(v string) *AlertTag {
	s.Key = &v
	return s
}

func (s *AlertTag) SetValue(v string) *AlertTag {
	s.Value = &v
	return s
}

type ConditionConfiguration struct {
	// example:
	//
	// cnt > 100
	Condition *string `json:"condition,omitempty" xml:"condition,omitempty"`
	// example:
	//
	// __count__ > 5
	CountCondition *string `json:"countCondition,omitempty" xml:"countCondition,omitempty"`
}

func (s ConditionConfiguration) String() string {
	return tea.Prettify(s)
}

func (s ConditionConfiguration) GoString() string {
	return s.String()
}

func (s *ConditionConfiguration) SetCondition(v string) *ConditionConfiguration {
	s.Condition = &v
	return s
}

func (s *ConditionConfiguration) SetCountCondition(v string) *ConditionConfiguration {
	s.CountCondition = &v
	return s
}

type ConsumeProcessor struct {
	// This parameter is required.
	Configuration *ConsumeProcessorConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty"`
	// example:
	//
	// 1717171200
	CreateTime *int64 `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// example:
	//
	// 过滤content字段
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// 字段过滤处理
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// consume-processor-1
	ProcessorName *string `json:"processorName,omitempty" xml:"processorName,omitempty"`
	// example:
	//
	// 1717171200
	UpdateTime *int64 `json:"updateTime,omitempty" xml:"updateTime,omitempty"`
}

func (s ConsumeProcessor) String() string {
	return tea.Prettify(s)
}

func (s ConsumeProcessor) GoString() string {
	return s.String()
}

func (s *ConsumeProcessor) SetConfiguration(v *ConsumeProcessorConfiguration) *ConsumeProcessor {
	s.Configuration = v
	return s
}

func (s *ConsumeProcessor) SetCreateTime(v int64) *ConsumeProcessor {
	s.CreateTime = &v
	return s
}

func (s *ConsumeProcessor) SetDescription(v string) *ConsumeProcessor {
	s.Description = &v
	return s
}

func (s *ConsumeProcessor) SetDisplayName(v string) *ConsumeProcessor {
	s.DisplayName = &v
	return s
}

func (s *ConsumeProcessor) SetProcessorName(v string) *ConsumeProcessor {
	s.ProcessorName = &v
	return s
}

func (s *ConsumeProcessor) SetUpdateTime(v int64) *ConsumeProcessor {
	s.UpdateTime = &v
	return s
}

type ConsumeProcessorConfiguration struct {
	// This parameter is required.
	//
	// example:
	//
	// 	- | project content
	Spl *string `json:"spl,omitempty" xml:"spl,omitempty"`
}

func (s ConsumeProcessorConfiguration) String() string {
	return tea.Prettify(s)
}

func (s ConsumeProcessorConfiguration) GoString() string {
	return s.String()
}

func (s *ConsumeProcessorConfiguration) SetSpl(v string) *ConsumeProcessorConfiguration {
	s.Spl = &v
	return s
}

type ConsumerGroup struct {
	// example:
	//
	// test-group
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// example:
	//
	// false
	Order *bool `json:"order,omitempty" xml:"order,omitempty"`
	// example:
	//
	// 300
	Timeout *int32 `json:"timeout,omitempty" xml:"timeout,omitempty"`
}

func (s ConsumerGroup) String() string {
	return tea.Prettify(s)
}

func (s ConsumerGroup) GoString() string {
	return s.String()
}

func (s *ConsumerGroup) SetName(v string) *ConsumerGroup {
	s.Name = &v
	return s
}

func (s *ConsumerGroup) SetOrder(v bool) *ConsumerGroup {
	s.Order = &v
	return s
}

func (s *ConsumerGroup) SetTimeout(v int32) *ConsumerGroup {
	s.Timeout = &v
	return s
}

type CopilotAction struct {
	Action                  *string                                 `json:"action,omitempty" xml:"action,omitempty"`
	Description             *string                                 `json:"description,omitempty" xml:"description,omitempty"`
	Name                    *string                                 `json:"name,omitempty" xml:"name,omitempty"`
	Parameters              []*CopilotActionParameters              `json:"parameters,omitempty" xml:"parameters,omitempty" type:"Repeated"`
	QueryTemplate           *string                                 `json:"queryTemplate,omitempty" xml:"queryTemplate,omitempty"`
	QueryTemplateParameters []*CopilotActionQueryTemplateParameters `json:"queryTemplateParameters,omitempty" xml:"queryTemplateParameters,omitempty" type:"Repeated"`
	Scene                   *string                                 `json:"scene,omitempty" xml:"scene,omitempty"`
}

func (s CopilotAction) String() string {
	return tea.Prettify(s)
}

func (s CopilotAction) GoString() string {
	return s.String()
}

func (s *CopilotAction) SetAction(v string) *CopilotAction {
	s.Action = &v
	return s
}

func (s *CopilotAction) SetDescription(v string) *CopilotAction {
	s.Description = &v
	return s
}

func (s *CopilotAction) SetName(v string) *CopilotAction {
	s.Name = &v
	return s
}

func (s *CopilotAction) SetParameters(v []*CopilotActionParameters) *CopilotAction {
	s.Parameters = v
	return s
}

func (s *CopilotAction) SetQueryTemplate(v string) *CopilotAction {
	s.QueryTemplate = &v
	return s
}

func (s *CopilotAction) SetQueryTemplateParameters(v []*CopilotActionQueryTemplateParameters) *CopilotAction {
	s.QueryTemplateParameters = v
	return s
}

func (s *CopilotAction) SetScene(v string) *CopilotAction {
	s.Scene = &v
	return s
}

type CopilotActionParameters struct {
	Name     *string `json:"name,omitempty" xml:"name,omitempty"`
	Prompt   *string `json:"prompt,omitempty" xml:"prompt,omitempty"`
	Required *string `json:"required,omitempty" xml:"required,omitempty"`
	Type     *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s CopilotActionParameters) String() string {
	return tea.Prettify(s)
}

func (s CopilotActionParameters) GoString() string {
	return s.String()
}

func (s *CopilotActionParameters) SetName(v string) *CopilotActionParameters {
	s.Name = &v
	return s
}

func (s *CopilotActionParameters) SetPrompt(v string) *CopilotActionParameters {
	s.Prompt = &v
	return s
}

func (s *CopilotActionParameters) SetRequired(v string) *CopilotActionParameters {
	s.Required = &v
	return s
}

func (s *CopilotActionParameters) SetType(v string) *CopilotActionParameters {
	s.Type = &v
	return s
}

type CopilotActionQueryTemplateParameters struct {
	Name     *string `json:"name,omitempty" xml:"name,omitempty"`
	Prompt   *string `json:"prompt,omitempty" xml:"prompt,omitempty"`
	Required *string `json:"required,omitempty" xml:"required,omitempty"`
	Type     *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s CopilotActionQueryTemplateParameters) String() string {
	return tea.Prettify(s)
}

func (s CopilotActionQueryTemplateParameters) GoString() string {
	return s.String()
}

func (s *CopilotActionQueryTemplateParameters) SetName(v string) *CopilotActionQueryTemplateParameters {
	s.Name = &v
	return s
}

func (s *CopilotActionQueryTemplateParameters) SetPrompt(v string) *CopilotActionQueryTemplateParameters {
	s.Prompt = &v
	return s
}

func (s *CopilotActionQueryTemplateParameters) SetRequired(v string) *CopilotActionQueryTemplateParameters {
	s.Required = &v
	return s
}

func (s *CopilotActionQueryTemplateParameters) SetType(v string) *CopilotActionQueryTemplateParameters {
	s.Type = &v
	return s
}

type ETL struct {
	// This parameter is required.
	Configuration *ETLConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty"`
	// example:
	//
	// 1714274900
	CreateTime *int64 `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// example:
	//
	// 加工作业
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// etljob
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// example:
	//
	// 1714274900
	LastModifiedTime *int64 `json:"lastModifiedTime,omitempty" xml:"lastModifiedTime,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// etl-20240426
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// example:
	//
	// f0eb655e501a8780808d1970ef6d04c4
	ScheduleId *string `json:"scheduleId,omitempty" xml:"scheduleId,omitempty"`
	// example:
	//
	// RUNNING
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s ETL) String() string {
	return tea.Prettify(s)
}

func (s ETL) GoString() string {
	return s.String()
}

func (s *ETL) SetConfiguration(v *ETLConfiguration) *ETL {
	s.Configuration = v
	return s
}

func (s *ETL) SetCreateTime(v int64) *ETL {
	s.CreateTime = &v
	return s
}

func (s *ETL) SetDescription(v string) *ETL {
	s.Description = &v
	return s
}

func (s *ETL) SetDisplayName(v string) *ETL {
	s.DisplayName = &v
	return s
}

func (s *ETL) SetLastModifiedTime(v int64) *ETL {
	s.LastModifiedTime = &v
	return s
}

func (s *ETL) SetName(v string) *ETL {
	s.Name = &v
	return s
}

func (s *ETL) SetScheduleId(v string) *ETL {
	s.ScheduleId = &v
	return s
}

func (s *ETL) SetStatus(v string) *ETL {
	s.Status = &v
	return s
}

type ETLConfiguration struct {
	// Deprecated
	AccessKeyId *string `json:"accessKeyId,omitempty" xml:"accessKeyId,omitempty"`
	// Deprecated
	AccessKeySecret *string `json:"accessKeySecret,omitempty" xml:"accessKeySecret,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// 1714274900
	FromTime *int64 `json:"fromTime,omitempty" xml:"fromTime,omitempty"`
	// example:
	//
	// SPL
	Lang *string `json:"lang,omitempty" xml:"lang,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// test-logstore
	Logstore *string `json:"logstore,omitempty" xml:"logstore,omitempty"`
	// example:
	//
	// config.vpc.vpc_id.test1：vpc-uf6mskb0b****n9yj
	Parameters map[string]interface{} `json:"parameters,omitempty" xml:"parameters,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// acs:ram::13234:role/logtarget
	RoleArn *string `json:"roleArn,omitempty" xml:"roleArn,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// e_set("key","value")
	Script *string `json:"script,omitempty" xml:"script,omitempty"`
	// This parameter is required.
	Sinks []*ETLConfigurationSink `json:"sinks,omitempty" xml:"sinks,omitempty" type:"Repeated"`
	// This parameter is required.
	//
	// example:
	//
	// 1714274970
	ToTime *int64 `json:"toTime,omitempty" xml:"toTime,omitempty"`
}

func (s ETLConfiguration) String() string {
	return tea.Prettify(s)
}

func (s ETLConfiguration) GoString() string {
	return s.String()
}

func (s *ETLConfiguration) SetAccessKeyId(v string) *ETLConfiguration {
	s.AccessKeyId = &v
	return s
}

func (s *ETLConfiguration) SetAccessKeySecret(v string) *ETLConfiguration {
	s.AccessKeySecret = &v
	return s
}

func (s *ETLConfiguration) SetFromTime(v int64) *ETLConfiguration {
	s.FromTime = &v
	return s
}

func (s *ETLConfiguration) SetLang(v string) *ETLConfiguration {
	s.Lang = &v
	return s
}

func (s *ETLConfiguration) SetLogstore(v string) *ETLConfiguration {
	s.Logstore = &v
	return s
}

func (s *ETLConfiguration) SetParameters(v map[string]interface{}) *ETLConfiguration {
	s.Parameters = v
	return s
}

func (s *ETLConfiguration) SetRoleArn(v string) *ETLConfiguration {
	s.RoleArn = &v
	return s
}

func (s *ETLConfiguration) SetScript(v string) *ETLConfiguration {
	s.Script = &v
	return s
}

func (s *ETLConfiguration) SetSinks(v []*ETLConfigurationSink) *ETLConfiguration {
	s.Sinks = v
	return s
}

func (s *ETLConfiguration) SetToTime(v int64) *ETLConfiguration {
	s.ToTime = &v
	return s
}

type ETLConfigurationSink struct {
	// Deprecated
	AccessKeyId *string `json:"accessKeyId,omitempty" xml:"accessKeyId,omitempty"`
	// Deprecated
	AccessKeySecret *string   `json:"accessKeySecret,omitempty" xml:"accessKeySecret,omitempty"`
	Datasets        []*string `json:"datasets,omitempty" xml:"datasets,omitempty" type:"Repeated"`
	Endpoint        *string   `json:"endpoint,omitempty" xml:"endpoint,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// test-logstore
	Logstore *string `json:"logstore,omitempty" xml:"logstore,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// test-etljob
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// test-project
	Project *string `json:"project,omitempty" xml:"project,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// acs:ram::13234:role/logtarget
	RoleArn *string `json:"roleArn,omitempty" xml:"roleArn,omitempty"`
}

func (s ETLConfigurationSink) String() string {
	return tea.Prettify(s)
}

func (s ETLConfigurationSink) GoString() string {
	return s.String()
}

func (s *ETLConfigurationSink) SetAccessKeyId(v string) *ETLConfigurationSink {
	s.AccessKeyId = &v
	return s
}

func (s *ETLConfigurationSink) SetAccessKeySecret(v string) *ETLConfigurationSink {
	s.AccessKeySecret = &v
	return s
}

func (s *ETLConfigurationSink) SetDatasets(v []*string) *ETLConfigurationSink {
	s.Datasets = v
	return s
}

func (s *ETLConfigurationSink) SetEndpoint(v string) *ETLConfigurationSink {
	s.Endpoint = &v
	return s
}

func (s *ETLConfigurationSink) SetLogstore(v string) *ETLConfigurationSink {
	s.Logstore = &v
	return s
}

func (s *ETLConfigurationSink) SetName(v string) *ETLConfigurationSink {
	s.Name = &v
	return s
}

func (s *ETLConfigurationSink) SetProject(v string) *ETLConfigurationSink {
	s.Project = &v
	return s
}

func (s *ETLConfigurationSink) SetRoleArn(v string) *ETLConfigurationSink {
	s.RoleArn = &v
	return s
}

type EncryptConf struct {
	// This parameter is required.
	Enable *bool `json:"enable,omitempty" xml:"enable,omitempty"`
	// example:
	//
	// default
	EncryptType *string             `json:"encrypt_type,omitempty" xml:"encrypt_type,omitempty"`
	UserCmkInfo *EncryptUserCmkConf `json:"user_cmk_info,omitempty" xml:"user_cmk_info,omitempty"`
}

func (s EncryptConf) String() string {
	return tea.Prettify(s)
}

func (s EncryptConf) GoString() string {
	return s.String()
}

func (s *EncryptConf) SetEnable(v bool) *EncryptConf {
	s.Enable = &v
	return s
}

func (s *EncryptConf) SetEncryptType(v string) *EncryptConf {
	s.EncryptType = &v
	return s
}

func (s *EncryptConf) SetUserCmkInfo(v *EncryptUserCmkConf) *EncryptConf {
	s.UserCmkInfo = v
	return s
}

type EncryptUserCmkConf struct {
	// This parameter is required.
	Arn *string `json:"arn,omitempty" xml:"arn,omitempty"`
	// This parameter is required.
	CmkKeyId *string `json:"cmk_key_id,omitempty" xml:"cmk_key_id,omitempty"`
	// This parameter is required.
	RegionId *string `json:"region_id,omitempty" xml:"region_id,omitempty"`
}

func (s EncryptUserCmkConf) String() string {
	return tea.Prettify(s)
}

func (s EncryptUserCmkConf) GoString() string {
	return s.String()
}

func (s *EncryptUserCmkConf) SetArn(v string) *EncryptUserCmkConf {
	s.Arn = &v
	return s
}

func (s *EncryptUserCmkConf) SetCmkKeyId(v string) *EncryptUserCmkConf {
	s.CmkKeyId = &v
	return s
}

func (s *EncryptUserCmkConf) SetRegionId(v string) *EncryptUserCmkConf {
	s.RegionId = &v
	return s
}

type GroupConfiguration struct {
	Fields []*string `json:"fields,omitempty" xml:"fields,omitempty" type:"Repeated"`
	// This parameter is required.
	//
	// example:
	//
	// custom
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s GroupConfiguration) String() string {
	return tea.Prettify(s)
}

func (s GroupConfiguration) GoString() string {
	return s.String()
}

func (s *GroupConfiguration) SetFields(v []*string) *GroupConfiguration {
	s.Fields = v
	return s
}

func (s *GroupConfiguration) SetType(v string) *GroupConfiguration {
	s.Type = &v
	return s
}

type Histogram struct {
	Count    *int64  `json:"count,omitempty" xml:"count,omitempty"`
	From     *int32  `json:"from,omitempty" xml:"from,omitempty"`
	Progress *string `json:"progress,omitempty" xml:"progress,omitempty"`
	To       *int32  `json:"to,omitempty" xml:"to,omitempty"`
}

func (s Histogram) String() string {
	return tea.Prettify(s)
}

func (s Histogram) GoString() string {
	return s.String()
}

func (s *Histogram) SetCount(v int64) *Histogram {
	s.Count = &v
	return s
}

func (s *Histogram) SetFrom(v int32) *Histogram {
	s.From = &v
	return s
}

func (s *Histogram) SetProgress(v string) *Histogram {
	s.Progress = &v
	return s
}

func (s *Histogram) SetTo(v int32) *Histogram {
	s.To = &v
	return s
}

type IndexJsonKey struct {
	// example:
	//
	// myAlias
	Alias *string `json:"alias,omitempty" xml:"alias,omitempty"`
	// example:
	//
	// true
	CaseSensitive *bool `json:"caseSensitive,omitempty" xml:"caseSensitive,omitempty"`
	// example:
	//
	// true
	Chn *bool `json:"chn,omitempty" xml:"chn,omitempty"`
	// example:
	//
	// true
	DocValue *bool     `json:"doc_value,omitempty" xml:"doc_value,omitempty"`
	Token    []*string `json:"token,omitempty" xml:"token,omitempty" type:"Repeated"`
	// This parameter is required.
	//
	// example:
	//
	// text
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s IndexJsonKey) String() string {
	return tea.Prettify(s)
}

func (s IndexJsonKey) GoString() string {
	return s.String()
}

func (s *IndexJsonKey) SetAlias(v string) *IndexJsonKey {
	s.Alias = &v
	return s
}

func (s *IndexJsonKey) SetCaseSensitive(v bool) *IndexJsonKey {
	s.CaseSensitive = &v
	return s
}

func (s *IndexJsonKey) SetChn(v bool) *IndexJsonKey {
	s.Chn = &v
	return s
}

func (s *IndexJsonKey) SetDocValue(v bool) *IndexJsonKey {
	s.DocValue = &v
	return s
}

func (s *IndexJsonKey) SetToken(v []*string) *IndexJsonKey {
	s.Token = v
	return s
}

func (s *IndexJsonKey) SetType(v string) *IndexJsonKey {
	s.Type = &v
	return s
}

type IndexKey struct {
	// example:
	//
	// myAlias
	Alias *string `json:"alias,omitempty" xml:"alias,omitempty"`
	// example:
	//
	// true
	CaseSensitive *bool `json:"caseSensitive,omitempty" xml:"caseSensitive,omitempty"`
	// example:
	//
	// true
	Chn *bool `json:"chn,omitempty" xml:"chn,omitempty"`
	// example:
	//
	// true
	DocValue *bool `json:"doc_value,omitempty" xml:"doc_value,omitempty"`
	// example:
	//
	// true
	IndexAll *bool                    `json:"index_all,omitempty" xml:"index_all,omitempty"`
	JsonKeys map[string]*IndexJsonKey `json:"json_keys,omitempty" xml:"json_keys,omitempty"`
	MaxDepth *int64                   `json:"max_depth,omitempty" xml:"max_depth,omitempty"`
	Token    []*string                `json:"token,omitempty" xml:"token,omitempty" type:"Repeated"`
	// This parameter is required.
	//
	// example:
	//
	// text
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s IndexKey) String() string {
	return tea.Prettify(s)
}

func (s IndexKey) GoString() string {
	return s.String()
}

func (s *IndexKey) SetAlias(v string) *IndexKey {
	s.Alias = &v
	return s
}

func (s *IndexKey) SetCaseSensitive(v bool) *IndexKey {
	s.CaseSensitive = &v
	return s
}

func (s *IndexKey) SetChn(v bool) *IndexKey {
	s.Chn = &v
	return s
}

func (s *IndexKey) SetDocValue(v bool) *IndexKey {
	s.DocValue = &v
	return s
}

func (s *IndexKey) SetIndexAll(v bool) *IndexKey {
	s.IndexAll = &v
	return s
}

func (s *IndexKey) SetJsonKeys(v map[string]*IndexJsonKey) *IndexKey {
	s.JsonKeys = v
	return s
}

func (s *IndexKey) SetMaxDepth(v int64) *IndexKey {
	s.MaxDepth = &v
	return s
}

func (s *IndexKey) SetToken(v []*string) *IndexKey {
	s.Token = v
	return s
}

func (s *IndexKey) SetType(v string) *IndexKey {
	s.Type = &v
	return s
}

type IngestProcessor struct {
	// This parameter is required.
	Configuration *IngestProcessorConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty"`
	// example:
	//
	// 1717171200
	CreateTime *int64 `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// example:
	//
	// 过滤content字段
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// 字段过滤处理
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// ingest-processor-1
	ProcessorName *string `json:"processorName,omitempty" xml:"processorName,omitempty"`
	// example:
	//
	// 1717171200
	UpdateTime *int64 `json:"updateTime,omitempty" xml:"updateTime,omitempty"`
}

func (s IngestProcessor) String() string {
	return tea.Prettify(s)
}

func (s IngestProcessor) GoString() string {
	return s.String()
}

func (s *IngestProcessor) SetConfiguration(v *IngestProcessorConfiguration) *IngestProcessor {
	s.Configuration = v
	return s
}

func (s *IngestProcessor) SetCreateTime(v int64) *IngestProcessor {
	s.CreateTime = &v
	return s
}

func (s *IngestProcessor) SetDescription(v string) *IngestProcessor {
	s.Description = &v
	return s
}

func (s *IngestProcessor) SetDisplayName(v string) *IngestProcessor {
	s.DisplayName = &v
	return s
}

func (s *IngestProcessor) SetProcessorName(v string) *IngestProcessor {
	s.ProcessorName = &v
	return s
}

func (s *IngestProcessor) SetUpdateTime(v int64) *IngestProcessor {
	s.UpdateTime = &v
	return s
}

type IngestProcessorConfiguration struct {
	// example:
	//
	// keep
	ParseFail *string `json:"parseFail,omitempty" xml:"parseFail,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// 	- | project content
	Spl *string `json:"spl,omitempty" xml:"spl,omitempty"`
}

func (s IngestProcessorConfiguration) String() string {
	return tea.Prettify(s)
}

func (s IngestProcessorConfiguration) GoString() string {
	return s.String()
}

func (s *IngestProcessorConfiguration) SetParseFail(v string) *IngestProcessorConfiguration {
	s.ParseFail = &v
	return s
}

func (s *IngestProcessorConfiguration) SetSpl(v string) *IngestProcessorConfiguration {
	s.Spl = &v
	return s
}

type JoinConfiguration struct {
	// example:
	//
	// $0.id == $1.id
	Condition *string `json:"condition,omitempty" xml:"condition,omitempty"`
	// example:
	//
	// left_join
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s JoinConfiguration) String() string {
	return tea.Prettify(s)
}

func (s JoinConfiguration) GoString() string {
	return s.String()
}

func (s *JoinConfiguration) SetCondition(v string) *JoinConfiguration {
	s.Condition = &v
	return s
}

func (s *JoinConfiguration) SetType(v string) *JoinConfiguration {
	s.Type = &v
	return s
}

type LogContent struct {
	// This parameter is required.
	//
	// example:
	//
	// key-test
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// value-test
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s LogContent) String() string {
	return tea.Prettify(s)
}

func (s LogContent) GoString() string {
	return s.String()
}

func (s *LogContent) SetKey(v string) *LogContent {
	s.Key = &v
	return s
}

func (s *LogContent) SetValue(v string) *LogContent {
	s.Value = &v
	return s
}

type LogGroup struct {
	// This parameter is required.
	LogItems []*LogItem `json:"LogItems,omitempty" xml:"LogItems,omitempty" type:"Repeated"`
	LogTags  []*LogTag  `json:"LogTags,omitempty" xml:"LogTags,omitempty" type:"Repeated"`
	// example:
	//
	// 192.1.1.1
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// example:
	//
	// topic-test
	Topic *string `json:"Topic,omitempty" xml:"Topic,omitempty"`
}

func (s LogGroup) String() string {
	return tea.Prettify(s)
}

func (s LogGroup) GoString() string {
	return s.String()
}

func (s *LogGroup) SetLogItems(v []*LogItem) *LogGroup {
	s.LogItems = v
	return s
}

func (s *LogGroup) SetLogTags(v []*LogTag) *LogGroup {
	s.LogTags = v
	return s
}

func (s *LogGroup) SetSource(v string) *LogGroup {
	s.Source = &v
	return s
}

func (s *LogGroup) SetTopic(v string) *LogGroup {
	s.Topic = &v
	return s
}

type LogGroupList struct {
	// This parameter is required.
	LogGroupList []*LogGroup `json:"logGroupList,omitempty" xml:"logGroupList,omitempty" type:"Repeated"`
}

func (s LogGroupList) String() string {
	return tea.Prettify(s)
}

func (s LogGroupList) GoString() string {
	return s.String()
}

func (s *LogGroupList) SetLogGroupList(v []*LogGroup) *LogGroupList {
	s.LogGroupList = v
	return s
}

type LogItem struct {
	// This parameter is required.
	Contents []*LogContent `json:"Contents,omitempty" xml:"Contents,omitempty" type:"Repeated"`
	// This parameter is required.
	//
	// example:
	//
	// 1690254376
	Time *int32 `json:"Time,omitempty" xml:"Time,omitempty"`
}

func (s LogItem) String() string {
	return tea.Prettify(s)
}

func (s LogItem) GoString() string {
	return s.String()
}

func (s *LogItem) SetContents(v []*LogContent) *LogItem {
	s.Contents = v
	return s
}

func (s *LogItem) SetTime(v int32) *LogItem {
	s.Time = &v
	return s
}

type LogTag struct {
	// This parameter is required.
	//
	// example:
	//
	// key-test
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// value-test
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s LogTag) String() string {
	return tea.Prettify(s)
}

func (s LogTag) GoString() string {
	return s.String()
}

func (s *LogTag) SetKey(v string) *LogTag {
	s.Key = &v
	return s
}

func (s *LogTag) SetValue(v string) *LogTag {
	s.Value = &v
	return s
}

type LogtailConfig struct {
	// This parameter is required.
	//
	// example:
	//
	// test-config
	ConfigName *string `json:"configName,omitempty" xml:"configName,omitempty"`
	// example:
	//
	// 1655176807
	CreateTime *int64 `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// This parameter is required.
	InputDetail map[string]interface{} `json:"inputDetail,omitempty" xml:"inputDetail,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// file
	InputType *string `json:"inputType,omitempty" xml:"inputType,omitempty"`
	// example:
	//
	// 1655176807
	LastModifyTime *int64 `json:"lastModifyTime,omitempty" xml:"lastModifyTime,omitempty"`
	// example:
	//
	// 2022-06-14 11:13:29.796 | DEBUG    | __main__:<module>:1 - hello world
	LogSample *string `json:"logSample,omitempty" xml:"logSample,omitempty"`
	// This parameter is required.
	OutputDetail *LogtailConfigOutputDetail `json:"outputDetail,omitempty" xml:"outputDetail,omitempty" type:"Struct"`
	// This parameter is required.
	//
	// example:
	//
	// LogService
	OutputType *string `json:"outputType,omitempty" xml:"outputType,omitempty"`
}

func (s LogtailConfig) String() string {
	return tea.Prettify(s)
}

func (s LogtailConfig) GoString() string {
	return s.String()
}

func (s *LogtailConfig) SetConfigName(v string) *LogtailConfig {
	s.ConfigName = &v
	return s
}

func (s *LogtailConfig) SetCreateTime(v int64) *LogtailConfig {
	s.CreateTime = &v
	return s
}

func (s *LogtailConfig) SetInputDetail(v map[string]interface{}) *LogtailConfig {
	s.InputDetail = v
	return s
}

func (s *LogtailConfig) SetInputType(v string) *LogtailConfig {
	s.InputType = &v
	return s
}

func (s *LogtailConfig) SetLastModifyTime(v int64) *LogtailConfig {
	s.LastModifyTime = &v
	return s
}

func (s *LogtailConfig) SetLogSample(v string) *LogtailConfig {
	s.LogSample = &v
	return s
}

func (s *LogtailConfig) SetOutputDetail(v *LogtailConfigOutputDetail) *LogtailConfig {
	s.OutputDetail = v
	return s
}

func (s *LogtailConfig) SetOutputType(v string) *LogtailConfig {
	s.OutputType = &v
	return s
}

type LogtailConfigOutputDetail struct {
	// This parameter is required.
	//
	// example:
	//
	// cn-hangzhou-intranet.log.aliyuncs.com
	Endpoint *string `json:"endpoint,omitempty" xml:"endpoint,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// test-logstore
	LogstoreName *string `json:"logstoreName,omitempty" xml:"logstoreName,omitempty"`
	// example:
	//
	// cn-hangzhou
	Region *string `json:"region,omitempty" xml:"region,omitempty"`
	// example:
	//
	// logs
	TelemetryType *string `json:"telemetryType,omitempty" xml:"telemetryType,omitempty"`
}

func (s LogtailConfigOutputDetail) String() string {
	return tea.Prettify(s)
}

func (s LogtailConfigOutputDetail) GoString() string {
	return s.String()
}

func (s *LogtailConfigOutputDetail) SetEndpoint(v string) *LogtailConfigOutputDetail {
	s.Endpoint = &v
	return s
}

func (s *LogtailConfigOutputDetail) SetLogstoreName(v string) *LogtailConfigOutputDetail {
	s.LogstoreName = &v
	return s
}

func (s *LogtailConfigOutputDetail) SetRegion(v string) *LogtailConfigOutputDetail {
	s.Region = &v
	return s
}

func (s *LogtailConfigOutputDetail) SetTelemetryType(v string) *LogtailConfigOutputDetail {
	s.TelemetryType = &v
	return s
}

type LogtailPipelineConfig struct {
	Aggregators []map[string]interface{} `json:"aggregators,omitempty" xml:"aggregators,omitempty" type:"Repeated"`
	// This parameter is required.
	//
	// example:
	//
	// test-config
	ConfigName *string `json:"configName,omitempty" xml:"configName,omitempty"`
	// example:
	//
	// 1655176807
	CreateTime *int64 `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// This parameter is required.
	Flushers []map[string]interface{} `json:"flushers,omitempty" xml:"flushers,omitempty" type:"Repeated"`
	Global   map[string]interface{}   `json:"global,omitempty" xml:"global,omitempty"`
	// This parameter is required.
	Inputs []map[string]interface{} `json:"inputs,omitempty" xml:"inputs,omitempty" type:"Repeated"`
	// example:
	//
	// 1655176807
	LastModifyTime *int64 `json:"lastModifyTime,omitempty" xml:"lastModifyTime,omitempty"`
	// example:
	//
	// 127.0.0.1 - - [10/Jun/2022:12:36:49 +0800] "GET /index.html HTTP/1.1" 200
	LogSample  *string                  `json:"logSample,omitempty" xml:"logSample,omitempty"`
	Processors []map[string]interface{} `json:"processors,omitempty" xml:"processors,omitempty" type:"Repeated"`
}

func (s LogtailPipelineConfig) String() string {
	return tea.Prettify(s)
}

func (s LogtailPipelineConfig) GoString() string {
	return s.String()
}

func (s *LogtailPipelineConfig) SetAggregators(v []map[string]interface{}) *LogtailPipelineConfig {
	s.Aggregators = v
	return s
}

func (s *LogtailPipelineConfig) SetConfigName(v string) *LogtailPipelineConfig {
	s.ConfigName = &v
	return s
}

func (s *LogtailPipelineConfig) SetCreateTime(v int64) *LogtailPipelineConfig {
	s.CreateTime = &v
	return s
}

func (s *LogtailPipelineConfig) SetFlushers(v []map[string]interface{}) *LogtailPipelineConfig {
	s.Flushers = v
	return s
}

func (s *LogtailPipelineConfig) SetGlobal(v map[string]interface{}) *LogtailPipelineConfig {
	s.Global = v
	return s
}

func (s *LogtailPipelineConfig) SetInputs(v []map[string]interface{}) *LogtailPipelineConfig {
	s.Inputs = v
	return s
}

func (s *LogtailPipelineConfig) SetLastModifyTime(v int64) *LogtailPipelineConfig {
	s.LastModifyTime = &v
	return s
}

func (s *LogtailPipelineConfig) SetLogSample(v string) *LogtailPipelineConfig {
	s.LogSample = &v
	return s
}

func (s *LogtailPipelineConfig) SetProcessors(v []map[string]interface{}) *LogtailPipelineConfig {
	s.Processors = v
	return s
}

type MLDataParam struct {
	// example:
	//
	// dc74b0f569126bb310e1ba6454c351ac
	AnnotationdataId *string                                 `json:"annotationdataId,omitempty" xml:"annotationdataId,omitempty"`
	Annotations      map[string]*MLDataParamAnnotationsValue `json:"annotations,omitempty" xml:"annotations,omitempty"`
	Config           map[string]*string                      `json:"config,omitempty" xml:"config,omitempty"`
	// example:
	//
	// 1695094335
	CreateTime *int64 `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// example:
	//
	// 59db060bd89468245d76416a68a510ac
	DataHash *string `json:"dataHash,omitempty" xml:"dataHash,omitempty"`
	// example:
	//
	// a9bd488f6dd42d294495fb780858e83d
	DatasetId *string `json:"datasetId,omitempty" xml:"datasetId,omitempty"`
	// example:
	//
	// 1695094335
	LastModifyTime *int64                                  `json:"lastModifyTime,omitempty" xml:"lastModifyTime,omitempty"`
	Predictions    map[string]*MLDataParamPredictionsValue `json:"predictions,omitempty" xml:"predictions,omitempty"`
	// example:
	//
	// xxx/xxx/xxx/
	Value *string `json:"value,omitempty" xml:"value,omitempty"`
	// example:
	//
	// oss
	ValueType *string `json:"valueType,omitempty" xml:"valueType,omitempty"`
}

func (s MLDataParam) String() string {
	return tea.Prettify(s)
}

func (s MLDataParam) GoString() string {
	return s.String()
}

func (s *MLDataParam) SetAnnotationdataId(v string) *MLDataParam {
	s.AnnotationdataId = &v
	return s
}

func (s *MLDataParam) SetAnnotations(v map[string]*MLDataParamAnnotationsValue) *MLDataParam {
	s.Annotations = v
	return s
}

func (s *MLDataParam) SetConfig(v map[string]*string) *MLDataParam {
	s.Config = v
	return s
}

func (s *MLDataParam) SetCreateTime(v int64) *MLDataParam {
	s.CreateTime = &v
	return s
}

func (s *MLDataParam) SetDataHash(v string) *MLDataParam {
	s.DataHash = &v
	return s
}

func (s *MLDataParam) SetDatasetId(v string) *MLDataParam {
	s.DatasetId = &v
	return s
}

func (s *MLDataParam) SetLastModifyTime(v int64) *MLDataParam {
	s.LastModifyTime = &v
	return s
}

func (s *MLDataParam) SetPredictions(v map[string]*MLDataParamPredictionsValue) *MLDataParam {
	s.Predictions = v
	return s
}

func (s *MLDataParam) SetValue(v string) *MLDataParam {
	s.Value = &v
	return s
}

func (s *MLDataParam) SetValueType(v string) *MLDataParam {
	s.ValueType = &v
	return s
}

type MLDataSetParam struct {
	// example:
	//
	// sls-console
	CreateBy *string `json:"createBy,omitempty" xml:"createBy,omitempty"`
	// example:
	//
	// 1695090077
	CreateTime *int64 `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// example:
	//
	// Metric
	DataType *string `json:"dataType,omitempty" xml:"dataType,omitempty"`
	// example:
	//
	// d9bd488f6dd42d294495fb780858e83d
	DatasetId *string `json:"datasetId,omitempty" xml:"datasetId,omitempty"`
	// example:
	//
	// 数据集A
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// example:
	//
	// a191ae4ca615b0ccb93c211fc8a998af
	LabelId *string `json:"labelId,omitempty" xml:"labelId,omitempty"`
	// example:
	//
	// 1695090077
	LastModifyTime *int64 `json:"lastModifyTime,omitempty" xml:"lastModifyTime,omitempty"`
	// example:
	//
	// sls_builtin_dataset_metric.shapeclassification.anomalydetection
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// example:
	//
	// Metric.ShapeClassification.AnomalyDetection
	SettingType *string `json:"settingType,omitempty" xml:"settingType,omitempty"`
}

func (s MLDataSetParam) String() string {
	return tea.Prettify(s)
}

func (s MLDataSetParam) GoString() string {
	return s.String()
}

func (s *MLDataSetParam) SetCreateBy(v string) *MLDataSetParam {
	s.CreateBy = &v
	return s
}

func (s *MLDataSetParam) SetCreateTime(v int64) *MLDataSetParam {
	s.CreateTime = &v
	return s
}

func (s *MLDataSetParam) SetDataType(v string) *MLDataSetParam {
	s.DataType = &v
	return s
}

func (s *MLDataSetParam) SetDatasetId(v string) *MLDataSetParam {
	s.DatasetId = &v
	return s
}

func (s *MLDataSetParam) SetDescription(v string) *MLDataSetParam {
	s.Description = &v
	return s
}

func (s *MLDataSetParam) SetLabelId(v string) *MLDataSetParam {
	s.LabelId = &v
	return s
}

func (s *MLDataSetParam) SetLastModifyTime(v int64) *MLDataSetParam {
	s.LastModifyTime = &v
	return s
}

func (s *MLDataSetParam) SetName(v string) *MLDataSetParam {
	s.Name = &v
	return s
}

func (s *MLDataSetParam) SetSettingType(v string) *MLDataSetParam {
	s.SettingType = &v
	return s
}

type MLLabelParam struct {
	// example:
	//
	// 1695090077
	CreateTime *int64 `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// example:
	//
	// 默认表
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// example:
	//
	// abbd488f6dd42d294495fb780858e83d
	LabelId *string `json:"labelId,omitempty" xml:"labelId,omitempty"`
	// example:
	//
	// 1695090077
	LastModifyTime *int64 `json:"lastModifyTime,omitempty" xml:"lastModifyTime,omitempty"`
	// example:
	//
	// 标签表
	Name     *string                 `json:"name,omitempty" xml:"name,omitempty"`
	Settings []*MLLabelParamSettings `json:"settings,omitempty" xml:"settings,omitempty" type:"Repeated"`
	// example:
	//
	// xxx
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s MLLabelParam) String() string {
	return tea.Prettify(s)
}

func (s MLLabelParam) GoString() string {
	return s.String()
}

func (s *MLLabelParam) SetCreateTime(v int64) *MLLabelParam {
	s.CreateTime = &v
	return s
}

func (s *MLLabelParam) SetDescription(v string) *MLLabelParam {
	s.Description = &v
	return s
}

func (s *MLLabelParam) SetLabelId(v string) *MLLabelParam {
	s.LabelId = &v
	return s
}

func (s *MLLabelParam) SetLastModifyTime(v int64) *MLLabelParam {
	s.LastModifyTime = &v
	return s
}

func (s *MLLabelParam) SetName(v string) *MLLabelParam {
	s.Name = &v
	return s
}

func (s *MLLabelParam) SetSettings(v []*MLLabelParamSettings) *MLLabelParam {
	s.Settings = v
	return s
}

func (s *MLLabelParam) SetType(v string) *MLLabelParam {
	s.Type = &v
	return s
}

type MLLabelParamSettings struct {
	// example:
	//
	// ""
	Config *string `json:"config,omitempty" xml:"config,omitempty"`
	// example:
	//
	// builtin
	Mode *string `json:"mode,omitempty" xml:"mode,omitempty"`
	// example:
	//
	// Trace.RCA
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// example:
	//
	// 0.01
	Version *string `json:"version,omitempty" xml:"version,omitempty"`
}

func (s MLLabelParamSettings) String() string {
	return tea.Prettify(s)
}

func (s MLLabelParamSettings) GoString() string {
	return s.String()
}

func (s *MLLabelParamSettings) SetConfig(v string) *MLLabelParamSettings {
	s.Config = &v
	return s
}

func (s *MLLabelParamSettings) SetMode(v string) *MLLabelParamSettings {
	s.Mode = &v
	return s
}

func (s *MLLabelParamSettings) SetType(v string) *MLLabelParamSettings {
	s.Type = &v
	return s
}

func (s *MLLabelParamSettings) SetVersion(v string) *MLLabelParamSettings {
	s.Version = &v
	return s
}

type MLServiceAnalysisParam struct {
	Input     []map[string]*string `json:"input,omitempty" xml:"input,omitempty" type:"Repeated"`
	Parameter map[string]*string   `json:"parameter,omitempty" xml:"parameter,omitempty"`
}

func (s MLServiceAnalysisParam) String() string {
	return tea.Prettify(s)
}

func (s MLServiceAnalysisParam) GoString() string {
	return s.String()
}

func (s *MLServiceAnalysisParam) SetInput(v []map[string]*string) *MLServiceAnalysisParam {
	s.Input = v
	return s
}

func (s *MLServiceAnalysisParam) SetParameter(v map[string]*string) *MLServiceAnalysisParam {
	s.Parameter = v
	return s
}

type MLServiceParam struct {
	// example:
	//
	// 某某服务
	Description *string              `json:"description,omitempty" xml:"description,omitempty"`
	Model       *MLServiceParamModel `json:"model,omitempty" xml:"model,omitempty" type:"Struct"`
	// example:
	//
	// service_name
	Name     *string                 `json:"name,omitempty" xml:"name,omitempty"`
	Resource *MLServiceParamResource `json:"resource,omitempty" xml:"resource,omitempty" type:"Struct"`
	// example:
	//
	// sls_builtin
	ServiceType *string `json:"serviceType,omitempty" xml:"serviceType,omitempty"`
	// example:
	//
	// running
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
	// example:
	//
	// 1695090077
	UpdateTimestamp *int64 `json:"updateTimestamp,omitempty" xml:"updateTimestamp,omitempty"`
}

func (s MLServiceParam) String() string {
	return tea.Prettify(s)
}

func (s MLServiceParam) GoString() string {
	return s.String()
}

func (s *MLServiceParam) SetDescription(v string) *MLServiceParam {
	s.Description = &v
	return s
}

func (s *MLServiceParam) SetModel(v *MLServiceParamModel) *MLServiceParam {
	s.Model = v
	return s
}

func (s *MLServiceParam) SetName(v string) *MLServiceParam {
	s.Name = &v
	return s
}

func (s *MLServiceParam) SetResource(v *MLServiceParamResource) *MLServiceParam {
	s.Resource = v
	return s
}

func (s *MLServiceParam) SetServiceType(v string) *MLServiceParam {
	s.ServiceType = &v
	return s
}

func (s *MLServiceParam) SetStatus(v string) *MLServiceParam {
	s.Status = &v
	return s
}

func (s *MLServiceParam) SetUpdateTimestamp(v int64) *MLServiceParam {
	s.UpdateTimestamp = &v
	return s
}

type MLServiceParamModel struct {
	// example:
	//
	// xxxx
	ModelResourceId *string `json:"modelResourceId,omitempty" xml:"modelResourceId,omitempty"`
	// example:
	//
	// xxx_type
	ModelResourceType *string `json:"modelResourceType,omitempty" xml:"modelResourceType,omitempty"`
}

func (s MLServiceParamModel) String() string {
	return tea.Prettify(s)
}

func (s MLServiceParamModel) GoString() string {
	return s.String()
}

func (s *MLServiceParamModel) SetModelResourceId(v string) *MLServiceParamModel {
	s.ModelResourceId = &v
	return s
}

func (s *MLServiceParamModel) SetModelResourceType(v string) *MLServiceParamModel {
	s.ModelResourceType = &v
	return s
}

type MLServiceParamResource struct {
	// example:
	//
	// 2
	CpuLimit *int32 `json:"cpuLimit,omitempty" xml:"cpuLimit,omitempty"`
	// example:
	//
	// 20
	Gpu *int32 `json:"gpu,omitempty" xml:"gpu,omitempty"`
	// example:
	//
	// 64
	MemoryLimit *int32 `json:"memoryLimit,omitempty" xml:"memoryLimit,omitempty"`
	// example:
	//
	// 2
	Replica *int32 `json:"replica,omitempty" xml:"replica,omitempty"`
}

func (s MLServiceParamResource) String() string {
	return tea.Prettify(s)
}

func (s MLServiceParamResource) GoString() string {
	return s.String()
}

func (s *MLServiceParamResource) SetCpuLimit(v int32) *MLServiceParamResource {
	s.CpuLimit = &v
	return s
}

func (s *MLServiceParamResource) SetGpu(v int32) *MLServiceParamResource {
	s.Gpu = &v
	return s
}

func (s *MLServiceParamResource) SetMemoryLimit(v int32) *MLServiceParamResource {
	s.MemoryLimit = &v
	return s
}

func (s *MLServiceParamResource) SetReplica(v int32) *MLServiceParamResource {
	s.Replica = &v
	return s
}

type MaxComputeExport struct {
	// This parameter is required.
	Configuration *MaxComputeExportConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty"`
	// example:
	//
	// 1714284115
	CreateTime *int64 `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// example:
	//
	// odpsexport-demo
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// odpsexport-test
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// example:
	//
	// 1714284589
	LastModifiedTime *int64 `json:"lastModifiedTime,omitempty" xml:"lastModifiedTime,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// export-general-1714033191-584993-hcl
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// example:
	//
	// c7f01719d9feb105fc9d8df92af62010
	ScheduleId *string `json:"scheduleId,omitempty" xml:"scheduleId,omitempty"`
	// example:
	//
	// RUNNING
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s MaxComputeExport) String() string {
	return tea.Prettify(s)
}

func (s MaxComputeExport) GoString() string {
	return s.String()
}

func (s *MaxComputeExport) SetConfiguration(v *MaxComputeExportConfiguration) *MaxComputeExport {
	s.Configuration = v
	return s
}

func (s *MaxComputeExport) SetCreateTime(v int64) *MaxComputeExport {
	s.CreateTime = &v
	return s
}

func (s *MaxComputeExport) SetDescription(v string) *MaxComputeExport {
	s.Description = &v
	return s
}

func (s *MaxComputeExport) SetDisplayName(v string) *MaxComputeExport {
	s.DisplayName = &v
	return s
}

func (s *MaxComputeExport) SetLastModifiedTime(v int64) *MaxComputeExport {
	s.LastModifiedTime = &v
	return s
}

func (s *MaxComputeExport) SetName(v string) *MaxComputeExport {
	s.Name = &v
	return s
}

func (s *MaxComputeExport) SetScheduleId(v string) *MaxComputeExport {
	s.ScheduleId = &v
	return s
}

func (s *MaxComputeExport) SetStatus(v string) *MaxComputeExport {
	s.Status = &v
	return s
}

type MaxComputeExportConfiguration struct {
	// This parameter is required.
	//
	// example:
	//
	// 1
	FromTime *int64 `json:"fromTime,omitempty" xml:"fromTime,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// sls-logstore-demo
	Logstore *string `json:"logstore,omitempty" xml:"logstore,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// acs:ram::123456789:role/aliyunlogdefaultrole
	RoleArn *string `json:"roleArn,omitempty" xml:"roleArn,omitempty"`
	// This parameter is required.
	Sink *MaxComputeExportConfigurationSink `json:"sink,omitempty" xml:"sink,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// 0
	ToTime *int64 `json:"toTime,omitempty" xml:"toTime,omitempty"`
}

func (s MaxComputeExportConfiguration) String() string {
	return tea.Prettify(s)
}

func (s MaxComputeExportConfiguration) GoString() string {
	return s.String()
}

func (s *MaxComputeExportConfiguration) SetFromTime(v int64) *MaxComputeExportConfiguration {
	s.FromTime = &v
	return s
}

func (s *MaxComputeExportConfiguration) SetLogstore(v string) *MaxComputeExportConfiguration {
	s.Logstore = &v
	return s
}

func (s *MaxComputeExportConfiguration) SetRoleArn(v string) *MaxComputeExportConfiguration {
	s.RoleArn = &v
	return s
}

func (s *MaxComputeExportConfiguration) SetSink(v *MaxComputeExportConfigurationSink) *MaxComputeExportConfiguration {
	s.Sink = v
	return s
}

func (s *MaxComputeExportConfiguration) SetToTime(v int64) *MaxComputeExportConfiguration {
	s.ToTime = &v
	return s
}

type MaxComputeExportConfigurationSink struct {
	// example:
	//
	// 1800
	BufferInterval *string `json:"bufferInterval,omitempty" xml:"bufferInterval,omitempty"`
	// This parameter is required.
	Fields []*string `json:"fields,omitempty" xml:"fields,omitempty" type:"Repeated"`
	// example:
	//
	// true
	FilterInvalid *bool `json:"filterInvalid,omitempty" xml:"filterInvalid,omitempty"`
	// Deprecated
	//
	// example:
	//
	// asdfghjk
	OdpsAccessKeyId *string `json:"odpsAccessKeyId,omitempty" xml:"odpsAccessKeyId,omitempty"`
	// Deprecated
	//
	// example:
	//
	// esasdfghjkl
	OdpsAccessSecret *string `json:"odpsAccessSecret,omitempty" xml:"odpsAccessSecret,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// http://service.cn-hangzhou.maxcompute.aliyun-inc.com/api
	OdpsEndpoint *string `json:"odpsEndpoint,omitempty" xml:"odpsEndpoint,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// demo_project
	OdpsProject *string `json:"odpsProject,omitempty" xml:"odpsProject,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// acs:ram::123456789:role/aliyunlogdefaultrole
	OdpsRolearn *string `json:"odpsRolearn,omitempty" xml:"odpsRolearn,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// demo_table
	OdpsTable *string `json:"odpsTable,omitempty" xml:"odpsTable,omitempty"`
	// example:
	//
	// http://dt.cn-hangzhou.maxcompute.aliyun-inc.com
	OdpsTunnelEndpoint *string `json:"odpsTunnelEndpoint,omitempty" xml:"odpsTunnelEndpoint,omitempty"`
	// This parameter is required.
	PartitionColumn []*string `json:"partitionColumn,omitempty" xml:"partitionColumn,omitempty" type:"Repeated"`
	// This parameter is required.
	//
	// example:
	//
	// %Y_%m_%d
	PartitionTimeFormat *string `json:"partitionTimeFormat,omitempty" xml:"partitionTimeFormat,omitempty"`
	// example:
	//
	// StrfTimeFormat
	TimeFormatType *string `json:"timeFormatType,omitempty" xml:"timeFormatType,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// +0800
	TimeZone *string `json:"timeZone,omitempty" xml:"timeZone,omitempty"`
}

func (s MaxComputeExportConfigurationSink) String() string {
	return tea.Prettify(s)
}

func (s MaxComputeExportConfigurationSink) GoString() string {
	return s.String()
}

func (s *MaxComputeExportConfigurationSink) SetBufferInterval(v string) *MaxComputeExportConfigurationSink {
	s.BufferInterval = &v
	return s
}

func (s *MaxComputeExportConfigurationSink) SetFields(v []*string) *MaxComputeExportConfigurationSink {
	s.Fields = v
	return s
}

func (s *MaxComputeExportConfigurationSink) SetFilterInvalid(v bool) *MaxComputeExportConfigurationSink {
	s.FilterInvalid = &v
	return s
}

func (s *MaxComputeExportConfigurationSink) SetOdpsAccessKeyId(v string) *MaxComputeExportConfigurationSink {
	s.OdpsAccessKeyId = &v
	return s
}

func (s *MaxComputeExportConfigurationSink) SetOdpsAccessSecret(v string) *MaxComputeExportConfigurationSink {
	s.OdpsAccessSecret = &v
	return s
}

func (s *MaxComputeExportConfigurationSink) SetOdpsEndpoint(v string) *MaxComputeExportConfigurationSink {
	s.OdpsEndpoint = &v
	return s
}

func (s *MaxComputeExportConfigurationSink) SetOdpsProject(v string) *MaxComputeExportConfigurationSink {
	s.OdpsProject = &v
	return s
}

func (s *MaxComputeExportConfigurationSink) SetOdpsRolearn(v string) *MaxComputeExportConfigurationSink {
	s.OdpsRolearn = &v
	return s
}

func (s *MaxComputeExportConfigurationSink) SetOdpsTable(v string) *MaxComputeExportConfigurationSink {
	s.OdpsTable = &v
	return s
}

func (s *MaxComputeExportConfigurationSink) SetOdpsTunnelEndpoint(v string) *MaxComputeExportConfigurationSink {
	s.OdpsTunnelEndpoint = &v
	return s
}

func (s *MaxComputeExportConfigurationSink) SetPartitionColumn(v []*string) *MaxComputeExportConfigurationSink {
	s.PartitionColumn = v
	return s
}

func (s *MaxComputeExportConfigurationSink) SetPartitionTimeFormat(v string) *MaxComputeExportConfigurationSink {
	s.PartitionTimeFormat = &v
	return s
}

func (s *MaxComputeExportConfigurationSink) SetTimeFormatType(v string) *MaxComputeExportConfigurationSink {
	s.TimeFormatType = &v
	return s
}

func (s *MaxComputeExportConfigurationSink) SetTimeZone(v string) *MaxComputeExportConfigurationSink {
	s.TimeZone = &v
	return s
}

type OSSExport struct {
	Configuration *OSSExportConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty"`
	// example:
	//
	// 1714284025
	CreateTime *int64 `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// example:
	//
	// job-test
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// job-demo
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// example:
	//
	// 1714284115
	LastModifiedTime *int64 `json:"lastModifiedTime,omitempty" xml:"lastModifiedTime,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// job-1714109458-123456
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// example:
	//
	// c7f01719d9feb105fc9d8df92af62010
	ScheduleId *string `json:"scheduleId,omitempty" xml:"scheduleId,omitempty"`
	// example:
	//
	// RUNNING
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s OSSExport) String() string {
	return tea.Prettify(s)
}

func (s OSSExport) GoString() string {
	return s.String()
}

func (s *OSSExport) SetConfiguration(v *OSSExportConfiguration) *OSSExport {
	s.Configuration = v
	return s
}

func (s *OSSExport) SetCreateTime(v int64) *OSSExport {
	s.CreateTime = &v
	return s
}

func (s *OSSExport) SetDescription(v string) *OSSExport {
	s.Description = &v
	return s
}

func (s *OSSExport) SetDisplayName(v string) *OSSExport {
	s.DisplayName = &v
	return s
}

func (s *OSSExport) SetLastModifiedTime(v int64) *OSSExport {
	s.LastModifiedTime = &v
	return s
}

func (s *OSSExport) SetName(v string) *OSSExport {
	s.Name = &v
	return s
}

func (s *OSSExport) SetScheduleId(v string) *OSSExport {
	s.ScheduleId = &v
	return s
}

func (s *OSSExport) SetStatus(v string) *OSSExport {
	s.Status = &v
	return s
}

type OSSExportConfiguration struct {
	// example:
	//
	// 1714123644
	FromTime *int64 `json:"fromTime,omitempty" xml:"fromTime,omitempty"`
	// example:
	//
	// logstore-demo
	Logstore *string `json:"logstore,omitempty" xml:"logstore,omitempty"`
	// example:
	//
	// acs:ram::123456789:role/aliyunlogdefaultrole
	RoleArn *string                     `json:"roleArn,omitempty" xml:"roleArn,omitempty"`
	Sink    *OSSExportConfigurationSink `json:"sink,omitempty" xml:"sink,omitempty" type:"Struct"`
	// example:
	//
	// 1714357112
	ToTime *int64 `json:"toTime,omitempty" xml:"toTime,omitempty"`
}

func (s OSSExportConfiguration) String() string {
	return tea.Prettify(s)
}

func (s OSSExportConfiguration) GoString() string {
	return s.String()
}

func (s *OSSExportConfiguration) SetFromTime(v int64) *OSSExportConfiguration {
	s.FromTime = &v
	return s
}

func (s *OSSExportConfiguration) SetLogstore(v string) *OSSExportConfiguration {
	s.Logstore = &v
	return s
}

func (s *OSSExportConfiguration) SetRoleArn(v string) *OSSExportConfiguration {
	s.RoleArn = &v
	return s
}

func (s *OSSExportConfiguration) SetSink(v *OSSExportConfigurationSink) *OSSExportConfiguration {
	s.Sink = v
	return s
}

func (s *OSSExportConfiguration) SetToTime(v int64) *OSSExportConfiguration {
	s.ToTime = &v
	return s
}

type OSSExportConfigurationSink struct {
	// This parameter is required.
	//
	// example:
	//
	// test-bucket
	Bucket *string `json:"bucket,omitempty" xml:"bucket,omitempty"`
	// example:
	//
	// 300
	BufferInterval *int64 `json:"bufferInterval,omitempty" xml:"bufferInterval,omitempty"`
	// example:
	//
	// 256
	BufferSize *int64 `json:"bufferSize,omitempty" xml:"bufferSize,omitempty"`
	// example:
	//
	// snappy
	CompressionType *string                `json:"compressionType,omitempty" xml:"compressionType,omitempty"`
	ContentDetail   map[string]interface{} `json:"contentDetail,omitempty" xml:"contentDetail,omitempty"`
	// example:
	//
	// json
	ContentType *string `json:"contentType,omitempty" xml:"contentType,omitempty"`
	// Deprecated
	//
	// example:
	//
	// 900
	DelaySec *int64 `json:"delaySec,omitempty" xml:"delaySec,omitempty"`
	// example:
	//
	// 900
	DelaySeconds *int64 `json:"delaySeconds,omitempty" xml:"delaySeconds,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// http://oss-cn-hangzhou-internal.aliyuncs.com
	Endpoint *string `json:"endpoint,omitempty" xml:"endpoint,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// %Y/%m/%d/%H/%M
	PathFormat *string `json:"pathFormat,omitempty" xml:"pathFormat,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// time
	PathFormatType *string `json:"pathFormatType,omitempty" xml:"pathFormatType,omitempty"`
	// example:
	//
	// demo/
	Prefix *string `json:"prefix,omitempty" xml:"prefix,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// acs:ram::123456789:role/aliyunlogdefaultrole
	RoleArn *string `json:"roleArn,omitempty" xml:"roleArn,omitempty"`
	// example:
	//
	// .json
	Suffix *string `json:"suffix,omitempty" xml:"suffix,omitempty"`
	// example:
	//
	// +0800
	TimeZone *string `json:"timeZone,omitempty" xml:"timeZone,omitempty"`
}

func (s OSSExportConfigurationSink) String() string {
	return tea.Prettify(s)
}

func (s OSSExportConfigurationSink) GoString() string {
	return s.String()
}

func (s *OSSExportConfigurationSink) SetBucket(v string) *OSSExportConfigurationSink {
	s.Bucket = &v
	return s
}

func (s *OSSExportConfigurationSink) SetBufferInterval(v int64) *OSSExportConfigurationSink {
	s.BufferInterval = &v
	return s
}

func (s *OSSExportConfigurationSink) SetBufferSize(v int64) *OSSExportConfigurationSink {
	s.BufferSize = &v
	return s
}

func (s *OSSExportConfigurationSink) SetCompressionType(v string) *OSSExportConfigurationSink {
	s.CompressionType = &v
	return s
}

func (s *OSSExportConfigurationSink) SetContentDetail(v map[string]interface{}) *OSSExportConfigurationSink {
	s.ContentDetail = v
	return s
}

func (s *OSSExportConfigurationSink) SetContentType(v string) *OSSExportConfigurationSink {
	s.ContentType = &v
	return s
}

func (s *OSSExportConfigurationSink) SetDelaySec(v int64) *OSSExportConfigurationSink {
	s.DelaySec = &v
	return s
}

func (s *OSSExportConfigurationSink) SetDelaySeconds(v int64) *OSSExportConfigurationSink {
	s.DelaySeconds = &v
	return s
}

func (s *OSSExportConfigurationSink) SetEndpoint(v string) *OSSExportConfigurationSink {
	s.Endpoint = &v
	return s
}

func (s *OSSExportConfigurationSink) SetPathFormat(v string) *OSSExportConfigurationSink {
	s.PathFormat = &v
	return s
}

func (s *OSSExportConfigurationSink) SetPathFormatType(v string) *OSSExportConfigurationSink {
	s.PathFormatType = &v
	return s
}

func (s *OSSExportConfigurationSink) SetPrefix(v string) *OSSExportConfigurationSink {
	s.Prefix = &v
	return s
}

func (s *OSSExportConfigurationSink) SetRoleArn(v string) *OSSExportConfigurationSink {
	s.RoleArn = &v
	return s
}

func (s *OSSExportConfigurationSink) SetSuffix(v string) *OSSExportConfigurationSink {
	s.Suffix = &v
	return s
}

func (s *OSSExportConfigurationSink) SetTimeZone(v string) *OSSExportConfigurationSink {
	s.TimeZone = &v
	return s
}

type OSSIngestion struct {
	// This parameter is required.
	Configuration *OSSIngestionConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty"`
	// example:
	//
	// 1714360481
	CreateTime *int64 `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// example:
	//
	// oss ingestion
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// oss ingestion
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// example:
	//
	// 1714360481
	LastModifiedTime *int64 `json:"lastModifiedTime,omitempty" xml:"lastModifiedTime,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// ingest-oss-123456
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// This parameter is required.
	Schedule *Schedule `json:"schedule,omitempty" xml:"schedule,omitempty"`
	// example:
	//
	// c7f01719d9feb105fc9d8df92af62010
	ScheduleId *string `json:"scheduleId,omitempty" xml:"scheduleId,omitempty"`
	// example:
	//
	// RUNNING
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s OSSIngestion) String() string {
	return tea.Prettify(s)
}

func (s OSSIngestion) GoString() string {
	return s.String()
}

func (s *OSSIngestion) SetConfiguration(v *OSSIngestionConfiguration) *OSSIngestion {
	s.Configuration = v
	return s
}

func (s *OSSIngestion) SetCreateTime(v int64) *OSSIngestion {
	s.CreateTime = &v
	return s
}

func (s *OSSIngestion) SetDescription(v string) *OSSIngestion {
	s.Description = &v
	return s
}

func (s *OSSIngestion) SetDisplayName(v string) *OSSIngestion {
	s.DisplayName = &v
	return s
}

func (s *OSSIngestion) SetLastModifiedTime(v int64) *OSSIngestion {
	s.LastModifiedTime = &v
	return s
}

func (s *OSSIngestion) SetName(v string) *OSSIngestion {
	s.Name = &v
	return s
}

func (s *OSSIngestion) SetSchedule(v *Schedule) *OSSIngestion {
	s.Schedule = v
	return s
}

func (s *OSSIngestion) SetScheduleId(v string) *OSSIngestion {
	s.ScheduleId = &v
	return s
}

func (s *OSSIngestion) SetStatus(v string) *OSSIngestion {
	s.Status = &v
	return s
}

type OSSIngestionConfiguration struct {
	// This parameter is required.
	//
	// example:
	//
	// myLogstore
	Logstore *string `json:"logstore,omitempty" xml:"logstore,omitempty"`
	// This parameter is required.
	Source *OSSIngestionConfigurationSource `json:"source,omitempty" xml:"source,omitempty"`
}

func (s OSSIngestionConfiguration) String() string {
	return tea.Prettify(s)
}

func (s OSSIngestionConfiguration) GoString() string {
	return s.String()
}

func (s *OSSIngestionConfiguration) SetLogstore(v string) *OSSIngestionConfiguration {
	s.Logstore = &v
	return s
}

func (s *OSSIngestionConfiguration) SetSource(v *OSSIngestionConfigurationSource) *OSSIngestionConfiguration {
	s.Source = v
	return s
}

type OSSIngestionConfigurationSource struct {
	// This parameter is required.
	//
	// example:
	//
	// ossbucket
	Bucket *string `json:"bucket,omitempty" xml:"bucket,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// none
	CompressionCodec *string `json:"compressionCodec,omitempty" xml:"compressionCodec,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// UTF-8
	Encoding *string `json:"encoding,omitempty" xml:"encoding,omitempty"`
	// example:
	//
	// 1714360481
	EndTime *int64 `json:"endTime,omitempty" xml:"endTime,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// oss-cn-hangzhou.aliyuncs.com
	Endpoint *string `json:"endpoint,omitempty" xml:"endpoint,omitempty"`
	// This parameter is required.
	Format map[string]interface{} `json:"format,omitempty" xml:"format,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// never
	Interval *string `json:"interval,omitempty" xml:"interval,omitempty"`
	// example:
	//
	// .*
	Pattern *string `json:"pattern,omitempty" xml:"pattern,omitempty"`
	// example:
	//
	// prefix
	Prefix *string `json:"prefix,omitempty" xml:"prefix,omitempty"`
	// example:
	//
	// true
	RestoreObjectEnabled *bool `json:"restoreObjectEnabled,omitempty" xml:"restoreObjectEnabled,omitempty"`
	// example:
	//
	// acs:ram::12345:role/aliyunlogdefaultrole
	RoleARN *string `json:"roleARN,omitempty" xml:"roleARN,omitempty"`
	// example:
	//
	// 1714274081
	StartTime *int64 `json:"startTime,omitempty" xml:"startTime,omitempty"`
	// example:
	//
	// __time__
	TimeField *string `json:"timeField,omitempty" xml:"timeField,omitempty"`
	// example:
	//
	// yyyy-MM-dd HH:mm:ss
	TimeFormat *string `json:"timeFormat,omitempty" xml:"timeFormat,omitempty"`
	// example:
	//
	// [0-9]{0,2}\/[0-9a-zA-Z]+\/[0-9:,]+
	TimePattern *string `json:"timePattern,omitempty" xml:"timePattern,omitempty"`
	// example:
	//
	// GMT+08:00
	TimeZone *string `json:"timeZone,omitempty" xml:"timeZone,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// false
	UseMetaIndex *bool `json:"useMetaIndex,omitempty" xml:"useMetaIndex,omitempty"`
}

func (s OSSIngestionConfigurationSource) String() string {
	return tea.Prettify(s)
}

func (s OSSIngestionConfigurationSource) GoString() string {
	return s.String()
}

func (s *OSSIngestionConfigurationSource) SetBucket(v string) *OSSIngestionConfigurationSource {
	s.Bucket = &v
	return s
}

func (s *OSSIngestionConfigurationSource) SetCompressionCodec(v string) *OSSIngestionConfigurationSource {
	s.CompressionCodec = &v
	return s
}

func (s *OSSIngestionConfigurationSource) SetEncoding(v string) *OSSIngestionConfigurationSource {
	s.Encoding = &v
	return s
}

func (s *OSSIngestionConfigurationSource) SetEndTime(v int64) *OSSIngestionConfigurationSource {
	s.EndTime = &v
	return s
}

func (s *OSSIngestionConfigurationSource) SetEndpoint(v string) *OSSIngestionConfigurationSource {
	s.Endpoint = &v
	return s
}

func (s *OSSIngestionConfigurationSource) SetFormat(v map[string]interface{}) *OSSIngestionConfigurationSource {
	s.Format = v
	return s
}

func (s *OSSIngestionConfigurationSource) SetInterval(v string) *OSSIngestionConfigurationSource {
	s.Interval = &v
	return s
}

func (s *OSSIngestionConfigurationSource) SetPattern(v string) *OSSIngestionConfigurationSource {
	s.Pattern = &v
	return s
}

func (s *OSSIngestionConfigurationSource) SetPrefix(v string) *OSSIngestionConfigurationSource {
	s.Prefix = &v
	return s
}

func (s *OSSIngestionConfigurationSource) SetRestoreObjectEnabled(v bool) *OSSIngestionConfigurationSource {
	s.RestoreObjectEnabled = &v
	return s
}

func (s *OSSIngestionConfigurationSource) SetRoleARN(v string) *OSSIngestionConfigurationSource {
	s.RoleARN = &v
	return s
}

func (s *OSSIngestionConfigurationSource) SetStartTime(v int64) *OSSIngestionConfigurationSource {
	s.StartTime = &v
	return s
}

func (s *OSSIngestionConfigurationSource) SetTimeField(v string) *OSSIngestionConfigurationSource {
	s.TimeField = &v
	return s
}

func (s *OSSIngestionConfigurationSource) SetTimeFormat(v string) *OSSIngestionConfigurationSource {
	s.TimeFormat = &v
	return s
}

func (s *OSSIngestionConfigurationSource) SetTimePattern(v string) *OSSIngestionConfigurationSource {
	s.TimePattern = &v
	return s
}

func (s *OSSIngestionConfigurationSource) SetTimeZone(v string) *OSSIngestionConfigurationSource {
	s.TimeZone = &v
	return s
}

func (s *OSSIngestionConfigurationSource) SetUseMetaIndex(v bool) *OSSIngestionConfigurationSource {
	s.UseMetaIndex = &v
	return s
}

type PolicyConfiguration struct {
	// example:
	//
	// example_action_policy
	ActionPolicyId *string `json:"actionPolicyId,omitempty" xml:"actionPolicyId,omitempty"`
	// example:
	//
	// sls.builtin.dynamic
	AlertPolicyId *string `json:"alertPolicyId,omitempty" xml:"alertPolicyId,omitempty"`
	// example:
	//
	// 10m
	RepeatInterval *string `json:"repeatInterval,omitempty" xml:"repeatInterval,omitempty"`
}

func (s PolicyConfiguration) String() string {
	return tea.Prettify(s)
}

func (s PolicyConfiguration) GoString() string {
	return s.String()
}

func (s *PolicyConfiguration) SetActionPolicyId(v string) *PolicyConfiguration {
	s.ActionPolicyId = &v
	return s
}

func (s *PolicyConfiguration) SetAlertPolicyId(v string) *PolicyConfiguration {
	s.AlertPolicyId = &v
	return s
}

func (s *PolicyConfiguration) SetRepeatInterval(v string) *PolicyConfiguration {
	s.RepeatInterval = &v
	return s
}

type ProcessorAssociate struct {
	// This parameter is required.
	//
	// example:
	//
	// ingest-processor-1
	ProcessorId *string `json:"processorId,omitempty" xml:"processorId,omitempty"`
}

func (s ProcessorAssociate) String() string {
	return tea.Prettify(s)
}

func (s ProcessorAssociate) GoString() string {
	return s.String()
}

func (s *ProcessorAssociate) SetProcessorId(v string) *ProcessorAssociate {
	s.ProcessorId = &v
	return s
}

type ProjectSummary struct {
	// This parameter is required.
	CreateTime *int64 `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// This parameter is required.
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// This parameter is required.
	ProjectName *string `json:"projectName,omitempty" xml:"projectName,omitempty"`
	// This parameter is required.
	Region *string `json:"region,omitempty" xml:"region,omitempty"`
	// This parameter is required.
	ResourceGroupId *string `json:"resourceGroupId,omitempty" xml:"resourceGroupId,omitempty"`
	// This parameter is required.
	UpdateTime *int64 `json:"updateTime,omitempty" xml:"updateTime,omitempty"`
}

func (s ProjectSummary) String() string {
	return tea.Prettify(s)
}

func (s ProjectSummary) GoString() string {
	return s.String()
}

func (s *ProjectSummary) SetCreateTime(v int64) *ProjectSummary {
	s.CreateTime = &v
	return s
}

func (s *ProjectSummary) SetDescription(v string) *ProjectSummary {
	s.Description = &v
	return s
}

func (s *ProjectSummary) SetProjectName(v string) *ProjectSummary {
	s.ProjectName = &v
	return s
}

func (s *ProjectSummary) SetRegion(v string) *ProjectSummary {
	s.Region = &v
	return s
}

func (s *ProjectSummary) SetResourceGroupId(v string) *ProjectSummary {
	s.ResourceGroupId = &v
	return s
}

func (s *ProjectSummary) SetUpdateTime(v int64) *ProjectSummary {
	s.UpdateTime = &v
	return s
}

type S3Ingestion struct {
	// This parameter is required.
	Configuration *S3IngestionConfigurationSource `json:"configuration,omitempty" xml:"configuration,omitempty"`
	// example:
	//
	// 1714360481
	CreateTime *int64 `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// example:
	//
	// s3 ingestion
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// s3 ingestion
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// example:
	//
	// 1714360481
	LastModifiedTime *int64 `json:"lastModifiedTime,omitempty" xml:"lastModifiedTime,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// ingest-s3-123456
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// This parameter is required.
	Schedule *Schedule `json:"schedule,omitempty" xml:"schedule,omitempty"`
	// example:
	//
	// c7f01719d9feb105fc9d8df92af62010
	ScheduleId *string `json:"scheduleId,omitempty" xml:"scheduleId,omitempty"`
	// example:
	//
	// RUNNING
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s S3Ingestion) String() string {
	return tea.Prettify(s)
}

func (s S3Ingestion) GoString() string {
	return s.String()
}

func (s *S3Ingestion) SetConfiguration(v *S3IngestionConfigurationSource) *S3Ingestion {
	s.Configuration = v
	return s
}

func (s *S3Ingestion) SetCreateTime(v int64) *S3Ingestion {
	s.CreateTime = &v
	return s
}

func (s *S3Ingestion) SetDescription(v string) *S3Ingestion {
	s.Description = &v
	return s
}

func (s *S3Ingestion) SetDisplayName(v string) *S3Ingestion {
	s.DisplayName = &v
	return s
}

func (s *S3Ingestion) SetLastModifiedTime(v int64) *S3Ingestion {
	s.LastModifiedTime = &v
	return s
}

func (s *S3Ingestion) SetName(v string) *S3Ingestion {
	s.Name = &v
	return s
}

func (s *S3Ingestion) SetSchedule(v *Schedule) *S3Ingestion {
	s.Schedule = v
	return s
}

func (s *S3Ingestion) SetScheduleId(v string) *S3Ingestion {
	s.ScheduleId = &v
	return s
}

func (s *S3Ingestion) SetStatus(v string) *S3Ingestion {
	s.Status = &v
	return s
}

type S3IngestionConfiguration struct {
	// example:
	//
	// myLogstore
	Logstore *string                         `json:"logstore,omitempty" xml:"logstore,omitempty"`
	Source   *S3IngestionConfigurationSource `json:"source,omitempty" xml:"source,omitempty"`
}

func (s S3IngestionConfiguration) String() string {
	return tea.Prettify(s)
}

func (s S3IngestionConfiguration) GoString() string {
	return s.String()
}

func (s *S3IngestionConfiguration) SetLogstore(v string) *S3IngestionConfiguration {
	s.Logstore = &v
	return s
}

func (s *S3IngestionConfiguration) SetSource(v *S3IngestionConfigurationSource) *S3IngestionConfiguration {
	s.Source = v
	return s
}

type S3IngestionConfigurationSource struct {
	// This parameter is required.
	//
	// example:
	//
	// AKIxxxxxxxxxxYJE
	AwsAccessKey *string `json:"awsAccessKey,omitempty" xml:"awsAccessKey,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// 123xxxxxxxxxxfjf
	AwsAccessKeySecret *string `json:"awsAccessKeySecret,omitempty" xml:"awsAccessKeySecret,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// ap-northeast-1
	AwsRegion *string `json:"awsRegion,omitempty" xml:"awsRegion,omitempty"`
	// example:
	//
	// https://sqs.ap-northeast-1.amazonaws.com/123456788/chifan
	AwsSQSQueueUrl *string `json:"awsSQSQueueUrl,omitempty" xml:"awsSQSQueueUrl,omitempty"`
	// example:
	//
	// false
	AwsUseSQS *bool `json:"awsUseSQS,omitempty" xml:"awsUseSQS,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// s3bucket
	Bucket *string `json:"bucket,omitempty" xml:"bucket,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// none
	CompressionCodec *string `json:"compressionCodec,omitempty" xml:"compressionCodec,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// UTF-8
	Encoding *string `json:"encoding,omitempty" xml:"encoding,omitempty"`
	// example:
	//
	// 1714360481
	EndTime *int64 `json:"endTime,omitempty" xml:"endTime,omitempty"`
	// This parameter is required.
	Format map[string]interface{} `json:"format,omitempty" xml:"format,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// 30m
	Interval *string `json:"interval,omitempty" xml:"interval,omitempty"`
	// example:
	//
	// .*
	Pattern *string `json:"pattern,omitempty" xml:"pattern,omitempty"`
	// example:
	//
	// prefix
	Prefix *string `json:"prefix,omitempty" xml:"prefix,omitempty"`
	// example:
	//
	// 1714274081
	StartTime *int64 `json:"startTime,omitempty" xml:"startTime,omitempty"`
	// example:
	//
	// false
	TagPackId *bool `json:"tagPackId,omitempty" xml:"tagPackId,omitempty"`
	// example:
	//
	// __time__
	TimeField *string `json:"timeField,omitempty" xml:"timeField,omitempty"`
	// example:
	//
	// yyyy-MM-dd HH:mm:ss
	TimeFormat *string `json:"timeFormat,omitempty" xml:"timeFormat,omitempty"`
	// example:
	//
	// [0-9]{0,2}\/[0-9a-zA-Z]+\/[0-9:,]+
	TimePattern *string `json:"timePattern,omitempty" xml:"timePattern,omitempty"`
	// example:
	//
	// GMT+08:00
	TimeZone *string `json:"timeZone,omitempty" xml:"timeZone,omitempty"`
	// example:
	//
	// false
	UseAwsSQSOnly *bool `json:"useAwsSQSOnly,omitempty" xml:"useAwsSQSOnly,omitempty"`
}

func (s S3IngestionConfigurationSource) String() string {
	return tea.Prettify(s)
}

func (s S3IngestionConfigurationSource) GoString() string {
	return s.String()
}

func (s *S3IngestionConfigurationSource) SetAwsAccessKey(v string) *S3IngestionConfigurationSource {
	s.AwsAccessKey = &v
	return s
}

func (s *S3IngestionConfigurationSource) SetAwsAccessKeySecret(v string) *S3IngestionConfigurationSource {
	s.AwsAccessKeySecret = &v
	return s
}

func (s *S3IngestionConfigurationSource) SetAwsRegion(v string) *S3IngestionConfigurationSource {
	s.AwsRegion = &v
	return s
}

func (s *S3IngestionConfigurationSource) SetAwsSQSQueueUrl(v string) *S3IngestionConfigurationSource {
	s.AwsSQSQueueUrl = &v
	return s
}

func (s *S3IngestionConfigurationSource) SetAwsUseSQS(v bool) *S3IngestionConfigurationSource {
	s.AwsUseSQS = &v
	return s
}

func (s *S3IngestionConfigurationSource) SetBucket(v string) *S3IngestionConfigurationSource {
	s.Bucket = &v
	return s
}

func (s *S3IngestionConfigurationSource) SetCompressionCodec(v string) *S3IngestionConfigurationSource {
	s.CompressionCodec = &v
	return s
}

func (s *S3IngestionConfigurationSource) SetEncoding(v string) *S3IngestionConfigurationSource {
	s.Encoding = &v
	return s
}

func (s *S3IngestionConfigurationSource) SetEndTime(v int64) *S3IngestionConfigurationSource {
	s.EndTime = &v
	return s
}

func (s *S3IngestionConfigurationSource) SetFormat(v map[string]interface{}) *S3IngestionConfigurationSource {
	s.Format = v
	return s
}

func (s *S3IngestionConfigurationSource) SetInterval(v string) *S3IngestionConfigurationSource {
	s.Interval = &v
	return s
}

func (s *S3IngestionConfigurationSource) SetPattern(v string) *S3IngestionConfigurationSource {
	s.Pattern = &v
	return s
}

func (s *S3IngestionConfigurationSource) SetPrefix(v string) *S3IngestionConfigurationSource {
	s.Prefix = &v
	return s
}

func (s *S3IngestionConfigurationSource) SetStartTime(v int64) *S3IngestionConfigurationSource {
	s.StartTime = &v
	return s
}

func (s *S3IngestionConfigurationSource) SetTagPackId(v bool) *S3IngestionConfigurationSource {
	s.TagPackId = &v
	return s
}

func (s *S3IngestionConfigurationSource) SetTimeField(v string) *S3IngestionConfigurationSource {
	s.TimeField = &v
	return s
}

func (s *S3IngestionConfigurationSource) SetTimeFormat(v string) *S3IngestionConfigurationSource {
	s.TimeFormat = &v
	return s
}

func (s *S3IngestionConfigurationSource) SetTimePattern(v string) *S3IngestionConfigurationSource {
	s.TimePattern = &v
	return s
}

func (s *S3IngestionConfigurationSource) SetTimeZone(v string) *S3IngestionConfigurationSource {
	s.TimeZone = &v
	return s
}

func (s *S3IngestionConfigurationSource) SetUseAwsSQSOnly(v bool) *S3IngestionConfigurationSource {
	s.UseAwsSQSOnly = &v
	return s
}

type SavedSearch struct {
	// This parameter is required.
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// This parameter is required.
	Logstore *string `json:"logstore,omitempty" xml:"logstore,omitempty"`
	// This parameter is required.
	SavedsearchName *string `json:"savedsearchName,omitempty" xml:"savedsearchName,omitempty"`
	// This parameter is required.
	SearchQuery *string `json:"searchQuery,omitempty" xml:"searchQuery,omitempty"`
	Topic       *string `json:"topic,omitempty" xml:"topic,omitempty"`
}

func (s SavedSearch) String() string {
	return tea.Prettify(s)
}

func (s SavedSearch) GoString() string {
	return s.String()
}

func (s *SavedSearch) SetDisplayName(v string) *SavedSearch {
	s.DisplayName = &v
	return s
}

func (s *SavedSearch) SetLogstore(v string) *SavedSearch {
	s.Logstore = &v
	return s
}

func (s *SavedSearch) SetSavedsearchName(v string) *SavedSearch {
	s.SavedsearchName = &v
	return s
}

func (s *SavedSearch) SetSearchQuery(v string) *SavedSearch {
	s.SearchQuery = &v
	return s
}

func (s *SavedSearch) SetTopic(v string) *SavedSearch {
	s.Topic = &v
	return s
}

type Schedule struct {
	// example:
	//
	// 0/5 	- 	- 	- *
	CronExpression *string `json:"cronExpression,omitempty" xml:"cronExpression,omitempty"`
	// example:
	//
	// 4
	Delay *int32 `json:"delay,omitempty" xml:"delay,omitempty"`
	// example:
	//
	// 60s
	Interval *string `json:"interval,omitempty" xml:"interval,omitempty"`
	// example:
	//
	// false
	RunImmediately *bool `json:"runImmediately,omitempty" xml:"runImmediately,omitempty"`
	// example:
	//
	// +0800
	TimeZone *string `json:"timeZone,omitempty" xml:"timeZone,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// FixedRate
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s Schedule) String() string {
	return tea.Prettify(s)
}

func (s Schedule) GoString() string {
	return s.String()
}

func (s *Schedule) SetCronExpression(v string) *Schedule {
	s.CronExpression = &v
	return s
}

func (s *Schedule) SetDelay(v int32) *Schedule {
	s.Delay = &v
	return s
}

func (s *Schedule) SetInterval(v string) *Schedule {
	s.Interval = &v
	return s
}

func (s *Schedule) SetRunImmediately(v bool) *Schedule {
	s.RunImmediately = &v
	return s
}

func (s *Schedule) SetTimeZone(v string) *Schedule {
	s.TimeZone = &v
	return s
}

func (s *Schedule) SetType(v string) *Schedule {
	s.Type = &v
	return s
}

type ScheduledSQL struct {
	// This parameter is required.
	Configuration *ScheduledSQLConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty"`
	// example:
	//
	// 1714123644
	CreateTime *int64 `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// example:
	//
	// schedule-sql-test
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// scheduleSqlTest
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// example:
	//
	// 1714123644
	LastModifiedTime *int64 `json:"lastModifiedTime,omitempty" xml:"lastModifiedTime,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// sql-1714123463-225223
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// This parameter is required.
	Schedule *Schedule `json:"schedule,omitempty" xml:"schedule,omitempty"`
	// example:
	//
	// e73f43732852064ad5d091914e39342f
	ScheduleId *string `json:"scheduleId,omitempty" xml:"scheduleId,omitempty"`
	// example:
	//
	// ENABLED
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s ScheduledSQL) String() string {
	return tea.Prettify(s)
}

func (s ScheduledSQL) GoString() string {
	return s.String()
}

func (s *ScheduledSQL) SetConfiguration(v *ScheduledSQLConfiguration) *ScheduledSQL {
	s.Configuration = v
	return s
}

func (s *ScheduledSQL) SetCreateTime(v int64) *ScheduledSQL {
	s.CreateTime = &v
	return s
}

func (s *ScheduledSQL) SetDescription(v string) *ScheduledSQL {
	s.Description = &v
	return s
}

func (s *ScheduledSQL) SetDisplayName(v string) *ScheduledSQL {
	s.DisplayName = &v
	return s
}

func (s *ScheduledSQL) SetLastModifiedTime(v int64) *ScheduledSQL {
	s.LastModifiedTime = &v
	return s
}

func (s *ScheduledSQL) SetName(v string) *ScheduledSQL {
	s.Name = &v
	return s
}

func (s *ScheduledSQL) SetSchedule(v *Schedule) *ScheduledSQL {
	s.Schedule = v
	return s
}

func (s *ScheduledSQL) SetScheduleId(v string) *ScheduledSQL {
	s.ScheduleId = &v
	return s
}

func (s *ScheduledSQL) SetStatus(v string) *ScheduledSQL {
	s.Status = &v
	return s
}

type ScheduledSQLConfiguration struct {
	// This parameter is required.
	//
	// example:
	//
	// log2log
	DataFormat *string `json:"dataFormat,omitempty" xml:"dataFormat,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// cn-hangzhou-intranet.log.aliyuncs.com
	DestEndpoint *string `json:"destEndpoint,omitempty" xml:"destEndpoint,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// dest-logstore-demo
	DestLogstore *string `json:"destLogstore,omitempty" xml:"destLogstore,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// project-demo
	DestProject *string `json:"destProject,omitempty" xml:"destProject,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// acs:ram::123456789:role/aliyunlogetlrole
	DestRoleArn *string `json:"destRoleArn,omitempty" xml:"destRoleArn,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// 1712592000
	FromTime *int64 `json:"fromTime,omitempty" xml:"fromTime,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// @m-1m
	FromTimeExpr *string `json:"fromTimeExpr,omitempty" xml:"fromTimeExpr,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// 20
	MaxRetries *int64 `json:"maxRetries,omitempty" xml:"maxRetries,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// 600
	MaxRunTimeInSeconds *int64 `json:"maxRunTimeInSeconds,omitempty" xml:"maxRunTimeInSeconds,omitempty"`
	// This parameter is required.
	Parameters map[string]interface{} `json:"parameters,omitempty" xml:"parameters,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// enhanced
	ResourcePool *string `json:"resourcePool,omitempty" xml:"resourcePool,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// acs:ram::123456789:role/aliyunlogetlrole
	RoleArn *string `json:"roleArn,omitempty" xml:"roleArn,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// 	- | select *
	Script *string `json:"script,omitempty" xml:"script,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// source-logstore-demo
	SourceLogstore *string `json:"sourceLogstore,omitempty" xml:"sourceLogstore,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// searchQuery
	SqlType *string `json:"sqlType,omitempty" xml:"sqlType,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// 0
	ToTime *int64 `json:"toTime,omitempty" xml:"toTime,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// @m
	ToTimeExpr *string `json:"toTimeExpr,omitempty" xml:"toTimeExpr,omitempty"`
}

func (s ScheduledSQLConfiguration) String() string {
	return tea.Prettify(s)
}

func (s ScheduledSQLConfiguration) GoString() string {
	return s.String()
}

func (s *ScheduledSQLConfiguration) SetDataFormat(v string) *ScheduledSQLConfiguration {
	s.DataFormat = &v
	return s
}

func (s *ScheduledSQLConfiguration) SetDestEndpoint(v string) *ScheduledSQLConfiguration {
	s.DestEndpoint = &v
	return s
}

func (s *ScheduledSQLConfiguration) SetDestLogstore(v string) *ScheduledSQLConfiguration {
	s.DestLogstore = &v
	return s
}

func (s *ScheduledSQLConfiguration) SetDestProject(v string) *ScheduledSQLConfiguration {
	s.DestProject = &v
	return s
}

func (s *ScheduledSQLConfiguration) SetDestRoleArn(v string) *ScheduledSQLConfiguration {
	s.DestRoleArn = &v
	return s
}

func (s *ScheduledSQLConfiguration) SetFromTime(v int64) *ScheduledSQLConfiguration {
	s.FromTime = &v
	return s
}

func (s *ScheduledSQLConfiguration) SetFromTimeExpr(v string) *ScheduledSQLConfiguration {
	s.FromTimeExpr = &v
	return s
}

func (s *ScheduledSQLConfiguration) SetMaxRetries(v int64) *ScheduledSQLConfiguration {
	s.MaxRetries = &v
	return s
}

func (s *ScheduledSQLConfiguration) SetMaxRunTimeInSeconds(v int64) *ScheduledSQLConfiguration {
	s.MaxRunTimeInSeconds = &v
	return s
}

func (s *ScheduledSQLConfiguration) SetParameters(v map[string]interface{}) *ScheduledSQLConfiguration {
	s.Parameters = v
	return s
}

func (s *ScheduledSQLConfiguration) SetResourcePool(v string) *ScheduledSQLConfiguration {
	s.ResourcePool = &v
	return s
}

func (s *ScheduledSQLConfiguration) SetRoleArn(v string) *ScheduledSQLConfiguration {
	s.RoleArn = &v
	return s
}

func (s *ScheduledSQLConfiguration) SetScript(v string) *ScheduledSQLConfiguration {
	s.Script = &v
	return s
}

func (s *ScheduledSQLConfiguration) SetSourceLogstore(v string) *ScheduledSQLConfiguration {
	s.SourceLogstore = &v
	return s
}

func (s *ScheduledSQLConfiguration) SetSqlType(v string) *ScheduledSQLConfiguration {
	s.SqlType = &v
	return s
}

func (s *ScheduledSQLConfiguration) SetToTime(v int64) *ScheduledSQLConfiguration {
	s.ToTime = &v
	return s
}

func (s *ScheduledSQLConfiguration) SetToTimeExpr(v string) *ScheduledSQLConfiguration {
	s.ToTimeExpr = &v
	return s
}

type SeverityConfiguration struct {
	EvalCondition *ConditionConfiguration `json:"evalCondition,omitempty" xml:"evalCondition,omitempty"`
	// example:
	//
	// 8
	Severity *int32 `json:"severity,omitempty" xml:"severity,omitempty"`
}

func (s SeverityConfiguration) String() string {
	return tea.Prettify(s)
}

func (s SeverityConfiguration) GoString() string {
	return s.String()
}

func (s *SeverityConfiguration) SetEvalCondition(v *ConditionConfiguration) *SeverityConfiguration {
	s.EvalCondition = v
	return s
}

func (s *SeverityConfiguration) SetSeverity(v int32) *SeverityConfiguration {
	s.Severity = &v
	return s
}

type SinkAlerthubConfiguration struct {
	// example:
	//
	// true
	Enabled *bool `json:"enabled,omitempty" xml:"enabled,omitempty"`
}

func (s SinkAlerthubConfiguration) String() string {
	return tea.Prettify(s)
}

func (s SinkAlerthubConfiguration) GoString() string {
	return s.String()
}

func (s *SinkAlerthubConfiguration) SetEnabled(v bool) *SinkAlerthubConfiguration {
	s.Enabled = &v
	return s
}

type SinkCmsConfiguration struct {
	// example:
	//
	// true
	Enabled *bool `json:"enabled,omitempty" xml:"enabled,omitempty"`
}

func (s SinkCmsConfiguration) String() string {
	return tea.Prettify(s)
}

func (s SinkCmsConfiguration) GoString() string {
	return s.String()
}

func (s *SinkCmsConfiguration) SetEnabled(v bool) *SinkCmsConfiguration {
	s.Enabled = &v
	return s
}

type SinkEventStoreConfiguration struct {
	// example:
	//
	// true
	Enabled *bool `json:"enabled,omitempty" xml:"enabled,omitempty"`
	// example:
	//
	// cn-shanghai-intranet.log.aliyuncs.com
	Endpoint *string `json:"endpoint,omitempty" xml:"endpoint,omitempty"`
	// example:
	//
	// exampleStore
	EventStore *string `json:"eventStore,omitempty" xml:"eventStore,omitempty"`
	// example:
	//
	// exampleProject
	Project *string `json:"project,omitempty" xml:"project,omitempty"`
	// example:
	//
	// acs:ram::123456789:role/aliyunlogetlrole
	RoleArn *string `json:"roleArn,omitempty" xml:"roleArn,omitempty"`
}

func (s SinkEventStoreConfiguration) String() string {
	return tea.Prettify(s)
}

func (s SinkEventStoreConfiguration) GoString() string {
	return s.String()
}

func (s *SinkEventStoreConfiguration) SetEnabled(v bool) *SinkEventStoreConfiguration {
	s.Enabled = &v
	return s
}

func (s *SinkEventStoreConfiguration) SetEndpoint(v string) *SinkEventStoreConfiguration {
	s.Endpoint = &v
	return s
}

func (s *SinkEventStoreConfiguration) SetEventStore(v string) *SinkEventStoreConfiguration {
	s.EventStore = &v
	return s
}

func (s *SinkEventStoreConfiguration) SetProject(v string) *SinkEventStoreConfiguration {
	s.Project = &v
	return s
}

func (s *SinkEventStoreConfiguration) SetRoleArn(v string) *SinkEventStoreConfiguration {
	s.RoleArn = &v
	return s
}

type StoreViewStore struct {
	// This parameter is required.
	Project *string `json:"project,omitempty" xml:"project,omitempty"`
	Query   *string `json:"query,omitempty" xml:"query,omitempty"`
	// This parameter is required.
	StoreName *string `json:"storeName,omitempty" xml:"storeName,omitempty"`
}

func (s StoreViewStore) String() string {
	return tea.Prettify(s)
}

func (s StoreViewStore) GoString() string {
	return s.String()
}

func (s *StoreViewStore) SetProject(v string) *StoreViewStore {
	s.Project = &v
	return s
}

func (s *StoreViewStore) SetQuery(v string) *StoreViewStore {
	s.Query = &v
	return s
}

func (s *StoreViewStore) SetStoreName(v string) *StoreViewStore {
	s.StoreName = &v
	return s
}

type TemplateConfiguration struct {
	Aonotations map[string]interface{} `json:"aonotations,omitempty" xml:"aonotations,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// sls.app.ack.ip.not_enough
	Id *string `json:"id,omitempty" xml:"id,omitempty"`
	// example:
	//
	// cn
	Lang   *string                `json:"lang,omitempty" xml:"lang,omitempty"`
	Tokens map[string]interface{} `json:"tokens,omitempty" xml:"tokens,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// sys
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
	// example:
	//
	// 1
	Version *string `json:"version,omitempty" xml:"version,omitempty"`
}

func (s TemplateConfiguration) String() string {
	return tea.Prettify(s)
}

func (s TemplateConfiguration) GoString() string {
	return s.String()
}

func (s *TemplateConfiguration) SetAonotations(v map[string]interface{}) *TemplateConfiguration {
	s.Aonotations = v
	return s
}

func (s *TemplateConfiguration) SetId(v string) *TemplateConfiguration {
	s.Id = &v
	return s
}

func (s *TemplateConfiguration) SetLang(v string) *TemplateConfiguration {
	s.Lang = &v
	return s
}

func (s *TemplateConfiguration) SetTokens(v map[string]interface{}) *TemplateConfiguration {
	s.Tokens = v
	return s
}

func (s *TemplateConfiguration) SetType(v string) *TemplateConfiguration {
	s.Type = &v
	return s
}

func (s *TemplateConfiguration) SetVersion(v string) *TemplateConfiguration {
	s.Version = &v
	return s
}

type Ticket struct {
	// example:
	//
	// 1000000000
	CallerUid *int64 `json:"callerUid,omitempty" xml:"callerUid,omitempty"`
	// example:
	//
	// 2023-09-06 14:57:07
	CreateDate *string `json:"createDate,omitempty" xml:"createDate,omitempty"`
	// example:
	//
	// 100
	ExpirationTime *int64 `json:"expirationTime,omitempty" xml:"expirationTime,omitempty"`
	// example:
	//
	// 2023-09-06 14:58:07
	ExpireDate *string `json:"expireDate,omitempty" xml:"expireDate,omitempty"`
	// example:
	//
	// {"xx":"yy"}
	Extra *string `json:"extra,omitempty" xml:"extra,omitempty"`
	// example:
	//
	// 测试
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// example:
	//
	// 1
	Number *int32 `json:"number,omitempty" xml:"number,omitempty"`
	// example:
	//
	// {"type":"aliyun","ids":[1,2]}
	SharingTo *string `json:"sharingTo,omitempty" xml:"sharingTo,omitempty"`
	// example:
	//
	// xxxxx
	Ticket *string `json:"ticket,omitempty" xml:"ticket,omitempty"`
	// example:
	//
	// xxxxx
	TicketId *string `json:"ticketId,omitempty" xml:"ticketId,omitempty"`
	// example:
	//
	// 1
	UsedNumber *int32 `json:"usedNumber,omitempty" xml:"usedNumber,omitempty"`
	// example:
	//
	// false
	Valid *bool `json:"valid,omitempty" xml:"valid,omitempty"`
}

func (s Ticket) String() string {
	return tea.Prettify(s)
}

func (s Ticket) GoString() string {
	return s.String()
}

func (s *Ticket) SetCallerUid(v int64) *Ticket {
	s.CallerUid = &v
	return s
}

func (s *Ticket) SetCreateDate(v string) *Ticket {
	s.CreateDate = &v
	return s
}

func (s *Ticket) SetExpirationTime(v int64) *Ticket {
	s.ExpirationTime = &v
	return s
}

func (s *Ticket) SetExpireDate(v string) *Ticket {
	s.ExpireDate = &v
	return s
}

func (s *Ticket) SetExtra(v string) *Ticket {
	s.Extra = &v
	return s
}

func (s *Ticket) SetName(v string) *Ticket {
	s.Name = &v
	return s
}

func (s *Ticket) SetNumber(v int32) *Ticket {
	s.Number = &v
	return s
}

func (s *Ticket) SetSharingTo(v string) *Ticket {
	s.SharingTo = &v
	return s
}

func (s *Ticket) SetTicket(v string) *Ticket {
	s.Ticket = &v
	return s
}

func (s *Ticket) SetTicketId(v string) *Ticket {
	s.TicketId = &v
	return s
}

func (s *Ticket) SetUsedNumber(v int32) *Ticket {
	s.UsedNumber = &v
	return s
}

func (s *Ticket) SetValid(v bool) *Ticket {
	s.Valid = &v
	return s
}

type Chart struct {
	// This parameter is required.
	Action map[string]interface{} `json:"action,omitempty" xml:"action,omitempty"`
	// This parameter is required.
	Display map[string]interface{} `json:"display,omitempty" xml:"display,omitempty"`
	// This parameter is required.
	Search map[string]interface{} `json:"search,omitempty" xml:"search,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// my-chart
	Title *string `json:"title,omitempty" xml:"title,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// linepro
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s Chart) String() string {
	return tea.Prettify(s)
}

func (s Chart) GoString() string {
	return s.String()
}

func (s *Chart) SetAction(v map[string]interface{}) *Chart {
	s.Action = v
	return s
}

func (s *Chart) SetDisplay(v map[string]interface{}) *Chart {
	s.Display = v
	return s
}

func (s *Chart) SetSearch(v map[string]interface{}) *Chart {
	s.Search = v
	return s
}

func (s *Chart) SetTitle(v string) *Chart {
	s.Title = &v
	return s
}

func (s *Chart) SetType(v string) *Chart {
	s.Type = &v
	return s
}

type Dashboard struct {
	Attribute map[string]*string `json:"attribute,omitempty" xml:"attribute,omitempty"`
	// This parameter is required.
	Charts []*Chart `json:"charts,omitempty" xml:"charts,omitempty" type:"Repeated"`
	// This parameter is required.
	//
	// example:
	//
	// dashboard-1609294922657-434834
	DashboardName *string `json:"dashboardName,omitempty" xml:"dashboardName,omitempty"`
	// example:
	//
	// 这是一个仪表盘。
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// test-alert
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
}

func (s Dashboard) String() string {
	return tea.Prettify(s)
}

func (s Dashboard) GoString() string {
	return s.String()
}

func (s *Dashboard) SetAttribute(v map[string]*string) *Dashboard {
	s.Attribute = v
	return s
}

func (s *Dashboard) SetCharts(v []*Chart) *Dashboard {
	s.Charts = v
	return s
}

func (s *Dashboard) SetDashboardName(v string) *Dashboard {
	s.DashboardName = &v
	return s
}

func (s *Dashboard) SetDescription(v string) *Dashboard {
	s.Description = &v
	return s
}

func (s *Dashboard) SetDisplayName(v string) *Dashboard {
	s.DisplayName = &v
	return s
}

type ExternalStore struct {
	// This parameter is required.
	//
	// example:
	//
	// rds_store
	ExternalStoreName *string `json:"externalStoreName,omitempty" xml:"externalStoreName,omitempty"`
	// This parameter is required.
	Parameter map[string]interface{} `json:"parameter,omitempty" xml:"parameter,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// rds-vpc
	StoreType *string `json:"storeType,omitempty" xml:"storeType,omitempty"`
}

func (s ExternalStore) String() string {
	return tea.Prettify(s)
}

func (s ExternalStore) GoString() string {
	return s.String()
}

func (s *ExternalStore) SetExternalStoreName(v string) *ExternalStore {
	s.ExternalStoreName = &v
	return s
}

func (s *ExternalStore) SetParameter(v map[string]interface{}) *ExternalStore {
	s.Parameter = v
	return s
}

func (s *ExternalStore) SetStoreType(v string) *ExternalStore {
	s.StoreType = &v
	return s
}

type Index struct {
	Keys map[string]*IndexKey `json:"keys,omitempty" xml:"keys,omitempty"`
	Line *IndexLine           `json:"line,omitempty" xml:"line,omitempty" type:"Struct"`
	// example:
	//
	// true
	LogReduce          *bool     `json:"log_reduce,omitempty" xml:"log_reduce,omitempty"`
	LogReduceBlackList []*string `json:"log_reduce_black_list,omitempty" xml:"log_reduce_black_list,omitempty" type:"Repeated"`
	LogReduceWhiteList []*string `json:"log_reduce_white_list,omitempty" xml:"log_reduce_white_list,omitempty" type:"Repeated"`
	// example:
	//
	// 2048
	MaxTextLen *int32 `json:"max_text_len,omitempty" xml:"max_text_len,omitempty"`
}

func (s Index) String() string {
	return tea.Prettify(s)
}

func (s Index) GoString() string {
	return s.String()
}

func (s *Index) SetKeys(v map[string]*IndexKey) *Index {
	s.Keys = v
	return s
}

func (s *Index) SetLine(v *IndexLine) *Index {
	s.Line = v
	return s
}

func (s *Index) SetLogReduce(v bool) *Index {
	s.LogReduce = &v
	return s
}

func (s *Index) SetLogReduceBlackList(v []*string) *Index {
	s.LogReduceBlackList = v
	return s
}

func (s *Index) SetLogReduceWhiteList(v []*string) *Index {
	s.LogReduceWhiteList = v
	return s
}

func (s *Index) SetMaxTextLen(v int32) *Index {
	s.MaxTextLen = &v
	return s
}

type IndexLine struct {
	// example:
	//
	// true
	CaseSensitive *bool `json:"caseSensitive,omitempty" xml:"caseSensitive,omitempty"`
	// example:
	//
	// true
	Chn         *bool     `json:"chn,omitempty" xml:"chn,omitempty"`
	ExcludeKeys []*string `json:"exclude_keys,omitempty" xml:"exclude_keys,omitempty" type:"Repeated"`
	IncludeKeys []*string `json:"include_keys,omitempty" xml:"include_keys,omitempty" type:"Repeated"`
	// This parameter is required.
	Token []*string `json:"token,omitempty" xml:"token,omitempty" type:"Repeated"`
}

func (s IndexLine) String() string {
	return tea.Prettify(s)
}

func (s IndexLine) GoString() string {
	return s.String()
}

func (s *IndexLine) SetCaseSensitive(v bool) *IndexLine {
	s.CaseSensitive = &v
	return s
}

func (s *IndexLine) SetChn(v bool) *IndexLine {
	s.Chn = &v
	return s
}

func (s *IndexLine) SetExcludeKeys(v []*string) *IndexLine {
	s.ExcludeKeys = v
	return s
}

func (s *IndexLine) SetIncludeKeys(v []*string) *IndexLine {
	s.IncludeKeys = v
	return s
}

func (s *IndexLine) SetToken(v []*string) *IndexLine {
	s.Token = v
	return s
}

type Logging struct {
	// This parameter is required.
	LoggingDetails []*LoggingLoggingDetails `json:"loggingDetails,omitempty" xml:"loggingDetails,omitempty" type:"Repeated"`
	// This parameter is required.
	//
	// example:
	//
	// my-project
	LoggingProject *string `json:"loggingProject,omitempty" xml:"loggingProject,omitempty"`
}

func (s Logging) String() string {
	return tea.Prettify(s)
}

func (s Logging) GoString() string {
	return s.String()
}

func (s *Logging) SetLoggingDetails(v []*LoggingLoggingDetails) *Logging {
	s.LoggingDetails = v
	return s
}

func (s *Logging) SetLoggingProject(v string) *Logging {
	s.LoggingProject = &v
	return s
}

type LoggingLoggingDetails struct {
	// This parameter is required.
	//
	// example:
	//
	// my-logstore
	Logstore *string `json:"logstore,omitempty" xml:"logstore,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// consumergroup_log
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s LoggingLoggingDetails) String() string {
	return tea.Prettify(s)
}

func (s LoggingLoggingDetails) GoString() string {
	return s.String()
}

func (s *LoggingLoggingDetails) SetLogstore(v string) *LoggingLoggingDetails {
	s.Logstore = &v
	return s
}

func (s *LoggingLoggingDetails) SetType(v string) *LoggingLoggingDetails {
	s.Type = &v
	return s
}

type Logstore struct {
	// example:
	//
	// true
	AppendMeta *bool `json:"appendMeta,omitempty" xml:"appendMeta,omitempty"`
	// example:
	//
	// true
	AutoSplit  *bool  `json:"autoSplit,omitempty" xml:"autoSplit,omitempty"`
	CreateTime *int32 `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// example:
	//
	// false
	EnableTracking *bool        `json:"enable_tracking,omitempty" xml:"enable_tracking,omitempty"`
	EncryptConf    *EncryptConf `json:"encrypt_conf,omitempty" xml:"encrypt_conf,omitempty"`
	HotTtl         *int32       `json:"hot_ttl,omitempty" xml:"hot_ttl,omitempty"`
	// example:
	//
	// 30
	InfrequentAccessTTL *int32 `json:"infrequentAccessTTL,omitempty" xml:"infrequentAccessTTL,omitempty"`
	LastModifyTime      *int32 `json:"lastModifyTime,omitempty" xml:"lastModifyTime,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// my-logstore
	LogstoreName *string `json:"logstoreName,omitempty" xml:"logstoreName,omitempty"`
	// example:
	//
	// 2
	MaxSplitShard *int32 `json:"maxSplitShard,omitempty" xml:"maxSplitShard,omitempty"`
	// example:
	//
	// standard
	Mode        *string `json:"mode,omitempty" xml:"mode,omitempty"`
	ProcessorId *string `json:"processorId,omitempty" xml:"processorId,omitempty"`
	ProductType *string `json:"productType,omitempty" xml:"productType,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// 2
	ShardCount    *int32  `json:"shardCount,omitempty" xml:"shardCount,omitempty"`
	TelemetryType *string `json:"telemetryType,omitempty" xml:"telemetryType,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// 30
	Ttl *int32 `json:"ttl,omitempty" xml:"ttl,omitempty"`
}

func (s Logstore) String() string {
	return tea.Prettify(s)
}

func (s Logstore) GoString() string {
	return s.String()
}

func (s *Logstore) SetAppendMeta(v bool) *Logstore {
	s.AppendMeta = &v
	return s
}

func (s *Logstore) SetAutoSplit(v bool) *Logstore {
	s.AutoSplit = &v
	return s
}

func (s *Logstore) SetCreateTime(v int32) *Logstore {
	s.CreateTime = &v
	return s
}

func (s *Logstore) SetEnableTracking(v bool) *Logstore {
	s.EnableTracking = &v
	return s
}

func (s *Logstore) SetEncryptConf(v *EncryptConf) *Logstore {
	s.EncryptConf = v
	return s
}

func (s *Logstore) SetHotTtl(v int32) *Logstore {
	s.HotTtl = &v
	return s
}

func (s *Logstore) SetInfrequentAccessTTL(v int32) *Logstore {
	s.InfrequentAccessTTL = &v
	return s
}

func (s *Logstore) SetLastModifyTime(v int32) *Logstore {
	s.LastModifyTime = &v
	return s
}

func (s *Logstore) SetLogstoreName(v string) *Logstore {
	s.LogstoreName = &v
	return s
}

func (s *Logstore) SetMaxSplitShard(v int32) *Logstore {
	s.MaxSplitShard = &v
	return s
}

func (s *Logstore) SetMode(v string) *Logstore {
	s.Mode = &v
	return s
}

func (s *Logstore) SetProcessorId(v string) *Logstore {
	s.ProcessorId = &v
	return s
}

func (s *Logstore) SetProductType(v string) *Logstore {
	s.ProductType = &v
	return s
}

func (s *Logstore) SetShardCount(v int32) *Logstore {
	s.ShardCount = &v
	return s
}

func (s *Logstore) SetTelemetryType(v string) *Logstore {
	s.TelemetryType = &v
	return s
}

func (s *Logstore) SetTtl(v int32) *Logstore {
	s.Ttl = &v
	return s
}

type Machine struct {
	// example:
	//
	// test
	HostId *string `json:"host-id,omitempty" xml:"host-id,omitempty"`
	// example:
	//
	// 192.168.x.x
	Ip *string `json:"ip,omitempty" xml:"ip,omitempty"`
	// example:
	//
	// 1657509674
	LastHeartbeatTime *int64 `json:"lastHeartbeatTime,omitempty" xml:"lastHeartbeatTime,omitempty"`
	// example:
	//
	// 3B70F4F1-80F7-46C4-A6C1-100D66C***47
	MachineUniqueid *string `json:"machine-uniqueid,omitempty" xml:"machine-uniqueid,omitempty"`
	// example:
	//
	// test
	UserdefinedId *string `json:"userdefined-id,omitempty" xml:"userdefined-id,omitempty"`
}

func (s Machine) String() string {
	return tea.Prettify(s)
}

func (s Machine) GoString() string {
	return s.String()
}

func (s *Machine) SetHostId(v string) *Machine {
	s.HostId = &v
	return s
}

func (s *Machine) SetIp(v string) *Machine {
	s.Ip = &v
	return s
}

func (s *Machine) SetLastHeartbeatTime(v int64) *Machine {
	s.LastHeartbeatTime = &v
	return s
}

func (s *Machine) SetMachineUniqueid(v string) *Machine {
	s.MachineUniqueid = &v
	return s
}

func (s *Machine) SetUserdefinedId(v string) *Machine {
	s.UserdefinedId = &v
	return s
}

type MachineGroup struct {
	GroupAttribute *MachineGroupGroupAttribute `json:"groupAttribute,omitempty" xml:"groupAttribute,omitempty" type:"Struct"`
	// This parameter is required.
	//
	// example:
	//
	// test-group
	GroupName *string `json:"groupName,omitempty" xml:"groupName,omitempty"`
	GroupType *string `json:"groupType,omitempty" xml:"groupType,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// ip
	MachineIdentifyType *string `json:"machineIdentifyType,omitempty" xml:"machineIdentifyType,omitempty"`
	// This parameter is required.
	MachineList []*string `json:"machineList,omitempty" xml:"machineList,omitempty" type:"Repeated"`
}

func (s MachineGroup) String() string {
	return tea.Prettify(s)
}

func (s MachineGroup) GoString() string {
	return s.String()
}

func (s *MachineGroup) SetGroupAttribute(v *MachineGroupGroupAttribute) *MachineGroup {
	s.GroupAttribute = v
	return s
}

func (s *MachineGroup) SetGroupName(v string) *MachineGroup {
	s.GroupName = &v
	return s
}

func (s *MachineGroup) SetGroupType(v string) *MachineGroup {
	s.GroupType = &v
	return s
}

func (s *MachineGroup) SetMachineIdentifyType(v string) *MachineGroup {
	s.MachineIdentifyType = &v
	return s
}

func (s *MachineGroup) SetMachineList(v []*string) *MachineGroup {
	s.MachineList = v
	return s
}

type MachineGroupGroupAttribute struct {
	// example:
	//
	// test-group
	ExternalName *string `json:"externalName,omitempty" xml:"externalName,omitempty"`
	// example:
	//
	// test-topic
	GroupTopic *string `json:"groupTopic,omitempty" xml:"groupTopic,omitempty"`
}

func (s MachineGroupGroupAttribute) String() string {
	return tea.Prettify(s)
}

func (s MachineGroupGroupAttribute) GoString() string {
	return s.String()
}

func (s *MachineGroupGroupAttribute) SetExternalName(v string) *MachineGroupGroupAttribute {
	s.ExternalName = &v
	return s
}

func (s *MachineGroupGroupAttribute) SetGroupTopic(v string) *MachineGroupGroupAttribute {
	s.GroupTopic = &v
	return s
}

type Project struct {
	CreateTime *string `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// example:
	//
	// LRS
	DataRedundancyType *string `json:"dataRedundancyType,omitempty" xml:"dataRedundancyType,omitempty"`
	// This parameter is required.
	Description    *string `json:"description,omitempty" xml:"description,omitempty"`
	LastModifyTime *string `json:"lastModifyTime,omitempty" xml:"lastModifyTime,omitempty"`
	Location       *string `json:"location,omitempty" xml:"location,omitempty"`
	Owner          *string `json:"owner,omitempty" xml:"owner,omitempty"`
	// This parameter is required.
	ProjectName *string                `json:"projectName,omitempty" xml:"projectName,omitempty"`
	Quota       map[string]interface{} `json:"quota,omitempty" xml:"quota,omitempty"`
	// example:
	//
	// false
	RecycleBinEnabled *bool   `json:"recycleBinEnabled,omitempty" xml:"recycleBinEnabled,omitempty"`
	Region            *string `json:"region,omitempty" xml:"region,omitempty"`
	ResourceGroupId   *string `json:"resourceGroupId,omitempty" xml:"resourceGroupId,omitempty"`
	Status            *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s Project) String() string {
	return tea.Prettify(s)
}

func (s Project) GoString() string {
	return s.String()
}

func (s *Project) SetCreateTime(v string) *Project {
	s.CreateTime = &v
	return s
}

func (s *Project) SetDataRedundancyType(v string) *Project {
	s.DataRedundancyType = &v
	return s
}

func (s *Project) SetDescription(v string) *Project {
	s.Description = &v
	return s
}

func (s *Project) SetLastModifyTime(v string) *Project {
	s.LastModifyTime = &v
	return s
}

func (s *Project) SetLocation(v string) *Project {
	s.Location = &v
	return s
}

func (s *Project) SetOwner(v string) *Project {
	s.Owner = &v
	return s
}

func (s *Project) SetProjectName(v string) *Project {
	s.ProjectName = &v
	return s
}

func (s *Project) SetQuota(v map[string]interface{}) *Project {
	s.Quota = v
	return s
}

func (s *Project) SetRecycleBinEnabled(v bool) *Project {
	s.RecycleBinEnabled = &v
	return s
}

func (s *Project) SetRegion(v string) *Project {
	s.Region = &v
	return s
}

func (s *Project) SetResourceGroupId(v string) *Project {
	s.ResourceGroupId = &v
	return s
}

func (s *Project) SetStatus(v string) *Project {
	s.Status = &v
	return s
}

type ServiceStatus struct {
	// example:
	//
	// false
	Enabled *bool `json:"enabled,omitempty" xml:"enabled,omitempty"`
	// example:
	//
	// NotExist
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s ServiceStatus) String() string {
	return tea.Prettify(s)
}

func (s ServiceStatus) GoString() string {
	return s.String()
}

func (s *ServiceStatus) SetEnabled(v bool) *ServiceStatus {
	s.Enabled = &v
	return s
}

func (s *ServiceStatus) SetStatus(v string) *ServiceStatus {
	s.Status = &v
	return s
}

type Shard struct {
	// example:
	//
	// 1453949705
	CreateTime *int32 `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// example:
	//
	// 8000000000000000000000000000000
	ExclusiveEndKey *string `json:"exclusiveEndKey,omitempty" xml:"exclusiveEndKey,omitempty"`
	// example:
	//
	// 00000000000000000000000000000000
	InclusiveBeginKey *string `json:"inclusiveBeginKey,omitempty" xml:"inclusiveBeginKey,omitempty"`
	// example:
	//
	// 0
	ShardID *int32 `json:"shardID,omitempty" xml:"shardID,omitempty"`
	// example:
	//
	// readwrite
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s Shard) String() string {
	return tea.Prettify(s)
}

func (s Shard) GoString() string {
	return s.String()
}

func (s *Shard) SetCreateTime(v int32) *Shard {
	s.CreateTime = &v
	return s
}

func (s *Shard) SetExclusiveEndKey(v string) *Shard {
	s.ExclusiveEndKey = &v
	return s
}

func (s *Shard) SetInclusiveBeginKey(v string) *Shard {
	s.InclusiveBeginKey = &v
	return s
}

func (s *Shard) SetShardID(v int32) *Shard {
	s.ShardID = &v
	return s
}

func (s *Shard) SetStatus(v string) *Shard {
	s.Status = &v
	return s
}

type MLDataParamAnnotationsValue struct {
	// example:
	//
	// xxxx
	AnnotatedBy *string `json:"annotatedBy,omitempty" xml:"annotatedBy,omitempty"`
	// example:
	//
	// 1694761550
	UpdateTime *int64               `json:"updateTime,omitempty" xml:"updateTime,omitempty"`
	Results    []map[string]*string `json:"results,omitempty" xml:"results,omitempty" type:"Repeated"`
}

func (s MLDataParamAnnotationsValue) String() string {
	return tea.Prettify(s)
}

func (s MLDataParamAnnotationsValue) GoString() string {
	return s.String()
}

func (s *MLDataParamAnnotationsValue) SetAnnotatedBy(v string) *MLDataParamAnnotationsValue {
	s.AnnotatedBy = &v
	return s
}

func (s *MLDataParamAnnotationsValue) SetUpdateTime(v int64) *MLDataParamAnnotationsValue {
	s.UpdateTime = &v
	return s
}

func (s *MLDataParamAnnotationsValue) SetResults(v []map[string]*string) *MLDataParamAnnotationsValue {
	s.Results = v
	return s
}

type MLDataParamPredictionsValue struct {
	// example:
	//
	// xxx
	AnnotatedBy *string `json:"annotatedBy,omitempty" xml:"annotatedBy,omitempty"`
	// example:
	//
	// 1694761550
	UpdateTime *int64               `json:"updateTime,omitempty" xml:"updateTime,omitempty"`
	Results    []map[string]*string `json:"results,omitempty" xml:"results,omitempty" type:"Repeated"`
}

func (s MLDataParamPredictionsValue) String() string {
	return tea.Prettify(s)
}

func (s MLDataParamPredictionsValue) GoString() string {
	return s.String()
}

func (s *MLDataParamPredictionsValue) SetAnnotatedBy(v string) *MLDataParamPredictionsValue {
	s.AnnotatedBy = &v
	return s
}

func (s *MLDataParamPredictionsValue) SetUpdateTime(v int64) *MLDataParamPredictionsValue {
	s.UpdateTime = &v
	return s
}

func (s *MLDataParamPredictionsValue) SetResults(v []map[string]*string) *MLDataParamPredictionsValue {
	s.Results = v
	return s
}

type ApplyConfigToMachineGroupResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s ApplyConfigToMachineGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ApplyConfigToMachineGroupResponse) GoString() string {
	return s.String()
}

func (s *ApplyConfigToMachineGroupResponse) SetHeaders(v map[string]*string) *ApplyConfigToMachineGroupResponse {
	s.Headers = v
	return s
}

func (s *ApplyConfigToMachineGroupResponse) SetStatusCode(v int32) *ApplyConfigToMachineGroupResponse {
	s.StatusCode = &v
	return s
}

type ChangeResourceGroupRequest struct {
	// The ID of the resource group.
	//
	// This parameter is required.
	//
	// example:
	//
	// rg-aek2i7nhaxifxey
	ResourceGroupId *string `json:"resourceGroupId,omitempty" xml:"resourceGroupId,omitempty"`
	// The ID of the resource.
	//
	// This parameter is required.
	//
	// example:
	//
	// ali-test-project
	ResourceId *string `json:"resourceId,omitempty" xml:"resourceId,omitempty"`
	// The type of the resource. Only PROJECT is supported. Set the value to PROJECT.
	//
	// example:
	//
	// PROJECT
	ResourceType *string `json:"resourceType,omitempty" xml:"resourceType,omitempty"`
}

func (s ChangeResourceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceGroupRequest) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupRequest) SetResourceGroupId(v string) *ChangeResourceGroupRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetResourceId(v string) *ChangeResourceGroupRequest {
	s.ResourceId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetResourceType(v string) *ChangeResourceGroupRequest {
	s.ResourceType = &v
	return s
}

type ChangeResourceGroupResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s ChangeResourceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceGroupResponse) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupResponse) SetHeaders(v map[string]*string) *ChangeResourceGroupResponse {
	s.Headers = v
	return s
}

func (s *ChangeResourceGroupResponse) SetStatusCode(v int32) *ChangeResourceGroupResponse {
	s.StatusCode = &v
	return s
}

type ConsumerGroupHeartBeatRequest struct {
	// The IDs of shards whose data is being consumed.
	//
	// This parameter is required.
	Body []*int32 `json:"body,omitempty" xml:"body,omitempty" type:"Repeated"`
	// The consumer.
	//
	// This parameter is required.
	//
	// example:
	//
	// consumer_1
	Consumer *string `json:"consumer,omitempty" xml:"consumer,omitempty"`
}

func (s ConsumerGroupHeartBeatRequest) String() string {
	return tea.Prettify(s)
}

func (s ConsumerGroupHeartBeatRequest) GoString() string {
	return s.String()
}

func (s *ConsumerGroupHeartBeatRequest) SetBody(v []*int32) *ConsumerGroupHeartBeatRequest {
	s.Body = v
	return s
}

func (s *ConsumerGroupHeartBeatRequest) SetConsumer(v string) *ConsumerGroupHeartBeatRequest {
	s.Consumer = &v
	return s
}

type ConsumerGroupHeartBeatResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       []*int32           `json:"body,omitempty" xml:"body,omitempty" type:"Repeated"`
}

func (s ConsumerGroupHeartBeatResponse) String() string {
	return tea.Prettify(s)
}

func (s ConsumerGroupHeartBeatResponse) GoString() string {
	return s.String()
}

func (s *ConsumerGroupHeartBeatResponse) SetHeaders(v map[string]*string) *ConsumerGroupHeartBeatResponse {
	s.Headers = v
	return s
}

func (s *ConsumerGroupHeartBeatResponse) SetStatusCode(v int32) *ConsumerGroupHeartBeatResponse {
	s.StatusCode = &v
	return s
}

func (s *ConsumerGroupHeartBeatResponse) SetBody(v []*int32) *ConsumerGroupHeartBeatResponse {
	s.Body = v
	return s
}

type ConsumerGroupUpdateCheckPointRequest struct {
	// The value of the checkpoint.
	//
	// This parameter is required.
	//
	// example:
	//
	// MTUyNDE1NTM3OTM3MzkwODQ5Ng==
	Checkpoint *string `json:"checkpoint,omitempty" xml:"checkpoint,omitempty"`
	// The ID of the shard.
	//
	// This parameter is required.
	//
	// example:
	//
	// 0
	Shard *int32 `json:"shard,omitempty" xml:"shard,omitempty"`
	// The consumer.
	//
	// This parameter is required.
	//
	// example:
	//
	// consumer_1
	Consumer *string `json:"consumer,omitempty" xml:"consumer,omitempty"`
	// Specifies whether to enable forceful updates. Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// False
	ForceSuccess *bool `json:"forceSuccess,omitempty" xml:"forceSuccess,omitempty"`
}

func (s ConsumerGroupUpdateCheckPointRequest) String() string {
	return tea.Prettify(s)
}

func (s ConsumerGroupUpdateCheckPointRequest) GoString() string {
	return s.String()
}

func (s *ConsumerGroupUpdateCheckPointRequest) SetCheckpoint(v string) *ConsumerGroupUpdateCheckPointRequest {
	s.Checkpoint = &v
	return s
}

func (s *ConsumerGroupUpdateCheckPointRequest) SetShard(v int32) *ConsumerGroupUpdateCheckPointRequest {
	s.Shard = &v
	return s
}

func (s *ConsumerGroupUpdateCheckPointRequest) SetConsumer(v string) *ConsumerGroupUpdateCheckPointRequest {
	s.Consumer = &v
	return s
}

func (s *ConsumerGroupUpdateCheckPointRequest) SetForceSuccess(v bool) *ConsumerGroupUpdateCheckPointRequest {
	s.ForceSuccess = &v
	return s
}

type ConsumerGroupUpdateCheckPointResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s ConsumerGroupUpdateCheckPointResponse) String() string {
	return tea.Prettify(s)
}

func (s ConsumerGroupUpdateCheckPointResponse) GoString() string {
	return s.String()
}

func (s *ConsumerGroupUpdateCheckPointResponse) SetHeaders(v map[string]*string) *ConsumerGroupUpdateCheckPointResponse {
	s.Headers = v
	return s
}

func (s *ConsumerGroupUpdateCheckPointResponse) SetStatusCode(v int32) *ConsumerGroupUpdateCheckPointResponse {
	s.StatusCode = &v
	return s
}

type CreateAgentInstanceConfigRequest struct {
	// This parameter is required.
	Config *string `json:"config,omitempty" xml:"config,omitempty"`
	// This parameter is required.
	ConfigMatcher *string `json:"configMatcher,omitempty" xml:"configMatcher,omitempty"`
	// This parameter is required.
	ConfigName *string `json:"configName,omitempty" xml:"configName,omitempty"`
	IsGray     *bool   `json:"isGray,omitempty" xml:"isGray,omitempty"`
}

func (s CreateAgentInstanceConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAgentInstanceConfigRequest) GoString() string {
	return s.String()
}

func (s *CreateAgentInstanceConfigRequest) SetConfig(v string) *CreateAgentInstanceConfigRequest {
	s.Config = &v
	return s
}

func (s *CreateAgentInstanceConfigRequest) SetConfigMatcher(v string) *CreateAgentInstanceConfigRequest {
	s.ConfigMatcher = &v
	return s
}

func (s *CreateAgentInstanceConfigRequest) SetConfigName(v string) *CreateAgentInstanceConfigRequest {
	s.ConfigName = &v
	return s
}

func (s *CreateAgentInstanceConfigRequest) SetIsGray(v bool) *CreateAgentInstanceConfigRequest {
	s.IsGray = &v
	return s
}

type CreateAgentInstanceConfigResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateAgentInstanceConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAgentInstanceConfigResponse) GoString() string {
	return s.String()
}

func (s *CreateAgentInstanceConfigResponse) SetHeaders(v map[string]*string) *CreateAgentInstanceConfigResponse {
	s.Headers = v
	return s
}

func (s *CreateAgentInstanceConfigResponse) SetStatusCode(v int32) *CreateAgentInstanceConfigResponse {
	s.StatusCode = &v
	return s
}

type CreateAlertRequest struct {
	// The detailed configurations of the alert rule.
	//
	// This parameter is required.
	Configuration *AlertConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty"`
	// The description of the alert rule.
	//
	// example:
	//
	// An alert rule
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// The display name of the alert rule.
	//
	// This parameter is required.
	//
	// example:
	//
	// test-alert
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// The name of the alert rule. Make sure that the name is unique in a project.
	//
	// This parameter is required.
	//
	// example:
	//
	// alert-123456
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The scheduling configurations of the alert rule.
	//
	// This parameter is required.
	Schedule *Schedule `json:"schedule,omitempty" xml:"schedule,omitempty"`
}

func (s CreateAlertRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAlertRequest) GoString() string {
	return s.String()
}

func (s *CreateAlertRequest) SetConfiguration(v *AlertConfiguration) *CreateAlertRequest {
	s.Configuration = v
	return s
}

func (s *CreateAlertRequest) SetDescription(v string) *CreateAlertRequest {
	s.Description = &v
	return s
}

func (s *CreateAlertRequest) SetDisplayName(v string) *CreateAlertRequest {
	s.DisplayName = &v
	return s
}

func (s *CreateAlertRequest) SetName(v string) *CreateAlertRequest {
	s.Name = &v
	return s
}

func (s *CreateAlertRequest) SetSchedule(v *Schedule) *CreateAlertRequest {
	s.Schedule = v
	return s
}

type CreateAlertResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateAlertResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAlertResponse) GoString() string {
	return s.String()
}

func (s *CreateAlertResponse) SetHeaders(v map[string]*string) *CreateAlertResponse {
	s.Headers = v
	return s
}

func (s *CreateAlertResponse) SetStatusCode(v int32) *CreateAlertResponse {
	s.StatusCode = &v
	return s
}

type CreateAnnotationDataSetRequest struct {
	// The data structure of the request.
	Body *MLDataSetParam `json:"body,omitempty" xml:"body,omitempty"`
	// The unique identifier of the dataset.
	//
	// example:
	//
	// cb8cc4eb51a85e823471cdb368fae9be
	DatasetId *string `json:"datasetId,omitempty" xml:"datasetId,omitempty"`
}

func (s CreateAnnotationDataSetRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAnnotationDataSetRequest) GoString() string {
	return s.String()
}

func (s *CreateAnnotationDataSetRequest) SetBody(v *MLDataSetParam) *CreateAnnotationDataSetRequest {
	s.Body = v
	return s
}

func (s *CreateAnnotationDataSetRequest) SetDatasetId(v string) *CreateAnnotationDataSetRequest {
	s.DatasetId = &v
	return s
}

type CreateAnnotationDataSetResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateAnnotationDataSetResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAnnotationDataSetResponse) GoString() string {
	return s.String()
}

func (s *CreateAnnotationDataSetResponse) SetHeaders(v map[string]*string) *CreateAnnotationDataSetResponse {
	s.Headers = v
	return s
}

func (s *CreateAnnotationDataSetResponse) SetStatusCode(v int32) *CreateAnnotationDataSetResponse {
	s.StatusCode = &v
	return s
}

type CreateAnnotationLabelRequest struct {
	// The data structure of the request.
	Body *MLLabelParam `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateAnnotationLabelRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAnnotationLabelRequest) GoString() string {
	return s.String()
}

func (s *CreateAnnotationLabelRequest) SetBody(v *MLLabelParam) *CreateAnnotationLabelRequest {
	s.Body = v
	return s
}

type CreateAnnotationLabelResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateAnnotationLabelResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAnnotationLabelResponse) GoString() string {
	return s.String()
}

func (s *CreateAnnotationLabelResponse) SetHeaders(v map[string]*string) *CreateAnnotationLabelResponse {
	s.Headers = v
	return s
}

func (s *CreateAnnotationLabelResponse) SetStatusCode(v int32) *CreateAnnotationLabelResponse {
	s.StatusCode = &v
	return s
}

type CreateConfigRequest struct {
	// The body of the request.
	Body *LogtailConfig `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateConfigRequest) GoString() string {
	return s.String()
}

func (s *CreateConfigRequest) SetBody(v *LogtailConfig) *CreateConfigRequest {
	s.Body = v
	return s
}

type CreateConfigResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateConfigResponse) GoString() string {
	return s.String()
}

func (s *CreateConfigResponse) SetHeaders(v map[string]*string) *CreateConfigResponse {
	s.Headers = v
	return s
}

func (s *CreateConfigResponse) SetStatusCode(v int32) *CreateConfigResponse {
	s.StatusCode = &v
	return s
}

type CreateConsumerGroupRequest struct {
	// The name of the consumer group. The name must be unique in a project.
	//
	// This parameter is required.
	//
	// example:
	//
	// consumerGroupX
	ConsumerGroup *string `json:"consumerGroup,omitempty" xml:"consumerGroup,omitempty"`
	// Specifies whether to consume data in sequence. Valid values:
	//
	// 	- true
	//
	//     	- In a shard, data is consumed in ascending order based on the value of the \\*\\*__tag__:__receive_time__\\*\\	- field.
	//
	//     	- If a shard is split, data in the original shard is consumed first. Then, data in the new shards is consumed at the same time.
	//
	//     	- If shards are merged, data in the original shards is consumed first. Then, data in the new shard is consumed.
	//
	// 	- false Data in all shards is consumed at the same time. If a new shard is generated after a shard is split or after shards are merged, data in the new shard is immediately consumed.
	//
	// This parameter is required.
	//
	// example:
	//
	// true
	Order *bool `json:"order,omitempty" xml:"order,omitempty"`
	// The timeout period. If the server does not receive heartbeats from a consumer within the timeout period, the server deletes the consumer. Unit: seconds.
	//
	// This parameter is required.
	//
	// example:
	//
	// 300
	Timeout *int32 `json:"timeout,omitempty" xml:"timeout,omitempty"`
}

func (s CreateConsumerGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateConsumerGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateConsumerGroupRequest) SetConsumerGroup(v string) *CreateConsumerGroupRequest {
	s.ConsumerGroup = &v
	return s
}

func (s *CreateConsumerGroupRequest) SetOrder(v bool) *CreateConsumerGroupRequest {
	s.Order = &v
	return s
}

func (s *CreateConsumerGroupRequest) SetTimeout(v int32) *CreateConsumerGroupRequest {
	s.Timeout = &v
	return s
}

type CreateConsumerGroupResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateConsumerGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateConsumerGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateConsumerGroupResponse) SetHeaders(v map[string]*string) *CreateConsumerGroupResponse {
	s.Headers = v
	return s
}

func (s *CreateConsumerGroupResponse) SetStatusCode(v int32) *CreateConsumerGroupResponse {
	s.StatusCode = &v
	return s
}

type CreateDashboardRequest struct {
	// The data structure of the dashboard.
	//
	// This parameter is required.
	Body *Dashboard `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateDashboardRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDashboardRequest) GoString() string {
	return s.String()
}

func (s *CreateDashboardRequest) SetBody(v *Dashboard) *CreateDashboardRequest {
	s.Body = v
	return s
}

type CreateDashboardResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateDashboardResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDashboardResponse) GoString() string {
	return s.String()
}

func (s *CreateDashboardResponse) SetHeaders(v map[string]*string) *CreateDashboardResponse {
	s.Headers = v
	return s
}

func (s *CreateDashboardResponse) SetStatusCode(v int32) *CreateDashboardResponse {
	s.StatusCode = &v
	return s
}

type CreateDomainRequest struct {
	// The domain name.
	//
	// This parameter is required.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"domainName,omitempty" xml:"domainName,omitempty"`
}

func (s CreateDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDomainRequest) GoString() string {
	return s.String()
}

func (s *CreateDomainRequest) SetDomainName(v string) *CreateDomainRequest {
	s.DomainName = &v
	return s
}

type CreateDomainResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDomainResponse) GoString() string {
	return s.String()
}

func (s *CreateDomainResponse) SetHeaders(v map[string]*string) *CreateDomainResponse {
	s.Headers = v
	return s
}

func (s *CreateDomainResponse) SetStatusCode(v int32) *CreateDomainResponse {
	s.StatusCode = &v
	return s
}

type CreateDownloadJobRequest struct {
	// 下载配置
	//
	// This parameter is required.
	Configuration *CreateDownloadJobRequestConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty" type:"Struct"`
	// 任务描述
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// 任务显示名称
	//
	// This parameter is required.
	//
	// example:
	//
	// download-123456789
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// 代表资源名称的资源属性字段
	//
	// This parameter is required.
	//
	// example:
	//
	// download-123
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
}

func (s CreateDownloadJobRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDownloadJobRequest) GoString() string {
	return s.String()
}

func (s *CreateDownloadJobRequest) SetConfiguration(v *CreateDownloadJobRequestConfiguration) *CreateDownloadJobRequest {
	s.Configuration = v
	return s
}

func (s *CreateDownloadJobRequest) SetDescription(v string) *CreateDownloadJobRequest {
	s.Description = &v
	return s
}

func (s *CreateDownloadJobRequest) SetDisplayName(v string) *CreateDownloadJobRequest {
	s.DisplayName = &v
	return s
}

func (s *CreateDownloadJobRequest) SetName(v string) *CreateDownloadJobRequest {
	s.Name = &v
	return s
}

type CreateDownloadJobRequestConfiguration struct {
	// This parameter is required.
	//
	// example:
	//
	// false
	AllowInComplete *bool `json:"allowInComplete,omitempty" xml:"allowInComplete,omitempty"`
	// 起点时间戳（精确到秒）
	//
	// This parameter is required.
	//
	// example:
	//
	// 1722406260
	FromTime *int64 `json:"fromTime,omitempty" xml:"fromTime,omitempty"`
	// 源logstore
	//
	// This parameter is required.
	//
	// example:
	//
	// test-logstore
	Logstore *string `json:"logstore,omitempty" xml:"logstore,omitempty"`
	// 是否启用powerSql
	//
	// example:
	//
	// true
	PowerSql *bool `json:"powerSql,omitempty" xml:"powerSql,omitempty"`
	// 查询语句
	//
	// This parameter is required.
	//
	// example:
	//
	// 	- | select *
	Query *string `json:"query,omitempty" xml:"query,omitempty"`
	// 导出配置
	//
	// This parameter is required.
	Sink *CreateDownloadJobRequestConfigurationSink `json:"sink,omitempty" xml:"sink,omitempty" type:"Struct"`
	// 结束时间戳（精确到秒）
	//
	// This parameter is required.
	//
	// example:
	//
	// 1722409860
	ToTime *int64 `json:"toTime,omitempty" xml:"toTime,omitempty"`
}

func (s CreateDownloadJobRequestConfiguration) String() string {
	return tea.Prettify(s)
}

func (s CreateDownloadJobRequestConfiguration) GoString() string {
	return s.String()
}

func (s *CreateDownloadJobRequestConfiguration) SetAllowInComplete(v bool) *CreateDownloadJobRequestConfiguration {
	s.AllowInComplete = &v
	return s
}

func (s *CreateDownloadJobRequestConfiguration) SetFromTime(v int64) *CreateDownloadJobRequestConfiguration {
	s.FromTime = &v
	return s
}

func (s *CreateDownloadJobRequestConfiguration) SetLogstore(v string) *CreateDownloadJobRequestConfiguration {
	s.Logstore = &v
	return s
}

func (s *CreateDownloadJobRequestConfiguration) SetPowerSql(v bool) *CreateDownloadJobRequestConfiguration {
	s.PowerSql = &v
	return s
}

func (s *CreateDownloadJobRequestConfiguration) SetQuery(v string) *CreateDownloadJobRequestConfiguration {
	s.Query = &v
	return s
}

func (s *CreateDownloadJobRequestConfiguration) SetSink(v *CreateDownloadJobRequestConfigurationSink) *CreateDownloadJobRequestConfiguration {
	s.Sink = v
	return s
}

func (s *CreateDownloadJobRequestConfiguration) SetToTime(v int64) *CreateDownloadJobRequestConfiguration {
	s.ToTime = &v
	return s
}

type CreateDownloadJobRequestConfigurationSink struct {
	// 对象存储桶
	//
	// example:
	//
	// oss-test-bucket
	Bucket *string `json:"bucket,omitempty" xml:"bucket,omitempty"`
	// 压缩格式
	//
	// This parameter is required.
	//
	// example:
	//
	// none
	CompressionType *string `json:"compressionType,omitempty" xml:"compressionType,omitempty"`
	// 下载文件格式
	//
	// This parameter is required.
	//
	// example:
	//
	// csv
	ContentType *string `json:"contentType,omitempty" xml:"contentType,omitempty"`
	// example:
	//
	// download/
	Prefix *string `json:"prefix,omitempty" xml:"prefix,omitempty"`
	// 下载使用roleArn
	//
	// example:
	//
	// acs:ram::0123456789:role/aliyunlogdefaultrole
	RoleArn *string `json:"roleArn,omitempty" xml:"roleArn,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// AliyunOSS
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s CreateDownloadJobRequestConfigurationSink) String() string {
	return tea.Prettify(s)
}

func (s CreateDownloadJobRequestConfigurationSink) GoString() string {
	return s.String()
}

func (s *CreateDownloadJobRequestConfigurationSink) SetBucket(v string) *CreateDownloadJobRequestConfigurationSink {
	s.Bucket = &v
	return s
}

func (s *CreateDownloadJobRequestConfigurationSink) SetCompressionType(v string) *CreateDownloadJobRequestConfigurationSink {
	s.CompressionType = &v
	return s
}

func (s *CreateDownloadJobRequestConfigurationSink) SetContentType(v string) *CreateDownloadJobRequestConfigurationSink {
	s.ContentType = &v
	return s
}

func (s *CreateDownloadJobRequestConfigurationSink) SetPrefix(v string) *CreateDownloadJobRequestConfigurationSink {
	s.Prefix = &v
	return s
}

func (s *CreateDownloadJobRequestConfigurationSink) SetRoleArn(v string) *CreateDownloadJobRequestConfigurationSink {
	s.RoleArn = &v
	return s
}

func (s *CreateDownloadJobRequestConfigurationSink) SetType(v string) *CreateDownloadJobRequestConfigurationSink {
	s.Type = &v
	return s
}

type CreateDownloadJobResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateDownloadJobResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDownloadJobResponse) GoString() string {
	return s.String()
}

func (s *CreateDownloadJobResponse) SetHeaders(v map[string]*string) *CreateDownloadJobResponse {
	s.Headers = v
	return s
}

func (s *CreateDownloadJobResponse) SetStatusCode(v int32) *CreateDownloadJobResponse {
	s.StatusCode = &v
	return s
}

type CreateETLRequest struct {
	// This parameter is required.
	Configuration *ETLConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty"`
	// example:
	//
	// this is ETL
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// sls-test-etl
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// etl-123456
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
}

func (s CreateETLRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateETLRequest) GoString() string {
	return s.String()
}

func (s *CreateETLRequest) SetConfiguration(v *ETLConfiguration) *CreateETLRequest {
	s.Configuration = v
	return s
}

func (s *CreateETLRequest) SetDescription(v string) *CreateETLRequest {
	s.Description = &v
	return s
}

func (s *CreateETLRequest) SetDisplayName(v string) *CreateETLRequest {
	s.DisplayName = &v
	return s
}

func (s *CreateETLRequest) SetName(v string) *CreateETLRequest {
	s.Name = &v
	return s
}

type CreateETLResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateETLResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateETLResponse) GoString() string {
	return s.String()
}

func (s *CreateETLResponse) SetHeaders(v map[string]*string) *CreateETLResponse {
	s.Headers = v
	return s
}

func (s *CreateETLResponse) SetStatusCode(v int32) *CreateETLResponse {
	s.StatusCode = &v
	return s
}

type CreateIndexRequest struct {
	// The request body.
	Body *Index `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateIndexRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateIndexRequest) GoString() string {
	return s.String()
}

func (s *CreateIndexRequest) SetBody(v *Index) *CreateIndexRequest {
	s.Body = v
	return s
}

type CreateIndexResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateIndexResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateIndexResponse) GoString() string {
	return s.String()
}

func (s *CreateIndexResponse) SetHeaders(v map[string]*string) *CreateIndexResponse {
	s.Headers = v
	return s
}

func (s *CreateIndexResponse) SetStatusCode(v int32) *CreateIndexResponse {
	s.StatusCode = &v
	return s
}

type CreateLogStoreRequest struct {
	// Specifies whether to record the **public IP address*	- and **log receiving time**. Default value: false. Valid values:
	//
	// 	- true********
	//
	// 	- false********
	//
	// example:
	//
	// false
	AppendMeta *bool `json:"appendMeta,omitempty" xml:"appendMeta,omitempty"`
	// Specifies whether to enable automatic sharding. Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// true
	AutoSplit *bool `json:"autoSplit,omitempty" xml:"autoSplit,omitempty"`
	// Specifies whether to enable the web tracking feature. Default value: false. Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// false
	EnableTracking *bool `json:"enable_tracking,omitempty" xml:"enable_tracking,omitempty"`
	// The data structure of the encryption configuration. The following parameters are included: `enable`, `encrypt_type`, and `user_cmk_info`. For more information, see [EncryptConf](https://help.aliyun.com/document_detail/409461.html).
	EncryptConf *EncryptConf `json:"encrypt_conf,omitempty" xml:"encrypt_conf,omitempty"`
	// The retention period of data in the hot storage tier of the Logstore. Valid values: 7 to 3000. Unit: days.
	//
	// After the retention period that is specified for the hot storage tier elapses, the data is moved to the Infrequent Access (IA) storage tier. For more information, see [Enable hot and cold-tiered storage for a Logstore](https://help.aliyun.com/document_detail/308645.html).
	//
	// example:
	//
	// 60
	HotTtl *int32 `json:"hot_ttl,omitempty" xml:"hot_ttl,omitempty"`
	// The retention period of data in the IA storage tier of the Logstore. You must set this parameter to at least 30 days. After the data retention period that you specify for the IA storage tier elapses, the data is moved to the Archive storage tier.
	//
	// example:
	//
	// 30
	InfrequentAccessTTL *int32 `json:"infrequentAccessTTL,omitempty" xml:"infrequentAccessTTL,omitempty"`
	// The name of the Logstore. The name must meet the following requirements:
	//
	// 	- The name must be unique in a project.
	//
	// 	- The name can contain only lowercase letters, digits, hyphens (-), and underscores (_).
	//
	// 	- The name must start and end with a lowercase letter or a digit.
	//
	// 	- The name must be 3 to 63 characters in length.
	//
	// This parameter is required.
	//
	// example:
	//
	// my-logstore
	LogstoreName *string `json:"logstoreName,omitempty" xml:"logstoreName,omitempty"`
	// The maximum number of shards into which existing shards can be automatically split. Valid values: 1 to 256.
	//
	// >  If you set autoSplit to true, you must specify this parameter.
	//
	// example:
	//
	// 64
	MaxSplitShard *int32 `json:"maxSplitShard,omitempty" xml:"maxSplitShard,omitempty"`
	// The type of the Logstore. Simple Log Service provides two types of Logstores: Standard Logstores and Query Logstores. Valid values:
	//
	// 	- **standard**: Standard Logstore. This type of Logstore supports the log analysis feature and is suitable for scenarios such as real-time monitoring and interactive analysis. You can also use this type of Logstore to build a comprehensive observability system.
	//
	// 	- **query**: Query Logstore. This type of Logstore supports high-performance queries. The index traffic fee of a Query Logstore is approximately half that of a Standard Logstore. Query Logstores do not support SQL analysis. Query Logstores are suitable for scenarios in which the amount of data is large, the log retention period is long, or log analysis is not required. If logs are stored for weeks or months, the log retention period is considered long.
	//
	// example:
	//
	// standard
	Mode        *string `json:"mode,omitempty" xml:"mode,omitempty"`
	ProcessorId *string `json:"processorId,omitempty" xml:"processorId,omitempty"`
	// The number of shards.
	//
	// >  You cannot call the CreateLogStore operation to change the number of shards. You can call the SplitShard or MergeShards operation to change the number of shards.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2
	ShardCount *int32 `json:"shardCount,omitempty" xml:"shardCount,omitempty"`
	// The type of the observable data. Valid values:
	//
	// 	- **None*	- (default): log data
	//
	// 	- **Metrics**: metric data
	//
	// example:
	//
	// None
	TelemetryType *string `json:"telemetryType,omitempty" xml:"telemetryType,omitempty"`
	// The retention period of data. Unit: days. Valid values: 1 to 3000. If you set this parameter to 3650, data is permanently stored.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1
	Ttl *int32 `json:"ttl,omitempty" xml:"ttl,omitempty"`
}

func (s CreateLogStoreRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateLogStoreRequest) GoString() string {
	return s.String()
}

func (s *CreateLogStoreRequest) SetAppendMeta(v bool) *CreateLogStoreRequest {
	s.AppendMeta = &v
	return s
}

func (s *CreateLogStoreRequest) SetAutoSplit(v bool) *CreateLogStoreRequest {
	s.AutoSplit = &v
	return s
}

func (s *CreateLogStoreRequest) SetEnableTracking(v bool) *CreateLogStoreRequest {
	s.EnableTracking = &v
	return s
}

func (s *CreateLogStoreRequest) SetEncryptConf(v *EncryptConf) *CreateLogStoreRequest {
	s.EncryptConf = v
	return s
}

func (s *CreateLogStoreRequest) SetHotTtl(v int32) *CreateLogStoreRequest {
	s.HotTtl = &v
	return s
}

func (s *CreateLogStoreRequest) SetInfrequentAccessTTL(v int32) *CreateLogStoreRequest {
	s.InfrequentAccessTTL = &v
	return s
}

func (s *CreateLogStoreRequest) SetLogstoreName(v string) *CreateLogStoreRequest {
	s.LogstoreName = &v
	return s
}

func (s *CreateLogStoreRequest) SetMaxSplitShard(v int32) *CreateLogStoreRequest {
	s.MaxSplitShard = &v
	return s
}

func (s *CreateLogStoreRequest) SetMode(v string) *CreateLogStoreRequest {
	s.Mode = &v
	return s
}

func (s *CreateLogStoreRequest) SetProcessorId(v string) *CreateLogStoreRequest {
	s.ProcessorId = &v
	return s
}

func (s *CreateLogStoreRequest) SetShardCount(v int32) *CreateLogStoreRequest {
	s.ShardCount = &v
	return s
}

func (s *CreateLogStoreRequest) SetTelemetryType(v string) *CreateLogStoreRequest {
	s.TelemetryType = &v
	return s
}

func (s *CreateLogStoreRequest) SetTtl(v int32) *CreateLogStoreRequest {
	s.Ttl = &v
	return s
}

type CreateLogStoreResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateLogStoreResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateLogStoreResponse) GoString() string {
	return s.String()
}

func (s *CreateLogStoreResponse) SetHeaders(v map[string]*string) *CreateLogStoreResponse {
	s.Headers = v
	return s
}

func (s *CreateLogStoreResponse) SetStatusCode(v int32) *CreateLogStoreResponse {
	s.StatusCode = &v
	return s
}

type CreateLoggingRequest struct {
	// The configurations of service logs.
	//
	// This parameter is required.
	LoggingDetails []*CreateLoggingRequestLoggingDetails `json:"loggingDetails,omitempty" xml:"loggingDetails,omitempty" type:"Repeated"`
	// The name of the project to which service logs are stored.
	//
	// This parameter is required.
	//
	// example:
	//
	// my-project
	LoggingProject *string `json:"loggingProject,omitempty" xml:"loggingProject,omitempty"`
}

func (s CreateLoggingRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateLoggingRequest) GoString() string {
	return s.String()
}

func (s *CreateLoggingRequest) SetLoggingDetails(v []*CreateLoggingRequestLoggingDetails) *CreateLoggingRequest {
	s.LoggingDetails = v
	return s
}

func (s *CreateLoggingRequest) SetLoggingProject(v string) *CreateLoggingRequest {
	s.LoggingProject = &v
	return s
}

type CreateLoggingRequestLoggingDetails struct {
	// The name of the Logstore to which service logs of the type are stored.
	//
	// This parameter is required.
	//
	// example:
	//
	// my-logstore
	Logstore *string `json:"logstore,omitempty" xml:"logstore,omitempty"`
	// The type of service logs. Valid values:
	//
	// 	- consumergroup_log: the consumption delay logs of consumer groups.
	//
	// 	- logtail_alarm: the alert logs of Logtail.
	//
	// 	- operation_log: the operation logs.
	//
	// 	- logtail_profile: the collection logs of Logtail.
	//
	// 	- metering: the metering logs.
	//
	// 	- logtail_status: the status logs of Logtail.
	//
	// 	- scheduledsqlalert: the run logs of Scheduled SQL jobs.
	//
	// 	- etl_alert: the run logs of data transformation jobs.
	//
	// This parameter is required.
	//
	// example:
	//
	// consumergroup_log
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s CreateLoggingRequestLoggingDetails) String() string {
	return tea.Prettify(s)
}

func (s CreateLoggingRequestLoggingDetails) GoString() string {
	return s.String()
}

func (s *CreateLoggingRequestLoggingDetails) SetLogstore(v string) *CreateLoggingRequestLoggingDetails {
	s.Logstore = &v
	return s
}

func (s *CreateLoggingRequestLoggingDetails) SetType(v string) *CreateLoggingRequestLoggingDetails {
	s.Type = &v
	return s
}

type CreateLoggingResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateLoggingResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateLoggingResponse) GoString() string {
	return s.String()
}

func (s *CreateLoggingResponse) SetHeaders(v map[string]*string) *CreateLoggingResponse {
	s.Headers = v
	return s
}

func (s *CreateLoggingResponse) SetStatusCode(v int32) *CreateLoggingResponse {
	s.StatusCode = &v
	return s
}

type CreateLogtailPipelineConfigRequest struct {
	// The aggregation plug-ins.
	//
	// >  This parameter takes effect only when extended plug-ins are used. You can use only one aggregation plug-in.
	Aggregators []map[string]interface{} `json:"aggregators,omitempty" xml:"aggregators,omitempty" type:"Repeated"`
	// The name of the configuration.
	//
	// >  The name of the configuration must be unique in the project to which the configuration belongs. After the configuration is created, you cannot change the name of the configuration. The name must meet the following requirements:
	//
	// 	- The name can contain only lowercase letters, digits, hyphens (-), and underscores (_).
	//
	// 	- The name must start and end with a lowercase letter or a digit.
	//
	// 	- The name must be 2 to 128 characters in length.
	//
	// This parameter is required.
	//
	// example:
	//
	// test-config
	ConfigName *string `json:"configName,omitempty" xml:"configName,omitempty"`
	// The output plug-ins.
	//
	// >  You can configure only one output plug-in.
	//
	// This parameter is required.
	Flushers []map[string]interface{} `json:"flushers,omitempty" xml:"flushers,omitempty" type:"Repeated"`
	// The global settings.
	Global map[string]interface{} `json:"global,omitempty" xml:"global,omitempty"`
	// The input plug-ins.
	//
	// >  You can configure only one input plug-in.
	//
	// This parameter is required.
	Inputs []map[string]interface{} `json:"inputs,omitempty" xml:"inputs,omitempty" type:"Repeated"`
	// The sample log. You can specify multiple sample logs.
	//
	// example:
	//
	// 2022-06-14 11:13:29.796 | DEBUG    | __main__:<module>:1 - hello world
	LogSample *string `json:"logSample,omitempty" xml:"logSample,omitempty"`
	// The processing plug-ins.
	//
	// >  Logtail plug-ins for data processing are classified into native plug-ins and extended plug-ins. For more information, see [Overview of Logtail plug-ins for data processing](https://help.aliyun.com/document_detail/64957.html).
	//
	// >
	//
	// 	- You can use native plug-ins only to collect text logs.
	//
	// 	- You cannot add native plug-ins and extended plug-ins at a time.
	//
	// 	- When you add native plug-ins, take note of the following items:
	//
	//     	- You must add one of the following Logtail plug-ins for data processing as the first plug-in: Data Parsing (Regex Mode), Data Parsing (Delimiter Mode), Data Parsing (JSON Mode), Data Parsing (NGINX Mode), Data Parsing (Apache Mode), and Data Parsing (IIS Mode).
	//
	//     	- After you add the first plug-in, you can add one Time Parsing plug-in, one Data Filtering plug-in, and multiple Data Masking plug-ins.
	Processors []map[string]interface{} `json:"processors,omitempty" xml:"processors,omitempty" type:"Repeated"`
}

func (s CreateLogtailPipelineConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateLogtailPipelineConfigRequest) GoString() string {
	return s.String()
}

func (s *CreateLogtailPipelineConfigRequest) SetAggregators(v []map[string]interface{}) *CreateLogtailPipelineConfigRequest {
	s.Aggregators = v
	return s
}

func (s *CreateLogtailPipelineConfigRequest) SetConfigName(v string) *CreateLogtailPipelineConfigRequest {
	s.ConfigName = &v
	return s
}

func (s *CreateLogtailPipelineConfigRequest) SetFlushers(v []map[string]interface{}) *CreateLogtailPipelineConfigRequest {
	s.Flushers = v
	return s
}

func (s *CreateLogtailPipelineConfigRequest) SetGlobal(v map[string]interface{}) *CreateLogtailPipelineConfigRequest {
	s.Global = v
	return s
}

func (s *CreateLogtailPipelineConfigRequest) SetInputs(v []map[string]interface{}) *CreateLogtailPipelineConfigRequest {
	s.Inputs = v
	return s
}

func (s *CreateLogtailPipelineConfigRequest) SetLogSample(v string) *CreateLogtailPipelineConfigRequest {
	s.LogSample = &v
	return s
}

func (s *CreateLogtailPipelineConfigRequest) SetProcessors(v []map[string]interface{}) *CreateLogtailPipelineConfigRequest {
	s.Processors = v
	return s
}

type CreateLogtailPipelineConfigResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateLogtailPipelineConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateLogtailPipelineConfigResponse) GoString() string {
	return s.String()
}

func (s *CreateLogtailPipelineConfigResponse) SetHeaders(v map[string]*string) *CreateLogtailPipelineConfigResponse {
	s.Headers = v
	return s
}

func (s *CreateLogtailPipelineConfigResponse) SetStatusCode(v int32) *CreateLogtailPipelineConfigResponse {
	s.StatusCode = &v
	return s
}

type CreateMachineGroupRequest struct {
	// The attributes of the machine group.
	GroupAttribute *CreateMachineGroupRequestGroupAttribute `json:"groupAttribute,omitempty" xml:"groupAttribute,omitempty" type:"Struct"`
	// The name of the machine group. The name must meet the following requirements:
	//
	// 	- The name of each machine group in a project must be unique.
	//
	// 	- It can contain only lowercase letters, digits, hyphens (-), and underscores (_).
	//
	// 	- It must start and end with a lowercase letter or a digit.
	//
	// 	- It must be 3 to 128 characters in length.
	//
	// This parameter is required.
	//
	// example:
	//
	// test-machine-group
	GroupName *string `json:"groupName,omitempty" xml:"groupName,omitempty"`
	// The type of the machine group. The parameter can be left empty.
	//
	// example:
	//
	// ""
	GroupType *string `json:"groupType,omitempty" xml:"groupType,omitempty"`
	// The type of the machine group identifier. Valid values:
	//
	// 	- ip: The machine group uses IP addresses as identifiers.
	//
	// 	- userdefined: The machine group uses custom identifiers.
	//
	// This parameter is required.
	//
	// example:
	//
	// ip
	MachineIdentifyType *string `json:"machineIdentifyType,omitempty" xml:"machineIdentifyType,omitempty"`
	// The identifiers of machine group.
	//
	// 	- If you set machineIdentifyType to ip, enter the IP address of the machine.
	//
	// 	- If you set machineIdentifyType to userdefined, enter a custom identifier.
	//
	// This parameter is required.
	MachineList []*string `json:"machineList,omitempty" xml:"machineList,omitempty" type:"Repeated"`
}

func (s CreateMachineGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateMachineGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateMachineGroupRequest) SetGroupAttribute(v *CreateMachineGroupRequestGroupAttribute) *CreateMachineGroupRequest {
	s.GroupAttribute = v
	return s
}

func (s *CreateMachineGroupRequest) SetGroupName(v string) *CreateMachineGroupRequest {
	s.GroupName = &v
	return s
}

func (s *CreateMachineGroupRequest) SetGroupType(v string) *CreateMachineGroupRequest {
	s.GroupType = &v
	return s
}

func (s *CreateMachineGroupRequest) SetMachineIdentifyType(v string) *CreateMachineGroupRequest {
	s.MachineIdentifyType = &v
	return s
}

func (s *CreateMachineGroupRequest) SetMachineList(v []*string) *CreateMachineGroupRequest {
	s.MachineList = v
	return s
}

type CreateMachineGroupRequestGroupAttribute struct {
	// The identifier of the external management system on which the machine group depends.
	//
	// example:
	//
	// testgroup
	ExternalName *string `json:"externalName,omitempty" xml:"externalName,omitempty"`
	// The log topic of the machine group.
	//
	// example:
	//
	// testtopic
	GroupTopic *string `json:"groupTopic,omitempty" xml:"groupTopic,omitempty"`
}

func (s CreateMachineGroupRequestGroupAttribute) String() string {
	return tea.Prettify(s)
}

func (s CreateMachineGroupRequestGroupAttribute) GoString() string {
	return s.String()
}

func (s *CreateMachineGroupRequestGroupAttribute) SetExternalName(v string) *CreateMachineGroupRequestGroupAttribute {
	s.ExternalName = &v
	return s
}

func (s *CreateMachineGroupRequestGroupAttribute) SetGroupTopic(v string) *CreateMachineGroupRequestGroupAttribute {
	s.GroupTopic = &v
	return s
}

type CreateMachineGroupResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateMachineGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateMachineGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateMachineGroupResponse) SetHeaders(v map[string]*string) *CreateMachineGroupResponse {
	s.Headers = v
	return s
}

func (s *CreateMachineGroupResponse) SetStatusCode(v int32) *CreateMachineGroupResponse {
	s.StatusCode = &v
	return s
}

type CreateMetricStoreRequest struct {
	// Specifies whether to enable automatic sharding.
	//
	// example:
	//
	// true
	AutoSplit           *bool  `json:"autoSplit,omitempty" xml:"autoSplit,omitempty"`
	HotTtl              *int32 `json:"hot_ttl,omitempty" xml:"hot_ttl,omitempty"`
	InfrequentAccessTTL *int32 `json:"infrequentAccessTTL,omitempty" xml:"infrequentAccessTTL,omitempty"`
	// The maximum number of shards into which existing shards can be automatically split. This parameter is valid only when you set the autoSplit parameter to true.
	//
	// example:
	//
	// 64
	MaxSplitShard *int32 `json:"maxSplitShard,omitempty" xml:"maxSplitShard,omitempty"`
	// The type of the metric data. Example: prometheus.
	//
	// example:
	//
	// prometheus
	MetricType *string `json:"metricType,omitempty" xml:"metricType,omitempty"`
	// The type of the Metricstore. For example, you can set the parameter to standard to query Standard Metricstores.
	//
	// example:
	//
	// standard
	Mode *string `json:"mode,omitempty" xml:"mode,omitempty"`
	// The name of the Metricstore.
	//
	// This parameter is required.
	//
	// example:
	//
	// my_metric_store
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The number of shards in the Metricstore.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2
	ShardCount *int32 `json:"shardCount,omitempty" xml:"shardCount,omitempty"`
	// The retention period of the metric data in the Metricstore. Unit: days.
	//
	// This parameter is required.
	//
	// example:
	//
	// 7
	Ttl *int32 `json:"ttl,omitempty" xml:"ttl,omitempty"`
}

func (s CreateMetricStoreRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateMetricStoreRequest) GoString() string {
	return s.String()
}

func (s *CreateMetricStoreRequest) SetAutoSplit(v bool) *CreateMetricStoreRequest {
	s.AutoSplit = &v
	return s
}

func (s *CreateMetricStoreRequest) SetHotTtl(v int32) *CreateMetricStoreRequest {
	s.HotTtl = &v
	return s
}

func (s *CreateMetricStoreRequest) SetInfrequentAccessTTL(v int32) *CreateMetricStoreRequest {
	s.InfrequentAccessTTL = &v
	return s
}

func (s *CreateMetricStoreRequest) SetMaxSplitShard(v int32) *CreateMetricStoreRequest {
	s.MaxSplitShard = &v
	return s
}

func (s *CreateMetricStoreRequest) SetMetricType(v string) *CreateMetricStoreRequest {
	s.MetricType = &v
	return s
}

func (s *CreateMetricStoreRequest) SetMode(v string) *CreateMetricStoreRequest {
	s.Mode = &v
	return s
}

func (s *CreateMetricStoreRequest) SetName(v string) *CreateMetricStoreRequest {
	s.Name = &v
	return s
}

func (s *CreateMetricStoreRequest) SetShardCount(v int32) *CreateMetricStoreRequest {
	s.ShardCount = &v
	return s
}

func (s *CreateMetricStoreRequest) SetTtl(v int32) *CreateMetricStoreRequest {
	s.Ttl = &v
	return s
}

type CreateMetricStoreResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateMetricStoreResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateMetricStoreResponse) GoString() string {
	return s.String()
}

func (s *CreateMetricStoreResponse) SetHeaders(v map[string]*string) *CreateMetricStoreResponse {
	s.Headers = v
	return s
}

func (s *CreateMetricStoreResponse) SetStatusCode(v int32) *CreateMetricStoreResponse {
	s.StatusCode = &v
	return s
}

type CreateOSSExportRequest struct {
	// The configuration details of the job.
	//
	// This parameter is required.
	Configuration *OSSExportConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty"`
	// The description of the job.
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// The display name of the job.
	//
	// This parameter is required.
	//
	// example:
	//
	// ali-test-oss-job
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// The unique identifier of the OSS data shipping job.
	//
	// This parameter is required.
	//
	// example:
	//
	// job-123456789-123456
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
}

func (s CreateOSSExportRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOSSExportRequest) GoString() string {
	return s.String()
}

func (s *CreateOSSExportRequest) SetConfiguration(v *OSSExportConfiguration) *CreateOSSExportRequest {
	s.Configuration = v
	return s
}

func (s *CreateOSSExportRequest) SetDescription(v string) *CreateOSSExportRequest {
	s.Description = &v
	return s
}

func (s *CreateOSSExportRequest) SetDisplayName(v string) *CreateOSSExportRequest {
	s.DisplayName = &v
	return s
}

func (s *CreateOSSExportRequest) SetName(v string) *CreateOSSExportRequest {
	s.Name = &v
	return s
}

type CreateOSSExportResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateOSSExportResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOSSExportResponse) GoString() string {
	return s.String()
}

func (s *CreateOSSExportResponse) SetHeaders(v map[string]*string) *CreateOSSExportResponse {
	s.Headers = v
	return s
}

func (s *CreateOSSExportResponse) SetStatusCode(v int32) *CreateOSSExportResponse {
	s.StatusCode = &v
	return s
}

type CreateOSSHDFSExportRequest struct {
	// The configuration details of the job.
	//
	// This parameter is required.
	Configuration *OSSExportConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty"`
	// The description of the job.
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// The display name of the job.
	//
	// This parameter is required.
	//
	// example:
	//
	// ali-test-oss-hdfs-job
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// The unique identifier of the OSS data shipping job.
	//
	// This parameter is required.
	//
	// example:
	//
	// job-123456789-123456
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
}

func (s CreateOSSHDFSExportRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOSSHDFSExportRequest) GoString() string {
	return s.String()
}

func (s *CreateOSSHDFSExportRequest) SetConfiguration(v *OSSExportConfiguration) *CreateOSSHDFSExportRequest {
	s.Configuration = v
	return s
}

func (s *CreateOSSHDFSExportRequest) SetDescription(v string) *CreateOSSHDFSExportRequest {
	s.Description = &v
	return s
}

func (s *CreateOSSHDFSExportRequest) SetDisplayName(v string) *CreateOSSHDFSExportRequest {
	s.DisplayName = &v
	return s
}

func (s *CreateOSSHDFSExportRequest) SetName(v string) *CreateOSSHDFSExportRequest {
	s.Name = &v
	return s
}

type CreateOSSHDFSExportResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateOSSHDFSExportResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOSSHDFSExportResponse) GoString() string {
	return s.String()
}

func (s *CreateOSSHDFSExportResponse) SetHeaders(v map[string]*string) *CreateOSSHDFSExportResponse {
	s.Headers = v
	return s
}

func (s *CreateOSSHDFSExportResponse) SetStatusCode(v int32) *CreateOSSHDFSExportResponse {
	s.StatusCode = &v
	return s
}

type CreateOSSIngestionRequest struct {
	// The configurations of the OSS data import job.
	//
	// This parameter is required.
	Configuration *OSSIngestionConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty"`
	// The description of the job.
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// The display name.
	//
	// This parameter is required.
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// The name of the OSS data import job.
	//
	// This parameter is required.
	//
	// example:
	//
	// ingest-oss-123456
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The scheduling type. By default, you do not need to specify this parameter. If you want to import data at regular intervals, such as importing data every Monday at 08: 00., you can specify a cron expression.
	Schedule *Schedule `json:"schedule,omitempty" xml:"schedule,omitempty"`
}

func (s CreateOSSIngestionRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOSSIngestionRequest) GoString() string {
	return s.String()
}

func (s *CreateOSSIngestionRequest) SetConfiguration(v *OSSIngestionConfiguration) *CreateOSSIngestionRequest {
	s.Configuration = v
	return s
}

func (s *CreateOSSIngestionRequest) SetDescription(v string) *CreateOSSIngestionRequest {
	s.Description = &v
	return s
}

func (s *CreateOSSIngestionRequest) SetDisplayName(v string) *CreateOSSIngestionRequest {
	s.DisplayName = &v
	return s
}

func (s *CreateOSSIngestionRequest) SetName(v string) *CreateOSSIngestionRequest {
	s.Name = &v
	return s
}

func (s *CreateOSSIngestionRequest) SetSchedule(v *Schedule) *CreateOSSIngestionRequest {
	s.Schedule = v
	return s
}

type CreateOSSIngestionResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateOSSIngestionResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOSSIngestionResponse) GoString() string {
	return s.String()
}

func (s *CreateOSSIngestionResponse) SetHeaders(v map[string]*string) *CreateOSSIngestionResponse {
	s.Headers = v
	return s
}

func (s *CreateOSSIngestionResponse) SetStatusCode(v int32) *CreateOSSIngestionResponse {
	s.StatusCode = &v
	return s
}

type CreateOssExternalStoreRequest struct {
	// The name of the external store.
	//
	// This parameter is required.
	//
	// example:
	//
	// test_oss_store
	ExternalStoreName *string `json:"externalStoreName,omitempty" xml:"externalStoreName,omitempty"`
	// The parameters of the external store.
	//
	// This parameter is required.
	Parameter *CreateOssExternalStoreRequestParameter `json:"parameter,omitempty" xml:"parameter,omitempty" type:"Struct"`
	// The type of the external store. Set the value to oss.
	//
	// This parameter is required.
	//
	// example:
	//
	// oss
	StoreType *string `json:"storeType,omitempty" xml:"storeType,omitempty"`
}

func (s CreateOssExternalStoreRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOssExternalStoreRequest) GoString() string {
	return s.String()
}

func (s *CreateOssExternalStoreRequest) SetExternalStoreName(v string) *CreateOssExternalStoreRequest {
	s.ExternalStoreName = &v
	return s
}

func (s *CreateOssExternalStoreRequest) SetParameter(v *CreateOssExternalStoreRequestParameter) *CreateOssExternalStoreRequest {
	s.Parameter = v
	return s
}

func (s *CreateOssExternalStoreRequest) SetStoreType(v string) *CreateOssExternalStoreRequest {
	s.StoreType = &v
	return s
}

type CreateOssExternalStoreRequestParameter struct {
	// The AccessKey ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// LTAI5tFsHGGeYry*****1Sz
	Accessid *string `json:"accessid,omitempty" xml:"accessid,omitempty"`
	// The AccessKey secret.
	//
	// This parameter is required.
	//
	// example:
	//
	// GyviCLDVHkHrOztdkxuE6******Rp6
	Accesskey *string `json:"accesskey,omitempty" xml:"accesskey,omitempty"`
	// The name of the OSS bucket.
	//
	// This parameter is required.
	//
	// example:
	//
	// my-bucket
	Bucket *string `json:"bucket,omitempty" xml:"bucket,omitempty"`
	// The associated fields.
	//
	// This parameter is required.
	Columns []*CreateOssExternalStoreRequestParameterColumns `json:"columns,omitempty" xml:"columns,omitempty" type:"Repeated"`
	// The OSS endpoint. For more information, see [Regions and endpoints](https://help.aliyun.com/document_detail/31837.html).
	//
	// This parameter is required.
	//
	// example:
	//
	// oss-cn-hangzhou.aliyuncs.com
	Endpoint *string `json:"endpoint,omitempty" xml:"endpoint,omitempty"`
	// The associated OSS objects. Valid values of n: 1 to 100.
	//
	// This parameter is required.
	Objects []*string `json:"objects,omitempty" xml:"objects,omitempty" type:"Repeated"`
}

func (s CreateOssExternalStoreRequestParameter) String() string {
	return tea.Prettify(s)
}

func (s CreateOssExternalStoreRequestParameter) GoString() string {
	return s.String()
}

func (s *CreateOssExternalStoreRequestParameter) SetAccessid(v string) *CreateOssExternalStoreRequestParameter {
	s.Accessid = &v
	return s
}

func (s *CreateOssExternalStoreRequestParameter) SetAccesskey(v string) *CreateOssExternalStoreRequestParameter {
	s.Accesskey = &v
	return s
}

func (s *CreateOssExternalStoreRequestParameter) SetBucket(v string) *CreateOssExternalStoreRequestParameter {
	s.Bucket = &v
	return s
}

func (s *CreateOssExternalStoreRequestParameter) SetColumns(v []*CreateOssExternalStoreRequestParameterColumns) *CreateOssExternalStoreRequestParameter {
	s.Columns = v
	return s
}

func (s *CreateOssExternalStoreRequestParameter) SetEndpoint(v string) *CreateOssExternalStoreRequestParameter {
	s.Endpoint = &v
	return s
}

func (s *CreateOssExternalStoreRequestParameter) SetObjects(v []*string) *CreateOssExternalStoreRequestParameter {
	s.Objects = v
	return s
}

type CreateOssExternalStoreRequestParameterColumns struct {
	// The name of the field.
	//
	// This parameter is required.
	//
	// example:
	//
	// auto-test
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The data type of the field.
	//
	// This parameter is required.
	//
	// example:
	//
	// sls
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s CreateOssExternalStoreRequestParameterColumns) String() string {
	return tea.Prettify(s)
}

func (s CreateOssExternalStoreRequestParameterColumns) GoString() string {
	return s.String()
}

func (s *CreateOssExternalStoreRequestParameterColumns) SetName(v string) *CreateOssExternalStoreRequestParameterColumns {
	s.Name = &v
	return s
}

func (s *CreateOssExternalStoreRequestParameterColumns) SetType(v string) *CreateOssExternalStoreRequestParameterColumns {
	s.Type = &v
	return s
}

type CreateOssExternalStoreResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateOssExternalStoreResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOssExternalStoreResponse) GoString() string {
	return s.String()
}

func (s *CreateOssExternalStoreResponse) SetHeaders(v map[string]*string) *CreateOssExternalStoreResponse {
	s.Headers = v
	return s
}

func (s *CreateOssExternalStoreResponse) SetStatusCode(v int32) *CreateOssExternalStoreResponse {
	s.StatusCode = &v
	return s
}

type CreateProjectRequest struct {
	// Data redundancy type
	//
	// example:
	//
	// LRS
	DataRedundancyType *string `json:"dataRedundancyType,omitempty" xml:"dataRedundancyType,omitempty"`
	// The description of the project.
	//
	// This parameter is required.
	//
	// example:
	//
	// this is test
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// The name of the project. The name must be unique in a region. You cannot change the name after you create the project. The name must meet the following requirements:
	//
	// 	- The name must be unique.
	//
	// 	- It can contain only lowercase letters, digits, and hyphens (-).
	//
	// 	- It must start and end with a lowercase letter or a digit.
	//
	// 	- It must be 3 to 63 characters in length.
	//
	// This parameter is required.
	//
	// example:
	//
	// test-project
	ProjectName       *string `json:"projectName,omitempty" xml:"projectName,omitempty"`
	RecycleBinEnabled *bool   `json:"recycleBinEnabled,omitempty" xml:"recycleBinEnabled,omitempty"`
	// The ID of the resource group.
	//
	// example:
	//
	// rg-aekzf******sxby
	ResourceGroupId *string `json:"resourceGroupId,omitempty" xml:"resourceGroupId,omitempty"`
}

func (s CreateProjectRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateProjectRequest) GoString() string {
	return s.String()
}

func (s *CreateProjectRequest) SetDataRedundancyType(v string) *CreateProjectRequest {
	s.DataRedundancyType = &v
	return s
}

func (s *CreateProjectRequest) SetDescription(v string) *CreateProjectRequest {
	s.Description = &v
	return s
}

func (s *CreateProjectRequest) SetProjectName(v string) *CreateProjectRequest {
	s.ProjectName = &v
	return s
}

func (s *CreateProjectRequest) SetRecycleBinEnabled(v bool) *CreateProjectRequest {
	s.RecycleBinEnabled = &v
	return s
}

func (s *CreateProjectRequest) SetResourceGroupId(v string) *CreateProjectRequest {
	s.ResourceGroupId = &v
	return s
}

type CreateProjectResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateProjectResponse) GoString() string {
	return s.String()
}

func (s *CreateProjectResponse) SetHeaders(v map[string]*string) *CreateProjectResponse {
	s.Headers = v
	return s
}

func (s *CreateProjectResponse) SetStatusCode(v int32) *CreateProjectResponse {
	s.StatusCode = &v
	return s
}

type CreateRdsExternalStoreRequest struct {
	// The name of the external store. The name must be unique in a project and must be different from Logstore names.
	//
	// This parameter is required.
	//
	// example:
	//
	// rds_store
	ExternalStoreName *string `json:"externalStoreName,omitempty" xml:"externalStoreName,omitempty"`
	// The parameter struct.
	//
	// This parameter is required.
	Parameter *CreateRdsExternalStoreRequestParameter `json:"parameter,omitempty" xml:"parameter,omitempty" type:"Struct"`
	// The storage type. Set the value to rds-vpc, which indicates an ApsaraDB RDS for MySQL database in a virtual private cloud (VPC).
	//
	// This parameter is required.
	//
	// example:
	//
	// rds-vpc
	StoreType *string `json:"storeType,omitempty" xml:"storeType,omitempty"`
}

func (s CreateRdsExternalStoreRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateRdsExternalStoreRequest) GoString() string {
	return s.String()
}

func (s *CreateRdsExternalStoreRequest) SetExternalStoreName(v string) *CreateRdsExternalStoreRequest {
	s.ExternalStoreName = &v
	return s
}

func (s *CreateRdsExternalStoreRequest) SetParameter(v *CreateRdsExternalStoreRequestParameter) *CreateRdsExternalStoreRequest {
	s.Parameter = v
	return s
}

func (s *CreateRdsExternalStoreRequest) SetStoreType(v string) *CreateRdsExternalStoreRequest {
	s.StoreType = &v
	return s
}

type CreateRdsExternalStoreRequestParameter struct {
	// The name of the database in the ApsaraDB RDS for MySQL instance.
	//
	// This parameter is required.
	//
	// example:
	//
	// meta
	Db *string `json:"db,omitempty" xml:"db,omitempty"`
	// The internal or public endpoint of the ApsaraDB RDS for MySQL instance.
	//
	// example:
	//
	// 192.168.XX.XX
	Host *string `json:"host,omitempty" xml:"host,omitempty"`
	// The ID of the ApsaraDB RDS for MySQL instance.
	//
	// example:
	//
	// i-bp1b6c719dfa08exf****
	InstanceId *string `json:"instance-id,omitempty" xml:"instance-id,omitempty"`
	// The password that is used to log on to the ApsaraDB RDS for MySQL instance.
	//
	// This parameter is required.
	//
	// example:
	//
	// sfdsfldsfksfls****
	Password *string `json:"password,omitempty" xml:"password,omitempty"`
	// The internal or public port of the ApsaraDB RDS for MySQL instance.
	//
	// This parameter is required.
	//
	// example:
	//
	// 3306
	Port *string `json:"port,omitempty" xml:"port,omitempty"`
	// The region where the ApsaraDB RDS for MySQL instance resides. Valid values: cn-qingdao, cn-beijing, and cn-hangzhou.
	//
	// This parameter is required.
	//
	// example:
	//
	// cn-qingdao
	Region *string `json:"region,omitempty" xml:"region,omitempty"`
	// The name of the database table in the ApsaraDB RDS for MySQL instance.
	//
	// This parameter is required.
	//
	// example:
	//
	// join_meta
	Table *string `json:"table,omitempty" xml:"table,omitempty"`
	// The username that is used to log on to the ApsaraDB RDS for MySQL instance.
	//
	// This parameter is required.
	//
	// example:
	//
	// root
	Username *string `json:"username,omitempty" xml:"username,omitempty"`
	// The ID of the VPC to which the ApsaraDB RDS for MySQL instance belongs.
	//
	// example:
	//
	// vpc-bp1aevy8sofi8mh1q****
	VpcId *string `json:"vpc-id,omitempty" xml:"vpc-id,omitempty"`
}

func (s CreateRdsExternalStoreRequestParameter) String() string {
	return tea.Prettify(s)
}

func (s CreateRdsExternalStoreRequestParameter) GoString() string {
	return s.String()
}

func (s *CreateRdsExternalStoreRequestParameter) SetDb(v string) *CreateRdsExternalStoreRequestParameter {
	s.Db = &v
	return s
}

func (s *CreateRdsExternalStoreRequestParameter) SetHost(v string) *CreateRdsExternalStoreRequestParameter {
	s.Host = &v
	return s
}

func (s *CreateRdsExternalStoreRequestParameter) SetInstanceId(v string) *CreateRdsExternalStoreRequestParameter {
	s.InstanceId = &v
	return s
}

func (s *CreateRdsExternalStoreRequestParameter) SetPassword(v string) *CreateRdsExternalStoreRequestParameter {
	s.Password = &v
	return s
}

func (s *CreateRdsExternalStoreRequestParameter) SetPort(v string) *CreateRdsExternalStoreRequestParameter {
	s.Port = &v
	return s
}

func (s *CreateRdsExternalStoreRequestParameter) SetRegion(v string) *CreateRdsExternalStoreRequestParameter {
	s.Region = &v
	return s
}

func (s *CreateRdsExternalStoreRequestParameter) SetTable(v string) *CreateRdsExternalStoreRequestParameter {
	s.Table = &v
	return s
}

func (s *CreateRdsExternalStoreRequestParameter) SetUsername(v string) *CreateRdsExternalStoreRequestParameter {
	s.Username = &v
	return s
}

func (s *CreateRdsExternalStoreRequestParameter) SetVpcId(v string) *CreateRdsExternalStoreRequestParameter {
	s.VpcId = &v
	return s
}

type CreateRdsExternalStoreResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateRdsExternalStoreResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateRdsExternalStoreResponse) GoString() string {
	return s.String()
}

func (s *CreateRdsExternalStoreResponse) SetHeaders(v map[string]*string) *CreateRdsExternalStoreResponse {
	s.Headers = v
	return s
}

func (s *CreateRdsExternalStoreResponse) SetStatusCode(v int32) *CreateRdsExternalStoreResponse {
	s.StatusCode = &v
	return s
}

type CreateSavedSearchRequest struct {
	// The display name.
	//
	// This parameter is required.
	//
	// example:
	//
	// displayname
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// The name of the Logstore to which the saved search belongs.
	//
	// This parameter is required.
	//
	// example:
	//
	// aliyun-test-logstore
	Logstore *string `json:"logstore,omitempty" xml:"logstore,omitempty"`
	// The name of the saved search. The name must be 3 to 63 characters in length.
	//
	// This parameter is required.
	//
	// example:
	//
	// pv in minutes
	SavedsearchName *string `json:"savedsearchName,omitempty" xml:"savedsearchName,omitempty"`
	// The query statement of the saved search. A query statement consists of a search statement and an analytic statement in the `Search statement|Analytic statement` format. For more information, see [Log search overview](https://help.aliyun.com/document_detail/43772.html) and [Log analysis overview](https://help.aliyun.com/document_detail/53608.html).
	//
	// This parameter is required.
	//
	// example:
	//
	// *|select date_format(__time__-__time__%60, \\"%H:%i:%s\\") as time, COUNT(*) as pv group by time
	SearchQuery *string `json:"searchQuery,omitempty" xml:"searchQuery,omitempty"`
	// The topic of the logs.
	//
	// This parameter is required.
	//
	// example:
	//
	// theme
	Topic *string `json:"topic,omitempty" xml:"topic,omitempty"`
}

func (s CreateSavedSearchRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSavedSearchRequest) GoString() string {
	return s.String()
}

func (s *CreateSavedSearchRequest) SetDisplayName(v string) *CreateSavedSearchRequest {
	s.DisplayName = &v
	return s
}

func (s *CreateSavedSearchRequest) SetLogstore(v string) *CreateSavedSearchRequest {
	s.Logstore = &v
	return s
}

func (s *CreateSavedSearchRequest) SetSavedsearchName(v string) *CreateSavedSearchRequest {
	s.SavedsearchName = &v
	return s
}

func (s *CreateSavedSearchRequest) SetSearchQuery(v string) *CreateSavedSearchRequest {
	s.SearchQuery = &v
	return s
}

func (s *CreateSavedSearchRequest) SetTopic(v string) *CreateSavedSearchRequest {
	s.Topic = &v
	return s
}

type CreateSavedSearchResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateSavedSearchResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSavedSearchResponse) GoString() string {
	return s.String()
}

func (s *CreateSavedSearchResponse) SetHeaders(v map[string]*string) *CreateSavedSearchResponse {
	s.Headers = v
	return s
}

func (s *CreateSavedSearchResponse) SetStatusCode(v int32) *CreateSavedSearchResponse {
	s.StatusCode = &v
	return s
}

type CreateScheduledSQLRequest struct {
	// This parameter is required.
	Configuration *ScheduledSQLConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty"`
	Description   *string                    `json:"description,omitempty" xml:"description,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// ali-test-scheduled-sql
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// sql-123456789-123456
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// This parameter is required.
	Schedule *Schedule `json:"schedule,omitempty" xml:"schedule,omitempty"`
}

func (s CreateScheduledSQLRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateScheduledSQLRequest) GoString() string {
	return s.String()
}

func (s *CreateScheduledSQLRequest) SetConfiguration(v *ScheduledSQLConfiguration) *CreateScheduledSQLRequest {
	s.Configuration = v
	return s
}

func (s *CreateScheduledSQLRequest) SetDescription(v string) *CreateScheduledSQLRequest {
	s.Description = &v
	return s
}

func (s *CreateScheduledSQLRequest) SetDisplayName(v string) *CreateScheduledSQLRequest {
	s.DisplayName = &v
	return s
}

func (s *CreateScheduledSQLRequest) SetName(v string) *CreateScheduledSQLRequest {
	s.Name = &v
	return s
}

func (s *CreateScheduledSQLRequest) SetSchedule(v *Schedule) *CreateScheduledSQLRequest {
	s.Schedule = v
	return s
}

type CreateScheduledSQLResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateScheduledSQLResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateScheduledSQLResponse) GoString() string {
	return s.String()
}

func (s *CreateScheduledSQLResponse) SetHeaders(v map[string]*string) *CreateScheduledSQLResponse {
	s.Headers = v
	return s
}

func (s *CreateScheduledSQLResponse) SetStatusCode(v int32) *CreateScheduledSQLResponse {
	s.StatusCode = &v
	return s
}

type CreateSqlInstanceRequest struct {
	// The number of compute units (CUs). When you use the Dedicated SQL feature, CUs are used in parallel.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2
	Cu *int32 `json:"cu,omitempty" xml:"cu,omitempty"`
	// Specifies whether to enable the Dedicated SQL feature for the project. If you set this parameter to true, the Dedicated SQL feature is enabled for the specified project and takes effect for all query statements that you execute in the project, including the query statements for alerts and dashboards.
	//
	// This parameter is required.
	UseAsDefault *bool `json:"useAsDefault,omitempty" xml:"useAsDefault,omitempty"`
}

func (s CreateSqlInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSqlInstanceRequest) GoString() string {
	return s.String()
}

func (s *CreateSqlInstanceRequest) SetCu(v int32) *CreateSqlInstanceRequest {
	s.Cu = &v
	return s
}

func (s *CreateSqlInstanceRequest) SetUseAsDefault(v bool) *CreateSqlInstanceRequest {
	s.UseAsDefault = &v
	return s
}

type CreateSqlInstanceResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateSqlInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSqlInstanceResponse) GoString() string {
	return s.String()
}

func (s *CreateSqlInstanceResponse) SetHeaders(v map[string]*string) *CreateSqlInstanceResponse {
	s.Headers = v
	return s
}

func (s *CreateSqlInstanceResponse) SetStatusCode(v int32) *CreateSqlInstanceResponse {
	s.StatusCode = &v
	return s
}

type CreateStoreViewRequest struct {
	// The name of the dataset.
	//
	// 	- The name can contain lowercase letters, digits, and underscores (_).
	//
	// 	- The name must start with a lowercase letter.
	//
	// 	- The name must be 3 to 62 characters in length.
	//
	// This parameter is required.
	//
	// example:
	//
	// my_storeview
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The type of the dataset. Valid values: metricstore and logstore.
	//
	// This parameter is required.
	//
	// example:
	//
	// logstore
	StoreType *string `json:"storeType,omitempty" xml:"storeType,omitempty"`
	// The Logstores or Metricstores.
	//
	// This parameter is required.
	Stores []*StoreViewStore `json:"stores,omitempty" xml:"stores,omitempty" type:"Repeated"`
}

func (s CreateStoreViewRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateStoreViewRequest) GoString() string {
	return s.String()
}

func (s *CreateStoreViewRequest) SetName(v string) *CreateStoreViewRequest {
	s.Name = &v
	return s
}

func (s *CreateStoreViewRequest) SetStoreType(v string) *CreateStoreViewRequest {
	s.StoreType = &v
	return s
}

func (s *CreateStoreViewRequest) SetStores(v []*StoreViewStore) *CreateStoreViewRequest {
	s.Stores = v
	return s
}

type CreateStoreViewResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s CreateStoreViewResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateStoreViewResponse) GoString() string {
	return s.String()
}

func (s *CreateStoreViewResponse) SetHeaders(v map[string]*string) *CreateStoreViewResponse {
	s.Headers = v
	return s
}

func (s *CreateStoreViewResponse) SetStatusCode(v int32) *CreateStoreViewResponse {
	s.StatusCode = &v
	return s
}

type CreateTicketRequest struct {
	// 	- The validity period of the access token. Unit: seconds. Default value: 86400, which specifies one day. Valid values: 0 to 86400.
	//
	// 	- The validity period of the access token is the smaller value between accessTokenExpirationTime and expirationTime.
	//
	// 	- If you use a Security Token Service (STS) token to call this operation, the validity period of the access token is the smallest value among accessTokenExpirationTime, expirationTime, and the validity period of the STS token.
	//
	// example:
	//
	// 600
	AccessTokenExpirationTime *int64 `json:"accessTokenExpirationTime,omitempty" xml:"accessTokenExpirationTime,omitempty"`
	// 	- You must use the Simple Log Service endpoint for the China (Shanghai) or Singapore region to call the CreateTicket operation. After you obtain the ticket, you can use the ticket regardless of the region.
	//
	// 	- The validity period for the URL of the console page that you want to embed. Unit: seconds. Default value: 86400, which specifies one day. Valid values: 0 to 2592000. The value 2592000 specifies 30 days.
	//
	// example:
	//
	// 86400
	ExpirationTime *int64 `json:"expirationTime,omitempty" xml:"expirationTime,omitempty"`
}

func (s CreateTicketRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTicketRequest) GoString() string {
	return s.String()
}

func (s *CreateTicketRequest) SetAccessTokenExpirationTime(v int64) *CreateTicketRequest {
	s.AccessTokenExpirationTime = &v
	return s
}

func (s *CreateTicketRequest) SetExpirationTime(v int64) *CreateTicketRequest {
	s.ExpirationTime = &v
	return s
}

type CreateTicketResponseBody struct {
	// The ticket that is used for logon-free access.
	//
	// example:
	//
	// eyJ***************.eyJ******************.KUT****************
	Ticket *string `json:"ticket,omitempty" xml:"ticket,omitempty"`
}

func (s CreateTicketResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTicketResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTicketResponseBody) SetTicket(v string) *CreateTicketResponseBody {
	s.Ticket = &v
	return s
}

type CreateTicketResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateTicketResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateTicketResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTicketResponse) GoString() string {
	return s.String()
}

func (s *CreateTicketResponse) SetHeaders(v map[string]*string) *CreateTicketResponse {
	s.Headers = v
	return s
}

func (s *CreateTicketResponse) SetStatusCode(v int32) *CreateTicketResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTicketResponse) SetBody(v *CreateTicketResponseBody) *CreateTicketResponse {
	s.Body = v
	return s
}

type DeleteAgentInstanceConfigRequest struct {
	IsGray *bool `json:"isGray,omitempty" xml:"isGray,omitempty"`
}

func (s DeleteAgentInstanceConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAgentInstanceConfigRequest) GoString() string {
	return s.String()
}

func (s *DeleteAgentInstanceConfigRequest) SetIsGray(v bool) *DeleteAgentInstanceConfigRequest {
	s.IsGray = &v
	return s
}

type DeleteAgentInstanceConfigResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteAgentInstanceConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAgentInstanceConfigResponse) GoString() string {
	return s.String()
}

func (s *DeleteAgentInstanceConfigResponse) SetHeaders(v map[string]*string) *DeleteAgentInstanceConfigResponse {
	s.Headers = v
	return s
}

func (s *DeleteAgentInstanceConfigResponse) SetStatusCode(v int32) *DeleteAgentInstanceConfigResponse {
	s.StatusCode = &v
	return s
}

type DeleteAlertResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteAlertResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAlertResponse) GoString() string {
	return s.String()
}

func (s *DeleteAlertResponse) SetHeaders(v map[string]*string) *DeleteAlertResponse {
	s.Headers = v
	return s
}

func (s *DeleteAlertResponse) SetStatusCode(v int32) *DeleteAlertResponse {
	s.StatusCode = &v
	return s
}

type DeleteAnnotationDataResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteAnnotationDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAnnotationDataResponse) GoString() string {
	return s.String()
}

func (s *DeleteAnnotationDataResponse) SetHeaders(v map[string]*string) *DeleteAnnotationDataResponse {
	s.Headers = v
	return s
}

func (s *DeleteAnnotationDataResponse) SetStatusCode(v int32) *DeleteAnnotationDataResponse {
	s.StatusCode = &v
	return s
}

type DeleteAnnotationDataSetResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteAnnotationDataSetResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAnnotationDataSetResponse) GoString() string {
	return s.String()
}

func (s *DeleteAnnotationDataSetResponse) SetHeaders(v map[string]*string) *DeleteAnnotationDataSetResponse {
	s.Headers = v
	return s
}

func (s *DeleteAnnotationDataSetResponse) SetStatusCode(v int32) *DeleteAnnotationDataSetResponse {
	s.StatusCode = &v
	return s
}

type DeleteAnnotationLabelResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteAnnotationLabelResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAnnotationLabelResponse) GoString() string {
	return s.String()
}

func (s *DeleteAnnotationLabelResponse) SetHeaders(v map[string]*string) *DeleteAnnotationLabelResponse {
	s.Headers = v
	return s
}

func (s *DeleteAnnotationLabelResponse) SetStatusCode(v int32) *DeleteAnnotationLabelResponse {
	s.StatusCode = &v
	return s
}

type DeleteCollectionPolicyRequest struct {
	// example:
	//
	// access_log
	DataCode *string `json:"dataCode,omitempty" xml:"dataCode,omitempty"`
	// example:
	//
	// oss
	ProductCode *string `json:"productCode,omitempty" xml:"productCode,omitempty"`
}

func (s DeleteCollectionPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCollectionPolicyRequest) GoString() string {
	return s.String()
}

func (s *DeleteCollectionPolicyRequest) SetDataCode(v string) *DeleteCollectionPolicyRequest {
	s.DataCode = &v
	return s
}

func (s *DeleteCollectionPolicyRequest) SetProductCode(v string) *DeleteCollectionPolicyRequest {
	s.ProductCode = &v
	return s
}

type DeleteCollectionPolicyResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteCollectionPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCollectionPolicyResponse) GoString() string {
	return s.String()
}

func (s *DeleteCollectionPolicyResponse) SetHeaders(v map[string]*string) *DeleteCollectionPolicyResponse {
	s.Headers = v
	return s
}

func (s *DeleteCollectionPolicyResponse) SetStatusCode(v int32) *DeleteCollectionPolicyResponse {
	s.StatusCode = &v
	return s
}

type DeleteConfigResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteConfigResponse) GoString() string {
	return s.String()
}

func (s *DeleteConfigResponse) SetHeaders(v map[string]*string) *DeleteConfigResponse {
	s.Headers = v
	return s
}

func (s *DeleteConfigResponse) SetStatusCode(v int32) *DeleteConfigResponse {
	s.StatusCode = &v
	return s
}

type DeleteConsumerGroupResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteConsumerGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteConsumerGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteConsumerGroupResponse) SetHeaders(v map[string]*string) *DeleteConsumerGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteConsumerGroupResponse) SetStatusCode(v int32) *DeleteConsumerGroupResponse {
	s.StatusCode = &v
	return s
}

type DeleteDashboardResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteDashboardResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDashboardResponse) GoString() string {
	return s.String()
}

func (s *DeleteDashboardResponse) SetHeaders(v map[string]*string) *DeleteDashboardResponse {
	s.Headers = v
	return s
}

func (s *DeleteDashboardResponse) SetStatusCode(v int32) *DeleteDashboardResponse {
	s.StatusCode = &v
	return s
}

type DeleteDomainResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDomainResponse) GoString() string {
	return s.String()
}

func (s *DeleteDomainResponse) SetHeaders(v map[string]*string) *DeleteDomainResponse {
	s.Headers = v
	return s
}

func (s *DeleteDomainResponse) SetStatusCode(v int32) *DeleteDomainResponse {
	s.StatusCode = &v
	return s
}

type DeleteDownloadJobResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteDownloadJobResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDownloadJobResponse) GoString() string {
	return s.String()
}

func (s *DeleteDownloadJobResponse) SetHeaders(v map[string]*string) *DeleteDownloadJobResponse {
	s.Headers = v
	return s
}

func (s *DeleteDownloadJobResponse) SetStatusCode(v int32) *DeleteDownloadJobResponse {
	s.StatusCode = &v
	return s
}

type DeleteETLResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteETLResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteETLResponse) GoString() string {
	return s.String()
}

func (s *DeleteETLResponse) SetHeaders(v map[string]*string) *DeleteETLResponse {
	s.Headers = v
	return s
}

func (s *DeleteETLResponse) SetStatusCode(v int32) *DeleteETLResponse {
	s.StatusCode = &v
	return s
}

type DeleteExternalStoreResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteExternalStoreResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteExternalStoreResponse) GoString() string {
	return s.String()
}

func (s *DeleteExternalStoreResponse) SetHeaders(v map[string]*string) *DeleteExternalStoreResponse {
	s.Headers = v
	return s
}

func (s *DeleteExternalStoreResponse) SetStatusCode(v int32) *DeleteExternalStoreResponse {
	s.StatusCode = &v
	return s
}

type DeleteIndexResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteIndexResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteIndexResponse) GoString() string {
	return s.String()
}

func (s *DeleteIndexResponse) SetHeaders(v map[string]*string) *DeleteIndexResponse {
	s.Headers = v
	return s
}

func (s *DeleteIndexResponse) SetStatusCode(v int32) *DeleteIndexResponse {
	s.StatusCode = &v
	return s
}

type DeleteIngestProcessorResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteIngestProcessorResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteIngestProcessorResponse) GoString() string {
	return s.String()
}

func (s *DeleteIngestProcessorResponse) SetHeaders(v map[string]*string) *DeleteIngestProcessorResponse {
	s.Headers = v
	return s
}

func (s *DeleteIngestProcessorResponse) SetStatusCode(v int32) *DeleteIngestProcessorResponse {
	s.StatusCode = &v
	return s
}

type DeleteLogStoreResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteLogStoreResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteLogStoreResponse) GoString() string {
	return s.String()
}

func (s *DeleteLogStoreResponse) SetHeaders(v map[string]*string) *DeleteLogStoreResponse {
	s.Headers = v
	return s
}

func (s *DeleteLogStoreResponse) SetStatusCode(v int32) *DeleteLogStoreResponse {
	s.StatusCode = &v
	return s
}

type DeleteLoggingResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteLoggingResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteLoggingResponse) GoString() string {
	return s.String()
}

func (s *DeleteLoggingResponse) SetHeaders(v map[string]*string) *DeleteLoggingResponse {
	s.Headers = v
	return s
}

func (s *DeleteLoggingResponse) SetStatusCode(v int32) *DeleteLoggingResponse {
	s.StatusCode = &v
	return s
}

type DeleteLogtailPipelineConfigResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteLogtailPipelineConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteLogtailPipelineConfigResponse) GoString() string {
	return s.String()
}

func (s *DeleteLogtailPipelineConfigResponse) SetHeaders(v map[string]*string) *DeleteLogtailPipelineConfigResponse {
	s.Headers = v
	return s
}

func (s *DeleteLogtailPipelineConfigResponse) SetStatusCode(v int32) *DeleteLogtailPipelineConfigResponse {
	s.StatusCode = &v
	return s
}

type DeleteMachineGroupResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteMachineGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteMachineGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteMachineGroupResponse) SetHeaders(v map[string]*string) *DeleteMachineGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteMachineGroupResponse) SetStatusCode(v int32) *DeleteMachineGroupResponse {
	s.StatusCode = &v
	return s
}

type DeleteMetricStoreResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteMetricStoreResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteMetricStoreResponse) GoString() string {
	return s.String()
}

func (s *DeleteMetricStoreResponse) SetHeaders(v map[string]*string) *DeleteMetricStoreResponse {
	s.Headers = v
	return s
}

func (s *DeleteMetricStoreResponse) SetStatusCode(v int32) *DeleteMetricStoreResponse {
	s.StatusCode = &v
	return s
}

type DeleteOSSExportResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteOSSExportResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteOSSExportResponse) GoString() string {
	return s.String()
}

func (s *DeleteOSSExportResponse) SetHeaders(v map[string]*string) *DeleteOSSExportResponse {
	s.Headers = v
	return s
}

func (s *DeleteOSSExportResponse) SetStatusCode(v int32) *DeleteOSSExportResponse {
	s.StatusCode = &v
	return s
}

type DeleteOSSHDFSExportResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteOSSHDFSExportResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteOSSHDFSExportResponse) GoString() string {
	return s.String()
}

func (s *DeleteOSSHDFSExportResponse) SetHeaders(v map[string]*string) *DeleteOSSHDFSExportResponse {
	s.Headers = v
	return s
}

func (s *DeleteOSSHDFSExportResponse) SetStatusCode(v int32) *DeleteOSSHDFSExportResponse {
	s.StatusCode = &v
	return s
}

type DeleteOSSIngestionResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteOSSIngestionResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteOSSIngestionResponse) GoString() string {
	return s.String()
}

func (s *DeleteOSSIngestionResponse) SetHeaders(v map[string]*string) *DeleteOSSIngestionResponse {
	s.Headers = v
	return s
}

func (s *DeleteOSSIngestionResponse) SetStatusCode(v int32) *DeleteOSSIngestionResponse {
	s.StatusCode = &v
	return s
}

type DeleteProjectRequest struct {
	ForceDelete *bool `json:"forceDelete,omitempty" xml:"forceDelete,omitempty"`
}

func (s DeleteProjectRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteProjectRequest) GoString() string {
	return s.String()
}

func (s *DeleteProjectRequest) SetForceDelete(v bool) *DeleteProjectRequest {
	s.ForceDelete = &v
	return s
}

type DeleteProjectResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteProjectResponse) GoString() string {
	return s.String()
}

func (s *DeleteProjectResponse) SetHeaders(v map[string]*string) *DeleteProjectResponse {
	s.Headers = v
	return s
}

func (s *DeleteProjectResponse) SetStatusCode(v int32) *DeleteProjectResponse {
	s.StatusCode = &v
	return s
}

type DeleteProjectPolicyResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteProjectPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteProjectPolicyResponse) GoString() string {
	return s.String()
}

func (s *DeleteProjectPolicyResponse) SetHeaders(v map[string]*string) *DeleteProjectPolicyResponse {
	s.Headers = v
	return s
}

func (s *DeleteProjectPolicyResponse) SetStatusCode(v int32) *DeleteProjectPolicyResponse {
	s.StatusCode = &v
	return s
}

type DeleteSavedSearchResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteSavedSearchResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSavedSearchResponse) GoString() string {
	return s.String()
}

func (s *DeleteSavedSearchResponse) SetHeaders(v map[string]*string) *DeleteSavedSearchResponse {
	s.Headers = v
	return s
}

func (s *DeleteSavedSearchResponse) SetStatusCode(v int32) *DeleteSavedSearchResponse {
	s.StatusCode = &v
	return s
}

type DeleteScheduledSQLResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteScheduledSQLResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteScheduledSQLResponse) GoString() string {
	return s.String()
}

func (s *DeleteScheduledSQLResponse) SetHeaders(v map[string]*string) *DeleteScheduledSQLResponse {
	s.Headers = v
	return s
}

func (s *DeleteScheduledSQLResponse) SetStatusCode(v int32) *DeleteScheduledSQLResponse {
	s.StatusCode = &v
	return s
}

type DeleteStoreViewResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DeleteStoreViewResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteStoreViewResponse) GoString() string {
	return s.String()
}

func (s *DeleteStoreViewResponse) SetHeaders(v map[string]*string) *DeleteStoreViewResponse {
	s.Headers = v
	return s
}

func (s *DeleteStoreViewResponse) SetStatusCode(v int32) *DeleteStoreViewResponse {
	s.StatusCode = &v
	return s
}

type DescribeRegionsRequest struct {
	// A short description of struct
	Language *string `json:"language,omitempty" xml:"language,omitempty"`
}

func (s DescribeRegionsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsRequest) GoString() string {
	return s.String()
}

func (s *DescribeRegionsRequest) SetLanguage(v string) *DescribeRegionsRequest {
	s.Language = &v
	return s
}

type DescribeRegionsResponseBody struct {
	Regions []*DescribeRegionsResponseBodyRegions `json:"regions,omitempty" xml:"regions,omitempty" type:"Repeated"`
}

func (s DescribeRegionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBody) SetRegions(v []*DescribeRegionsResponseBodyRegions) *DescribeRegionsResponseBody {
	s.Regions = v
	return s
}

type DescribeRegionsResponseBodyRegions struct {
	InternetEndpoint *string `json:"internetEndpoint,omitempty" xml:"internetEndpoint,omitempty"`
	IntranetEndpoint *string `json:"intranetEndpoint,omitempty" xml:"intranetEndpoint,omitempty"`
	LocalName        *string `json:"localName,omitempty" xml:"localName,omitempty"`
	// SLS region
	Region *string `json:"region,omitempty" xml:"region,omitempty"`
}

func (s DescribeRegionsResponseBodyRegions) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponseBodyRegions) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBodyRegions) SetInternetEndpoint(v string) *DescribeRegionsResponseBodyRegions {
	s.InternetEndpoint = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegions) SetIntranetEndpoint(v string) *DescribeRegionsResponseBodyRegions {
	s.IntranetEndpoint = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegions) SetLocalName(v string) *DescribeRegionsResponseBodyRegions {
	s.LocalName = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegions) SetRegion(v string) *DescribeRegionsResponseBodyRegions {
	s.Region = &v
	return s
}

type DescribeRegionsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeRegionsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeRegionsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponse) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponse) SetHeaders(v map[string]*string) *DescribeRegionsResponse {
	s.Headers = v
	return s
}

func (s *DescribeRegionsResponse) SetStatusCode(v int32) *DescribeRegionsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRegionsResponse) SetBody(v *DescribeRegionsResponseBody) *DescribeRegionsResponse {
	s.Body = v
	return s
}

type DisableAlertResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DisableAlertResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableAlertResponse) GoString() string {
	return s.String()
}

func (s *DisableAlertResponse) SetHeaders(v map[string]*string) *DisableAlertResponse {
	s.Headers = v
	return s
}

func (s *DisableAlertResponse) SetStatusCode(v int32) *DisableAlertResponse {
	s.StatusCode = &v
	return s
}

type DisableScheduledSQLResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s DisableScheduledSQLResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableScheduledSQLResponse) GoString() string {
	return s.String()
}

func (s *DisableScheduledSQLResponse) SetHeaders(v map[string]*string) *DisableScheduledSQLResponse {
	s.Headers = v
	return s
}

func (s *DisableScheduledSQLResponse) SetStatusCode(v int32) *DisableScheduledSQLResponse {
	s.StatusCode = &v
	return s
}

type EnableAlertResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s EnableAlertResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableAlertResponse) GoString() string {
	return s.String()
}

func (s *EnableAlertResponse) SetHeaders(v map[string]*string) *EnableAlertResponse {
	s.Headers = v
	return s
}

func (s *EnableAlertResponse) SetStatusCode(v int32) *EnableAlertResponse {
	s.StatusCode = &v
	return s
}

type EnableScheduledSQLResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s EnableScheduledSQLResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableScheduledSQLResponse) GoString() string {
	return s.String()
}

func (s *EnableScheduledSQLResponse) SetHeaders(v map[string]*string) *EnableScheduledSQLResponse {
	s.Headers = v
	return s
}

func (s *EnableScheduledSQLResponse) SetStatusCode(v int32) *EnableScheduledSQLResponse {
	s.StatusCode = &v
	return s
}

type GetAgentInstanceConfigResponseBody struct {
	Config         *string `json:"config,omitempty" xml:"config,omitempty"`
	ConfigMatcher  *string `json:"configMatcher,omitempty" xml:"configMatcher,omitempty"`
	ConfigName     *string `json:"configName,omitempty" xml:"configName,omitempty"`
	CreateTime     *int64  `json:"createTime,omitempty" xml:"createTime,omitempty"`
	IsGray         *bool   `json:"isGray,omitempty" xml:"isGray,omitempty"`
	LastModifyTime *int64  `json:"lastModifyTime,omitempty" xml:"lastModifyTime,omitempty"`
}

func (s GetAgentInstanceConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAgentInstanceConfigResponseBody) GoString() string {
	return s.String()
}

func (s *GetAgentInstanceConfigResponseBody) SetConfig(v string) *GetAgentInstanceConfigResponseBody {
	s.Config = &v
	return s
}

func (s *GetAgentInstanceConfigResponseBody) SetConfigMatcher(v string) *GetAgentInstanceConfigResponseBody {
	s.ConfigMatcher = &v
	return s
}

func (s *GetAgentInstanceConfigResponseBody) SetConfigName(v string) *GetAgentInstanceConfigResponseBody {
	s.ConfigName = &v
	return s
}

func (s *GetAgentInstanceConfigResponseBody) SetCreateTime(v int64) *GetAgentInstanceConfigResponseBody {
	s.CreateTime = &v
	return s
}

func (s *GetAgentInstanceConfigResponseBody) SetIsGray(v bool) *GetAgentInstanceConfigResponseBody {
	s.IsGray = &v
	return s
}

func (s *GetAgentInstanceConfigResponseBody) SetLastModifyTime(v int64) *GetAgentInstanceConfigResponseBody {
	s.LastModifyTime = &v
	return s
}

type GetAgentInstanceConfigResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetAgentInstanceConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetAgentInstanceConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAgentInstanceConfigResponse) GoString() string {
	return s.String()
}

func (s *GetAgentInstanceConfigResponse) SetHeaders(v map[string]*string) *GetAgentInstanceConfigResponse {
	s.Headers = v
	return s
}

func (s *GetAgentInstanceConfigResponse) SetStatusCode(v int32) *GetAgentInstanceConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAgentInstanceConfigResponse) SetBody(v *GetAgentInstanceConfigResponseBody) *GetAgentInstanceConfigResponse {
	s.Body = v
	return s
}

type GetAlertResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *Alert             `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetAlertResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAlertResponse) GoString() string {
	return s.String()
}

func (s *GetAlertResponse) SetHeaders(v map[string]*string) *GetAlertResponse {
	s.Headers = v
	return s
}

func (s *GetAlertResponse) SetStatusCode(v int32) *GetAlertResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAlertResponse) SetBody(v *Alert) *GetAlertResponse {
	s.Body = v
	return s
}

type GetAnnotationDataResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *MLDataParam       `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetAnnotationDataResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAnnotationDataResponse) GoString() string {
	return s.String()
}

func (s *GetAnnotationDataResponse) SetHeaders(v map[string]*string) *GetAnnotationDataResponse {
	s.Headers = v
	return s
}

func (s *GetAnnotationDataResponse) SetStatusCode(v int32) *GetAnnotationDataResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAnnotationDataResponse) SetBody(v *MLDataParam) *GetAnnotationDataResponse {
	s.Body = v
	return s
}

type GetAnnotationDataSetResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *MLDataSetParam    `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetAnnotationDataSetResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAnnotationDataSetResponse) GoString() string {
	return s.String()
}

func (s *GetAnnotationDataSetResponse) SetHeaders(v map[string]*string) *GetAnnotationDataSetResponse {
	s.Headers = v
	return s
}

func (s *GetAnnotationDataSetResponse) SetStatusCode(v int32) *GetAnnotationDataSetResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAnnotationDataSetResponse) SetBody(v *MLDataSetParam) *GetAnnotationDataSetResponse {
	s.Body = v
	return s
}

type GetAnnotationLabelResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *MLLabelParam      `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetAnnotationLabelResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAnnotationLabelResponse) GoString() string {
	return s.String()
}

func (s *GetAnnotationLabelResponse) SetHeaders(v map[string]*string) *GetAnnotationLabelResponse {
	s.Headers = v
	return s
}

func (s *GetAnnotationLabelResponse) SetStatusCode(v int32) *GetAnnotationLabelResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAnnotationLabelResponse) SetBody(v *MLLabelParam) *GetAnnotationLabelResponse {
	s.Body = v
	return s
}

type GetAppliedConfigsResponseBody struct {
	// The names of the Logtail configurations.
	Configs []*string `json:"configs,omitempty" xml:"configs,omitempty" type:"Repeated"`
	// The number of Logtail configurations.
	//
	// example:
	//
	// 2
	Count *int32 `json:"count,omitempty" xml:"count,omitempty"`
}

func (s GetAppliedConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAppliedConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *GetAppliedConfigsResponseBody) SetConfigs(v []*string) *GetAppliedConfigsResponseBody {
	s.Configs = v
	return s
}

func (s *GetAppliedConfigsResponseBody) SetCount(v int32) *GetAppliedConfigsResponseBody {
	s.Count = &v
	return s
}

type GetAppliedConfigsResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetAppliedConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetAppliedConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAppliedConfigsResponse) GoString() string {
	return s.String()
}

func (s *GetAppliedConfigsResponse) SetHeaders(v map[string]*string) *GetAppliedConfigsResponse {
	s.Headers = v
	return s
}

func (s *GetAppliedConfigsResponse) SetStatusCode(v int32) *GetAppliedConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAppliedConfigsResponse) SetBody(v *GetAppliedConfigsResponseBody) *GetAppliedConfigsResponse {
	s.Body = v
	return s
}

type GetAppliedMachineGroupsResponseBody struct {
	// The number of returned machine groups.
	//
	// example:
	//
	// 2
	Count *int32 `json:"count,omitempty" xml:"count,omitempty"`
	// The names of the returned machine groups.
	//
	// example:
	//
	// [ "sample-group1","sample-group2" ]
	Machinegroups []*string `json:"machinegroups,omitempty" xml:"machinegroups,omitempty" type:"Repeated"`
}

func (s GetAppliedMachineGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAppliedMachineGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *GetAppliedMachineGroupsResponseBody) SetCount(v int32) *GetAppliedMachineGroupsResponseBody {
	s.Count = &v
	return s
}

func (s *GetAppliedMachineGroupsResponseBody) SetMachinegroups(v []*string) *GetAppliedMachineGroupsResponseBody {
	s.Machinegroups = v
	return s
}

type GetAppliedMachineGroupsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetAppliedMachineGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetAppliedMachineGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAppliedMachineGroupsResponse) GoString() string {
	return s.String()
}

func (s *GetAppliedMachineGroupsResponse) SetHeaders(v map[string]*string) *GetAppliedMachineGroupsResponse {
	s.Headers = v
	return s
}

func (s *GetAppliedMachineGroupsResponse) SetStatusCode(v int32) *GetAppliedMachineGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAppliedMachineGroupsResponse) SetBody(v *GetAppliedMachineGroupsResponseBody) *GetAppliedMachineGroupsResponse {
	s.Body = v
	return s
}

type GetCheckPointRequest struct {
	// The shard ID.
	//
	// 	- If the specified shard does not exist, an empty list is returned.
	//
	// 	- If no shard ID is specified, the checkpoints of all shards are returned.
	//
	// example:
	//
	// 1
	Shard *int32 `json:"shard,omitempty" xml:"shard,omitempty"`
}

func (s GetCheckPointRequest) String() string {
	return tea.Prettify(s)
}

func (s GetCheckPointRequest) GoString() string {
	return s.String()
}

func (s *GetCheckPointRequest) SetShard(v int32) *GetCheckPointRequest {
	s.Shard = &v
	return s
}

type GetCheckPointResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       []*GetCheckPointResponseBody `json:"body,omitempty" xml:"body,omitempty" type:"Repeated"`
}

func (s GetCheckPointResponse) String() string {
	return tea.Prettify(s)
}

func (s GetCheckPointResponse) GoString() string {
	return s.String()
}

func (s *GetCheckPointResponse) SetHeaders(v map[string]*string) *GetCheckPointResponse {
	s.Headers = v
	return s
}

func (s *GetCheckPointResponse) SetStatusCode(v int32) *GetCheckPointResponse {
	s.StatusCode = &v
	return s
}

func (s *GetCheckPointResponse) SetBody(v []*GetCheckPointResponseBody) *GetCheckPointResponse {
	s.Body = v
	return s
}

type GetCheckPointResponseBody struct {
	// The shard ID.
	//
	// example:
	//
	// 0
	Shard *int32 `json:"shard,omitempty" xml:"shard,omitempty"`
	// The value of the checkpoint.
	//
	// example:
	//
	// MTUyNDE1NTM3OTM3MzkwODQ5Ng==
	Checkpoint *string `json:"checkpoint,omitempty" xml:"checkpoint,omitempty"`
	// The time when the checkpoint was last updated. The value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	//
	// example:
	//
	// 1524224984800922
	UpdateTime *int64 `json:"updateTime,omitempty" xml:"updateTime,omitempty"`
	// The consumer at the checkpoint.
	//
	// example:
	//
	// consumer_1
	Consumer *string `json:"consumer,omitempty" xml:"consumer,omitempty"`
}

func (s GetCheckPointResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetCheckPointResponseBody) GoString() string {
	return s.String()
}

func (s *GetCheckPointResponseBody) SetShard(v int32) *GetCheckPointResponseBody {
	s.Shard = &v
	return s
}

func (s *GetCheckPointResponseBody) SetCheckpoint(v string) *GetCheckPointResponseBody {
	s.Checkpoint = &v
	return s
}

func (s *GetCheckPointResponseBody) SetUpdateTime(v int64) *GetCheckPointResponseBody {
	s.UpdateTime = &v
	return s
}

func (s *GetCheckPointResponseBody) SetConsumer(v string) *GetCheckPointResponseBody {
	s.Consumer = &v
	return s
}

type GetCollectionPolicyRequest struct {
	// example:
	//
	// access_log
	DataCode *string `json:"dataCode,omitempty" xml:"dataCode,omitempty"`
	// example:
	//
	// oss
	ProductCode *string `json:"productCode,omitempty" xml:"productCode,omitempty"`
}

func (s GetCollectionPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s GetCollectionPolicyRequest) GoString() string {
	return s.String()
}

func (s *GetCollectionPolicyRequest) SetDataCode(v string) *GetCollectionPolicyRequest {
	s.DataCode = &v
	return s
}

func (s *GetCollectionPolicyRequest) SetProductCode(v string) *GetCollectionPolicyRequest {
	s.ProductCode = &v
	return s
}

type GetCollectionPolicyResponseBody struct {
	CollectionPolicy *GetCollectionPolicyResponseBodyCollectionPolicy `json:"collectionPolicy,omitempty" xml:"collectionPolicy,omitempty" type:"Struct"`
}

func (s GetCollectionPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetCollectionPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *GetCollectionPolicyResponseBody) SetCollectionPolicy(v *GetCollectionPolicyResponseBodyCollectionPolicy) *GetCollectionPolicyResponseBody {
	s.CollectionPolicy = v
	return s
}

type GetCollectionPolicyResponseBodyCollectionPolicy struct {
	CentralizeConfig *GetCollectionPolicyResponseBodyCollectionPolicyCentralizeConfig `json:"centralizeConfig,omitempty" xml:"centralizeConfig,omitempty" type:"Struct"`
	// example:
	//
	// false
	CentralizeEnabled *bool `json:"centralizeEnabled,omitempty" xml:"centralizeEnabled,omitempty"`
	// example:
	//
	// access_log
	DataCode   *string                                                    `json:"dataCode,omitempty" xml:"dataCode,omitempty"`
	DataConfig *GetCollectionPolicyResponseBodyCollectionPolicyDataConfig `json:"dataConfig,omitempty" xml:"dataConfig,omitempty" type:"Struct"`
	// example:
	//
	// true
	Enabled *bool `json:"enabled,omitempty" xml:"enabled,omitempty"`
	// example:
	//
	// false
	InternalPolicy *bool                                                        `json:"internalPolicy,omitempty" xml:"internalPolicy,omitempty"`
	PolicyConfig   *GetCollectionPolicyResponseBodyCollectionPolicyPolicyConfig `json:"policyConfig,omitempty" xml:"policyConfig,omitempty" type:"Struct"`
	// example:
	//
	// your_log_policy
	PolicyName *string `json:"policyName,omitempty" xml:"policyName,omitempty"`
	// example:
	//
	// 148***********50
	PolicyUid *string `json:"policyUid,omitempty" xml:"policyUid,omitempty"`
	// example:
	//
	// oss
	ProductCode       *string                                                           `json:"productCode,omitempty" xml:"productCode,omitempty"`
	ResourceDirectory *GetCollectionPolicyResponseBodyCollectionPolicyResourceDirectory `json:"resourceDirectory,omitempty" xml:"resourceDirectory,omitempty" type:"Struct"`
}

func (s GetCollectionPolicyResponseBodyCollectionPolicy) String() string {
	return tea.Prettify(s)
}

func (s GetCollectionPolicyResponseBodyCollectionPolicy) GoString() string {
	return s.String()
}

func (s *GetCollectionPolicyResponseBodyCollectionPolicy) SetCentralizeConfig(v *GetCollectionPolicyResponseBodyCollectionPolicyCentralizeConfig) *GetCollectionPolicyResponseBodyCollectionPolicy {
	s.CentralizeConfig = v
	return s
}

func (s *GetCollectionPolicyResponseBodyCollectionPolicy) SetCentralizeEnabled(v bool) *GetCollectionPolicyResponseBodyCollectionPolicy {
	s.CentralizeEnabled = &v
	return s
}

func (s *GetCollectionPolicyResponseBodyCollectionPolicy) SetDataCode(v string) *GetCollectionPolicyResponseBodyCollectionPolicy {
	s.DataCode = &v
	return s
}

func (s *GetCollectionPolicyResponseBodyCollectionPolicy) SetDataConfig(v *GetCollectionPolicyResponseBodyCollectionPolicyDataConfig) *GetCollectionPolicyResponseBodyCollectionPolicy {
	s.DataConfig = v
	return s
}

func (s *GetCollectionPolicyResponseBodyCollectionPolicy) SetEnabled(v bool) *GetCollectionPolicyResponseBodyCollectionPolicy {
	s.Enabled = &v
	return s
}

func (s *GetCollectionPolicyResponseBodyCollectionPolicy) SetInternalPolicy(v bool) *GetCollectionPolicyResponseBodyCollectionPolicy {
	s.InternalPolicy = &v
	return s
}

func (s *GetCollectionPolicyResponseBodyCollectionPolicy) SetPolicyConfig(v *GetCollectionPolicyResponseBodyCollectionPolicyPolicyConfig) *GetCollectionPolicyResponseBodyCollectionPolicy {
	s.PolicyConfig = v
	return s
}

func (s *GetCollectionPolicyResponseBodyCollectionPolicy) SetPolicyName(v string) *GetCollectionPolicyResponseBodyCollectionPolicy {
	s.PolicyName = &v
	return s
}

func (s *GetCollectionPolicyResponseBodyCollectionPolicy) SetPolicyUid(v string) *GetCollectionPolicyResponseBodyCollectionPolicy {
	s.PolicyUid = &v
	return s
}

func (s *GetCollectionPolicyResponseBodyCollectionPolicy) SetProductCode(v string) *GetCollectionPolicyResponseBodyCollectionPolicy {
	s.ProductCode = &v
	return s
}

func (s *GetCollectionPolicyResponseBodyCollectionPolicy) SetResourceDirectory(v *GetCollectionPolicyResponseBodyCollectionPolicyResourceDirectory) *GetCollectionPolicyResponseBodyCollectionPolicy {
	s.ResourceDirectory = v
	return s
}

type GetCollectionPolicyResponseBodyCollectionPolicyCentralizeConfig struct {
	// example:
	//
	// your-sls-logstore-in-beijing
	DestLogstore *string `json:"destLogstore,omitempty" xml:"destLogstore,omitempty"`
	// example:
	//
	// your-sls-project-in-beijing
	DestProject *string `json:"destProject,omitempty" xml:"destProject,omitempty"`
	// example:
	//
	// cn-beijing
	DestRegion *string `json:"destRegion,omitempty" xml:"destRegion,omitempty"`
	// example:
	//
	// your-sls-logstore-ttl
	DestTTL *int32 `json:"destTTL,omitempty" xml:"destTTL,omitempty"`
}

func (s GetCollectionPolicyResponseBodyCollectionPolicyCentralizeConfig) String() string {
	return tea.Prettify(s)
}

func (s GetCollectionPolicyResponseBodyCollectionPolicyCentralizeConfig) GoString() string {
	return s.String()
}

func (s *GetCollectionPolicyResponseBodyCollectionPolicyCentralizeConfig) SetDestLogstore(v string) *GetCollectionPolicyResponseBodyCollectionPolicyCentralizeConfig {
	s.DestLogstore = &v
	return s
}

func (s *GetCollectionPolicyResponseBodyCollectionPolicyCentralizeConfig) SetDestProject(v string) *GetCollectionPolicyResponseBodyCollectionPolicyCentralizeConfig {
	s.DestProject = &v
	return s
}

func (s *GetCollectionPolicyResponseBodyCollectionPolicyCentralizeConfig) SetDestRegion(v string) *GetCollectionPolicyResponseBodyCollectionPolicyCentralizeConfig {
	s.DestRegion = &v
	return s
}

func (s *GetCollectionPolicyResponseBodyCollectionPolicyCentralizeConfig) SetDestTTL(v int32) *GetCollectionPolicyResponseBodyCollectionPolicyCentralizeConfig {
	s.DestTTL = &v
	return s
}

type GetCollectionPolicyResponseBodyCollectionPolicyDataConfig struct {
	// example:
	//
	// ""
	DataProject *string `json:"dataProject,omitempty" xml:"dataProject,omitempty"`
	// example:
	//
	// cn-beijing
	DataRegion *string `json:"dataRegion,omitempty" xml:"dataRegion,omitempty"`
}

func (s GetCollectionPolicyResponseBodyCollectionPolicyDataConfig) String() string {
	return tea.Prettify(s)
}

func (s GetCollectionPolicyResponseBodyCollectionPolicyDataConfig) GoString() string {
	return s.String()
}

func (s *GetCollectionPolicyResponseBodyCollectionPolicyDataConfig) SetDataProject(v string) *GetCollectionPolicyResponseBodyCollectionPolicyDataConfig {
	s.DataProject = &v
	return s
}

func (s *GetCollectionPolicyResponseBodyCollectionPolicyDataConfig) SetDataRegion(v string) *GetCollectionPolicyResponseBodyCollectionPolicyDataConfig {
	s.DataRegion = &v
	return s
}

type GetCollectionPolicyResponseBodyCollectionPolicyPolicyConfig struct {
	InstanceIds []*string `json:"instanceIds,omitempty" xml:"instanceIds,omitempty" type:"Repeated"`
	Regions     []*string `json:"regions,omitempty" xml:"regions,omitempty" type:"Repeated"`
	// example:
	//
	// all
	ResourceMode *string `json:"resourceMode,omitempty" xml:"resourceMode,omitempty"`
	// example:
	//
	// {"tag1":"value1","tag2":"value2"}
	ResourceTags map[string]interface{} `json:"resourceTags,omitempty" xml:"resourceTags,omitempty"`
}

func (s GetCollectionPolicyResponseBodyCollectionPolicyPolicyConfig) String() string {
	return tea.Prettify(s)
}

func (s GetCollectionPolicyResponseBodyCollectionPolicyPolicyConfig) GoString() string {
	return s.String()
}

func (s *GetCollectionPolicyResponseBodyCollectionPolicyPolicyConfig) SetInstanceIds(v []*string) *GetCollectionPolicyResponseBodyCollectionPolicyPolicyConfig {
	s.InstanceIds = v
	return s
}

func (s *GetCollectionPolicyResponseBodyCollectionPolicyPolicyConfig) SetRegions(v []*string) *GetCollectionPolicyResponseBodyCollectionPolicyPolicyConfig {
	s.Regions = v
	return s
}

func (s *GetCollectionPolicyResponseBodyCollectionPolicyPolicyConfig) SetResourceMode(v string) *GetCollectionPolicyResponseBodyCollectionPolicyPolicyConfig {
	s.ResourceMode = &v
	return s
}

func (s *GetCollectionPolicyResponseBodyCollectionPolicyPolicyConfig) SetResourceTags(v map[string]interface{}) *GetCollectionPolicyResponseBodyCollectionPolicyPolicyConfig {
	s.ResourceTags = v
	return s
}

type GetCollectionPolicyResponseBodyCollectionPolicyResourceDirectory struct {
	// example:
	//
	// all,custom
	AccountGroupType *string   `json:"accountGroupType,omitempty" xml:"accountGroupType,omitempty"`
	Members          []*string `json:"members,omitempty" xml:"members,omitempty" type:"Repeated"`
}

func (s GetCollectionPolicyResponseBodyCollectionPolicyResourceDirectory) String() string {
	return tea.Prettify(s)
}

func (s GetCollectionPolicyResponseBodyCollectionPolicyResourceDirectory) GoString() string {
	return s.String()
}

func (s *GetCollectionPolicyResponseBodyCollectionPolicyResourceDirectory) SetAccountGroupType(v string) *GetCollectionPolicyResponseBodyCollectionPolicyResourceDirectory {
	s.AccountGroupType = &v
	return s
}

func (s *GetCollectionPolicyResponseBodyCollectionPolicyResourceDirectory) SetMembers(v []*string) *GetCollectionPolicyResponseBodyCollectionPolicyResourceDirectory {
	s.Members = v
	return s
}

type GetCollectionPolicyResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetCollectionPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetCollectionPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s GetCollectionPolicyResponse) GoString() string {
	return s.String()
}

func (s *GetCollectionPolicyResponse) SetHeaders(v map[string]*string) *GetCollectionPolicyResponse {
	s.Headers = v
	return s
}

func (s *GetCollectionPolicyResponse) SetStatusCode(v int32) *GetCollectionPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *GetCollectionPolicyResponse) SetBody(v *GetCollectionPolicyResponseBody) *GetCollectionPolicyResponse {
	s.Body = v
	return s
}

type GetConfigResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *LogtailConfig     `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s GetConfigResponse) GoString() string {
	return s.String()
}

func (s *GetConfigResponse) SetHeaders(v map[string]*string) *GetConfigResponse {
	s.Headers = v
	return s
}

func (s *GetConfigResponse) SetStatusCode(v int32) *GetConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *GetConfigResponse) SetBody(v *LogtailConfig) *GetConfigResponse {
	s.Body = v
	return s
}

type GetContextLogsRequest struct {
	// The number of logs that you want to obtain and are generated before the generation time of the start log. Valid values: `(0,100]`.
	//
	// This parameter is required.
	//
	// example:
	//
	// 10
	BackLines *int64 `json:"back_lines,omitempty" xml:"back_lines,omitempty"`
	// The number of logs that you want to obtain and are generated after the generation time of the start log. Valid values: `(0,100]`.
	//
	// This parameter is required.
	//
	// example:
	//
	// 10
	ForwardLines *int64 `json:"forward_lines,omitempty" xml:"forward_lines,omitempty"`
	// The unique identifier of the log group to which the start log belongs.
	//
	// This parameter is required.
	//
	// example:
	//
	// 85C897C740352DC6-808
	PackId *string `json:"pack_id,omitempty" xml:"pack_id,omitempty"`
	// The unique context identifier of the start log in the log group.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2|MTY1NTcwNTUzODY5MTY0MDk1Mg==|3|0
	PackMeta *string `json:"pack_meta,omitempty" xml:"pack_meta,omitempty"`
}

func (s GetContextLogsRequest) String() string {
	return tea.Prettify(s)
}

func (s GetContextLogsRequest) GoString() string {
	return s.String()
}

func (s *GetContextLogsRequest) SetBackLines(v int64) *GetContextLogsRequest {
	s.BackLines = &v
	return s
}

func (s *GetContextLogsRequest) SetForwardLines(v int64) *GetContextLogsRequest {
	s.ForwardLines = &v
	return s
}

func (s *GetContextLogsRequest) SetPackId(v string) *GetContextLogsRequest {
	s.PackId = &v
	return s
}

func (s *GetContextLogsRequest) SetPackMeta(v string) *GetContextLogsRequest {
	s.PackMeta = &v
	return s
}

type GetContextLogsResponseBody struct {
	// The number of logs that are generated before the generation time of the start log.
	//
	// example:
	//
	// 100
	BackLines *int64 `json:"back_lines,omitempty" xml:"back_lines,omitempty"`
	// The number of logs that are generated after the generation time of the start log.
	//
	// example:
	//
	// 100
	ForwardLines *int64 `json:"forward_lines,omitempty" xml:"forward_lines,omitempty"`
	// The logs that are returned.
	Logs []map[string]interface{} `json:"logs,omitempty" xml:"logs,omitempty" type:"Repeated"`
	// Indicates whether the query and analysis results are complete. Valid values:
	//
	// 	- Complete: The query is successful, and the complete query and analysis results are returned.
	//
	// 	- Incomplete: The query is successful, but the query and analysis results are incomplete. To obtain the complete results, you must repeat the request.
	//
	// example:
	//
	// Complete
	Progress *string `json:"progress,omitempty" xml:"progress,omitempty"`
	// The total number of logs that are returned. The logs include the start log that is specified in the request.
	//
	// example:
	//
	// 201
	TotalLines *int64 `json:"total_lines,omitempty" xml:"total_lines,omitempty"`
}

func (s GetContextLogsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetContextLogsResponseBody) GoString() string {
	return s.String()
}

func (s *GetContextLogsResponseBody) SetBackLines(v int64) *GetContextLogsResponseBody {
	s.BackLines = &v
	return s
}

func (s *GetContextLogsResponseBody) SetForwardLines(v int64) *GetContextLogsResponseBody {
	s.ForwardLines = &v
	return s
}

func (s *GetContextLogsResponseBody) SetLogs(v []map[string]interface{}) *GetContextLogsResponseBody {
	s.Logs = v
	return s
}

func (s *GetContextLogsResponseBody) SetProgress(v string) *GetContextLogsResponseBody {
	s.Progress = &v
	return s
}

func (s *GetContextLogsResponseBody) SetTotalLines(v int64) *GetContextLogsResponseBody {
	s.TotalLines = &v
	return s
}

type GetContextLogsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetContextLogsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetContextLogsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetContextLogsResponse) GoString() string {
	return s.String()
}

func (s *GetContextLogsResponse) SetHeaders(v map[string]*string) *GetContextLogsResponse {
	s.Headers = v
	return s
}

func (s *GetContextLogsResponse) SetStatusCode(v int32) *GetContextLogsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetContextLogsResponse) SetBody(v *GetContextLogsResponseBody) *GetContextLogsResponse {
	s.Body = v
	return s
}

type GetCursorRequest struct {
	// The point in time that you want to use to query a cursor. Set the value to a UNIX timestamp or a string such as `begin` and `end`.
	//
	// This parameter is required.
	//
	// example:
	//
	// begin
	From *string `json:"from,omitempty" xml:"from,omitempty"`
}

func (s GetCursorRequest) String() string {
	return tea.Prettify(s)
}

func (s GetCursorRequest) GoString() string {
	return s.String()
}

func (s *GetCursorRequest) SetFrom(v string) *GetCursorRequest {
	s.From = &v
	return s
}

type GetCursorResponseBody struct {
	// The value of the cursor.
	//
	// example:
	//
	// MTQ0NzI5OTYwNjg5NjYzMjM1Ng==
	Cursor *string `json:"cursor,omitempty" xml:"cursor,omitempty"`
}

func (s GetCursorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetCursorResponseBody) GoString() string {
	return s.String()
}

func (s *GetCursorResponseBody) SetCursor(v string) *GetCursorResponseBody {
	s.Cursor = &v
	return s
}

type GetCursorResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetCursorResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetCursorResponse) String() string {
	return tea.Prettify(s)
}

func (s GetCursorResponse) GoString() string {
	return s.String()
}

func (s *GetCursorResponse) SetHeaders(v map[string]*string) *GetCursorResponse {
	s.Headers = v
	return s
}

func (s *GetCursorResponse) SetStatusCode(v int32) *GetCursorResponse {
	s.StatusCode = &v
	return s
}

func (s *GetCursorResponse) SetBody(v *GetCursorResponseBody) *GetCursorResponse {
	s.Body = v
	return s
}

type GetCursorTimeRequest struct {
	// The cursor.
	//
	// This parameter is required.
	//
	// example:
	//
	// MTU0NzQ3MDY4MjM3NjUxMzQ0Ng==
	Cursor *string `json:"cursor,omitempty" xml:"cursor,omitempty"`
}

func (s GetCursorTimeRequest) String() string {
	return tea.Prettify(s)
}

func (s GetCursorTimeRequest) GoString() string {
	return s.String()
}

func (s *GetCursorTimeRequest) SetCursor(v string) *GetCursorTimeRequest {
	s.Cursor = &v
	return s
}

type GetCursorTimeResponseBody struct {
	// The server time that is queried based on the cursor. The value is a UNIX timestamp representing the number of seconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	//
	// example:
	//
	// 1554260243
	CursorTime *string `json:"cursor_time,omitempty" xml:"cursor_time,omitempty"`
}

func (s GetCursorTimeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetCursorTimeResponseBody) GoString() string {
	return s.String()
}

func (s *GetCursorTimeResponseBody) SetCursorTime(v string) *GetCursorTimeResponseBody {
	s.CursorTime = &v
	return s
}

type GetCursorTimeResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetCursorTimeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetCursorTimeResponse) String() string {
	return tea.Prettify(s)
}

func (s GetCursorTimeResponse) GoString() string {
	return s.String()
}

func (s *GetCursorTimeResponse) SetHeaders(v map[string]*string) *GetCursorTimeResponse {
	s.Headers = v
	return s
}

func (s *GetCursorTimeResponse) SetStatusCode(v int32) *GetCursorTimeResponse {
	s.StatusCode = &v
	return s
}

func (s *GetCursorTimeResponse) SetBody(v *GetCursorTimeResponseBody) *GetCursorTimeResponse {
	s.Body = v
	return s
}

type GetDashboardResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *Dashboard         `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetDashboardResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDashboardResponse) GoString() string {
	return s.String()
}

func (s *GetDashboardResponse) SetHeaders(v map[string]*string) *GetDashboardResponse {
	s.Headers = v
	return s
}

func (s *GetDashboardResponse) SetStatusCode(v int32) *GetDashboardResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDashboardResponse) SetBody(v *Dashboard) *GetDashboardResponse {
	s.Body = v
	return s
}

type GetDownloadJobResponseBody struct {
	// 下载配置
	Configuration *GetDownloadJobResponseBodyConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty" type:"Struct"`
	// 代表创建时间的资源属性字段
	//
	// example:
	//
	// 1722411060
	CreateTime *string `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// 任务描述
	//
	// example:
	//
	// a download job
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// 任务显示名称
	//
	// example:
	//
	// download-123456
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// 任务执行细节
	ExecutionDetails *GetDownloadJobResponseBodyExecutionDetails `json:"executionDetails,omitempty" xml:"executionDetails,omitempty" type:"Struct"`
	// 代表资源名称的资源属性字段
	//
	// example:
	//
	// download-123
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The status of the log download task.
	//
	// example:
	//
	// running
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s GetDownloadJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDownloadJobResponseBody) GoString() string {
	return s.String()
}

func (s *GetDownloadJobResponseBody) SetConfiguration(v *GetDownloadJobResponseBodyConfiguration) *GetDownloadJobResponseBody {
	s.Configuration = v
	return s
}

func (s *GetDownloadJobResponseBody) SetCreateTime(v string) *GetDownloadJobResponseBody {
	s.CreateTime = &v
	return s
}

func (s *GetDownloadJobResponseBody) SetDescription(v string) *GetDownloadJobResponseBody {
	s.Description = &v
	return s
}

func (s *GetDownloadJobResponseBody) SetDisplayName(v string) *GetDownloadJobResponseBody {
	s.DisplayName = &v
	return s
}

func (s *GetDownloadJobResponseBody) SetExecutionDetails(v *GetDownloadJobResponseBodyExecutionDetails) *GetDownloadJobResponseBody {
	s.ExecutionDetails = v
	return s
}

func (s *GetDownloadJobResponseBody) SetName(v string) *GetDownloadJobResponseBody {
	s.Name = &v
	return s
}

func (s *GetDownloadJobResponseBody) SetStatus(v string) *GetDownloadJobResponseBody {
	s.Status = &v
	return s
}

type GetDownloadJobResponseBodyConfiguration struct {
	// example:
	//
	// true
	AllowInComplete *bool `json:"allowInComplete,omitempty" xml:"allowInComplete,omitempty"`
	// 起点时间戳（精确到秒）
	//
	// example:
	//
	// 1722409860
	FromTime *int64 `json:"fromTime,omitempty" xml:"fromTime,omitempty"`
	// 源logstore
	//
	// example:
	//
	// ali-test-logstore
	Logstore *string `json:"logstore,omitempty" xml:"logstore,omitempty"`
	// 是否启用powerSql
	//
	// example:
	//
	// false
	PowerSql *bool `json:"powerSql,omitempty" xml:"powerSql,omitempty"`
	// 查询语句
	//
	// example:
	//
	// 	- | select *
	Query *string `json:"query,omitempty" xml:"query,omitempty"`
	// 导出配置
	Sink *GetDownloadJobResponseBodyConfigurationSink `json:"sink,omitempty" xml:"sink,omitempty" type:"Struct"`
	// 结束时间戳（精确到秒）
	//
	// example:
	//
	// 1722411060
	ToTime *int64 `json:"toTime,omitempty" xml:"toTime,omitempty"`
}

func (s GetDownloadJobResponseBodyConfiguration) String() string {
	return tea.Prettify(s)
}

func (s GetDownloadJobResponseBodyConfiguration) GoString() string {
	return s.String()
}

func (s *GetDownloadJobResponseBodyConfiguration) SetAllowInComplete(v bool) *GetDownloadJobResponseBodyConfiguration {
	s.AllowInComplete = &v
	return s
}

func (s *GetDownloadJobResponseBodyConfiguration) SetFromTime(v int64) *GetDownloadJobResponseBodyConfiguration {
	s.FromTime = &v
	return s
}

func (s *GetDownloadJobResponseBodyConfiguration) SetLogstore(v string) *GetDownloadJobResponseBodyConfiguration {
	s.Logstore = &v
	return s
}

func (s *GetDownloadJobResponseBodyConfiguration) SetPowerSql(v bool) *GetDownloadJobResponseBodyConfiguration {
	s.PowerSql = &v
	return s
}

func (s *GetDownloadJobResponseBodyConfiguration) SetQuery(v string) *GetDownloadJobResponseBodyConfiguration {
	s.Query = &v
	return s
}

func (s *GetDownloadJobResponseBodyConfiguration) SetSink(v *GetDownloadJobResponseBodyConfigurationSink) *GetDownloadJobResponseBodyConfiguration {
	s.Sink = v
	return s
}

func (s *GetDownloadJobResponseBodyConfiguration) SetToTime(v int64) *GetDownloadJobResponseBodyConfiguration {
	s.ToTime = &v
	return s
}

type GetDownloadJobResponseBodyConfigurationSink struct {
	// 对象存储桶
	//
	// example:
	//
	// ali-test-oss-bucket
	Bucket *string `json:"bucket,omitempty" xml:"bucket,omitempty"`
	// 压缩格式
	//
	// example:
	//
	// none
	CompressionType *string `json:"compressionType,omitempty" xml:"compressionType,omitempty"`
	// 下载文件格式
	//
	// example:
	//
	// csv
	ContentType *string `json:"contentType,omitempty" xml:"contentType,omitempty"`
	// example:
	//
	// download/
	Prefix *string `json:"prefix,omitempty" xml:"prefix,omitempty"`
	// 下载使用roleArn
	//
	// example:
	//
	// acs:ram::0123456789:role/aliyunlogdefaultrole
	RoleArn *string `json:"roleArn,omitempty" xml:"roleArn,omitempty"`
	// example:
	//
	// AliyunOSS
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s GetDownloadJobResponseBodyConfigurationSink) String() string {
	return tea.Prettify(s)
}

func (s GetDownloadJobResponseBodyConfigurationSink) GoString() string {
	return s.String()
}

func (s *GetDownloadJobResponseBodyConfigurationSink) SetBucket(v string) *GetDownloadJobResponseBodyConfigurationSink {
	s.Bucket = &v
	return s
}

func (s *GetDownloadJobResponseBodyConfigurationSink) SetCompressionType(v string) *GetDownloadJobResponseBodyConfigurationSink {
	s.CompressionType = &v
	return s
}

func (s *GetDownloadJobResponseBodyConfigurationSink) SetContentType(v string) *GetDownloadJobResponseBodyConfigurationSink {
	s.ContentType = &v
	return s
}

func (s *GetDownloadJobResponseBodyConfigurationSink) SetPrefix(v string) *GetDownloadJobResponseBodyConfigurationSink {
	s.Prefix = &v
	return s
}

func (s *GetDownloadJobResponseBodyConfigurationSink) SetRoleArn(v string) *GetDownloadJobResponseBodyConfigurationSink {
	s.RoleArn = &v
	return s
}

func (s *GetDownloadJobResponseBodyConfigurationSink) SetType(v string) *GetDownloadJobResponseBodyConfigurationSink {
	s.Type = &v
	return s
}

type GetDownloadJobResponseBodyExecutionDetails struct {
	// example:
	//
	// EXSFGSDASDASDG123ASD
	CheckSum *string `json:"checkSum,omitempty" xml:"checkSum,omitempty"`
	// 下载错误信息
	//
	// example:
	//
	// timeout
	ErrorMessage *string `json:"errorMessage,omitempty" xml:"errorMessage,omitempty"`
	// 下载执行时间
	//
	// example:
	//
	// 123
	ExecuteTime *int64 `json:"executeTime,omitempty" xml:"executeTime,omitempty"`
	// 下载结果链接
	//
	// example:
	//
	// https://xxx.csv.zst?xxx
	FilePath *string `json:"filePath,omitempty" xml:"filePath,omitempty"`
	// 下载文件大小
	//
	// example:
	//
	// 123456
	FileSize *int64 `json:"fileSize,omitempty" xml:"fileSize,omitempty"`
	// 下载日志条数
	//
	// example:
	//
	// 123
	LogCount *int64  `json:"logCount,omitempty" xml:"logCount,omitempty"`
	Notice   *string `json:"notice,omitempty" xml:"notice,omitempty"`
	// 下载进度
	//
	// example:
	//
	// 100
	Progress *int64 `json:"progress,omitempty" xml:"progress,omitempty"`
}

func (s GetDownloadJobResponseBodyExecutionDetails) String() string {
	return tea.Prettify(s)
}

func (s GetDownloadJobResponseBodyExecutionDetails) GoString() string {
	return s.String()
}

func (s *GetDownloadJobResponseBodyExecutionDetails) SetCheckSum(v string) *GetDownloadJobResponseBodyExecutionDetails {
	s.CheckSum = &v
	return s
}

func (s *GetDownloadJobResponseBodyExecutionDetails) SetErrorMessage(v string) *GetDownloadJobResponseBodyExecutionDetails {
	s.ErrorMessage = &v
	return s
}

func (s *GetDownloadJobResponseBodyExecutionDetails) SetExecuteTime(v int64) *GetDownloadJobResponseBodyExecutionDetails {
	s.ExecuteTime = &v
	return s
}

func (s *GetDownloadJobResponseBodyExecutionDetails) SetFilePath(v string) *GetDownloadJobResponseBodyExecutionDetails {
	s.FilePath = &v
	return s
}

func (s *GetDownloadJobResponseBodyExecutionDetails) SetFileSize(v int64) *GetDownloadJobResponseBodyExecutionDetails {
	s.FileSize = &v
	return s
}

func (s *GetDownloadJobResponseBodyExecutionDetails) SetLogCount(v int64) *GetDownloadJobResponseBodyExecutionDetails {
	s.LogCount = &v
	return s
}

func (s *GetDownloadJobResponseBodyExecutionDetails) SetNotice(v string) *GetDownloadJobResponseBodyExecutionDetails {
	s.Notice = &v
	return s
}

func (s *GetDownloadJobResponseBodyExecutionDetails) SetProgress(v int64) *GetDownloadJobResponseBodyExecutionDetails {
	s.Progress = &v
	return s
}

type GetDownloadJobResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetDownloadJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetDownloadJobResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDownloadJobResponse) GoString() string {
	return s.String()
}

func (s *GetDownloadJobResponse) SetHeaders(v map[string]*string) *GetDownloadJobResponse {
	s.Headers = v
	return s
}

func (s *GetDownloadJobResponse) SetStatusCode(v int32) *GetDownloadJobResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDownloadJobResponse) SetBody(v *GetDownloadJobResponseBody) *GetDownloadJobResponse {
	s.Body = v
	return s
}

type GetETLResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ETL               `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetETLResponse) String() string {
	return tea.Prettify(s)
}

func (s GetETLResponse) GoString() string {
	return s.String()
}

func (s *GetETLResponse) SetHeaders(v map[string]*string) *GetETLResponse {
	s.Headers = v
	return s
}

func (s *GetETLResponse) SetStatusCode(v int32) *GetETLResponse {
	s.StatusCode = &v
	return s
}

func (s *GetETLResponse) SetBody(v *ETL) *GetETLResponse {
	s.Body = v
	return s
}

type GetExternalStoreResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ExternalStore     `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetExternalStoreResponse) String() string {
	return tea.Prettify(s)
}

func (s GetExternalStoreResponse) GoString() string {
	return s.String()
}

func (s *GetExternalStoreResponse) SetHeaders(v map[string]*string) *GetExternalStoreResponse {
	s.Headers = v
	return s
}

func (s *GetExternalStoreResponse) SetStatusCode(v int32) *GetExternalStoreResponse {
	s.StatusCode = &v
	return s
}

func (s *GetExternalStoreResponse) SetBody(v *ExternalStore) *GetExternalStoreResponse {
	s.Body = v
	return s
}

type GetHistogramsRequest struct {
	// The start time of the subinterval. The value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1409529600
	From *int64 `json:"from,omitempty" xml:"from,omitempty"`
	// The search statement. Only search statements are supported. Analytic statements are not supported. For more information about the syntax of search statements, see [Log search overview](https://help.aliyun.com/document_detail/43772.html).
	//
	// example:
	//
	// with_pack_meta
	Query *string `json:"query,omitempty" xml:"query,omitempty"`
	// The end time of the subinterval. The value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1409569200
	To *int64 `json:"to,omitempty" xml:"to,omitempty"`
	// The topic of the logs.
	//
	// example:
	//
	// topic
	Topic *string `json:"topic,omitempty" xml:"topic,omitempty"`
}

func (s GetHistogramsRequest) String() string {
	return tea.Prettify(s)
}

func (s GetHistogramsRequest) GoString() string {
	return s.String()
}

func (s *GetHistogramsRequest) SetFrom(v int64) *GetHistogramsRequest {
	s.From = &v
	return s
}

func (s *GetHistogramsRequest) SetQuery(v string) *GetHistogramsRequest {
	s.Query = &v
	return s
}

func (s *GetHistogramsRequest) SetTo(v int64) *GetHistogramsRequest {
	s.To = &v
	return s
}

func (s *GetHistogramsRequest) SetTopic(v string) *GetHistogramsRequest {
	s.Topic = &v
	return s
}

type GetHistogramsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       []*GetHistogramsResponseBody `json:"body,omitempty" xml:"body,omitempty" type:"Repeated"`
}

func (s GetHistogramsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetHistogramsResponse) GoString() string {
	return s.String()
}

func (s *GetHistogramsResponse) SetHeaders(v map[string]*string) *GetHistogramsResponse {
	s.Headers = v
	return s
}

func (s *GetHistogramsResponse) SetStatusCode(v int32) *GetHistogramsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetHistogramsResponse) SetBody(v []*GetHistogramsResponseBody) *GetHistogramsResponse {
	s.Body = v
	return s
}

type GetHistogramsResponseBody struct {
	// The start time of the subinterval. The value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	//
	// The time range that is specified in this operation is a left-closed, right-open interval. The interval includes the start time specified by the from parameter, but does not include the end time specified by the to parameter. If you specify the same value for the from and to parameters, the interval is invalid, and an error message is returned.
	//
	// example:
	//
	// 1409529600
	From *int64 `json:"from,omitempty" xml:"from,omitempty"`
	// The end time of the subinterval. The value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	//
	// The time range that is specified in this operation is a left-closed, right-open interval. The interval includes the start time specified by the from parameter, but does not include the end time specified by the to parameter. If you specify the same value for the from and to parameters, the interval is invalid, and an error message is returned.
	//
	// example:
	//
	// 1409569200
	To *int64 `json:"to,omitempty" xml:"to,omitempty"`
	// The number of logs that are generated within the subinterval.
	//
	// example:
	//
	// 2
	Count *int64 `json:"count,omitempty" xml:"count,omitempty"`
	// Indicates whether the query and analysis results in the subinterval is complete. Valid values:
	//
	// Complete: The query is successful, and the complete query and analysis results are returned.
	//
	// Incomplete: The query is successful, but the query and analysis results are incomplete. To obtain the complete results, you must repeat the request.
	//
	// example:
	//
	// Complete
	Progress *string `json:"progress,omitempty" xml:"progress,omitempty"`
}

func (s GetHistogramsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetHistogramsResponseBody) GoString() string {
	return s.String()
}

func (s *GetHistogramsResponseBody) SetFrom(v int64) *GetHistogramsResponseBody {
	s.From = &v
	return s
}

func (s *GetHistogramsResponseBody) SetTo(v int64) *GetHistogramsResponseBody {
	s.To = &v
	return s
}

func (s *GetHistogramsResponseBody) SetCount(v int64) *GetHistogramsResponseBody {
	s.Count = &v
	return s
}

func (s *GetHistogramsResponseBody) SetProgress(v string) *GetHistogramsResponseBody {
	s.Progress = &v
	return s
}

type GetIndexResponseBody struct {
	// The type of the index.
	//
	// example:
	//
	// v2
	IndexMode *string `json:"index_mode,omitempty" xml:"index_mode,omitempty"`
	// The configurations of field indexes. A field index is in the key-value format in which the key specifies the name of the field and the value specifies the index configuration of the field.
	Keys map[string]*IndexKey `json:"keys,omitempty" xml:"keys,omitempty"`
	// The time when the index configurations were last updated. The value is a UNIX timestamp representing the number of seconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	//
	// example:
	//
	// 1524155379
	LastModifyTime *int64 `json:"lastModifyTime,omitempty" xml:"lastModifyTime,omitempty"`
	// The configurations of full-text indexes.
	Line *GetIndexResponseBodyLine `json:"line,omitempty" xml:"line,omitempty" type:"Struct"`
	// Indicates whether the log clustering feature is enabled.
	//
	// example:
	//
	// false
	LogReduce *bool `json:"log_reduce,omitempty" xml:"log_reduce,omitempty"`
	// The fields in the blacklist that are used to cluster logs. This parameter is valid only if the log clustering feature is enabled.
	LogReduceBlackList []*string `json:"log_reduce_black_list,omitempty" xml:"log_reduce_black_list,omitempty" type:"Repeated"`
	// The fields in the whitelist that are used to cluster logs. This parameter is valid only if the log clustering feature is enabled.
	LogReduceWhiteList []*string `json:"log_reduce_white_list,omitempty" xml:"log_reduce_white_list,omitempty" type:"Repeated"`
	// The maximum length of a field value that can be retained. Default value: 2048. Unit: bytes. The default value is equal to 2 KB. You can change the value of the max_text_len parameter. Valid values: 64 to 16384. Unit: bytes.
	//
	// example:
	//
	// 2048
	MaxTextLen *int32 `json:"max_text_len,omitempty" xml:"max_text_len,omitempty"`
	// The storage type. The value is fixed as pg.
	//
	// example:
	//
	// pg
	Storage *string `json:"storage,omitempty" xml:"storage,omitempty"`
	// The lifecycle of the index file. Valid values: 7, 30, and 90. Unit: day.
	//
	// This parameter is required.
	//
	// example:
	//
	// 30
	Ttl *int32 `json:"ttl,omitempty" xml:"ttl,omitempty"`
}

func (s GetIndexResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetIndexResponseBody) GoString() string {
	return s.String()
}

func (s *GetIndexResponseBody) SetIndexMode(v string) *GetIndexResponseBody {
	s.IndexMode = &v
	return s
}

func (s *GetIndexResponseBody) SetKeys(v map[string]*IndexKey) *GetIndexResponseBody {
	s.Keys = v
	return s
}

func (s *GetIndexResponseBody) SetLastModifyTime(v int64) *GetIndexResponseBody {
	s.LastModifyTime = &v
	return s
}

func (s *GetIndexResponseBody) SetLine(v *GetIndexResponseBodyLine) *GetIndexResponseBody {
	s.Line = v
	return s
}

func (s *GetIndexResponseBody) SetLogReduce(v bool) *GetIndexResponseBody {
	s.LogReduce = &v
	return s
}

func (s *GetIndexResponseBody) SetLogReduceBlackList(v []*string) *GetIndexResponseBody {
	s.LogReduceBlackList = v
	return s
}

func (s *GetIndexResponseBody) SetLogReduceWhiteList(v []*string) *GetIndexResponseBody {
	s.LogReduceWhiteList = v
	return s
}

func (s *GetIndexResponseBody) SetMaxTextLen(v int32) *GetIndexResponseBody {
	s.MaxTextLen = &v
	return s
}

func (s *GetIndexResponseBody) SetStorage(v string) *GetIndexResponseBody {
	s.Storage = &v
	return s
}

func (s *GetIndexResponseBody) SetTtl(v int32) *GetIndexResponseBody {
	s.Ttl = &v
	return s
}

type GetIndexResponseBodyLine struct {
	// Indicates whether case sensitivity is enabled. Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// false
	CaseSensitive *bool `json:"caseSensitive,omitempty" xml:"caseSensitive,omitempty"`
	// Indicates whether Chinese characters are included. Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// false
	Chn *bool `json:"chn,omitempty" xml:"chn,omitempty"`
	// The excluded fields.
	ExcludeKeys []*string `json:"exclude_keys,omitempty" xml:"exclude_keys,omitempty" type:"Repeated"`
	// The included fields.
	IncludeKeys []*string `json:"include_keys,omitempty" xml:"include_keys,omitempty" type:"Repeated"`
	// The delimiters.
	//
	// This parameter is required.
	Token []*string `json:"token,omitempty" xml:"token,omitempty" type:"Repeated"`
}

func (s GetIndexResponseBodyLine) String() string {
	return tea.Prettify(s)
}

func (s GetIndexResponseBodyLine) GoString() string {
	return s.String()
}

func (s *GetIndexResponseBodyLine) SetCaseSensitive(v bool) *GetIndexResponseBodyLine {
	s.CaseSensitive = &v
	return s
}

func (s *GetIndexResponseBodyLine) SetChn(v bool) *GetIndexResponseBodyLine {
	s.Chn = &v
	return s
}

func (s *GetIndexResponseBodyLine) SetExcludeKeys(v []*string) *GetIndexResponseBodyLine {
	s.ExcludeKeys = v
	return s
}

func (s *GetIndexResponseBodyLine) SetIncludeKeys(v []*string) *GetIndexResponseBodyLine {
	s.IncludeKeys = v
	return s
}

func (s *GetIndexResponseBodyLine) SetToken(v []*string) *GetIndexResponseBodyLine {
	s.Token = v
	return s
}

type GetIndexResponse struct {
	Headers    map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetIndexResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetIndexResponse) String() string {
	return tea.Prettify(s)
}

func (s GetIndexResponse) GoString() string {
	return s.String()
}

func (s *GetIndexResponse) SetHeaders(v map[string]*string) *GetIndexResponse {
	s.Headers = v
	return s
}

func (s *GetIndexResponse) SetStatusCode(v int32) *GetIndexResponse {
	s.StatusCode = &v
	return s
}

func (s *GetIndexResponse) SetBody(v *GetIndexResponseBody) *GetIndexResponse {
	s.Body = v
	return s
}

type GetIngestProcessorResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *IngestProcessor   `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetIngestProcessorResponse) String() string {
	return tea.Prettify(s)
}

func (s GetIngestProcessorResponse) GoString() string {
	return s.String()
}

func (s *GetIngestProcessorResponse) SetHeaders(v map[string]*string) *GetIngestProcessorResponse {
	s.Headers = v
	return s
}

func (s *GetIngestProcessorResponse) SetStatusCode(v int32) *GetIngestProcessorResponse {
	s.StatusCode = &v
	return s
}

func (s *GetIngestProcessorResponse) SetBody(v *IngestProcessor) *GetIngestProcessorResponse {
	s.Body = v
	return s
}

type GetLogStoreResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *Logstore          `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetLogStoreResponse) String() string {
	return tea.Prettify(s)
}

func (s GetLogStoreResponse) GoString() string {
	return s.String()
}

func (s *GetLogStoreResponse) SetHeaders(v map[string]*string) *GetLogStoreResponse {
	s.Headers = v
	return s
}

func (s *GetLogStoreResponse) SetStatusCode(v int32) *GetLogStoreResponse {
	s.StatusCode = &v
	return s
}

func (s *GetLogStoreResponse) SetBody(v *Logstore) *GetLogStoreResponse {
	s.Body = v
	return s
}

type GetLogStoreMeteringModeResponseBody struct {
	// The billing mode. Default value: ChargeByFunction. Valid values: ChargeByFunction and ChargeByDataIngest.
	//
	// example:
	//
	// ChargeByFunction
	MeteringMode *string `json:"meteringMode,omitempty" xml:"meteringMode,omitempty"`
}

func (s GetLogStoreMeteringModeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetLogStoreMeteringModeResponseBody) GoString() string {
	return s.String()
}

func (s *GetLogStoreMeteringModeResponseBody) SetMeteringMode(v string) *GetLogStoreMeteringModeResponseBody {
	s.MeteringMode = &v
	return s
}

type GetLogStoreMeteringModeResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetLogStoreMeteringModeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetLogStoreMeteringModeResponse) String() string {
	return tea.Prettify(s)
}

func (s GetLogStoreMeteringModeResponse) GoString() string {
	return s.String()
}

func (s *GetLogStoreMeteringModeResponse) SetHeaders(v map[string]*string) *GetLogStoreMeteringModeResponse {
	s.Headers = v
	return s
}

func (s *GetLogStoreMeteringModeResponse) SetStatusCode(v int32) *GetLogStoreMeteringModeResponse {
	s.StatusCode = &v
	return s
}

func (s *GetLogStoreMeteringModeResponse) SetBody(v *GetLogStoreMeteringModeResponseBody) *GetLogStoreMeteringModeResponse {
	s.Body = v
	return s
}

type GetLoggingResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *Logging           `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetLoggingResponse) String() string {
	return tea.Prettify(s)
}

func (s GetLoggingResponse) GoString() string {
	return s.String()
}

func (s *GetLoggingResponse) SetHeaders(v map[string]*string) *GetLoggingResponse {
	s.Headers = v
	return s
}

func (s *GetLoggingResponse) SetStatusCode(v int32) *GetLoggingResponse {
	s.StatusCode = &v
	return s
}

func (s *GetLoggingResponse) SetBody(v *Logging) *GetLoggingResponse {
	s.Body = v
	return s
}

type GetLogsRequest struct {
	// The beginning of the time range to query. The value is the log time that is specified when log data is written.
	//
	// 	- The time range that is specified in this operation is a left-closed, right-open interval. The interval includes the start time specified by the **from*	- parameter, but does not include the end time specified by the **to*	- parameter. If you specify the same value for the **from*	- and **to*	- parameters, the interval is invalid, and an error message is returned.
	//
	// 	- The value is a UNIX timestamp representing the number of seconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	//
	// > To ensure that full data can be queried, specify a query time range that is accurate to the minute. If you also specify a time range in an analytic statement, Simple Log Service uses the time range specified in the analytic statement for query and analysis.
	//
	// If you want to specify a time range that is accurate to the second in your analytic statement, you must use the from_unixtime or to_unixtime function to convert the time format. For more information about the functions, see [from_unixtime function](https://help.aliyun.com/document_detail/63451.html) and [to_unixtime function](https://help.aliyun.com/document_detail/63451.html). Examples:
	//
	// 	- `	- | SELECT 	- FROM log WHERE from_unixtime(__time__) > from_unixtime(1664186624) AND from_unixtime(__time__) < now()`
	//
	// 	- `	- | SELECT 	- FROM log WHERE __time__ > to_unixtime(date_parse(\\"2022-10-19 15:46:05\\", \\"%Y-%m-%d %H:%i:%s\\")) AND __time__ < to_unixtime(now())`
	//
	// This parameter is required.
	//
	// example:
	//
	// 1627268185
	From *int32 `json:"from,omitempty" xml:"from,omitempty"`
	// The maximum number of logs to return for the request. This parameter takes effect only when the query parameter is set to a search statement. Minimum value: 0. Maximum value: 100. Default value: 100. For more information, see [Perform paged queries](https://help.aliyun.com/document_detail/89994.html).
	//
	// example:
	//
	// 100
	Line *int64 `json:"line,omitempty" xml:"line,omitempty"`
	// The line from which the query starts. This parameter takes effect only when the query parameter is set to a search statement. Default value: 0. For more information, see [Perform paged queries](https://help.aliyun.com/document_detail/89994.html).
	//
	// example:
	//
	// 0
	Offset *int64 `json:"offset,omitempty" xml:"offset,omitempty"`
	// Specifies whether to enable the Dedicated SQL feature. For more information, see [Enable Dedicated SQL](https://help.aliyun.com/document_detail/223777.html). Valid values:
	//
	// 	- true: enables the Dedicated SQL feature.
	//
	// 	- false (default): enables the Standard SQL feature.
	//
	// You can use the powerSql or **query*	- parameter to configure Dedicated SQL.
	//
	// example:
	//
	// false
	PowerSql *bool `json:"powerSql,omitempty" xml:"powerSql,omitempty"`
	// The search statement or the query statement. For more information, see [Log search overview](https://help.aliyun.com/document_detail/43772.html) and [Log analysis overview](https://help.aliyun.com/document_detail/53608.html). If you add `set session parallel_sql=true;` to the analytic statement in the query parameter, Dedicated SQL is used. For example, you can set the query parameter to `	- | set session parallel_sql=true; select count(*) as pv`. For more information about common errors that may occur during log query and analysis, see [How do I resolve common errors that occur when I query and analyze logs?](https://help.aliyun.com/document_detail/61628.html)
	//
	// > If you specify an analytic statement in the value of the query parameter, the line and offset parameters do not take effect. In this case, we recommend that you set the line and offset parameters to 0 and use the LIMIT clause to limit the number of logs to return on each page. For more information, see [Paged query](https://help.aliyun.com/document_detail/89994.html).
	//
	// example:
	//
	// status: 401 | SELECT remote_addr,COUNT(*) as pv GROUP by remote_addr ORDER by pv desc limit 5
	Query *string `json:"query,omitempty" xml:"query,omitempty"`
	// Specifies whether to return logs in reverse chronological order of log timestamps. The log timestamps are accurate to the minute. Valid values:
	//
	// 	- true: returns logs in reverse chronological order of log timestamps.
	//
	// 	- false (default): returns logs in chronological order of log timestamps.
	//
	// >
	//
	// 	- The reverse parameter takes effect only when the query parameter is set to a search statement. The reverse parameter specifies the method used to sort returned logs.
	//
	// 	- If the query parameter is set to a query statement, the reverse parameter does not take effect. The method used to sort returned logs is specified by the ORDER BY clause in the analytic statement. If you use the keyword asc in the ORDER BY clause, the logs are sorted in chronological order. If you use the keyword desc in the ORDER BY clause, the logs are sorted in reverse chronological order. By default, asc is used in the ORDER BY clause.
	//
	// example:
	//
	// false
	Reverse *bool `json:"reverse,omitempty" xml:"reverse,omitempty"`
	// The end of the time range to query. The value is the log time that is specified when log data is written.
	//
	// 	- The time range that is specified in this operation is a left-closed, right-open interval. The interval includes the start time specified by the **from*	- parameter, but does not include the end time specified by the **to*	- parameter. If you specify the same value for the **from*	- and **to*	- parameters, the interval is invalid, and an error message is returned.
	//
	// 	- The value is a UNIX timestamp representing the number of seconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	//
	// > To ensure that full data can be queried, specify a query time range that is accurate to the minute. If you also specify a time range in an analytic statement, Simple Log Service uses the time range specified in the analytic statement for query and analysis.
	//
	// If you want to specify a time range that is accurate to the second in your analytic statement, you must use the from_unixtime or to_unixtime function to convert the time format. For more information about the functions, see [from_unixtime function](https://help.aliyun.com/document_detail/63451.html) and [to_unixtime function](https://help.aliyun.com/document_detail/63451.html). Examples:
	//
	// 	- `	- | SELECT 	- FROM log WHERE from_unixtime(__time__) > from_unixtime(1664186624) AND from_unixtime(__time__) < now()`
	//
	// 	- `	- | SELECT 	- FROM log WHERE __time__ > to_unixtime(date_parse(\\"2022-10-19 15:46:05\\", \\"%Y-%m-%d %H:%i:%s\\")) AND __time__ < to_unixtime(now())`
	//
	// This parameter is required.
	//
	// example:
	//
	// 1627269085
	To *int32 `json:"to,omitempty" xml:"to,omitempty"`
	// The topic of the logs. The default value is an empty string. For more information, see [Topic](https://help.aliyun.com/document_detail/48881.html).
	//
	// example:
	//
	// topic
	Topic *string `json:"topic,omitempty" xml:"topic,omitempty"`
}

func (s GetLogsRequest) String() string {
	return tea.Prettify(s)
}

func (s GetLogsRequest) GoString() string {
	return s.String()
}

func (s *GetLogsRequest) SetFrom(v int32) *GetLogsRequest {
	s.From = &v
	return s
}

func (s *GetLogsRequest) SetLine(v int64) *GetLogsRequest {
	s.Line = &v
	return s
}

func (s *GetLogsRequest) SetOffset(v int64) *GetLogsRequest {
	s.Offset = &v
	return s
}

func (s *GetLogsRequest) SetPowerSql(v bool) *GetLogsRequest {
	s.PowerSql = &v
	return s
}

func (s *GetLogsRequest) SetQuery(v string) *GetLogsRequest {
	s.Query = &v
	return s
}

func (s *GetLogsRequest) SetReverse(v bool) *GetLogsRequest {
	s.Reverse = &v
	return s
}

func (s *GetLogsRequest) SetTo(v int32) *GetLogsRequest {
	s.To = &v
	return s
}

func (s *GetLogsRequest) SetTopic(v string) *GetLogsRequest {
	s.Topic = &v
	return s
}

type GetLogsResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       []map[string]interface{} `json:"body,omitempty" xml:"body,omitempty" type:"Repeated"`
}

func (s GetLogsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetLogsResponse) GoString() string {
	return s.String()
}

func (s *GetLogsResponse) SetHeaders(v map[string]*string) *GetLogsResponse {
	s.Headers = v
	return s
}

func (s *GetLogsResponse) SetStatusCode(v int32) *GetLogsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetLogsResponse) SetBody(v []map[string]interface{}) *GetLogsResponse {
	s.Body = v
	return s
}

type GetLogsV2Headers struct {
	CommonHeaders map[string]*string `json:"commonHeaders,omitempty" xml:"commonHeaders,omitempty"`
	// The compression format.
	//
	// 	- For Java, Python, and Go, only the lz4 and gzip algorithms are supported for decompression.
	//
	// 	- For PHP, JavaScript, and C#, only the gzip algorithm is supported for decompression.
	//
	// This parameter is required.
	//
	// example:
	//
	// lz4
	AcceptEncoding *string `json:"Accept-Encoding,omitempty" xml:"Accept-Encoding,omitempty"`
}

func (s GetLogsV2Headers) String() string {
	return tea.Prettify(s)
}

func (s GetLogsV2Headers) GoString() string {
	return s.String()
}

func (s *GetLogsV2Headers) SetCommonHeaders(v map[string]*string) *GetLogsV2Headers {
	s.CommonHeaders = v
	return s
}

func (s *GetLogsV2Headers) SetAcceptEncoding(v string) *GetLogsV2Headers {
	s.AcceptEncoding = &v
	return s
}

type GetLogsV2Request struct {
	// Specifies whether to page forward or backward for the scan-based query or phrase search.
	//
	// example:
	//
	// false
	Forward *bool `json:"forward,omitempty" xml:"forward,omitempty"`
	// The beginning of the time range to query. The value is the log time that is specified when log data is written.
	//
	// The time range that is specified in this operation is a left-closed, right-open interval. The interval includes the start time specified by the from parameter, but does not include the end time specified by the to parameter. If you specify the same value for the from and to parameters, the interval is invalid, and an error message is returned. The value is a timestamp that follows the UNIX time format. It is the number of seconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1627268185
	From *int32 `json:"from,omitempty" xml:"from,omitempty"`
	// Specifies whether to highlight the returned result.
	//
	// example:
	//
	// false
	Highlight *bool `json:"highlight,omitempty" xml:"highlight,omitempty"`
	// The maximum number of logs to return for the request. This parameter takes effect only when the query parameter is set to a search statement. Valid values: 0 to 100. Default value: 100.
	//
	// example:
	//
	// 100
	Line *int64 `json:"line,omitempty" xml:"line,omitempty"`
	// The line from which the query starts. This parameter takes effect only when the query parameter is set to a search statement. Default value: 0.
	//
	// example:
	//
	// 0
	Offset *int64 `json:"offset,omitempty" xml:"offset,omitempty"`
	// Specifies whether to enable the SQL enhancement feature. By default, the feature is disabled.
	//
	// example:
	//
	// false
	PowerSql *bool `json:"powerSql,omitempty" xml:"powerSql,omitempty"`
	// The search statement or query statement. For more information, see the "Log search overview" and "Log analysis overview" topics.
	//
	// If you add set session parallel_sql=true; to the analytic statement in the query parameter, Dedicated SQL is used. Example: \\	- | set session parallel_sql=true; select count(\\*) as pv.
	//
	// Note: If you specify an analytic statement in the query parameter, the line and offset parameters do not take effect in this operation. In this case, we recommend that you set the line and offset parameters to 0 and use the LIMIT clause to specify the number of logs to return on each page. For more information, see the "Perform paged queries" topic.
	//
	// example:
	//
	// status: 401 | SELECT remote_addr,COUNT(*) as pv GROUP by remote_addr ORDER by pv desc limit 5
	Query *string `json:"query,omitempty" xml:"query,omitempty"`
	// Specifies whether to return logs in reverse chronological order of log timestamps. The log timestamps are accurate to minutes. Valid values:
	//
	// true: Logs are returned in reverse chronological order of log timestamps. false (default): Logs are returned in chronological order of log timestamps. Note: The reverse parameter takes effect only when the query parameter is set to a search statement. The reverse parameter specifies the method used to sort returned logs. If the query parameter is set to a query statement, the reverse parameter does not take effect. The method used to sort returned logs is specified by the ORDER BY clause in the analytic statement. If you use the keyword asc in the ORDER BY clause, the logs are sorted in chronological order. If you use the keyword desc in the ORDER BY clause, the logs are sorted in reverse chronological order. By default, asc is used in the ORDER BY clause.
	//
	// example:
	//
	// false
	Reverse *bool `json:"reverse,omitempty" xml:"reverse,omitempty"`
	// The parameter that is used to query data.
	//
	// example:
	//
	// mode=scan
	Session *string `json:"session,omitempty" xml:"session,omitempty"`
	// The end of the time range to query. The value is the log time that is specified when log data is written.
	//
	// The time range that is specified in this operation is a left-closed, right-open interval. The interval includes the start time specified by the from parameter, but does not include the end time specified by the to parameter. If you specify the same value for the from and to parameters, the interval is invalid, and an error message is returned. The value is a timestamp that follows the UNIX time format. It is the number of seconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1627268185
	To *int32 `json:"to,omitempty" xml:"to,omitempty"`
	// The topic of the logs. Default value: double quotation marks ("").
	//
	// example:
	//
	// ""
	Topic *string `json:"topic,omitempty" xml:"topic,omitempty"`
}

func (s GetLogsV2Request) String() string {
	return tea.Prettify(s)
}

func (s GetLogsV2Request) GoString() string {
	return s.String()
}

func (s *GetLogsV2Request) SetForward(v bool) *GetLogsV2Request {
	s.Forward = &v
	return s
}

func (s *GetLogsV2Request) SetFrom(v int32) *GetLogsV2Request {
	s.From = &v
	return s
}

func (s *GetLogsV2Request) SetHighlight(v bool) *GetLogsV2Request {
	s.Highlight = &v
	return s
}

func (s *GetLogsV2Request) SetLine(v int64) *GetLogsV2Request {
	s.Line = &v
	return s
}

func (s *GetLogsV2Request) SetOffset(v int64) *GetLogsV2Request {
	s.Offset = &v
	return s
}

func (s *GetLogsV2Request) SetPowerSql(v bool) *GetLogsV2Request {
	s.PowerSql = &v
	return s
}

func (s *GetLogsV2Request) SetQuery(v string) *GetLogsV2Request {
	s.Query = &v
	return s
}

func (s *GetLogsV2Request) SetReverse(v bool) *GetLogsV2Request {
	s.Reverse = &v
	return s
}

func (s *GetLogsV2Request) SetSession(v string) *GetLogsV2Request {
	s.Session = &v
	return s
}

func (s *GetLogsV2Request) SetTo(v int32) *GetLogsV2Request {
	s.To = &v
	return s
}

func (s *GetLogsV2Request) SetTopic(v string) *GetLogsV2Request {
	s.Topic = &v
	return s
}

type GetLogsV2ResponseBody struct {
	// The returned result.
	Data []map[string]*string `json:"data,omitempty" xml:"data,omitempty" type:"Repeated"`
	// The metadata of the returned data.
	Meta *GetLogsV2ResponseBodyMeta `json:"meta,omitempty" xml:"meta,omitempty" type:"Struct"`
}

func (s GetLogsV2ResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetLogsV2ResponseBody) GoString() string {
	return s.String()
}

func (s *GetLogsV2ResponseBody) SetData(v []map[string]*string) *GetLogsV2ResponseBody {
	s.Data = v
	return s
}

func (s *GetLogsV2ResponseBody) SetMeta(v *GetLogsV2ResponseBodyMeta) *GetLogsV2ResponseBody {
	s.Meta = v
	return s
}

type GetLogsV2ResponseBodyMeta struct {
	// The SQL statement after | in the query statement.
	//
	// example:
	//
	// select *
	AggQuery    *string   `json:"aggQuery,omitempty" xml:"aggQuery,omitempty"`
	ColumnTypes []*string `json:"columnTypes,omitempty" xml:"columnTypes,omitempty" type:"Repeated"`
	// The number of rows that are returned.
	//
	// example:
	//
	// 1
	Count *int32 `json:"count,omitempty" xml:"count,omitempty"`
	// example:
	//
	// 3
	CpuCores *int32 `json:"cpuCores,omitempty" xml:"cpuCores,omitempty"`
	// example:
	//
	// 0.002
	CpuSec *float64 `json:"cpuSec,omitempty" xml:"cpuSec,omitempty"`
	// The amount of time that is consumed by the request. Unit: milliseconds.
	//
	// example:
	//
	// 5
	ElapsedMillisecond *int64 `json:"elapsedMillisecond,omitempty" xml:"elapsedMillisecond,omitempty"`
	// Indicates whether the query is an SQL query.
	//
	// example:
	//
	// false
	HasSQL     *bool           `json:"hasSQL,omitempty" xml:"hasSQL,omitempty"`
	Highlights [][]*LogContent `json:"highlights,omitempty" xml:"highlights,omitempty" type:"Repeated"`
	// Indicates whether the returned result is accurate to seconds.
	//
	// example:
	//
	// true
	IsAccurate *bool `json:"isAccurate,omitempty" xml:"isAccurate,omitempty"`
	// All keys in the query result.
	Keys []*string `json:"keys,omitempty" xml:"keys,omitempty" type:"Repeated"`
	// example:
	//
	// 100
	Limited *int32 `json:"limited,omitempty" xml:"limited,omitempty"`
	// example:
	//
	// 0
	Mode            *int32                                    `json:"mode,omitempty" xml:"mode,omitempty"`
	PhraseQueryInfo *GetLogsV2ResponseBodyMetaPhraseQueryInfo `json:"phraseQueryInfo,omitempty" xml:"phraseQueryInfo,omitempty" type:"Struct"`
	// The number of logs that are processed in the request.
	//
	// example:
	//
	// 10000
	ProcessedBytes *int64 `json:"processedBytes,omitempty" xml:"processedBytes,omitempty"`
	// The number of rows that are processed in the request.
	//
	// example:
	//
	// 10000
	ProcessedRows *int64 `json:"processedRows,omitempty" xml:"processedRows,omitempty"`
	// Indicates whether the query result is complete. Valid values:
	//
	// 	- Complete: The query was successful, and the complete result is returned.
	//
	// 	- Incomplete: The query was successful, but the query result is incomplete. To obtain the complete result, you must call the operation again.
	//
	// example:
	//
	// Complete
	Progress *string `json:"progress,omitempty" xml:"progress,omitempty"`
	// example:
	//
	// 1024
	ScanBytes *int64 `json:"scanBytes,omitempty" xml:"scanBytes,omitempty"`
	// The type of observable data.
	//
	// example:
	//
	// None
	TelementryType *string `json:"telementryType,omitempty" xml:"telementryType,omitempty"`
	// All terms in the query statement.
	Terms []map[string]interface{} `json:"terms,omitempty" xml:"terms,omitempty" type:"Repeated"`
	// The part before | in the query statement.
	//
	// example:
	//
	// *
	WhereQuery *string `json:"whereQuery,omitempty" xml:"whereQuery,omitempty"`
}

func (s GetLogsV2ResponseBodyMeta) String() string {
	return tea.Prettify(s)
}

func (s GetLogsV2ResponseBodyMeta) GoString() string {
	return s.String()
}

func (s *GetLogsV2ResponseBodyMeta) SetAggQuery(v string) *GetLogsV2ResponseBodyMeta {
	s.AggQuery = &v
	return s
}

func (s *GetLogsV2ResponseBodyMeta) SetColumnTypes(v []*string) *GetLogsV2ResponseBodyMeta {
	s.ColumnTypes = v
	return s
}

func (s *GetLogsV2ResponseBodyMeta) SetCount(v int32) *GetLogsV2ResponseBodyMeta {
	s.Count = &v
	return s
}

func (s *GetLogsV2ResponseBodyMeta) SetCpuCores(v int32) *GetLogsV2ResponseBodyMeta {
	s.CpuCores = &v
	return s
}

func (s *GetLogsV2ResponseBodyMeta) SetCpuSec(v float64) *GetLogsV2ResponseBodyMeta {
	s.CpuSec = &v
	return s
}

func (s *GetLogsV2ResponseBodyMeta) SetElapsedMillisecond(v int64) *GetLogsV2ResponseBodyMeta {
	s.ElapsedMillisecond = &v
	return s
}

func (s *GetLogsV2ResponseBodyMeta) SetHasSQL(v bool) *GetLogsV2ResponseBodyMeta {
	s.HasSQL = &v
	return s
}

func (s *GetLogsV2ResponseBodyMeta) SetHighlights(v [][]*LogContent) *GetLogsV2ResponseBodyMeta {
	s.Highlights = v
	return s
}

func (s *GetLogsV2ResponseBodyMeta) SetIsAccurate(v bool) *GetLogsV2ResponseBodyMeta {
	s.IsAccurate = &v
	return s
}

func (s *GetLogsV2ResponseBodyMeta) SetKeys(v []*string) *GetLogsV2ResponseBodyMeta {
	s.Keys = v
	return s
}

func (s *GetLogsV2ResponseBodyMeta) SetLimited(v int32) *GetLogsV2ResponseBodyMeta {
	s.Limited = &v
	return s
}

func (s *GetLogsV2ResponseBodyMeta) SetMode(v int32) *GetLogsV2ResponseBodyMeta {
	s.Mode = &v
	return s
}

func (s *GetLogsV2ResponseBodyMeta) SetPhraseQueryInfo(v *GetLogsV2ResponseBodyMetaPhraseQueryInfo) *GetLogsV2ResponseBodyMeta {
	s.PhraseQueryInfo = v
	return s
}

func (s *GetLogsV2ResponseBodyMeta) SetProcessedBytes(v int64) *GetLogsV2ResponseBodyMeta {
	s.ProcessedBytes = &v
	return s
}

func (s *GetLogsV2ResponseBodyMeta) SetProcessedRows(v int64) *GetLogsV2ResponseBodyMeta {
	s.ProcessedRows = &v
	return s
}

func (s *GetLogsV2ResponseBodyMeta) SetProgress(v string) *GetLogsV2ResponseBodyMeta {
	s.Progress = &v
	return s
}

func (s *GetLogsV2ResponseBodyMeta) SetScanBytes(v int64) *GetLogsV2ResponseBodyMeta {
	s.ScanBytes = &v
	return s
}

func (s *GetLogsV2ResponseBodyMeta) SetTelementryType(v string) *GetLogsV2ResponseBodyMeta {
	s.TelementryType = &v
	return s
}

func (s *GetLogsV2ResponseBodyMeta) SetTerms(v []map[string]interface{}) *GetLogsV2ResponseBodyMeta {
	s.Terms = v
	return s
}

func (s *GetLogsV2ResponseBodyMeta) SetWhereQuery(v string) *GetLogsV2ResponseBodyMeta {
	s.WhereQuery = &v
	return s
}

type GetLogsV2ResponseBodyMetaPhraseQueryInfo struct {
	// example:
	//
	// 0
	BeginOffset *int64 `json:"beginOffset,omitempty" xml:"beginOffset,omitempty"`
	// example:
	//
	// 0
	EndOffset *int64 `json:"endOffset,omitempty" xml:"endOffset,omitempty"`
	// example:
	//
	// 1
	EndTime *int64 `json:"endTime,omitempty" xml:"endTime,omitempty"`
	// example:
	//
	// true
	ScanAll *bool `json:"scanAll,omitempty" xml:"scanAll,omitempty"`
}

func (s GetLogsV2ResponseBodyMetaPhraseQueryInfo) String() string {
	return tea.Prettify(s)
}

func (s GetLogsV2ResponseBodyMetaPhraseQueryInfo) GoString() string {
	return s.String()
}

func (s *GetLogsV2ResponseBodyMetaPhraseQueryInfo) SetBeginOffset(v int64) *GetLogsV2ResponseBodyMetaPhraseQueryInfo {
	s.BeginOffset = &v
	return s
}

func (s *GetLogsV2ResponseBodyMetaPhraseQueryInfo) SetEndOffset(v int64) *GetLogsV2ResponseBodyMetaPhraseQueryInfo {
	s.EndOffset = &v
	return s
}

func (s *GetLogsV2ResponseBodyMetaPhraseQueryInfo) SetEndTime(v int64) *GetLogsV2ResponseBodyMetaPhraseQueryInfo {
	s.EndTime = &v
	return s
}

func (s *GetLogsV2ResponseBodyMetaPhraseQueryInfo) SetScanAll(v bool) *GetLogsV2ResponseBodyMetaPhraseQueryInfo {
	s.ScanAll = &v
	return s
}

type GetLogsV2Response struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetLogsV2ResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetLogsV2Response) String() string {
	return tea.Prettify(s)
}

func (s GetLogsV2Response) GoString() string {
	return s.String()
}

func (s *GetLogsV2Response) SetHeaders(v map[string]*string) *GetLogsV2Response {
	s.Headers = v
	return s
}

func (s *GetLogsV2Response) SetStatusCode(v int32) *GetLogsV2Response {
	s.StatusCode = &v
	return s
}

func (s *GetLogsV2Response) SetBody(v *GetLogsV2ResponseBody) *GetLogsV2Response {
	s.Body = v
	return s
}

type GetLogtailPipelineConfigResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *LogtailPipelineConfig `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetLogtailPipelineConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s GetLogtailPipelineConfigResponse) GoString() string {
	return s.String()
}

func (s *GetLogtailPipelineConfigResponse) SetHeaders(v map[string]*string) *GetLogtailPipelineConfigResponse {
	s.Headers = v
	return s
}

func (s *GetLogtailPipelineConfigResponse) SetStatusCode(v int32) *GetLogtailPipelineConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *GetLogtailPipelineConfigResponse) SetBody(v *LogtailPipelineConfig) *GetLogtailPipelineConfigResponse {
	s.Body = v
	return s
}

type GetMLServiceResultsRequest struct {
	// example:
	//
	// true
	AllowBuiltin *bool                   `json:"allowBuiltin,omitempty" xml:"allowBuiltin,omitempty"`
	Body         *MLServiceAnalysisParam `json:"body,omitempty" xml:"body,omitempty"`
	// The version of the algorithm. The algorithm varies based on the version.
	//
	// example:
	//
	// v1
	Version *string `json:"version,omitempty" xml:"version,omitempty"`
}

func (s GetMLServiceResultsRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMLServiceResultsRequest) GoString() string {
	return s.String()
}

func (s *GetMLServiceResultsRequest) SetAllowBuiltin(v bool) *GetMLServiceResultsRequest {
	s.AllowBuiltin = &v
	return s
}

func (s *GetMLServiceResultsRequest) SetBody(v *MLServiceAnalysisParam) *GetMLServiceResultsRequest {
	s.Body = v
	return s
}

func (s *GetMLServiceResultsRequest) SetVersion(v string) *GetMLServiceResultsRequest {
	s.Version = &v
	return s
}

type GetMLServiceResultsResponseBody struct {
	Data   []map[string]*string `json:"data,omitempty" xml:"data,omitempty" type:"Repeated"`
	Status map[string]*string   `json:"status,omitempty" xml:"status,omitempty"`
}

func (s GetMLServiceResultsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMLServiceResultsResponseBody) GoString() string {
	return s.String()
}

func (s *GetMLServiceResultsResponseBody) SetData(v []map[string]*string) *GetMLServiceResultsResponseBody {
	s.Data = v
	return s
}

func (s *GetMLServiceResultsResponseBody) SetStatus(v map[string]*string) *GetMLServiceResultsResponseBody {
	s.Status = v
	return s
}

type GetMLServiceResultsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMLServiceResultsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMLServiceResultsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMLServiceResultsResponse) GoString() string {
	return s.String()
}

func (s *GetMLServiceResultsResponse) SetHeaders(v map[string]*string) *GetMLServiceResultsResponse {
	s.Headers = v
	return s
}

func (s *GetMLServiceResultsResponse) SetStatusCode(v int32) *GetMLServiceResultsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMLServiceResultsResponse) SetBody(v *GetMLServiceResultsResponseBody) *GetMLServiceResultsResponse {
	s.Body = v
	return s
}

type GetMachineGroupResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *MachineGroup      `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMachineGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMachineGroupResponse) GoString() string {
	return s.String()
}

func (s *GetMachineGroupResponse) SetHeaders(v map[string]*string) *GetMachineGroupResponse {
	s.Headers = v
	return s
}

func (s *GetMachineGroupResponse) SetStatusCode(v int32) *GetMachineGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMachineGroupResponse) SetBody(v *MachineGroup) *GetMachineGroupResponse {
	s.Body = v
	return s
}

type GetMetricStoreResponseBody struct {
	// Indicates whether the automatic sharding feature is enabled.
	//
	// example:
	//
	// true
	AutoSplit *bool `json:"autoSplit,omitempty" xml:"autoSplit,omitempty"`
	// The creation time. The value is a UNIX timestamp.
	//
	// example:
	//
	// 1698933894
	CreateTime          *int64 `json:"createTime,omitempty" xml:"createTime,omitempty"`
	HotTtl              *int32 `json:"hot_ttl,omitempty" xml:"hot_ttl,omitempty"`
	InfrequentAccessTTL *int32 `json:"infrequentAccessTTL,omitempty" xml:"infrequentAccessTTL,omitempty"`
	// The last update time. The value is a UNIX timestamp.
	//
	// example:
	//
	// 1712023974
	LastModifyTime *int64 `json:"lastModifyTime,omitempty" xml:"lastModifyTime,omitempty"`
	// The maximum number of shards into which existing shards can be automatically split.
	//
	// example:
	//
	// 64
	MaxSplitShard *int32 `json:"maxSplitShard,omitempty" xml:"maxSplitShard,omitempty"`
	// The metric type of the Metricstore. Example: prometheus.
	//
	// example:
	//
	// prometheus
	MetricType *string `json:"metricType,omitempty" xml:"metricType,omitempty"`
	// The specification type of the Metricstore. Example: standard.
	//
	// example:
	//
	// standard
	Mode *string `json:"mode,omitempty" xml:"mode,omitempty"`
	// The name of the Metricstore.
	//
	// example:
	//
	// my_metric_store
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The number of shards.
	//
	// example:
	//
	// 2
	ShardCount *int32 `json:"shardCount,omitempty" xml:"shardCount,omitempty"`
	// The retention period. Unit: days.
	//
	// example:
	//
	// 7
	Ttl *int32 `json:"ttl,omitempty" xml:"ttl,omitempty"`
}

func (s GetMetricStoreResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMetricStoreResponseBody) GoString() string {
	return s.String()
}

func (s *GetMetricStoreResponseBody) SetAutoSplit(v bool) *GetMetricStoreResponseBody {
	s.AutoSplit = &v
	return s
}

func (s *GetMetricStoreResponseBody) SetCreateTime(v int64) *GetMetricStoreResponseBody {
	s.CreateTime = &v
	return s
}

func (s *GetMetricStoreResponseBody) SetHotTtl(v int32) *GetMetricStoreResponseBody {
	s.HotTtl = &v
	return s
}

func (s *GetMetricStoreResponseBody) SetInfrequentAccessTTL(v int32) *GetMetricStoreResponseBody {
	s.InfrequentAccessTTL = &v
	return s
}

func (s *GetMetricStoreResponseBody) SetLastModifyTime(v int64) *GetMetricStoreResponseBody {
	s.LastModifyTime = &v
	return s
}

func (s *GetMetricStoreResponseBody) SetMaxSplitShard(v int32) *GetMetricStoreResponseBody {
	s.MaxSplitShard = &v
	return s
}

func (s *GetMetricStoreResponseBody) SetMetricType(v string) *GetMetricStoreResponseBody {
	s.MetricType = &v
	return s
}

func (s *GetMetricStoreResponseBody) SetMode(v string) *GetMetricStoreResponseBody {
	s.Mode = &v
	return s
}

func (s *GetMetricStoreResponseBody) SetName(v string) *GetMetricStoreResponseBody {
	s.Name = &v
	return s
}

func (s *GetMetricStoreResponseBody) SetShardCount(v int32) *GetMetricStoreResponseBody {
	s.ShardCount = &v
	return s
}

func (s *GetMetricStoreResponseBody) SetTtl(v int32) *GetMetricStoreResponseBody {
	s.Ttl = &v
	return s
}

type GetMetricStoreResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMetricStoreResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMetricStoreResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMetricStoreResponse) GoString() string {
	return s.String()
}

func (s *GetMetricStoreResponse) SetHeaders(v map[string]*string) *GetMetricStoreResponse {
	s.Headers = v
	return s
}

func (s *GetMetricStoreResponse) SetStatusCode(v int32) *GetMetricStoreResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMetricStoreResponse) SetBody(v *GetMetricStoreResponseBody) *GetMetricStoreResponse {
	s.Body = v
	return s
}

type GetMetricStoreMeteringModeResponseBody struct {
	// The billing mode. Default value: ChargeByFunction. Valid values: ChargeByFunction and ChargeByDataIngest.
	//
	// example:
	//
	// ChargeByFunction
	MeteringMode *string `json:"meteringMode,omitempty" xml:"meteringMode,omitempty"`
}

func (s GetMetricStoreMeteringModeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMetricStoreMeteringModeResponseBody) GoString() string {
	return s.String()
}

func (s *GetMetricStoreMeteringModeResponseBody) SetMeteringMode(v string) *GetMetricStoreMeteringModeResponseBody {
	s.MeteringMode = &v
	return s
}

type GetMetricStoreMeteringModeResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMetricStoreMeteringModeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMetricStoreMeteringModeResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMetricStoreMeteringModeResponse) GoString() string {
	return s.String()
}

func (s *GetMetricStoreMeteringModeResponse) SetHeaders(v map[string]*string) *GetMetricStoreMeteringModeResponse {
	s.Headers = v
	return s
}

func (s *GetMetricStoreMeteringModeResponse) SetStatusCode(v int32) *GetMetricStoreMeteringModeResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMetricStoreMeteringModeResponse) SetBody(v *GetMetricStoreMeteringModeResponseBody) *GetMetricStoreMeteringModeResponse {
	s.Body = v
	return s
}

type GetOSSExportResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *OSSExport         `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetOSSExportResponse) String() string {
	return tea.Prettify(s)
}

func (s GetOSSExportResponse) GoString() string {
	return s.String()
}

func (s *GetOSSExportResponse) SetHeaders(v map[string]*string) *GetOSSExportResponse {
	s.Headers = v
	return s
}

func (s *GetOSSExportResponse) SetStatusCode(v int32) *GetOSSExportResponse {
	s.StatusCode = &v
	return s
}

func (s *GetOSSExportResponse) SetBody(v *OSSExport) *GetOSSExportResponse {
	s.Body = v
	return s
}

type GetOSSHDFSExportResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *OSSExport         `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetOSSHDFSExportResponse) String() string {
	return tea.Prettify(s)
}

func (s GetOSSHDFSExportResponse) GoString() string {
	return s.String()
}

func (s *GetOSSHDFSExportResponse) SetHeaders(v map[string]*string) *GetOSSHDFSExportResponse {
	s.Headers = v
	return s
}

func (s *GetOSSHDFSExportResponse) SetStatusCode(v int32) *GetOSSHDFSExportResponse {
	s.StatusCode = &v
	return s
}

func (s *GetOSSHDFSExportResponse) SetBody(v *OSSExport) *GetOSSHDFSExportResponse {
	s.Body = v
	return s
}

type GetOSSIngestionResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *OSSIngestion      `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetOSSIngestionResponse) String() string {
	return tea.Prettify(s)
}

func (s GetOSSIngestionResponse) GoString() string {
	return s.String()
}

func (s *GetOSSIngestionResponse) SetHeaders(v map[string]*string) *GetOSSIngestionResponse {
	s.Headers = v
	return s
}

func (s *GetOSSIngestionResponse) SetStatusCode(v int32) *GetOSSIngestionResponse {
	s.StatusCode = &v
	return s
}

func (s *GetOSSIngestionResponse) SetBody(v *OSSIngestion) *GetOSSIngestionResponse {
	s.Body = v
	return s
}

type GetProjectResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *Project           `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s GetProjectResponse) GoString() string {
	return s.String()
}

func (s *GetProjectResponse) SetHeaders(v map[string]*string) *GetProjectResponse {
	s.Headers = v
	return s
}

func (s *GetProjectResponse) SetStatusCode(v int32) *GetProjectResponse {
	s.StatusCode = &v
	return s
}

func (s *GetProjectResponse) SetBody(v *Project) *GetProjectResponse {
	s.Body = v
	return s
}

type GetProjectLogsRequest struct {
	// Specifies whether to enable the Dedicated SQL feature. For more information, see [Enable Dedicated SQL](https://help.aliyun.com/document_detail/223777.html). Valid values:
	//
	// 	- true
	//
	// 	- false (default): enables the Standard SQL feature.
	//
	// You can use the powerSql or **query*	- parameter to configure Dedicated SQL.
	//
	// example:
	//
	// false
	PowerSql *bool `json:"powerSql,omitempty" xml:"powerSql,omitempty"`
	// The standard SQL statement. In this example, the SQL statement queries the number of page views (PVs) from 2022-03-01 10:41:40 to 2022-03-01 10:56:40 in a Logstore whose name is nginx-moni.
	//
	// This parameter is required.
	//
	// example:
	//
	// SELECT COUNT(*) as pv FROM nginx-moni where __time__ &gt; 1646102500 and __time__ &lt; 1646103400
	Query *string `json:"query,omitempty" xml:"query,omitempty"`
}

func (s GetProjectLogsRequest) String() string {
	return tea.Prettify(s)
}

func (s GetProjectLogsRequest) GoString() string {
	return s.String()
}

func (s *GetProjectLogsRequest) SetPowerSql(v bool) *GetProjectLogsRequest {
	s.PowerSql = &v
	return s
}

func (s *GetProjectLogsRequest) SetQuery(v string) *GetProjectLogsRequest {
	s.Query = &v
	return s
}

type GetProjectLogsResponse struct {
	Headers    map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       []map[string]*string `json:"body,omitempty" xml:"body,omitempty" type:"Repeated"`
}

func (s GetProjectLogsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetProjectLogsResponse) GoString() string {
	return s.String()
}

func (s *GetProjectLogsResponse) SetHeaders(v map[string]*string) *GetProjectLogsResponse {
	s.Headers = v
	return s
}

func (s *GetProjectLogsResponse) SetStatusCode(v int32) *GetProjectLogsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetProjectLogsResponse) SetBody(v []map[string]*string) *GetProjectLogsResponse {
	s.Body = v
	return s
}

type GetProjectPolicyResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *string            `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetProjectPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s GetProjectPolicyResponse) GoString() string {
	return s.String()
}

func (s *GetProjectPolicyResponse) SetHeaders(v map[string]*string) *GetProjectPolicyResponse {
	s.Headers = v
	return s
}

func (s *GetProjectPolicyResponse) SetStatusCode(v int32) *GetProjectPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *GetProjectPolicyResponse) SetBody(v string) *GetProjectPolicyResponse {
	s.Body = &v
	return s
}

type GetSavedSearchResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SavedSearch       `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetSavedSearchResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSavedSearchResponse) GoString() string {
	return s.String()
}

func (s *GetSavedSearchResponse) SetHeaders(v map[string]*string) *GetSavedSearchResponse {
	s.Headers = v
	return s
}

func (s *GetSavedSearchResponse) SetStatusCode(v int32) *GetSavedSearchResponse {
	s.StatusCode = &v
	return s
}

func (s *GetSavedSearchResponse) SetBody(v *SavedSearch) *GetSavedSearchResponse {
	s.Body = v
	return s
}

type GetScheduledSQLResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ScheduledSQL      `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetScheduledSQLResponse) String() string {
	return tea.Prettify(s)
}

func (s GetScheduledSQLResponse) GoString() string {
	return s.String()
}

func (s *GetScheduledSQLResponse) SetHeaders(v map[string]*string) *GetScheduledSQLResponse {
	s.Headers = v
	return s
}

func (s *GetScheduledSQLResponse) SetStatusCode(v int32) *GetScheduledSQLResponse {
	s.StatusCode = &v
	return s
}

func (s *GetScheduledSQLResponse) SetBody(v *ScheduledSQL) *GetScheduledSQLResponse {
	s.Body = v
	return s
}

type GetSlsServiceResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ServiceStatus     `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetSlsServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSlsServiceResponse) GoString() string {
	return s.String()
}

func (s *GetSlsServiceResponse) SetHeaders(v map[string]*string) *GetSlsServiceResponse {
	s.Headers = v
	return s
}

func (s *GetSlsServiceResponse) SetStatusCode(v int32) *GetSlsServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *GetSlsServiceResponse) SetBody(v *ServiceStatus) *GetSlsServiceResponse {
	s.Body = v
	return s
}

type GetSqlInstanceResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       []*GetSqlInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" type:"Repeated"`
}

func (s GetSqlInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSqlInstanceResponse) GoString() string {
	return s.String()
}

func (s *GetSqlInstanceResponse) SetHeaders(v map[string]*string) *GetSqlInstanceResponse {
	s.Headers = v
	return s
}

func (s *GetSqlInstanceResponse) SetStatusCode(v int32) *GetSqlInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *GetSqlInstanceResponse) SetBody(v []*GetSqlInstanceResponseBody) *GetSqlInstanceResponse {
	s.Body = v
	return s
}

type GetSqlInstanceResponseBody struct {
	// example:
	//
	// project_name
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// example:
	//
	// 2
	Cu *int32 `json:"cu,omitempty" xml:"cu,omitempty"`
	// example:
	//
	// 1710230272
	CreateTime *int32 `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// example:
	//
	// 1710230272
	UpdateTime *int32 `json:"updateTime,omitempty" xml:"updateTime,omitempty"`
	// example:
	//
	// true
	UseAsDefault *bool `json:"useAsDefault,omitempty" xml:"useAsDefault,omitempty"`
}

func (s GetSqlInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetSqlInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *GetSqlInstanceResponseBody) SetName(v string) *GetSqlInstanceResponseBody {
	s.Name = &v
	return s
}

func (s *GetSqlInstanceResponseBody) SetCu(v int32) *GetSqlInstanceResponseBody {
	s.Cu = &v
	return s
}

func (s *GetSqlInstanceResponseBody) SetCreateTime(v int32) *GetSqlInstanceResponseBody {
	s.CreateTime = &v
	return s
}

func (s *GetSqlInstanceResponseBody) SetUpdateTime(v int32) *GetSqlInstanceResponseBody {
	s.UpdateTime = &v
	return s
}

func (s *GetSqlInstanceResponseBody) SetUseAsDefault(v bool) *GetSqlInstanceResponseBody {
	s.UseAsDefault = &v
	return s
}

type GetStoreViewResponseBody struct {
	// The type of the dataset.
	//
	// Valid values:
	//
	// 	- metricstore
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// 	- logstore
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// example:
	//
	// logstore
	StoreType *string `json:"storeType,omitempty" xml:"storeType,omitempty"`
	// The Logstores or Metricstores.
	Stores []*StoreViewStore `json:"stores,omitempty" xml:"stores,omitempty" type:"Repeated"`
}

func (s GetStoreViewResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetStoreViewResponseBody) GoString() string {
	return s.String()
}

func (s *GetStoreViewResponseBody) SetStoreType(v string) *GetStoreViewResponseBody {
	s.StoreType = &v
	return s
}

func (s *GetStoreViewResponseBody) SetStores(v []*StoreViewStore) *GetStoreViewResponseBody {
	s.Stores = v
	return s
}

type GetStoreViewResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetStoreViewResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetStoreViewResponse) String() string {
	return tea.Prettify(s)
}

func (s GetStoreViewResponse) GoString() string {
	return s.String()
}

func (s *GetStoreViewResponse) SetHeaders(v map[string]*string) *GetStoreViewResponse {
	s.Headers = v
	return s
}

func (s *GetStoreViewResponse) SetStatusCode(v int32) *GetStoreViewResponse {
	s.StatusCode = &v
	return s
}

func (s *GetStoreViewResponse) SetBody(v *GetStoreViewResponseBody) *GetStoreViewResponse {
	s.Body = v
	return s
}

type GetStoreViewIndexResponseBody struct {
	// The index configurations.
	Indexes []*GetStoreViewIndexResponseBodyIndexes `json:"indexes,omitempty" xml:"indexes,omitempty" type:"Repeated"`
}

func (s GetStoreViewIndexResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetStoreViewIndexResponseBody) GoString() string {
	return s.String()
}

func (s *GetStoreViewIndexResponseBody) SetIndexes(v []*GetStoreViewIndexResponseBodyIndexes) *GetStoreViewIndexResponseBody {
	s.Indexes = v
	return s
}

type GetStoreViewIndexResponseBodyIndexes struct {
	// The index configurations of the Logstore.
	Index *Index `json:"index,omitempty" xml:"index,omitempty"`
	// The name of the Logstore.
	//
	// example:
	//
	// my-logstore
	Logstore *string `json:"logstore,omitempty" xml:"logstore,omitempty"`
	// The name of the project to which the Logstore belongs.
	//
	// example:
	//
	// example-project
	Project *string `json:"project,omitempty" xml:"project,omitempty"`
}

func (s GetStoreViewIndexResponseBodyIndexes) String() string {
	return tea.Prettify(s)
}

func (s GetStoreViewIndexResponseBodyIndexes) GoString() string {
	return s.String()
}

func (s *GetStoreViewIndexResponseBodyIndexes) SetIndex(v *Index) *GetStoreViewIndexResponseBodyIndexes {
	s.Index = v
	return s
}

func (s *GetStoreViewIndexResponseBodyIndexes) SetLogstore(v string) *GetStoreViewIndexResponseBodyIndexes {
	s.Logstore = &v
	return s
}

func (s *GetStoreViewIndexResponseBodyIndexes) SetProject(v string) *GetStoreViewIndexResponseBodyIndexes {
	s.Project = &v
	return s
}

type GetStoreViewIndexResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetStoreViewIndexResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetStoreViewIndexResponse) String() string {
	return tea.Prettify(s)
}

func (s GetStoreViewIndexResponse) GoString() string {
	return s.String()
}

func (s *GetStoreViewIndexResponse) SetHeaders(v map[string]*string) *GetStoreViewIndexResponse {
	s.Headers = v
	return s
}

func (s *GetStoreViewIndexResponse) SetStatusCode(v int32) *GetStoreViewIndexResponse {
	s.StatusCode = &v
	return s
}

func (s *GetStoreViewIndexResponse) SetBody(v *GetStoreViewIndexResponseBody) *GetStoreViewIndexResponse {
	s.Body = v
	return s
}

type ListAgentInstanceConfigsRequest struct {
	Offset *int64 `json:"offset,omitempty" xml:"offset,omitempty"`
	Size   *int64 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListAgentInstanceConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAgentInstanceConfigsRequest) GoString() string {
	return s.String()
}

func (s *ListAgentInstanceConfigsRequest) SetOffset(v int64) *ListAgentInstanceConfigsRequest {
	s.Offset = &v
	return s
}

func (s *ListAgentInstanceConfigsRequest) SetSize(v int64) *ListAgentInstanceConfigsRequest {
	s.Size = &v
	return s
}

type ListAgentInstanceConfigsResponseBody struct {
	Configs []*string `json:"configs,omitempty" xml:"configs,omitempty" type:"Repeated"`
	Size    *int64    `json:"size,omitempty" xml:"size,omitempty"`
	Total   *int64    `json:"total,omitempty" xml:"total,omitempty"`
}

func (s ListAgentInstanceConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAgentInstanceConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *ListAgentInstanceConfigsResponseBody) SetConfigs(v []*string) *ListAgentInstanceConfigsResponseBody {
	s.Configs = v
	return s
}

func (s *ListAgentInstanceConfigsResponseBody) SetSize(v int64) *ListAgentInstanceConfigsResponseBody {
	s.Size = &v
	return s
}

func (s *ListAgentInstanceConfigsResponseBody) SetTotal(v int64) *ListAgentInstanceConfigsResponseBody {
	s.Total = &v
	return s
}

type ListAgentInstanceConfigsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListAgentInstanceConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListAgentInstanceConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAgentInstanceConfigsResponse) GoString() string {
	return s.String()
}

func (s *ListAgentInstanceConfigsResponse) SetHeaders(v map[string]*string) *ListAgentInstanceConfigsResponse {
	s.Headers = v
	return s
}

func (s *ListAgentInstanceConfigsResponse) SetStatusCode(v int32) *ListAgentInstanceConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAgentInstanceConfigsResponse) SetBody(v *ListAgentInstanceConfigsResponseBody) *ListAgentInstanceConfigsResponse {
	s.Body = v
	return s
}

type ListAlertsRequest struct {
	// example:
	//
	// ali-test-logstore
	Logstore *string `json:"logstore,omitempty" xml:"logstore,omitempty"`
	// example:
	//
	// 0
	Offset *int32 `json:"offset,omitempty" xml:"offset,omitempty"`
	// The number of entries per page. Maximum value: 200. Default value: 10.
	//
	// example:
	//
	// 10
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListAlertsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAlertsRequest) GoString() string {
	return s.String()
}

func (s *ListAlertsRequest) SetLogstore(v string) *ListAlertsRequest {
	s.Logstore = &v
	return s
}

func (s *ListAlertsRequest) SetOffset(v int32) *ListAlertsRequest {
	s.Offset = &v
	return s
}

func (s *ListAlertsRequest) SetSize(v int32) *ListAlertsRequest {
	s.Size = &v
	return s
}

type ListAlertsResponseBody struct {
	// The number of alert rules that are returned.
	//
	// example:
	//
	// 10
	Count *int32 `json:"count,omitempty" xml:"count,omitempty"`
	// The alert rules.
	Results []*Alert `json:"results,omitempty" xml:"results,omitempty" type:"Repeated"`
	// The total number of alert rules in the project.
	//
	// example:
	//
	// 80
	Total *int32 `json:"total,omitempty" xml:"total,omitempty"`
}

func (s ListAlertsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAlertsResponseBody) GoString() string {
	return s.String()
}

func (s *ListAlertsResponseBody) SetCount(v int32) *ListAlertsResponseBody {
	s.Count = &v
	return s
}

func (s *ListAlertsResponseBody) SetResults(v []*Alert) *ListAlertsResponseBody {
	s.Results = v
	return s
}

func (s *ListAlertsResponseBody) SetTotal(v int32) *ListAlertsResponseBody {
	s.Total = &v
	return s
}

type ListAlertsResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListAlertsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListAlertsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAlertsResponse) GoString() string {
	return s.String()
}

func (s *ListAlertsResponse) SetHeaders(v map[string]*string) *ListAlertsResponse {
	s.Headers = v
	return s
}

func (s *ListAlertsResponse) SetStatusCode(v int32) *ListAlertsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAlertsResponse) SetBody(v *ListAlertsResponseBody) *ListAlertsResponse {
	s.Body = v
	return s
}

type ListAnnotationDataRequest struct {
	// The line from which the query starts.
	//
	// example:
	//
	// 0
	Offset *int32 `json:"offset,omitempty" xml:"offset,omitempty"`
	// The number of entries per page.
	//
	// example:
	//
	// 100
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListAnnotationDataRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAnnotationDataRequest) GoString() string {
	return s.String()
}

func (s *ListAnnotationDataRequest) SetOffset(v int32) *ListAnnotationDataRequest {
	s.Offset = &v
	return s
}

func (s *ListAnnotationDataRequest) SetSize(v int32) *ListAnnotationDataRequest {
	s.Size = &v
	return s
}

type ListAnnotationDataResponseBody struct {
	// The data returned.
	Data []*MLDataParam `json:"data,omitempty" xml:"data,omitempty" type:"Repeated"`
	// The total number of entries returned.
	//
	// example:
	//
	// 20
	Total *int32 `json:"total,omitempty" xml:"total,omitempty"`
}

func (s ListAnnotationDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAnnotationDataResponseBody) GoString() string {
	return s.String()
}

func (s *ListAnnotationDataResponseBody) SetData(v []*MLDataParam) *ListAnnotationDataResponseBody {
	s.Data = v
	return s
}

func (s *ListAnnotationDataResponseBody) SetTotal(v int32) *ListAnnotationDataResponseBody {
	s.Total = &v
	return s
}

type ListAnnotationDataResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListAnnotationDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListAnnotationDataResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAnnotationDataResponse) GoString() string {
	return s.String()
}

func (s *ListAnnotationDataResponse) SetHeaders(v map[string]*string) *ListAnnotationDataResponse {
	s.Headers = v
	return s
}

func (s *ListAnnotationDataResponse) SetStatusCode(v int32) *ListAnnotationDataResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAnnotationDataResponse) SetBody(v *ListAnnotationDataResponseBody) *ListAnnotationDataResponse {
	s.Body = v
	return s
}

type ListAnnotationDataSetsRequest struct {
	// The line from which the query starts.
	//
	// example:
	//
	// 0
	Offset *int32 `json:"offset,omitempty" xml:"offset,omitempty"`
	// The number of entries per page.
	//
	// example:
	//
	// 100
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListAnnotationDataSetsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAnnotationDataSetsRequest) GoString() string {
	return s.String()
}

func (s *ListAnnotationDataSetsRequest) SetOffset(v int32) *ListAnnotationDataSetsRequest {
	s.Offset = &v
	return s
}

func (s *ListAnnotationDataSetsRequest) SetSize(v int32) *ListAnnotationDataSetsRequest {
	s.Size = &v
	return s
}

type ListAnnotationDataSetsResponseBody struct {
	// The data returned.
	Data []*MLDataSetParam `json:"data,omitempty" xml:"data,omitempty" type:"Repeated"`
	// The total number of entries returned.
	//
	// example:
	//
	// 20
	Total *int32 `json:"total,omitempty" xml:"total,omitempty"`
}

func (s ListAnnotationDataSetsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAnnotationDataSetsResponseBody) GoString() string {
	return s.String()
}

func (s *ListAnnotationDataSetsResponseBody) SetData(v []*MLDataSetParam) *ListAnnotationDataSetsResponseBody {
	s.Data = v
	return s
}

func (s *ListAnnotationDataSetsResponseBody) SetTotal(v int32) *ListAnnotationDataSetsResponseBody {
	s.Total = &v
	return s
}

type ListAnnotationDataSetsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListAnnotationDataSetsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListAnnotationDataSetsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAnnotationDataSetsResponse) GoString() string {
	return s.String()
}

func (s *ListAnnotationDataSetsResponse) SetHeaders(v map[string]*string) *ListAnnotationDataSetsResponse {
	s.Headers = v
	return s
}

func (s *ListAnnotationDataSetsResponse) SetStatusCode(v int32) *ListAnnotationDataSetsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAnnotationDataSetsResponse) SetBody(v *ListAnnotationDataSetsResponseBody) *ListAnnotationDataSetsResponse {
	s.Body = v
	return s
}

type ListAnnotationLabelsRequest struct {
	// The line from which the query starts.
	//
	// example:
	//
	// 0
	Offset *int32 `json:"offset,omitempty" xml:"offset,omitempty"`
	// The number of entries per page.
	//
	// example:
	//
	// 100
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListAnnotationLabelsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAnnotationLabelsRequest) GoString() string {
	return s.String()
}

func (s *ListAnnotationLabelsRequest) SetOffset(v int32) *ListAnnotationLabelsRequest {
	s.Offset = &v
	return s
}

func (s *ListAnnotationLabelsRequest) SetSize(v int32) *ListAnnotationLabelsRequest {
	s.Size = &v
	return s
}

type ListAnnotationLabelsResponseBody struct {
	// The data returned.
	Data []*MLLabelParam `json:"data,omitempty" xml:"data,omitempty" type:"Repeated"`
	// The total number of tags that meet the query conditions.
	//
	// example:
	//
	// 20
	Total *int32 `json:"total,omitempty" xml:"total,omitempty"`
}

func (s ListAnnotationLabelsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAnnotationLabelsResponseBody) GoString() string {
	return s.String()
}

func (s *ListAnnotationLabelsResponseBody) SetData(v []*MLLabelParam) *ListAnnotationLabelsResponseBody {
	s.Data = v
	return s
}

func (s *ListAnnotationLabelsResponseBody) SetTotal(v int32) *ListAnnotationLabelsResponseBody {
	s.Total = &v
	return s
}

type ListAnnotationLabelsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListAnnotationLabelsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListAnnotationLabelsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAnnotationLabelsResponse) GoString() string {
	return s.String()
}

func (s *ListAnnotationLabelsResponse) SetHeaders(v map[string]*string) *ListAnnotationLabelsResponse {
	s.Headers = v
	return s
}

func (s *ListAnnotationLabelsResponse) SetStatusCode(v int32) *ListAnnotationLabelsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAnnotationLabelsResponse) SetBody(v *ListAnnotationLabelsResponseBody) *ListAnnotationLabelsResponse {
	s.Body = v
	return s
}

type ListCollectionPoliciesRequest struct {
	// example:
	//
	// your-central-project1
	CentralProject *string `json:"centralProject,omitempty" xml:"centralProject,omitempty"`
	// example:
	//
	// access_log
	DataCode *string `json:"dataCode,omitempty" xml:"dataCode,omitempty"`
	// example:
	//
	// your-test-bucket1
	InstanceId *string `json:"instanceId,omitempty" xml:"instanceId,omitempty"`
	// example:
	//
	// 0
	Offset *int32 `json:"offset,omitempty" xml:"offset,omitempty"`
	// example:
	//
	// your_log_policy
	PolicyName *string `json:"policyName,omitempty" xml:"policyName,omitempty"`
	// The code of the service.
	//
	// example:
	//
	// oss
	ProductCode *string `json:"productCode,omitempty" xml:"productCode,omitempty"`
	// example:
	//
	// 50
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListCollectionPoliciesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListCollectionPoliciesRequest) GoString() string {
	return s.String()
}

func (s *ListCollectionPoliciesRequest) SetCentralProject(v string) *ListCollectionPoliciesRequest {
	s.CentralProject = &v
	return s
}

func (s *ListCollectionPoliciesRequest) SetDataCode(v string) *ListCollectionPoliciesRequest {
	s.DataCode = &v
	return s
}

func (s *ListCollectionPoliciesRequest) SetInstanceId(v string) *ListCollectionPoliciesRequest {
	s.InstanceId = &v
	return s
}

func (s *ListCollectionPoliciesRequest) SetOffset(v int32) *ListCollectionPoliciesRequest {
	s.Offset = &v
	return s
}

func (s *ListCollectionPoliciesRequest) SetPolicyName(v string) *ListCollectionPoliciesRequest {
	s.PolicyName = &v
	return s
}

func (s *ListCollectionPoliciesRequest) SetProductCode(v string) *ListCollectionPoliciesRequest {
	s.ProductCode = &v
	return s
}

func (s *ListCollectionPoliciesRequest) SetSize(v int32) *ListCollectionPoliciesRequest {
	s.Size = &v
	return s
}

type ListCollectionPoliciesResponseBody struct {
	// example:
	//
	// 1
	CurrentCount *int32 `json:"currentCount,omitempty" xml:"currentCount,omitempty"`
	// The data of the policies that are matched against the query conditions. The data is returned based on paginated results.
	Data       []*ListCollectionPoliciesResponseBodyData       `json:"data,omitempty" xml:"data,omitempty" type:"Repeated"`
	Statistics []*ListCollectionPoliciesResponseBodyStatistics `json:"statistics,omitempty" xml:"statistics,omitempty" type:"Repeated"`
	// example:
	//
	// 1
	TotalCount *int32 `json:"totalCount,omitempty" xml:"totalCount,omitempty"`
}

func (s ListCollectionPoliciesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListCollectionPoliciesResponseBody) GoString() string {
	return s.String()
}

func (s *ListCollectionPoliciesResponseBody) SetCurrentCount(v int32) *ListCollectionPoliciesResponseBody {
	s.CurrentCount = &v
	return s
}

func (s *ListCollectionPoliciesResponseBody) SetData(v []*ListCollectionPoliciesResponseBodyData) *ListCollectionPoliciesResponseBody {
	s.Data = v
	return s
}

func (s *ListCollectionPoliciesResponseBody) SetStatistics(v []*ListCollectionPoliciesResponseBodyStatistics) *ListCollectionPoliciesResponseBody {
	s.Statistics = v
	return s
}

func (s *ListCollectionPoliciesResponseBody) SetTotalCount(v int32) *ListCollectionPoliciesResponseBody {
	s.TotalCount = &v
	return s
}

type ListCollectionPoliciesResponseBodyData struct {
	// The configuration for centralized storage.
	CentralizeConfig *ListCollectionPoliciesResponseBodyDataCentralizeConfig `json:"centralizeConfig,omitempty" xml:"centralizeConfig,omitempty" type:"Struct"`
	// example:
	//
	// false
	CentralizeEnabled *bool `json:"centralizeEnabled,omitempty" xml:"centralizeEnabled,omitempty"`
	// example:
	//
	// access_log
	DataCode   *string                                           `json:"dataCode,omitempty" xml:"dataCode,omitempty"`
	DataConfig *ListCollectionPoliciesResponseBodyDataDataConfig `json:"dataConfig,omitempty" xml:"dataConfig,omitempty" type:"Struct"`
	// example:
	//
	// true
	Enabled *bool `json:"enabled,omitempty" xml:"enabled,omitempty"`
	// example:
	//
	// false
	InternalPolicy *bool                                               `json:"internalPolicy,omitempty" xml:"internalPolicy,omitempty"`
	PolicyConfig   *ListCollectionPoliciesResponseBodyDataPolicyConfig `json:"policyConfig,omitempty" xml:"policyConfig,omitempty" type:"Struct"`
	// example:
	//
	// your_log_policy
	PolicyName *string `json:"policyName,omitempty" xml:"policyName,omitempty"`
	// example:
	//
	// 148***********50
	PolicyUid *string `json:"policyUid,omitempty" xml:"policyUid,omitempty"`
	// example:
	//
	// oss
	ProductCode       *string                                                  `json:"productCode,omitempty" xml:"productCode,omitempty"`
	ResourceDirectory *ListCollectionPoliciesResponseBodyDataResourceDirectory `json:"resourceDirectory,omitempty" xml:"resourceDirectory,omitempty" type:"Struct"`
}

func (s ListCollectionPoliciesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListCollectionPoliciesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListCollectionPoliciesResponseBodyData) SetCentralizeConfig(v *ListCollectionPoliciesResponseBodyDataCentralizeConfig) *ListCollectionPoliciesResponseBodyData {
	s.CentralizeConfig = v
	return s
}

func (s *ListCollectionPoliciesResponseBodyData) SetCentralizeEnabled(v bool) *ListCollectionPoliciesResponseBodyData {
	s.CentralizeEnabled = &v
	return s
}

func (s *ListCollectionPoliciesResponseBodyData) SetDataCode(v string) *ListCollectionPoliciesResponseBodyData {
	s.DataCode = &v
	return s
}

func (s *ListCollectionPoliciesResponseBodyData) SetDataConfig(v *ListCollectionPoliciesResponseBodyDataDataConfig) *ListCollectionPoliciesResponseBodyData {
	s.DataConfig = v
	return s
}

func (s *ListCollectionPoliciesResponseBodyData) SetEnabled(v bool) *ListCollectionPoliciesResponseBodyData {
	s.Enabled = &v
	return s
}

func (s *ListCollectionPoliciesResponseBodyData) SetInternalPolicy(v bool) *ListCollectionPoliciesResponseBodyData {
	s.InternalPolicy = &v
	return s
}

func (s *ListCollectionPoliciesResponseBodyData) SetPolicyConfig(v *ListCollectionPoliciesResponseBodyDataPolicyConfig) *ListCollectionPoliciesResponseBodyData {
	s.PolicyConfig = v
	return s
}

func (s *ListCollectionPoliciesResponseBodyData) SetPolicyName(v string) *ListCollectionPoliciesResponseBodyData {
	s.PolicyName = &v
	return s
}

func (s *ListCollectionPoliciesResponseBodyData) SetPolicyUid(v string) *ListCollectionPoliciesResponseBodyData {
	s.PolicyUid = &v
	return s
}

func (s *ListCollectionPoliciesResponseBodyData) SetProductCode(v string) *ListCollectionPoliciesResponseBodyData {
	s.ProductCode = &v
	return s
}

func (s *ListCollectionPoliciesResponseBodyData) SetResourceDirectory(v *ListCollectionPoliciesResponseBodyDataResourceDirectory) *ListCollectionPoliciesResponseBodyData {
	s.ResourceDirectory = v
	return s
}

type ListCollectionPoliciesResponseBodyDataCentralizeConfig struct {
	// example:
	//
	// your-sls-logstore-in-beijing
	DestLogstore *string `json:"destLogstore,omitempty" xml:"destLogstore,omitempty"`
	// example:
	//
	// your-sls-project-in-beijing
	DestProject *string `json:"destProject,omitempty" xml:"destProject,omitempty"`
	// example:
	//
	// cn-beijing
	DestRegion *string `json:"destRegion,omitempty" xml:"destRegion,omitempty"`
	// The data retention period for centralized storage. Unit: days.
	//
	// example:
	//
	// your-sls-logstore-ttl
	DestTTL *int32 `json:"destTTL,omitempty" xml:"destTTL,omitempty"`
}

func (s ListCollectionPoliciesResponseBodyDataCentralizeConfig) String() string {
	return tea.Prettify(s)
}

func (s ListCollectionPoliciesResponseBodyDataCentralizeConfig) GoString() string {
	return s.String()
}

func (s *ListCollectionPoliciesResponseBodyDataCentralizeConfig) SetDestLogstore(v string) *ListCollectionPoliciesResponseBodyDataCentralizeConfig {
	s.DestLogstore = &v
	return s
}

func (s *ListCollectionPoliciesResponseBodyDataCentralizeConfig) SetDestProject(v string) *ListCollectionPoliciesResponseBodyDataCentralizeConfig {
	s.DestProject = &v
	return s
}

func (s *ListCollectionPoliciesResponseBodyDataCentralizeConfig) SetDestRegion(v string) *ListCollectionPoliciesResponseBodyDataCentralizeConfig {
	s.DestRegion = &v
	return s
}

func (s *ListCollectionPoliciesResponseBodyDataCentralizeConfig) SetDestTTL(v int32) *ListCollectionPoliciesResponseBodyDataCentralizeConfig {
	s.DestTTL = &v
	return s
}

type ListCollectionPoliciesResponseBodyDataDataConfig struct {
	// example:
	//
	// ""
	DataProject *string `json:"dataProject,omitempty" xml:"dataProject,omitempty"`
	// example:
	//
	// cn-hangzhou
	DataRegion *string `json:"dataRegion,omitempty" xml:"dataRegion,omitempty"`
}

func (s ListCollectionPoliciesResponseBodyDataDataConfig) String() string {
	return tea.Prettify(s)
}

func (s ListCollectionPoliciesResponseBodyDataDataConfig) GoString() string {
	return s.String()
}

func (s *ListCollectionPoliciesResponseBodyDataDataConfig) SetDataProject(v string) *ListCollectionPoliciesResponseBodyDataDataConfig {
	s.DataProject = &v
	return s
}

func (s *ListCollectionPoliciesResponseBodyDataDataConfig) SetDataRegion(v string) *ListCollectionPoliciesResponseBodyDataDataConfig {
	s.DataRegion = &v
	return s
}

type ListCollectionPoliciesResponseBodyDataPolicyConfig struct {
	InstanceIds []*string `json:"instanceIds,omitempty" xml:"instanceIds,omitempty" type:"Repeated"`
	Regions     []*string `json:"regions,omitempty" xml:"regions,omitempty" type:"Repeated"`
	// example:
	//
	// all
	ResourceMode *string `json:"resourceMode,omitempty" xml:"resourceMode,omitempty"`
	// example:
	//
	// {"tag1":"value1","tag2":"value2"}
	ResourceTags map[string]interface{} `json:"resourceTags,omitempty" xml:"resourceTags,omitempty"`
}

func (s ListCollectionPoliciesResponseBodyDataPolicyConfig) String() string {
	return tea.Prettify(s)
}

func (s ListCollectionPoliciesResponseBodyDataPolicyConfig) GoString() string {
	return s.String()
}

func (s *ListCollectionPoliciesResponseBodyDataPolicyConfig) SetInstanceIds(v []*string) *ListCollectionPoliciesResponseBodyDataPolicyConfig {
	s.InstanceIds = v
	return s
}

func (s *ListCollectionPoliciesResponseBodyDataPolicyConfig) SetRegions(v []*string) *ListCollectionPoliciesResponseBodyDataPolicyConfig {
	s.Regions = v
	return s
}

func (s *ListCollectionPoliciesResponseBodyDataPolicyConfig) SetResourceMode(v string) *ListCollectionPoliciesResponseBodyDataPolicyConfig {
	s.ResourceMode = &v
	return s
}

func (s *ListCollectionPoliciesResponseBodyDataPolicyConfig) SetResourceTags(v map[string]interface{}) *ListCollectionPoliciesResponseBodyDataPolicyConfig {
	s.ResourceTags = v
	return s
}

type ListCollectionPoliciesResponseBodyDataResourceDirectory struct {
	// example:
	//
	// all,custom
	AccountGroupType *string   `json:"accountGroupType,omitempty" xml:"accountGroupType,omitempty"`
	Members          []*string `json:"members,omitempty" xml:"members,omitempty" type:"Repeated"`
}

func (s ListCollectionPoliciesResponseBodyDataResourceDirectory) String() string {
	return tea.Prettify(s)
}

func (s ListCollectionPoliciesResponseBodyDataResourceDirectory) GoString() string {
	return s.String()
}

func (s *ListCollectionPoliciesResponseBodyDataResourceDirectory) SetAccountGroupType(v string) *ListCollectionPoliciesResponseBodyDataResourceDirectory {
	s.AccountGroupType = &v
	return s
}

func (s *ListCollectionPoliciesResponseBodyDataResourceDirectory) SetMembers(v []*string) *ListCollectionPoliciesResponseBodyDataResourceDirectory {
	s.Members = v
	return s
}

type ListCollectionPoliciesResponseBodyStatistics struct {
	PolicySourceList []*ListCollectionPoliciesResponseBodyStatisticsPolicySourceList `json:"policySourceList,omitempty" xml:"policySourceList,omitempty" type:"Repeated"`
	// example:
	//
	// oss
	ProductCode *string `json:"productCode,omitempty" xml:"productCode,omitempty"`
}

func (s ListCollectionPoliciesResponseBodyStatistics) String() string {
	return tea.Prettify(s)
}

func (s ListCollectionPoliciesResponseBodyStatistics) GoString() string {
	return s.String()
}

func (s *ListCollectionPoliciesResponseBodyStatistics) SetPolicySourceList(v []*ListCollectionPoliciesResponseBodyStatisticsPolicySourceList) *ListCollectionPoliciesResponseBodyStatistics {
	s.PolicySourceList = v
	return s
}

func (s *ListCollectionPoliciesResponseBodyStatistics) SetProductCode(v string) *ListCollectionPoliciesResponseBodyStatistics {
	s.ProductCode = &v
	return s
}

type ListCollectionPoliciesResponseBodyStatisticsPolicySourceList struct {
	// example:
	//
	// policy_name1_from148
	PolicyName *string `json:"policyName,omitempty" xml:"policyName,omitempty"`
	// example:
	//
	// 148***********50
	PolicyUid *string `json:"policyUid,omitempty" xml:"policyUid,omitempty"`
}

func (s ListCollectionPoliciesResponseBodyStatisticsPolicySourceList) String() string {
	return tea.Prettify(s)
}

func (s ListCollectionPoliciesResponseBodyStatisticsPolicySourceList) GoString() string {
	return s.String()
}

func (s *ListCollectionPoliciesResponseBodyStatisticsPolicySourceList) SetPolicyName(v string) *ListCollectionPoliciesResponseBodyStatisticsPolicySourceList {
	s.PolicyName = &v
	return s
}

func (s *ListCollectionPoliciesResponseBodyStatisticsPolicySourceList) SetPolicyUid(v string) *ListCollectionPoliciesResponseBodyStatisticsPolicySourceList {
	s.PolicyUid = &v
	return s
}

type ListCollectionPoliciesResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListCollectionPoliciesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListCollectionPoliciesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListCollectionPoliciesResponse) GoString() string {
	return s.String()
}

func (s *ListCollectionPoliciesResponse) SetHeaders(v map[string]*string) *ListCollectionPoliciesResponse {
	s.Headers = v
	return s
}

func (s *ListCollectionPoliciesResponse) SetStatusCode(v int32) *ListCollectionPoliciesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListCollectionPoliciesResponse) SetBody(v *ListCollectionPoliciesResponseBody) *ListCollectionPoliciesResponse {
	s.Body = v
	return s
}

type ListConfigRequest struct {
	// The name of the Logtail configuration, which is used for fuzzy match.
	//
	// example:
	//
	// logtail-config-sample
	ConfigName *string `json:"configName,omitempty" xml:"configName,omitempty"`
	// The name of the Logstore.
	//
	// This parameter is required.
	//
	// example:
	//
	// ali-test-logstore
	LogstoreName *string `json:"logstoreName,omitempty" xml:"logstoreName,omitempty"`
	// The line from which the query starts. Default value: 0.
	//
	// This parameter is required.
	//
	// example:
	//
	// 0
	Offset *int64 `json:"offset,omitempty" xml:"offset,omitempty"`
	// The number of entries per page. Maximum value: 500.
	//
	// This parameter is required.
	//
	// example:
	//
	// 10
	Size *int64 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s ListConfigRequest) GoString() string {
	return s.String()
}

func (s *ListConfigRequest) SetConfigName(v string) *ListConfigRequest {
	s.ConfigName = &v
	return s
}

func (s *ListConfigRequest) SetLogstoreName(v string) *ListConfigRequest {
	s.LogstoreName = &v
	return s
}

func (s *ListConfigRequest) SetOffset(v int64) *ListConfigRequest {
	s.Offset = &v
	return s
}

func (s *ListConfigRequest) SetSize(v int64) *ListConfigRequest {
	s.Size = &v
	return s
}

type ListConfigResponseBody struct {
	// The Logtail configurations that are returned on the current page.
	Configs []*string `json:"configs,omitempty" xml:"configs,omitempty" type:"Repeated"`
	// The number of Logtail configurations that are returned on the current page.
	//
	// example:
	//
	// 3
	Count *int32 `json:"count,omitempty" xml:"count,omitempty"`
	// The total number of Logtail configurations that meet the query conditions.
	//
	// example:
	//
	// 2
	Total *int32 `json:"total,omitempty" xml:"total,omitempty"`
}

func (s ListConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListConfigResponseBody) GoString() string {
	return s.String()
}

func (s *ListConfigResponseBody) SetConfigs(v []*string) *ListConfigResponseBody {
	s.Configs = v
	return s
}

func (s *ListConfigResponseBody) SetCount(v int32) *ListConfigResponseBody {
	s.Count = &v
	return s
}

func (s *ListConfigResponseBody) SetTotal(v int32) *ListConfigResponseBody {
	s.Total = &v
	return s
}

type ListConfigResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s ListConfigResponse) GoString() string {
	return s.String()
}

func (s *ListConfigResponse) SetHeaders(v map[string]*string) *ListConfigResponse {
	s.Headers = v
	return s
}

func (s *ListConfigResponse) SetStatusCode(v int32) *ListConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *ListConfigResponse) SetBody(v *ListConfigResponseBody) *ListConfigResponse {
	s.Body = v
	return s
}

type ListConsumerGroupResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       []*ConsumerGroup   `json:"body,omitempty" xml:"body,omitempty" type:"Repeated"`
}

func (s ListConsumerGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ListConsumerGroupResponse) GoString() string {
	return s.String()
}

func (s *ListConsumerGroupResponse) SetHeaders(v map[string]*string) *ListConsumerGroupResponse {
	s.Headers = v
	return s
}

func (s *ListConsumerGroupResponse) SetStatusCode(v int32) *ListConsumerGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ListConsumerGroupResponse) SetBody(v []*ConsumerGroup) *ListConsumerGroupResponse {
	s.Body = v
	return s
}

type ListDashboardRequest struct {
	// The line from which the query starts. Default value: 0.
	//
	// example:
	//
	// 0
	Offset *int32 `json:"offset,omitempty" xml:"offset,omitempty"`
	// The number of entries per page. Maximum value: 500. Default value: 500.
	//
	// example:
	//
	// 10
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListDashboardRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDashboardRequest) GoString() string {
	return s.String()
}

func (s *ListDashboardRequest) SetOffset(v int32) *ListDashboardRequest {
	s.Offset = &v
	return s
}

func (s *ListDashboardRequest) SetSize(v int32) *ListDashboardRequest {
	s.Size = &v
	return s
}

type ListDashboardResponseBody struct {
	// The details of the dashboard.
	DashboardItems []*ListDashboardResponseBodyDashboardItems `json:"dashboardItems,omitempty" xml:"dashboardItems,omitempty" type:"Repeated"`
	// The queried dashboards. Each dashboard in the array is specified by dashboardName.
	Dashboards []*string `json:"dashboards,omitempty" xml:"dashboards,omitempty" type:"Repeated"`
}

func (s ListDashboardResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDashboardResponseBody) GoString() string {
	return s.String()
}

func (s *ListDashboardResponseBody) SetDashboardItems(v []*ListDashboardResponseBodyDashboardItems) *ListDashboardResponseBody {
	s.DashboardItems = v
	return s
}

func (s *ListDashboardResponseBody) SetDashboards(v []*string) *ListDashboardResponseBody {
	s.Dashboards = v
	return s
}

type ListDashboardResponseBodyDashboardItems struct {
	// The dashboard ID. The ID must be unique in a project. Fuzzy search is supported. For example, if you enter da, all dashboards whose IDs start with da are queried.
	//
	// example:
	//
	// dashboard-1609294922657-434834
	DashboardName *string `json:"dashboardName,omitempty" xml:"dashboardName,omitempty"`
	// The display name of the dashboard.
	//
	// example:
	//
	// data-ingest
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
}

func (s ListDashboardResponseBodyDashboardItems) String() string {
	return tea.Prettify(s)
}

func (s ListDashboardResponseBodyDashboardItems) GoString() string {
	return s.String()
}

func (s *ListDashboardResponseBodyDashboardItems) SetDashboardName(v string) *ListDashboardResponseBodyDashboardItems {
	s.DashboardName = &v
	return s
}

func (s *ListDashboardResponseBodyDashboardItems) SetDisplayName(v string) *ListDashboardResponseBodyDashboardItems {
	s.DisplayName = &v
	return s
}

type ListDashboardResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDashboardResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDashboardResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDashboardResponse) GoString() string {
	return s.String()
}

func (s *ListDashboardResponse) SetHeaders(v map[string]*string) *ListDashboardResponse {
	s.Headers = v
	return s
}

func (s *ListDashboardResponse) SetStatusCode(v int32) *ListDashboardResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDashboardResponse) SetBody(v *ListDashboardResponseBody) *ListDashboardResponse {
	s.Body = v
	return s
}

type ListDomainsRequest struct {
	// The domain name that is used to match custom domain names. For example, if you set domainName to `example.com`, the matched domain names are `a.example.com` and `b.example.com`.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"domainName,omitempty" xml:"domainName,omitempty"`
	// The line from which the query starts. Default value: 0.
	//
	// example:
	//
	// 0
	Offset *int32 `json:"offset,omitempty" xml:"offset,omitempty"`
	// The number of entries per page. Default value: 500. Maximum value: 500.
	//
	// example:
	//
	// 10
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDomainsRequest) GoString() string {
	return s.String()
}

func (s *ListDomainsRequest) SetDomainName(v string) *ListDomainsRequest {
	s.DomainName = &v
	return s
}

func (s *ListDomainsRequest) SetOffset(v int32) *ListDomainsRequest {
	s.Offset = &v
	return s
}

func (s *ListDomainsRequest) SetSize(v int32) *ListDomainsRequest {
	s.Size = &v
	return s
}

type ListDomainsResponseBody struct {
	// The number of domain names that are returned on the current page.
	//
	// example:
	//
	// 1
	Count *int64 `json:"count,omitempty" xml:"count,omitempty"`
	// The domain names.
	Domains []*string `json:"domains,omitempty" xml:"domains,omitempty" type:"Repeated"`
	// The total number of domain names that are returned.
	//
	// example:
	//
	// 1
	Total *int64 `json:"total,omitempty" xml:"total,omitempty"`
}

func (s ListDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *ListDomainsResponseBody) SetCount(v int64) *ListDomainsResponseBody {
	s.Count = &v
	return s
}

func (s *ListDomainsResponseBody) SetDomains(v []*string) *ListDomainsResponseBody {
	s.Domains = v
	return s
}

func (s *ListDomainsResponseBody) SetTotal(v int64) *ListDomainsResponseBody {
	s.Total = &v
	return s
}

type ListDomainsResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDomainsResponse) GoString() string {
	return s.String()
}

func (s *ListDomainsResponse) SetHeaders(v map[string]*string) *ListDomainsResponse {
	s.Headers = v
	return s
}

func (s *ListDomainsResponse) SetStatusCode(v int32) *ListDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDomainsResponse) SetBody(v *ListDomainsResponseBody) *ListDomainsResponse {
	s.Body = v
	return s
}

type ListDownloadJobsRequest struct {
	// example:
	//
	// ali-test-logstore
	Logstore *string `json:"logstore,omitempty" xml:"logstore,omitempty"`
	// example:
	//
	// 0
	Offset *int64 `json:"offset,omitempty" xml:"offset,omitempty"`
	// example:
	//
	// 10
	Size *int64 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListDownloadJobsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDownloadJobsRequest) GoString() string {
	return s.String()
}

func (s *ListDownloadJobsRequest) SetLogstore(v string) *ListDownloadJobsRequest {
	s.Logstore = &v
	return s
}

func (s *ListDownloadJobsRequest) SetOffset(v int64) *ListDownloadJobsRequest {
	s.Offset = &v
	return s
}

func (s *ListDownloadJobsRequest) SetSize(v int64) *ListDownloadJobsRequest {
	s.Size = &v
	return s
}

type ListDownloadJobsResponseBody struct {
	// example:
	//
	// 10
	Count *int32 `json:"count,omitempty" xml:"count,omitempty"`
	// The log download tasks.
	Results []*ListDownloadJobsResponseBodyResults `json:"results,omitempty" xml:"results,omitempty" type:"Repeated"`
	// example:
	//
	// 10
	Total *int32 `json:"total,omitempty" xml:"total,omitempty"`
}

func (s ListDownloadJobsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDownloadJobsResponseBody) GoString() string {
	return s.String()
}

func (s *ListDownloadJobsResponseBody) SetCount(v int32) *ListDownloadJobsResponseBody {
	s.Count = &v
	return s
}

func (s *ListDownloadJobsResponseBody) SetResults(v []*ListDownloadJobsResponseBodyResults) *ListDownloadJobsResponseBody {
	s.Results = v
	return s
}

func (s *ListDownloadJobsResponseBody) SetTotal(v int32) *ListDownloadJobsResponseBody {
	s.Total = &v
	return s
}

type ListDownloadJobsResponseBodyResults struct {
	// 下载配置
	Configuration *ListDownloadJobsResponseBodyResultsConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty" type:"Struct"`
	// example:
	//
	// 1722411060
	CreateTime *string `json:"createTime,omitempty" xml:"createTime,omitempty"`
	// 任务描述
	//
	// example:
	//
	// a download job
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// 任务显示名称
	//
	// example:
	//
	// download-123
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// 任务执行细节
	ExecutionDetails *ListDownloadJobsResponseBodyResultsExecutionDetails `json:"executionDetails,omitempty" xml:"executionDetails,omitempty" type:"Struct"`
	// 代表资源名称的资源属性字段
	//
	// example:
	//
	// download-123
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The task status.
	//
	// example:
	//
	// running
	Status *string `json:"status,omitempty" xml:"status,omitempty"`
}

func (s ListDownloadJobsResponseBodyResults) String() string {
	return tea.Prettify(s)
}

func (s ListDownloadJobsResponseBodyResults) GoString() string {
	return s.String()
}

func (s *ListDownloadJobsResponseBodyResults) SetConfiguration(v *ListDownloadJobsResponseBodyResultsConfiguration) *ListDownloadJobsResponseBodyResults {
	s.Configuration = v
	return s
}

func (s *ListDownloadJobsResponseBodyResults) SetCreateTime(v string) *ListDownloadJobsResponseBodyResults {
	s.CreateTime = &v
	return s
}

func (s *ListDownloadJobsResponseBodyResults) SetDescription(v string) *ListDownloadJobsResponseBodyResults {
	s.Description = &v
	return s
}

func (s *ListDownloadJobsResponseBodyResults) SetDisplayName(v string) *ListDownloadJobsResponseBodyResults {
	s.DisplayName = &v
	return s
}

func (s *ListDownloadJobsResponseBodyResults) SetExecutionDetails(v *ListDownloadJobsResponseBodyResultsExecutionDetails) *ListDownloadJobsResponseBodyResults {
	s.ExecutionDetails = v
	return s
}

func (s *ListDownloadJobsResponseBodyResults) SetName(v string) *ListDownloadJobsResponseBodyResults {
	s.Name = &v
	return s
}

func (s *ListDownloadJobsResponseBodyResults) SetStatus(v string) *ListDownloadJobsResponseBodyResults {
	s.Status = &v
	return s
}

type ListDownloadJobsResponseBodyResultsConfiguration struct {
	// example:
	//
	// false
	AllowInComplete *string `json:"allowInComplete,omitempty" xml:"allowInComplete,omitempty"`
	// 起点时间戳（精确到秒）
	//
	// example:
	//
	// 1722409260
	FromTime *int64 `json:"fromTime,omitempty" xml:"fromTime,omitempty"`
	// 源logstore
	//
	// example:
	//
	// ali-test-logstore
	Logstore *string `json:"logstore,omitempty" xml:"logstore,omitempty"`
	// 是否启用powerSql
	//
	// example:
	//
	// true
	PowerSql *bool `json:"powerSql,omitempty" xml:"powerSql,omitempty"`
	// 查询语句
	//
	// example:
	//
	// 	- | select *
	Query *string `json:"query,omitempty" xml:"query,omitempty"`
	// 导出配置
	Sink *ListDownloadJobsResponseBodyResultsConfigurationSink `json:"sink,omitempty" xml:"sink,omitempty" type:"Struct"`
	// 结束时间戳（精确到秒）
	//
	// example:
	//
	// 1722411060
	ToTime *int64 `json:"toTime,omitempty" xml:"toTime,omitempty"`
}

func (s ListDownloadJobsResponseBodyResultsConfiguration) String() string {
	return tea.Prettify(s)
}

func (s ListDownloadJobsResponseBodyResultsConfiguration) GoString() string {
	return s.String()
}

func (s *ListDownloadJobsResponseBodyResultsConfiguration) SetAllowInComplete(v string) *ListDownloadJobsResponseBodyResultsConfiguration {
	s.AllowInComplete = &v
	return s
}

func (s *ListDownloadJobsResponseBodyResultsConfiguration) SetFromTime(v int64) *ListDownloadJobsResponseBodyResultsConfiguration {
	s.FromTime = &v
	return s
}

func (s *ListDownloadJobsResponseBodyResultsConfiguration) SetLogstore(v string) *ListDownloadJobsResponseBodyResultsConfiguration {
	s.Logstore = &v
	return s
}

func (s *ListDownloadJobsResponseBodyResultsConfiguration) SetPowerSql(v bool) *ListDownloadJobsResponseBodyResultsConfiguration {
	s.PowerSql = &v
	return s
}

func (s *ListDownloadJobsResponseBodyResultsConfiguration) SetQuery(v string) *ListDownloadJobsResponseBodyResultsConfiguration {
	s.Query = &v
	return s
}

func (s *ListDownloadJobsResponseBodyResultsConfiguration) SetSink(v *ListDownloadJobsResponseBodyResultsConfigurationSink) *ListDownloadJobsResponseBodyResultsConfiguration {
	s.Sink = v
	return s
}

func (s *ListDownloadJobsResponseBodyResultsConfiguration) SetToTime(v int64) *ListDownloadJobsResponseBodyResultsConfiguration {
	s.ToTime = &v
	return s
}

type ListDownloadJobsResponseBodyResultsConfigurationSink struct {
	// 对象存储桶
	//
	// example:
	//
	// ali-test-oss-bucket
	Bucket *string `json:"bucket,omitempty" xml:"bucket,omitempty"`
	// 压缩格式
	//
	// example:
	//
	// none
	CompressionType *string `json:"compressionType,omitempty" xml:"compressionType,omitempty"`
	// 下载文件格式
	//
	// example:
	//
	// csv
	ContentType *string `json:"contentType,omitempty" xml:"contentType,omitempty"`
	// example:
	//
	// download/
	Prefix *string `json:"prefix,omitempty" xml:"prefix,omitempty"`
	// 下载使用roleArn
	//
	// example:
	//
	// acs:ram::123456:role/aliyunlogimportossrole
	RoleArn *string `json:"roleArn,omitempty" xml:"roleArn,omitempty"`
	// example:
	//
	// AliyunOSS
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s ListDownloadJobsResponseBodyResultsConfigurationSink) String() string {
	return tea.Prettify(s)
}

func (s ListDownloadJobsResponseBodyResultsConfigurationSink) GoString() string {
	return s.String()
}

func (s *ListDownloadJobsResponseBodyResultsConfigurationSink) SetBucket(v string) *ListDownloadJobsResponseBodyResultsConfigurationSink {
	s.Bucket = &v
	return s
}

func (s *ListDownloadJobsResponseBodyResultsConfigurationSink) SetCompressionType(v string) *ListDownloadJobsResponseBodyResultsConfigurationSink {
	s.CompressionType = &v
	return s
}

func (s *ListDownloadJobsResponseBodyResultsConfigurationSink) SetContentType(v string) *ListDownloadJobsResponseBodyResultsConfigurationSink {
	s.ContentType = &v
	return s
}

func (s *ListDownloadJobsResponseBodyResultsConfigurationSink) SetPrefix(v string) *ListDownloadJobsResponseBodyResultsConfigurationSink {
	s.Prefix = &v
	return s
}

func (s *ListDownloadJobsResponseBodyResultsConfigurationSink) SetRoleArn(v string) *ListDownloadJobsResponseBodyResultsConfigurationSink {
	s.RoleArn = &v
	return s
}

func (s *ListDownloadJobsResponseBodyResultsConfigurationSink) SetType(v string) *ListDownloadJobsResponseBodyResultsConfigurationSink {
	s.Type = &v
	return s
}

type ListDownloadJobsResponseBodyResultsExecutionDetails struct {
	// example:
	//
	// ETASFGASDASQWDasd
	CheckSum *string `json:"checkSum,omitempty" xml:"checkSum,omitempty"`
	// 下载错误信息
	//
	// example:
	//
	// timeout
	ErrorMessage *string `json:"errorMessage,omitempty" xml:"errorMessage,omitempty"`
	// 下载执行时间
	//
	// example:
	//
	// 123
	ExecuteTime *int64 `json:"executeTime,omitempty" xml:"executeTime,omitempty"`
	// 下载结果链接
	//
	// example:
	//
	// https://sls-downloaded-xxxx.csv.gzip?Expiresxxx
	FilePath *string `json:"filePath,omitempty" xml:"filePath,omitempty"`
	// 下载文件大小
	//
	// example:
	//
	// 123456
	FileSize *int64 `json:"fileSize,omitempty" xml:"fileSize,omitempty"`
	// 下载日志条数
	//
	// example:
	//
	// 123
	LogCount *int64  `json:"logCount,omitempty" xml:"logCount,omitempty"`
	Notice   *string `json:"notice,omitempty" xml:"notice,omitempty"`
	// 下载进度
	//
	// example:
	//
	// 100
	Progress *int64 `json:"progress,omitempty" xml:"progress,omitempty"`
}

func (s ListDownloadJobsResponseBodyResultsExecutionDetails) String() string {
	return tea.Prettify(s)
}

func (s ListDownloadJobsResponseBodyResultsExecutionDetails) GoString() string {
	return s.String()
}

func (s *ListDownloadJobsResponseBodyResultsExecutionDetails) SetCheckSum(v string) *ListDownloadJobsResponseBodyResultsExecutionDetails {
	s.CheckSum = &v
	return s
}

func (s *ListDownloadJobsResponseBodyResultsExecutionDetails) SetErrorMessage(v string) *ListDownloadJobsResponseBodyResultsExecutionDetails {
	s.ErrorMessage = &v
	return s
}

func (s *ListDownloadJobsResponseBodyResultsExecutionDetails) SetExecuteTime(v int64) *ListDownloadJobsResponseBodyResultsExecutionDetails {
	s.ExecuteTime = &v
	return s
}

func (s *ListDownloadJobsResponseBodyResultsExecutionDetails) SetFilePath(v string) *ListDownloadJobsResponseBodyResultsExecutionDetails {
	s.FilePath = &v
	return s
}

func (s *ListDownloadJobsResponseBodyResultsExecutionDetails) SetFileSize(v int64) *ListDownloadJobsResponseBodyResultsExecutionDetails {
	s.FileSize = &v
	return s
}

func (s *ListDownloadJobsResponseBodyResultsExecutionDetails) SetLogCount(v int64) *ListDownloadJobsResponseBodyResultsExecutionDetails {
	s.LogCount = &v
	return s
}

func (s *ListDownloadJobsResponseBodyResultsExecutionDetails) SetNotice(v string) *ListDownloadJobsResponseBodyResultsExecutionDetails {
	s.Notice = &v
	return s
}

func (s *ListDownloadJobsResponseBodyResultsExecutionDetails) SetProgress(v int64) *ListDownloadJobsResponseBodyResultsExecutionDetails {
	s.Progress = &v
	return s
}

type ListDownloadJobsResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDownloadJobsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDownloadJobsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDownloadJobsResponse) GoString() string {
	return s.String()
}

func (s *ListDownloadJobsResponse) SetHeaders(v map[string]*string) *ListDownloadJobsResponse {
	s.Headers = v
	return s
}

func (s *ListDownloadJobsResponse) SetStatusCode(v int32) *ListDownloadJobsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDownloadJobsResponse) SetBody(v *ListDownloadJobsResponseBody) *ListDownloadJobsResponse {
	s.Body = v
	return s
}

type ListETLsRequest struct {
	Logstore *string `json:"logstore,omitempty" xml:"logstore,omitempty"`
	// example:
	//
	// 0
	Offset *int32 `json:"offset,omitempty" xml:"offset,omitempty"`
	// example:
	//
	// 10
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListETLsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListETLsRequest) GoString() string {
	return s.String()
}

func (s *ListETLsRequest) SetLogstore(v string) *ListETLsRequest {
	s.Logstore = &v
	return s
}

func (s *ListETLsRequest) SetOffset(v int32) *ListETLsRequest {
	s.Offset = &v
	return s
}

func (s *ListETLsRequest) SetSize(v int32) *ListETLsRequest {
	s.Size = &v
	return s
}

type ListETLsResponseBody struct {
	Count   *int32 `json:"count,omitempty" xml:"count,omitempty"`
	Results []*ETL `json:"results,omitempty" xml:"results,omitempty" type:"Repeated"`
	Total   *int32 `json:"total,omitempty" xml:"total,omitempty"`
}

func (s ListETLsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListETLsResponseBody) GoString() string {
	return s.String()
}

func (s *ListETLsResponseBody) SetCount(v int32) *ListETLsResponseBody {
	s.Count = &v
	return s
}

func (s *ListETLsResponseBody) SetResults(v []*ETL) *ListETLsResponseBody {
	s.Results = v
	return s
}

func (s *ListETLsResponseBody) SetTotal(v int32) *ListETLsResponseBody {
	s.Total = &v
	return s
}

type ListETLsResponse struct {
	Headers    map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListETLsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListETLsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListETLsResponse) GoString() string {
	return s.String()
}

func (s *ListETLsResponse) SetHeaders(v map[string]*string) *ListETLsResponse {
	s.Headers = v
	return s
}

func (s *ListETLsResponse) SetStatusCode(v int32) *ListETLsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListETLsResponse) SetBody(v *ListETLsResponseBody) *ListETLsResponse {
	s.Body = v
	return s
}

type ListIngestProcessorsRequest struct {
	// The display name of the ingest processor.
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// The offset. Default value: 0.
	//
	// example:
	//
	// 0
	Offset *int32 `json:"offset,omitempty" xml:"offset,omitempty"`
	// The identifier of the ingest processor.
	//
	// example:
	//
	// parse-nginx-log
	ProcessorName *string `json:"processorName,omitempty" xml:"processorName,omitempty"`
	// The number of entries. Default value: 200.
	//
	// example:
	//
	// 200
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListIngestProcessorsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListIngestProcessorsRequest) GoString() string {
	return s.String()
}

func (s *ListIngestProcessorsRequest) SetDisplayName(v string) *ListIngestProcessorsRequest {
	s.DisplayName = &v
	return s
}

func (s *ListIngestProcessorsRequest) SetOffset(v int32) *ListIngestProcessorsRequest {
	s.Offset = &v
	return s
}

func (s *ListIngestProcessorsRequest) SetProcessorName(v string) *ListIngestProcessorsRequest {
	s.ProcessorName = &v
	return s
}

func (s *ListIngestProcessorsRequest) SetSize(v int32) *ListIngestProcessorsRequest {
	s.Size = &v
	return s
}

type ListIngestProcessorsResponseBody struct {
	// The number of entries returned.
	//
	// example:
	//
	// 5
	Count *int32 `json:"count,omitempty" xml:"count,omitempty"`
	// The ingest processors that are returned.
	Processors []*IngestProcessor `json:"processors,omitempty" xml:"processors,omitempty" type:"Repeated"`
	// The total number of entries returned.
	//
	// example:
	//
	// 10
	Total *int32 `json:"total,omitempty" xml:"total,omitempty"`
}

func (s ListIngestProcessorsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListIngestProcessorsResponseBody) GoString() string {
	return s.String()
}

func (s *ListIngestProcessorsResponseBody) SetCount(v int32) *ListIngestProcessorsResponseBody {
	s.Count = &v
	return s
}

func (s *ListIngestProcessorsResponseBody) SetProcessors(v []*IngestProcessor) *ListIngestProcessorsResponseBody {
	s.Processors = v
	return s
}

func (s *ListIngestProcessorsResponseBody) SetTotal(v int32) *ListIngestProcessorsResponseBody {
	s.Total = &v
	return s
}

type ListIngestProcessorsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListIngestProcessorsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListIngestProcessorsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListIngestProcessorsResponse) GoString() string {
	return s.String()
}

func (s *ListIngestProcessorsResponse) SetHeaders(v map[string]*string) *ListIngestProcessorsResponse {
	s.Headers = v
	return s
}

func (s *ListIngestProcessorsResponse) SetStatusCode(v int32) *ListIngestProcessorsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListIngestProcessorsResponse) SetBody(v *ListIngestProcessorsResponseBody) *ListIngestProcessorsResponse {
	s.Body = v
	return s
}

type ListLogStoresRequest struct {
	// The name of the Logstore. Fuzzy match is supported. For example, if you enter test, Logstores whose name contains test are returned.
	//
	// example:
	//
	// my-logstore
	LogstoreName *string `json:"logstoreName,omitempty" xml:"logstoreName,omitempty"`
	// The type of the Logstore. Valid values: standard and query.
	//
	// 	- **standard**: Standard Logstore. This type of Logstore supports the log analysis feature and is suitable for scenarios such as real-time monitoring and interactive analysis. You can also use this type of Logstore to build a comprehensive observability system.
	//
	// 	- **query**: Query Logstore. This type of Logstore supports high-performance queries. The index traffic fee of a Query Logstore is approximately half that of a Standard Logstore. Query Logstores do not support SQL analysis. Query Logstores are suitable for scenarios in which the volume of data is large, the log retention period is long, or log analysis is not required. Log retention periods of weeks or months are considered long.
	//
	// example:
	//
	// standard
	Mode *string `json:"mode,omitempty" xml:"mode,omitempty"`
	// The line from which the query starts. Default value: 0.
	//
	// example:
	//
	// 0
	Offset *int32 `json:"offset,omitempty" xml:"offset,omitempty"`
	// The number of entries per page. Maximum value: 500. Default value: 200.
	//
	// example:
	//
	// 10
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
	// The type of the data that you want to query. Valid values:
	//
	// 	- None: logs
	//
	// 	- Metrics: metrics
	//
	// example:
	//
	// None
	TelemetryType *string `json:"telemetryType,omitempty" xml:"telemetryType,omitempty"`
}

func (s ListLogStoresRequest) String() string {
	return tea.Prettify(s)
}

func (s ListLogStoresRequest) GoString() string {
	return s.String()
}

func (s *ListLogStoresRequest) SetLogstoreName(v string) *ListLogStoresRequest {
	s.LogstoreName = &v
	return s
}

func (s *ListLogStoresRequest) SetMode(v string) *ListLogStoresRequest {
	s.Mode = &v
	return s
}

func (s *ListLogStoresRequest) SetOffset(v int32) *ListLogStoresRequest {
	s.Offset = &v
	return s
}

func (s *ListLogStoresRequest) SetSize(v int32) *ListLogStoresRequest {
	s.Size = &v
	return s
}

func (s *ListLogStoresRequest) SetTelemetryType(v string) *ListLogStoresRequest {
	s.TelemetryType = &v
	return s
}

type ListLogStoresResponseBody struct {
	// The number of entries returned on the current page.
	//
	// example:
	//
	// 2
	Count *int32 `json:"count,omitempty" xml:"count,omitempty"`
	// The Logstores that meet the query conditions.
	//
	// example:
	//
	// ["test-1","test-2"]
	Logstores []*string `json:"logstores,omitempty" xml:"logstores,omitempty" type:"Repeated"`
	// The number of the Logstores that meet the query conditions.
	//
	// example:
	//
	// 2
	Total *int32 `json:"total,omitempty" xml:"total,omitempty"`
}

func (s ListLogStoresResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListLogStoresResponseBody) GoString() string {
	return s.String()
}

func (s *ListLogStoresResponseBody) SetCount(v int32) *ListLogStoresResponseBody {
	s.Count = &v
	return s
}

func (s *ListLogStoresResponseBody) SetLogstores(v []*string) *ListLogStoresResponseBody {
	s.Logstores = v
	return s
}

func (s *ListLogStoresResponseBody) SetTotal(v int32) *ListLogStoresResponseBody {
	s.Total = &v
	return s
}

type ListLogStoresResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListLogStoresResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListLogStoresResponse) String() string {
	return tea.Prettify(s)
}

func (s ListLogStoresResponse) GoString() string {
	return s.String()
}

func (s *ListLogStoresResponse) SetHeaders(v map[string]*string) *ListLogStoresResponse {
	s.Headers = v
	return s
}

func (s *ListLogStoresResponse) SetStatusCode(v int32) *ListLogStoresResponse {
	s.StatusCode = &v
	return s
}

func (s *ListLogStoresResponse) SetBody(v *ListLogStoresResponseBody) *ListLogStoresResponse {
	s.Body = v
	return s
}

type ListLogtailPipelineConfigRequest struct {
	// The name of the Logtail pipeline configuration.
	//
	// example:
	//
	// logtail-config-sample
	ConfigName *string `json:"configName,omitempty" xml:"configName,omitempty"`
	// The name of the Logstore.
	//
	// example:
	//
	// test-logstore
	LogstoreName *string `json:"logstoreName,omitempty" xml:"logstoreName,omitempty"`
	// The line from which the query starts.
	//
	// example:
	//
	// 0
	Offset *int64 `json:"offset,omitempty" xml:"offset,omitempty"`
	// The number of Logtail pipeline configurations per page.
	//
	// example:
	//
	// 20
	Size *int64 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListLogtailPipelineConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s ListLogtailPipelineConfigRequest) GoString() string {
	return s.String()
}

func (s *ListLogtailPipelineConfigRequest) SetConfigName(v string) *ListLogtailPipelineConfigRequest {
	s.ConfigName = &v
	return s
}

func (s *ListLogtailPipelineConfigRequest) SetLogstoreName(v string) *ListLogtailPipelineConfigRequest {
	s.LogstoreName = &v
	return s
}

func (s *ListLogtailPipelineConfigRequest) SetOffset(v int64) *ListLogtailPipelineConfigRequest {
	s.Offset = &v
	return s
}

func (s *ListLogtailPipelineConfigRequest) SetSize(v int64) *ListLogtailPipelineConfigRequest {
	s.Size = &v
	return s
}

type ListLogtailPipelineConfigResponseBody struct {
	// The Logtail pipeline configurations that are returned on the current page.
	Configs []*string `json:"configs,omitempty" xml:"configs,omitempty" type:"Repeated"`
	// The number of Logtail pipeline configurations that are returned on the current page.
	//
	// example:
	//
	// 10
	Count *int32 `json:"count,omitempty" xml:"count,omitempty"`
	// The total number of Logtail pipeline configurations in the current project.
	//
	// example:
	//
	// 20
	Total *int32 `json:"total,omitempty" xml:"total,omitempty"`
}

func (s ListLogtailPipelineConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListLogtailPipelineConfigResponseBody) GoString() string {
	return s.String()
}

func (s *ListLogtailPipelineConfigResponseBody) SetConfigs(v []*string) *ListLogtailPipelineConfigResponseBody {
	s.Configs = v
	return s
}

func (s *ListLogtailPipelineConfigResponseBody) SetCount(v int32) *ListLogtailPipelineConfigResponseBody {
	s.Count = &v
	return s
}

func (s *ListLogtailPipelineConfigResponseBody) SetTotal(v int32) *ListLogtailPipelineConfigResponseBody {
	s.Total = &v
	return s
}

type ListLogtailPipelineConfigResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListLogtailPipelineConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListLogtailPipelineConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s ListLogtailPipelineConfigResponse) GoString() string {
	return s.String()
}

func (s *ListLogtailPipelineConfigResponse) SetHeaders(v map[string]*string) *ListLogtailPipelineConfigResponse {
	s.Headers = v
	return s
}

func (s *ListLogtailPipelineConfigResponse) SetStatusCode(v int32) *ListLogtailPipelineConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *ListLogtailPipelineConfigResponse) SetBody(v *ListLogtailPipelineConfigResponseBody) *ListLogtailPipelineConfigResponse {
	s.Body = v
	return s
}

type ListMachineGroupRequest struct {
	// The name of the machine group. This parameter is used to filter machine groups. Partial match is supported.
	//
	// example:
	//
	// test-machine-group
	GroupName *string `json:"groupName,omitempty" xml:"groupName,omitempty"`
	// The line from which the query starts. Default value: 0.
	//
	// example:
	//
	// 1
	Offset *int32 `json:"offset,omitempty" xml:"offset,omitempty"`
	// The number of entries per page. Maximum value: 500.
	//
	// example:
	//
	// 10
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListMachineGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ListMachineGroupRequest) GoString() string {
	return s.String()
}

func (s *ListMachineGroupRequest) SetGroupName(v string) *ListMachineGroupRequest {
	s.GroupName = &v
	return s
}

func (s *ListMachineGroupRequest) SetOffset(v int32) *ListMachineGroupRequest {
	s.Offset = &v
	return s
}

func (s *ListMachineGroupRequest) SetSize(v int32) *ListMachineGroupRequest {
	s.Size = &v
	return s
}

type ListMachineGroupResponseBody struct {
	// The number of machine groups that are returned on the current page.
	//
	// example:
	//
	// 2
	Count *int32 `json:"count,omitempty" xml:"count,omitempty"`
	// The machine groups that meet the query conditions.
	//
	// example:
	//
	// [ "test-machine-group-1", "test-machine-group-2" ]
	Machinegroups []*string `json:"machinegroups,omitempty" xml:"machinegroups,omitempty" type:"Repeated"`
	// The total number of machine groups that meet the query conditions.
	//
	// example:
	//
	// 2
	Total *int32 `json:"total,omitempty" xml:"total,omitempty"`
}

func (s ListMachineGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListMachineGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ListMachineGroupResponseBody) SetCount(v int32) *ListMachineGroupResponseBody {
	s.Count = &v
	return s
}

func (s *ListMachineGroupResponseBody) SetMachinegroups(v []*string) *ListMachineGroupResponseBody {
	s.Machinegroups = v
	return s
}

func (s *ListMachineGroupResponseBody) SetTotal(v int32) *ListMachineGroupResponseBody {
	s.Total = &v
	return s
}

type ListMachineGroupResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListMachineGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListMachineGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ListMachineGroupResponse) GoString() string {
	return s.String()
}

func (s *ListMachineGroupResponse) SetHeaders(v map[string]*string) *ListMachineGroupResponse {
	s.Headers = v
	return s
}

func (s *ListMachineGroupResponse) SetStatusCode(v int32) *ListMachineGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ListMachineGroupResponse) SetBody(v *ListMachineGroupResponseBody) *ListMachineGroupResponse {
	s.Body = v
	return s
}

type ListMachinesRequest struct {
	// The line from which the query starts. Default value: 0.
	//
	// example:
	//
	// 0
	Offset *int32 `json:"offset,omitempty" xml:"offset,omitempty"`
	// The number of entries per page. Default value: 100. Maximum value: 500.
	//
	// example:
	//
	// 10
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListMachinesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListMachinesRequest) GoString() string {
	return s.String()
}

func (s *ListMachinesRequest) SetOffset(v int32) *ListMachinesRequest {
	s.Offset = &v
	return s
}

func (s *ListMachinesRequest) SetSize(v int32) *ListMachinesRequest {
	s.Size = &v
	return s
}

type ListMachinesResponseBody struct {
	// The number of machines that are returned on the current page.
	//
	// example:
	//
	// 3
	Count *int32 `json:"count,omitempty" xml:"count,omitempty"`
	// The machines that are returned.
	Machines []*Machine `json:"machines,omitempty" xml:"machines,omitempty" type:"Repeated"`
	// The total number of machines.
	//
	// example:
	//
	// 8
	Total *int32 `json:"total,omitempty" xml:"total,omitempty"`
}

func (s ListMachinesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListMachinesResponseBody) GoString() string {
	return s.String()
}

func (s *ListMachinesResponseBody) SetCount(v int32) *ListMachinesResponseBody {
	s.Count = &v
	return s
}

func (s *ListMachinesResponseBody) SetMachines(v []*Machine) *ListMachinesResponseBody {
	s.Machines = v
	return s
}

func (s *ListMachinesResponseBody) SetTotal(v int32) *ListMachinesResponseBody {
	s.Total = &v
	return s
}

type ListMachinesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListMachinesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListMachinesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListMachinesResponse) GoString() string {
	return s.String()
}

func (s *ListMachinesResponse) SetHeaders(v map[string]*string) *ListMachinesResponse {
	s.Headers = v
	return s
}

func (s *ListMachinesResponse) SetStatusCode(v int32) *ListMachinesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListMachinesResponse) SetBody(v *ListMachinesResponseBody) *ListMachinesResponse {
	s.Body = v
	return s
}

type ListMetricStoresRequest struct {
	// The type of the Metricstore. For example, you can set the parameter to standard to query Standard Metricstores.
	//
	// example:
	//
	// standard
	Mode *string `json:"mode,omitempty" xml:"mode,omitempty"`
	// The name of the Metricstore. Fuzzy search is supported. If you do not specify this parameter, all Metricstores are involved.
	//
	// example:
	//
	// metric_store
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The start position of the query.
	//
	// example:
	//
	// 0
	Offset *int32 `json:"offset,omitempty" xml:"offset,omitempty"`
	// The number of entries per page.
	//
	// example:
	//
	// 500
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListMetricStoresRequest) String() string {
	return tea.Prettify(s)
}

func (s ListMetricStoresRequest) GoString() string {
	return s.String()
}

func (s *ListMetricStoresRequest) SetMode(v string) *ListMetricStoresRequest {
	s.Mode = &v
	return s
}

func (s *ListMetricStoresRequest) SetName(v string) *ListMetricStoresRequest {
	s.Name = &v
	return s
}

func (s *ListMetricStoresRequest) SetOffset(v int32) *ListMetricStoresRequest {
	s.Offset = &v
	return s
}

func (s *ListMetricStoresRequest) SetSize(v int32) *ListMetricStoresRequest {
	s.Size = &v
	return s
}

type ListMetricStoresResponseBody struct {
	// The total number of entries returned.
	//
	// example:
	//
	// 10
	Count *int32 `json:"count,omitempty" xml:"count,omitempty"`
	// The names of the Metricstores.
	Metricstores []*string `json:"metricstores,omitempty" xml:"metricstores,omitempty" type:"Repeated"`
	// The total number of queried Metricstores.
	//
	// example:
	//
	// 100
	Total *int32 `json:"total,omitempty" xml:"total,omitempty"`
}

func (s ListMetricStoresResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListMetricStoresResponseBody) GoString() string {
	return s.String()
}

func (s *ListMetricStoresResponseBody) SetCount(v int32) *ListMetricStoresResponseBody {
	s.Count = &v
	return s
}

func (s *ListMetricStoresResponseBody) SetMetricstores(v []*string) *ListMetricStoresResponseBody {
	s.Metricstores = v
	return s
}

func (s *ListMetricStoresResponseBody) SetTotal(v int32) *ListMetricStoresResponseBody {
	s.Total = &v
	return s
}

type ListMetricStoresResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListMetricStoresResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListMetricStoresResponse) String() string {
	return tea.Prettify(s)
}

func (s ListMetricStoresResponse) GoString() string {
	return s.String()
}

func (s *ListMetricStoresResponse) SetHeaders(v map[string]*string) *ListMetricStoresResponse {
	s.Headers = v
	return s
}

func (s *ListMetricStoresResponse) SetStatusCode(v int32) *ListMetricStoresResponse {
	s.StatusCode = &v
	return s
}

func (s *ListMetricStoresResponse) SetBody(v *ListMetricStoresResponseBody) *ListMetricStoresResponse {
	s.Body = v
	return s
}

type ListOSSExportsRequest struct {
	Logstore *string `json:"logstore,omitempty" xml:"logstore,omitempty"`
	// example:
	//
	// 0
	Offset *int32 `json:"offset,omitempty" xml:"offset,omitempty"`
	// The number of entries to return. Default value: 10.
	//
	// example:
	//
	// 100
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListOSSExportsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListOSSExportsRequest) GoString() string {
	return s.String()
}

func (s *ListOSSExportsRequest) SetLogstore(v string) *ListOSSExportsRequest {
	s.Logstore = &v
	return s
}

func (s *ListOSSExportsRequest) SetOffset(v int32) *ListOSSExportsRequest {
	s.Offset = &v
	return s
}

func (s *ListOSSExportsRequest) SetSize(v int32) *ListOSSExportsRequest {
	s.Size = &v
	return s
}

type ListOSSExportsResponseBody struct {
	// example:
	//
	// 2
	Count   *int32       `json:"count,omitempty" xml:"count,omitempty"`
	Results []*OSSExport `json:"results,omitempty" xml:"results,omitempty" type:"Repeated"`
	// example:
	//
	// 10
	Total *int32 `json:"total,omitempty" xml:"total,omitempty"`
}

func (s ListOSSExportsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListOSSExportsResponseBody) GoString() string {
	return s.String()
}

func (s *ListOSSExportsResponseBody) SetCount(v int32) *ListOSSExportsResponseBody {
	s.Count = &v
	return s
}

func (s *ListOSSExportsResponseBody) SetResults(v []*OSSExport) *ListOSSExportsResponseBody {
	s.Results = v
	return s
}

func (s *ListOSSExportsResponseBody) SetTotal(v int32) *ListOSSExportsResponseBody {
	s.Total = &v
	return s
}

type ListOSSExportsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListOSSExportsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListOSSExportsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListOSSExportsResponse) GoString() string {
	return s.String()
}

func (s *ListOSSExportsResponse) SetHeaders(v map[string]*string) *ListOSSExportsResponse {
	s.Headers = v
	return s
}

func (s *ListOSSExportsResponse) SetStatusCode(v int32) *ListOSSExportsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListOSSExportsResponse) SetBody(v *ListOSSExportsResponseBody) *ListOSSExportsResponse {
	s.Body = v
	return s
}

type ListOSSHDFSExportsRequest struct {
	Logstore *string `json:"logstore,omitempty" xml:"logstore,omitempty"`
	// example:
	//
	// 0
	Offset *int32 `json:"offset,omitempty" xml:"offset,omitempty"`
	// The number of entries to return. Default value: 10.
	//
	// example:
	//
	// 100
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListOSSHDFSExportsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListOSSHDFSExportsRequest) GoString() string {
	return s.String()
}

func (s *ListOSSHDFSExportsRequest) SetLogstore(v string) *ListOSSHDFSExportsRequest {
	s.Logstore = &v
	return s
}

func (s *ListOSSHDFSExportsRequest) SetOffset(v int32) *ListOSSHDFSExportsRequest {
	s.Offset = &v
	return s
}

func (s *ListOSSHDFSExportsRequest) SetSize(v int32) *ListOSSHDFSExportsRequest {
	s.Size = &v
	return s
}

type ListOSSHDFSExportsResponseBody struct {
	// example:
	//
	// 2
	Count   *int32       `json:"count,omitempty" xml:"count,omitempty"`
	Results []*OSSExport `json:"results,omitempty" xml:"results,omitempty" type:"Repeated"`
	// example:
	//
	// 10
	Total *int32 `json:"total,omitempty" xml:"total,omitempty"`
}

func (s ListOSSHDFSExportsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListOSSHDFSExportsResponseBody) GoString() string {
	return s.String()
}

func (s *ListOSSHDFSExportsResponseBody) SetCount(v int32) *ListOSSHDFSExportsResponseBody {
	s.Count = &v
	return s
}

func (s *ListOSSHDFSExportsResponseBody) SetResults(v []*OSSExport) *ListOSSHDFSExportsResponseBody {
	s.Results = v
	return s
}

func (s *ListOSSHDFSExportsResponseBody) SetTotal(v int32) *ListOSSHDFSExportsResponseBody {
	s.Total = &v
	return s
}

type ListOSSHDFSExportsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListOSSHDFSExportsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListOSSHDFSExportsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListOSSHDFSExportsResponse) GoString() string {
	return s.String()
}

func (s *ListOSSHDFSExportsResponse) SetHeaders(v map[string]*string) *ListOSSHDFSExportsResponse {
	s.Headers = v
	return s
}

func (s *ListOSSHDFSExportsResponse) SetStatusCode(v int32) *ListOSSHDFSExportsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListOSSHDFSExportsResponse) SetBody(v *ListOSSHDFSExportsResponseBody) *ListOSSHDFSExportsResponse {
	s.Body = v
	return s
}

type ListOSSIngestionsRequest struct {
	Logstore *string `json:"logstore,omitempty" xml:"logstore,omitempty"`
	// example:
	//
	// 0
	Offset *int32 `json:"offset,omitempty" xml:"offset,omitempty"`
	// example:
	//
	// 10
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListOSSIngestionsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListOSSIngestionsRequest) GoString() string {
	return s.String()
}

func (s *ListOSSIngestionsRequest) SetLogstore(v string) *ListOSSIngestionsRequest {
	s.Logstore = &v
	return s
}

func (s *ListOSSIngestionsRequest) SetOffset(v int32) *ListOSSIngestionsRequest {
	s.Offset = &v
	return s
}

func (s *ListOSSIngestionsRequest) SetSize(v int32) *ListOSSIngestionsRequest {
	s.Size = &v
	return s
}

type ListOSSIngestionsResponseBody struct {
	// The number of OSS data import jobs that are returned.
	//
	// example:
	//
	// 10
	Count *int32 `json:"count,omitempty" xml:"count,omitempty"`
	// The OSS data import jobs.
	Results []*OSSIngestion `json:"results,omitempty" xml:"results,omitempty" type:"Repeated"`
	// The total number of OSS data import jobs in the project.
	//
	// example:
	//
	// 80
	Total *int32 `json:"total,omitempty" xml:"total,omitempty"`
}

func (s ListOSSIngestionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListOSSIngestionsResponseBody) GoString() string {
	return s.String()
}

func (s *ListOSSIngestionsResponseBody) SetCount(v int32) *ListOSSIngestionsResponseBody {
	s.Count = &v
	return s
}

func (s *ListOSSIngestionsResponseBody) SetResults(v []*OSSIngestion) *ListOSSIngestionsResponseBody {
	s.Results = v
	return s
}

func (s *ListOSSIngestionsResponseBody) SetTotal(v int32) *ListOSSIngestionsResponseBody {
	s.Total = &v
	return s
}

type ListOSSIngestionsResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListOSSIngestionsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListOSSIngestionsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListOSSIngestionsResponse) GoString() string {
	return s.String()
}

func (s *ListOSSIngestionsResponse) SetHeaders(v map[string]*string) *ListOSSIngestionsResponse {
	s.Headers = v
	return s
}

func (s *ListOSSIngestionsResponse) SetStatusCode(v int32) *ListOSSIngestionsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListOSSIngestionsResponse) SetBody(v *ListOSSIngestionsResponseBody) *ListOSSIngestionsResponse {
	s.Body = v
	return s
}

type ListProjectRequest struct {
	FetchQuota *bool `json:"fetchQuota,omitempty" xml:"fetchQuota,omitempty"`
	// The line from which the query starts. Default value: 0.
	//
	// example:
	//
	// 0
	Offset *int32 `json:"offset,omitempty" xml:"offset,omitempty"`
	// The name of the project.
	//
	// example:
	//
	// ali-test-project
	ProjectName     *string `json:"projectName,omitempty" xml:"projectName,omitempty"`
	ResourceGroupId *string `json:"resourceGroupId,omitempty" xml:"resourceGroupId,omitempty"`
	// The number of entries per page. Default value: 100. This operation can return up to 500 projects.
	//
	// example:
	//
	// 10
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListProjectRequest) String() string {
	return tea.Prettify(s)
}

func (s ListProjectRequest) GoString() string {
	return s.String()
}

func (s *ListProjectRequest) SetFetchQuota(v bool) *ListProjectRequest {
	s.FetchQuota = &v
	return s
}

func (s *ListProjectRequest) SetOffset(v int32) *ListProjectRequest {
	s.Offset = &v
	return s
}

func (s *ListProjectRequest) SetProjectName(v string) *ListProjectRequest {
	s.ProjectName = &v
	return s
}

func (s *ListProjectRequest) SetResourceGroupId(v string) *ListProjectRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListProjectRequest) SetSize(v int32) *ListProjectRequest {
	s.Size = &v
	return s
}

type ListProjectResponseBody struct {
	// The number of returned projects on the current page.
	//
	// example:
	//
	// 2
	Count *int64 `json:"count,omitempty" xml:"count,omitempty"`
	// The projects that meet the query conditions.
	Projects []*Project `json:"projects,omitempty" xml:"projects,omitempty" type:"Repeated"`
	// The total number of projects that meet the query conditions.
	//
	// example:
	//
	// 11
	Total *int64 `json:"total,omitempty" xml:"total,omitempty"`
}

func (s ListProjectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListProjectResponseBody) GoString() string {
	return s.String()
}

func (s *ListProjectResponseBody) SetCount(v int64) *ListProjectResponseBody {
	s.Count = &v
	return s
}

func (s *ListProjectResponseBody) SetProjects(v []*Project) *ListProjectResponseBody {
	s.Projects = v
	return s
}

func (s *ListProjectResponseBody) SetTotal(v int64) *ListProjectResponseBody {
	s.Total = &v
	return s
}

type ListProjectResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListProjectResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s ListProjectResponse) GoString() string {
	return s.String()
}

func (s *ListProjectResponse) SetHeaders(v map[string]*string) *ListProjectResponse {
	s.Headers = v
	return s
}

func (s *ListProjectResponse) SetStatusCode(v int32) *ListProjectResponse {
	s.StatusCode = &v
	return s
}

func (s *ListProjectResponse) SetBody(v *ListProjectResponseBody) *ListProjectResponse {
	s.Body = v
	return s
}

type ListSavedSearchRequest struct {
	// The line from which the query starts. Default value: 0.
	//
	// example:
	//
	// 0
	Offset *int32 `json:"offset,omitempty" xml:"offset,omitempty"`
	// The number of entries per page. Maximum value: 500.
	//
	// example:
	//
	// 10
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListSavedSearchRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSavedSearchRequest) GoString() string {
	return s.String()
}

func (s *ListSavedSearchRequest) SetOffset(v int32) *ListSavedSearchRequest {
	s.Offset = &v
	return s
}

func (s *ListSavedSearchRequest) SetSize(v int32) *ListSavedSearchRequest {
	s.Size = &v
	return s
}

type ListSavedSearchResponseBody struct {
	// The number of saved searches returned on the current page.
	//
	// example:
	//
	// 4
	Count *int32 `json:"count,omitempty" xml:"count,omitempty"`
	// The saved searches.
	//
	// example:
	//
	// [ "test-1", "test-2" ]
	SavedsearchItems []*SavedSearch `json:"savedsearchItems,omitempty" xml:"savedsearchItems,omitempty" type:"Repeated"`
	// The total number of saved searches that meet the query conditions.
	//
	// example:
	//
	// 4
	Total *int32 `json:"total,omitempty" xml:"total,omitempty"`
}

func (s ListSavedSearchResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSavedSearchResponseBody) GoString() string {
	return s.String()
}

func (s *ListSavedSearchResponseBody) SetCount(v int32) *ListSavedSearchResponseBody {
	s.Count = &v
	return s
}

func (s *ListSavedSearchResponseBody) SetSavedsearchItems(v []*SavedSearch) *ListSavedSearchResponseBody {
	s.SavedsearchItems = v
	return s
}

func (s *ListSavedSearchResponseBody) SetTotal(v int32) *ListSavedSearchResponseBody {
	s.Total = &v
	return s
}

type ListSavedSearchResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListSavedSearchResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListSavedSearchResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSavedSearchResponse) GoString() string {
	return s.String()
}

func (s *ListSavedSearchResponse) SetHeaders(v map[string]*string) *ListSavedSearchResponse {
	s.Headers = v
	return s
}

func (s *ListSavedSearchResponse) SetStatusCode(v int32) *ListSavedSearchResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSavedSearchResponse) SetBody(v *ListSavedSearchResponseBody) *ListSavedSearchResponse {
	s.Body = v
	return s
}

type ListScheduledSQLsRequest struct {
	// The name of the Logstore.
	//
	// example:
	//
	// ali-test-logstore
	Logstore *string `json:"logstore,omitempty" xml:"logstore,omitempty"`
	// example:
	//
	// 0
	Offset *int64 `json:"offset,omitempty" xml:"offset,omitempty"`
	// The number of entries to return. Default value: 10.
	//
	// example:
	//
	// 100
	Size *int64 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s ListScheduledSQLsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListScheduledSQLsRequest) GoString() string {
	return s.String()
}

func (s *ListScheduledSQLsRequest) SetLogstore(v string) *ListScheduledSQLsRequest {
	s.Logstore = &v
	return s
}

func (s *ListScheduledSQLsRequest) SetOffset(v int64) *ListScheduledSQLsRequest {
	s.Offset = &v
	return s
}

func (s *ListScheduledSQLsRequest) SetSize(v int64) *ListScheduledSQLsRequest {
	s.Size = &v
	return s
}

type ListScheduledSQLsResponseBody struct {
	// example:
	//
	// 10
	Count   *int32          `json:"count,omitempty" xml:"count,omitempty"`
	Results []*ScheduledSQL `json:"results,omitempty" xml:"results,omitempty" type:"Repeated"`
	// example:
	//
	// 80
	Total *int32 `json:"total,omitempty" xml:"total,omitempty"`
}

func (s ListScheduledSQLsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListScheduledSQLsResponseBody) GoString() string {
	return s.String()
}

func (s *ListScheduledSQLsResponseBody) SetCount(v int32) *ListScheduledSQLsResponseBody {
	s.Count = &v
	return s
}

func (s *ListScheduledSQLsResponseBody) SetResults(v []*ScheduledSQL) *ListScheduledSQLsResponseBody {
	s.Results = v
	return s
}

func (s *ListScheduledSQLsResponseBody) SetTotal(v int32) *ListScheduledSQLsResponseBody {
	s.Total = &v
	return s
}

type ListScheduledSQLsResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListScheduledSQLsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListScheduledSQLsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListScheduledSQLsResponse) GoString() string {
	return s.String()
}

func (s *ListScheduledSQLsResponse) SetHeaders(v map[string]*string) *ListScheduledSQLsResponse {
	s.Headers = v
	return s
}

func (s *ListScheduledSQLsResponse) SetStatusCode(v int32) *ListScheduledSQLsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListScheduledSQLsResponse) SetBody(v *ListScheduledSQLsResponseBody) *ListScheduledSQLsResponse {
	s.Body = v
	return s
}

type ListShardsResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       []*Shard           `json:"body,omitempty" xml:"body,omitempty" type:"Repeated"`
}

func (s ListShardsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListShardsResponse) GoString() string {
	return s.String()
}

func (s *ListShardsResponse) SetHeaders(v map[string]*string) *ListShardsResponse {
	s.Headers = v
	return s
}

func (s *ListShardsResponse) SetStatusCode(v int32) *ListShardsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListShardsResponse) SetBody(v []*Shard) *ListShardsResponse {
	s.Body = v
	return s
}

type ListStoreViewsRequest struct {
	// The dataset name that is used for fuzzy match.
	//
	// example:
	//
	// my_storeview
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The offset of the datasets to return. Default value: 0.
	//
	// example:
	//
	// 0
	Offset *int32 `json:"offset,omitempty" xml:"offset,omitempty"`
	// The number of datasets to return. Default value: 100.
	//
	// example:
	//
	// 100
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
	// The type of the datasets to return. By default, datasets are not filtered by type.
	//
	// Valid values:
	//
	// 	- metricstore
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// 	- logstore
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// example:
	//
	// logstore
	StoreType *string `json:"storeType,omitempty" xml:"storeType,omitempty"`
}

func (s ListStoreViewsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListStoreViewsRequest) GoString() string {
	return s.String()
}

func (s *ListStoreViewsRequest) SetName(v string) *ListStoreViewsRequest {
	s.Name = &v
	return s
}

func (s *ListStoreViewsRequest) SetOffset(v int32) *ListStoreViewsRequest {
	s.Offset = &v
	return s
}

func (s *ListStoreViewsRequest) SetSize(v int32) *ListStoreViewsRequest {
	s.Size = &v
	return s
}

func (s *ListStoreViewsRequest) SetStoreType(v string) *ListStoreViewsRequest {
	s.StoreType = &v
	return s
}

type ListStoreViewsResponseBody struct {
	// The number of returned datasets.
	//
	// example:
	//
	// 100
	Count *int32 `json:"count,omitempty" xml:"count,omitempty"`
	// The dataset names.
	Storeviews []*string `json:"storeviews,omitempty" xml:"storeviews,omitempty" type:"Repeated"`
	// The total number of datasets in the project.
	//
	// example:
	//
	// 100
	Total *int32 `json:"total,omitempty" xml:"total,omitempty"`
}

func (s ListStoreViewsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListStoreViewsResponseBody) GoString() string {
	return s.String()
}

func (s *ListStoreViewsResponseBody) SetCount(v int32) *ListStoreViewsResponseBody {
	s.Count = &v
	return s
}

func (s *ListStoreViewsResponseBody) SetStoreviews(v []*string) *ListStoreViewsResponseBody {
	s.Storeviews = v
	return s
}

func (s *ListStoreViewsResponseBody) SetTotal(v int32) *ListStoreViewsResponseBody {
	s.Total = &v
	return s
}

type ListStoreViewsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListStoreViewsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListStoreViewsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListStoreViewsResponse) GoString() string {
	return s.String()
}

func (s *ListStoreViewsResponse) SetHeaders(v map[string]*string) *ListStoreViewsResponse {
	s.Headers = v
	return s
}

func (s *ListStoreViewsResponse) SetStatusCode(v int32) *ListStoreViewsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListStoreViewsResponse) SetBody(v *ListStoreViewsResponseBody) *ListStoreViewsResponse {
	s.Body = v
	return s
}

type ListTagResourcesRequest struct {
	// The IDs of the resources whose tags you want to query. You must specify at least one of resourceId and tags.
	ResourceId []*string `json:"resourceId,omitempty" xml:"resourceId,omitempty" type:"Repeated"`
	// The type of the resource. Valid values:
	//
	// 	- project
	//
	// 	- logstore
	//
	// 	- dashboard
	//
	// 	- machinegroup
	//
	// 	- logtailconfig
	//
	// This parameter is required.
	//
	// example:
	//
	// project
	ResourceType *string `json:"resourceType,omitempty" xml:"resourceType,omitempty"`
	// The tags that you want to use to filter resources based on exact match. Each tag is a key-value pair. You must specify at least one of resourceId and tags.
	//
	// You can enter up to 20 tags.
	Tags []*ListTagResourcesRequestTags `json:"tags,omitempty" xml:"tags,omitempty" type:"Repeated"`
}

func (s ListTagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequest) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequest) SetResourceId(v []*string) *ListTagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *ListTagResourcesRequest) SetResourceType(v string) *ListTagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesRequest) SetTags(v []*ListTagResourcesRequestTags) *ListTagResourcesRequest {
	s.Tags = v
	return s
}

type ListTagResourcesRequestTags struct {
	// The key of the tag that you want to use to filter resources. For example, if you set the key to `"test-key"`, only resources to which the key is added are returned.``
	//
	// This parameter is required.
	//
	// example:
	//
	// key1
	Key *string `json:"key,omitempty" xml:"key,omitempty"`
	// The value of the tag that you want to use to filter resources. If you set the value to null, resources are filtered based only on the key of the tag.
	//
	// if can be null:
	// true
	//
	// example:
	//
	// value1
	Value *string `json:"value,omitempty" xml:"value,omitempty"`
}

func (s ListTagResourcesRequestTags) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequestTags) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequestTags) SetKey(v string) *ListTagResourcesRequestTags {
	s.Key = &v
	return s
}

func (s *ListTagResourcesRequestTags) SetValue(v string) *ListTagResourcesRequestTags {
	s.Value = &v
	return s
}

type ListTagResourcesShrinkRequest struct {
	// The IDs of the resources whose tags you want to query. You must specify at least one of resourceId and tags.
	ResourceIdShrink *string `json:"resourceId,omitempty" xml:"resourceId,omitempty"`
	// The type of the resource. Valid values:
	//
	// 	- project
	//
	// 	- logstore
	//
	// 	- dashboard
	//
	// 	- machinegroup
	//
	// 	- logtailconfig
	//
	// This parameter is required.
	//
	// example:
	//
	// project
	ResourceType *string `json:"resourceType,omitempty" xml:"resourceType,omitempty"`
	// The tags that you want to use to filter resources based on exact match. Each tag is a key-value pair. You must specify at least one of resourceId and tags.
	//
	// You can enter up to 20 tags.
	TagsShrink *string `json:"tags,omitempty" xml:"tags,omitempty"`
}

func (s ListTagResourcesShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesShrinkRequest) GoString() string {
	return s.String()
}

func (s *ListTagResourcesShrinkRequest) SetResourceIdShrink(v string) *ListTagResourcesShrinkRequest {
	s.ResourceIdShrink = &v
	return s
}

func (s *ListTagResourcesShrinkRequest) SetResourceType(v string) *ListTagResourcesShrinkRequest {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesShrinkRequest) SetTagsShrink(v string) *ListTagResourcesShrinkRequest {
	s.TagsShrink = &v
	return s
}

type ListTagResourcesResponseBody struct {
	// The pagination token that is used in the next request to retrieve a new page of results.
	//
	// example:
	//
	// caeba0bbb2be03f84eb48b699f0a4883
	NextToken *string `json:"nextToken,omitempty" xml:"nextToken,omitempty"`
	// The returned tags.
	TagResources []*ListTagResourcesResponseBodyTagResources `json:"tagResources,omitempty" xml:"tagResources,omitempty" type:"Repeated"`
}

func (s ListTagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBody) SetNextToken(v string) *ListTagResourcesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetTagResources(v []*ListTagResourcesResponseBodyTagResources) *ListTagResourcesResponseBody {
	s.TagResources = v
	return s
}

type ListTagResourcesResponseBodyTagResources struct {
	// The ID of the resource.
	//
	// example:
	//
	// ali-test-project
	ResourceId *string `json:"resourceId,omitempty" xml:"resourceId,omitempty"`
	// The type of the resource.
	//
	// example:
	//
	// project
	ResourceType *string `json:"resourceType,omitempty" xml:"resourceType,omitempty"`
	// The key of the tag.
	//
	// example:
	//
	// key1
	TagKey *string `json:"tagKey,omitempty" xml:"tagKey,omitempty"`
	// The value of the tag.
	//
	// example:
	//
	// value1
	TagValue *string `json:"tagValue,omitempty" xml:"tagValue,omitempty"`
}

func (s ListTagResourcesResponseBodyTagResources) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResources) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResources) SetResourceId(v string) *ListTagResourcesResponseBodyTagResources {
	s.ResourceId = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResources) SetResourceType(v string) *ListTagResourcesResponseBodyTagResources {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResources) SetTagKey(v string) *ListTagResourcesResponseBodyTagResources {
	s.TagKey = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResources) SetTagValue(v string) *ListTagResourcesResponseBodyTagResources {
	s.TagValue = &v
	return s
}

type ListTagResourcesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListTagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListTagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponse) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponse) SetHeaders(v map[string]*string) *ListTagResourcesResponse {
	s.Headers = v
	return s
}

func (s *ListTagResourcesResponse) SetStatusCode(v int32) *ListTagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTagResourcesResponse) SetBody(v *ListTagResourcesResponseBody) *ListTagResourcesResponse {
	s.Body = v
	return s
}

type MergeShardResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       []*Shard           `json:"body,omitempty" xml:"body,omitempty" type:"Repeated"`
}

func (s MergeShardResponse) String() string {
	return tea.Prettify(s)
}

func (s MergeShardResponse) GoString() string {
	return s.String()
}

func (s *MergeShardResponse) SetHeaders(v map[string]*string) *MergeShardResponse {
	s.Headers = v
	return s
}

func (s *MergeShardResponse) SetStatusCode(v int32) *MergeShardResponse {
	s.StatusCode = &v
	return s
}

func (s *MergeShardResponse) SetBody(v []*Shard) *MergeShardResponse {
	s.Body = v
	return s
}

type OpenSlsServiceResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s OpenSlsServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s OpenSlsServiceResponse) GoString() string {
	return s.String()
}

func (s *OpenSlsServiceResponse) SetHeaders(v map[string]*string) *OpenSlsServiceResponse {
	s.Headers = v
	return s
}

func (s *OpenSlsServiceResponse) SetStatusCode(v int32) *OpenSlsServiceResponse {
	s.StatusCode = &v
	return s
}

type PullLogsHeaders struct {
	CommonHeaders map[string]*string `json:"commonHeaders,omitempty" xml:"commonHeaders,omitempty"`
	// example:
	//
	// lz4
	AcceptEncoding *string `json:"Accept-Encoding,omitempty" xml:"Accept-Encoding,omitempty"`
}

func (s PullLogsHeaders) String() string {
	return tea.Prettify(s)
}

func (s PullLogsHeaders) GoString() string {
	return s.String()
}

func (s *PullLogsHeaders) SetCommonHeaders(v map[string]*string) *PullLogsHeaders {
	s.CommonHeaders = v
	return s
}

func (s *PullLogsHeaders) SetAcceptEncoding(v string) *PullLogsHeaders {
	s.AcceptEncoding = &v
	return s
}

type PullLogsRequest struct {
	// This parameter is required.
	//
	// example:
	//
	// 1000
	Count *int32 `json:"count,omitempty" xml:"count,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// MTQ0NzMyOTQwMTEwMjEzMDkwNA
	Cursor *string `json:"cursor,omitempty" xml:"cursor,omitempty"`
	// example:
	//
	// MTU1NzA1NzQwMTEwMjEzMDkwCg
	EndCursor *string `json:"end_cursor,omitempty" xml:"end_cursor,omitempty"`
	// The SPL statement that is used to filter data. For more information, see [SPL instructions](https://help.aliyun.com/document_detail/2536530.html).
	//
	// example:
	//
	// 	- | where userId=\\"123\\"
	Query *string `json:"query,omitempty" xml:"query,omitempty"`
}

func (s PullLogsRequest) String() string {
	return tea.Prettify(s)
}

func (s PullLogsRequest) GoString() string {
	return s.String()
}

func (s *PullLogsRequest) SetCount(v int32) *PullLogsRequest {
	s.Count = &v
	return s
}

func (s *PullLogsRequest) SetCursor(v string) *PullLogsRequest {
	s.Cursor = &v
	return s
}

func (s *PullLogsRequest) SetEndCursor(v string) *PullLogsRequest {
	s.EndCursor = &v
	return s
}

func (s *PullLogsRequest) SetQuery(v string) *PullLogsRequest {
	s.Query = &v
	return s
}

type PullLogsResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *LogGroupList      `json:"body,omitempty" xml:"body,omitempty"`
}

func (s PullLogsResponse) String() string {
	return tea.Prettify(s)
}

func (s PullLogsResponse) GoString() string {
	return s.String()
}

func (s *PullLogsResponse) SetHeaders(v map[string]*string) *PullLogsResponse {
	s.Headers = v
	return s
}

func (s *PullLogsResponse) SetStatusCode(v int32) *PullLogsResponse {
	s.StatusCode = &v
	return s
}

func (s *PullLogsResponse) SetBody(v *LogGroupList) *PullLogsResponse {
	s.Body = v
	return s
}

type PutAnnotationDataRequest struct {
	// The unique identifier of the data.
	//
	// example:
	//
	// 2156d560fc7c01420542df92cd6365ds
	AnnotationdataId *string `json:"annotationdataId,omitempty" xml:"annotationdataId,omitempty"`
	// The data structure of the request.
	MlDataParam *MLDataParam `json:"mlDataParam,omitempty" xml:"mlDataParam,omitempty"`
	// The raw log data.
	RawLog []map[string]*string `json:"rawLog,omitempty" xml:"rawLog,omitempty" type:"Repeated"`
}

func (s PutAnnotationDataRequest) String() string {
	return tea.Prettify(s)
}

func (s PutAnnotationDataRequest) GoString() string {
	return s.String()
}

func (s *PutAnnotationDataRequest) SetAnnotationdataId(v string) *PutAnnotationDataRequest {
	s.AnnotationdataId = &v
	return s
}

func (s *PutAnnotationDataRequest) SetMlDataParam(v *MLDataParam) *PutAnnotationDataRequest {
	s.MlDataParam = v
	return s
}

func (s *PutAnnotationDataRequest) SetRawLog(v []map[string]*string) *PutAnnotationDataRequest {
	s.RawLog = v
	return s
}

type PutAnnotationDataResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s PutAnnotationDataResponse) String() string {
	return tea.Prettify(s)
}

func (s PutAnnotationDataResponse) GoString() string {
	return s.String()
}

func (s *PutAnnotationDataResponse) SetHeaders(v map[string]*string) *PutAnnotationDataResponse {
	s.Headers = v
	return s
}

func (s *PutAnnotationDataResponse) SetStatusCode(v int32) *PutAnnotationDataResponse {
	s.StatusCode = &v
	return s
}

type PutIngestProcessorRequest struct {
	// The configuration of the ingest processor.
	//
	// This parameter is required.
	Configuration *IngestProcessorConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty"`
	// The description of the ingest processor.
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// The display name of the ingest processor.
	//
	// This parameter is required.
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
}

func (s PutIngestProcessorRequest) String() string {
	return tea.Prettify(s)
}

func (s PutIngestProcessorRequest) GoString() string {
	return s.String()
}

func (s *PutIngestProcessorRequest) SetConfiguration(v *IngestProcessorConfiguration) *PutIngestProcessorRequest {
	s.Configuration = v
	return s
}

func (s *PutIngestProcessorRequest) SetDescription(v string) *PutIngestProcessorRequest {
	s.Description = &v
	return s
}

func (s *PutIngestProcessorRequest) SetDisplayName(v string) *PutIngestProcessorRequest {
	s.DisplayName = &v
	return s
}

type PutIngestProcessorResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s PutIngestProcessorResponse) String() string {
	return tea.Prettify(s)
}

func (s PutIngestProcessorResponse) GoString() string {
	return s.String()
}

func (s *PutIngestProcessorResponse) SetHeaders(v map[string]*string) *PutIngestProcessorResponse {
	s.Headers = v
	return s
}

func (s *PutIngestProcessorResponse) SetStatusCode(v int32) *PutIngestProcessorResponse {
	s.StatusCode = &v
	return s
}

type PutLogsHeaders struct {
	CommonHeaders map[string]*string `json:"commonHeaders,omitempty" xml:"commonHeaders,omitempty"`
	// The compression format. lz4 and gzip are supported.
	//
	// This parameter is required.
	//
	// example:
	//
	// lz4
	XLogCompresstype *string `json:"x-log-compresstype,omitempty" xml:"x-log-compresstype,omitempty"`
}

func (s PutLogsHeaders) String() string {
	return tea.Prettify(s)
}

func (s PutLogsHeaders) GoString() string {
	return s.String()
}

func (s *PutLogsHeaders) SetCommonHeaders(v map[string]*string) *PutLogsHeaders {
	s.CommonHeaders = v
	return s
}

func (s *PutLogsHeaders) SetXLogCompresstype(v string) *PutLogsHeaders {
	s.XLogCompresstype = &v
	return s
}

type PutLogsRequest struct {
	// The compressed Protobuf data.
	Body *LogGroup `json:"body,omitempty" xml:"body,omitempty"`
}

func (s PutLogsRequest) String() string {
	return tea.Prettify(s)
}

func (s PutLogsRequest) GoString() string {
	return s.String()
}

func (s *PutLogsRequest) SetBody(v *LogGroup) *PutLogsRequest {
	s.Body = v
	return s
}

type PutLogsResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s PutLogsResponse) String() string {
	return tea.Prettify(s)
}

func (s PutLogsResponse) GoString() string {
	return s.String()
}

func (s *PutLogsResponse) SetHeaders(v map[string]*string) *PutLogsResponse {
	s.Headers = v
	return s
}

func (s *PutLogsResponse) SetStatusCode(v int32) *PutLogsResponse {
	s.StatusCode = &v
	return s
}

type PutProjectPolicyRequest struct {
	// The project policy.
	//
	// example:
	//
	// { 	"Version": "1", 	"Statement": [{ 		"Action": ["log:PostLogStoreLogs"], 		"Resource": "acs:log:*:*:project/exampleproject/*", 		"Effect": "Deny", 		"Condition": { 			"StringNotLike": { 				"acs:SourceVpc": ["vpc-*"] 			} 		} 	}] }
	Body *string `json:"body,omitempty" xml:"body,omitempty"`
}

func (s PutProjectPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s PutProjectPolicyRequest) GoString() string {
	return s.String()
}

func (s *PutProjectPolicyRequest) SetBody(v string) *PutProjectPolicyRequest {
	s.Body = &v
	return s
}

type PutProjectPolicyResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s PutProjectPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s PutProjectPolicyResponse) GoString() string {
	return s.String()
}

func (s *PutProjectPolicyResponse) SetHeaders(v map[string]*string) *PutProjectPolicyResponse {
	s.Headers = v
	return s
}

func (s *PutProjectPolicyResponse) SetStatusCode(v int32) *PutProjectPolicyResponse {
	s.StatusCode = &v
	return s
}

type PutProjectTransferAccelerationRequest struct {
	// This parameter is required.
	Enabled *bool `json:"enabled,omitempty" xml:"enabled,omitempty"`
}

func (s PutProjectTransferAccelerationRequest) String() string {
	return tea.Prettify(s)
}

func (s PutProjectTransferAccelerationRequest) GoString() string {
	return s.String()
}

func (s *PutProjectTransferAccelerationRequest) SetEnabled(v bool) *PutProjectTransferAccelerationRequest {
	s.Enabled = &v
	return s
}

type PutProjectTransferAccelerationResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s PutProjectTransferAccelerationResponse) String() string {
	return tea.Prettify(s)
}

func (s PutProjectTransferAccelerationResponse) GoString() string {
	return s.String()
}

func (s *PutProjectTransferAccelerationResponse) SetHeaders(v map[string]*string) *PutProjectTransferAccelerationResponse {
	s.Headers = v
	return s
}

func (s *PutProjectTransferAccelerationResponse) SetStatusCode(v int32) *PutProjectTransferAccelerationResponse {
	s.StatusCode = &v
	return s
}

type PutWebtrackingRequest struct {
	// The logs. Each element is a JSON object that indicates a log.
	//
	// >  **Note**: The time in a log that is collected by using the web tracking feature is the time at which Simple Log Service receives the log. You do not need to configure the __time__ field for each log. If this field exists, it is overwritten by the time at which Simple Log Service receives the log.
	//
	// This parameter is required.
	Logs []map[string]*string `json:"__logs__,omitempty" xml:"__logs__,omitempty" type:"Repeated"`
	// The source of the logs.
	//
	// This parameter is required.
	//
	// example:
	//
	// source
	Source *string `json:"__source__,omitempty" xml:"__source__,omitempty"`
	// The tags of the logs.
	Tags map[string]*string `json:"__tags__,omitempty" xml:"__tags__,omitempty"`
	// The topic of the logs.
	//
	// example:
	//
	// topic
	Topic *string `json:"__topic__,omitempty" xml:"__topic__,omitempty"`
}

func (s PutWebtrackingRequest) String() string {
	return tea.Prettify(s)
}

func (s PutWebtrackingRequest) GoString() string {
	return s.String()
}

func (s *PutWebtrackingRequest) SetLogs(v []map[string]*string) *PutWebtrackingRequest {
	s.Logs = v
	return s
}

func (s *PutWebtrackingRequest) SetSource(v string) *PutWebtrackingRequest {
	s.Source = &v
	return s
}

func (s *PutWebtrackingRequest) SetTags(v map[string]*string) *PutWebtrackingRequest {
	s.Tags = v
	return s
}

func (s *PutWebtrackingRequest) SetTopic(v string) *PutWebtrackingRequest {
	s.Topic = &v
	return s
}

type PutWebtrackingResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s PutWebtrackingResponse) String() string {
	return tea.Prettify(s)
}

func (s PutWebtrackingResponse) GoString() string {
	return s.String()
}

func (s *PutWebtrackingResponse) SetHeaders(v map[string]*string) *PutWebtrackingResponse {
	s.Headers = v
	return s
}

func (s *PutWebtrackingResponse) SetStatusCode(v int32) *PutWebtrackingResponse {
	s.StatusCode = &v
	return s
}

type RefreshTokenRequest struct {
	// 	- The validity period of the access token. Unit: seconds. Default value: 86400, which specifies one day. Valid values: 0 to 86400.
	//
	// 	- The validity period of the access token is the smaller value between accessTokenExpirationTime and expirationTime.
	//
	// 	- If you use a Security Token Service (STS) token to call this operation, the validity period of the access token is the smallest value among accessTokenExpirationTime, expirationTime, and the validity period of the STS token.
	//
	// example:
	//
	// 600
	AccessTokenExpirationTime *int64 `json:"accessTokenExpirationTime,omitempty" xml:"accessTokenExpirationTime,omitempty"`
	// The ticket that is used for logon-free access.
	//
	// example:
	//
	// eyJ***************.eyJ******************.KUT****************
	Ticket *string `json:"ticket,omitempty" xml:"ticket,omitempty"`
}

func (s RefreshTokenRequest) String() string {
	return tea.Prettify(s)
}

func (s RefreshTokenRequest) GoString() string {
	return s.String()
}

func (s *RefreshTokenRequest) SetAccessTokenExpirationTime(v int64) *RefreshTokenRequest {
	s.AccessTokenExpirationTime = &v
	return s
}

func (s *RefreshTokenRequest) SetTicket(v string) *RefreshTokenRequest {
	s.Ticket = &v
	return s
}

type RefreshTokenResponseBody struct {
	// example:
	//
	// eyJ***************.eyJ******************.KUT****************
	AccessToken *string `json:"accessToken,omitempty" xml:"accessToken,omitempty"`
}

func (s RefreshTokenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RefreshTokenResponseBody) GoString() string {
	return s.String()
}

func (s *RefreshTokenResponseBody) SetAccessToken(v string) *RefreshTokenResponseBody {
	s.AccessToken = &v
	return s
}

type RefreshTokenResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RefreshTokenResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RefreshTokenResponse) String() string {
	return tea.Prettify(s)
}

func (s RefreshTokenResponse) GoString() string {
	return s.String()
}

func (s *RefreshTokenResponse) SetHeaders(v map[string]*string) *RefreshTokenResponse {
	s.Headers = v
	return s
}

func (s *RefreshTokenResponse) SetStatusCode(v int32) *RefreshTokenResponse {
	s.StatusCode = &v
	return s
}

func (s *RefreshTokenResponse) SetBody(v *RefreshTokenResponseBody) *RefreshTokenResponse {
	s.Body = v
	return s
}

type RemoveConfigFromMachineGroupResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s RemoveConfigFromMachineGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveConfigFromMachineGroupResponse) GoString() string {
	return s.String()
}

func (s *RemoveConfigFromMachineGroupResponse) SetHeaders(v map[string]*string) *RemoveConfigFromMachineGroupResponse {
	s.Headers = v
	return s
}

func (s *RemoveConfigFromMachineGroupResponse) SetStatusCode(v int32) *RemoveConfigFromMachineGroupResponse {
	s.StatusCode = &v
	return s
}

type SplitShardRequest struct {
	// The position where the shard is split.
	//
	// example:
	//
	// ef000000000000000000000000000000
	Key *string `json:"key,omitempty" xml:"key,omitempty"`
	// The number of new shards that are generated after splitting.
	//
	// example:
	//
	// 2
	ShardCount *int32 `json:"shardCount,omitempty" xml:"shardCount,omitempty"`
}

func (s SplitShardRequest) String() string {
	return tea.Prettify(s)
}

func (s SplitShardRequest) GoString() string {
	return s.String()
}

func (s *SplitShardRequest) SetKey(v string) *SplitShardRequest {
	s.Key = &v
	return s
}

func (s *SplitShardRequest) SetShardCount(v int32) *SplitShardRequest {
	s.ShardCount = &v
	return s
}

type SplitShardResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       []*Shard           `json:"body,omitempty" xml:"body,omitempty" type:"Repeated"`
}

func (s SplitShardResponse) String() string {
	return tea.Prettify(s)
}

func (s SplitShardResponse) GoString() string {
	return s.String()
}

func (s *SplitShardResponse) SetHeaders(v map[string]*string) *SplitShardResponse {
	s.Headers = v
	return s
}

func (s *SplitShardResponse) SetStatusCode(v int32) *SplitShardResponse {
	s.StatusCode = &v
	return s
}

func (s *SplitShardResponse) SetBody(v []*Shard) *SplitShardResponse {
	s.Body = v
	return s
}

type StartETLResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s StartETLResponse) String() string {
	return tea.Prettify(s)
}

func (s StartETLResponse) GoString() string {
	return s.String()
}

func (s *StartETLResponse) SetHeaders(v map[string]*string) *StartETLResponse {
	s.Headers = v
	return s
}

func (s *StartETLResponse) SetStatusCode(v int32) *StartETLResponse {
	s.StatusCode = &v
	return s
}

type StartOSSExportResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s StartOSSExportResponse) String() string {
	return tea.Prettify(s)
}

func (s StartOSSExportResponse) GoString() string {
	return s.String()
}

func (s *StartOSSExportResponse) SetHeaders(v map[string]*string) *StartOSSExportResponse {
	s.Headers = v
	return s
}

func (s *StartOSSExportResponse) SetStatusCode(v int32) *StartOSSExportResponse {
	s.StatusCode = &v
	return s
}

type StartOSSHDFSExportResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s StartOSSHDFSExportResponse) String() string {
	return tea.Prettify(s)
}

func (s StartOSSHDFSExportResponse) GoString() string {
	return s.String()
}

func (s *StartOSSHDFSExportResponse) SetHeaders(v map[string]*string) *StartOSSHDFSExportResponse {
	s.Headers = v
	return s
}

func (s *StartOSSHDFSExportResponse) SetStatusCode(v int32) *StartOSSHDFSExportResponse {
	s.StatusCode = &v
	return s
}

type StartOSSIngestionResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s StartOSSIngestionResponse) String() string {
	return tea.Prettify(s)
}

func (s StartOSSIngestionResponse) GoString() string {
	return s.String()
}

func (s *StartOSSIngestionResponse) SetHeaders(v map[string]*string) *StartOSSIngestionResponse {
	s.Headers = v
	return s
}

func (s *StartOSSIngestionResponse) SetStatusCode(v int32) *StartOSSIngestionResponse {
	s.StatusCode = &v
	return s
}

type StopETLResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s StopETLResponse) String() string {
	return tea.Prettify(s)
}

func (s StopETLResponse) GoString() string {
	return s.String()
}

func (s *StopETLResponse) SetHeaders(v map[string]*string) *StopETLResponse {
	s.Headers = v
	return s
}

func (s *StopETLResponse) SetStatusCode(v int32) *StopETLResponse {
	s.StatusCode = &v
	return s
}

type StopOSSExportResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s StopOSSExportResponse) String() string {
	return tea.Prettify(s)
}

func (s StopOSSExportResponse) GoString() string {
	return s.String()
}

func (s *StopOSSExportResponse) SetHeaders(v map[string]*string) *StopOSSExportResponse {
	s.Headers = v
	return s
}

func (s *StopOSSExportResponse) SetStatusCode(v int32) *StopOSSExportResponse {
	s.StatusCode = &v
	return s
}

type StopOSSHDFSExportResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s StopOSSHDFSExportResponse) String() string {
	return tea.Prettify(s)
}

func (s StopOSSHDFSExportResponse) GoString() string {
	return s.String()
}

func (s *StopOSSHDFSExportResponse) SetHeaders(v map[string]*string) *StopOSSHDFSExportResponse {
	s.Headers = v
	return s
}

func (s *StopOSSHDFSExportResponse) SetStatusCode(v int32) *StopOSSHDFSExportResponse {
	s.StatusCode = &v
	return s
}

type StopOSSIngestionResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s StopOSSIngestionResponse) String() string {
	return tea.Prettify(s)
}

func (s StopOSSIngestionResponse) GoString() string {
	return s.String()
}

func (s *StopOSSIngestionResponse) SetHeaders(v map[string]*string) *StopOSSIngestionResponse {
	s.Headers = v
	return s
}

func (s *StopOSSIngestionResponse) SetStatusCode(v int32) *StopOSSIngestionResponse {
	s.StatusCode = &v
	return s
}

type TagResourcesRequest struct {
	// The resource IDs. You can specify only one resource and add tags to the resource.
	//
	// This parameter is required.
	ResourceId []*string `json:"resourceId,omitempty" xml:"resourceId,omitempty" type:"Repeated"`
	// The type of the resource. Valid values:
	//
	// 	- project
	//
	// 	- logstore
	//
	// 	- dashboard
	//
	// 	- machinegroup
	//
	// 	- logtailconfig
	//
	// This parameter is required.
	//
	// example:
	//
	// project
	ResourceType *string `json:"resourceType,omitempty" xml:"resourceType,omitempty"`
	// The tags that you want to add to the resource. You can specify up to 20 tags in each call. Each tag is a key-value pair.
	//
	// This parameter is required.
	Tags []*TagResourcesRequestTags `json:"tags,omitempty" xml:"tags,omitempty" type:"Repeated"`
}

func (s TagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequest) GoString() string {
	return s.String()
}

func (s *TagResourcesRequest) SetResourceId(v []*string) *TagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *TagResourcesRequest) SetResourceType(v string) *TagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *TagResourcesRequest) SetTags(v []*TagResourcesRequestTags) *TagResourcesRequest {
	s.Tags = v
	return s
}

type TagResourcesRequestTags struct {
	// The key of the tag. The key must meet the following requirements:
	//
	// 	- The key must be `1 to 128` characters in length.
	//
	// 	- The key cannot contain `http://` or `https://`.
	//
	// 	- The key cannot start with `acs:` or `aliyun`.
	//
	// This parameter is required.
	//
	// example:
	//
	// key1
	Key *string `json:"key,omitempty" xml:"key,omitempty"`
	// The value of the tag. The value must meet the following requirements:
	//
	// 	- The value must be `1 to 128` characters in length.
	//
	// 	- The value cannot contain `http://` or `https://`.
	//
	// This parameter is required.
	//
	// example:
	//
	// value1
	Value *string `json:"value,omitempty" xml:"value,omitempty"`
}

func (s TagResourcesRequestTags) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequestTags) GoString() string {
	return s.String()
}

func (s *TagResourcesRequestTags) SetKey(v string) *TagResourcesRequestTags {
	s.Key = &v
	return s
}

func (s *TagResourcesRequestTags) SetValue(v string) *TagResourcesRequestTags {
	s.Value = &v
	return s
}

type TagResourcesResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s TagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponse) GoString() string {
	return s.String()
}

func (s *TagResourcesResponse) SetHeaders(v map[string]*string) *TagResourcesResponse {
	s.Headers = v
	return s
}

func (s *TagResourcesResponse) SetStatusCode(v int32) *TagResourcesResponse {
	s.StatusCode = &v
	return s
}

type UntagResourcesRequest struct {
	// Specifies whether to unbind all tags. Default value: false. Valid values:
	//
	// 	- false: unbinds only the tags that match the value of tags.
	//
	// 	- true: unbinds all tags that are bound to the resource.
	//
	// example:
	//
	// false
	All *bool `json:"all,omitempty" xml:"all,omitempty"`
	// The resource IDs. Each time you call this operation, you can unbind tags only from a single resource. Therefore, you can enter only one resource ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// ali-test-project
	ResourceId []*string `json:"resourceId,omitempty" xml:"resourceId,omitempty" type:"Repeated"`
	// The type of the resource. Valid values:
	//
	// 	- project
	//
	// 	- logstore
	//
	// 	- dashboard
	//
	// 	- machinegroup
	//
	// 	- logtailconfig
	//
	// example:
	//
	// project
	ResourceType *string `json:"resourceType,omitempty" xml:"resourceType,omitempty"`
	// The tag keys. If you set all to false, only the tags that match the value of this parameter are unbound.
	Tags []*string `json:"tags,omitempty" xml:"tags,omitempty" type:"Repeated"`
}

func (s UntagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesRequest) GoString() string {
	return s.String()
}

func (s *UntagResourcesRequest) SetAll(v bool) *UntagResourcesRequest {
	s.All = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceId(v []*string) *UntagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *UntagResourcesRequest) SetResourceType(v string) *UntagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *UntagResourcesRequest) SetTags(v []*string) *UntagResourcesRequest {
	s.Tags = v
	return s
}

type UntagResourcesResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UntagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponse) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponse) SetHeaders(v map[string]*string) *UntagResourcesResponse {
	s.Headers = v
	return s
}

func (s *UntagResourcesResponse) SetStatusCode(v int32) *UntagResourcesResponse {
	s.StatusCode = &v
	return s
}

type UpdateAgentInstanceConfigRequest struct {
	// This parameter is required.
	Config *string `json:"config,omitempty" xml:"config,omitempty"`
	// This parameter is required.
	ConfigMatcher *string `json:"configMatcher,omitempty" xml:"configMatcher,omitempty"`
	IsGray        *bool   `json:"isGray,omitempty" xml:"isGray,omitempty"`
}

func (s UpdateAgentInstanceConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAgentInstanceConfigRequest) GoString() string {
	return s.String()
}

func (s *UpdateAgentInstanceConfigRequest) SetConfig(v string) *UpdateAgentInstanceConfigRequest {
	s.Config = &v
	return s
}

func (s *UpdateAgentInstanceConfigRequest) SetConfigMatcher(v string) *UpdateAgentInstanceConfigRequest {
	s.ConfigMatcher = &v
	return s
}

func (s *UpdateAgentInstanceConfigRequest) SetIsGray(v bool) *UpdateAgentInstanceConfigRequest {
	s.IsGray = &v
	return s
}

type UpdateAgentInstanceConfigResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateAgentInstanceConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAgentInstanceConfigResponse) GoString() string {
	return s.String()
}

func (s *UpdateAgentInstanceConfigResponse) SetHeaders(v map[string]*string) *UpdateAgentInstanceConfigResponse {
	s.Headers = v
	return s
}

func (s *UpdateAgentInstanceConfigResponse) SetStatusCode(v int32) *UpdateAgentInstanceConfigResponse {
	s.StatusCode = &v
	return s
}

type UpdateAlertRequest struct {
	// The detailed configurations of the alert rule.
	//
	// This parameter is required.
	Configuration *AlertConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty"`
	// The description of the alert rule.
	//
	// example:
	//
	// this is description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// The display name of the alert rule.
	//
	// This parameter is required.
	//
	// example:
	//
	// this is alert
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// The scheduling settings of the alert rule.
	//
	// This parameter is required.
	Schedule *Schedule `json:"schedule,omitempty" xml:"schedule,omitempty"`
}

func (s UpdateAlertRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAlertRequest) GoString() string {
	return s.String()
}

func (s *UpdateAlertRequest) SetConfiguration(v *AlertConfiguration) *UpdateAlertRequest {
	s.Configuration = v
	return s
}

func (s *UpdateAlertRequest) SetDescription(v string) *UpdateAlertRequest {
	s.Description = &v
	return s
}

func (s *UpdateAlertRequest) SetDisplayName(v string) *UpdateAlertRequest {
	s.DisplayName = &v
	return s
}

func (s *UpdateAlertRequest) SetSchedule(v *Schedule) *UpdateAlertRequest {
	s.Schedule = v
	return s
}

type UpdateAlertResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateAlertResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAlertResponse) GoString() string {
	return s.String()
}

func (s *UpdateAlertResponse) SetHeaders(v map[string]*string) *UpdateAlertResponse {
	s.Headers = v
	return s
}

func (s *UpdateAlertResponse) SetStatusCode(v int32) *UpdateAlertResponse {
	s.StatusCode = &v
	return s
}

type UpdateAnnotationDataSetRequest struct {
	// The data structure of the request.
	Body *MLDataSetParam `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateAnnotationDataSetRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAnnotationDataSetRequest) GoString() string {
	return s.String()
}

func (s *UpdateAnnotationDataSetRequest) SetBody(v *MLDataSetParam) *UpdateAnnotationDataSetRequest {
	s.Body = v
	return s
}

type UpdateAnnotationDataSetResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateAnnotationDataSetResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAnnotationDataSetResponse) GoString() string {
	return s.String()
}

func (s *UpdateAnnotationDataSetResponse) SetHeaders(v map[string]*string) *UpdateAnnotationDataSetResponse {
	s.Headers = v
	return s
}

func (s *UpdateAnnotationDataSetResponse) SetStatusCode(v int32) *UpdateAnnotationDataSetResponse {
	s.StatusCode = &v
	return s
}

type UpdateAnnotationLabelRequest struct {
	// The data structure of the request.
	Body *MLLabelParam `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateAnnotationLabelRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAnnotationLabelRequest) GoString() string {
	return s.String()
}

func (s *UpdateAnnotationLabelRequest) SetBody(v *MLLabelParam) *UpdateAnnotationLabelRequest {
	s.Body = v
	return s
}

type UpdateAnnotationLabelResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateAnnotationLabelResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAnnotationLabelResponse) GoString() string {
	return s.String()
}

func (s *UpdateAnnotationLabelResponse) SetHeaders(v map[string]*string) *UpdateAnnotationLabelResponse {
	s.Headers = v
	return s
}

func (s *UpdateAnnotationLabelResponse) SetStatusCode(v int32) *UpdateAnnotationLabelResponse {
	s.StatusCode = &v
	return s
}

type UpdateConfigRequest struct {
	// The body of the request.
	Body *LogtailConfig `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateConfigRequest) GoString() string {
	return s.String()
}

func (s *UpdateConfigRequest) SetBody(v *LogtailConfig) *UpdateConfigRequest {
	s.Body = v
	return s
}

type UpdateConfigResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateConfigResponse) GoString() string {
	return s.String()
}

func (s *UpdateConfigResponse) SetHeaders(v map[string]*string) *UpdateConfigResponse {
	s.Headers = v
	return s
}

func (s *UpdateConfigResponse) SetStatusCode(v int32) *UpdateConfigResponse {
	s.StatusCode = &v
	return s
}

type UpdateConsumerGroupRequest struct {
	// Specifies whether to consume data in sequence. Valid values:
	//
	// 	- true: If a shard is split, the data in the original shard is consumed first. Then, the data in the new shards is consumed at the same time. If shards are merged, the data in the original shards is consumed first. Then, the data in the new shard is consumed.
	//
	// 	- false: The data in all shards is consumed at the same time. If a new shard is generated after a shard is split or shards are merged, the data in the new shard is immediately consumed.
	//
	// example:
	//
	// true
	Order *bool `json:"order,omitempty" xml:"order,omitempty"`
	// The timeout period. If Simple Log Service does not receive heartbeats from a consumer within the timeout period, Simple Log Service deletes the consumer. Unit: seconds
	//
	// example:
	//
	// 300
	Timeout *int32 `json:"timeout,omitempty" xml:"timeout,omitempty"`
}

func (s UpdateConsumerGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateConsumerGroupRequest) GoString() string {
	return s.String()
}

func (s *UpdateConsumerGroupRequest) SetOrder(v bool) *UpdateConsumerGroupRequest {
	s.Order = &v
	return s
}

func (s *UpdateConsumerGroupRequest) SetTimeout(v int32) *UpdateConsumerGroupRequest {
	s.Timeout = &v
	return s
}

type UpdateConsumerGroupResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateConsumerGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateConsumerGroupResponse) GoString() string {
	return s.String()
}

func (s *UpdateConsumerGroupResponse) SetHeaders(v map[string]*string) *UpdateConsumerGroupResponse {
	s.Headers = v
	return s
}

func (s *UpdateConsumerGroupResponse) SetStatusCode(v int32) *UpdateConsumerGroupResponse {
	s.StatusCode = &v
	return s
}

type UpdateDashboardRequest struct {
	// The attribute values of the dashboard.
	Attribute map[string]*string `json:"attribute,omitempty" xml:"attribute,omitempty"`
	// The charts on the dashboard.
	//
	// This parameter is required.
	Charts []*Chart `json:"charts,omitempty" xml:"charts,omitempty" type:"Repeated"`
	// The name of the dashboard.
	//
	// This parameter is required.
	//
	// example:
	//
	// dashboard-1609294922657-434834
	DashboardName *string `json:"dashboardName,omitempty" xml:"dashboardName,omitempty"`
	// The description of the dashboard.
	//
	// example:
	//
	// test dashboard.
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// The display name of the dashboard.
	//
	// This parameter is required.
	//
	// example:
	//
	// Method pv
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
}

func (s UpdateDashboardRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDashboardRequest) GoString() string {
	return s.String()
}

func (s *UpdateDashboardRequest) SetAttribute(v map[string]*string) *UpdateDashboardRequest {
	s.Attribute = v
	return s
}

func (s *UpdateDashboardRequest) SetCharts(v []*Chart) *UpdateDashboardRequest {
	s.Charts = v
	return s
}

func (s *UpdateDashboardRequest) SetDashboardName(v string) *UpdateDashboardRequest {
	s.DashboardName = &v
	return s
}

func (s *UpdateDashboardRequest) SetDescription(v string) *UpdateDashboardRequest {
	s.Description = &v
	return s
}

func (s *UpdateDashboardRequest) SetDisplayName(v string) *UpdateDashboardRequest {
	s.DisplayName = &v
	return s
}

type UpdateDashboardResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateDashboardResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDashboardResponse) GoString() string {
	return s.String()
}

func (s *UpdateDashboardResponse) SetHeaders(v map[string]*string) *UpdateDashboardResponse {
	s.Headers = v
	return s
}

func (s *UpdateDashboardResponse) SetStatusCode(v int32) *UpdateDashboardResponse {
	s.StatusCode = &v
	return s
}

type UpdateETLRequest struct {
	// This parameter is required.
	Configuration *ETLConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty"`
	// example:
	//
	// this is description
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// this is update
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
}

func (s UpdateETLRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateETLRequest) GoString() string {
	return s.String()
}

func (s *UpdateETLRequest) SetConfiguration(v *ETLConfiguration) *UpdateETLRequest {
	s.Configuration = v
	return s
}

func (s *UpdateETLRequest) SetDescription(v string) *UpdateETLRequest {
	s.Description = &v
	return s
}

func (s *UpdateETLRequest) SetDisplayName(v string) *UpdateETLRequest {
	s.DisplayName = &v
	return s
}

type UpdateETLResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateETLResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateETLResponse) GoString() string {
	return s.String()
}

func (s *UpdateETLResponse) SetHeaders(v map[string]*string) *UpdateETLResponse {
	s.Headers = v
	return s
}

func (s *UpdateETLResponse) SetStatusCode(v int32) *UpdateETLResponse {
	s.StatusCode = &v
	return s
}

type UpdateIndexRequest struct {
	// The request body.
	Body *Index `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateIndexRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateIndexRequest) GoString() string {
	return s.String()
}

func (s *UpdateIndexRequest) SetBody(v *Index) *UpdateIndexRequest {
	s.Body = v
	return s
}

type UpdateIndexResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateIndexResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateIndexResponse) GoString() string {
	return s.String()
}

func (s *UpdateIndexResponse) SetHeaders(v map[string]*string) *UpdateIndexResponse {
	s.Headers = v
	return s
}

func (s *UpdateIndexResponse) SetStatusCode(v int32) *UpdateIndexResponse {
	s.StatusCode = &v
	return s
}

type UpdateLogStoreRequest struct {
	// Specifies whether to record public IP addresses. Default value: false. Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// false
	AppendMeta *bool `json:"appendMeta,omitempty" xml:"appendMeta,omitempty"`
	// Specifies whether to enable automatic sharding. Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// true
	AutoSplit *bool `json:"autoSplit,omitempty" xml:"autoSplit,omitempty"`
	// Specifies whether to enable the web tracking feature. Default value: false. Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// false
	EnableTracking *bool `json:"enable_tracking,omitempty" xml:"enable_tracking,omitempty"`
	// The data structure of the encryption configuration.
	EncryptConf *EncryptConf `json:"encrypt_conf,omitempty" xml:"encrypt_conf,omitempty"`
	// The retention period of data in the hot storage tier of the Logstore. Valid values: 7 to 3000. Unit: days. After the retention period that is specified for the hot storage tier elapses, the data is moved to the Infrequent Access (IA) storage tier. For more information, see [Enable hot and cold-tiered storage for a Logstore](https://help.aliyun.com/document_detail/308645.html).
	//
	// example:
	//
	// 60
	HotTtl *int32 `json:"hot_ttl,omitempty" xml:"hot_ttl,omitempty"`
	// The retention period of data in the IA storage tier of the Logstore. You must set this parameter to at least 30 days. After the data retention period that you specify for the IA storage tier elapses, the data is moved to the Archive storage tier.
	//
	// example:
	//
	// 30
	InfrequentAccessTTL *int32 `json:"infrequentAccessTTL,omitempty" xml:"infrequentAccessTTL,omitempty"`
	// The name of the Logstore.
	//
	// This parameter is required.
	//
	// example:
	//
	// test-logstore
	LogstoreName *string `json:"logstoreName,omitempty" xml:"logstoreName,omitempty"`
	// The maximum number of shards into which existing shards can be automatically split. Valid values: 1 to 256.
	//
	// >  If you set autoSplit to true, you must specify maxSplitShard.
	//
	// example:
	//
	// 64
	MaxSplitShard *int32 `json:"maxSplitShard,omitempty" xml:"maxSplitShard,omitempty"`
	// The type of the Logstore. Simple Log Service provides two types of Logstores: Standard Logstores and Query Logstores. Valid values:
	//
	// 	- **standard**: Standard Logstore. This type of Logstore supports the log analysis feature and is suitable for scenarios such as real-time monitoring and interactive analysis. You can also use this type of Logstore to build a comprehensive observability system.
	//
	// 	- **query**: Query Logstore. This type of Logstore supports high-performance queries. The index traffic fee of a Query Logstore is approximately half that of a Standard Logstore. Query Logstores do not support SQL analysis. Query Logstores are suitable for scenarios in which the amount of data is large, the log retention period is long, or log analysis is not required. If logs are stored for weeks or months, the log retention period is considered long.
	//
	// example:
	//
	// standard
	Mode *string `json:"mode,omitempty" xml:"mode,omitempty"`
	// Deprecated
	//
	// The number of shards.
	//
	// >  You cannot call the UpdateLogStore operation to change the number of shards. You can call the SplitShard or MergeShards operation to change the number of shards.
	//
	// example:
	//
	// 2
	ShardCount *int32 `json:"shardCount,omitempty" xml:"shardCount,omitempty"`
	// Deprecated
	//
	// The type of the observable data. Valid values:
	//
	// 	- None (default): log data.
	//
	// 	- Metrics: metric data.
	//
	// example:
	//
	// None
	TelemetryType *string `json:"telemetryType,omitempty" xml:"telemetryType,omitempty"`
	// The retention period of data. Unit: days. Valid values: 1 to 3650. If you set this parameter to 3650, logs are permanently stored.
	//
	// This parameter is required.
	//
	// example:
	//
	// 30
	Ttl *int32 `json:"ttl,omitempty" xml:"ttl,omitempty"`
}

func (s UpdateLogStoreRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogStoreRequest) GoString() string {
	return s.String()
}

func (s *UpdateLogStoreRequest) SetAppendMeta(v bool) *UpdateLogStoreRequest {
	s.AppendMeta = &v
	return s
}

func (s *UpdateLogStoreRequest) SetAutoSplit(v bool) *UpdateLogStoreRequest {
	s.AutoSplit = &v
	return s
}

func (s *UpdateLogStoreRequest) SetEnableTracking(v bool) *UpdateLogStoreRequest {
	s.EnableTracking = &v
	return s
}

func (s *UpdateLogStoreRequest) SetEncryptConf(v *EncryptConf) *UpdateLogStoreRequest {
	s.EncryptConf = v
	return s
}

func (s *UpdateLogStoreRequest) SetHotTtl(v int32) *UpdateLogStoreRequest {
	s.HotTtl = &v
	return s
}

func (s *UpdateLogStoreRequest) SetInfrequentAccessTTL(v int32) *UpdateLogStoreRequest {
	s.InfrequentAccessTTL = &v
	return s
}

func (s *UpdateLogStoreRequest) SetLogstoreName(v string) *UpdateLogStoreRequest {
	s.LogstoreName = &v
	return s
}

func (s *UpdateLogStoreRequest) SetMaxSplitShard(v int32) *UpdateLogStoreRequest {
	s.MaxSplitShard = &v
	return s
}

func (s *UpdateLogStoreRequest) SetMode(v string) *UpdateLogStoreRequest {
	s.Mode = &v
	return s
}

func (s *UpdateLogStoreRequest) SetShardCount(v int32) *UpdateLogStoreRequest {
	s.ShardCount = &v
	return s
}

func (s *UpdateLogStoreRequest) SetTelemetryType(v string) *UpdateLogStoreRequest {
	s.TelemetryType = &v
	return s
}

func (s *UpdateLogStoreRequest) SetTtl(v int32) *UpdateLogStoreRequest {
	s.Ttl = &v
	return s
}

type UpdateLogStoreResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateLogStoreResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogStoreResponse) GoString() string {
	return s.String()
}

func (s *UpdateLogStoreResponse) SetHeaders(v map[string]*string) *UpdateLogStoreResponse {
	s.Headers = v
	return s
}

func (s *UpdateLogStoreResponse) SetStatusCode(v int32) *UpdateLogStoreResponse {
	s.StatusCode = &v
	return s
}

type UpdateLogStoreEncryptionRequest struct {
	// Specifies whether to enable the encryption feature. After you update the encryption configuration of the Logstore, you can modify only the enable parameter in subsequent update requests. You cannot modify the encryptType or userCmkInfo parameters.
	//
	// This parameter is required.
	//
	// example:
	//
	// true
	Enable *bool `json:"enable,omitempty" xml:"enable,omitempty"`
	// The encryption algorithm. Valid values: default, m4, sm4_ecb, sm4_cbc, sm4_gcm, aes_ecb, aes_cbc, aes_cfb, aes_ofb, and aes_gcm.
	//
	// example:
	//
	// default
	EncryptType *string `json:"encryptType,omitempty" xml:"encryptType,omitempty"`
	// Optional. If you use a BYOK key to encrypt logs, you must specify this parameter. If you use the service key of Simple Log Service to encrypt logs, you do not need to specify this parameter.
	UserCmkInfo *UpdateLogStoreEncryptionRequestUserCmkInfo `json:"userCmkInfo,omitempty" xml:"userCmkInfo,omitempty" type:"Struct"`
}

func (s UpdateLogStoreEncryptionRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogStoreEncryptionRequest) GoString() string {
	return s.String()
}

func (s *UpdateLogStoreEncryptionRequest) SetEnable(v bool) *UpdateLogStoreEncryptionRequest {
	s.Enable = &v
	return s
}

func (s *UpdateLogStoreEncryptionRequest) SetEncryptType(v string) *UpdateLogStoreEncryptionRequest {
	s.EncryptType = &v
	return s
}

func (s *UpdateLogStoreEncryptionRequest) SetUserCmkInfo(v *UpdateLogStoreEncryptionRequestUserCmkInfo) *UpdateLogStoreEncryptionRequest {
	s.UserCmkInfo = v
	return s
}

type UpdateLogStoreEncryptionRequestUserCmkInfo struct {
	// The ID of the CMK to which the BYOK key belongs. You can create a CMK in KMS. The CMK must be in the same region as the endpoint of Simple Log Service.
	//
	// example:
	//
	// f5136b95-2420-ab31-xxxxxxxxx
	KeyId *string `json:"keyId,omitempty" xml:"keyId,omitempty"`
	// The region ID. Example: cn-hangzhou.
	//
	// example:
	//
	// cn-hangzhou
	RegionId *string `json:"regionId,omitempty" xml:"regionId,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the Resource Access Management (RAM) role.The value is in the acs:ram::12344\\*\\*\\*:role/xxxxx format. To use a BYOK key to encrypt logs, you must create a RAM role and grant the AliyunKMSReadOnlyAccess and AliyunKMSCryptoUserAccess permissions to the RAM role. You must grant the API caller the PassRole permission on the RAM role.
	//
	// example:
	//
	// acs:ram::12344***:role/xxxxx
	RoleArn *string `json:"roleArn,omitempty" xml:"roleArn,omitempty"`
}

func (s UpdateLogStoreEncryptionRequestUserCmkInfo) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogStoreEncryptionRequestUserCmkInfo) GoString() string {
	return s.String()
}

func (s *UpdateLogStoreEncryptionRequestUserCmkInfo) SetKeyId(v string) *UpdateLogStoreEncryptionRequestUserCmkInfo {
	s.KeyId = &v
	return s
}

func (s *UpdateLogStoreEncryptionRequestUserCmkInfo) SetRegionId(v string) *UpdateLogStoreEncryptionRequestUserCmkInfo {
	s.RegionId = &v
	return s
}

func (s *UpdateLogStoreEncryptionRequestUserCmkInfo) SetRoleArn(v string) *UpdateLogStoreEncryptionRequestUserCmkInfo {
	s.RoleArn = &v
	return s
}

type UpdateLogStoreEncryptionResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateLogStoreEncryptionResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogStoreEncryptionResponse) GoString() string {
	return s.String()
}

func (s *UpdateLogStoreEncryptionResponse) SetHeaders(v map[string]*string) *UpdateLogStoreEncryptionResponse {
	s.Headers = v
	return s
}

func (s *UpdateLogStoreEncryptionResponse) SetStatusCode(v int32) *UpdateLogStoreEncryptionResponse {
	s.StatusCode = &v
	return s
}

type UpdateLogStoreMeteringModeRequest struct {
	// The billing mode. Valid values: ChargeByFunction and ChargeByDataIngest. Default value: ChargeByFunction. The value ChargeByFunction specifies the pay-by-feature billing mode. The value ChargeByDataIngest specifies the pay-by-ingested-data billing mode.
	//
	// This parameter is required.
	//
	// example:
	//
	// ChargeByFunction
	MeteringMode *string `json:"meteringMode,omitempty" xml:"meteringMode,omitempty"`
}

func (s UpdateLogStoreMeteringModeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogStoreMeteringModeRequest) GoString() string {
	return s.String()
}

func (s *UpdateLogStoreMeteringModeRequest) SetMeteringMode(v string) *UpdateLogStoreMeteringModeRequest {
	s.MeteringMode = &v
	return s
}

type UpdateLogStoreMeteringModeResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateLogStoreMeteringModeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogStoreMeteringModeResponse) GoString() string {
	return s.String()
}

func (s *UpdateLogStoreMeteringModeResponse) SetHeaders(v map[string]*string) *UpdateLogStoreMeteringModeResponse {
	s.Headers = v
	return s
}

func (s *UpdateLogStoreMeteringModeResponse) SetStatusCode(v int32) *UpdateLogStoreMeteringModeResponse {
	s.StatusCode = &v
	return s
}

type UpdateLogStoreProcessorRequest struct {
	// The identifier of the ingest processor.
	//
	// This parameter is required.
	//
	// example:
	//
	// parse-nginx-log
	ProcessorName *string `json:"processorName,omitempty" xml:"processorName,omitempty"`
}

func (s UpdateLogStoreProcessorRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogStoreProcessorRequest) GoString() string {
	return s.String()
}

func (s *UpdateLogStoreProcessorRequest) SetProcessorName(v string) *UpdateLogStoreProcessorRequest {
	s.ProcessorName = &v
	return s
}

type UpdateLogStoreProcessorResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateLogStoreProcessorResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogStoreProcessorResponse) GoString() string {
	return s.String()
}

func (s *UpdateLogStoreProcessorResponse) SetHeaders(v map[string]*string) *UpdateLogStoreProcessorResponse {
	s.Headers = v
	return s
}

func (s *UpdateLogStoreProcessorResponse) SetStatusCode(v int32) *UpdateLogStoreProcessorResponse {
	s.StatusCode = &v
	return s
}

type UpdateLoggingRequest struct {
	// The configurations of service logs.
	//
	// This parameter is required.
	LoggingDetails []*UpdateLoggingRequestLoggingDetails `json:"loggingDetails,omitempty" xml:"loggingDetails,omitempty" type:"Repeated"`
	// The name of the project to which you want to save service logs.
	//
	// This parameter is required.
	//
	// example:
	//
	// my-project
	LoggingProject *string `json:"loggingProject,omitempty" xml:"loggingProject,omitempty"`
}

func (s UpdateLoggingRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateLoggingRequest) GoString() string {
	return s.String()
}

func (s *UpdateLoggingRequest) SetLoggingDetails(v []*UpdateLoggingRequestLoggingDetails) *UpdateLoggingRequest {
	s.LoggingDetails = v
	return s
}

func (s *UpdateLoggingRequest) SetLoggingProject(v string) *UpdateLoggingRequest {
	s.LoggingProject = &v
	return s
}

type UpdateLoggingRequestLoggingDetails struct {
	// The name of the Logstore to which you want to save service logs.
	//
	// This parameter is required.
	//
	// example:
	//
	// my-logstore
	Logstore *string `json:"logstore,omitempty" xml:"logstore,omitempty"`
	// The type of service logs. Valid values:
	//
	// 	- consumergroup_log: the consumption delay logs of consumer groups.
	//
	// 	- logtail_alarm: the alert logs of Logtail.
	//
	// 	- operation_log: the operation logs.
	//
	// 	- logtail_profile: the collection logs of Logtail.
	//
	// 	- metering: the metering logs.
	//
	// 	- logtail_status: the status logs of Logtail.
	//
	// 	- scheduledsqlalert: the operational logs of Scheduled SQL jobs.
	//
	// 	- etl_alert: the operational logs of data transformation jobs.
	//
	// This parameter is required.
	//
	// example:
	//
	// consumergroup_log
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s UpdateLoggingRequestLoggingDetails) String() string {
	return tea.Prettify(s)
}

func (s UpdateLoggingRequestLoggingDetails) GoString() string {
	return s.String()
}

func (s *UpdateLoggingRequestLoggingDetails) SetLogstore(v string) *UpdateLoggingRequestLoggingDetails {
	s.Logstore = &v
	return s
}

func (s *UpdateLoggingRequestLoggingDetails) SetType(v string) *UpdateLoggingRequestLoggingDetails {
	s.Type = &v
	return s
}

type UpdateLoggingResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateLoggingResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateLoggingResponse) GoString() string {
	return s.String()
}

func (s *UpdateLoggingResponse) SetHeaders(v map[string]*string) *UpdateLoggingResponse {
	s.Headers = v
	return s
}

func (s *UpdateLoggingResponse) SetStatusCode(v int32) *UpdateLoggingResponse {
	s.StatusCode = &v
	return s
}

type UpdateLogtailPipelineConfigRequest struct {
	// The aggregation plug-ins.
	//
	// >  This parameter takes effect only when extended plug-ins are used. You can use only one aggregation plug-in.
	Aggregators []map[string]interface{} `json:"aggregators,omitempty" xml:"aggregators,omitempty" type:"Repeated"`
	// The name of the configuration.
	//
	// >  The value of this parameter must be the same as the value of configName in the outer layer.
	//
	// This parameter is required.
	//
	// example:
	//
	// test-config
	ConfigName *string `json:"configName,omitempty" xml:"configName,omitempty"`
	// The output plug-ins.
	//
	// >  You can configure only one output plug-in.
	//
	// This parameter is required.
	Flushers []map[string]interface{} `json:"flushers,omitempty" xml:"flushers,omitempty" type:"Repeated"`
	// The global settings.
	Global map[string]interface{} `json:"global,omitempty" xml:"global,omitempty"`
	// The input plug-ins.
	//
	// >  You can configure only one input plug-in.
	//
	// This parameter is required.
	Inputs []map[string]interface{} `json:"inputs,omitempty" xml:"inputs,omitempty" type:"Repeated"`
	// The sample log. You can specify multiple sample logs.
	//
	// example:
	//
	// 2022-06-14 11:13:29.796 | DEBUG    | __main__:<module>:1 - hello world
	LogSample *string `json:"logSample,omitempty" xml:"logSample,omitempty"`
	// The processing plug-ins.
	//
	// >  Logtail plug-ins for data processing are classified into native plug-ins and extended plug-ins. For more information, see [Overview of Logtail plug-ins for data processing](https://help.aliyun.com/document_detail/64957.html).
	//
	// >
	//
	// 	- You can use native plug-ins only to collect text logs.
	//
	// 	- You cannot add native plug-ins and extended plug-ins at a time.
	//
	// 	- When you add native plug-ins, take note of the following items:
	//
	//     	- You must add one of the following Logtail plug-ins for data processing as the first plug-in: Data Parsing (Regex Mode), Data Parsing (Delimiter Mode), Data Parsing (JSON Mode), Data Parsing (NGINX Mode), Data Parsing (Apache Mode), and Data Parsing (IIS Mode).
	//
	//     	- After you add the first plug-in, you can add one Time Parsing plug-in, one Data Filtering plug-in, and multiple Data Masking plug-ins.
	Processors []map[string]interface{} `json:"processors,omitempty" xml:"processors,omitempty" type:"Repeated"`
}

func (s UpdateLogtailPipelineConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogtailPipelineConfigRequest) GoString() string {
	return s.String()
}

func (s *UpdateLogtailPipelineConfigRequest) SetAggregators(v []map[string]interface{}) *UpdateLogtailPipelineConfigRequest {
	s.Aggregators = v
	return s
}

func (s *UpdateLogtailPipelineConfigRequest) SetConfigName(v string) *UpdateLogtailPipelineConfigRequest {
	s.ConfigName = &v
	return s
}

func (s *UpdateLogtailPipelineConfigRequest) SetFlushers(v []map[string]interface{}) *UpdateLogtailPipelineConfigRequest {
	s.Flushers = v
	return s
}

func (s *UpdateLogtailPipelineConfigRequest) SetGlobal(v map[string]interface{}) *UpdateLogtailPipelineConfigRequest {
	s.Global = v
	return s
}

func (s *UpdateLogtailPipelineConfigRequest) SetInputs(v []map[string]interface{}) *UpdateLogtailPipelineConfigRequest {
	s.Inputs = v
	return s
}

func (s *UpdateLogtailPipelineConfigRequest) SetLogSample(v string) *UpdateLogtailPipelineConfigRequest {
	s.LogSample = &v
	return s
}

func (s *UpdateLogtailPipelineConfigRequest) SetProcessors(v []map[string]interface{}) *UpdateLogtailPipelineConfigRequest {
	s.Processors = v
	return s
}

type UpdateLogtailPipelineConfigResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateLogtailPipelineConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateLogtailPipelineConfigResponse) GoString() string {
	return s.String()
}

func (s *UpdateLogtailPipelineConfigResponse) SetHeaders(v map[string]*string) *UpdateLogtailPipelineConfigResponse {
	s.Headers = v
	return s
}

func (s *UpdateLogtailPipelineConfigResponse) SetStatusCode(v int32) *UpdateLogtailPipelineConfigResponse {
	s.StatusCode = &v
	return s
}

type UpdateMachineGroupRequest struct {
	// The attribute of the machine group. This parameter is empty by default.
	GroupAttribute *UpdateMachineGroupRequestGroupAttribute `json:"groupAttribute,omitempty" xml:"groupAttribute,omitempty" type:"Struct"`
	// The name of the machine group.
	//
	// This parameter is required.
	//
	// example:
	//
	// test-machine-group
	GroupName *string `json:"groupName,omitempty" xml:"groupName,omitempty"`
	// The type of the machine group. Set the value to an empty string.
	//
	// example:
	//
	// ""
	GroupType *string `json:"groupType,omitempty" xml:"groupType,omitempty"`
	// The identifier type of the machine group. Valid values:
	//
	// 	- ip: The machine group uses IP addresses as identifiers.
	//
	// 	- userdefined: The machine group uses custom identifiers.
	//
	// This parameter is required.
	//
	// example:
	//
	// userdefined
	MachineIdentifyType *string `json:"machineIdentifyType,omitempty" xml:"machineIdentifyType,omitempty"`
	// The identifiers of the machines in the machine group.
	//
	// 	- If you set machineIdentifyType to ip, enter the IP addresses of the machines.
	//
	// 	- If you set machineIdentifyType to userdefined, enter a custom identifier.
	//
	// This parameter is required.
	//
	// example:
	//
	// [uu_id_1，uu_id_2]
	MachineList []*string `json:"machineList,omitempty" xml:"machineList,omitempty" type:"Repeated"`
}

func (s UpdateMachineGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateMachineGroupRequest) GoString() string {
	return s.String()
}

func (s *UpdateMachineGroupRequest) SetGroupAttribute(v *UpdateMachineGroupRequestGroupAttribute) *UpdateMachineGroupRequest {
	s.GroupAttribute = v
	return s
}

func (s *UpdateMachineGroupRequest) SetGroupName(v string) *UpdateMachineGroupRequest {
	s.GroupName = &v
	return s
}

func (s *UpdateMachineGroupRequest) SetGroupType(v string) *UpdateMachineGroupRequest {
	s.GroupType = &v
	return s
}

func (s *UpdateMachineGroupRequest) SetMachineIdentifyType(v string) *UpdateMachineGroupRequest {
	s.MachineIdentifyType = &v
	return s
}

func (s *UpdateMachineGroupRequest) SetMachineList(v []*string) *UpdateMachineGroupRequest {
	s.MachineList = v
	return s
}

type UpdateMachineGroupRequestGroupAttribute struct {
	// The identifier of the external management system on which the machine group depends. This parameter is empty by default.
	//
	// example:
	//
	// testgroup2
	ExternalName *string `json:"externalName,omitempty" xml:"externalName,omitempty"`
	// The topic of the machine group. This parameter is empty by default.
	//
	// example:
	//
	// testtopic2
	GroupTopic *string `json:"groupTopic,omitempty" xml:"groupTopic,omitempty"`
}

func (s UpdateMachineGroupRequestGroupAttribute) String() string {
	return tea.Prettify(s)
}

func (s UpdateMachineGroupRequestGroupAttribute) GoString() string {
	return s.String()
}

func (s *UpdateMachineGroupRequestGroupAttribute) SetExternalName(v string) *UpdateMachineGroupRequestGroupAttribute {
	s.ExternalName = &v
	return s
}

func (s *UpdateMachineGroupRequestGroupAttribute) SetGroupTopic(v string) *UpdateMachineGroupRequestGroupAttribute {
	s.GroupTopic = &v
	return s
}

type UpdateMachineGroupResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateMachineGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateMachineGroupResponse) GoString() string {
	return s.String()
}

func (s *UpdateMachineGroupResponse) SetHeaders(v map[string]*string) *UpdateMachineGroupResponse {
	s.Headers = v
	return s
}

func (s *UpdateMachineGroupResponse) SetStatusCode(v int32) *UpdateMachineGroupResponse {
	s.StatusCode = &v
	return s
}

type UpdateMachineGroupMachineRequest struct {
	// The operation on the machine. Valid values: add and delete. A value of add specifies to add the machine to the machine group. A value of delete specifies to remove the machine from the machine group.
	//
	// example:
	//
	// add
	Action *string `json:"action,omitempty" xml:"action,omitempty"`
	// The machines to be added or removed.
	//
	// This parameter is required.
	Body []*string `json:"body,omitempty" xml:"body,omitempty" type:"Repeated"`
}

func (s UpdateMachineGroupMachineRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateMachineGroupMachineRequest) GoString() string {
	return s.String()
}

func (s *UpdateMachineGroupMachineRequest) SetAction(v string) *UpdateMachineGroupMachineRequest {
	s.Action = &v
	return s
}

func (s *UpdateMachineGroupMachineRequest) SetBody(v []*string) *UpdateMachineGroupMachineRequest {
	s.Body = v
	return s
}

type UpdateMachineGroupMachineResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateMachineGroupMachineResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateMachineGroupMachineResponse) GoString() string {
	return s.String()
}

func (s *UpdateMachineGroupMachineResponse) SetHeaders(v map[string]*string) *UpdateMachineGroupMachineResponse {
	s.Headers = v
	return s
}

func (s *UpdateMachineGroupMachineResponse) SetStatusCode(v int32) *UpdateMachineGroupMachineResponse {
	s.StatusCode = &v
	return s
}

type UpdateMetricStoreRequest struct {
	// Specifies whether to enable automatic sharding.
	//
	// example:
	//
	// true
	AutoSplit           *bool  `json:"autoSplit,omitempty" xml:"autoSplit,omitempty"`
	HotTtl              *int32 `json:"hot_ttl,omitempty" xml:"hot_ttl,omitempty"`
	InfrequentAccessTTL *int32 `json:"infrequentAccessTTL,omitempty" xml:"infrequentAccessTTL,omitempty"`
	// The maximum number of shards into which existing shards can be automatically split. This parameter is valid only when you set the autoSplit parameter to true.
	//
	// example:
	//
	// 64
	MaxSplitShard *int32 `json:"maxSplitShard,omitempty" xml:"maxSplitShard,omitempty"`
	// The type of the Metricstore.
	//
	// example:
	//
	// standard
	Mode *string `json:"mode,omitempty" xml:"mode,omitempty"`
	// The retention period of the metric data. Unit: days.
	//
	// example:
	//
	// 7
	Ttl *int32 `json:"ttl,omitempty" xml:"ttl,omitempty"`
}

func (s UpdateMetricStoreRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateMetricStoreRequest) GoString() string {
	return s.String()
}

func (s *UpdateMetricStoreRequest) SetAutoSplit(v bool) *UpdateMetricStoreRequest {
	s.AutoSplit = &v
	return s
}

func (s *UpdateMetricStoreRequest) SetHotTtl(v int32) *UpdateMetricStoreRequest {
	s.HotTtl = &v
	return s
}

func (s *UpdateMetricStoreRequest) SetInfrequentAccessTTL(v int32) *UpdateMetricStoreRequest {
	s.InfrequentAccessTTL = &v
	return s
}

func (s *UpdateMetricStoreRequest) SetMaxSplitShard(v int32) *UpdateMetricStoreRequest {
	s.MaxSplitShard = &v
	return s
}

func (s *UpdateMetricStoreRequest) SetMode(v string) *UpdateMetricStoreRequest {
	s.Mode = &v
	return s
}

func (s *UpdateMetricStoreRequest) SetTtl(v int32) *UpdateMetricStoreRequest {
	s.Ttl = &v
	return s
}

type UpdateMetricStoreResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateMetricStoreResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateMetricStoreResponse) GoString() string {
	return s.String()
}

func (s *UpdateMetricStoreResponse) SetHeaders(v map[string]*string) *UpdateMetricStoreResponse {
	s.Headers = v
	return s
}

func (s *UpdateMetricStoreResponse) SetStatusCode(v int32) *UpdateMetricStoreResponse {
	s.StatusCode = &v
	return s
}

type UpdateMetricStoreMeteringModeRequest struct {
	// This parameter is required.
	//
	// example:
	//
	// ChargeByFunction
	MeteringMode *string `json:"meteringMode,omitempty" xml:"meteringMode,omitempty"`
}

func (s UpdateMetricStoreMeteringModeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateMetricStoreMeteringModeRequest) GoString() string {
	return s.String()
}

func (s *UpdateMetricStoreMeteringModeRequest) SetMeteringMode(v string) *UpdateMetricStoreMeteringModeRequest {
	s.MeteringMode = &v
	return s
}

type UpdateMetricStoreMeteringModeResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateMetricStoreMeteringModeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateMetricStoreMeteringModeResponse) GoString() string {
	return s.String()
}

func (s *UpdateMetricStoreMeteringModeResponse) SetHeaders(v map[string]*string) *UpdateMetricStoreMeteringModeResponse {
	s.Headers = v
	return s
}

func (s *UpdateMetricStoreMeteringModeResponse) SetStatusCode(v int32) *UpdateMetricStoreMeteringModeResponse {
	s.StatusCode = &v
	return s
}

type UpdateMetricStoreProcessorRequest struct {
	// The identifier of the ingest processor.
	//
	// This parameter is required.
	//
	// example:
	//
	// filter-metrics
	ProcessorName *string `json:"processorName,omitempty" xml:"processorName,omitempty"`
}

func (s UpdateMetricStoreProcessorRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateMetricStoreProcessorRequest) GoString() string {
	return s.String()
}

func (s *UpdateMetricStoreProcessorRequest) SetProcessorName(v string) *UpdateMetricStoreProcessorRequest {
	s.ProcessorName = &v
	return s
}

type UpdateMetricStoreProcessorResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateMetricStoreProcessorResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateMetricStoreProcessorResponse) GoString() string {
	return s.String()
}

func (s *UpdateMetricStoreProcessorResponse) SetHeaders(v map[string]*string) *UpdateMetricStoreProcessorResponse {
	s.Headers = v
	return s
}

func (s *UpdateMetricStoreProcessorResponse) SetStatusCode(v int32) *UpdateMetricStoreProcessorResponse {
	s.StatusCode = &v
	return s
}

type UpdateOSSExportRequest struct {
	// The configuration details of the job.
	Configuration *OSSExportConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty"`
	// The description of the job.
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// The display name of the job.
	//
	// example:
	//
	// ali-test-oss-job
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
}

func (s UpdateOSSExportRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateOSSExportRequest) GoString() string {
	return s.String()
}

func (s *UpdateOSSExportRequest) SetConfiguration(v *OSSExportConfiguration) *UpdateOSSExportRequest {
	s.Configuration = v
	return s
}

func (s *UpdateOSSExportRequest) SetDescription(v string) *UpdateOSSExportRequest {
	s.Description = &v
	return s
}

func (s *UpdateOSSExportRequest) SetDisplayName(v string) *UpdateOSSExportRequest {
	s.DisplayName = &v
	return s
}

type UpdateOSSExportResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateOSSExportResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateOSSExportResponse) GoString() string {
	return s.String()
}

func (s *UpdateOSSExportResponse) SetHeaders(v map[string]*string) *UpdateOSSExportResponse {
	s.Headers = v
	return s
}

func (s *UpdateOSSExportResponse) SetStatusCode(v int32) *UpdateOSSExportResponse {
	s.StatusCode = &v
	return s
}

type UpdateOSSHDFSExportRequest struct {
	// The configuration details of the job.
	//
	// This parameter is required.
	Configuration *OSSExportConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty"`
	// The description of the job.
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// The display name of the job.
	//
	// This parameter is required.
	//
	// example:
	//
	// ali-test-oss-hdfs-job
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
}

func (s UpdateOSSHDFSExportRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateOSSHDFSExportRequest) GoString() string {
	return s.String()
}

func (s *UpdateOSSHDFSExportRequest) SetConfiguration(v *OSSExportConfiguration) *UpdateOSSHDFSExportRequest {
	s.Configuration = v
	return s
}

func (s *UpdateOSSHDFSExportRequest) SetDescription(v string) *UpdateOSSHDFSExportRequest {
	s.Description = &v
	return s
}

func (s *UpdateOSSHDFSExportRequest) SetDisplayName(v string) *UpdateOSSHDFSExportRequest {
	s.DisplayName = &v
	return s
}

type UpdateOSSHDFSExportResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateOSSHDFSExportResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateOSSHDFSExportResponse) GoString() string {
	return s.String()
}

func (s *UpdateOSSHDFSExportResponse) SetHeaders(v map[string]*string) *UpdateOSSHDFSExportResponse {
	s.Headers = v
	return s
}

func (s *UpdateOSSHDFSExportResponse) SetStatusCode(v int32) *UpdateOSSHDFSExportResponse {
	s.StatusCode = &v
	return s
}

type UpdateOSSIngestionRequest struct {
	// The configurations of the OSS data import job.
	//
	// This parameter is required.
	Configuration *OSSIngestionConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty"`
	// The description of the OSS data import job.
	Description *string `json:"description,omitempty" xml:"description,omitempty"`
	// The display name of the OSS data import job.
	//
	// This parameter is required.
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// The scheduling type. By default, you do not need to specify this parameter. If you want to import data at regular intervals, such as importing data every Monday at 08: 00., you can specify a cron expression.
	Schedule *Schedule `json:"schedule,omitempty" xml:"schedule,omitempty"`
}

func (s UpdateOSSIngestionRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateOSSIngestionRequest) GoString() string {
	return s.String()
}

func (s *UpdateOSSIngestionRequest) SetConfiguration(v *OSSIngestionConfiguration) *UpdateOSSIngestionRequest {
	s.Configuration = v
	return s
}

func (s *UpdateOSSIngestionRequest) SetDescription(v string) *UpdateOSSIngestionRequest {
	s.Description = &v
	return s
}

func (s *UpdateOSSIngestionRequest) SetDisplayName(v string) *UpdateOSSIngestionRequest {
	s.DisplayName = &v
	return s
}

func (s *UpdateOSSIngestionRequest) SetSchedule(v *Schedule) *UpdateOSSIngestionRequest {
	s.Schedule = v
	return s
}

type UpdateOSSIngestionResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateOSSIngestionResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateOSSIngestionResponse) GoString() string {
	return s.String()
}

func (s *UpdateOSSIngestionResponse) SetHeaders(v map[string]*string) *UpdateOSSIngestionResponse {
	s.Headers = v
	return s
}

func (s *UpdateOSSIngestionResponse) SetStatusCode(v int32) *UpdateOSSIngestionResponse {
	s.StatusCode = &v
	return s
}

type UpdateOssExternalStoreRequest struct {
	// The name of the external store.
	//
	// This parameter is required.
	//
	// example:
	//
	// test-oss-store
	ExternalStoreName *string `json:"externalStoreName,omitempty" xml:"externalStoreName,omitempty"`
	// The parameters that are configured for the external store.
	//
	// This parameter is required.
	Parameter *UpdateOssExternalStoreRequestParameter `json:"parameter,omitempty" xml:"parameter,omitempty" type:"Struct"`
	// The type of the external store. Set the value to oss.
	//
	// This parameter is required.
	//
	// example:
	//
	// oss
	StoreType *string `json:"storeType,omitempty" xml:"storeType,omitempty"`
}

func (s UpdateOssExternalStoreRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateOssExternalStoreRequest) GoString() string {
	return s.String()
}

func (s *UpdateOssExternalStoreRequest) SetExternalStoreName(v string) *UpdateOssExternalStoreRequest {
	s.ExternalStoreName = &v
	return s
}

func (s *UpdateOssExternalStoreRequest) SetParameter(v *UpdateOssExternalStoreRequestParameter) *UpdateOssExternalStoreRequest {
	s.Parameter = v
	return s
}

func (s *UpdateOssExternalStoreRequest) SetStoreType(v string) *UpdateOssExternalStoreRequest {
	s.StoreType = &v
	return s
}

type UpdateOssExternalStoreRequestParameter struct {
	// The AccessKey ID of your account.
	//
	// This parameter is required.
	//
	// example:
	//
	// LTAI5tFsHGGeYry*****1Sz
	Accessid *string `json:"accessid,omitempty" xml:"accessid,omitempty"`
	// The AccessKey secret of your account.
	//
	// This parameter is required.
	//
	// example:
	//
	// GyviCLDVHkHrOztdkxuE6******Rp6
	Accesskey *string `json:"accesskey,omitempty" xml:"accesskey,omitempty"`
	// The name of the OSS bucket.
	//
	// This parameter is required.
	//
	// example:
	//
	// my-bucket
	Bucket *string `json:"bucket,omitempty" xml:"bucket,omitempty"`
	// The fields that are associated to the external store.
	//
	// This parameter is required.
	Columns []*UpdateOssExternalStoreRequestParameterColumns `json:"columns,omitempty" xml:"columns,omitempty" type:"Repeated"`
	// The Object Storage Service (OSS) endpoint.
	//
	// This parameter is required.
	//
	// example:
	//
	// oss-cn-hangzhou.aliyuncs.com
	Endpoint *string `json:"endpoint,omitempty" xml:"endpoint,omitempty"`
	// The names of the OSS objects that are associated to the external store.
	//
	// This parameter is required.
	Objects []*string `json:"objects,omitempty" xml:"objects,omitempty" type:"Repeated"`
}

func (s UpdateOssExternalStoreRequestParameter) String() string {
	return tea.Prettify(s)
}

func (s UpdateOssExternalStoreRequestParameter) GoString() string {
	return s.String()
}

func (s *UpdateOssExternalStoreRequestParameter) SetAccessid(v string) *UpdateOssExternalStoreRequestParameter {
	s.Accessid = &v
	return s
}

func (s *UpdateOssExternalStoreRequestParameter) SetAccesskey(v string) *UpdateOssExternalStoreRequestParameter {
	s.Accesskey = &v
	return s
}

func (s *UpdateOssExternalStoreRequestParameter) SetBucket(v string) *UpdateOssExternalStoreRequestParameter {
	s.Bucket = &v
	return s
}

func (s *UpdateOssExternalStoreRequestParameter) SetColumns(v []*UpdateOssExternalStoreRequestParameterColumns) *UpdateOssExternalStoreRequestParameter {
	s.Columns = v
	return s
}

func (s *UpdateOssExternalStoreRequestParameter) SetEndpoint(v string) *UpdateOssExternalStoreRequestParameter {
	s.Endpoint = &v
	return s
}

func (s *UpdateOssExternalStoreRequestParameter) SetObjects(v []*string) *UpdateOssExternalStoreRequestParameter {
	s.Objects = v
	return s
}

type UpdateOssExternalStoreRequestParameterColumns struct {
	// The name of the field.
	//
	// This parameter is required.
	//
	// example:
	//
	// test
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The type of the field.
	//
	// This parameter is required.
	//
	// example:
	//
	// varchar
	Type *string `json:"type,omitempty" xml:"type,omitempty"`
}

func (s UpdateOssExternalStoreRequestParameterColumns) String() string {
	return tea.Prettify(s)
}

func (s UpdateOssExternalStoreRequestParameterColumns) GoString() string {
	return s.String()
}

func (s *UpdateOssExternalStoreRequestParameterColumns) SetName(v string) *UpdateOssExternalStoreRequestParameterColumns {
	s.Name = &v
	return s
}

func (s *UpdateOssExternalStoreRequestParameterColumns) SetType(v string) *UpdateOssExternalStoreRequestParameterColumns {
	s.Type = &v
	return s
}

type UpdateOssExternalStoreResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateOssExternalStoreResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateOssExternalStoreResponse) GoString() string {
	return s.String()
}

func (s *UpdateOssExternalStoreResponse) SetHeaders(v map[string]*string) *UpdateOssExternalStoreResponse {
	s.Headers = v
	return s
}

func (s *UpdateOssExternalStoreResponse) SetStatusCode(v int32) *UpdateOssExternalStoreResponse {
	s.StatusCode = &v
	return s
}

type UpdateProjectRequest struct {
	// The description of the project. The default value is an empty string.
	//
	// This parameter is required.
	//
	// example:
	//
	// Description of my-project-test
	Description       *string `json:"description,omitempty" xml:"description,omitempty"`
	RecycleBinEnabled *bool   `json:"recycleBinEnabled,omitempty" xml:"recycleBinEnabled,omitempty"`
}

func (s UpdateProjectRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateProjectRequest) GoString() string {
	return s.String()
}

func (s *UpdateProjectRequest) SetDescription(v string) *UpdateProjectRequest {
	s.Description = &v
	return s
}

func (s *UpdateProjectRequest) SetRecycleBinEnabled(v bool) *UpdateProjectRequest {
	s.RecycleBinEnabled = &v
	return s
}

type UpdateProjectResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateProjectResponse) GoString() string {
	return s.String()
}

func (s *UpdateProjectResponse) SetHeaders(v map[string]*string) *UpdateProjectResponse {
	s.Headers = v
	return s
}

func (s *UpdateProjectResponse) SetStatusCode(v int32) *UpdateProjectResponse {
	s.StatusCode = &v
	return s
}

type UpdateRdsExternalStoreRequest struct {
	// The name of the external store.
	//
	// This parameter is required.
	//
	// example:
	//
	// rds_store
	ExternalStoreName *string `json:"externalStoreName,omitempty" xml:"externalStoreName,omitempty"`
	// The parameter struct.
	//
	// This parameter is required.
	Parameter *UpdateRdsExternalStoreRequestParameter `json:"parameter,omitempty" xml:"parameter,omitempty" type:"Struct"`
	// The storage type. Set the value to rds-vpc, which indicates an ApsaraDB RDS for MySQL database in a virtual private cloud (VPC).
	//
	// This parameter is required.
	//
	// example:
	//
	// rds-vpc
	StoreType *string `json:"storeType,omitempty" xml:"storeType,omitempty"`
}

func (s UpdateRdsExternalStoreRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateRdsExternalStoreRequest) GoString() string {
	return s.String()
}

func (s *UpdateRdsExternalStoreRequest) SetExternalStoreName(v string) *UpdateRdsExternalStoreRequest {
	s.ExternalStoreName = &v
	return s
}

func (s *UpdateRdsExternalStoreRequest) SetParameter(v *UpdateRdsExternalStoreRequestParameter) *UpdateRdsExternalStoreRequest {
	s.Parameter = v
	return s
}

func (s *UpdateRdsExternalStoreRequest) SetStoreType(v string) *UpdateRdsExternalStoreRequest {
	s.StoreType = &v
	return s
}

type UpdateRdsExternalStoreRequestParameter struct {
	// The name of the database in the ApsaraDB RDS for MySQL instance.
	//
	// This parameter is required.
	//
	// example:
	//
	// meta
	Db *string `json:"db,omitempty" xml:"db,omitempty"`
	// The internal or public endpoint of the ApsaraDB RDS for MySQL instance.
	//
	// example:
	//
	// 192.168.XX.XX
	Host *string `json:"host,omitempty" xml:"host,omitempty"`
	// The ID of the ApsaraDB RDS for MySQL instance.
	//
	// example:
	//
	// i-bp1b6c719dfa08exf****
	InstanceId *string `json:"instance-id,omitempty" xml:"instance-id,omitempty"`
	// The password that is used to log on to the ApsaraDB RDS for MySQL instance.
	//
	// This parameter is required.
	//
	// example:
	//
	// sfdsfldsfksfls****
	Password *string `json:"password,omitempty" xml:"password,omitempty"`
	// The internal or public port of the ApsaraDB RDS for MySQL instance.
	//
	// This parameter is required.
	//
	// example:
	//
	// 3306
	Port *string `json:"port,omitempty" xml:"port,omitempty"`
	// The region where the ApsaraDB RDS for MySQL instance resides. Valid values: cn-qingdao, cn-beijing, and cn-hangzhou.
	//
	// This parameter is required.
	//
	// example:
	//
	// cn-qingdao
	Region *string `json:"region,omitempty" xml:"region,omitempty"`
	// The name of the database table in the ApsaraDB RDS for MySQL instance.
	//
	// This parameter is required.
	//
	// example:
	//
	// join_meta
	Table *string `json:"table,omitempty" xml:"table,omitempty"`
	// The username that is used to log on to the ApsaraDB RDS for MySQL instance.
	//
	// This parameter is required.
	//
	// example:
	//
	// root
	Username *string `json:"username,omitempty" xml:"username,omitempty"`
	// The ID of the VPC to which the ApsaraDB RDS for MySQL instance belongs.
	//
	// example:
	//
	// vpc-bp1aevy8sofi8mh1q****
	VpcId *string `json:"vpc-id,omitempty" xml:"vpc-id,omitempty"`
}

func (s UpdateRdsExternalStoreRequestParameter) String() string {
	return tea.Prettify(s)
}

func (s UpdateRdsExternalStoreRequestParameter) GoString() string {
	return s.String()
}

func (s *UpdateRdsExternalStoreRequestParameter) SetDb(v string) *UpdateRdsExternalStoreRequestParameter {
	s.Db = &v
	return s
}

func (s *UpdateRdsExternalStoreRequestParameter) SetHost(v string) *UpdateRdsExternalStoreRequestParameter {
	s.Host = &v
	return s
}

func (s *UpdateRdsExternalStoreRequestParameter) SetInstanceId(v string) *UpdateRdsExternalStoreRequestParameter {
	s.InstanceId = &v
	return s
}

func (s *UpdateRdsExternalStoreRequestParameter) SetPassword(v string) *UpdateRdsExternalStoreRequestParameter {
	s.Password = &v
	return s
}

func (s *UpdateRdsExternalStoreRequestParameter) SetPort(v string) *UpdateRdsExternalStoreRequestParameter {
	s.Port = &v
	return s
}

func (s *UpdateRdsExternalStoreRequestParameter) SetRegion(v string) *UpdateRdsExternalStoreRequestParameter {
	s.Region = &v
	return s
}

func (s *UpdateRdsExternalStoreRequestParameter) SetTable(v string) *UpdateRdsExternalStoreRequestParameter {
	s.Table = &v
	return s
}

func (s *UpdateRdsExternalStoreRequestParameter) SetUsername(v string) *UpdateRdsExternalStoreRequestParameter {
	s.Username = &v
	return s
}

func (s *UpdateRdsExternalStoreRequestParameter) SetVpcId(v string) *UpdateRdsExternalStoreRequestParameter {
	s.VpcId = &v
	return s
}

type UpdateRdsExternalStoreResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateRdsExternalStoreResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateRdsExternalStoreResponse) GoString() string {
	return s.String()
}

func (s *UpdateRdsExternalStoreResponse) SetHeaders(v map[string]*string) *UpdateRdsExternalStoreResponse {
	s.Headers = v
	return s
}

func (s *UpdateRdsExternalStoreResponse) SetStatusCode(v int32) *UpdateRdsExternalStoreResponse {
	s.StatusCode = &v
	return s
}

type UpdateSavedSearchRequest struct {
	// The display name.
	//
	// This parameter is required.
	//
	// example:
	//
	// displayname
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// The name of the Logstore to which the saved search belongs.
	//
	// This parameter is required.
	//
	// example:
	//
	// aliyun-test-logstore
	Logstore *string `json:"logstore,omitempty" xml:"logstore,omitempty"`
	// The name of the saved search. The name must be 3 to 63 characters in length.
	//
	// This parameter is required.
	//
	// example:
	//
	// savedsearch-name
	SavedsearchName *string `json:"savedsearchName,omitempty" xml:"savedsearchName,omitempty"`
	// The query statement of the saved search. A query statement consists of a search statement and an analytic statement in the Search statement|Analytic statement format. For more information, see [Log search overview](https://help.aliyun.com/document_detail/43772.html) and [Log analysis overview](https://help.aliyun.com/document_detail/53608.html).
	//
	// This parameter is required.
	//
	// example:
	//
	// *|select date_format(__time__-__time__%60, \\"%H:%i:%s\\") as time, COUNT(*) as pv group by time
	SearchQuery *string `json:"searchQuery,omitempty" xml:"searchQuery,omitempty"`
	// The topic of the logs.
	//
	// example:
	//
	// theme
	Topic *string `json:"topic,omitempty" xml:"topic,omitempty"`
}

func (s UpdateSavedSearchRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateSavedSearchRequest) GoString() string {
	return s.String()
}

func (s *UpdateSavedSearchRequest) SetDisplayName(v string) *UpdateSavedSearchRequest {
	s.DisplayName = &v
	return s
}

func (s *UpdateSavedSearchRequest) SetLogstore(v string) *UpdateSavedSearchRequest {
	s.Logstore = &v
	return s
}

func (s *UpdateSavedSearchRequest) SetSavedsearchName(v string) *UpdateSavedSearchRequest {
	s.SavedsearchName = &v
	return s
}

func (s *UpdateSavedSearchRequest) SetSearchQuery(v string) *UpdateSavedSearchRequest {
	s.SearchQuery = &v
	return s
}

func (s *UpdateSavedSearchRequest) SetTopic(v string) *UpdateSavedSearchRequest {
	s.Topic = &v
	return s
}

type UpdateSavedSearchResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateSavedSearchResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateSavedSearchResponse) GoString() string {
	return s.String()
}

func (s *UpdateSavedSearchResponse) SetHeaders(v map[string]*string) *UpdateSavedSearchResponse {
	s.Headers = v
	return s
}

func (s *UpdateSavedSearchResponse) SetStatusCode(v int32) *UpdateSavedSearchResponse {
	s.StatusCode = &v
	return s
}

type UpdateScheduledSQLRequest struct {
	// This parameter is required.
	Configuration *ScheduledSQLConfiguration `json:"configuration,omitempty" xml:"configuration,omitempty"`
	Description   *string                    `json:"description,omitempty" xml:"description,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// ali-test-scheduled-sql
	DisplayName *string `json:"displayName,omitempty" xml:"displayName,omitempty"`
	// This parameter is required.
	Schedule *Schedule `json:"schedule,omitempty" xml:"schedule,omitempty"`
}

func (s UpdateScheduledSQLRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateScheduledSQLRequest) GoString() string {
	return s.String()
}

func (s *UpdateScheduledSQLRequest) SetConfiguration(v *ScheduledSQLConfiguration) *UpdateScheduledSQLRequest {
	s.Configuration = v
	return s
}

func (s *UpdateScheduledSQLRequest) SetDescription(v string) *UpdateScheduledSQLRequest {
	s.Description = &v
	return s
}

func (s *UpdateScheduledSQLRequest) SetDisplayName(v string) *UpdateScheduledSQLRequest {
	s.DisplayName = &v
	return s
}

func (s *UpdateScheduledSQLRequest) SetSchedule(v *Schedule) *UpdateScheduledSQLRequest {
	s.Schedule = v
	return s
}

type UpdateScheduledSQLResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateScheduledSQLResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateScheduledSQLResponse) GoString() string {
	return s.String()
}

func (s *UpdateScheduledSQLResponse) SetHeaders(v map[string]*string) *UpdateScheduledSQLResponse {
	s.Headers = v
	return s
}

func (s *UpdateScheduledSQLResponse) SetStatusCode(v int32) *UpdateScheduledSQLResponse {
	s.StatusCode = &v
	return s
}

type UpdateSqlInstanceRequest struct {
	// This parameter is required.
	//
	// example:
	//
	// 2
	Cu *int32 `json:"cu,omitempty" xml:"cu,omitempty"`
	// This parameter is required.
	UseAsDefault *bool `json:"useAsDefault,omitempty" xml:"useAsDefault,omitempty"`
}

func (s UpdateSqlInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateSqlInstanceRequest) GoString() string {
	return s.String()
}

func (s *UpdateSqlInstanceRequest) SetCu(v int32) *UpdateSqlInstanceRequest {
	s.Cu = &v
	return s
}

func (s *UpdateSqlInstanceRequest) SetUseAsDefault(v bool) *UpdateSqlInstanceRequest {
	s.UseAsDefault = &v
	return s
}

type UpdateSqlInstanceResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateSqlInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateSqlInstanceResponse) GoString() string {
	return s.String()
}

func (s *UpdateSqlInstanceResponse) SetHeaders(v map[string]*string) *UpdateSqlInstanceResponse {
	s.Headers = v
	return s
}

func (s *UpdateSqlInstanceResponse) SetStatusCode(v int32) *UpdateSqlInstanceResponse {
	s.StatusCode = &v
	return s
}

type UpdateStoreViewRequest struct {
	// The type of the dataset.
	//
	// Valid values:
	//
	// 	- metricstore
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// 	- logstore
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// This parameter is required.
	//
	// example:
	//
	// logstore
	StoreType *string `json:"storeType,omitempty" xml:"storeType,omitempty"`
	// The Logstores or Metricstores.
	//
	// This parameter is required.
	Stores []*StoreViewStore `json:"stores,omitempty" xml:"stores,omitempty" type:"Repeated"`
}

func (s UpdateStoreViewRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateStoreViewRequest) GoString() string {
	return s.String()
}

func (s *UpdateStoreViewRequest) SetStoreType(v string) *UpdateStoreViewRequest {
	s.StoreType = &v
	return s
}

func (s *UpdateStoreViewRequest) SetStores(v []*StoreViewStore) *UpdateStoreViewRequest {
	s.Stores = v
	return s
}

type UpdateStoreViewResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpdateStoreViewResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateStoreViewResponse) GoString() string {
	return s.String()
}

func (s *UpdateStoreViewResponse) SetHeaders(v map[string]*string) *UpdateStoreViewResponse {
	s.Headers = v
	return s
}

func (s *UpdateStoreViewResponse) SetStatusCode(v int32) *UpdateStoreViewResponse {
	s.StatusCode = &v
	return s
}

type UpsertCollectionPolicyRequest struct {
	// The configurations of centralized storage.
	CentralizeConfig *UpsertCollectionPolicyRequestCentralizeConfig `json:"centralizeConfig,omitempty" xml:"centralizeConfig,omitempty" type:"Struct"`
	// Specifies whether to enable centralized storage. Default value: false.
	//
	// example:
	//
	// false
	CentralizeEnabled *bool `json:"centralizeEnabled,omitempty" xml:"centralizeEnabled,omitempty"`
	// The code of the log type.
	//
	// This parameter is required.
	//
	// example:
	//
	// access_log
	DataCode *string `json:"dataCode,omitempty" xml:"dataCode,omitempty"`
	// The data configurations. The configuration is returned only for global logs. For example, if productCode is set to sls, the configuration is returned.
	DataConfig *UpsertCollectionPolicyRequestDataConfig `json:"dataConfig,omitempty" xml:"dataConfig,omitempty" type:"Struct"`
	// Specifies whether to enable the policy.
	//
	// This parameter is required.
	//
	// example:
	//
	// true
	Enabled *bool `json:"enabled,omitempty" xml:"enabled,omitempty"`
	// The configurations of the policy.
	//
	// This parameter is required.
	PolicyConfig *UpsertCollectionPolicyRequestPolicyConfig `json:"policyConfig,omitempty" xml:"policyConfig,omitempty" type:"Struct"`
	// The name must meet the following requirements:
	//
	// 	- The name can contain only lowercase letters, digits, hyphens (-), and underscores (_).
	//
	// 	- The name must start with a letter.
	//
	// 	- The name must be 3 to 63 characters in length.
	//
	// This parameter is required.
	//
	// example:
	//
	// your_log_policy
	PolicyName *string `json:"policyName,omitempty" xml:"policyName,omitempty"`
	// The code of the service.
	//
	// This parameter is required.
	//
	// example:
	//
	// oss
	ProductCode *string `json:"productCode,omitempty" xml:"productCode,omitempty"`
	// The configurations of the resource directory. The account must have activated the resource directory and be a management account or a delegated administrator of the resource directory.
	ResourceDirectory *UpsertCollectionPolicyRequestResourceDirectory `json:"resourceDirectory,omitempty" xml:"resourceDirectory,omitempty" type:"Struct"`
}

func (s UpsertCollectionPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s UpsertCollectionPolicyRequest) GoString() string {
	return s.String()
}

func (s *UpsertCollectionPolicyRequest) SetCentralizeConfig(v *UpsertCollectionPolicyRequestCentralizeConfig) *UpsertCollectionPolicyRequest {
	s.CentralizeConfig = v
	return s
}

func (s *UpsertCollectionPolicyRequest) SetCentralizeEnabled(v bool) *UpsertCollectionPolicyRequest {
	s.CentralizeEnabled = &v
	return s
}

func (s *UpsertCollectionPolicyRequest) SetDataCode(v string) *UpsertCollectionPolicyRequest {
	s.DataCode = &v
	return s
}

func (s *UpsertCollectionPolicyRequest) SetDataConfig(v *UpsertCollectionPolicyRequestDataConfig) *UpsertCollectionPolicyRequest {
	s.DataConfig = v
	return s
}

func (s *UpsertCollectionPolicyRequest) SetEnabled(v bool) *UpsertCollectionPolicyRequest {
	s.Enabled = &v
	return s
}

func (s *UpsertCollectionPolicyRequest) SetPolicyConfig(v *UpsertCollectionPolicyRequestPolicyConfig) *UpsertCollectionPolicyRequest {
	s.PolicyConfig = v
	return s
}

func (s *UpsertCollectionPolicyRequest) SetPolicyName(v string) *UpsertCollectionPolicyRequest {
	s.PolicyName = &v
	return s
}

func (s *UpsertCollectionPolicyRequest) SetProductCode(v string) *UpsertCollectionPolicyRequest {
	s.ProductCode = &v
	return s
}

func (s *UpsertCollectionPolicyRequest) SetResourceDirectory(v *UpsertCollectionPolicyRequestResourceDirectory) *UpsertCollectionPolicyRequest {
	s.ResourceDirectory = v
	return s
}

type UpsertCollectionPolicyRequestCentralizeConfig struct {
	// The destination logstore for centralized storage. Make sure that the region of the destination logstore is consistent with the region specified by destRegion and the destination logstore belongs to the destination project specified by destProject.
	//
	// example:
	//
	// your-sls-logstore-in-beijing
	DestLogstore *string `json:"destLogstore,omitempty" xml:"destLogstore,omitempty"`
	// The destination project for centralized storage. Make sure that the region of the destination project is consistent with the region specified by destRegion.
	//
	// example:
	//
	// your-sls-project-in-beijing
	DestProject *string `json:"destProject,omitempty" xml:"destProject,omitempty"`
	// The destination region for centralized storage.
	//
	// example:
	//
	// cn-beijing
	DestRegion *string `json:"destRegion,omitempty" xml:"destRegion,omitempty"`
	// The data retention period for centralized storage. Unit: days. This parameter takes effect only when you use an existing logstore for centralized storage.
	//
	// example:
	//
	// your-sls-logstore-ttl
	DestTTL *int32 `json:"destTTL,omitempty" xml:"destTTL,omitempty"`
}

func (s UpsertCollectionPolicyRequestCentralizeConfig) String() string {
	return tea.Prettify(s)
}

func (s UpsertCollectionPolicyRequestCentralizeConfig) GoString() string {
	return s.String()
}

func (s *UpsertCollectionPolicyRequestCentralizeConfig) SetDestLogstore(v string) *UpsertCollectionPolicyRequestCentralizeConfig {
	s.DestLogstore = &v
	return s
}

func (s *UpsertCollectionPolicyRequestCentralizeConfig) SetDestProject(v string) *UpsertCollectionPolicyRequestCentralizeConfig {
	s.DestProject = &v
	return s
}

func (s *UpsertCollectionPolicyRequestCentralizeConfig) SetDestRegion(v string) *UpsertCollectionPolicyRequestCentralizeConfig {
	s.DestRegion = &v
	return s
}

func (s *UpsertCollectionPolicyRequestCentralizeConfig) SetDestTTL(v int32) *UpsertCollectionPolicyRequestCentralizeConfig {
	s.DestTTL = &v
	return s
}

type UpsertCollectionPolicyRequestDataConfig struct {
	// The region for storing the global logs that are collected for the first time.
	//
	// example:
	//
	// cn-beijing
	DataRegion *string `json:"dataRegion,omitempty" xml:"dataRegion,omitempty"`
}

func (s UpsertCollectionPolicyRequestDataConfig) String() string {
	return tea.Prettify(s)
}

func (s UpsertCollectionPolicyRequestDataConfig) GoString() string {
	return s.String()
}

func (s *UpsertCollectionPolicyRequestDataConfig) SetDataRegion(v string) *UpsertCollectionPolicyRequestDataConfig {
	s.DataRegion = &v
	return s
}

type UpsertCollectionPolicyRequestPolicyConfig struct {
	// The IDs of the instances. This parameter takes effect only when resourceMode is set to instanceMode. Logs are collected only from instances that use the specified IDs.
	InstanceIds []*string `json:"instanceIds,omitempty" xml:"instanceIds,omitempty" type:"Repeated"`
	// The regions of the instances. This parameter takes effect only when resourceMode is set to attributeMode. Wildcard characters are supported. If you leave this parameter empty, region-based filtering is not performed. The system considers that all instances are matched. If you specify a value for this parameter, logs of instances that reside in the specified regions are collected. Logs are collected from an instance only if the resource tags and region of the instance match the specified conditions.
	Regions []*string `json:"regions,omitempty" xml:"regions,omitempty" type:"Repeated"`
	// The resource collection mode. Valid values: all, attributeMode, and instanceMode. The value all specifies that logs of all instances within your account are collected to the default logstore. The value attributeMode specifies that logs are collected based on the regions of instances and resource tags. The value instanceMode specifies that logs are collected based on instance IDs.
	//
	// This parameter is required.
	//
	// example:
	//
	// all
	ResourceMode *string `json:"resourceMode,omitempty" xml:"resourceMode,omitempty"`
	// The resource tags. This parameter takes effect only when resourceMode is set to attributeMode. If you leave this parameter empty, resource tag-based filtering is not performed. The system considers that all instances are matched. If you specify a value for this parameter, logs of instances that use the specified resource tags are collected. Logs are collected from an instance only if the resource tags and region of the instance match the specified conditions.
	//
	// example:
	//
	// {"tag1":"value1",“tag2":"value2"}
	ResourceTags map[string]interface{} `json:"resourceTags,omitempty" xml:"resourceTags,omitempty"`
}

func (s UpsertCollectionPolicyRequestPolicyConfig) String() string {
	return tea.Prettify(s)
}

func (s UpsertCollectionPolicyRequestPolicyConfig) GoString() string {
	return s.String()
}

func (s *UpsertCollectionPolicyRequestPolicyConfig) SetInstanceIds(v []*string) *UpsertCollectionPolicyRequestPolicyConfig {
	s.InstanceIds = v
	return s
}

func (s *UpsertCollectionPolicyRequestPolicyConfig) SetRegions(v []*string) *UpsertCollectionPolicyRequestPolicyConfig {
	s.Regions = v
	return s
}

func (s *UpsertCollectionPolicyRequestPolicyConfig) SetResourceMode(v string) *UpsertCollectionPolicyRequestPolicyConfig {
	s.ResourceMode = &v
	return s
}

func (s *UpsertCollectionPolicyRequestPolicyConfig) SetResourceTags(v map[string]interface{}) *UpsertCollectionPolicyRequestPolicyConfig {
	s.ResourceTags = v
	return s
}

type UpsertCollectionPolicyRequestResourceDirectory struct {
	// The mode of the resource directory. Valid values: all and custom.
	//
	// example:
	//
	// all,custom
	AccountGroupType *string `json:"accountGroupType,omitempty" xml:"accountGroupType,omitempty"`
	// The members. If accountGroupType is set to custom, the members are returned.
	Members []*string `json:"members,omitempty" xml:"members,omitempty" type:"Repeated"`
}

func (s UpsertCollectionPolicyRequestResourceDirectory) String() string {
	return tea.Prettify(s)
}

func (s UpsertCollectionPolicyRequestResourceDirectory) GoString() string {
	return s.String()
}

func (s *UpsertCollectionPolicyRequestResourceDirectory) SetAccountGroupType(v string) *UpsertCollectionPolicyRequestResourceDirectory {
	s.AccountGroupType = &v
	return s
}

func (s *UpsertCollectionPolicyRequestResourceDirectory) SetMembers(v []*string) *UpsertCollectionPolicyRequestResourceDirectory {
	s.Members = v
	return s
}

type UpsertCollectionPolicyResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
}

func (s UpsertCollectionPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s UpsertCollectionPolicyResponse) GoString() string {
	return s.String()
}

func (s *UpsertCollectionPolicyResponse) SetHeaders(v map[string]*string) *UpsertCollectionPolicyResponse {
	s.Headers = v
	return s
}

func (s *UpsertCollectionPolicyResponse) SetStatusCode(v int32) *UpsertCollectionPolicyResponse {
	s.StatusCode = &v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.ProductId = tea.String("Sls")
	gatewayClient, _err := gatewayclient.NewClient()
	if _err != nil {
		return _err
	}

	client.Spi = gatewayClient
	if tea.BoolValue(util.IsUnset(config.HttpClient)) {
		defaultHttpClient, _err := httpclient.NewHttpClient()
		if _err != nil {
			return _err
		}

		client.HttpClient = defaultHttpClient
	}

	client.EndpointRule = tea.String("central")
	return nil
}

// Summary:
//
// Applies a Logtail configuration to a machine group.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ApplyConfigToMachineGroupResponse
func (client *Client) ApplyConfigToMachineGroupWithOptions(project *string, machineGroup *string, configName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ApplyConfigToMachineGroupResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("ApplyConfigToMachineGroup"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/machinegroups/" + tea.StringValue(machineGroup) + "/configs/" + tea.StringValue(configName)),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &ApplyConfigToMachineGroupResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Applies a Logtail configuration to a machine group.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @return ApplyConfigToMachineGroupResponse
func (client *Client) ApplyConfigToMachineGroup(project *string, machineGroup *string, configName *string) (_result *ApplyConfigToMachineGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ApplyConfigToMachineGroupResponse{}
	_body, _err := client.ApplyConfigToMachineGroupWithOptions(project, machineGroup, configName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Changes the resource group to which a resource belongs.
//
// @param request - ChangeResourceGroupRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ChangeResourceGroupResponse
func (client *Client) ChangeResourceGroupWithOptions(project *string, request *ChangeResourceGroupRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ChangeResourceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		body["resourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		body["resourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		body["resourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ChangeResourceGroup"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/resourcegroup"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &ChangeResourceGroupResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Changes the resource group to which a resource belongs.
//
// @param request - ChangeResourceGroupRequest
//
// @return ChangeResourceGroupResponse
func (client *Client) ChangeResourceGroup(project *string, request *ChangeResourceGroupRequest) (_result *ChangeResourceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ChangeResourceGroupResponse{}
	_body, _err := client.ChangeResourceGroupWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Sends heartbeats to a server from a consumer.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - Connections between consumers and Simple Log Service are established by sending heartbeat messages at regular intervals. If Simple Log Service does not receive heartbeat messages from a consumer on schedule, Simple Log Service deletes the consumer.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
//   - The name of the consumer group is obtained. For more information, see [ListConsumerGroup](https://help.aliyun.com/document_detail/74964.html).
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:ConsumerGroupHeartBeat`|`acs:log:${regionId}:${accountId}:project/{#ProjectName}/logstore/{#LogstoreName}/consumergroup/{#ConsumerGroupName}`|
//
// @param request - ConsumerGroupHeartBeatRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ConsumerGroupHeartBeatResponse
func (client *Client) ConsumerGroupHeartBeatWithOptions(project *string, logstore *string, consumerGroup *string, request *ConsumerGroupHeartBeatRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ConsumerGroupHeartBeatResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Consumer)) {
		query["consumer"] = request.Consumer
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("ConsumerGroupHeartBeat"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "/consumergroups/" + tea.StringValue(consumerGroup) + "?type=heartbeat"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("array"),
	}
	_result = &ConsumerGroupHeartBeatResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Sends heartbeats to a server from a consumer.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - Connections between consumers and Simple Log Service are established by sending heartbeat messages at regular intervals. If Simple Log Service does not receive heartbeat messages from a consumer on schedule, Simple Log Service deletes the consumer.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
//   - The name of the consumer group is obtained. For more information, see [ListConsumerGroup](https://help.aliyun.com/document_detail/74964.html).
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:ConsumerGroupHeartBeat`|`acs:log:${regionId}:${accountId}:project/{#ProjectName}/logstore/{#LogstoreName}/consumergroup/{#ConsumerGroupName}`|
//
// @param request - ConsumerGroupHeartBeatRequest
//
// @return ConsumerGroupHeartBeatResponse
func (client *Client) ConsumerGroupHeartBeat(project *string, logstore *string, consumerGroup *string, request *ConsumerGroupHeartBeatRequest) (_result *ConsumerGroupHeartBeatResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ConsumerGroupHeartBeatResponse{}
	_body, _err := client.ConsumerGroupHeartBeatWithOptions(project, logstore, consumerGroup, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates the checkpoint of a shard for a consumer group.
//
// Description:
//
//	  If you do not specify a consumer, you must set **forceSuccess*	- to **true**. Otherwise, the checkpoint cannot be updated.
//
//		- Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//		- An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
// @param request - ConsumerGroupUpdateCheckPointRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ConsumerGroupUpdateCheckPointResponse
func (client *Client) ConsumerGroupUpdateCheckPointWithOptions(project *string, logstore *string, consumerGroup *string, request *ConsumerGroupUpdateCheckPointRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ConsumerGroupUpdateCheckPointResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Consumer)) {
		query["consumer"] = request.Consumer
	}

	if !tea.BoolValue(util.IsUnset(request.ForceSuccess)) {
		query["forceSuccess"] = request.ForceSuccess
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Checkpoint)) {
		body["checkpoint"] = request.Checkpoint
	}

	if !tea.BoolValue(util.IsUnset(request.Shard)) {
		body["shard"] = request.Shard
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ConsumerGroupUpdateCheckPoint"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "/consumergroups/" + tea.StringValue(consumerGroup) + "?type=checkpoint"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &ConsumerGroupUpdateCheckPointResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates the checkpoint of a shard for a consumer group.
//
// Description:
//
//	  If you do not specify a consumer, you must set **forceSuccess*	- to **true**. Otherwise, the checkpoint cannot be updated.
//
//		- Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//		- An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
// @param request - ConsumerGroupUpdateCheckPointRequest
//
// @return ConsumerGroupUpdateCheckPointResponse
func (client *Client) ConsumerGroupUpdateCheckPoint(project *string, logstore *string, consumerGroup *string, request *ConsumerGroupUpdateCheckPointRequest) (_result *ConsumerGroupUpdateCheckPointResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ConsumerGroupUpdateCheckPointResponse{}
	_body, _err := client.ConsumerGroupUpdateCheckPointWithOptions(project, logstore, consumerGroup, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// # CreateAgentInstanceConfig
//
// @param request - CreateAgentInstanceConfigRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateAgentInstanceConfigResponse
func (client *Client) CreateAgentInstanceConfigWithOptions(request *CreateAgentInstanceConfigRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateAgentInstanceConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Config)) {
		body["config"] = request.Config
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigMatcher)) {
		body["configMatcher"] = request.ConfigMatcher
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigName)) {
		body["configName"] = request.ConfigName
	}

	if !tea.BoolValue(util.IsUnset(request.IsGray)) {
		body["isGray"] = request.IsGray
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAgentInstanceConfig"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/agentinstanceconfigs"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateAgentInstanceConfigResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// # CreateAgentInstanceConfig
//
// @param request - CreateAgentInstanceConfigRequest
//
// @return CreateAgentInstanceConfigResponse
func (client *Client) CreateAgentInstanceConfig(request *CreateAgentInstanceConfigRequest) (_result *CreateAgentInstanceConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateAgentInstanceConfigResponse{}
	_body, _err := client.CreateAgentInstanceConfigWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// # CreateAlert
//
// @param request - CreateAlertRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateAlertResponse
func (client *Client) CreateAlertWithOptions(project *string, request *CreateAlertRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateAlertResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Configuration)) {
		body["configuration"] = request.Configuration
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DisplayName)) {
		body["displayName"] = request.DisplayName
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Schedule)) {
		body["schedule"] = request.Schedule
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAlert"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/alerts"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateAlertResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// # CreateAlert
//
// @param request - CreateAlertRequest
//
// @return CreateAlertResponse
func (client *Client) CreateAlert(project *string, request *CreateAlertRequest) (_result *CreateAlertResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateAlertResponse{}
	_body, _err := client.CreateAlertWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a dataset.
//
// @param request - CreateAnnotationDataSetRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateAnnotationDataSetResponse
func (client *Client) CreateAnnotationDataSetWithOptions(request *CreateAnnotationDataSetRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateAnnotationDataSetResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DatasetId)) {
		query["datasetId"] = request.DatasetId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(request.Body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAnnotationDataSet"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ml/annotationdataset"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateAnnotationDataSetResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a dataset.
//
// @param request - CreateAnnotationDataSetRequest
//
// @return CreateAnnotationDataSetResponse
func (client *Client) CreateAnnotationDataSet(request *CreateAnnotationDataSetRequest) (_result *CreateAnnotationDataSetResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateAnnotationDataSetResponse{}
	_body, _err := client.CreateAnnotationDataSetWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a tag table.
//
// @param request - CreateAnnotationLabelRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateAnnotationLabelResponse
func (client *Client) CreateAnnotationLabelWithOptions(request *CreateAnnotationLabelRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateAnnotationLabelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(request.Body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAnnotationLabel"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ml/annotationlabel"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateAnnotationLabelResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a tag table.
//
// @param request - CreateAnnotationLabelRequest
//
// @return CreateAnnotationLabelResponse
func (client *Client) CreateAnnotationLabel(request *CreateAnnotationLabelRequest) (_result *CreateAnnotationLabelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateAnnotationLabelResponse{}
	_body, _err := client.CreateAnnotationLabelWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a Logtail configuration.
//
// Description:
//
// ### [](#)Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
//   - You can create up to 100 Logtail configurations in a project.
//
//   - The Logtail configuration is planned out. For more information, see [Logtail configurations](https://help.aliyun.com/document_detail/29058.html).
//
// @param request - CreateConfigRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateConfigResponse
func (client *Client) CreateConfigWithOptions(project *string, request *CreateConfigRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(request.Body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateConfig"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/configs"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateConfigResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a Logtail configuration.
//
// Description:
//
// ### [](#)Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
//   - You can create up to 100 Logtail configurations in a project.
//
//   - The Logtail configuration is planned out. For more information, see [Logtail configurations](https://help.aliyun.com/document_detail/29058.html).
//
// @param request - CreateConfigRequest
//
// @return CreateConfigResponse
func (client *Client) CreateConfig(project *string, request *CreateConfigRequest) (_result *CreateConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateConfigResponse{}
	_body, _err := client.CreateConfigWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a consumer group for a Logstore.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - You can create up to 30 consumer groups for a Logstore. The name of a consumer group must be unique in a project.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
//   - Simple Log Service provides examples of both regular log consumption and consumer group-based log consumption by using Simple Log Service SDK for Java. For more information, see [Consume log data](https://help.aliyun.com/document_detail/120035.html) and [Use consumer groups to consume data](https://help.aliyun.com/document_detail/28998.html).
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:CreateConsumerGroup`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#logstoreName}/consumergroup/{#ConsumerGroup}`|
//
// @param request - CreateConsumerGroupRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateConsumerGroupResponse
func (client *Client) CreateConsumerGroupWithOptions(project *string, logstore *string, request *CreateConsumerGroupRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateConsumerGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConsumerGroup)) {
		body["consumerGroup"] = request.ConsumerGroup
	}

	if !tea.BoolValue(util.IsUnset(request.Order)) {
		body["order"] = request.Order
	}

	if !tea.BoolValue(util.IsUnset(request.Timeout)) {
		body["timeout"] = request.Timeout
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateConsumerGroup"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "/consumergroups"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateConsumerGroupResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a consumer group for a Logstore.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - You can create up to 30 consumer groups for a Logstore. The name of a consumer group must be unique in a project.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
//   - Simple Log Service provides examples of both regular log consumption and consumer group-based log consumption by using Simple Log Service SDK for Java. For more information, see [Consume log data](https://help.aliyun.com/document_detail/120035.html) and [Use consumer groups to consume data](https://help.aliyun.com/document_detail/28998.html).
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:CreateConsumerGroup`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#logstoreName}/consumergroup/{#ConsumerGroup}`|
//
// @param request - CreateConsumerGroupRequest
//
// @return CreateConsumerGroupResponse
func (client *Client) CreateConsumerGroup(project *string, logstore *string, request *CreateConsumerGroupRequest) (_result *CreateConsumerGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateConsumerGroupResponse{}
	_body, _err := client.CreateConsumerGroupWithOptions(project, logstore, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a dashboard.
//
// Description:
//
// ### [](#)Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
// @param request - CreateDashboardRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateDashboardResponse
func (client *Client) CreateDashboardWithOptions(project *string, request *CreateDashboardRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateDashboardResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(request.Body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDashboard"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/dashboards"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateDashboardResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a dashboard.
//
// Description:
//
// ### [](#)Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
// @param request - CreateDashboardRequest
//
// @return CreateDashboardResponse
func (client *Client) CreateDashboard(project *string, request *CreateDashboardRequest) (_result *CreateDashboardResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateDashboardResponse{}
	_body, _err := client.CreateDashboardWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Binds a new custom domain name to a project.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - CreateDomainRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateDomainResponse
func (client *Client) CreateDomainWithOptions(project *string, request *CreateDomainRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		body["domainName"] = request.DomainName
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDomain"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/domains"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateDomainResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Binds a new custom domain name to a project.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - CreateDomainRequest
//
// @return CreateDomainResponse
func (client *Client) CreateDomain(project *string, request *CreateDomainRequest) (_result *CreateDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateDomainResponse{}
	_body, _err := client.CreateDomainWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 创建下载任务
//
// @param request - CreateDownloadJobRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateDownloadJobResponse
func (client *Client) CreateDownloadJobWithOptions(project *string, request *CreateDownloadJobRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateDownloadJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Configuration)) {
		body["configuration"] = request.Configuration
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DisplayName)) {
		body["displayName"] = request.DisplayName
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDownloadJob"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/downloadjobs"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateDownloadJobResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 创建下载任务
//
// @param request - CreateDownloadJobRequest
//
// @return CreateDownloadJobResponse
func (client *Client) CreateDownloadJob(project *string, request *CreateDownloadJobRequest) (_result *CreateDownloadJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateDownloadJobResponse{}
	_body, _err := client.CreateDownloadJobWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 创建数据加工任务
//
// @param request - CreateETLRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateETLResponse
func (client *Client) CreateETLWithOptions(project *string, request *CreateETLRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateETLResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Configuration)) {
		body["configuration"] = request.Configuration
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DisplayName)) {
		body["displayName"] = request.DisplayName
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateETL"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/etls"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateETLResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 创建数据加工任务
//
// @param request - CreateETLRequest
//
// @return CreateETLResponse
func (client *Client) CreateETL(project *string, request *CreateETLRequest) (_result *CreateETLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateETLResponse{}
	_body, _err := client.CreateETLWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates indexes for a Logstore.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - CreateIndexRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateIndexResponse
func (client *Client) CreateIndexWithOptions(project *string, logstore *string, request *CreateIndexRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateIndexResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(request.Body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateIndex"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "/index"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateIndexResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates indexes for a Logstore.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - CreateIndexRequest
//
// @return CreateIndexResponse
func (client *Client) CreateIndex(project *string, logstore *string, request *CreateIndexRequest) (_result *CreateIndexResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateIndexResponse{}
	_body, _err := client.CreateIndexWithOptions(project, logstore, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a Logstore.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
//   - You can create up to 200 Logstores in each project.
//
//   - If the retention period of a log reaches the data retention period that you specified for the Logstore, the log is deleted.
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:CreateLogStore`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#LogstoreName}`|
//
// @param request - CreateLogStoreRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateLogStoreResponse
func (client *Client) CreateLogStoreWithOptions(project *string, request *CreateLogStoreRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateLogStoreResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppendMeta)) {
		body["appendMeta"] = request.AppendMeta
	}

	if !tea.BoolValue(util.IsUnset(request.AutoSplit)) {
		body["autoSplit"] = request.AutoSplit
	}

	if !tea.BoolValue(util.IsUnset(request.EnableTracking)) {
		body["enable_tracking"] = request.EnableTracking
	}

	if !tea.BoolValue(util.IsUnset(request.EncryptConf)) {
		body["encrypt_conf"] = request.EncryptConf
	}

	if !tea.BoolValue(util.IsUnset(request.HotTtl)) {
		body["hot_ttl"] = request.HotTtl
	}

	if !tea.BoolValue(util.IsUnset(request.InfrequentAccessTTL)) {
		body["infrequentAccessTTL"] = request.InfrequentAccessTTL
	}

	if !tea.BoolValue(util.IsUnset(request.LogstoreName)) {
		body["logstoreName"] = request.LogstoreName
	}

	if !tea.BoolValue(util.IsUnset(request.MaxSplitShard)) {
		body["maxSplitShard"] = request.MaxSplitShard
	}

	if !tea.BoolValue(util.IsUnset(request.Mode)) {
		body["mode"] = request.Mode
	}

	if !tea.BoolValue(util.IsUnset(request.ProcessorId)) {
		body["processorId"] = request.ProcessorId
	}

	if !tea.BoolValue(util.IsUnset(request.ShardCount)) {
		body["shardCount"] = request.ShardCount
	}

	if !tea.BoolValue(util.IsUnset(request.TelemetryType)) {
		body["telemetryType"] = request.TelemetryType
	}

	if !tea.BoolValue(util.IsUnset(request.Ttl)) {
		body["ttl"] = request.Ttl
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateLogStore"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateLogStoreResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a Logstore.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
//   - You can create up to 200 Logstores in each project.
//
//   - If the retention period of a log reaches the data retention period that you specified for the Logstore, the log is deleted.
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:CreateLogStore`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#LogstoreName}`|
//
// @param request - CreateLogStoreRequest
//
// @return CreateLogStoreResponse
func (client *Client) CreateLogStore(project *string, request *CreateLogStoreRequest) (_result *CreateLogStoreResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateLogStoreResponse{}
	_body, _err := client.CreateLogStoreWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Enables the service log feature for a project.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - CreateLoggingRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateLoggingResponse
func (client *Client) CreateLoggingWithOptions(project *string, request *CreateLoggingRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateLoggingResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LoggingDetails)) {
		body["loggingDetails"] = request.LoggingDetails
	}

	if !tea.BoolValue(util.IsUnset(request.LoggingProject)) {
		body["loggingProject"] = request.LoggingProject
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateLogging"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logging"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateLoggingResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Enables the service log feature for a project.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - CreateLoggingRequest
//
// @return CreateLoggingResponse
func (client *Client) CreateLogging(project *string, request *CreateLoggingRequest) (_result *CreateLoggingResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateLoggingResponse{}
	_body, _err := client.CreateLoggingWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a Logtail pipeline configuration.
//
// Description:
//
// The UK (London) region is supported. Supported regions are constantly updated.
//
// @param request - CreateLogtailPipelineConfigRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateLogtailPipelineConfigResponse
func (client *Client) CreateLogtailPipelineConfigWithOptions(project *string, request *CreateLogtailPipelineConfigRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateLogtailPipelineConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Aggregators)) {
		body["aggregators"] = request.Aggregators
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigName)) {
		body["configName"] = request.ConfigName
	}

	if !tea.BoolValue(util.IsUnset(request.Flushers)) {
		body["flushers"] = request.Flushers
	}

	if !tea.BoolValue(util.IsUnset(request.Global)) {
		body["global"] = request.Global
	}

	if !tea.BoolValue(util.IsUnset(request.Inputs)) {
		body["inputs"] = request.Inputs
	}

	if !tea.BoolValue(util.IsUnset(request.LogSample)) {
		body["logSample"] = request.LogSample
	}

	if !tea.BoolValue(util.IsUnset(request.Processors)) {
		body["processors"] = request.Processors
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateLogtailPipelineConfig"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pipelineconfigs"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateLogtailPipelineConfigResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a Logtail pipeline configuration.
//
// Description:
//
// The UK (London) region is supported. Supported regions are constantly updated.
//
// @param request - CreateLogtailPipelineConfigRequest
//
// @return CreateLogtailPipelineConfigResponse
func (client *Client) CreateLogtailPipelineConfig(project *string, request *CreateLogtailPipelineConfigRequest) (_result *CreateLogtailPipelineConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateLogtailPipelineConfigResponse{}
	_body, _err := client.CreateLogtailPipelineConfigWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a machine group.
//
// Description:
//
// ### Usage notes
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - CreateMachineGroupRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateMachineGroupResponse
func (client *Client) CreateMachineGroupWithOptions(project *string, request *CreateMachineGroupRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateMachineGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupAttribute)) {
		body["groupAttribute"] = request.GroupAttribute
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		body["groupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.GroupType)) {
		body["groupType"] = request.GroupType
	}

	if !tea.BoolValue(util.IsUnset(request.MachineIdentifyType)) {
		body["machineIdentifyType"] = request.MachineIdentifyType
	}

	if !tea.BoolValue(util.IsUnset(request.MachineList)) {
		body["machineList"] = request.MachineList
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateMachineGroup"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/machinegroups"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateMachineGroupResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a machine group.
//
// Description:
//
// ### Usage notes
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - CreateMachineGroupRequest
//
// @return CreateMachineGroupResponse
func (client *Client) CreateMachineGroup(project *string, request *CreateMachineGroupRequest) (_result *CreateMachineGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateMachineGroupResponse{}
	_body, _err := client.CreateMachineGroupWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a Metricstore to store metric data.
//
// Description:
//
// Metricstores are used to store metric data. For more information, see [Metric data](https://help.aliyun.com/document_detail/174965.html).
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query metric data is obtained. The information includes the name of the project to which the metric data belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
//   - You can create up to 200 Logstores or Metricstores in a project.
//
//   - Metric data is automatically deleted when the retention period of the metric data ends.
//
// @param request - CreateMetricStoreRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateMetricStoreResponse
func (client *Client) CreateMetricStoreWithOptions(project *string, request *CreateMetricStoreRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateMetricStoreResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoSplit)) {
		body["autoSplit"] = request.AutoSplit
	}

	if !tea.BoolValue(util.IsUnset(request.HotTtl)) {
		body["hot_ttl"] = request.HotTtl
	}

	if !tea.BoolValue(util.IsUnset(request.InfrequentAccessTTL)) {
		body["infrequentAccessTTL"] = request.InfrequentAccessTTL
	}

	if !tea.BoolValue(util.IsUnset(request.MaxSplitShard)) {
		body["maxSplitShard"] = request.MaxSplitShard
	}

	if !tea.BoolValue(util.IsUnset(request.MetricType)) {
		body["metricType"] = request.MetricType
	}

	if !tea.BoolValue(util.IsUnset(request.Mode)) {
		body["mode"] = request.Mode
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ShardCount)) {
		body["shardCount"] = request.ShardCount
	}

	if !tea.BoolValue(util.IsUnset(request.Ttl)) {
		body["ttl"] = request.Ttl
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateMetricStore"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/metricstores"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateMetricStoreResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a Metricstore to store metric data.
//
// Description:
//
// Metricstores are used to store metric data. For more information, see [Metric data](https://help.aliyun.com/document_detail/174965.html).
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query metric data is obtained. The information includes the name of the project to which the metric data belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
//   - You can create up to 200 Logstores or Metricstores in a project.
//
//   - Metric data is automatically deleted when the retention period of the metric data ends.
//
// @param request - CreateMetricStoreRequest
//
// @return CreateMetricStoreResponse
func (client *Client) CreateMetricStore(project *string, request *CreateMetricStoreRequest) (_result *CreateMetricStoreResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateMetricStoreResponse{}
	_body, _err := client.CreateMetricStoreWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Ships logs from a Simple Log Service Logstore to an Object Storage Service (OSS) bucket.
//
// @param request - CreateOSSExportRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateOSSExportResponse
func (client *Client) CreateOSSExportWithOptions(project *string, request *CreateOSSExportRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateOSSExportResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Configuration)) {
		body["configuration"] = request.Configuration
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DisplayName)) {
		body["displayName"] = request.DisplayName
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOSSExport"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ossexports"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateOSSExportResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Ships logs from a Simple Log Service Logstore to an Object Storage Service (OSS) bucket.
//
// @param request - CreateOSSExportRequest
//
// @return CreateOSSExportResponse
func (client *Client) CreateOSSExport(project *string, request *CreateOSSExportRequest) (_result *CreateOSSExportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateOSSExportResponse{}
	_body, _err := client.CreateOSSExportWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates an OSS-HDFS data shipping job in a project.
//
// @param request - CreateOSSHDFSExportRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateOSSHDFSExportResponse
func (client *Client) CreateOSSHDFSExportWithOptions(project *string, request *CreateOSSHDFSExportRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateOSSHDFSExportResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Configuration)) {
		body["configuration"] = request.Configuration
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DisplayName)) {
		body["displayName"] = request.DisplayName
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOSSHDFSExport"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/osshdfsexports"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateOSSHDFSExportResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates an OSS-HDFS data shipping job in a project.
//
// @param request - CreateOSSHDFSExportRequest
//
// @return CreateOSSHDFSExportResponse
func (client *Client) CreateOSSHDFSExport(project *string, request *CreateOSSHDFSExportRequest) (_result *CreateOSSHDFSExportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateOSSHDFSExportResponse{}
	_body, _err := client.CreateOSSHDFSExportWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates an Object Storage Service (OSS) data import job in a project.
//
// @param request - CreateOSSIngestionRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateOSSIngestionResponse
func (client *Client) CreateOSSIngestionWithOptions(project *string, request *CreateOSSIngestionRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateOSSIngestionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Configuration)) {
		body["configuration"] = request.Configuration
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DisplayName)) {
		body["displayName"] = request.DisplayName
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Schedule)) {
		body["schedule"] = request.Schedule
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOSSIngestion"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ossingestions"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateOSSIngestionResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates an Object Storage Service (OSS) data import job in a project.
//
// @param request - CreateOSSIngestionRequest
//
// @return CreateOSSIngestionResponse
func (client *Client) CreateOSSIngestion(project *string, request *CreateOSSIngestionRequest) (_result *CreateOSSIngestionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateOSSIngestionResponse{}
	_body, _err := client.CreateOSSIngestionWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates an Object Storage Service (OSS) external store.
//
// Description:
//
// ### [](#)Usage notes
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - CreateOssExternalStoreRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateOssExternalStoreResponse
func (client *Client) CreateOssExternalStoreWithOptions(project *string, request *CreateOssExternalStoreRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateOssExternalStoreResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ExternalStoreName)) {
		body["externalStoreName"] = request.ExternalStoreName
	}

	if !tea.BoolValue(util.IsUnset(request.Parameter)) {
		body["parameter"] = request.Parameter
	}

	if !tea.BoolValue(util.IsUnset(request.StoreType)) {
		body["storeType"] = request.StoreType
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOssExternalStore"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/externalstores"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateOssExternalStoreResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates an Object Storage Service (OSS) external store.
//
// Description:
//
// ### [](#)Usage notes
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - CreateOssExternalStoreRequest
//
// @return CreateOssExternalStoreResponse
func (client *Client) CreateOssExternalStore(project *string, request *CreateOssExternalStoreRequest) (_result *CreateOssExternalStoreResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateOssExternalStoreResponse{}
	_body, _err := client.CreateOssExternalStoreWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a project.
//
// @param request - CreateProjectRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateProjectResponse
func (client *Client) CreateProjectWithOptions(request *CreateProjectRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateProjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DataRedundancyType)) {
		body["dataRedundancyType"] = request.DataRedundancyType
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["projectName"] = request.ProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.RecycleBinEnabled)) {
		body["recycleBinEnabled"] = request.RecycleBinEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		body["resourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateProject"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateProjectResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a project.
//
// @param request - CreateProjectRequest
//
// @return CreateProjectResponse
func (client *Client) CreateProject(request *CreateProjectRequest) (_result *CreateProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateProjectResponse{}
	_body, _err := client.CreateProjectWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates an ApsaraDB RDS external store.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - CreateRdsExternalStoreRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateRdsExternalStoreResponse
func (client *Client) CreateRdsExternalStoreWithOptions(project *string, request *CreateRdsExternalStoreRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateRdsExternalStoreResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ExternalStoreName)) {
		body["externalStoreName"] = request.ExternalStoreName
	}

	if !tea.BoolValue(util.IsUnset(request.Parameter)) {
		body["parameter"] = request.Parameter
	}

	if !tea.BoolValue(util.IsUnset(request.StoreType)) {
		body["storeType"] = request.StoreType
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateRdsExternalStore"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/externalstores"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateRdsExternalStoreResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates an ApsaraDB RDS external store.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - CreateRdsExternalStoreRequest
//
// @return CreateRdsExternalStoreResponse
func (client *Client) CreateRdsExternalStore(project *string, request *CreateRdsExternalStoreRequest) (_result *CreateRdsExternalStoreResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateRdsExternalStoreResponse{}
	_body, _err := client.CreateRdsExternalStoreWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a saved search.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
//   - Limits are imposed when you use Simple Log Service to query logs. We recommend that you specify query statements and query time ranges based on the limits. For more information, see [Log search overview](https://help.aliyun.com/document_detail/43772.html) and [Log analysis overview](https://help.aliyun.com/document_detail/53608.html).
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:CreateSavedSearch`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/savedsearch/{#SavedSearchName}`|
//
// @param request - CreateSavedSearchRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateSavedSearchResponse
func (client *Client) CreateSavedSearchWithOptions(project *string, request *CreateSavedSearchRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateSavedSearchResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DisplayName)) {
		body["displayName"] = request.DisplayName
	}

	if !tea.BoolValue(util.IsUnset(request.Logstore)) {
		body["logstore"] = request.Logstore
	}

	if !tea.BoolValue(util.IsUnset(request.SavedsearchName)) {
		body["savedsearchName"] = request.SavedsearchName
	}

	if !tea.BoolValue(util.IsUnset(request.SearchQuery)) {
		body["searchQuery"] = request.SearchQuery
	}

	if !tea.BoolValue(util.IsUnset(request.Topic)) {
		body["topic"] = request.Topic
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSavedSearch"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/savedsearches"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateSavedSearchResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a saved search.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
//   - Limits are imposed when you use Simple Log Service to query logs. We recommend that you specify query statements and query time ranges based on the limits. For more information, see [Log search overview](https://help.aliyun.com/document_detail/43772.html) and [Log analysis overview](https://help.aliyun.com/document_detail/53608.html).
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:CreateSavedSearch`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/savedsearch/{#SavedSearchName}`|
//
// @param request - CreateSavedSearchRequest
//
// @return CreateSavedSearchResponse
func (client *Client) CreateSavedSearch(project *string, request *CreateSavedSearchRequest) (_result *CreateSavedSearchResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateSavedSearchResponse{}
	_body, _err := client.CreateSavedSearchWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a Scheduled SQL job in a project.
//
// @param request - CreateScheduledSQLRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateScheduledSQLResponse
func (client *Client) CreateScheduledSQLWithOptions(project *string, request *CreateScheduledSQLRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateScheduledSQLResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Configuration)) {
		body["configuration"] = request.Configuration
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DisplayName)) {
		body["displayName"] = request.DisplayName
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Schedule)) {
		body["schedule"] = request.Schedule
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateScheduledSQL"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/scheduledsqls"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateScheduledSQLResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a Scheduled SQL job in a project.
//
// @param request - CreateScheduledSQLRequest
//
// @return CreateScheduledSQLResponse
func (client *Client) CreateScheduledSQL(project *string, request *CreateScheduledSQLRequest) (_result *CreateScheduledSQLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateScheduledSQLResponse{}
	_body, _err := client.CreateScheduledSQLWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// If you use the Standard SQL feature to analyze a large amount of data, the logs within the specified time range cannot be fully scanned in a single query request. In this case, the returned results may not contain all matched data. You can increase the number of shards to improve data read and write capabilities. However, this method takes effect only for incremental data. You can enable the Dedicated SQL feature to increase computing resources and the amount of data that can be analyzed in a single query request.
//
// Description:
//
// *Before you call this operation, make sure that you fully understand the [billing](https://help.aliyun.com/document_detail/223777.html) of Dedicated SQL.
//
// @param request - CreateSqlInstanceRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateSqlInstanceResponse
func (client *Client) CreateSqlInstanceWithOptions(project *string, request *CreateSqlInstanceRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateSqlInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Cu)) {
		body["cu"] = request.Cu
	}

	if !tea.BoolValue(util.IsUnset(request.UseAsDefault)) {
		body["useAsDefault"] = request.UseAsDefault
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSqlInstance"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/sqlinstance"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateSqlInstanceResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// If you use the Standard SQL feature to analyze a large amount of data, the logs within the specified time range cannot be fully scanned in a single query request. In this case, the returned results may not contain all matched data. You can increase the number of shards to improve data read and write capabilities. However, this method takes effect only for incremental data. You can enable the Dedicated SQL feature to increase computing resources and the amount of data that can be analyzed in a single query request.
//
// Description:
//
// *Before you call this operation, make sure that you fully understand the [billing](https://help.aliyun.com/document_detail/223777.html) of Dedicated SQL.
//
// @param request - CreateSqlInstanceRequest
//
// @return CreateSqlInstanceResponse
func (client *Client) CreateSqlInstance(project *string, request *CreateSqlInstanceRequest) (_result *CreateSqlInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateSqlInstanceResponse{}
	_body, _err := client.CreateSqlInstanceWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 创建StoreView
//
// @param request - CreateStoreViewRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateStoreViewResponse
func (client *Client) CreateStoreViewWithOptions(project *string, request *CreateStoreViewRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateStoreViewResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.StoreType)) {
		body["storeType"] = request.StoreType
	}

	if !tea.BoolValue(util.IsUnset(request.Stores)) {
		body["stores"] = request.Stores
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateStoreView"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/storeviews"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &CreateStoreViewResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 创建StoreView
//
// @param request - CreateStoreViewRequest
//
// @return CreateStoreViewResponse
func (client *Client) CreateStoreView(project *string, request *CreateStoreViewRequest) (_result *CreateStoreViewResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateStoreViewResponse{}
	_body, _err := client.CreateStoreViewWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Obtains a ticket. Simple Log Service allows you to share the query and analysis pages and dashboard pages with other users and embed the console pages into third-party systems. This way, other users can view your logs in password-free mode. The URLs of the shared pages are referred to as password-free URLs. You can call the CreateTicket operation to obtain a ticket and generate a password-free URL based on the ticket and the URL of the console page that you want to share.
//
// @param request - CreateTicketRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateTicketResponse
func (client *Client) CreateTicketWithOptions(request *CreateTicketRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateTicketResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccessTokenExpirationTime)) {
		query["accessTokenExpirationTime"] = request.AccessTokenExpirationTime
	}

	if !tea.BoolValue(util.IsUnset(request.ExpirationTime)) {
		query["expirationTime"] = request.ExpirationTime
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTicket"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/tickets"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTicketResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Obtains a ticket. Simple Log Service allows you to share the query and analysis pages and dashboard pages with other users and embed the console pages into third-party systems. This way, other users can view your logs in password-free mode. The URLs of the shared pages are referred to as password-free URLs. You can call the CreateTicket operation to obtain a ticket and generate a password-free URL based on the ticket and the URL of the console page that you want to share.
//
// @param request - CreateTicketRequest
//
// @return CreateTicketResponse
func (client *Client) CreateTicket(request *CreateTicketRequest) (_result *CreateTicketResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateTicketResponse{}
	_body, _err := client.CreateTicketWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// # DeleteAgentInstanceConfig
//
// @param request - DeleteAgentInstanceConfigRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteAgentInstanceConfigResponse
func (client *Client) DeleteAgentInstanceConfigWithOptions(configName *string, request *DeleteAgentInstanceConfigRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteAgentInstanceConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IsGray)) {
		query["isGray"] = request.IsGray
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAgentInstanceConfig"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/agentinstanceconfigs/" + tea.StringValue(configName)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteAgentInstanceConfigResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// # DeleteAgentInstanceConfig
//
// @param request - DeleteAgentInstanceConfigRequest
//
// @return DeleteAgentInstanceConfigResponse
func (client *Client) DeleteAgentInstanceConfig(configName *string, request *DeleteAgentInstanceConfigRequest) (_result *DeleteAgentInstanceConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteAgentInstanceConfigResponse{}
	_body, _err := client.DeleteAgentInstanceConfigWithOptions(configName, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an alert rule.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteAlertResponse
func (client *Client) DeleteAlertWithOptions(project *string, alertName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteAlertResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAlert"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/alerts/" + tea.StringValue(alertName)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteAlertResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes an alert rule.
//
// @return DeleteAlertResponse
func (client *Client) DeleteAlert(project *string, alertName *string) (_result *DeleteAlertResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteAlertResponse{}
	_body, _err := client.DeleteAlertWithOptions(project, alertName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Removes data from a dataset.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteAnnotationDataResponse
func (client *Client) DeleteAnnotationDataWithOptions(datasetId *string, annotationdataId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteAnnotationDataResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAnnotationData"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ml/annotationdataset/" + tea.StringValue(datasetId) + "/annotationdata/" + tea.StringValue(annotationdataId)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteAnnotationDataResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Removes data from a dataset.
//
// @return DeleteAnnotationDataResponse
func (client *Client) DeleteAnnotationData(datasetId *string, annotationdataId *string) (_result *DeleteAnnotationDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteAnnotationDataResponse{}
	_body, _err := client.DeleteAnnotationDataWithOptions(datasetId, annotationdataId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a dataset.
//
// Description:
//
// You can delete a dataset only if no data exists in the dataset.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteAnnotationDataSetResponse
func (client *Client) DeleteAnnotationDataSetWithOptions(datasetId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteAnnotationDataSetResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAnnotationDataSet"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ml/annotationdataset/" + tea.StringValue(datasetId)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteAnnotationDataSetResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a dataset.
//
// Description:
//
// You can delete a dataset only if no data exists in the dataset.
//
// @return DeleteAnnotationDataSetResponse
func (client *Client) DeleteAnnotationDataSet(datasetId *string) (_result *DeleteAnnotationDataSetResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteAnnotationDataSetResponse{}
	_body, _err := client.DeleteAnnotationDataSetWithOptions(datasetId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a tag table.
//
// Description:
//
// Only non-built-in tags can be deleted.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteAnnotationLabelResponse
func (client *Client) DeleteAnnotationLabelWithOptions(labelId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteAnnotationLabelResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAnnotationLabel"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ml/annotationlabel/" + tea.StringValue(labelId)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteAnnotationLabelResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a tag table.
//
// Description:
//
// Only non-built-in tags can be deleted.
//
// @return DeleteAnnotationLabelResponse
func (client *Client) DeleteAnnotationLabel(labelId *string) (_result *DeleteAnnotationLabelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteAnnotationLabelResponse{}
	_body, _err := client.DeleteAnnotationLabelWithOptions(labelId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a log collection policy from a cloud service.
//
// Description:
//
// You must use the Simple Log Service endpoint for the China (Shanghai), Singapore, or Heyuan ACDR Auto region to call the operation.
//
// @param request - DeleteCollectionPolicyRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteCollectionPolicyResponse
func (client *Client) DeleteCollectionPolicyWithOptions(policyName *string, request *DeleteCollectionPolicyRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteCollectionPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DataCode)) {
		query["dataCode"] = request.DataCode
	}

	if !tea.BoolValue(util.IsUnset(request.ProductCode)) {
		query["productCode"] = request.ProductCode
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCollectionPolicy"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/collectionpolicy/" + tea.StringValue(policyName)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteCollectionPolicyResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a log collection policy from a cloud service.
//
// Description:
//
// You must use the Simple Log Service endpoint for the China (Shanghai), Singapore, or Heyuan ACDR Auto region to call the operation.
//
// @param request - DeleteCollectionPolicyRequest
//
// @return DeleteCollectionPolicyResponse
func (client *Client) DeleteCollectionPolicy(policyName *string, request *DeleteCollectionPolicyRequest) (_result *DeleteCollectionPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteCollectionPolicyResponse{}
	_body, _err := client.DeleteCollectionPolicyWithOptions(policyName, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a Logtail configuration.
//
// Description:
//
// ### [](#)Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - If a Logtail configuration is applied to a machine group, you cannot collect data from the machine group after you delete the Logtail configuration.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
//   - The name of the required Logtail configuration is obtained. For more information, see [ListConfig](https://help.aliyun.com/document_detail/29043.html).
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteConfigResponse
func (client *Client) DeleteConfigWithOptions(project *string, configName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteConfigResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteConfig"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/configs/" + tea.StringValue(configName)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteConfigResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a Logtail configuration.
//
// Description:
//
// ### [](#)Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - If a Logtail configuration is applied to a machine group, you cannot collect data from the machine group after you delete the Logtail configuration.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
//   - The name of the required Logtail configuration is obtained. For more information, see [ListConfig](https://help.aliyun.com/document_detail/29043.html).
//
// @return DeleteConfigResponse
func (client *Client) DeleteConfig(project *string, configName *string) (_result *DeleteConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteConfigResponse{}
	_body, _err := client.DeleteConfigWithOptions(project, configName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a consumer group.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
//   - The name of the consumer group is obtained. For more information, see [ListConsumerGroup](https://help.aliyun.com/document_detail/74964.html).
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:DeleteConsumerGroup`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#logstoreName}/consumergroup/{#ConsumerGroup}`|
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteConsumerGroupResponse
func (client *Client) DeleteConsumerGroupWithOptions(project *string, logstore *string, consumerGroup *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteConsumerGroupResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteConsumerGroup"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "/consumergroups/" + tea.StringValue(consumerGroup)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteConsumerGroupResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a consumer group.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
//   - The name of the consumer group is obtained. For more information, see [ListConsumerGroup](https://help.aliyun.com/document_detail/74964.html).
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:DeleteConsumerGroup`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#logstoreName}/consumergroup/{#ConsumerGroup}`|
//
// @return DeleteConsumerGroupResponse
func (client *Client) DeleteConsumerGroup(project *string, logstore *string, consumerGroup *string) (_result *DeleteConsumerGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteConsumerGroupResponse{}
	_body, _err := client.DeleteConsumerGroupWithOptions(project, logstore, consumerGroup, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a dashboard.
//
// Description:
//
// ### [](#)Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteDashboardResponse
func (client *Client) DeleteDashboardWithOptions(project *string, dashboardName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteDashboardResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDashboard"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/dashboards/" + tea.StringValue(dashboardName)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteDashboardResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a dashboard.
//
// Description:
//
// ### [](#)Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
// @return DeleteDashboardResponse
func (client *Client) DeleteDashboard(project *string, dashboardName *string) (_result *DeleteDashboardResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteDashboardResponse{}
	_body, _err := client.DeleteDashboardWithOptions(project, dashboardName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a custom domain name that is bound to a project.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteDomainResponse
func (client *Client) DeleteDomainWithOptions(project *string, domainName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteDomainResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDomain"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/domains/" + tea.StringValue(domainName)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteDomainResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a custom domain name that is bound to a project.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @return DeleteDomainResponse
func (client *Client) DeleteDomain(project *string, domainName *string) (_result *DeleteDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteDomainResponse{}
	_body, _err := client.DeleteDomainWithOptions(project, domainName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a download task.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteDownloadJobResponse
func (client *Client) DeleteDownloadJobWithOptions(project *string, downloadJobName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteDownloadJobResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDownloadJob"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/downloadjobs/" + tea.StringValue(downloadJobName)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteDownloadJobResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a download task.
//
// @return DeleteDownloadJobResponse
func (client *Client) DeleteDownloadJob(project *string, downloadJobName *string) (_result *DeleteDownloadJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteDownloadJobResponse{}
	_body, _err := client.DeleteDownloadJobWithOptions(project, downloadJobName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 删除数据加工任务
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteETLResponse
func (client *Client) DeleteETLWithOptions(project *string, etlName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteETLResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteETL"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/etls/" + tea.StringValue(etlName)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteETLResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 删除数据加工任务
//
// @return DeleteETLResponse
func (client *Client) DeleteETL(project *string, etlName *string) (_result *DeleteETLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteETLResponse{}
	_body, _err := client.DeleteETLWithOptions(project, etlName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an external store.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteExternalStoreResponse
func (client *Client) DeleteExternalStoreWithOptions(project *string, externalStoreName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteExternalStoreResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteExternalStore"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/externalstores/" + tea.StringValue(externalStoreName)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteExternalStoreResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes an external store.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @return DeleteExternalStoreResponse
func (client *Client) DeleteExternalStore(project *string, externalStoreName *string) (_result *DeleteExternalStoreResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteExternalStoreResponse{}
	_body, _err := client.DeleteExternalStoreWithOptions(project, externalStoreName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an index of a Logstore.
//
// Description:
//
// ### Usage notes
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteIndexResponse
func (client *Client) DeleteIndexWithOptions(project *string, logstore *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteIndexResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteIndex"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "/index"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteIndexResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes an index of a Logstore.
//
// Description:
//
// ### Usage notes
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @return DeleteIndexResponse
func (client *Client) DeleteIndex(project *string, logstore *string) (_result *DeleteIndexResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteIndexResponse{}
	_body, _err := client.DeleteIndexWithOptions(project, logstore, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an ingest processor.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteIngestProcessorResponse
func (client *Client) DeleteIngestProcessorWithOptions(project *string, processorName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteIngestProcessorResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteIngestProcessor"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ingestprocessors/" + tea.StringValue(processorName)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteIngestProcessorResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes an ingest processor.
//
// @return DeleteIngestProcessorResponse
func (client *Client) DeleteIngestProcessor(project *string, processorName *string) (_result *DeleteIngestProcessorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteIngestProcessorResponse{}
	_body, _err := client.DeleteIngestProcessorWithOptions(project, processorName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a Logstore, including all shards and indexes in the Logstore.
//
// Description:
//
// ### Usage notes
//
// Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteLogStoreResponse
func (client *Client) DeleteLogStoreWithOptions(project *string, logstore *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteLogStoreResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteLogStore"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteLogStoreResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a Logstore, including all shards and indexes in the Logstore.
//
// Description:
//
// ### Usage notes
//
// Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
//
// @return DeleteLogStoreResponse
func (client *Client) DeleteLogStore(project *string, logstore *string) (_result *DeleteLogStoreResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteLogStoreResponse{}
	_body, _err := client.DeleteLogStoreWithOptions(project, logstore, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 关闭项目的服务日志记录。
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteLoggingResponse
func (client *Client) DeleteLoggingWithOptions(project *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteLoggingResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteLogging"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logging"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteLoggingResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 关闭项目的服务日志记录。
//
// @return DeleteLoggingResponse
func (client *Client) DeleteLogging(project *string) (_result *DeleteLoggingResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteLoggingResponse{}
	_body, _err := client.DeleteLoggingWithOptions(project, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a Logtail pipeline configuration.
//
// Description:
//
// The UK (London) region is supported. Supported regions are constantly updated.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteLogtailPipelineConfigResponse
func (client *Client) DeleteLogtailPipelineConfigWithOptions(project *string, configName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteLogtailPipelineConfigResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteLogtailPipelineConfig"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pipelineconfigs/" + tea.StringValue(configName)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteLogtailPipelineConfigResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a Logtail pipeline configuration.
//
// Description:
//
// The UK (London) region is supported. Supported regions are constantly updated.
//
// @return DeleteLogtailPipelineConfigResponse
func (client *Client) DeleteLogtailPipelineConfig(project *string, configName *string) (_result *DeleteLogtailPipelineConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteLogtailPipelineConfigResponse{}
	_body, _err := client.DeleteLogtailPipelineConfigWithOptions(project, configName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a machine group. If the Logtail configurations for log collection are applied to a machine group, the configurations are disassociated from the machine group after the machine group is deleted.
//
// Description:
//
// ### Usage notes
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteMachineGroupResponse
func (client *Client) DeleteMachineGroupWithOptions(project *string, machineGroup *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteMachineGroupResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteMachineGroup"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/machinegroups/" + tea.StringValue(machineGroup)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteMachineGroupResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a machine group. If the Logtail configurations for log collection are applied to a machine group, the configurations are disassociated from the machine group after the machine group is deleted.
//
// Description:
//
// ### Usage notes
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @return DeleteMachineGroupResponse
func (client *Client) DeleteMachineGroup(project *string, machineGroup *string) (_result *DeleteMachineGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteMachineGroupResponse{}
	_body, _err := client.DeleteMachineGroupWithOptions(project, machineGroup, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an existing Metricstore. When you delete a Metricstore, the metric data stored in the Metricstore and associated resources such as associated collection settings and transformation settings are also deleted.
//
// Description:
//
// Metricstores are used to store metric data. For more information, see [Metric data](https://help.aliyun.com/document_detail/174965.html).
//
//   - You must specify an existing Metricstore.
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query metric data is obtained. The information includes the name of the project to which the metric data belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
//   - You can create up to 200 Logstores or Metricstores in a project.
//
//   - Metric data is automatically deleted when the retention period of the metric data ends.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteMetricStoreResponse
func (client *Client) DeleteMetricStoreWithOptions(project *string, name *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteMetricStoreResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteMetricStore"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/metricstores/" + tea.StringValue(name)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("none"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteMetricStoreResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes an existing Metricstore. When you delete a Metricstore, the metric data stored in the Metricstore and associated resources such as associated collection settings and transformation settings are also deleted.
//
// Description:
//
// Metricstores are used to store metric data. For more information, see [Metric data](https://help.aliyun.com/document_detail/174965.html).
//
//   - You must specify an existing Metricstore.
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query metric data is obtained. The information includes the name of the project to which the metric data belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
//   - You can create up to 200 Logstores or Metricstores in a project.
//
//   - Metric data is automatically deleted when the retention period of the metric data ends.
//
// @return DeleteMetricStoreResponse
func (client *Client) DeleteMetricStore(project *string, name *string) (_result *DeleteMetricStoreResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteMetricStoreResponse{}
	_body, _err := client.DeleteMetricStoreWithOptions(project, name, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an Object Storage Service (OSS) data shipping job.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteOSSExportResponse
func (client *Client) DeleteOSSExportWithOptions(project *string, ossExportName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteOSSExportResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteOSSExport"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ossexports/" + tea.StringValue(ossExportName)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteOSSExportResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes an Object Storage Service (OSS) data shipping job.
//
// @return DeleteOSSExportResponse
func (client *Client) DeleteOSSExport(project *string, ossExportName *string) (_result *DeleteOSSExportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteOSSExportResponse{}
	_body, _err := client.DeleteOSSExportWithOptions(project, ossExportName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 删除OSSHDFS投递任务
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteOSSHDFSExportResponse
func (client *Client) DeleteOSSHDFSExportWithOptions(project *string, ossExportName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteOSSHDFSExportResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteOSSHDFSExport"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/osshdfsexports/" + tea.StringValue(ossExportName)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteOSSHDFSExportResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 删除OSSHDFS投递任务
//
// @return DeleteOSSHDFSExportResponse
func (client *Client) DeleteOSSHDFSExport(project *string, ossExportName *string) (_result *DeleteOSSHDFSExportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteOSSHDFSExportResponse{}
	_body, _err := client.DeleteOSSHDFSExportWithOptions(project, ossExportName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an Object Storage Service (OSS) data import job.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteOSSIngestionResponse
func (client *Client) DeleteOSSIngestionWithOptions(project *string, ossIngestionName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteOSSIngestionResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteOSSIngestion"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ossingestions/" + tea.StringValue(ossIngestionName)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteOSSIngestionResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes an Object Storage Service (OSS) data import job.
//
// @return DeleteOSSIngestionResponse
func (client *Client) DeleteOSSIngestion(project *string, ossIngestionName *string) (_result *DeleteOSSIngestionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteOSSIngestionResponse{}
	_body, _err := client.DeleteOSSIngestionWithOptions(project, ossIngestionName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a project.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - After you delete a project, all logs stored in the project and the configurations of the project are deleted and cannot be restored. Proceed with caution.
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:DeleteProject`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`|
//
// @param request - DeleteProjectRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteProjectResponse
func (client *Client) DeleteProjectWithOptions(project *string, request *DeleteProjectRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteProjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ForceDelete)) {
		query["forceDelete"] = request.ForceDelete
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteProject"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteProjectResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a project.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - After you delete a project, all logs stored in the project and the configurations of the project are deleted and cannot be restored. Proceed with caution.
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:DeleteProject`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`|
//
// @param request - DeleteProjectRequest
//
// @return DeleteProjectResponse
func (client *Client) DeleteProject(project *string, request *DeleteProjectRequest) (_result *DeleteProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteProjectResponse{}
	_body, _err := client.DeleteProjectWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a project policy.
//
// Description:
//
// ### [](#)Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteProjectPolicyResponse
func (client *Client) DeleteProjectPolicyWithOptions(project *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteProjectPolicyResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteProjectPolicy"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/policy"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteProjectPolicyResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a project policy.
//
// Description:
//
// ### [](#)Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
//
// @return DeleteProjectPolicyResponse
func (client *Client) DeleteProjectPolicy(project *string) (_result *DeleteProjectPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteProjectPolicyResponse{}
	_body, _err := client.DeleteProjectPolicyWithOptions(project, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a saved search.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
//   - After you delete a saved search, it cannot be restored. Proceed with caution.
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:DeleteSavedSearch`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/savedsearch/{#SavedSearchName}`|
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteSavedSearchResponse
func (client *Client) DeleteSavedSearchWithOptions(project *string, savedsearchName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteSavedSearchResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSavedSearch"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/savedsearches/" + tea.StringValue(savedsearchName)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteSavedSearchResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a saved search.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
//   - After you delete a saved search, it cannot be restored. Proceed with caution.
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:DeleteSavedSearch`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/savedsearch/{#SavedSearchName}`|
//
// @return DeleteSavedSearchResponse
func (client *Client) DeleteSavedSearch(project *string, savedsearchName *string) (_result *DeleteSavedSearchResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteSavedSearchResponse{}
	_body, _err := client.DeleteSavedSearchWithOptions(project, savedsearchName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a Scheduled SQL job.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteScheduledSQLResponse
func (client *Client) DeleteScheduledSQLWithOptions(project *string, scheduledSQLName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteScheduledSQLResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteScheduledSQL"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/scheduledsqls/" + tea.StringValue(scheduledSQLName)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteScheduledSQLResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a Scheduled SQL job.
//
// @return DeleteScheduledSQLResponse
func (client *Client) DeleteScheduledSQL(project *string, scheduledSQLName *string) (_result *DeleteScheduledSQLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteScheduledSQLResponse{}
	_body, _err := client.DeleteScheduledSQLWithOptions(project, scheduledSQLName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a dataset by using the name of the dataset.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteStoreViewResponse
func (client *Client) DeleteStoreViewWithOptions(project *string, name *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteStoreViewResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteStoreView"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/storeviews/" + tea.StringValue(name)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DeleteStoreViewResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Deletes a dataset by using the name of the dataset.
//
// @return DeleteStoreViewResponse
func (client *Client) DeleteStoreView(project *string, name *string) (_result *DeleteStoreViewResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteStoreViewResponse{}
	_body, _err := client.DeleteStoreViewWithOptions(project, name, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 查询可用的区域
//
// @param request - DescribeRegionsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeRegionsResponse
func (client *Client) DescribeRegionsWithOptions(request *DescribeRegionsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribeRegionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Language)) {
		query["language"] = request.Language
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRegions"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/regions"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRegionsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 查询可用的区域
//
// @param request - DescribeRegionsRequest
//
// @return DescribeRegionsResponse
func (client *Client) DescribeRegions(request *DescribeRegionsRequest) (_result *DescribeRegionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribeRegionsResponse{}
	_body, _err := client.DescribeRegionsWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Disables an alert rule.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DisableAlertResponse
func (client *Client) DisableAlertWithOptions(project *string, alertName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DisableAlertResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DisableAlert"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/alerts/" + tea.StringValue(alertName) + "?action=disable"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DisableAlertResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Disables an alert rule.
//
// @return DisableAlertResponse
func (client *Client) DisableAlert(project *string, alertName *string) (_result *DisableAlertResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DisableAlertResponse{}
	_body, _err := client.DisableAlertWithOptions(project, alertName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Disables the Scheduled SQL feature.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DisableScheduledSQLResponse
func (client *Client) DisableScheduledSQLWithOptions(project *string, scheduledSQLName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DisableScheduledSQLResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("DisableScheduledSQL"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/scheduledsqls/" + tea.StringValue(scheduledSQLName) + "?action=disable"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &DisableScheduledSQLResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Disables the Scheduled SQL feature.
//
// @return DisableScheduledSQLResponse
func (client *Client) DisableScheduledSQL(project *string, scheduledSQLName *string) (_result *DisableScheduledSQLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DisableScheduledSQLResponse{}
	_body, _err := client.DisableScheduledSQLWithOptions(project, scheduledSQLName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Enables an alert rule.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return EnableAlertResponse
func (client *Client) EnableAlertWithOptions(project *string, alertName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *EnableAlertResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("EnableAlert"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/alerts/" + tea.StringValue(alertName) + "?action=enable"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &EnableAlertResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Enables an alert rule.
//
// @return EnableAlertResponse
func (client *Client) EnableAlert(project *string, alertName *string) (_result *EnableAlertResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &EnableAlertResponse{}
	_body, _err := client.EnableAlertWithOptions(project, alertName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Enables the Scheduled SQL feature.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return EnableScheduledSQLResponse
func (client *Client) EnableScheduledSQLWithOptions(project *string, scheduledSQLName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *EnableScheduledSQLResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("EnableScheduledSQL"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/scheduledsqls/" + tea.StringValue(scheduledSQLName) + "?action=enable"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &EnableScheduledSQLResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Enables the Scheduled SQL feature.
//
// @return EnableScheduledSQLResponse
func (client *Client) EnableScheduledSQL(project *string, scheduledSQLName *string) (_result *EnableScheduledSQLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &EnableScheduledSQLResponse{}
	_body, _err := client.EnableScheduledSQLWithOptions(project, scheduledSQLName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// # GetAgentInstanceConfig
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetAgentInstanceConfigResponse
func (client *Client) GetAgentInstanceConfigWithOptions(configName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetAgentInstanceConfigResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetAgentInstanceConfig"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/agentinstanceconfigs/" + tea.StringValue(configName)),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAgentInstanceConfigResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// # GetAgentInstanceConfig
//
// @return GetAgentInstanceConfigResponse
func (client *Client) GetAgentInstanceConfig(configName *string) (_result *GetAgentInstanceConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetAgentInstanceConfigResponse{}
	_body, _err := client.GetAgentInstanceConfigWithOptions(configName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about an alert rule.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetAlertResponse
func (client *Client) GetAlertWithOptions(project *string, alertName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetAlertResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetAlert"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/alerts/" + tea.StringValue(alertName)),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAlertResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the information about an alert rule.
//
// @return GetAlertResponse
func (client *Client) GetAlert(project *string, alertName *string) (_result *GetAlertResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetAlertResponse{}
	_body, _err := client.GetAlertWithOptions(project, alertName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries data in datasets based on the unique identifier of the data.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetAnnotationDataResponse
func (client *Client) GetAnnotationDataWithOptions(datasetId *string, annotationdataId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetAnnotationDataResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetAnnotationData"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ml/annotationdataset/" + tea.StringValue(datasetId) + "/annotationdata/" + tea.StringValue(annotationdataId)),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAnnotationDataResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries data in datasets based on the unique identifier of the data.
//
// @return GetAnnotationDataResponse
func (client *Client) GetAnnotationData(datasetId *string, annotationdataId *string) (_result *GetAnnotationDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetAnnotationDataResponse{}
	_body, _err := client.GetAnnotationDataWithOptions(datasetId, annotationdataId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a dataset.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetAnnotationDataSetResponse
func (client *Client) GetAnnotationDataSetWithOptions(datasetId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetAnnotationDataSetResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetAnnotationDataSet"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ml/annotationdataset/" + tea.StringValue(datasetId)),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAnnotationDataSetResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a dataset.
//
// @return GetAnnotationDataSetResponse
func (client *Client) GetAnnotationDataSet(datasetId *string) (_result *GetAnnotationDataSetResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetAnnotationDataSetResponse{}
	_body, _err := client.GetAnnotationDataSetWithOptions(datasetId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a tag table by using a label ID.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetAnnotationLabelResponse
func (client *Client) GetAnnotationLabelWithOptions(labelId *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetAnnotationLabelResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetAnnotationLabel"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ml/annotationlabel/" + tea.StringValue(labelId)),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAnnotationLabelResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a tag table by using a label ID.
//
// @return GetAnnotationLabelResponse
func (client *Client) GetAnnotationLabel(labelId *string) (_result *GetAnnotationLabelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetAnnotationLabelResponse{}
	_body, _err := client.GetAnnotationLabelWithOptions(labelId, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the Logtail configurations that are applied to a machine group.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetAppliedConfigsResponse
func (client *Client) GetAppliedConfigsWithOptions(project *string, machineGroup *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetAppliedConfigsResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetAppliedConfigs"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/machinegroups/" + tea.StringValue(machineGroup) + "/configs"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAppliedConfigsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the Logtail configurations that are applied to a machine group.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @return GetAppliedConfigsResponse
func (client *Client) GetAppliedConfigs(project *string, machineGroup *string) (_result *GetAppliedConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetAppliedConfigsResponse{}
	_body, _err := client.GetAppliedConfigsWithOptions(project, machineGroup, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the machine groups to which a Logtail configuration is bound.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetAppliedMachineGroupsResponse
func (client *Client) GetAppliedMachineGroupsWithOptions(project *string, configName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetAppliedMachineGroupsResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetAppliedMachineGroups"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/configs/" + tea.StringValue(configName) + "/machinegroups"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAppliedMachineGroupsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the machine groups to which a Logtail configuration is bound.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @return GetAppliedMachineGroupsResponse
func (client *Client) GetAppliedMachineGroups(project *string, configName *string) (_result *GetAppliedMachineGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetAppliedMachineGroupsResponse{}
	_body, _err := client.GetAppliedMachineGroupsWithOptions(project, configName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the checkpoints of a shard from which data is consumed by a consumer group.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - GetCheckPointRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetCheckPointResponse
func (client *Client) GetCheckPointWithOptions(project *string, logstore *string, consumerGroup *string, request *GetCheckPointRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetCheckPointResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Shard)) {
		query["shard"] = request.Shard
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetCheckPoint"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "/consumergroups/" + tea.StringValue(consumerGroup)),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("array"),
	}
	_result = &GetCheckPointResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the checkpoints of a shard from which data is consumed by a consumer group.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - GetCheckPointRequest
//
// @return GetCheckPointResponse
func (client *Client) GetCheckPoint(project *string, logstore *string, consumerGroup *string, request *GetCheckPointRequest) (_result *GetCheckPointResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetCheckPointResponse{}
	_body, _err := client.GetCheckPointWithOptions(project, logstore, consumerGroup, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 调用GetCollectionPolicy获取对应的规则
//
// Description:
//
// You must use the Simple Log Service endpoint for the China (Shanghai), Singapore, or Heyuan ACDR Auto region to call the operation.
//
// @param request - GetCollectionPolicyRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetCollectionPolicyResponse
func (client *Client) GetCollectionPolicyWithOptions(policyName *string, request *GetCollectionPolicyRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetCollectionPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DataCode)) {
		query["dataCode"] = request.DataCode
	}

	if !tea.BoolValue(util.IsUnset(request.ProductCode)) {
		query["productCode"] = request.ProductCode
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetCollectionPolicy"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/collectionpolicy/" + tea.StringValue(policyName)),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetCollectionPolicyResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 调用GetCollectionPolicy获取对应的规则
//
// Description:
//
// You must use the Simple Log Service endpoint for the China (Shanghai), Singapore, or Heyuan ACDR Auto region to call the operation.
//
// @param request - GetCollectionPolicyRequest
//
// @return GetCollectionPolicyResponse
func (client *Client) GetCollectionPolicy(policyName *string, request *GetCollectionPolicyRequest) (_result *GetCollectionPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetCollectionPolicyResponse{}
	_body, _err := client.GetCollectionPolicyWithOptions(policyName, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the details of a Logtail configuration.
//
// Description:
//
// ### [](#)Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
//   - The name of the required Logtail configuration is obtained. For more information, see [ListConfig](https://help.aliyun.com/document_detail/29043.html).
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetConfigResponse
func (client *Client) GetConfigWithOptions(project *string, configName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetConfigResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetConfig"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/configs/" + tea.StringValue(configName)),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetConfigResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the details of a Logtail configuration.
//
// Description:
//
// ### [](#)Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
//   - The name of the required Logtail configuration is obtained. For more information, see [ListConfig](https://help.aliyun.com/document_detail/29043.html).
//
// @return GetConfigResponse
func (client *Client) GetConfig(project *string, configName *string) (_result *GetConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetConfigResponse{}
	_body, _err := client.GetConfigWithOptions(project, configName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the contextual logs of a specified log.
//
// Description:
//
// ### Usage notes
//
//   - You can specify a log as the start log. The time range of a contextual query is one day before and one day after the generation time of the start log.
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
//   - Indexes are configured before you query logs. For more information, see [Create indexes](https://help.aliyun.com/document_detail/90732.html).
//
//   - The values of the pack_id and pack_meta fields are obtained before you query logs. The fields are internal fields, and you can obtain the values by using the debugging feature of your browser in the Simple Log Service console.
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:GetLogStoreContextLogs`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#LogstoreName}`|
//
// @param request - GetContextLogsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetContextLogsResponse
func (client *Client) GetContextLogsWithOptions(project *string, logstore *string, request *GetContextLogsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetContextLogsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackLines)) {
		query["back_lines"] = request.BackLines
	}

	if !tea.BoolValue(util.IsUnset(request.ForwardLines)) {
		query["forward_lines"] = request.ForwardLines
	}

	if !tea.BoolValue(util.IsUnset(request.PackId)) {
		query["pack_id"] = request.PackId
	}

	if !tea.BoolValue(util.IsUnset(request.PackMeta)) {
		query["pack_meta"] = request.PackMeta
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetContextLogs"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "?type=context_log"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetContextLogsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the contextual logs of a specified log.
//
// Description:
//
// ### Usage notes
//
//   - You can specify a log as the start log. The time range of a contextual query is one day before and one day after the generation time of the start log.
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
//   - Indexes are configured before you query logs. For more information, see [Create indexes](https://help.aliyun.com/document_detail/90732.html).
//
//   - The values of the pack_id and pack_meta fields are obtained before you query logs. The fields are internal fields, and you can obtain the values by using the debugging feature of your browser in the Simple Log Service console.
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:GetLogStoreContextLogs`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#LogstoreName}`|
//
// @param request - GetContextLogsRequest
//
// @return GetContextLogsResponse
func (client *Client) GetContextLogs(project *string, logstore *string, request *GetContextLogsRequest) (_result *GetContextLogsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetContextLogsResponse{}
	_body, _err := client.GetContextLogsWithOptions(project, logstore, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a cursor based on a point in time.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - The following content describes the relationships among a cursor, project, Logstore, and shard:
//
//   - A project can have multiple Logstores.
//
//   - A Logstore can have multiple shards.
//
//   - You can use a cursor to obtain a log in a shard.
//
// @param request - GetCursorRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetCursorResponse
func (client *Client) GetCursorWithOptions(project *string, logstore *string, shardId *string, request *GetCursorRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetCursorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.From)) {
		query["from"] = request.From
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetCursor"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "/shards/" + tea.StringValue(shardId) + "?type=cursor"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetCursorResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a cursor based on a point in time.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - The following content describes the relationships among a cursor, project, Logstore, and shard:
//
//   - A project can have multiple Logstores.
//
//   - A Logstore can have multiple shards.
//
//   - You can use a cursor to obtain a log in a shard.
//
// @param request - GetCursorRequest
//
// @return GetCursorResponse
func (client *Client) GetCursor(project *string, logstore *string, shardId *string, request *GetCursorRequest) (_result *GetCursorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetCursorResponse{}
	_body, _err := client.GetCursorWithOptions(project, logstore, shardId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the server time of a cursor.
//
// @param request - GetCursorTimeRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetCursorTimeResponse
func (client *Client) GetCursorTimeWithOptions(project *string, logstore *string, shardId *string, request *GetCursorTimeRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetCursorTimeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Cursor)) {
		query["cursor"] = request.Cursor
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetCursorTime"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "/shards/" + tea.StringValue(shardId) + "?type=cursor_time"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetCursorTimeResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the server time of a cursor.
//
// @param request - GetCursorTimeRequest
//
// @return GetCursorTimeResponse
func (client *Client) GetCursorTime(project *string, logstore *string, shardId *string, request *GetCursorTimeRequest) (_result *GetCursorTimeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetCursorTimeResponse{}
	_body, _err := client.GetCursorTimeWithOptions(project, logstore, shardId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a dashboard.
//
// Description:
//
// ### [](#)Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetDashboardResponse
func (client *Client) GetDashboardWithOptions(project *string, dashboardName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetDashboardResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetDashboard"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/dashboards/" + tea.StringValue(dashboardName)),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDashboardResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a dashboard.
//
// Description:
//
// ### [](#)Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
// @return GetDashboardResponse
func (client *Client) GetDashboard(project *string, dashboardName *string) (_result *GetDashboardResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetDashboardResponse{}
	_body, _err := client.GetDashboardWithOptions(project, dashboardName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about a download task.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetDownloadJobResponse
func (client *Client) GetDownloadJobWithOptions(project *string, downloadJobName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetDownloadJobResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetDownloadJob"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/downloadjobs/" + tea.StringValue(downloadJobName)),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDownloadJobResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the information about a download task.
//
// @return GetDownloadJobResponse
func (client *Client) GetDownloadJob(project *string, downloadJobName *string) (_result *GetDownloadJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetDownloadJobResponse{}
	_body, _err := client.GetDownloadJobWithOptions(project, downloadJobName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 获取数据加工任务信息
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetETLResponse
func (client *Client) GetETLWithOptions(project *string, etlName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetETLResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetETL"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/etls/" + tea.StringValue(etlName)),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetETLResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 获取数据加工任务信息
//
// @return GetETLResponse
func (client *Client) GetETL(project *string, etlName *string) (_result *GetETLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetETLResponse{}
	_body, _err := client.GetETLWithOptions(project, etlName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the details of an external store.
//
// Description:
//
//	  The supported data sources of external stores include Object Storage Service (OSS) buckets and ApsaraDB RDS for MySQL databases in a virtual private cloud (VPC).
//
//		- Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetExternalStoreResponse
func (client *Client) GetExternalStoreWithOptions(project *string, externalStoreName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetExternalStoreResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetExternalStore"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/externalstores/" + tea.StringValue(externalStoreName)),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetExternalStoreResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the details of an external store.
//
// Description:
//
//	  The supported data sources of external stores include Object Storage Service (OSS) buckets and ApsaraDB RDS for MySQL databases in a virtual private cloud (VPC).
//
//		- Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @return GetExternalStoreResponse
func (client *Client) GetExternalStore(project *string, externalStoreName *string) (_result *GetExternalStoreResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetExternalStoreResponse{}
	_body, _err := client.GetExternalStoreWithOptions(project, externalStoreName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the distribution of logs that meet the specified search conditions in a Logstore.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - The time range is evenly divided into subintervals in the responses. If the time range that is specified in the request remains unchanged, the subintervals in the responses also remain unchanged.
//
//   - If the number of logs in a Logstore significantly changes, Simple Log Service cannot predict the number of times that you must call this operation to obtain the complete result. In this case, you must check the value of the progress parameter in the response of each request and determine whether to call this operation one more time to obtain the complete result. Each time you call this operation, the same number of charge units (CUs) are consumed.
//
//   - After a log is written to a Logstore, you can call the GetHistograms or GetLogs operation to query the log after a short latency. The latency of a query varies based on the type of the log. Simple Log Service classifies logs into the following types based on the log time:
//
//   - Real-time data: The difference between the time record in a log and the current time on Simple Log Service is within the interval (-180 seconds,900 seconds]. For example, if a log was generated at 12:03:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as real-time data. After real-time data is written to a Logstore, the data can be queried with a maximum latency of 3 seconds.
//
//   - Historical data: The difference between the time record in a log and the current time on Simple Log Service is within the interval [-604,800 seconds,-180 seconds). For example, if a log was generated at 12:00:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as historical data. This type of log is usually generated in data backfill scenarios.
//
//     After real-time data is written to a Logstore, the data can be queried with a maximum latency of 3 seconds. For 99.9% of queries, the latency is no more than 1 second.
//
// > Simple Log Service calculates the difference between the log time that is specified by the __time__ field and the receiving time that is specified by the __tag__:__receive_time__ field for each log. The receiving time indicates the time at which Simple Log Service receives the log. If the difference is within the interval (-180 seconds,900 seconds], Simple Log Service processes the log as real-time data. If the difference is within the interval [-604,800 seconds,-180 seconds), Simple Log Service processes the log as historical data.
//
//   - Simple Log Service provides examples on how to call the GetHistograms operation by using Simple Log Service SDK for Java. For more information, see [Use GetHistograms to query the distribution of logs](https://help.aliyun.com/document_detail/462234.html).
//
// @param request - GetHistogramsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetHistogramsResponse
func (client *Client) GetHistogramsWithOptions(project *string, logstore *string, request *GetHistogramsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetHistogramsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.From)) {
		query["from"] = request.From
	}

	if !tea.BoolValue(util.IsUnset(request.Query)) {
		query["query"] = request.Query
	}

	if !tea.BoolValue(util.IsUnset(request.To)) {
		query["to"] = request.To
	}

	if !tea.BoolValue(util.IsUnset(request.Topic)) {
		query["topic"] = request.Topic
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetHistograms"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "/index?type=histogram"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("array"),
	}
	_result = &GetHistogramsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the distribution of logs that meet the specified search conditions in a Logstore.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - The time range is evenly divided into subintervals in the responses. If the time range that is specified in the request remains unchanged, the subintervals in the responses also remain unchanged.
//
//   - If the number of logs in a Logstore significantly changes, Simple Log Service cannot predict the number of times that you must call this operation to obtain the complete result. In this case, you must check the value of the progress parameter in the response of each request and determine whether to call this operation one more time to obtain the complete result. Each time you call this operation, the same number of charge units (CUs) are consumed.
//
//   - After a log is written to a Logstore, you can call the GetHistograms or GetLogs operation to query the log after a short latency. The latency of a query varies based on the type of the log. Simple Log Service classifies logs into the following types based on the log time:
//
//   - Real-time data: The difference between the time record in a log and the current time on Simple Log Service is within the interval (-180 seconds,900 seconds]. For example, if a log was generated at 12:03:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as real-time data. After real-time data is written to a Logstore, the data can be queried with a maximum latency of 3 seconds.
//
//   - Historical data: The difference between the time record in a log and the current time on Simple Log Service is within the interval [-604,800 seconds,-180 seconds). For example, if a log was generated at 12:00:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as historical data. This type of log is usually generated in data backfill scenarios.
//
//     After real-time data is written to a Logstore, the data can be queried with a maximum latency of 3 seconds. For 99.9% of queries, the latency is no more than 1 second.
//
// > Simple Log Service calculates the difference between the log time that is specified by the __time__ field and the receiving time that is specified by the __tag__:__receive_time__ field for each log. The receiving time indicates the time at which Simple Log Service receives the log. If the difference is within the interval (-180 seconds,900 seconds], Simple Log Service processes the log as real-time data. If the difference is within the interval [-604,800 seconds,-180 seconds), Simple Log Service processes the log as historical data.
//
//   - Simple Log Service provides examples on how to call the GetHistograms operation by using Simple Log Service SDK for Java. For more information, see [Use GetHistograms to query the distribution of logs](https://help.aliyun.com/document_detail/462234.html).
//
// @param request - GetHistogramsRequest
//
// @return GetHistogramsResponse
func (client *Client) GetHistograms(project *string, logstore *string, request *GetHistogramsRequest) (_result *GetHistogramsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetHistogramsResponse{}
	_body, _err := client.GetHistogramsWithOptions(project, logstore, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the index of a Logstore.
//
// Description:
//
// ### Usage notes
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetIndexResponse
func (client *Client) GetIndexWithOptions(project *string, logstore *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetIndexResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetIndex"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "/index"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetIndexResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the index of a Logstore.
//
// Description:
//
// ### Usage notes
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @return GetIndexResponse
func (client *Client) GetIndex(project *string, logstore *string) (_result *GetIndexResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetIndexResponse{}
	_body, _err := client.GetIndexWithOptions(project, logstore, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries an ingest processor.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetIngestProcessorResponse
func (client *Client) GetIngestProcessorWithOptions(project *string, processorName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetIngestProcessorResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetIngestProcessor"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ingestprocessors/" + tea.StringValue(processorName)),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetIngestProcessorResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries an ingest processor.
//
// @return GetIngestProcessorResponse
func (client *Client) GetIngestProcessor(project *string, processorName *string) (_result *GetIngestProcessorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetIngestProcessorResponse{}
	_body, _err := client.GetIngestProcessorWithOptions(project, processorName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the details of a Logstore.
//
// Description:
//
// ### Usage notes
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetLogStoreResponse
func (client *Client) GetLogStoreWithOptions(project *string, logstore *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetLogStoreResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetLogStore"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore)),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetLogStoreResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the details of a Logstore.
//
// Description:
//
// ### Usage notes
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @return GetLogStoreResponse
func (client *Client) GetLogStore(project *string, logstore *string) (_result *GetLogStoreResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetLogStoreResponse{}
	_body, _err := client.GetLogStoreWithOptions(project, logstore, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the billing mode of a Logstore.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetLogStoreMeteringModeResponse
func (client *Client) GetLogStoreMeteringModeWithOptions(project *string, logstore *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetLogStoreMeteringModeResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetLogStoreMeteringMode"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "/meteringmode"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetLogStoreMeteringModeResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the billing mode of a Logstore.
//
// @return GetLogStoreMeteringModeResponse
func (client *Client) GetLogStoreMeteringMode(project *string, logstore *string) (_result *GetLogStoreMeteringModeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetLogStoreMeteringModeResponse{}
	_body, _err := client.GetLogStoreMeteringModeWithOptions(project, logstore, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the service log configuration of a project.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetLoggingResponse
func (client *Client) GetLoggingWithOptions(project *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetLoggingResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetLogging"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logging"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetLoggingResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the service log configuration of a project.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @return GetLoggingResponse
func (client *Client) GetLogging(project *string) (_result *GetLoggingResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetLoggingResponse{}
	_body, _err := client.GetLoggingWithOptions(project, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the logs of a Logstore in a project.
//
// Description:
//
// ### Usage notes
//
// **Note*	- Simple Log Service allows you to create a Scheduled SQL job. For more information, see [Create a scheduled SQL job](https://help.aliyun.com/document_detail/286457.html).
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
//   - Limits are imposed when you use Simple Log Service to query logs. We recommend that you specify query statements and query time ranges based on the limits. For more information, see [Log search overview](https://help.aliyun.com/document_detail/43772.html) and [Log analysis overview](https://help.aliyun.com/document_detail/53608.html).
//
//   - Indexes are configured before you query logs. For more information, see [Create indexes](https://help.aliyun.com/document_detail/90732.html).
//
//   - If the number of logs in a Logstore significantly changes, Simple Log Service cannot predict the number of times that you must call this operation to obtain the complete results. In this case, you must check the value of the x-log-progress parameter in the response of each request and determine whether to call this operation one more time to obtain the complete results. Each time you call this operation, the same number of charge units (CUs) are consumed.
//
//   - After a log is written to a Logstore, you can call the GetHistograms or the GetLogs operation to query the log. The latency of the query varies based on the type of the log. Simple Log Service classifies logs into the following types based on log timestamps:
//
//   - Real-time data: The difference between the time record in a log of this type and the current time on Simple Log Service is within the interval (-180 seconds,900 seconds\\]. For example, if a log was generated at 12:03:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as real-time data. This type of log is usually generated in common scenarios.
//
//   - Historical data: The difference between the time record in a log of this type and the current time on Simple Log Service is within the interval [-604,800 seconds,-180 seconds). For example, if a log was generated at 12:00:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as historical data. This type of log is usually generated in data backfill scenarios. After real-time data is written to a Logstore, the data can be queried with an approximate latency of 3 seconds.
//
// **Note*	- Simple Log Service calculates the difference between the log time that is specified by the __time__ field and the receiving time that is specified by the __tag__:**receive_time*	- field for each log. The receiving time indicates when Simple Log Service receives the log. If the difference is within the interval (-180 seconds,900 seconds\\], Simple Log Service processes the log as real-time data. If the difference is within the interval [-604,800 seconds,-180 seconds), Simple Log Service processes the log as historical data.
//
//   - Simple Log Service provides examples on how to call the GetLogs operation by using Simple Log Service SDK for Java and Simple Log Service SDK for Python. For more information, see [Examples of calling the GetLogs operation by using Simple Log Service SDK for Java](https://help.aliyun.com/document_detail/407683.html) and [Examples of calling the GetLogs operation by using Simple Log Service SDK for Python](https://help.aliyun.com/document_detail/407684.html).
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:GetLogStoreLogs`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#LogstoreName}`|
//
// @param request - GetLogsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetLogsResponse
func (client *Client) GetLogsWithOptions(project *string, logstore *string, request *GetLogsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetLogsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.From)) {
		query["from"] = request.From
	}

	if !tea.BoolValue(util.IsUnset(request.Line)) {
		query["line"] = request.Line
	}

	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.PowerSql)) {
		query["powerSql"] = request.PowerSql
	}

	if !tea.BoolValue(util.IsUnset(request.Query)) {
		query["query"] = request.Query
	}

	if !tea.BoolValue(util.IsUnset(request.Reverse)) {
		query["reverse"] = request.Reverse
	}

	if !tea.BoolValue(util.IsUnset(request.To)) {
		query["to"] = request.To
	}

	if !tea.BoolValue(util.IsUnset(request.Topic)) {
		query["topic"] = request.Topic
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetLogs"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "?type=log"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("array"),
	}
	_result = &GetLogsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the logs of a Logstore in a project.
//
// Description:
//
// ### Usage notes
//
// **Note*	- Simple Log Service allows you to create a Scheduled SQL job. For more information, see [Create a scheduled SQL job](https://help.aliyun.com/document_detail/286457.html).
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
//   - Limits are imposed when you use Simple Log Service to query logs. We recommend that you specify query statements and query time ranges based on the limits. For more information, see [Log search overview](https://help.aliyun.com/document_detail/43772.html) and [Log analysis overview](https://help.aliyun.com/document_detail/53608.html).
//
//   - Indexes are configured before you query logs. For more information, see [Create indexes](https://help.aliyun.com/document_detail/90732.html).
//
//   - If the number of logs in a Logstore significantly changes, Simple Log Service cannot predict the number of times that you must call this operation to obtain the complete results. In this case, you must check the value of the x-log-progress parameter in the response of each request and determine whether to call this operation one more time to obtain the complete results. Each time you call this operation, the same number of charge units (CUs) are consumed.
//
//   - After a log is written to a Logstore, you can call the GetHistograms or the GetLogs operation to query the log. The latency of the query varies based on the type of the log. Simple Log Service classifies logs into the following types based on log timestamps:
//
//   - Real-time data: The difference between the time record in a log of this type and the current time on Simple Log Service is within the interval (-180 seconds,900 seconds\\]. For example, if a log was generated at 12:03:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as real-time data. This type of log is usually generated in common scenarios.
//
//   - Historical data: The difference between the time record in a log of this type and the current time on Simple Log Service is within the interval [-604,800 seconds,-180 seconds). For example, if a log was generated at 12:00:00, September 25, 2014 (UTC) and Simple Log Service received the log at 12:05:00, September 25, 2014 (UTC), Simple Log Service processes the log as historical data. This type of log is usually generated in data backfill scenarios. After real-time data is written to a Logstore, the data can be queried with an approximate latency of 3 seconds.
//
// **Note*	- Simple Log Service calculates the difference between the log time that is specified by the __time__ field and the receiving time that is specified by the __tag__:**receive_time*	- field for each log. The receiving time indicates when Simple Log Service receives the log. If the difference is within the interval (-180 seconds,900 seconds\\], Simple Log Service processes the log as real-time data. If the difference is within the interval [-604,800 seconds,-180 seconds), Simple Log Service processes the log as historical data.
//
//   - Simple Log Service provides examples on how to call the GetLogs operation by using Simple Log Service SDK for Java and Simple Log Service SDK for Python. For more information, see [Examples of calling the GetLogs operation by using Simple Log Service SDK for Java](https://help.aliyun.com/document_detail/407683.html) and [Examples of calling the GetLogs operation by using Simple Log Service SDK for Python](https://help.aliyun.com/document_detail/407684.html).
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:GetLogStoreLogs`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#LogstoreName}`|
//
// @param request - GetLogsRequest
//
// @return GetLogsResponse
func (client *Client) GetLogs(project *string, logstore *string, request *GetLogsRequest) (_result *GetLogsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetLogsResponse{}
	_body, _err := client.GetLogsWithOptions(project, logstore, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the raw log data in a Logstore of a project. The returned result contains the raw log data within a specific time range. The returned result is compressed before transmission.
//
// Description:
//
//	  You can call this operation by using Alibaba Cloud SDK for Go, Java, TypeScript, or Python.
//
//		- You can call this operation by using Simple Log Service SDK for Go or Java.
//
//		- For more information, see [GetLogs](https://help.aliyun.com/document_detail/29029.html).
//
// @param request - GetLogsV2Request
//
// @param headers - GetLogsV2Headers
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetLogsV2Response
func (client *Client) GetLogsV2WithOptions(project *string, logstore *string, request *GetLogsV2Request, headers *GetLogsV2Headers, runtime *util.RuntimeOptions) (_result *GetLogsV2Response, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Forward)) {
		body["forward"] = request.Forward
	}

	if !tea.BoolValue(util.IsUnset(request.From)) {
		body["from"] = request.From
	}

	if !tea.BoolValue(util.IsUnset(request.Highlight)) {
		body["highlight"] = request.Highlight
	}

	if !tea.BoolValue(util.IsUnset(request.Line)) {
		body["line"] = request.Line
	}

	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		body["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.PowerSql)) {
		body["powerSql"] = request.PowerSql
	}

	if !tea.BoolValue(util.IsUnset(request.Query)) {
		body["query"] = request.Query
	}

	if !tea.BoolValue(util.IsUnset(request.Reverse)) {
		body["reverse"] = request.Reverse
	}

	if !tea.BoolValue(util.IsUnset(request.Session)) {
		body["session"] = request.Session
	}

	if !tea.BoolValue(util.IsUnset(request.To)) {
		body["to"] = request.To
	}

	if !tea.BoolValue(util.IsUnset(request.Topic)) {
		body["topic"] = request.Topic
	}

	realHeaders := make(map[string]*string)
	if !tea.BoolValue(util.IsUnset(headers.CommonHeaders)) {
		realHeaders = headers.CommonHeaders
	}

	if !tea.BoolValue(util.IsUnset(headers.AcceptEncoding)) {
		realHeaders["Accept-Encoding"] = util.ToJSONString(headers.AcceptEncoding)
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: realHeaders,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetLogsV2"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "/logs"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetLogsV2Response{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the raw log data in a Logstore of a project. The returned result contains the raw log data within a specific time range. The returned result is compressed before transmission.
//
// Description:
//
//	  You can call this operation by using Alibaba Cloud SDK for Go, Java, TypeScript, or Python.
//
//		- You can call this operation by using Simple Log Service SDK for Go or Java.
//
//		- For more information, see [GetLogs](https://help.aliyun.com/document_detail/29029.html).
//
// @param request - GetLogsV2Request
//
// @return GetLogsV2Response
func (client *Client) GetLogsV2(project *string, logstore *string, request *GetLogsV2Request) (_result *GetLogsV2Response, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := &GetLogsV2Headers{}
	_result = &GetLogsV2Response{}
	_body, _err := client.GetLogsV2WithOptions(project, logstore, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about a Logtail pipeline configuration.
//
// Description:
//
// The UK (London) region is supported. Supported regions are constantly updated.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetLogtailPipelineConfigResponse
func (client *Client) GetLogtailPipelineConfigWithOptions(project *string, configName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetLogtailPipelineConfigResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetLogtailPipelineConfig"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pipelineconfigs/" + tea.StringValue(configName)),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetLogtailPipelineConfigResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the information about a Logtail pipeline configuration.
//
// Description:
//
// The UK (London) region is supported. Supported regions are constantly updated.
//
// @return GetLogtailPipelineConfigResponse
func (client *Client) GetLogtailPipelineConfig(project *string, configName *string) (_result *GetLogtailPipelineConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetLogtailPipelineConfigResponse{}
	_body, _err := client.GetLogtailPipelineConfigWithOptions(project, configName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Simple Log Service provides intelligent analysis capabilities that can be used to analyze basic data such as logs, metrics, and traces. You can call the GetMLServiceResults operation to obtain the analysis results of a model. You can call the operation in the following scenarios: Named Entity Recognition (NER) tasks on logs, anomaly detection on time series, and root cause analysis on high-latency traces.
//
// Description:
//
// You must obtain the following basic permissions before you call this operation:
//
//	{
//
//	    "Version": "1",
//
//	    "Statement": [
//
//	        {
//
//	            "Action": [
//
//	                "log:Get*"
//
//	            ],
//
//	            "Resource": [
//
//	                "acs:log:*:*:mlservice/sls_builtin_*"
//
//	            ],
//
//	            "Effect": "Allow"
//
//	        }
//
//	    ]
//
//	}
//
// @param request - GetMLServiceResultsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetMLServiceResultsResponse
func (client *Client) GetMLServiceResultsWithOptions(serviceName *string, request *GetMLServiceResultsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetMLServiceResultsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AllowBuiltin)) {
		query["allowBuiltin"] = request.AllowBuiltin
	}

	if !tea.BoolValue(util.IsUnset(request.Version)) {
		query["version"] = request.Version
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(request.Body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMLServiceResults"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ml/service/" + tea.StringValue(serviceName) + "/analysis"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMLServiceResultsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Simple Log Service provides intelligent analysis capabilities that can be used to analyze basic data such as logs, metrics, and traces. You can call the GetMLServiceResults operation to obtain the analysis results of a model. You can call the operation in the following scenarios: Named Entity Recognition (NER) tasks on logs, anomaly detection on time series, and root cause analysis on high-latency traces.
//
// Description:
//
// You must obtain the following basic permissions before you call this operation:
//
//	{
//
//	    "Version": "1",
//
//	    "Statement": [
//
//	        {
//
//	            "Action": [
//
//	                "log:Get*"
//
//	            ],
//
//	            "Resource": [
//
//	                "acs:log:*:*:mlservice/sls_builtin_*"
//
//	            ],
//
//	            "Effect": "Allow"
//
//	        }
//
//	    ]
//
//	}
//
// @param request - GetMLServiceResultsRequest
//
// @return GetMLServiceResultsResponse
func (client *Client) GetMLServiceResults(serviceName *string, request *GetMLServiceResultsRequest) (_result *GetMLServiceResultsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetMLServiceResultsResponse{}
	_body, _err := client.GetMLServiceResultsWithOptions(serviceName, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the details of a machine group.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetMachineGroupResponse
func (client *Client) GetMachineGroupWithOptions(project *string, machineGroup *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetMachineGroupResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetMachineGroup"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/machinegroups/" + tea.StringValue(machineGroup)),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMachineGroupResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the details of a machine group.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @return GetMachineGroupResponse
func (client *Client) GetMachineGroup(project *string, machineGroup *string) (_result *GetMachineGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetMachineGroupResponse{}
	_body, _err := client.GetMachineGroupWithOptions(project, machineGroup, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a Metricstore.
//
// Description:
//
// Metricstores are used to store metric data. For more information about Metricstores, see [Metricstores](https://help.aliyun.com/document_detail/171723.html). For more information about metric data, see [Metric data](https://help.aliyun.com/document_detail/174965.html). You can call this operation to query the settings of a Metricstore. To query the metric data in a Metricstore, see [Query and analysis](https://help.aliyun.com/document_detail/174968.html) and [GetLogsV2](https://help.aliyun.com/document_detail/2771318.html).
//
//   - You must specify an existing Metricstore.
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query metric data is obtained. The information includes the name of the project to which the metric data belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
//   - You can create up to 200 Logstores or Metricstores in a project.
//
//   - Metric data is automatically deleted when the retention period of the metric data ends.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetMetricStoreResponse
func (client *Client) GetMetricStoreWithOptions(project *string, name *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetMetricStoreResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetMetricStore"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/metricstores/" + tea.StringValue(name)),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("none"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMetricStoreResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a Metricstore.
//
// Description:
//
// Metricstores are used to store metric data. For more information about Metricstores, see [Metricstores](https://help.aliyun.com/document_detail/171723.html). For more information about metric data, see [Metric data](https://help.aliyun.com/document_detail/174965.html). You can call this operation to query the settings of a Metricstore. To query the metric data in a Metricstore, see [Query and analysis](https://help.aliyun.com/document_detail/174968.html) and [GetLogsV2](https://help.aliyun.com/document_detail/2771318.html).
//
//   - You must specify an existing Metricstore.
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query metric data is obtained. The information includes the name of the project to which the metric data belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
//   - You can create up to 200 Logstores or Metricstores in a project.
//
//   - Metric data is automatically deleted when the retention period of the metric data ends.
//
// @return GetMetricStoreResponse
func (client *Client) GetMetricStore(project *string, name *string) (_result *GetMetricStoreResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetMetricStoreResponse{}
	_body, _err := client.GetMetricStoreWithOptions(project, name, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the billing mode of a Metricstore.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetMetricStoreMeteringModeResponse
func (client *Client) GetMetricStoreMeteringModeWithOptions(project *string, metricStore *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetMetricStoreMeteringModeResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetMetricStoreMeteringMode"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/metricstores/" + tea.StringValue(metricStore) + "/meteringmode"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMetricStoreMeteringModeResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the billing mode of a Metricstore.
//
// @return GetMetricStoreMeteringModeResponse
func (client *Client) GetMetricStoreMeteringMode(project *string, metricStore *string) (_result *GetMetricStoreMeteringModeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetMetricStoreMeteringModeResponse{}
	_body, _err := client.GetMetricStoreMeteringModeWithOptions(project, metricStore, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 获取OSS投递任务
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetOSSExportResponse
func (client *Client) GetOSSExportWithOptions(project *string, ossExportName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetOSSExportResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetOSSExport"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ossexports/" + tea.StringValue(ossExportName)),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetOSSExportResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 获取OSS投递任务
//
// @return GetOSSExportResponse
func (client *Client) GetOSSExport(project *string, ossExportName *string) (_result *GetOSSExportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetOSSExportResponse{}
	_body, _err := client.GetOSSExportWithOptions(project, ossExportName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// # Get OSSHDFS Exports
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetOSSHDFSExportResponse
func (client *Client) GetOSSHDFSExportWithOptions(project *string, ossExportName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetOSSHDFSExportResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetOSSHDFSExport"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/osshdfsexports/" + tea.StringValue(ossExportName)),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetOSSHDFSExportResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// # Get OSSHDFS Exports
//
// @return GetOSSHDFSExportResponse
func (client *Client) GetOSSHDFSExport(project *string, ossExportName *string) (_result *GetOSSHDFSExportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetOSSHDFSExportResponse{}
	_body, _err := client.GetOSSHDFSExportWithOptions(project, ossExportName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about an Object Storage Service (OSS) data import job.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetOSSIngestionResponse
func (client *Client) GetOSSIngestionWithOptions(project *string, ossIngestionName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetOSSIngestionResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetOSSIngestion"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ossingestions/" + tea.StringValue(ossIngestionName)),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetOSSIngestionResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the information about an Object Storage Service (OSS) data import job.
//
// @return GetOSSIngestionResponse
func (client *Client) GetOSSIngestion(project *string, ossIngestionName *string) (_result *GetOSSIngestionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetOSSIngestionResponse{}
	_body, _err := client.GetOSSIngestionWithOptions(project, ossIngestionName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the details of a project.
//
// Description:
//
// ### Usage notes
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetProjectResponse
func (client *Client) GetProjectWithOptions(project *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetProjectResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetProject"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetProjectResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the details of a project.
//
// Description:
//
// ### Usage notes
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @return GetProjectResponse
func (client *Client) GetProject(project *string) (_result *GetProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetProjectResponse{}
	_body, _err := client.GetProjectWithOptions(project, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries logs in a project. You can use this operation to query logs at the project level.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
//   - Indexes are configured before you query logs. For more information, see [Create indexes](https://help.aliyun.com/document_detail/90732.html).
//
//   - Limits are imposed when you use Simple Log Service to query logs. We recommend that you specify query statements and query time ranges based on the limits. For more information, see [Log search overview](https://help.aliyun.com/document_detail/43772.html) and [Log analysis overview](https://help.aliyun.com/document_detail/53608.html).
//
//   - You must set query to a standard SQL statement.
//
//   - You must specify a Logstore in the FROM clause of an SQL statement. A Logstore can be used as an SQL table.
//
//   - You must specify a time range in an SQL statement by using the __date__ or __time__ parameter. The value of the __date__ parameter is a timestamp. The value of the __time__ parameter is an integer, and the unit of the value is seconds.
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:GetProjectLogs`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`|
//
// @param request - GetProjectLogsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetProjectLogsResponse
func (client *Client) GetProjectLogsWithOptions(project *string, request *GetProjectLogsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetProjectLogsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PowerSql)) {
		query["powerSql"] = request.PowerSql
	}

	if !tea.BoolValue(util.IsUnset(request.Query)) {
		query["query"] = request.Query
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetProjectLogs"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logs"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("array"),
	}
	_result = &GetProjectLogsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries logs in a project. You can use this operation to query logs at the project level.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
//   - Indexes are configured before you query logs. For more information, see [Create indexes](https://help.aliyun.com/document_detail/90732.html).
//
//   - Limits are imposed when you use Simple Log Service to query logs. We recommend that you specify query statements and query time ranges based on the limits. For more information, see [Log search overview](https://help.aliyun.com/document_detail/43772.html) and [Log analysis overview](https://help.aliyun.com/document_detail/53608.html).
//
//   - You must set query to a standard SQL statement.
//
//   - You must specify a Logstore in the FROM clause of an SQL statement. A Logstore can be used as an SQL table.
//
//   - You must specify a time range in an SQL statement by using the __date__ or __time__ parameter. The value of the __date__ parameter is a timestamp. The value of the __time__ parameter is an integer, and the unit of the value is seconds.
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:GetProjectLogs`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`|
//
// @param request - GetProjectLogsRequest
//
// @return GetProjectLogsResponse
func (client *Client) GetProjectLogs(project *string, request *GetProjectLogsRequest) (_result *GetProjectLogsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetProjectLogsResponse{}
	_body, _err := client.GetProjectLogsWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a project policy.
//
// Description:
//
// ### [](#)Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetProjectPolicyResponse
func (client *Client) GetProjectPolicyWithOptions(project *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetProjectPolicyResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetProjectPolicy"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/policy"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("string"),
	}
	_result = &GetProjectPolicyResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a project policy.
//
// Description:
//
// ### [](#)Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
//
// @return GetProjectPolicyResponse
func (client *Client) GetProjectPolicy(project *string) (_result *GetProjectPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetProjectPolicyResponse{}
	_body, _err := client.GetProjectPolicyWithOptions(project, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a saved search.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
//   - You can call the ListSavedSearch operation to query the name of a saved search.
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:GetSavedSearch`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/savedsearch/{#SavedSearchName}`|
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetSavedSearchResponse
func (client *Client) GetSavedSearchWithOptions(project *string, savedsearchName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetSavedSearchResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetSavedSearch"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/savedsearches/" + tea.StringValue(savedsearchName)),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetSavedSearchResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a saved search.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
//   - You can call the ListSavedSearch operation to query the name of a saved search.
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:GetSavedSearch`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/savedsearch/{#SavedSearchName}`|
//
// @return GetSavedSearchResponse
func (client *Client) GetSavedSearch(project *string, savedsearchName *string) (_result *GetSavedSearchResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetSavedSearchResponse{}
	_body, _err := client.GetSavedSearchWithOptions(project, savedsearchName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about a Scheduled SQL job.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetScheduledSQLResponse
func (client *Client) GetScheduledSQLWithOptions(project *string, scheduledSQLName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetScheduledSQLResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetScheduledSQL"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/scheduledsqls/" + tea.StringValue(scheduledSQLName)),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetScheduledSQLResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the information about a Scheduled SQL job.
//
// @return GetScheduledSQLResponse
func (client *Client) GetScheduledSQL(project *string, scheduledSQLName *string) (_result *GetScheduledSQLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetScheduledSQLResponse{}
	_body, _err := client.GetScheduledSQLWithOptions(project, scheduledSQLName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the activation status of Simple Log Service. You must use the endpoint for Simple Log Service only in the China (Shanghai) or Singapore region.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetSlsServiceResponse
func (client *Client) GetSlsServiceWithOptions(headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetSlsServiceResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetSlsService"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/slsservice"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetSlsServiceResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the activation status of Simple Log Service. You must use the endpoint for Simple Log Service only in the China (Shanghai) or Singapore region.
//
// @return GetSlsServiceResponse
func (client *Client) GetSlsService() (_result *GetSlsServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetSlsServiceResponse{}
	_body, _err := client.GetSlsServiceWithOptions(headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the configurations of the Dedicated SQL feature.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetSqlInstanceResponse
func (client *Client) GetSqlInstanceWithOptions(project *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetSqlInstanceResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetSqlInstance"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/sqlinstance"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("array"),
	}
	_result = &GetSqlInstanceResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the configurations of the Dedicated SQL feature.
//
// @return GetSqlInstanceResponse
func (client *Client) GetSqlInstance(project *string) (_result *GetSqlInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetSqlInstanceResponse{}
	_body, _err := client.GetSqlInstanceWithOptions(project, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the configurations of a dataset by using the name of the dataset.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetStoreViewResponse
func (client *Client) GetStoreViewWithOptions(project *string, name *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetStoreViewResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetStoreView"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/storeviews/" + tea.StringValue(name)),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetStoreViewResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the configurations of a dataset by using the name of the dataset.
//
// @return GetStoreViewResponse
func (client *Client) GetStoreView(project *string, name *string) (_result *GetStoreViewResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetStoreViewResponse{}
	_body, _err := client.GetStoreViewWithOptions(project, name, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the indexes of a dataset by using the name of the dataset. Only datasets of the logstore type are supported.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetStoreViewIndexResponse
func (client *Client) GetStoreViewIndexWithOptions(project *string, name *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetStoreViewIndexResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetStoreViewIndex"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/storeviews/" + tea.StringValue(name) + "/index"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetStoreViewIndexResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the indexes of a dataset by using the name of the dataset. Only datasets of the logstore type are supported.
//
// @return GetStoreViewIndexResponse
func (client *Client) GetStoreViewIndex(project *string, name *string) (_result *GetStoreViewIndexResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetStoreViewIndexResponse{}
	_body, _err := client.GetStoreViewIndexWithOptions(project, name, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// # ListAgentInstanceConfigs
//
// @param request - ListAgentInstanceConfigsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListAgentInstanceConfigsResponse
func (client *Client) ListAgentInstanceConfigsWithOptions(request *ListAgentInstanceConfigsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListAgentInstanceConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAgentInstanceConfigs"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/agentinstanceconfigs"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAgentInstanceConfigsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// # ListAgentInstanceConfigs
//
// @param request - ListAgentInstanceConfigsRequest
//
// @return ListAgentInstanceConfigsResponse
func (client *Client) ListAgentInstanceConfigs(request *ListAgentInstanceConfigsRequest) (_result *ListAgentInstanceConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListAgentInstanceConfigsResponse{}
	_body, _err := client.ListAgentInstanceConfigsWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a list of alert rules in a project.
//
// @param request - ListAlertsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListAlertsResponse
func (client *Client) ListAlertsWithOptions(project *string, request *ListAlertsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListAlertsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Logstore)) {
		query["logstore"] = request.Logstore
	}

	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAlerts"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/alerts"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAlertsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a list of alert rules in a project.
//
// @param request - ListAlertsRequest
//
// @return ListAlertsResponse
func (client *Client) ListAlerts(project *string, request *ListAlertsRequest) (_result *ListAlertsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListAlertsResponse{}
	_body, _err := client.ListAlertsWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries data in datasets.
//
// @param request - ListAnnotationDataRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListAnnotationDataResponse
func (client *Client) ListAnnotationDataWithOptions(datasetId *string, request *ListAnnotationDataRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListAnnotationDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAnnotationData"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ml/annotationdataset/" + tea.StringValue(datasetId) + "/annotationdata"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAnnotationDataResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries data in datasets.
//
// @param request - ListAnnotationDataRequest
//
// @return ListAnnotationDataResponse
func (client *Client) ListAnnotationData(datasetId *string, request *ListAnnotationDataRequest) (_result *ListAnnotationDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListAnnotationDataResponse{}
	_body, _err := client.ListAnnotationDataWithOptions(datasetId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a list of datasets.
//
// @param request - ListAnnotationDataSetsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListAnnotationDataSetsResponse
func (client *Client) ListAnnotationDataSetsWithOptions(request *ListAnnotationDataSetsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListAnnotationDataSetsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAnnotationDataSets"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ml/annotationdataset"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAnnotationDataSetsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a list of datasets.
//
// @param request - ListAnnotationDataSetsRequest
//
// @return ListAnnotationDataSetsResponse
func (client *Client) ListAnnotationDataSets(request *ListAnnotationDataSetsRequest) (_result *ListAnnotationDataSetsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListAnnotationDataSetsResponse{}
	_body, _err := client.ListAnnotationDataSetsWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a list of tag tables.
//
// @param request - ListAnnotationLabelsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListAnnotationLabelsResponse
func (client *Client) ListAnnotationLabelsWithOptions(request *ListAnnotationLabelsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListAnnotationLabelsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAnnotationLabels"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ml/annotationlabel"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAnnotationLabelsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a list of tag tables.
//
// @param request - ListAnnotationLabelsRequest
//
// @return ListAnnotationLabelsResponse
func (client *Client) ListAnnotationLabels(request *ListAnnotationLabelsRequest) (_result *ListAnnotationLabelsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListAnnotationLabelsResponse{}
	_body, _err := client.ListAnnotationLabelsWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a list of log collection policies for cloud services.
//
// Description:
//
// You must use the Simple Log Service endpoint for the China (Shanghai), Singapore, or Heyuan ACDR Auto region to call the operation.
//
// @param request - ListCollectionPoliciesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListCollectionPoliciesResponse
func (client *Client) ListCollectionPoliciesWithOptions(request *ListCollectionPoliciesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListCollectionPoliciesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CentralProject)) {
		query["centralProject"] = request.CentralProject
	}

	if !tea.BoolValue(util.IsUnset(request.DataCode)) {
		query["dataCode"] = request.DataCode
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["instanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyName)) {
		query["policyName"] = request.PolicyName
	}

	if !tea.BoolValue(util.IsUnset(request.ProductCode)) {
		query["productCode"] = request.ProductCode
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListCollectionPolicies"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/collectionpolicy"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListCollectionPoliciesResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a list of log collection policies for cloud services.
//
// Description:
//
// You must use the Simple Log Service endpoint for the China (Shanghai), Singapore, or Heyuan ACDR Auto region to call the operation.
//
// @param request - ListCollectionPoliciesRequest
//
// @return ListCollectionPoliciesResponse
func (client *Client) ListCollectionPolicies(request *ListCollectionPoliciesRequest) (_result *ListCollectionPoliciesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListCollectionPoliciesResponse{}
	_body, _err := client.ListCollectionPoliciesWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries all Logtail configurations in a project.
//
// Description:
//
// ### [](#)Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
// @param request - ListConfigRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListConfigResponse
func (client *Client) ListConfigWithOptions(project *string, request *ListConfigRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigName)) {
		query["configName"] = request.ConfigName
	}

	if !tea.BoolValue(util.IsUnset(request.LogstoreName)) {
		query["logstoreName"] = request.LogstoreName
	}

	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListConfig"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/configs"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListConfigResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries all Logtail configurations in a project.
//
// Description:
//
// ### [](#)Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
// @param request - ListConfigRequest
//
// @return ListConfigResponse
func (client *Client) ListConfig(project *string, request *ListConfigRequest) (_result *ListConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListConfigResponse{}
	_body, _err := client.ListConfigWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries all consumer groups of a Logstore.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:ListConsumerGroup`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#LogstoreName}/consumergroup/*`|
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListConsumerGroupResponse
func (client *Client) ListConsumerGroupWithOptions(project *string, logstore *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListConsumerGroupResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("ListConsumerGroup"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "/consumergroups"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("array"),
	}
	_result = &ListConsumerGroupResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries all consumer groups of a Logstore.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:ListConsumerGroup`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#LogstoreName}/consumergroup/*`|
//
// @return ListConsumerGroupResponse
func (client *Client) ListConsumerGroup(project *string, logstore *string) (_result *ListConsumerGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListConsumerGroupResponse{}
	_body, _err := client.ListConsumerGroupWithOptions(project, logstore, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a list of dashboards.
//
// Description:
//
// ### [](#)Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
// @param request - ListDashboardRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListDashboardResponse
func (client *Client) ListDashboardWithOptions(project *string, request *ListDashboardRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListDashboardResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDashboard"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/dashboards"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDashboardResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a list of dashboards.
//
// Description:
//
// ### [](#)Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
// @param request - ListDashboardRequest
//
// @return ListDashboardResponse
func (client *Client) ListDashboard(project *string, request *ListDashboardRequest) (_result *ListDashboardResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListDashboardResponse{}
	_body, _err := client.ListDashboardWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the custom domain names that are bound to projects.
//
// Description:
//
//	  Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//		- Only one custom domain name can be bound to each project.
//
// @param request - ListDomainsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListDomainsResponse
func (client *Client) ListDomainsWithOptions(project *string, request *ListDomainsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["domainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDomains"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/domains"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDomainsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the custom domain names that are bound to projects.
//
// Description:
//
//	  Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//		- Only one custom domain name can be bound to each project.
//
// @param request - ListDomainsRequest
//
// @return ListDomainsResponse
func (client *Client) ListDomains(project *string, request *ListDomainsRequest) (_result *ListDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListDomainsResponse{}
	_body, _err := client.ListDomainsWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 列举下载任务
//
// @param request - ListDownloadJobsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListDownloadJobsResponse
func (client *Client) ListDownloadJobsWithOptions(project *string, request *ListDownloadJobsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListDownloadJobsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Logstore)) {
		query["logstore"] = request.Logstore
	}

	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDownloadJobs"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/downloadjobs"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDownloadJobsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 列举下载任务
//
// @param request - ListDownloadJobsRequest
//
// @return ListDownloadJobsResponse
func (client *Client) ListDownloadJobs(project *string, request *ListDownloadJobsRequest) (_result *ListDownloadJobsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListDownloadJobsResponse{}
	_body, _err := client.ListDownloadJobsWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 列出数据加工任务
//
// @param request - ListETLsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListETLsResponse
func (client *Client) ListETLsWithOptions(project *string, request *ListETLsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListETLsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Logstore)) {
		query["logstore"] = request.Logstore
	}

	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListETLs"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/etls"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListETLsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 列出数据加工任务
//
// @param request - ListETLsRequest
//
// @return ListETLsResponse
func (client *Client) ListETLs(project *string, request *ListETLsRequest) (_result *ListETLsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListETLsResponse{}
	_body, _err := client.ListETLsWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a list of ingest processors that meet specific conditions.
//
// @param request - ListIngestProcessorsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListIngestProcessorsResponse
func (client *Client) ListIngestProcessorsWithOptions(project *string, request *ListIngestProcessorsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListIngestProcessorsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DisplayName)) {
		query["displayName"] = request.DisplayName
	}

	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.ProcessorName)) {
		query["processorName"] = request.ProcessorName
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListIngestProcessors"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ingestprocessors"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListIngestProcessorsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a list of ingest processors that meet specific conditions.
//
// @param request - ListIngestProcessorsRequest
//
// @return ListIngestProcessorsResponse
func (client *Client) ListIngestProcessors(project *string, request *ListIngestProcessorsRequest) (_result *ListIngestProcessorsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListIngestProcessorsResponse{}
	_body, _err := client.ListIngestProcessorsWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries all Logstores or Logstores that match specific conditions in a project.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:ListLogStores`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/*`|
//
// @param request - ListLogStoresRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListLogStoresResponse
func (client *Client) ListLogStoresWithOptions(project *string, request *ListLogStoresRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListLogStoresResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LogstoreName)) {
		query["logstoreName"] = request.LogstoreName
	}

	if !tea.BoolValue(util.IsUnset(request.Mode)) {
		query["mode"] = request.Mode
	}

	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	if !tea.BoolValue(util.IsUnset(request.TelemetryType)) {
		query["telemetryType"] = request.TelemetryType
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListLogStores"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListLogStoresResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries all Logstores or Logstores that match specific conditions in a project.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:ListLogStores`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/*`|
//
// @param request - ListLogStoresRequest
//
// @return ListLogStoresResponse
func (client *Client) ListLogStores(project *string, request *ListLogStoresRequest) (_result *ListLogStoresResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListLogStoresResponse{}
	_body, _err := client.ListLogStoresWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a list of Logtail pipeline configurations that meet the specified conditions.
//
// Description:
//
// The UK (London) region is supported. Supported regions are constantly updated.
//
// @param request - ListLogtailPipelineConfigRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListLogtailPipelineConfigResponse
func (client *Client) ListLogtailPipelineConfigWithOptions(project *string, request *ListLogtailPipelineConfigRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListLogtailPipelineConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigName)) {
		query["configName"] = request.ConfigName
	}

	if !tea.BoolValue(util.IsUnset(request.LogstoreName)) {
		query["logstoreName"] = request.LogstoreName
	}

	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListLogtailPipelineConfig"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pipelineconfigs"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListLogtailPipelineConfigResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a list of Logtail pipeline configurations that meet the specified conditions.
//
// Description:
//
// The UK (London) region is supported. Supported regions are constantly updated.
//
// @param request - ListLogtailPipelineConfigRequest
//
// @return ListLogtailPipelineConfigResponse
func (client *Client) ListLogtailPipelineConfig(project *string, request *ListLogtailPipelineConfigRequest) (_result *ListLogtailPipelineConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListLogtailPipelineConfigResponse{}
	_body, _err := client.ListLogtailPipelineConfigWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the machine groups of a project.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - ListMachineGroupRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListMachineGroupResponse
func (client *Client) ListMachineGroupWithOptions(project *string, request *ListMachineGroupRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListMachineGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["groupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListMachineGroup"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/machinegroups"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListMachineGroupResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the machine groups of a project.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - ListMachineGroupRequest
//
// @return ListMachineGroupResponse
func (client *Client) ListMachineGroup(project *string, request *ListMachineGroupRequest) (_result *ListMachineGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListMachineGroupResponse{}
	_body, _err := client.ListMachineGroupWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a list of machines that are connected to Simple Log Service in a specified machine group.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - ListMachinesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListMachinesResponse
func (client *Client) ListMachinesWithOptions(project *string, machineGroup *string, request *ListMachinesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListMachinesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListMachines"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/machinegroups/" + tea.StringValue(machineGroup) + "/machines"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListMachinesResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a list of machines that are connected to Simple Log Service in a specified machine group.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - ListMachinesRequest
//
// @return ListMachinesResponse
func (client *Client) ListMachines(project *string, machineGroup *string, request *ListMachinesRequest) (_result *ListMachinesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListMachinesResponse{}
	_body, _err := client.ListMachinesWithOptions(project, machineGroup, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the list of Metricstores in a project. You can use fuzzy search to query the Metricstores by Metricstore name.
//
// Description:
//
//	  Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//		- An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query metric data is obtained. The information includes the name of the project to which the metric data belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
// @param request - ListMetricStoresRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListMetricStoresResponse
func (client *Client) ListMetricStoresWithOptions(project *string, request *ListMetricStoresRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListMetricStoresResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Mode)) {
		query["mode"] = request.Mode
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListMetricStores"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/metricstores"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("none"),
		BodyType:    tea.String("json"),
	}
	_result = &ListMetricStoresResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the list of Metricstores in a project. You can use fuzzy search to query the Metricstores by Metricstore name.
//
// Description:
//
//	  Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//		- An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query metric data is obtained. The information includes the name of the project to which the metric data belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
// @param request - ListMetricStoresRequest
//
// @return ListMetricStoresResponse
func (client *Client) ListMetricStores(project *string, request *ListMetricStoresRequest) (_result *ListMetricStoresResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListMetricStoresResponse{}
	_body, _err := client.ListMetricStoresWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 列出OSS投递任务
//
// @param request - ListOSSExportsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListOSSExportsResponse
func (client *Client) ListOSSExportsWithOptions(project *string, request *ListOSSExportsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListOSSExportsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Logstore)) {
		query["logstore"] = request.Logstore
	}

	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListOSSExports"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ossexports"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListOSSExportsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 列出OSS投递任务
//
// @param request - ListOSSExportsRequest
//
// @return ListOSSExportsResponse
func (client *Client) ListOSSExports(project *string, request *ListOSSExportsRequest) (_result *ListOSSExportsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListOSSExportsResponse{}
	_body, _err := client.ListOSSExportsWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 列举OSSHDFS投递任务
//
// @param request - ListOSSHDFSExportsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListOSSHDFSExportsResponse
func (client *Client) ListOSSHDFSExportsWithOptions(project *string, request *ListOSSHDFSExportsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListOSSHDFSExportsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Logstore)) {
		query["logstore"] = request.Logstore
	}

	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListOSSHDFSExports"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/osshdfsexports"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListOSSHDFSExportsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 列举OSSHDFS投递任务
//
// @param request - ListOSSHDFSExportsRequest
//
// @return ListOSSHDFSExportsResponse
func (client *Client) ListOSSHDFSExports(project *string, request *ListOSSHDFSExportsRequest) (_result *ListOSSHDFSExportsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListOSSHDFSExportsResponse{}
	_body, _err := client.ListOSSHDFSExportsWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a list of Object Storage Service (OSS) data import jobs in a project.
//
// @param request - ListOSSIngestionsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListOSSIngestionsResponse
func (client *Client) ListOSSIngestionsWithOptions(project *string, request *ListOSSIngestionsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListOSSIngestionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Logstore)) {
		query["logstore"] = request.Logstore
	}

	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListOSSIngestions"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ossingestions"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListOSSIngestionsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a list of Object Storage Service (OSS) data import jobs in a project.
//
// @param request - ListOSSIngestionsRequest
//
// @return ListOSSIngestionsResponse
func (client *Client) ListOSSIngestions(project *string, request *ListOSSIngestionsRequest) (_result *ListOSSIngestionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListOSSIngestionsResponse{}
	_body, _err := client.ListOSSIngestionsWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the projects that meet specified conditions.
//
// Description:
//
// ### [](#)Usage notes
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - ListProjectRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListProjectResponse
func (client *Client) ListProjectWithOptions(request *ListProjectRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListProjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FetchQuota)) {
		query["fetchQuota"] = request.FetchQuota
	}

	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		query["projectName"] = request.ProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["resourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListProject"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListProjectResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries the projects that meet specified conditions.
//
// Description:
//
// ### [](#)Usage notes
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - ListProjectRequest
//
// @return ListProjectResponse
func (client *Client) ListProject(request *ListProjectRequest) (_result *ListProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListProjectResponse{}
	_body, _err := client.ListProjectWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a list of saved searches.
//
// Description:
//
// ### Usage notes
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - ListSavedSearchRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListSavedSearchResponse
func (client *Client) ListSavedSearchWithOptions(project *string, request *ListSavedSearchRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListSavedSearchResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSavedSearch"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/savedsearches"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSavedSearchResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a list of saved searches.
//
// Description:
//
// ### Usage notes
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - ListSavedSearchRequest
//
// @return ListSavedSearchResponse
func (client *Client) ListSavedSearch(project *string, request *ListSavedSearchRequest) (_result *ListSavedSearchResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListSavedSearchResponse{}
	_body, _err := client.ListSavedSearchWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a list of Scheduled SQL jobs in a project.
//
// @param request - ListScheduledSQLsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListScheduledSQLsResponse
func (client *Client) ListScheduledSQLsWithOptions(project *string, request *ListScheduledSQLsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListScheduledSQLsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Logstore)) {
		query["logstore"] = request.Logstore
	}

	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListScheduledSQLs"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/scheduledsqls"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListScheduledSQLsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a list of Scheduled SQL jobs in a project.
//
// @param request - ListScheduledSQLsRequest
//
// @return ListScheduledSQLsResponse
func (client *Client) ListScheduledSQLs(project *string, request *ListScheduledSQLsRequest) (_result *ListScheduledSQLsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListScheduledSQLsResponse{}
	_body, _err := client.ListScheduledSQLsWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a list of shards in a Logstore.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListShardsResponse
func (client *Client) ListShardsWithOptions(project *string, logstore *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListShardsResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("ListShards"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "/shards"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("array"),
	}
	_result = &ListShardsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a list of shards in a Logstore.
//
// @return ListShardsResponse
func (client *Client) ListShards(project *string, logstore *string) (_result *ListShardsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListShardsResponse{}
	_body, _err := client.ListShardsWithOptions(project, logstore, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries datasets in a project.
//
// @param request - ListStoreViewsRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListStoreViewsResponse
func (client *Client) ListStoreViewsWithOptions(project *string, request *ListStoreViewsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListStoreViewsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Offset)) {
		query["offset"] = request.Offset
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	if !tea.BoolValue(util.IsUnset(request.StoreType)) {
		query["storeType"] = request.StoreType
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListStoreViews"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/storeviews"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListStoreViewsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries datasets in a project.
//
// @param request - ListStoreViewsRequest
//
// @return ListStoreViewsResponse
func (client *Client) ListStoreViews(project *string, request *ListStoreViewsRequest) (_result *ListStoreViewsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListStoreViewsResponse{}
	_body, _err := client.ListStoreViewsWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a list of tags for one or more resources. You can query tags for resources by resource type or filter resources by tag. Each tag is a key-value pair.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
//
//   - For more information, see [Authorization rules](https://help.aliyun.com/document_detail/29049.html). The following types of resources are supported: project, Logstore, dashboard, machine group, and Logtail configuration.
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:ListTagResources`|The resource format varies based on the resource type.\\-`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logstore/${logstoreName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/dashboard/${dashboardName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/machinegroup/${machineGroupName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logtailconfig/${logtailConfigName}`|
//
// @param tmpReq - ListTagResourcesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListTagResourcesResponse
func (client *Client) ListTagResourcesWithOptions(tmpReq *ListTagResourcesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListTagResourcesResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ListTagResourcesShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.ResourceId)) {
		request.ResourceIdShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ResourceId, tea.String("resourceId"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.Tags)) {
		request.TagsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Tags, tea.String("tags"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceIdShrink)) {
		query["resourceId"] = request.ResourceIdShrink
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["resourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TagsShrink)) {
		query["tags"] = request.TagsShrink
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTagResources"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/tags"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries a list of tags for one or more resources. You can query tags for resources by resource type or filter resources by tag. Each tag is a key-value pair.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
//
//   - For more information, see [Authorization rules](https://help.aliyun.com/document_detail/29049.html). The following types of resources are supported: project, Logstore, dashboard, machine group, and Logtail configuration.
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:ListTagResources`|The resource format varies based on the resource type.\\-`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logstore/${logstoreName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/dashboard/${dashboardName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/machinegroup/${machineGroupName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logtailconfig/${logtailConfigName}`|
//
// @param request - ListTagResourcesRequest
//
// @return ListTagResourcesResponse
func (client *Client) ListTagResources(request *ListTagResourcesRequest) (_result *ListTagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListTagResourcesResponse{}
	_body, _err := client.ListTagResourcesWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 合并两个相邻的readwrite状态的Shards。在参数中指定一个shardID，服务端自动找相邻的下一个Shard进行合并。
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return MergeShardResponse
func (client *Client) MergeShardWithOptions(project *string, logstore *string, shard *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *MergeShardResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("MergeShard"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "/shards/" + tea.StringValue(shard) + "?action=merge"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("array"),
	}
	_result = &MergeShardResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 合并两个相邻的readwrite状态的Shards。在参数中指定一个shardID，服务端自动找相邻的下一个Shard进行合并。
//
// @return MergeShardResponse
func (client *Client) MergeShard(project *string, logstore *string, shard *string) (_result *MergeShardResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &MergeShardResponse{}
	_body, _err := client.MergeShardWithOptions(project, logstore, shard, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Activates Simple Log Service. You must use the endpoint for Simple Log Service only in the China (Shanghai) or Singapore region.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return OpenSlsServiceResponse
func (client *Client) OpenSlsServiceWithOptions(headers map[string]*string, runtime *util.RuntimeOptions) (_result *OpenSlsServiceResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("OpenSlsService"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/slsservice"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &OpenSlsServiceResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Activates Simple Log Service. You must use the endpoint for Simple Log Service only in the China (Shanghai) or Singapore region.
//
// @return OpenSlsServiceResponse
func (client *Client) OpenSlsService() (_result *OpenSlsServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &OpenSlsServiceResponse{}
	_body, _err := client.OpenSlsServiceWithOptions(headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries logs based on the specified cursors. You can call this operation to obtain raw logs. To query and analyze logs, you can call the GetLogsV2 operation.
//
// Description:
//
// *
//
// **Warning*	- You cannot call this operation in OpenAPI Explorer. You can use Simple Log Service SDK to call this operation. For more information, see SLS SDK Reference.
//
//   - You must specify a shard when you query the logs.
//
//   - You can query only logs in the Protocol Buffers (protobuf) format. For more information, see [Data encoding](https://help.aliyun.com/document_detail/29055.html).
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - PullLogsRequest
//
// @param headers - PullLogsHeaders
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return PullLogsResponse
func (client *Client) PullLogsWithOptions(project *string, logStore *string, shardId *string, request *PullLogsRequest, headers *PullLogsHeaders, runtime *util.RuntimeOptions) (_result *PullLogsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Count)) {
		query["count"] = request.Count
	}

	if !tea.BoolValue(util.IsUnset(request.Cursor)) {
		query["cursor"] = request.Cursor
	}

	if !tea.BoolValue(util.IsUnset(request.EndCursor)) {
		query["end_cursor"] = request.EndCursor
	}

	if !tea.BoolValue(util.IsUnset(request.Query)) {
		query["query"] = request.Query
	}

	realHeaders := make(map[string]*string)
	if !tea.BoolValue(util.IsUnset(headers.CommonHeaders)) {
		realHeaders = headers.CommonHeaders
	}

	if !tea.BoolValue(util.IsUnset(headers.AcceptEncoding)) {
		realHeaders["Accept-Encoding"] = util.ToJSONString(headers.AcceptEncoding)
	}

	req := &openapi.OpenApiRequest{
		Headers: realHeaders,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PullLogs"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logStore) + "/shards/" + tea.StringValue(shardId) + "?type=log"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("none"),
		BodyType:    tea.String("json"),
	}
	_result = &PullLogsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Queries logs based on the specified cursors. You can call this operation to obtain raw logs. To query and analyze logs, you can call the GetLogsV2 operation.
//
// Description:
//
// *
//
// **Warning*	- You cannot call this operation in OpenAPI Explorer. You can use Simple Log Service SDK to call this operation. For more information, see SLS SDK Reference.
//
//   - You must specify a shard when you query the logs.
//
//   - You can query only logs in the Protocol Buffers (protobuf) format. For more information, see [Data encoding](https://help.aliyun.com/document_detail/29055.html).
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - PullLogsRequest
//
// @return PullLogsResponse
func (client *Client) PullLogs(project *string, logStore *string, shardId *string, request *PullLogsRequest) (_result *PullLogsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := &PullLogsHeaders{}
	_result = &PullLogsResponse{}
	_body, _err := client.PullLogsWithOptions(project, logStore, shardId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Adds data to a dataset for storage.
//
// @param request - PutAnnotationDataRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return PutAnnotationDataResponse
func (client *Client) PutAnnotationDataWithOptions(datasetId *string, request *PutAnnotationDataRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *PutAnnotationDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AnnotationdataId)) {
		query["annotationdataId"] = request.AnnotationdataId
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MlDataParam)) {
		body["mlDataParam"] = request.MlDataParam
	}

	if !tea.BoolValue(util.IsUnset(request.RawLog)) {
		body["rawLog"] = request.RawLog
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("PutAnnotationData"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ml/annotationdataset/" + tea.StringValue(datasetId) + "/annotationdata"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &PutAnnotationDataResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Adds data to a dataset for storage.
//
// @param request - PutAnnotationDataRequest
//
// @return PutAnnotationDataResponse
func (client *Client) PutAnnotationData(datasetId *string, request *PutAnnotationDataRequest) (_result *PutAnnotationDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &PutAnnotationDataResponse{}
	_body, _err := client.PutAnnotationDataWithOptions(datasetId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates or modifies an ingest processor.
//
// @param request - PutIngestProcessorRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return PutIngestProcessorResponse
func (client *Client) PutIngestProcessorWithOptions(project *string, processorName *string, request *PutIngestProcessorRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *PutIngestProcessorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Configuration)) {
		body["configuration"] = request.Configuration
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DisplayName)) {
		body["displayName"] = request.DisplayName
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("PutIngestProcessor"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ingestprocessors/" + tea.StringValue(processorName)),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &PutIngestProcessorResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates or modifies an ingest processor.
//
// @param request - PutIngestProcessorRequest
//
// @return PutIngestProcessorResponse
func (client *Client) PutIngestProcessor(project *string, processorName *string, request *PutIngestProcessorRequest) (_result *PutIngestProcessorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &PutIngestProcessorResponse{}
	_body, _err := client.PutIngestProcessorWithOptions(project, processorName, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Writes logs to a Logstore.
//
// Description:
//
// *
//
// **Warning*	- You cannot call this operation in OpenAPI Explorer. You can use Simple Log Service SDK to call this operation. For more information, see SLS SDK Reference.
//
//   - When you call the PutLogs operation to write logs to Simple Log Service, Simple Log Servicechecks the format of the logs. If a log does not meet the format requirements, the request fails and no logs are written to Simple Log Service.
//
//   - You can write logs only in the Protocol Buffers (Protobuf) format as log groups. For more information, see [Data encoding](https://help.aliyun.com/document_detail/29055.html).
//
//   - You can write logs in one of the following modes:
//
//   - LoadBalance mode: In this mode, Log Service automatically writes logs to all writable shards in a Logstore. This mode delivers high availability for write operations and is suitable for data consumption scenarios in which you do not need to preserve the order of logs.
//
//   - KeyHash: In this mode, a key field is added in the URL parameter. Log Service writes logs to a shard based on the key field. The hash key is optional. If you do not configure the hash key, logs are written to shards in LoadBalance mode. For example, you can use the KeyHash mode to write data from a producer, such as an instance, to the shard whose hash value range includes the hash value of the producer name. This ensures that the data that is written to the shard is ordered and the data in the shard is consumed based on the order. This way, when a shard is split or when shards are merged, the data that is associated with the same hash key is stored only in one shard at a point in time. For more information, see [Shard](https://help.aliyun.com/document_detail/28976.html).
//
//   - You can call the PutLogs operation to write up to 10 MB of raw logs at a time. We recommend that you keep the total size of the values for each log in a log group to or below 1 MB. Historical versions of SDKs may have different limits. We recommend that you upgrade your SDK to the latest version.
//
//   - The references for Log Service SDK for Java and Log Service SDK for Python provide examples on how to call the PutLogs operation. For more information, see [Get started with Simple Log Service SDK for Java](https://help.aliyun.com/document_detail/279525.html) and [Get started with Simple Log Service SDK for Python](https://help.aliyun.com/document_detail/284638.html).
//
// @param request - PutLogsRequest
//
// @param headers - PutLogsHeaders
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return PutLogsResponse
func (client *Client) PutLogsWithOptions(project *string, logstore *string, request *PutLogsRequest, headers *PutLogsHeaders, runtime *util.RuntimeOptions) (_result *PutLogsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	realHeaders := make(map[string]*string)
	if !tea.BoolValue(util.IsUnset(headers.CommonHeaders)) {
		realHeaders = headers.CommonHeaders
	}

	if !tea.BoolValue(util.IsUnset(headers.XLogCompresstype)) {
		realHeaders["x-log-compresstype"] = util.ToJSONString(headers.XLogCompresstype)
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: realHeaders,
		Body:    openapiutil.ParseToMap(request.Body),
	}
	params := &openapi.Params{
		Action:      tea.String("PutLogs"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "/shards/lb"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("protobuf"),
		BodyType:    tea.String("none"),
	}
	_result = &PutLogsResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Writes logs to a Logstore.
//
// Description:
//
// *
//
// **Warning*	- You cannot call this operation in OpenAPI Explorer. You can use Simple Log Service SDK to call this operation. For more information, see SLS SDK Reference.
//
//   - When you call the PutLogs operation to write logs to Simple Log Service, Simple Log Servicechecks the format of the logs. If a log does not meet the format requirements, the request fails and no logs are written to Simple Log Service.
//
//   - You can write logs only in the Protocol Buffers (Protobuf) format as log groups. For more information, see [Data encoding](https://help.aliyun.com/document_detail/29055.html).
//
//   - You can write logs in one of the following modes:
//
//   - LoadBalance mode: In this mode, Log Service automatically writes logs to all writable shards in a Logstore. This mode delivers high availability for write operations and is suitable for data consumption scenarios in which you do not need to preserve the order of logs.
//
//   - KeyHash: In this mode, a key field is added in the URL parameter. Log Service writes logs to a shard based on the key field. The hash key is optional. If you do not configure the hash key, logs are written to shards in LoadBalance mode. For example, you can use the KeyHash mode to write data from a producer, such as an instance, to the shard whose hash value range includes the hash value of the producer name. This ensures that the data that is written to the shard is ordered and the data in the shard is consumed based on the order. This way, when a shard is split or when shards are merged, the data that is associated with the same hash key is stored only in one shard at a point in time. For more information, see [Shard](https://help.aliyun.com/document_detail/28976.html).
//
//   - You can call the PutLogs operation to write up to 10 MB of raw logs at a time. We recommend that you keep the total size of the values for each log in a log group to or below 1 MB. Historical versions of SDKs may have different limits. We recommend that you upgrade your SDK to the latest version.
//
//   - The references for Log Service SDK for Java and Log Service SDK for Python provide examples on how to call the PutLogs operation. For more information, see [Get started with Simple Log Service SDK for Java](https://help.aliyun.com/document_detail/279525.html) and [Get started with Simple Log Service SDK for Python](https://help.aliyun.com/document_detail/284638.html).
//
// @param request - PutLogsRequest
//
// @return PutLogsResponse
func (client *Client) PutLogs(project *string, logstore *string, request *PutLogsRequest) (_result *PutLogsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := &PutLogsHeaders{}
	_result = &PutLogsResponse{}
	_body, _err := client.PutLogsWithOptions(project, logstore, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a project policy.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - Alibaba Cloud Simple Log Service allows you to configure a project policy to authorize other users to access the specified Log Service resources.
//
//   - You must configure a project policy based on policy syntax. Before you configure a project policy, you must be familiar with the Action, Resource, and Condition parameters. For more information, see [RAM](https://help.aliyun.com/document_detail/128139.html).
//
//   - If you set the Principal element to an asterisk (\\*) and do not configure the Condition element when you configure a project policy, the policy applies to all users except for the project owner. If you set the Principal element to an asterisk (\\*) and configure the Condition element when you configure a project policy, the policy applies to all users including the project owner.
//
//   - You can configure multiple project policies for a project. The total size of the policies cannot exceed 16 KB.
//
// @param request - PutProjectPolicyRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return PutProjectPolicyResponse
func (client *Client) PutProjectPolicyWithOptions(project *string, request *PutProjectPolicyRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *PutProjectPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("PutProjectPolicy"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/policy"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &PutProjectPolicyResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates a project policy.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - Alibaba Cloud Simple Log Service allows you to configure a project policy to authorize other users to access the specified Log Service resources.
//
//   - You must configure a project policy based on policy syntax. Before you configure a project policy, you must be familiar with the Action, Resource, and Condition parameters. For more information, see [RAM](https://help.aliyun.com/document_detail/128139.html).
//
//   - If you set the Principal element to an asterisk (\\*) and do not configure the Condition element when you configure a project policy, the policy applies to all users except for the project owner. If you set the Principal element to an asterisk (\\*) and configure the Condition element when you configure a project policy, the policy applies to all users including the project owner.
//
//   - You can configure multiple project policies for a project. The total size of the policies cannot exceed 16 KB.
//
// @param request - PutProjectPolicyRequest
//
// @return PutProjectPolicyResponse
func (client *Client) PutProjectPolicy(project *string, request *PutProjectPolicyRequest) (_result *PutProjectPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &PutProjectPolicyResponse{}
	_body, _err := client.PutProjectPolicyWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 设置project传输加速状态
//
// @param request - PutProjectTransferAccelerationRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return PutProjectTransferAccelerationResponse
func (client *Client) PutProjectTransferAccelerationWithOptions(project *string, request *PutProjectTransferAccelerationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *PutProjectTransferAccelerationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Enabled)) {
		body["enabled"] = request.Enabled
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("PutProjectTransferAcceleration"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/transferacceleration"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &PutProjectTransferAccelerationResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 设置project传输加速状态
//
// @param request - PutProjectTransferAccelerationRequest
//
// @return PutProjectTransferAccelerationResponse
func (client *Client) PutProjectTransferAcceleration(project *string, request *PutProjectTransferAccelerationRequest) (_result *PutProjectTransferAccelerationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &PutProjectTransferAccelerationResponse{}
	_body, _err := client.PutProjectTransferAccelerationWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Sends multiple logs to Simple Log Service in one request.
//
// Description:
//
// ### [](#)Usage notes
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
//   - You can call this operation to collect logs from web pages or clients.
//
//   - If you use web tracking to collect logs and you do not call this operation, you can send only one log to Simple Log Service in a request. For more information, see [Use web tracking to collect logs](https://help.aliyun.com/document_detail/31752.html).
//
//   - If you want to collect a large amount of log data, you can call this operation to send multiple logs to Simple Log Service in one request.
//
//   - Before you can call this operation to send logs to a Logstore, you must enable web tracking for the Logstore. For more information, see [Use web tracking to collect logs](https://help.aliyun.com/document_detail/31752.html).
//
//   - You cannot call this operation to send the logs of multiple topics to Simple Log Service at a time.
//
//   - If you call this operation, anonymous users from the Internet are granted the write permissions on the Logstore. This may generate dirty data because AccessKey pair-based authentication is not performed.
//
// @param request - PutWebtrackingRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return PutWebtrackingResponse
func (client *Client) PutWebtrackingWithOptions(project *string, logstoreName *string, request *PutWebtrackingRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *PutWebtrackingResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Logs)) {
		body["__logs__"] = request.Logs
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		body["__source__"] = request.Source
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		body["__tags__"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.Topic)) {
		body["__topic__"] = request.Topic
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("PutWebtracking"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstoreName) + "/track"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("Anonymous"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &PutWebtrackingResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Sends multiple logs to Simple Log Service in one request.
//
// Description:
//
// ### [](#)Usage notes
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
//   - You can call this operation to collect logs from web pages or clients.
//
//   - If you use web tracking to collect logs and you do not call this operation, you can send only one log to Simple Log Service in a request. For more information, see [Use web tracking to collect logs](https://help.aliyun.com/document_detail/31752.html).
//
//   - If you want to collect a large amount of log data, you can call this operation to send multiple logs to Simple Log Service in one request.
//
//   - Before you can call this operation to send logs to a Logstore, you must enable web tracking for the Logstore. For more information, see [Use web tracking to collect logs](https://help.aliyun.com/document_detail/31752.html).
//
//   - You cannot call this operation to send the logs of multiple topics to Simple Log Service at a time.
//
//   - If you call this operation, anonymous users from the Internet are granted the write permissions on the Logstore. This may generate dirty data because AccessKey pair-based authentication is not performed.
//
// @param request - PutWebtrackingRequest
//
// @return PutWebtrackingResponse
func (client *Client) PutWebtracking(project *string, logstoreName *string, request *PutWebtrackingRequest) (_result *PutWebtrackingResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &PutWebtrackingResponse{}
	_body, _err := client.PutWebtrackingWithOptions(project, logstoreName, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 刷新token
//
// @param request - RefreshTokenRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RefreshTokenResponse
func (client *Client) RefreshTokenWithOptions(request *RefreshTokenRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *RefreshTokenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccessTokenExpirationTime)) {
		query["accessTokenExpirationTime"] = request.AccessTokenExpirationTime
	}

	if !tea.BoolValue(util.IsUnset(request.Ticket)) {
		query["ticket"] = request.Ticket
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RefreshToken"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/token/refresh"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &RefreshTokenResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 刷新token
//
// @param request - RefreshTokenRequest
//
// @return RefreshTokenResponse
func (client *Client) RefreshToken(request *RefreshTokenRequest) (_result *RefreshTokenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &RefreshTokenResponse{}
	_body, _err := client.RefreshTokenWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Removes a Logtail configuration from a machine group.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RemoveConfigFromMachineGroupResponse
func (client *Client) RemoveConfigFromMachineGroupWithOptions(project *string, machineGroup *string, configName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *RemoveConfigFromMachineGroupResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveConfigFromMachineGroup"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/machinegroups/" + tea.StringValue(machineGroup) + "/configs/" + tea.StringValue(configName)),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &RemoveConfigFromMachineGroupResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Removes a Logtail configuration from a machine group.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @return RemoveConfigFromMachineGroupResponse
func (client *Client) RemoveConfigFromMachineGroup(project *string, machineGroup *string, configName *string) (_result *RemoveConfigFromMachineGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &RemoveConfigFromMachineGroupResponse{}
	_body, _err := client.RemoveConfigFromMachineGroupWithOptions(project, machineGroup, configName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Splits a shard in the readwrite state.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - Each shard has an MD5 hash range, and each range is a left-closed, right-open interval. The interval is in the `[BeginKey,EndKey)` format. A shard can be in the readwrite or readonly state. You can split a shard and merge shards. For more information, see [Shard](https://help.aliyun.com/document_detail/28976.html).
//
// @param request - SplitShardRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SplitShardResponse
func (client *Client) SplitShardWithOptions(project *string, logstore *string, shard *string, request *SplitShardRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *SplitShardResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Key)) {
		query["key"] = request.Key
	}

	if !tea.BoolValue(util.IsUnset(request.ShardCount)) {
		query["shardCount"] = request.ShardCount
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SplitShard"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "/shards/" + tea.StringValue(shard) + "?action=split"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("array"),
	}
	_result = &SplitShardResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Splits a shard in the readwrite state.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - Each shard has an MD5 hash range, and each range is a left-closed, right-open interval. The interval is in the `[BeginKey,EndKey)` format. A shard can be in the readwrite or readonly state. You can split a shard and merge shards. For more information, see [Shard](https://help.aliyun.com/document_detail/28976.html).
//
// @param request - SplitShardRequest
//
// @return SplitShardResponse
func (client *Client) SplitShard(project *string, logstore *string, shard *string, request *SplitShardRequest) (_result *SplitShardResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &SplitShardResponse{}
	_body, _err := client.SplitShardWithOptions(project, logstore, shard, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 启动数据加工任务
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return StartETLResponse
func (client *Client) StartETLWithOptions(project *string, etlName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *StartETLResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("StartETL"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/etls/" + tea.StringValue(etlName) + "?action=START"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &StartETLResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 启动数据加工任务
//
// @return StartETLResponse
func (client *Client) StartETL(project *string, etlName *string) (_result *StartETLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &StartETLResponse{}
	_body, _err := client.StartETLWithOptions(project, etlName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 启动OSS投递任务
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return StartOSSExportResponse
func (client *Client) StartOSSExportWithOptions(project *string, ossExportName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *StartOSSExportResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("StartOSSExport"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ossexports/" + tea.StringValue(ossExportName) + "?action=START"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &StartOSSExportResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 启动OSS投递任务
//
// @return StartOSSExportResponse
func (client *Client) StartOSSExport(project *string, ossExportName *string) (_result *StartOSSExportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &StartOSSExportResponse{}
	_body, _err := client.StartOSSExportWithOptions(project, ossExportName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 启动OSSHDFS投递任务
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return StartOSSHDFSExportResponse
func (client *Client) StartOSSHDFSExportWithOptions(project *string, ossExportName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *StartOSSHDFSExportResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("StartOSSHDFSExport"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/osshdfsexports/" + tea.StringValue(ossExportName) + "?action=START"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &StartOSSHDFSExportResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 启动OSSHDFS投递任务
//
// @return StartOSSHDFSExportResponse
func (client *Client) StartOSSHDFSExport(project *string, ossExportName *string) (_result *StartOSSHDFSExportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &StartOSSHDFSExportResponse{}
	_body, _err := client.StartOSSHDFSExportWithOptions(project, ossExportName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Starts an Object Storage Service (OSS) data import job.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return StartOSSIngestionResponse
func (client *Client) StartOSSIngestionWithOptions(project *string, ossIngestionName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *StartOSSIngestionResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("StartOSSIngestion"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ossingestions/" + tea.StringValue(ossIngestionName) + "?action=START"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &StartOSSIngestionResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Starts an Object Storage Service (OSS) data import job.
//
// @return StartOSSIngestionResponse
func (client *Client) StartOSSIngestion(project *string, ossIngestionName *string) (_result *StartOSSIngestionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &StartOSSIngestionResponse{}
	_body, _err := client.StartOSSIngestionWithOptions(project, ossIngestionName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 停止数据加工任务
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return StopETLResponse
func (client *Client) StopETLWithOptions(project *string, etlName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *StopETLResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("StopETL"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/etls/" + tea.StringValue(etlName) + "?action=STOP"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &StopETLResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 停止数据加工任务
//
// @return StopETLResponse
func (client *Client) StopETL(project *string, etlName *string) (_result *StopETLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &StopETLResponse{}
	_body, _err := client.StopETLWithOptions(project, etlName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 停止OSS投递任务
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return StopOSSExportResponse
func (client *Client) StopOSSExportWithOptions(project *string, ossExportName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *StopOSSExportResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("StopOSSExport"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ossexports/" + tea.StringValue(ossExportName) + "?action=STOP"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &StopOSSExportResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 停止OSS投递任务
//
// @return StopOSSExportResponse
func (client *Client) StopOSSExport(project *string, ossExportName *string) (_result *StopOSSExportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &StopOSSExportResponse{}
	_body, _err := client.StopOSSExportWithOptions(project, ossExportName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 停止OSSHDFS投递任务
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return StopOSSHDFSExportResponse
func (client *Client) StopOSSHDFSExportWithOptions(project *string, ossExportName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *StopOSSHDFSExportResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("StopOSSHDFSExport"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/osshdfsexports/" + tea.StringValue(ossExportName) + "?action=STOP"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &StopOSSHDFSExportResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 停止OSSHDFS投递任务
//
// @return StopOSSHDFSExportResponse
func (client *Client) StopOSSHDFSExport(project *string, ossExportName *string) (_result *StopOSSHDFSExportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &StopOSSHDFSExportResponse{}
	_body, _err := client.StopOSSHDFSExportWithOptions(project, ossExportName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Stops an Object Storage Service (OSS) data import job.
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return StopOSSIngestionResponse
func (client *Client) StopOSSIngestionWithOptions(project *string, ossIngestionName *string, headers map[string]*string, runtime *util.RuntimeOptions) (_result *StopOSSIngestionResponse, _err error) {
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("StopOSSIngestion"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ossingestions/" + tea.StringValue(ossIngestionName) + "?action=STOP"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &StopOSSIngestionResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Stops an Object Storage Service (OSS) data import job.
//
// @return StopOSSIngestionResponse
func (client *Client) StopOSSIngestion(project *string, ossIngestionName *string) (_result *StopOSSIngestionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &StopOSSIngestionResponse{}
	_body, _err := client.StopOSSIngestionWithOptions(project, ossIngestionName, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates and adds tags to a resource. You can add tags only to projects.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
//
//   - For more information, see [Authorization rules](https://help.aliyun.com/document_detail/29049.html). The following types of resources are supported: project, Logstore, dashboard, machine group, and Logtail configuration.
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:TagResources`|The resource format varies based on the resource type.\\-`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logstore/${logstoreName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/dashboard/${dashboardName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/machinegroup/${machineGroupName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logtailconfig/${logtailConfigName}`|
//
// @param request - TagResourcesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return TagResourcesResponse
func (client *Client) TagResourcesWithOptions(request *TagResourcesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *TagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		body["resourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		body["resourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		body["tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("TagResources"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/tag"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &TagResourcesResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Creates and adds tags to a resource. You can add tags only to projects.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html)
//
//   - For more information, see [Authorization rules](https://help.aliyun.com/document_detail/29049.html). The following types of resources are supported: project, Logstore, dashboard, machine group, and Logtail configuration.
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:TagResources`|The resource format varies based on the resource type.\\-`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logstore/${logstoreName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/dashboard/${dashboardName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/machinegroup/${machineGroupName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logtailconfig/${logtailConfigName}`|
//
// @param request - TagResourcesRequest
//
// @return TagResourcesResponse
func (client *Client) TagResources(request *TagResourcesRequest) (_result *TagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &TagResourcesResponse{}
	_body, _err := client.TagResourcesWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Detaches one or more tags from a resource. You can detach tags only from Simple Log Service projects. You can detach multiple or all tags from a Simple Log Service project at a time.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) For more information, see [Authorization rules](https://help.aliyun.com/document_detail/29049.html). The following types of resources are supported: project, Logstore, dashboard, machine group, and Logtail configuration.
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:UntagResources`|The resource format varies based on the resource type.\\-`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logstore/${logstoreName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/dashboard/${dashboardName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/machinegroup/${machineGroupName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logtailconfig/${logtailConfigName}`|
//
// @param request - UntagResourcesRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UntagResourcesResponse
func (client *Client) UntagResourcesWithOptions(request *UntagResourcesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UntagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.All)) {
		body["all"] = request.All
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		body["resourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		body["resourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		body["tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UntagResources"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/untag"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UntagResourcesResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Detaches one or more tags from a resource. You can detach tags only from Simple Log Service projects. You can detach multiple or all tags from a Simple Log Service project at a time.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) For more information, see [Authorization rules](https://help.aliyun.com/document_detail/29049.html). The following types of resources are supported: project, Logstore, dashboard, machine group, and Logtail configuration.
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:UntagResources`|The resource format varies based on the resource type.\\-`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logstore/${logstoreName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/dashboard/${dashboardName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/machinegroup/${machineGroupName}`\\-`acs:log:${regionName}:${accountId}:project/${projectName}/logtailconfig/${logtailConfigName}`|
//
// @param request - UntagResourcesRequest
//
// @return UntagResourcesResponse
func (client *Client) UntagResources(request *UntagResourcesRequest) (_result *UntagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UntagResourcesResponse{}
	_body, _err := client.UntagResourcesWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// # UpdateAgentInstanceConfig
//
// @param request - UpdateAgentInstanceConfigRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateAgentInstanceConfigResponse
func (client *Client) UpdateAgentInstanceConfigWithOptions(configName *string, request *UpdateAgentInstanceConfigRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateAgentInstanceConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Config)) {
		body["config"] = request.Config
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigMatcher)) {
		body["configMatcher"] = request.ConfigMatcher
	}

	if !tea.BoolValue(util.IsUnset(request.IsGray)) {
		body["isGray"] = request.IsGray
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAgentInstanceConfig"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/agentinstanceconfigs/" + tea.StringValue(configName)),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateAgentInstanceConfigResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// # UpdateAgentInstanceConfig
//
// @param request - UpdateAgentInstanceConfigRequest
//
// @return UpdateAgentInstanceConfigResponse
func (client *Client) UpdateAgentInstanceConfig(configName *string, request *UpdateAgentInstanceConfigRequest) (_result *UpdateAgentInstanceConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateAgentInstanceConfigResponse{}
	_body, _err := client.UpdateAgentInstanceConfigWithOptions(configName, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates an alert rule.
//
// @param request - UpdateAlertRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateAlertResponse
func (client *Client) UpdateAlertWithOptions(project *string, alertName *string, request *UpdateAlertRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateAlertResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Configuration)) {
		body["configuration"] = request.Configuration
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DisplayName)) {
		body["displayName"] = request.DisplayName
	}

	if !tea.BoolValue(util.IsUnset(request.Schedule)) {
		body["schedule"] = request.Schedule
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAlert"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/alerts/" + tea.StringValue(alertName)),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateAlertResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates an alert rule.
//
// @param request - UpdateAlertRequest
//
// @return UpdateAlertResponse
func (client *Client) UpdateAlert(project *string, alertName *string, request *UpdateAlertRequest) (_result *UpdateAlertResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateAlertResponse{}
	_body, _err := client.UpdateAlertWithOptions(project, alertName, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates a dataset.
//
// @param request - UpdateAnnotationDataSetRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateAnnotationDataSetResponse
func (client *Client) UpdateAnnotationDataSetWithOptions(datasetId *string, request *UpdateAnnotationDataSetRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateAnnotationDataSetResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(request.Body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAnnotationDataSet"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ml/annotationdataset/" + tea.StringValue(datasetId)),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateAnnotationDataSetResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates a dataset.
//
// @param request - UpdateAnnotationDataSetRequest
//
// @return UpdateAnnotationDataSetResponse
func (client *Client) UpdateAnnotationDataSet(datasetId *string, request *UpdateAnnotationDataSetRequest) (_result *UpdateAnnotationDataSetResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateAnnotationDataSetResponse{}
	_body, _err := client.UpdateAnnotationDataSetWithOptions(datasetId, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates a tag table.
//
// Description:
//
// You can update only the names of the tags in a tag set.
//
// @param request - UpdateAnnotationLabelRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateAnnotationLabelResponse
func (client *Client) UpdateAnnotationLabelWithOptions(request *UpdateAnnotationLabelRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateAnnotationLabelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(request.Body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAnnotationLabel"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ml/annotationlabel"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateAnnotationLabelResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates a tag table.
//
// Description:
//
// You can update only the names of the tags in a tag set.
//
// @param request - UpdateAnnotationLabelRequest
//
// @return UpdateAnnotationLabelResponse
func (client *Client) UpdateAnnotationLabel(request *UpdateAnnotationLabelRequest) (_result *UpdateAnnotationLabelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateAnnotationLabelResponse{}
	_body, _err := client.UpdateAnnotationLabelWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies a Logtail configuration.
//
// Description:
//
// ### [](#)Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - After you update a Logtail configuration that is applied to a machine group, the new configuration immediately takes effect.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
//   - The Logtail configuration is planned out. For more information, see [Logtail configurations](https://help.aliyun.com/document_detail/29058.html).
//
// @param request - UpdateConfigRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateConfigResponse
func (client *Client) UpdateConfigWithOptions(project *string, configName *string, request *UpdateConfigRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(request.Body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateConfig"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/configs/" + tea.StringValue(configName)),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateConfigResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies a Logtail configuration.
//
// Description:
//
// ### [](#)Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - After you update a Logtail configuration that is applied to a machine group, the new configuration immediately takes effect.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a RAM user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
//   - The Logtail configuration is planned out. For more information, see [Logtail configurations](https://help.aliyun.com/document_detail/29058.html).
//
// @param request - UpdateConfigRequest
//
// @return UpdateConfigResponse
func (client *Client) UpdateConfig(project *string, configName *string, request *UpdateConfigRequest) (_result *UpdateConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateConfigResponse{}
	_body, _err := client.UpdateConfigWithOptions(project, configName, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates the attributes of a consumer group.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:UpdateConsumerGroup`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#logstoreName}/consumergroup/{#ConsumerGroup}`|
//
// @param request - UpdateConsumerGroupRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateConsumerGroupResponse
func (client *Client) UpdateConsumerGroupWithOptions(project *string, logstore *string, consumerGroup *string, request *UpdateConsumerGroupRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateConsumerGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Order)) {
		body["order"] = request.Order
	}

	if !tea.BoolValue(util.IsUnset(request.Timeout)) {
		body["timeout"] = request.Timeout
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateConsumerGroup"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "/consumergroups/" + tea.StringValue(consumerGroup)),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateConsumerGroupResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates the attributes of a consumer group.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:UpdateConsumerGroup`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/logstore/{#logstoreName}/consumergroup/{#ConsumerGroup}`|
//
// @param request - UpdateConsumerGroupRequest
//
// @return UpdateConsumerGroupResponse
func (client *Client) UpdateConsumerGroup(project *string, logstore *string, consumerGroup *string, request *UpdateConsumerGroupRequest) (_result *UpdateConsumerGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateConsumerGroupResponse{}
	_body, _err := client.UpdateConsumerGroupWithOptions(project, logstore, consumerGroup, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates a dashboard.
//
// Description:
//
// ### [](#)Usage notes
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - UpdateDashboardRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateDashboardResponse
func (client *Client) UpdateDashboardWithOptions(project *string, dashboardName *string, request *UpdateDashboardRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateDashboardResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Attribute)) {
		body["attribute"] = request.Attribute
	}

	if !tea.BoolValue(util.IsUnset(request.Charts)) {
		body["charts"] = request.Charts
	}

	if !tea.BoolValue(util.IsUnset(request.DashboardName)) {
		body["dashboardName"] = request.DashboardName
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DisplayName)) {
		body["displayName"] = request.DisplayName
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDashboard"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/dashboards/" + tea.StringValue(dashboardName)),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateDashboardResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates a dashboard.
//
// Description:
//
// ### [](#)Usage notes
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - UpdateDashboardRequest
//
// @return UpdateDashboardResponse
func (client *Client) UpdateDashboard(project *string, dashboardName *string, request *UpdateDashboardRequest) (_result *UpdateDashboardResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateDashboardResponse{}
	_body, _err := client.UpdateDashboardWithOptions(project, dashboardName, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 更新数据加工任务
//
// @param request - UpdateETLRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateETLResponse
func (client *Client) UpdateETLWithOptions(project *string, etlName *string, request *UpdateETLRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateETLResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Configuration)) {
		body["configuration"] = request.Configuration
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DisplayName)) {
		body["displayName"] = request.DisplayName
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateETL"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/etls/" + tea.StringValue(etlName)),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateETLResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 更新数据加工任务
//
// @param request - UpdateETLRequest
//
// @return UpdateETLResponse
func (client *Client) UpdateETL(project *string, etlName *string, request *UpdateETLRequest) (_result *UpdateETLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateETLResponse{}
	_body, _err := client.UpdateETLWithOptions(project, etlName, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates the indexes of a Logstore.
//
// Description:
//
// ### Usage notes
//
// Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
//
// @param request - UpdateIndexRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateIndexResponse
func (client *Client) UpdateIndexWithOptions(project *string, logstore *string, request *UpdateIndexRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateIndexResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(request.Body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateIndex"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "/index"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateIndexResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates the indexes of a Logstore.
//
// Description:
//
// ### Usage notes
//
// Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
//
// @param request - UpdateIndexRequest
//
// @return UpdateIndexResponse
func (client *Client) UpdateIndex(project *string, logstore *string, request *UpdateIndexRequest) (_result *UpdateIndexResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateIndexResponse{}
	_body, _err := client.UpdateIndexWithOptions(project, logstore, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates the attributes of a Logstore.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
//
//   - You can call the UpdateLogStore operation to change only the time-to-live (TTL) attribute.
//
// @param request - UpdateLogStoreRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateLogStoreResponse
func (client *Client) UpdateLogStoreWithOptions(project *string, logstore *string, request *UpdateLogStoreRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateLogStoreResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppendMeta)) {
		body["appendMeta"] = request.AppendMeta
	}

	if !tea.BoolValue(util.IsUnset(request.AutoSplit)) {
		body["autoSplit"] = request.AutoSplit
	}

	if !tea.BoolValue(util.IsUnset(request.EnableTracking)) {
		body["enable_tracking"] = request.EnableTracking
	}

	if !tea.BoolValue(util.IsUnset(request.EncryptConf)) {
		body["encrypt_conf"] = request.EncryptConf
	}

	if !tea.BoolValue(util.IsUnset(request.HotTtl)) {
		body["hot_ttl"] = request.HotTtl
	}

	if !tea.BoolValue(util.IsUnset(request.InfrequentAccessTTL)) {
		body["infrequentAccessTTL"] = request.InfrequentAccessTTL
	}

	if !tea.BoolValue(util.IsUnset(request.LogstoreName)) {
		body["logstoreName"] = request.LogstoreName
	}

	if !tea.BoolValue(util.IsUnset(request.MaxSplitShard)) {
		body["maxSplitShard"] = request.MaxSplitShard
	}

	if !tea.BoolValue(util.IsUnset(request.Mode)) {
		body["mode"] = request.Mode
	}

	if !tea.BoolValue(util.IsUnset(request.ShardCount)) {
		body["shardCount"] = request.ShardCount
	}

	if !tea.BoolValue(util.IsUnset(request.TelemetryType)) {
		body["telemetryType"] = request.TelemetryType
	}

	if !tea.BoolValue(util.IsUnset(request.Ttl)) {
		body["ttl"] = request.Ttl
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateLogStore"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore)),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateLogStoreResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates the attributes of a Logstore.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
//
//   - You can call the UpdateLogStore operation to change only the time-to-live (TTL) attribute.
//
// @param request - UpdateLogStoreRequest
//
// @return UpdateLogStoreResponse
func (client *Client) UpdateLogStore(project *string, logstore *string, request *UpdateLogStoreRequest) (_result *UpdateLogStoreResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateLogStoreResponse{}
	_body, _err := client.UpdateLogStoreWithOptions(project, logstore, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates the encryption configuration of a Logstore. You can create encryption configurations for the Logstore and enable or disable the encryption feature.
//
// Description:
//
// ## [](#)Limits
//
// If you specify a data encryption method when you configure data encryption settings, you cannot switch to the other method after the configuration. In addition, you cannot change the encryption algorithm or the encryption type. You can only enable or disable the encryption feature by using the enable parameter. If you specify the encryption method by using the service key of Simple Log Service when you configure data encryption settings, you cannot switch to the encryption method by using Bring Your Own Key (BYOK) keys after the configuration.
//
// ## [](#)Create encryption configurations
//
// ### [](#)Encryption by using service keys
//
// Simple Log Service is fully responsible for data encryption and key management. No additional operations are required. When you create encryption configurations for the Logstore, you must specify the enable and encryptType parameters.
//
// ### [](#byok)Encryption by using BYOK keys
//
// You must create a customer master key (CMK) in Key Management Service (KMS). Then, Simple Log Service encrypts logs by using the CMK. When you create encryption configurations for the Logstore, you must specify the enable, encryptType, and userCmkInfo parameters.
//
// ## [](#)Enable or disable the encryption feature
//
// After you create encryption configurations for the Logstore, you cannot modify the encryptType or userCmkInfo parameters. However, you can enable and disable the encryption feature by using the enable parameter.
//
// @param request - UpdateLogStoreEncryptionRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateLogStoreEncryptionResponse
func (client *Client) UpdateLogStoreEncryptionWithOptions(project *string, logstore *string, request *UpdateLogStoreEncryptionRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateLogStoreEncryptionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		body["enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.EncryptType)) {
		body["encryptType"] = request.EncryptType
	}

	if !tea.BoolValue(util.IsUnset(request.UserCmkInfo)) {
		body["userCmkInfo"] = request.UserCmkInfo
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateLogStoreEncryption"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "/encryption"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateLogStoreEncryptionResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates the encryption configuration of a Logstore. You can create encryption configurations for the Logstore and enable or disable the encryption feature.
//
// Description:
//
// ## [](#)Limits
//
// If you specify a data encryption method when you configure data encryption settings, you cannot switch to the other method after the configuration. In addition, you cannot change the encryption algorithm or the encryption type. You can only enable or disable the encryption feature by using the enable parameter. If you specify the encryption method by using the service key of Simple Log Service when you configure data encryption settings, you cannot switch to the encryption method by using Bring Your Own Key (BYOK) keys after the configuration.
//
// ## [](#)Create encryption configurations
//
// ### [](#)Encryption by using service keys
//
// Simple Log Service is fully responsible for data encryption and key management. No additional operations are required. When you create encryption configurations for the Logstore, you must specify the enable and encryptType parameters.
//
// ### [](#byok)Encryption by using BYOK keys
//
// You must create a customer master key (CMK) in Key Management Service (KMS). Then, Simple Log Service encrypts logs by using the CMK. When you create encryption configurations for the Logstore, you must specify the enable, encryptType, and userCmkInfo parameters.
//
// ## [](#)Enable or disable the encryption feature
//
// After you create encryption configurations for the Logstore, you cannot modify the encryptType or userCmkInfo parameters. However, you can enable and disable the encryption feature by using the enable parameter.
//
// @param request - UpdateLogStoreEncryptionRequest
//
// @return UpdateLogStoreEncryptionResponse
func (client *Client) UpdateLogStoreEncryption(project *string, logstore *string, request *UpdateLogStoreEncryptionRequest) (_result *UpdateLogStoreEncryptionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateLogStoreEncryptionResponse{}
	_body, _err := client.UpdateLogStoreEncryptionWithOptions(project, logstore, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Changes the billing mode of a Logstore.
//
// @param request - UpdateLogStoreMeteringModeRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateLogStoreMeteringModeResponse
func (client *Client) UpdateLogStoreMeteringModeWithOptions(project *string, logstore *string, request *UpdateLogStoreMeteringModeRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateLogStoreMeteringModeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MeteringMode)) {
		body["meteringMode"] = request.MeteringMode
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateLogStoreMeteringMode"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "/meteringmode"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateLogStoreMeteringModeResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Changes the billing mode of a Logstore.
//
// @param request - UpdateLogStoreMeteringModeRequest
//
// @return UpdateLogStoreMeteringModeResponse
func (client *Client) UpdateLogStoreMeteringMode(project *string, logstore *string, request *UpdateLogStoreMeteringModeRequest) (_result *UpdateLogStoreMeteringModeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateLogStoreMeteringModeResponse{}
	_body, _err := client.UpdateLogStoreMeteringModeWithOptions(project, logstore, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the ingest processor that is associated with a Logstore.
//
// @param request - UpdateLogStoreProcessorRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateLogStoreProcessorResponse
func (client *Client) UpdateLogStoreProcessorWithOptions(project *string, logstore *string, request *UpdateLogStoreProcessorRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateLogStoreProcessorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProcessorName)) {
		body["processorName"] = request.ProcessorName
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateLogStoreProcessor"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logstores/" + tea.StringValue(logstore) + "/processor"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateLogStoreProcessorResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the ingest processor that is associated with a Logstore.
//
// @param request - UpdateLogStoreProcessorRequest
//
// @return UpdateLogStoreProcessorResponse
func (client *Client) UpdateLogStoreProcessor(project *string, logstore *string, request *UpdateLogStoreProcessorRequest) (_result *UpdateLogStoreProcessorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateLogStoreProcessorResponse{}
	_body, _err := client.UpdateLogStoreProcessorWithOptions(project, logstore, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates the service log configurations of a project.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - UpdateLoggingRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateLoggingResponse
func (client *Client) UpdateLoggingWithOptions(project *string, request *UpdateLoggingRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateLoggingResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LoggingDetails)) {
		body["loggingDetails"] = request.LoggingDetails
	}

	if !tea.BoolValue(util.IsUnset(request.LoggingProject)) {
		body["loggingProject"] = request.LoggingProject
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateLogging"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/logging"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateLoggingResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates the service log configurations of a project.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - UpdateLoggingRequest
//
// @return UpdateLoggingResponse
func (client *Client) UpdateLogging(project *string, request *UpdateLoggingRequest) (_result *UpdateLoggingResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateLoggingResponse{}
	_body, _err := client.UpdateLoggingWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates a Logtail pipeline configuration.
//
// Description:
//
// The UK (London) region is supported. Supported regions are constantly updated.
//
// @param request - UpdateLogtailPipelineConfigRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateLogtailPipelineConfigResponse
func (client *Client) UpdateLogtailPipelineConfigWithOptions(project *string, configName *string, request *UpdateLogtailPipelineConfigRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateLogtailPipelineConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Aggregators)) {
		body["aggregators"] = request.Aggregators
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigName)) {
		body["configName"] = request.ConfigName
	}

	if !tea.BoolValue(util.IsUnset(request.Flushers)) {
		body["flushers"] = request.Flushers
	}

	if !tea.BoolValue(util.IsUnset(request.Global)) {
		body["global"] = request.Global
	}

	if !tea.BoolValue(util.IsUnset(request.Inputs)) {
		body["inputs"] = request.Inputs
	}

	if !tea.BoolValue(util.IsUnset(request.LogSample)) {
		body["logSample"] = request.LogSample
	}

	if !tea.BoolValue(util.IsUnset(request.Processors)) {
		body["processors"] = request.Processors
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateLogtailPipelineConfig"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pipelineconfigs/" + tea.StringValue(configName)),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateLogtailPipelineConfigResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates a Logtail pipeline configuration.
//
// Description:
//
// The UK (London) region is supported. Supported regions are constantly updated.
//
// @param request - UpdateLogtailPipelineConfigRequest
//
// @return UpdateLogtailPipelineConfigResponse
func (client *Client) UpdateLogtailPipelineConfig(project *string, configName *string, request *UpdateLogtailPipelineConfigRequest) (_result *UpdateLogtailPipelineConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateLogtailPipelineConfigResponse{}
	_body, _err := client.UpdateLogtailPipelineConfigWithOptions(project, configName, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the configuration of a machine group.
//
// Description:
//
// Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
//
// @param request - UpdateMachineGroupRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateMachineGroupResponse
func (client *Client) UpdateMachineGroupWithOptions(project *string, groupName *string, request *UpdateMachineGroupRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateMachineGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupAttribute)) {
		body["groupAttribute"] = request.GroupAttribute
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		body["groupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.GroupType)) {
		body["groupType"] = request.GroupType
	}

	if !tea.BoolValue(util.IsUnset(request.MachineIdentifyType)) {
		body["machineIdentifyType"] = request.MachineIdentifyType
	}

	if !tea.BoolValue(util.IsUnset(request.MachineList)) {
		body["machineList"] = request.MachineList
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateMachineGroup"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/machinegroups/" + tea.StringValue(groupName)),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateMachineGroupResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the configuration of a machine group.
//
// Description:
//
// Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
//
// @param request - UpdateMachineGroupRequest
//
// @return UpdateMachineGroupResponse
func (client *Client) UpdateMachineGroup(project *string, groupName *string, request *UpdateMachineGroupRequest) (_result *UpdateMachineGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateMachineGroupResponse{}
	_body, _err := client.UpdateMachineGroupWithOptions(project, groupName, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the machines in a machine group. You can add machine to or remove machines from the machine group.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - UpdateMachineGroupMachineRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateMachineGroupMachineResponse
func (client *Client) UpdateMachineGroupMachineWithOptions(project *string, machineGroup *string, request *UpdateMachineGroupMachineRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateMachineGroupMachineResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Action)) {
		query["action"] = request.Action
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Query:   openapiutil.Query(query),
		Body:    request.Body,
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateMachineGroupMachine"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/machinegroups/" + tea.StringValue(machineGroup) + "/machines"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateMachineGroupMachineResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Modifies the machines in a machine group. You can add machine to or remove machines from the machine group.
//
// Description:
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - UpdateMachineGroupMachineRequest
//
// @return UpdateMachineGroupMachineResponse
func (client *Client) UpdateMachineGroupMachine(project *string, machineGroup *string, request *UpdateMachineGroupMachineRequest) (_result *UpdateMachineGroupMachineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateMachineGroupMachineResponse{}
	_body, _err := client.UpdateMachineGroupMachineWithOptions(project, machineGroup, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates the settings of an existing Metricstore. Metricstores are used to store metric data.
//
// Description:
//
// Metricstores are used to store metric data. For more information, see [Metric data](https://help.aliyun.com/document_detail/174965.html).
//
//   - You must specify an existing Metricstore.
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query metric data is obtained. The information includes the name of the project to which the metric data belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
//   - You can create up to 200 Logstores or Metricstores in a project.
//
//   - Metric data is automatically deleted when the retention period of the metric data ends.
//
// @param request - UpdateMetricStoreRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateMetricStoreResponse
func (client *Client) UpdateMetricStoreWithOptions(project *string, name *string, request *UpdateMetricStoreRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateMetricStoreResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoSplit)) {
		body["autoSplit"] = request.AutoSplit
	}

	if !tea.BoolValue(util.IsUnset(request.HotTtl)) {
		body["hot_ttl"] = request.HotTtl
	}

	if !tea.BoolValue(util.IsUnset(request.InfrequentAccessTTL)) {
		body["infrequentAccessTTL"] = request.InfrequentAccessTTL
	}

	if !tea.BoolValue(util.IsUnset(request.MaxSplitShard)) {
		body["maxSplitShard"] = request.MaxSplitShard
	}

	if !tea.BoolValue(util.IsUnset(request.Mode)) {
		body["mode"] = request.Mode
	}

	if !tea.BoolValue(util.IsUnset(request.Ttl)) {
		body["ttl"] = request.Ttl
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateMetricStore"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/metricstores/" + tea.StringValue(name)),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateMetricStoreResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates the settings of an existing Metricstore. Metricstores are used to store metric data.
//
// Description:
//
// Metricstores are used to store metric data. For more information, see [Metric data](https://help.aliyun.com/document_detail/174965.html).
//
//   - You must specify an existing Metricstore.
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O\\&M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query metric data is obtained. The information includes the name of the project to which the metric data belong and the region of the project. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html).
//
//   - You can create up to 200 Logstores or Metricstores in a project.
//
//   - Metric data is automatically deleted when the retention period of the metric data ends.
//
// @param request - UpdateMetricStoreRequest
//
// @return UpdateMetricStoreResponse
func (client *Client) UpdateMetricStore(project *string, name *string, request *UpdateMetricStoreRequest) (_result *UpdateMetricStoreResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateMetricStoreResponse{}
	_body, _err := client.UpdateMetricStoreWithOptions(project, name, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 更新 MetricStore 计量模式
//
// @param request - UpdateMetricStoreMeteringModeRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateMetricStoreMeteringModeResponse
func (client *Client) UpdateMetricStoreMeteringModeWithOptions(project *string, metricStore *string, request *UpdateMetricStoreMeteringModeRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateMetricStoreMeteringModeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MeteringMode)) {
		body["meteringMode"] = request.MeteringMode
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateMetricStoreMeteringMode"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/metricstores/" + tea.StringValue(metricStore) + "/meteringmode"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateMetricStoreMeteringModeResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 更新 MetricStore 计量模式
//
// @param request - UpdateMetricStoreMeteringModeRequest
//
// @return UpdateMetricStoreMeteringModeResponse
func (client *Client) UpdateMetricStoreMeteringMode(project *string, metricStore *string, request *UpdateMetricStoreMeteringModeRequest) (_result *UpdateMetricStoreMeteringModeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateMetricStoreMeteringModeResponse{}
	_body, _err := client.UpdateMetricStoreMeteringModeWithOptions(project, metricStore, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates the ingest processor that is associated with a Metricstore.
//
// @param request - UpdateMetricStoreProcessorRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateMetricStoreProcessorResponse
func (client *Client) UpdateMetricStoreProcessorWithOptions(project *string, metricstore *string, request *UpdateMetricStoreProcessorRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateMetricStoreProcessorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProcessorName)) {
		body["processorName"] = request.ProcessorName
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateMetricStoreProcessor"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/metricstores/" + tea.StringValue(metricstore) + "/processor"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateMetricStoreProcessorResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates the ingest processor that is associated with a Metricstore.
//
// @param request - UpdateMetricStoreProcessorRequest
//
// @return UpdateMetricStoreProcessorResponse
func (client *Client) UpdateMetricStoreProcessor(project *string, metricstore *string, request *UpdateMetricStoreProcessorRequest) (_result *UpdateMetricStoreProcessorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateMetricStoreProcessorResponse{}
	_body, _err := client.UpdateMetricStoreProcessorWithOptions(project, metricstore, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 更新OSS投递任务
//
// @param request - UpdateOSSExportRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateOSSExportResponse
func (client *Client) UpdateOSSExportWithOptions(project *string, ossExportName *string, request *UpdateOSSExportRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateOSSExportResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Configuration)) {
		body["configuration"] = request.Configuration
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DisplayName)) {
		body["displayName"] = request.DisplayName
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateOSSExport"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ossexports/" + tea.StringValue(ossExportName)),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateOSSExportResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 更新OSS投递任务
//
// @param request - UpdateOSSExportRequest
//
// @return UpdateOSSExportResponse
func (client *Client) UpdateOSSExport(project *string, ossExportName *string, request *UpdateOSSExportRequest) (_result *UpdateOSSExportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateOSSExportResponse{}
	_body, _err := client.UpdateOSSExportWithOptions(project, ossExportName, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 更新OSSHDFS投递任务
//
// @param request - UpdateOSSHDFSExportRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateOSSHDFSExportResponse
func (client *Client) UpdateOSSHDFSExportWithOptions(project *string, ossExportName *string, request *UpdateOSSHDFSExportRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateOSSHDFSExportResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Configuration)) {
		body["configuration"] = request.Configuration
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DisplayName)) {
		body["displayName"] = request.DisplayName
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateOSSHDFSExport"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/osshdfsexports/" + tea.StringValue(ossExportName)),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateOSSHDFSExportResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 更新OSSHDFS投递任务
//
// @param request - UpdateOSSHDFSExportRequest
//
// @return UpdateOSSHDFSExportResponse
func (client *Client) UpdateOSSHDFSExport(project *string, ossExportName *string, request *UpdateOSSHDFSExportRequest) (_result *UpdateOSSHDFSExportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateOSSHDFSExportResponse{}
	_body, _err := client.UpdateOSSHDFSExportWithOptions(project, ossExportName, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates an Object Storage Service (OSS) data import job.
//
// @param request - UpdateOSSIngestionRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateOSSIngestionResponse
func (client *Client) UpdateOSSIngestionWithOptions(project *string, ossIngestionName *string, request *UpdateOSSIngestionRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateOSSIngestionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Configuration)) {
		body["configuration"] = request.Configuration
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DisplayName)) {
		body["displayName"] = request.DisplayName
	}

	if !tea.BoolValue(util.IsUnset(request.Schedule)) {
		body["schedule"] = request.Schedule
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateOSSIngestion"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/ossingestions/" + tea.StringValue(ossIngestionName)),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateOSSIngestionResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates an Object Storage Service (OSS) data import job.
//
// @param request - UpdateOSSIngestionRequest
//
// @return UpdateOSSIngestionResponse
func (client *Client) UpdateOSSIngestion(project *string, ossIngestionName *string, request *UpdateOSSIngestionRequest) (_result *UpdateOSSIngestionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateOSSIngestionResponse{}
	_body, _err := client.UpdateOSSIngestionWithOptions(project, ossIngestionName, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates an Object Storage Service (OSS) external store.
//
// Description:
//
// ### [](#)Usage notes
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - UpdateOssExternalStoreRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateOssExternalStoreResponse
func (client *Client) UpdateOssExternalStoreWithOptions(project *string, externalStoreName *string, request *UpdateOssExternalStoreRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateOssExternalStoreResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ExternalStoreName)) {
		body["externalStoreName"] = request.ExternalStoreName
	}

	if !tea.BoolValue(util.IsUnset(request.Parameter)) {
		body["parameter"] = request.Parameter
	}

	if !tea.BoolValue(util.IsUnset(request.StoreType)) {
		body["storeType"] = request.StoreType
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateOssExternalStore"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/externalstores/" + tea.StringValue(externalStoreName)),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateOssExternalStoreResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates an Object Storage Service (OSS) external store.
//
// Description:
//
// ### [](#)Usage notes
//
// Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
// @param request - UpdateOssExternalStoreRequest
//
// @return UpdateOssExternalStoreResponse
func (client *Client) UpdateOssExternalStore(project *string, externalStoreName *string, request *UpdateOssExternalStoreRequest) (_result *UpdateOssExternalStoreResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateOssExternalStoreResponse{}
	_body, _err := client.UpdateOssExternalStoreWithOptions(project, externalStoreName, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates a project.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:UpdateProject`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`|
//
// @param request - UpdateProjectRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateProjectResponse
func (client *Client) UpdateProjectWithOptions(project *string, request *UpdateProjectRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateProjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.RecycleBinEnabled)) {
		body["recycleBinEnabled"] = request.RecycleBinEnabled
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateProject"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateProjectResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates a project.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:UpdateProject`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}`|
//
// @param request - UpdateProjectRequest
//
// @return UpdateProjectResponse
func (client *Client) UpdateProject(project *string, request *UpdateProjectRequest) (_result *UpdateProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateProjectResponse{}
	_body, _err := client.UpdateProjectWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates an ApsaraDB RDS external store.
//
// Description:
//
// Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
//
// @param request - UpdateRdsExternalStoreRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateRdsExternalStoreResponse
func (client *Client) UpdateRdsExternalStoreWithOptions(project *string, externalStoreName *string, request *UpdateRdsExternalStoreRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateRdsExternalStoreResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ExternalStoreName)) {
		body["externalStoreName"] = request.ExternalStoreName
	}

	if !tea.BoolValue(util.IsUnset(request.Parameter)) {
		body["parameter"] = request.Parameter
	}

	if !tea.BoolValue(util.IsUnset(request.StoreType)) {
		body["storeType"] = request.StoreType
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateRdsExternalStore"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/externalstores/" + tea.StringValue(externalStoreName)),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateRdsExternalStoreResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates an ApsaraDB RDS external store.
//
// Description:
//
// Host consists of a project name and a Log Service endpoint. You must specify a project in Host.
//
// @param request - UpdateRdsExternalStoreRequest
//
// @return UpdateRdsExternalStoreResponse
func (client *Client) UpdateRdsExternalStore(project *string, externalStoreName *string, request *UpdateRdsExternalStoreRequest) (_result *UpdateRdsExternalStoreResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateRdsExternalStoreResponse{}
	_body, _err := client.UpdateRdsExternalStoreWithOptions(project, externalStoreName, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates a saved search.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
//   - Limits are imposed when you use Simple Log Service to query logs. We recommend that you specify query statements and query time ranges based on the limits. For more information, see [Log search overview](https://help.aliyun.com/document_detail/43772.html) and [Log analysis overview](https://help.aliyun.com/document_detail/53608.html).
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:UpdateSavedSearch`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/savedsearch/{#SavedSearchName}`|
//
// @param request - UpdateSavedSearchRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateSavedSearchResponse
func (client *Client) UpdateSavedSearchWithOptions(project *string, savedsearchName *string, request *UpdateSavedSearchRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateSavedSearchResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DisplayName)) {
		body["displayName"] = request.DisplayName
	}

	if !tea.BoolValue(util.IsUnset(request.Logstore)) {
		body["logstore"] = request.Logstore
	}

	if !tea.BoolValue(util.IsUnset(request.SavedsearchName)) {
		body["savedsearchName"] = request.SavedsearchName
	}

	if !tea.BoolValue(util.IsUnset(request.SearchQuery)) {
		body["searchQuery"] = request.SearchQuery
	}

	if !tea.BoolValue(util.IsUnset(request.Topic)) {
		body["topic"] = request.Topic
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateSavedSearch"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/savedsearches/" + tea.StringValue(savedsearchName)),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateSavedSearchResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates a saved search.
//
// Description:
//
// ### Usage notes
//
//   - Host consists of a project name and a Simple Log Service endpoint. You must specify a project in Host.
//
//   - An AccessKey pair is created and obtained. For more information, see [AccessKey pair](https://help.aliyun.com/document_detail/29009.html).
//
// The AccessKey pair of an Alibaba Cloud account has permissions on all API operations. Using these credentials to perform operations in Simple Log Service is a high-risk operation. We recommend that you use a Resource Access Management (RAM) user to call API operations or perform routine O&#x26;M. To create a RAM user, log on to the RAM console. Make sure that the RAM user has the management permissions on Simple Log Service resources. For more information, see [Create a RAM user and authorize the RAM user to access Simple Log Service](https://help.aliyun.com/document_detail/47664.html).
//
//   - The information that is required to query logs is obtained. The information includes the name of the project to which the logs belong, the region of the project, and the name of the Logstore to which the logs belong. For more information, see [Manage a project](https://help.aliyun.com/document_detail/48984.html) and [Manage a Logstore](https://help.aliyun.com/document_detail/48990.html).
//
//   - Limits are imposed when you use Simple Log Service to query logs. We recommend that you specify query statements and query time ranges based on the limits. For more information, see [Log search overview](https://help.aliyun.com/document_detail/43772.html) and [Log analysis overview](https://help.aliyun.com/document_detail/53608.html).
//
// ### Authentication resources
//
// The following table describes the authorization information that is required for this operation. You can add the information to the Action element of a RAM policy statement to grant a RAM user or a RAM role the permissions to call this operation.
//
// |Action|Resource|
//
// |:---|:---|
//
// |`log:UpdateSavedSearch`|`acs:log:{#regionId}:{#accountId}:project/{#ProjectName}/savedsearch/{#SavedSearchName}`|
//
// @param request - UpdateSavedSearchRequest
//
// @return UpdateSavedSearchResponse
func (client *Client) UpdateSavedSearch(project *string, savedsearchName *string, request *UpdateSavedSearchRequest) (_result *UpdateSavedSearchResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateSavedSearchResponse{}
	_body, _err := client.UpdateSavedSearchWithOptions(project, savedsearchName, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates a Scheduled SQL job.
//
// @param request - UpdateScheduledSQLRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateScheduledSQLResponse
func (client *Client) UpdateScheduledSQLWithOptions(project *string, scheduledSQLName *string, request *UpdateScheduledSQLRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateScheduledSQLResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Configuration)) {
		body["configuration"] = request.Configuration
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DisplayName)) {
		body["displayName"] = request.DisplayName
	}

	if !tea.BoolValue(util.IsUnset(request.Schedule)) {
		body["schedule"] = request.Schedule
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateScheduledSQL"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/scheduledsqls/" + tea.StringValue(scheduledSQLName)),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateScheduledSQLResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates a Scheduled SQL job.
//
// @param request - UpdateScheduledSQLRequest
//
// @return UpdateScheduledSQLResponse
func (client *Client) UpdateScheduledSQL(project *string, scheduledSQLName *string, request *UpdateScheduledSQLRequest) (_result *UpdateScheduledSQLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateScheduledSQLResponse{}
	_body, _err := client.UpdateScheduledSQLWithOptions(project, scheduledSQLName, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates the configurations of the Dedicated SQL feature.
//
// @param request - UpdateSqlInstanceRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateSqlInstanceResponse
func (client *Client) UpdateSqlInstanceWithOptions(project *string, request *UpdateSqlInstanceRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateSqlInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Cu)) {
		body["cu"] = request.Cu
	}

	if !tea.BoolValue(util.IsUnset(request.UseAsDefault)) {
		body["useAsDefault"] = request.UseAsDefault
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateSqlInstance"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/sqlinstance"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateSqlInstanceResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates the configurations of the Dedicated SQL feature.
//
// @param request - UpdateSqlInstanceRequest
//
// @return UpdateSqlInstanceResponse
func (client *Client) UpdateSqlInstance(project *string, request *UpdateSqlInstanceRequest) (_result *UpdateSqlInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateSqlInstanceResponse{}
	_body, _err := client.UpdateSqlInstanceWithOptions(project, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates the configurations of a dataset.
//
// @param request - UpdateStoreViewRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateStoreViewResponse
func (client *Client) UpdateStoreViewWithOptions(project *string, name *string, request *UpdateStoreViewRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateStoreViewResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	hostMap := make(map[string]*string)
	hostMap["project"] = project
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.StoreType)) {
		body["storeType"] = request.StoreType
	}

	if !tea.BoolValue(util.IsUnset(request.Stores)) {
		body["stores"] = request.Stores
	}

	req := &openapi.OpenApiRequest{
		HostMap: hostMap,
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateStoreView"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/storeviews/" + tea.StringValue(name)),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpdateStoreViewResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// Updates the configurations of a dataset.
//
// @param request - UpdateStoreViewRequest
//
// @return UpdateStoreViewResponse
func (client *Client) UpdateStoreView(project *string, name *string, request *UpdateStoreViewRequest) (_result *UpdateStoreViewResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateStoreViewResponse{}
	_body, _err := client.UpdateStoreViewWithOptions(project, name, request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 调用UpsertCollectionPolicy接口创建或更新日志采集规则
//
// @param request - UpsertCollectionPolicyRequest
//
// @param headers - map
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpsertCollectionPolicyResponse
func (client *Client) UpsertCollectionPolicyWithOptions(request *UpsertCollectionPolicyRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpsertCollectionPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CentralizeConfig)) {
		body["centralizeConfig"] = request.CentralizeConfig
	}

	if !tea.BoolValue(util.IsUnset(request.CentralizeEnabled)) {
		body["centralizeEnabled"] = request.CentralizeEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.DataCode)) {
		body["dataCode"] = request.DataCode
	}

	if !tea.BoolValue(util.IsUnset(request.DataConfig)) {
		body["dataConfig"] = request.DataConfig
	}

	if !tea.BoolValue(util.IsUnset(request.Enabled)) {
		body["enabled"] = request.Enabled
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyConfig)) {
		body["policyConfig"] = request.PolicyConfig
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyName)) {
		body["policyName"] = request.PolicyName
	}

	if !tea.BoolValue(util.IsUnset(request.ProductCode)) {
		body["productCode"] = request.ProductCode
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceDirectory)) {
		body["resourceDirectory"] = request.ResourceDirectory
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpsertCollectionPolicy"),
		Version:     tea.String("2020-12-30"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/collectionpolicy"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("none"),
	}
	_result = &UpsertCollectionPolicyResponse{}
	_body, _err := client.Execute(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

// Summary:
//
// 调用UpsertCollectionPolicy接口创建或更新日志采集规则
//
// @param request - UpsertCollectionPolicyRequest
//
// @return UpsertCollectionPolicyResponse
func (client *Client) UpsertCollectionPolicy(request *UpsertCollectionPolicyRequest) (_result *UpsertCollectionPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpsertCollectionPolicyResponse{}
	_body, _err := client.UpsertCollectionPolicyWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
