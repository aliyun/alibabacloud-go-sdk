// This file is auto-generated, don't edit it. Thanks.
/**
 *
 */
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	endpointutil "github.com/alibabacloud-go/endpoint-util/service"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
)

type AddCustomLineRequest struct {
	// The domain name for which you configure the custom line.
	DomainName *string                          `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	IpSegment  []*AddCustomLineRequestIpSegment `json:"IpSegment,omitempty" xml:"IpSegment,omitempty" type:"Repeated"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The name of the custom line.
	LineName *string `json:"LineName,omitempty" xml:"LineName,omitempty"`
}

func (s AddCustomLineRequest) String() string {
	return tea.Prettify(s)
}

func (s AddCustomLineRequest) GoString() string {
	return s.String()
}

func (s *AddCustomLineRequest) SetDomainName(v string) *AddCustomLineRequest {
	s.DomainName = &v
	return s
}

func (s *AddCustomLineRequest) SetIpSegment(v []*AddCustomLineRequestIpSegment) *AddCustomLineRequest {
	s.IpSegment = v
	return s
}

func (s *AddCustomLineRequest) SetLang(v string) *AddCustomLineRequest {
	s.Lang = &v
	return s
}

func (s *AddCustomLineRequest) SetLineName(v string) *AddCustomLineRequest {
	s.LineName = &v
	return s
}

type AddCustomLineRequestIpSegment struct {
	// The end IP address of the CIDR block.
	EndIp *string `json:"EndIp,omitempty" xml:"EndIp,omitempty"`
	// The start IP address of the CIDR block.
	StartIp *string `json:"StartIp,omitempty" xml:"StartIp,omitempty"`
}

func (s AddCustomLineRequestIpSegment) String() string {
	return tea.Prettify(s)
}

func (s AddCustomLineRequestIpSegment) GoString() string {
	return s.String()
}

func (s *AddCustomLineRequestIpSegment) SetEndIp(v string) *AddCustomLineRequestIpSegment {
	s.EndIp = &v
	return s
}

func (s *AddCustomLineRequestIpSegment) SetStartIp(v string) *AddCustomLineRequestIpSegment {
	s.StartIp = &v
	return s
}

type AddCustomLineResponseBody struct {
	// The code of the custom line.
	LineCode *string `json:"LineCode,omitempty" xml:"LineCode,omitempty"`
	// The unique ID of the custom line.
	LineId *int64 `json:"LineId,omitempty" xml:"LineId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddCustomLineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddCustomLineResponseBody) GoString() string {
	return s.String()
}

func (s *AddCustomLineResponseBody) SetLineCode(v string) *AddCustomLineResponseBody {
	s.LineCode = &v
	return s
}

func (s *AddCustomLineResponseBody) SetLineId(v int64) *AddCustomLineResponseBody {
	s.LineId = &v
	return s
}

func (s *AddCustomLineResponseBody) SetRequestId(v string) *AddCustomLineResponseBody {
	s.RequestId = &v
	return s
}

type AddCustomLineResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddCustomLineResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddCustomLineResponse) String() string {
	return tea.Prettify(s)
}

func (s AddCustomLineResponse) GoString() string {
	return s.String()
}

func (s *AddCustomLineResponse) SetHeaders(v map[string]*string) *AddCustomLineResponse {
	s.Headers = v
	return s
}

func (s *AddCustomLineResponse) SetStatusCode(v int32) *AddCustomLineResponse {
	s.StatusCode = &v
	return s
}

func (s *AddCustomLineResponse) SetBody(v *AddCustomLineResponseBody) *AddCustomLineResponse {
	s.Body = v
	return s
}

type AddDnsCacheDomainRequest struct {
	CacheTtlMax     *int32                                     `json:"CacheTtlMax,omitempty" xml:"CacheTtlMax,omitempty"`
	CacheTtlMin     *int32                                     `json:"CacheTtlMin,omitempty" xml:"CacheTtlMin,omitempty"`
	DomainName      *string                                    `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	InstanceId      *string                                    `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	Lang            *string                                    `json:"Lang,omitempty" xml:"Lang,omitempty"`
	Remark          *string                                    `json:"Remark,omitempty" xml:"Remark,omitempty"`
	SourceDnsServer []*AddDnsCacheDomainRequestSourceDnsServer `json:"SourceDnsServer,omitempty" xml:"SourceDnsServer,omitempty" type:"Repeated"`
	SourceEdns      *string                                    `json:"SourceEdns,omitempty" xml:"SourceEdns,omitempty"`
	SourceProtocol  *string                                    `json:"SourceProtocol,omitempty" xml:"SourceProtocol,omitempty"`
}

func (s AddDnsCacheDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s AddDnsCacheDomainRequest) GoString() string {
	return s.String()
}

func (s *AddDnsCacheDomainRequest) SetCacheTtlMax(v int32) *AddDnsCacheDomainRequest {
	s.CacheTtlMax = &v
	return s
}

func (s *AddDnsCacheDomainRequest) SetCacheTtlMin(v int32) *AddDnsCacheDomainRequest {
	s.CacheTtlMin = &v
	return s
}

func (s *AddDnsCacheDomainRequest) SetDomainName(v string) *AddDnsCacheDomainRequest {
	s.DomainName = &v
	return s
}

func (s *AddDnsCacheDomainRequest) SetInstanceId(v string) *AddDnsCacheDomainRequest {
	s.InstanceId = &v
	return s
}

func (s *AddDnsCacheDomainRequest) SetLang(v string) *AddDnsCacheDomainRequest {
	s.Lang = &v
	return s
}

func (s *AddDnsCacheDomainRequest) SetRemark(v string) *AddDnsCacheDomainRequest {
	s.Remark = &v
	return s
}

func (s *AddDnsCacheDomainRequest) SetSourceDnsServer(v []*AddDnsCacheDomainRequestSourceDnsServer) *AddDnsCacheDomainRequest {
	s.SourceDnsServer = v
	return s
}

func (s *AddDnsCacheDomainRequest) SetSourceEdns(v string) *AddDnsCacheDomainRequest {
	s.SourceEdns = &v
	return s
}

func (s *AddDnsCacheDomainRequest) SetSourceProtocol(v string) *AddDnsCacheDomainRequest {
	s.SourceProtocol = &v
	return s
}

type AddDnsCacheDomainRequestSourceDnsServer struct {
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
}

func (s AddDnsCacheDomainRequestSourceDnsServer) String() string {
	return tea.Prettify(s)
}

func (s AddDnsCacheDomainRequestSourceDnsServer) GoString() string {
	return s.String()
}

func (s *AddDnsCacheDomainRequestSourceDnsServer) SetHost(v string) *AddDnsCacheDomainRequestSourceDnsServer {
	s.Host = &v
	return s
}

func (s *AddDnsCacheDomainRequestSourceDnsServer) SetPort(v string) *AddDnsCacheDomainRequestSourceDnsServer {
	s.Port = &v
	return s
}

type AddDnsCacheDomainResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddDnsCacheDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddDnsCacheDomainResponseBody) GoString() string {
	return s.String()
}

func (s *AddDnsCacheDomainResponseBody) SetRequestId(v string) *AddDnsCacheDomainResponseBody {
	s.RequestId = &v
	return s
}

type AddDnsCacheDomainResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddDnsCacheDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddDnsCacheDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s AddDnsCacheDomainResponse) GoString() string {
	return s.String()
}

func (s *AddDnsCacheDomainResponse) SetHeaders(v map[string]*string) *AddDnsCacheDomainResponse {
	s.Headers = v
	return s
}

func (s *AddDnsCacheDomainResponse) SetStatusCode(v int32) *AddDnsCacheDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *AddDnsCacheDomainResponse) SetBody(v *AddDnsCacheDomainResponseBody) *AddDnsCacheDomainResponse {
	s.Body = v
	return s
}

type AddDnsGtmAccessStrategyRequest struct {
	DefaultAddrPool []*AddDnsGtmAccessStrategyRequestDefaultAddrPool `json:"DefaultAddrPool,omitempty" xml:"DefaultAddrPool,omitempty" type:"Repeated"`
	// The type of the primary address pool. Valid values:
	//
	// *   IPV4
	// *   IPV6
	// *   DOMAIN
	DefaultAddrPoolType *string `json:"DefaultAddrPoolType,omitempty" xml:"DefaultAddrPoolType,omitempty"`
	// Specifies whether to enable scheduling optimization for latency resolution for the primary address pool group. Valid values:
	//
	// *   OPEN: enable
	// *   CLOSE: disable
	DefaultLatencyOptimization *string `json:"DefaultLatencyOptimization,omitempty" xml:"DefaultLatencyOptimization,omitempty"`
	// The load balancing policy of the primary address pool group. Valid values:
	//
	// *   ALL_RR: returns all addresses.
	// *   RATIO: returns addresses by weight.
	DefaultLbaStrategy *string `json:"DefaultLbaStrategy,omitempty" xml:"DefaultLbaStrategy,omitempty"`
	// The maximum number of addresses returned from the primary address pool group.
	DefaultMaxReturnAddrNum *int32 `json:"DefaultMaxReturnAddrNum,omitempty" xml:"DefaultMaxReturnAddrNum,omitempty"`
	// The minimum number of available addresses in the primary address pool group.
	DefaultMinAvailableAddrNum *int32                                            `json:"DefaultMinAvailableAddrNum,omitempty" xml:"DefaultMinAvailableAddrNum,omitempty"`
	FailoverAddrPool           []*AddDnsGtmAccessStrategyRequestFailoverAddrPool `json:"FailoverAddrPool,omitempty" xml:"FailoverAddrPool,omitempty" type:"Repeated"`
	// The type of the secondary address pool. Valid values:
	//
	// *   IPV4
	// *   IPV6
	// *   DOMAIN
	FailoverAddrPoolType *string `json:"FailoverAddrPoolType,omitempty" xml:"FailoverAddrPoolType,omitempty"`
	// Specifies whether to enable scheduling optimization for latency resolution for the secondary address pool group. Valid values:
	//
	// *   OPEN: enable
	// *   CLOSE: disable
	FailoverLatencyOptimization *string `json:"FailoverLatencyOptimization,omitempty" xml:"FailoverLatencyOptimization,omitempty"`
	// The load balancing policy of the secondary address pool group. Valid values:
	//
	// *   ALL_RR: returns all addresses.
	// *   RATIO: returns addresses by weight.
	FailoverLbaStrategy *string `json:"FailoverLbaStrategy,omitempty" xml:"FailoverLbaStrategy,omitempty"`
	// The maximum number of addresses returned from the secondary address pool group.
	FailoverMaxReturnAddrNum *int32 `json:"FailoverMaxReturnAddrNum,omitempty" xml:"FailoverMaxReturnAddrNum,omitempty"`
	// The minimum number of available addresses in the secondary address pool group.
	FailoverMinAvailableAddrNum *int32 `json:"FailoverMinAvailableAddrNum,omitempty" xml:"FailoverMinAvailableAddrNum,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The line codes of source regions. For example: `["default", "drpeng"]` indicates Global and Dr. Peng Telecom & Media Group.
	Lines *string `json:"Lines,omitempty" xml:"Lines,omitempty"`
	// The type of the access policy. Valid values:
	//
	// *   GEO: geographical location-based
	// *   LATENCY: latency-based
	StrategyMode *string `json:"StrategyMode,omitempty" xml:"StrategyMode,omitempty"`
	// The name of the access policy.
	StrategyName *string `json:"StrategyName,omitempty" xml:"StrategyName,omitempty"`
}

func (s AddDnsGtmAccessStrategyRequest) String() string {
	return tea.Prettify(s)
}

func (s AddDnsGtmAccessStrategyRequest) GoString() string {
	return s.String()
}

func (s *AddDnsGtmAccessStrategyRequest) SetDefaultAddrPool(v []*AddDnsGtmAccessStrategyRequestDefaultAddrPool) *AddDnsGtmAccessStrategyRequest {
	s.DefaultAddrPool = v
	return s
}

func (s *AddDnsGtmAccessStrategyRequest) SetDefaultAddrPoolType(v string) *AddDnsGtmAccessStrategyRequest {
	s.DefaultAddrPoolType = &v
	return s
}

func (s *AddDnsGtmAccessStrategyRequest) SetDefaultLatencyOptimization(v string) *AddDnsGtmAccessStrategyRequest {
	s.DefaultLatencyOptimization = &v
	return s
}

func (s *AddDnsGtmAccessStrategyRequest) SetDefaultLbaStrategy(v string) *AddDnsGtmAccessStrategyRequest {
	s.DefaultLbaStrategy = &v
	return s
}

func (s *AddDnsGtmAccessStrategyRequest) SetDefaultMaxReturnAddrNum(v int32) *AddDnsGtmAccessStrategyRequest {
	s.DefaultMaxReturnAddrNum = &v
	return s
}

func (s *AddDnsGtmAccessStrategyRequest) SetDefaultMinAvailableAddrNum(v int32) *AddDnsGtmAccessStrategyRequest {
	s.DefaultMinAvailableAddrNum = &v
	return s
}

func (s *AddDnsGtmAccessStrategyRequest) SetFailoverAddrPool(v []*AddDnsGtmAccessStrategyRequestFailoverAddrPool) *AddDnsGtmAccessStrategyRequest {
	s.FailoverAddrPool = v
	return s
}

func (s *AddDnsGtmAccessStrategyRequest) SetFailoverAddrPoolType(v string) *AddDnsGtmAccessStrategyRequest {
	s.FailoverAddrPoolType = &v
	return s
}

func (s *AddDnsGtmAccessStrategyRequest) SetFailoverLatencyOptimization(v string) *AddDnsGtmAccessStrategyRequest {
	s.FailoverLatencyOptimization = &v
	return s
}

func (s *AddDnsGtmAccessStrategyRequest) SetFailoverLbaStrategy(v string) *AddDnsGtmAccessStrategyRequest {
	s.FailoverLbaStrategy = &v
	return s
}

func (s *AddDnsGtmAccessStrategyRequest) SetFailoverMaxReturnAddrNum(v int32) *AddDnsGtmAccessStrategyRequest {
	s.FailoverMaxReturnAddrNum = &v
	return s
}

func (s *AddDnsGtmAccessStrategyRequest) SetFailoverMinAvailableAddrNum(v int32) *AddDnsGtmAccessStrategyRequest {
	s.FailoverMinAvailableAddrNum = &v
	return s
}

func (s *AddDnsGtmAccessStrategyRequest) SetInstanceId(v string) *AddDnsGtmAccessStrategyRequest {
	s.InstanceId = &v
	return s
}

func (s *AddDnsGtmAccessStrategyRequest) SetLang(v string) *AddDnsGtmAccessStrategyRequest {
	s.Lang = &v
	return s
}

func (s *AddDnsGtmAccessStrategyRequest) SetLines(v string) *AddDnsGtmAccessStrategyRequest {
	s.Lines = &v
	return s
}

func (s *AddDnsGtmAccessStrategyRequest) SetStrategyMode(v string) *AddDnsGtmAccessStrategyRequest {
	s.StrategyMode = &v
	return s
}

func (s *AddDnsGtmAccessStrategyRequest) SetStrategyName(v string) *AddDnsGtmAccessStrategyRequest {
	s.StrategyName = &v
	return s
}

type AddDnsGtmAccessStrategyRequestDefaultAddrPool struct {
	// The ID of the address pool in the primary address pool group.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The weight of the address pool in the primary address pool group.
	LbaWeight *int32 `json:"LbaWeight,omitempty" xml:"LbaWeight,omitempty"`
}

func (s AddDnsGtmAccessStrategyRequestDefaultAddrPool) String() string {
	return tea.Prettify(s)
}

func (s AddDnsGtmAccessStrategyRequestDefaultAddrPool) GoString() string {
	return s.String()
}

func (s *AddDnsGtmAccessStrategyRequestDefaultAddrPool) SetId(v string) *AddDnsGtmAccessStrategyRequestDefaultAddrPool {
	s.Id = &v
	return s
}

func (s *AddDnsGtmAccessStrategyRequestDefaultAddrPool) SetLbaWeight(v int32) *AddDnsGtmAccessStrategyRequestDefaultAddrPool {
	s.LbaWeight = &v
	return s
}

type AddDnsGtmAccessStrategyRequestFailoverAddrPool struct {
	// The ID of the address pool in the secondary address pool group.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The weight of the address pool in the secondary address pool group.
	LbaWeight *int32 `json:"LbaWeight,omitempty" xml:"LbaWeight,omitempty"`
}

func (s AddDnsGtmAccessStrategyRequestFailoverAddrPool) String() string {
	return tea.Prettify(s)
}

func (s AddDnsGtmAccessStrategyRequestFailoverAddrPool) GoString() string {
	return s.String()
}

func (s *AddDnsGtmAccessStrategyRequestFailoverAddrPool) SetId(v string) *AddDnsGtmAccessStrategyRequestFailoverAddrPool {
	s.Id = &v
	return s
}

func (s *AddDnsGtmAccessStrategyRequestFailoverAddrPool) SetLbaWeight(v int32) *AddDnsGtmAccessStrategyRequestFailoverAddrPool {
	s.LbaWeight = &v
	return s
}

type AddDnsGtmAccessStrategyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the access policy.
	StrategyId *string `json:"StrategyId,omitempty" xml:"StrategyId,omitempty"`
}

func (s AddDnsGtmAccessStrategyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddDnsGtmAccessStrategyResponseBody) GoString() string {
	return s.String()
}

func (s *AddDnsGtmAccessStrategyResponseBody) SetRequestId(v string) *AddDnsGtmAccessStrategyResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddDnsGtmAccessStrategyResponseBody) SetStrategyId(v string) *AddDnsGtmAccessStrategyResponseBody {
	s.StrategyId = &v
	return s
}

type AddDnsGtmAccessStrategyResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddDnsGtmAccessStrategyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddDnsGtmAccessStrategyResponse) String() string {
	return tea.Prettify(s)
}

func (s AddDnsGtmAccessStrategyResponse) GoString() string {
	return s.String()
}

func (s *AddDnsGtmAccessStrategyResponse) SetHeaders(v map[string]*string) *AddDnsGtmAccessStrategyResponse {
	s.Headers = v
	return s
}

func (s *AddDnsGtmAccessStrategyResponse) SetStatusCode(v int32) *AddDnsGtmAccessStrategyResponse {
	s.StatusCode = &v
	return s
}

func (s *AddDnsGtmAccessStrategyResponse) SetBody(v *AddDnsGtmAccessStrategyResponseBody) *AddDnsGtmAccessStrategyResponse {
	s.Body = v
	return s
}

type AddDnsGtmAddressPoolRequest struct {
	// The addresses in the address pool.
	Addr []*AddDnsGtmAddressPoolRequestAddr `json:"Addr,omitempty" xml:"Addr,omitempty" type:"Repeated"`
	// The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.
	EvaluationCount *int32 `json:"EvaluationCount,omitempty" xml:"EvaluationCount,omitempty"`
	// The ID of the GTM instance for which you want to create an address pool.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The health check interval. Unit: seconds.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The monitored nodes.
	IspCityNode []*AddDnsGtmAddressPoolRequestIspCityNode `json:"IspCityNode,omitempty" xml:"IspCityNode,omitempty" type:"Repeated"`
	// The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The load balancing policy for the address pool. Valid values:
	//
	// *   ALL_RR: returns all addresses.
	// *   RATIO: returns addresses by weight.
	LbaStrategy *string `json:"LbaStrategy,omitempty" xml:"LbaStrategy,omitempty"`
	// The extended information, that is, the parameters required for the protocol. Different protocols require different parameters:
	//
	// *   HTTP or HTTPS:
	//
	//     *   port: the port to check.
	//
	//     *   host: the host configuration.
	//
	//     *   path: the health check URL.
	//
	//     *   code: the status code threshold. If the returned status code is greater than the specified threshold, the application service is deemed abnormal.
	//
	//     *   failureRate: the failure rate.
	//
	//     *   sni: specifies whether to enable Server Name Indication (SNI). This parameter is only required for the HTTPS protocol. Valid values:
	//
	//         *   true: enables SNI.
	//         *   Other value: disables SNI.
	//
	//     *   nodeType: the type of the monitored node when the address pool type is DOMAIN. Valid values:
	//
	//         *   IPV4
	//         *   IPV6
	//
	// *   PING:
	//
	//     *   failureRate: the failure rate.
	//
	//     *   packetNum: the number of ping packets.
	//
	//     *   packetLossRate: the loss rate of ping packets.
	//
	//     *   nodeType: the type of the monitored node when the address pool type is DOMAIN. Valid values:
	//
	//         *   IPV4
	//         *   IPV6
	//
	// *   TCP:
	//
	//     *   port: the port to check.
	//
	//     *   failureRate: the failure rate.
	//
	//     *   nodeType: the type of the monitored node when the address pool type is DOMAIN. Valid values:
	//
	//         *   IPV4
	//         *   IPV6
	MonitorExtendInfo *string `json:"MonitorExtendInfo,omitempty" xml:"MonitorExtendInfo,omitempty"`
	// Specifies whether to enable the health check. If this parameter is set to OPEN, the system validates the health check configuration. If this parameter is set to CLOSE, the health check configuration is discarded. Default value: CLOSE. Valid values:
	//
	// *   OPEN: enables the health check.
	// *   CLOSE: disables the health check.
	MonitorStatus *string `json:"MonitorStatus,omitempty" xml:"MonitorStatus,omitempty"`
	// The name of the address pool that you want to create.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The protocol used for the health check. Valid values:
	//
	// *   HTTP
	// *   HTTPS
	// *   PING
	// *   TCP
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The health check timeout period. Unit: milliseconds.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	// The type of the address pool. Valid values:
	//
	// *   IPV4: IPv4 address
	// *   IPV6: IPv6 address
	// *   DOMAIN: domain name
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s AddDnsGtmAddressPoolRequest) String() string {
	return tea.Prettify(s)
}

func (s AddDnsGtmAddressPoolRequest) GoString() string {
	return s.String()
}

func (s *AddDnsGtmAddressPoolRequest) SetAddr(v []*AddDnsGtmAddressPoolRequestAddr) *AddDnsGtmAddressPoolRequest {
	s.Addr = v
	return s
}

func (s *AddDnsGtmAddressPoolRequest) SetEvaluationCount(v int32) *AddDnsGtmAddressPoolRequest {
	s.EvaluationCount = &v
	return s
}

func (s *AddDnsGtmAddressPoolRequest) SetInstanceId(v string) *AddDnsGtmAddressPoolRequest {
	s.InstanceId = &v
	return s
}

func (s *AddDnsGtmAddressPoolRequest) SetInterval(v int32) *AddDnsGtmAddressPoolRequest {
	s.Interval = &v
	return s
}

func (s *AddDnsGtmAddressPoolRequest) SetIspCityNode(v []*AddDnsGtmAddressPoolRequestIspCityNode) *AddDnsGtmAddressPoolRequest {
	s.IspCityNode = v
	return s
}

func (s *AddDnsGtmAddressPoolRequest) SetLang(v string) *AddDnsGtmAddressPoolRequest {
	s.Lang = &v
	return s
}

func (s *AddDnsGtmAddressPoolRequest) SetLbaStrategy(v string) *AddDnsGtmAddressPoolRequest {
	s.LbaStrategy = &v
	return s
}

func (s *AddDnsGtmAddressPoolRequest) SetMonitorExtendInfo(v string) *AddDnsGtmAddressPoolRequest {
	s.MonitorExtendInfo = &v
	return s
}

func (s *AddDnsGtmAddressPoolRequest) SetMonitorStatus(v string) *AddDnsGtmAddressPoolRequest {
	s.MonitorStatus = &v
	return s
}

func (s *AddDnsGtmAddressPoolRequest) SetName(v string) *AddDnsGtmAddressPoolRequest {
	s.Name = &v
	return s
}

func (s *AddDnsGtmAddressPoolRequest) SetProtocolType(v string) *AddDnsGtmAddressPoolRequest {
	s.ProtocolType = &v
	return s
}

func (s *AddDnsGtmAddressPoolRequest) SetTimeout(v int32) *AddDnsGtmAddressPoolRequest {
	s.Timeout = &v
	return s
}

func (s *AddDnsGtmAddressPoolRequest) SetType(v string) *AddDnsGtmAddressPoolRequest {
	s.Type = &v
	return s
}

type AddDnsGtmAddressPoolRequestAddr struct {
	// The address.
	Addr *string `json:"Addr,omitempty" xml:"Addr,omitempty"`
	// The source region of the address. The value is a JSON string.
	//
	// *   lineCode: the line code of the source region of the address.
	//
	// *   lineCodeRectifyType: the rectification type of the line code. Default value: AUTO. Valid values:
	//
	//     *   NO_NEED: no need for rectification
	//     *   RECTIFIED: rectified
	//     *   AUTO: automatic rectification
	AttributeInfo *string `json:"AttributeInfo,omitempty" xml:"AttributeInfo,omitempty"`
	// The weight of the address.
	LbaWeight *int32 `json:"LbaWeight,omitempty" xml:"LbaWeight,omitempty"`
	// The mode of the address. Valid values:
	//
	// *   SMART: smart return
	// *   ONLINE: always online
	// *   OFFLINE: always offline
	Mode *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The description of the address.
	Remark *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
}

func (s AddDnsGtmAddressPoolRequestAddr) String() string {
	return tea.Prettify(s)
}

func (s AddDnsGtmAddressPoolRequestAddr) GoString() string {
	return s.String()
}

func (s *AddDnsGtmAddressPoolRequestAddr) SetAddr(v string) *AddDnsGtmAddressPoolRequestAddr {
	s.Addr = &v
	return s
}

func (s *AddDnsGtmAddressPoolRequestAddr) SetAttributeInfo(v string) *AddDnsGtmAddressPoolRequestAddr {
	s.AttributeInfo = &v
	return s
}

func (s *AddDnsGtmAddressPoolRequestAddr) SetLbaWeight(v int32) *AddDnsGtmAddressPoolRequestAddr {
	s.LbaWeight = &v
	return s
}

func (s *AddDnsGtmAddressPoolRequestAddr) SetMode(v string) *AddDnsGtmAddressPoolRequestAddr {
	s.Mode = &v
	return s
}

func (s *AddDnsGtmAddressPoolRequestAddr) SetRemark(v string) *AddDnsGtmAddressPoolRequestAddr {
	s.Remark = &v
	return s
}

type AddDnsGtmAddressPoolRequestIspCityNode struct {
	// The code of the city where the monitored node is deployed.
	CityCode *string `json:"CityCode,omitempty" xml:"CityCode,omitempty"`
	// The code of the Internet service provider (ISP) to which the monitored node belongs.
	IspCode *string `json:"IspCode,omitempty" xml:"IspCode,omitempty"`
}

func (s AddDnsGtmAddressPoolRequestIspCityNode) String() string {
	return tea.Prettify(s)
}

func (s AddDnsGtmAddressPoolRequestIspCityNode) GoString() string {
	return s.String()
}

func (s *AddDnsGtmAddressPoolRequestIspCityNode) SetCityCode(v string) *AddDnsGtmAddressPoolRequestIspCityNode {
	s.CityCode = &v
	return s
}

func (s *AddDnsGtmAddressPoolRequestIspCityNode) SetIspCode(v string) *AddDnsGtmAddressPoolRequestIspCityNode {
	s.IspCode = &v
	return s
}

type AddDnsGtmAddressPoolResponseBody struct {
	// The ID of the address pool created.
	AddrPoolId *string `json:"AddrPoolId,omitempty" xml:"AddrPoolId,omitempty"`
	// The ID of the health check configuration.
	MonitorConfigId *string `json:"MonitorConfigId,omitempty" xml:"MonitorConfigId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddDnsGtmAddressPoolResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddDnsGtmAddressPoolResponseBody) GoString() string {
	return s.String()
}

func (s *AddDnsGtmAddressPoolResponseBody) SetAddrPoolId(v string) *AddDnsGtmAddressPoolResponseBody {
	s.AddrPoolId = &v
	return s
}

func (s *AddDnsGtmAddressPoolResponseBody) SetMonitorConfigId(v string) *AddDnsGtmAddressPoolResponseBody {
	s.MonitorConfigId = &v
	return s
}

func (s *AddDnsGtmAddressPoolResponseBody) SetRequestId(v string) *AddDnsGtmAddressPoolResponseBody {
	s.RequestId = &v
	return s
}

type AddDnsGtmAddressPoolResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddDnsGtmAddressPoolResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddDnsGtmAddressPoolResponse) String() string {
	return tea.Prettify(s)
}

func (s AddDnsGtmAddressPoolResponse) GoString() string {
	return s.String()
}

func (s *AddDnsGtmAddressPoolResponse) SetHeaders(v map[string]*string) *AddDnsGtmAddressPoolResponse {
	s.Headers = v
	return s
}

func (s *AddDnsGtmAddressPoolResponse) SetStatusCode(v int32) *AddDnsGtmAddressPoolResponse {
	s.StatusCode = &v
	return s
}

func (s *AddDnsGtmAddressPoolResponse) SetBody(v *AddDnsGtmAddressPoolResponseBody) *AddDnsGtmAddressPoolResponse {
	s.Body = v
	return s
}

type AddDnsGtmMonitorRequest struct {
	// The ID of the address pool.
	AddrPoolId *string `json:"AddrPoolId,omitempty" xml:"AddrPoolId,omitempty"`
	// The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.
	EvaluationCount *int32 `json:"EvaluationCount,omitempty" xml:"EvaluationCount,omitempty"`
	// The health check interval. Unit: seconds.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The monitored nodes.
	IspCityNode []*AddDnsGtmMonitorRequestIspCityNode `json:"IspCityNode,omitempty" xml:"IspCityNode,omitempty" type:"Repeated"`
	// The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The extended information, that is, the parameters required for the protocol. Different protocols require different parameters:
	//
	// *   HTTP or HTTPS:
	//
	//     *   port: the port to check.
	//
	//     *   host: the host configuration.
	//
	//     *   path: the health check URL.
	//
	//     *   code: the status code threshold. If the returned status code is greater than the specified threshold, the application service is deemed abnormal.
	//
	//     *   failureRate: the failure rate.
	//
	//     *   sni: specifies whether to enable Server Name Indication (SNI). This parameter is only required for the HTTPS protocol. Valid values:
	//
	//         *   true: enables SNI.
	//         *   false: disables SNI.
	//
	//     *   nodeType: the type of the monitored node when the address pool type is DOMAIN. Valid values:
	//
	//         *   IPV4
	//         *   IPV6
	//
	// *   PING:
	//
	//     *   failureRate: the failure rate.
	//
	//     *   packetNum: the number of ping packets.
	//
	//     *   packetLossRate: the loss rate of ping packets.
	//
	//     *   nodeType: the type of the monitored node when the address pool type is DOMAIN. Valid values:
	//
	//         *   IPV4
	//         *   IPV6
	//
	// *   TCP:
	//
	//     *   port: the port to check.
	//
	//     *   failureRate: the failure rate.
	//
	//     *   nodeType: the type of the monitored node when the address pool type is DOMAIN. Valid values:
	//
	//         *   IPV4
	//         *   IPV6
	MonitorExtendInfo *string `json:"MonitorExtendInfo,omitempty" xml:"MonitorExtendInfo,omitempty"`
	// The protocol used for the health check. Valid values:
	//
	// *   HTTP
	// *   HTTPS
	// *   PING
	// *   TCP
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The health check timeout period. Unit: milliseconds.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
}

func (s AddDnsGtmMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s AddDnsGtmMonitorRequest) GoString() string {
	return s.String()
}

func (s *AddDnsGtmMonitorRequest) SetAddrPoolId(v string) *AddDnsGtmMonitorRequest {
	s.AddrPoolId = &v
	return s
}

func (s *AddDnsGtmMonitorRequest) SetEvaluationCount(v int32) *AddDnsGtmMonitorRequest {
	s.EvaluationCount = &v
	return s
}

func (s *AddDnsGtmMonitorRequest) SetInterval(v int32) *AddDnsGtmMonitorRequest {
	s.Interval = &v
	return s
}

func (s *AddDnsGtmMonitorRequest) SetIspCityNode(v []*AddDnsGtmMonitorRequestIspCityNode) *AddDnsGtmMonitorRequest {
	s.IspCityNode = v
	return s
}

func (s *AddDnsGtmMonitorRequest) SetLang(v string) *AddDnsGtmMonitorRequest {
	s.Lang = &v
	return s
}

func (s *AddDnsGtmMonitorRequest) SetMonitorExtendInfo(v string) *AddDnsGtmMonitorRequest {
	s.MonitorExtendInfo = &v
	return s
}

func (s *AddDnsGtmMonitorRequest) SetProtocolType(v string) *AddDnsGtmMonitorRequest {
	s.ProtocolType = &v
	return s
}

func (s *AddDnsGtmMonitorRequest) SetTimeout(v int32) *AddDnsGtmMonitorRequest {
	s.Timeout = &v
	return s
}

type AddDnsGtmMonitorRequestIspCityNode struct {
	// The code of the city where the monitored node is deployed.
	CityCode *string `json:"CityCode,omitempty" xml:"CityCode,omitempty"`
	// The code of the Internet service provider (ISP) to which the monitored node belongs.
	IspCode *string `json:"IspCode,omitempty" xml:"IspCode,omitempty"`
}

func (s AddDnsGtmMonitorRequestIspCityNode) String() string {
	return tea.Prettify(s)
}

func (s AddDnsGtmMonitorRequestIspCityNode) GoString() string {
	return s.String()
}

func (s *AddDnsGtmMonitorRequestIspCityNode) SetCityCode(v string) *AddDnsGtmMonitorRequestIspCityNode {
	s.CityCode = &v
	return s
}

func (s *AddDnsGtmMonitorRequestIspCityNode) SetIspCode(v string) *AddDnsGtmMonitorRequestIspCityNode {
	s.IspCode = &v
	return s
}

type AddDnsGtmMonitorResponseBody struct {
	// The ID of the health check configuration.
	MonitorConfigId *string `json:"MonitorConfigId,omitempty" xml:"MonitorConfigId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddDnsGtmMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddDnsGtmMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *AddDnsGtmMonitorResponseBody) SetMonitorConfigId(v string) *AddDnsGtmMonitorResponseBody {
	s.MonitorConfigId = &v
	return s
}

func (s *AddDnsGtmMonitorResponseBody) SetRequestId(v string) *AddDnsGtmMonitorResponseBody {
	s.RequestId = &v
	return s
}

type AddDnsGtmMonitorResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddDnsGtmMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddDnsGtmMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s AddDnsGtmMonitorResponse) GoString() string {
	return s.String()
}

func (s *AddDnsGtmMonitorResponse) SetHeaders(v map[string]*string) *AddDnsGtmMonitorResponse {
	s.Headers = v
	return s
}

func (s *AddDnsGtmMonitorResponse) SetStatusCode(v int32) *AddDnsGtmMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *AddDnsGtmMonitorResponse) SetBody(v *AddDnsGtmMonitorResponseBody) *AddDnsGtmMonitorResponse {
	s.Body = v
	return s
}

type AddDomainRequest struct {
	// The domain name to be added.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The ID of the domain name group. The default value is the ID of the default domain name group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The language of the domain name.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s AddDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s AddDomainRequest) GoString() string {
	return s.String()
}

func (s *AddDomainRequest) SetDomainName(v string) *AddDomainRequest {
	s.DomainName = &v
	return s
}

func (s *AddDomainRequest) SetGroupId(v string) *AddDomainRequest {
	s.GroupId = &v
	return s
}

func (s *AddDomainRequest) SetLang(v string) *AddDomainRequest {
	s.Lang = &v
	return s
}

func (s *AddDomainRequest) SetResourceGroupId(v string) *AddDomainRequest {
	s.ResourceGroupId = &v
	return s
}

type AddDomainResponseBody struct {
	// The Domain Name System (DNS) servers that resolve the domain name.
	DnsServers *AddDomainResponseBodyDnsServers `json:"DnsServers,omitempty" xml:"DnsServers,omitempty" type:"Struct"`
	// The ID of the domain name.
	DomainId *string `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The ID of the domain name group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the domain name group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The Punycode for the domain name. This parameter is returned only for Chinese domain names.
	PunyCode *string `json:"PunyCode,omitempty" xml:"PunyCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddDomainResponseBody) GoString() string {
	return s.String()
}

func (s *AddDomainResponseBody) SetDnsServers(v *AddDomainResponseBodyDnsServers) *AddDomainResponseBody {
	s.DnsServers = v
	return s
}

func (s *AddDomainResponseBody) SetDomainId(v string) *AddDomainResponseBody {
	s.DomainId = &v
	return s
}

func (s *AddDomainResponseBody) SetDomainName(v string) *AddDomainResponseBody {
	s.DomainName = &v
	return s
}

func (s *AddDomainResponseBody) SetGroupId(v string) *AddDomainResponseBody {
	s.GroupId = &v
	return s
}

func (s *AddDomainResponseBody) SetGroupName(v string) *AddDomainResponseBody {
	s.GroupName = &v
	return s
}

func (s *AddDomainResponseBody) SetPunyCode(v string) *AddDomainResponseBody {
	s.PunyCode = &v
	return s
}

func (s *AddDomainResponseBody) SetRequestId(v string) *AddDomainResponseBody {
	s.RequestId = &v
	return s
}

type AddDomainResponseBodyDnsServers struct {
	DnsServer []*string `json:"DnsServer,omitempty" xml:"DnsServer,omitempty" type:"Repeated"`
}

func (s AddDomainResponseBodyDnsServers) String() string {
	return tea.Prettify(s)
}

func (s AddDomainResponseBodyDnsServers) GoString() string {
	return s.String()
}

func (s *AddDomainResponseBodyDnsServers) SetDnsServer(v []*string) *AddDomainResponseBodyDnsServers {
	s.DnsServer = v
	return s
}

type AddDomainResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s AddDomainResponse) GoString() string {
	return s.String()
}

func (s *AddDomainResponse) SetHeaders(v map[string]*string) *AddDomainResponse {
	s.Headers = v
	return s
}

func (s *AddDomainResponse) SetStatusCode(v int32) *AddDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *AddDomainResponse) SetBody(v *AddDomainResponseBody) *AddDomainResponse {
	s.Body = v
	return s
}

type AddDomainBackupRequest struct {
	// The domain name for which you want to create a backup task.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The backup cycle. Valid values:
	//
	// *   **DAY**: Backs up data once every day.
	// *   **HOUR**: Backs up data once every hour.
	PeriodType *string `json:"PeriodType,omitempty" xml:"PeriodType,omitempty"`
}

func (s AddDomainBackupRequest) String() string {
	return tea.Prettify(s)
}

func (s AddDomainBackupRequest) GoString() string {
	return s.String()
}

func (s *AddDomainBackupRequest) SetDomainName(v string) *AddDomainBackupRequest {
	s.DomainName = &v
	return s
}

func (s *AddDomainBackupRequest) SetLang(v string) *AddDomainBackupRequest {
	s.Lang = &v
	return s
}

func (s *AddDomainBackupRequest) SetPeriodType(v string) *AddDomainBackupRequest {
	s.PeriodType = &v
	return s
}

type AddDomainBackupResponseBody struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The backup cycle.
	PeriodType *string `json:"PeriodType,omitempty" xml:"PeriodType,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddDomainBackupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddDomainBackupResponseBody) GoString() string {
	return s.String()
}

func (s *AddDomainBackupResponseBody) SetDomainName(v string) *AddDomainBackupResponseBody {
	s.DomainName = &v
	return s
}

func (s *AddDomainBackupResponseBody) SetPeriodType(v string) *AddDomainBackupResponseBody {
	s.PeriodType = &v
	return s
}

func (s *AddDomainBackupResponseBody) SetRequestId(v string) *AddDomainBackupResponseBody {
	s.RequestId = &v
	return s
}

type AddDomainBackupResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddDomainBackupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddDomainBackupResponse) String() string {
	return tea.Prettify(s)
}

func (s AddDomainBackupResponse) GoString() string {
	return s.String()
}

func (s *AddDomainBackupResponse) SetHeaders(v map[string]*string) *AddDomainBackupResponse {
	s.Headers = v
	return s
}

func (s *AddDomainBackupResponse) SetStatusCode(v int32) *AddDomainBackupResponse {
	s.StatusCode = &v
	return s
}

func (s *AddDomainBackupResponse) SetBody(v *AddDomainBackupResponseBody) *AddDomainBackupResponse {
	s.Body = v
	return s
}

type AddDomainGroupRequest struct {
	// The name of the domain name group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s AddDomainGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s AddDomainGroupRequest) GoString() string {
	return s.String()
}

func (s *AddDomainGroupRequest) SetGroupName(v string) *AddDomainGroupRequest {
	s.GroupName = &v
	return s
}

func (s *AddDomainGroupRequest) SetLang(v string) *AddDomainGroupRequest {
	s.Lang = &v
	return s
}

type AddDomainGroupResponseBody struct {
	// The ID of the domain name group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the domain name group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddDomainGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddDomainGroupResponseBody) GoString() string {
	return s.String()
}

func (s *AddDomainGroupResponseBody) SetGroupId(v string) *AddDomainGroupResponseBody {
	s.GroupId = &v
	return s
}

func (s *AddDomainGroupResponseBody) SetGroupName(v string) *AddDomainGroupResponseBody {
	s.GroupName = &v
	return s
}

func (s *AddDomainGroupResponseBody) SetRequestId(v string) *AddDomainGroupResponseBody {
	s.RequestId = &v
	return s
}

type AddDomainGroupResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddDomainGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddDomainGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s AddDomainGroupResponse) GoString() string {
	return s.String()
}

func (s *AddDomainGroupResponse) SetHeaders(v map[string]*string) *AddDomainGroupResponse {
	s.Headers = v
	return s
}

func (s *AddDomainGroupResponse) SetStatusCode(v int32) *AddDomainGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *AddDomainGroupResponse) SetBody(v *AddDomainGroupResponseBody) *AddDomainGroupResponse {
	s.Body = v
	return s
}

type AddDomainRecordRequest struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The resolution line. Default value: **default**.
	Line *string `json:"Line,omitempty" xml:"Line,omitempty"`
	// The priority of an MX-type DNS record. Valid values: `[1,50]`.
	//
	// This parameter must be specified if the type of the DNS record is MX. A smaller value indicates a higher priority.
	Priority *int64 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The host record.
	//
	// For example, to resolve @.example.com, you must set RR to an at sign (@) instead of leaving it blank.
	RR *string `json:"RR,omitempty" xml:"RR,omitempty"`
	// The TTL of the resolution. Default value: 600. Unit: seconds.
	TTL *int64 `json:"TTL,omitempty" xml:"TTL,omitempty"`
	// The type of the DNS record. DNS record types
	//
	// [dns records types](https://www.alibabacloud.com/help/en/alibaba-cloud-dns/latest/dns-record-types)
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The IP address of the client.
	UserClientIp *string `json:"UserClientIp,omitempty" xml:"UserClientIp,omitempty"`
	// The value of the DNS record.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s AddDomainRecordRequest) String() string {
	return tea.Prettify(s)
}

func (s AddDomainRecordRequest) GoString() string {
	return s.String()
}

func (s *AddDomainRecordRequest) SetDomainName(v string) *AddDomainRecordRequest {
	s.DomainName = &v
	return s
}

func (s *AddDomainRecordRequest) SetLang(v string) *AddDomainRecordRequest {
	s.Lang = &v
	return s
}

func (s *AddDomainRecordRequest) SetLine(v string) *AddDomainRecordRequest {
	s.Line = &v
	return s
}

func (s *AddDomainRecordRequest) SetPriority(v int64) *AddDomainRecordRequest {
	s.Priority = &v
	return s
}

func (s *AddDomainRecordRequest) SetRR(v string) *AddDomainRecordRequest {
	s.RR = &v
	return s
}

func (s *AddDomainRecordRequest) SetTTL(v int64) *AddDomainRecordRequest {
	s.TTL = &v
	return s
}

func (s *AddDomainRecordRequest) SetType(v string) *AddDomainRecordRequest {
	s.Type = &v
	return s
}

func (s *AddDomainRecordRequest) SetUserClientIp(v string) *AddDomainRecordRequest {
	s.UserClientIp = &v
	return s
}

func (s *AddDomainRecordRequest) SetValue(v string) *AddDomainRecordRequest {
	s.Value = &v
	return s
}

type AddDomainRecordResponseBody struct {
	// The ID of the DNS record.
	RecordId *string `json:"RecordId,omitempty" xml:"RecordId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddDomainRecordResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddDomainRecordResponseBody) GoString() string {
	return s.String()
}

func (s *AddDomainRecordResponseBody) SetRecordId(v string) *AddDomainRecordResponseBody {
	s.RecordId = &v
	return s
}

func (s *AddDomainRecordResponseBody) SetRequestId(v string) *AddDomainRecordResponseBody {
	s.RequestId = &v
	return s
}

type AddDomainRecordResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddDomainRecordResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddDomainRecordResponse) String() string {
	return tea.Prettify(s)
}

func (s AddDomainRecordResponse) GoString() string {
	return s.String()
}

func (s *AddDomainRecordResponse) SetHeaders(v map[string]*string) *AddDomainRecordResponse {
	s.Headers = v
	return s
}

func (s *AddDomainRecordResponse) SetStatusCode(v int32) *AddDomainRecordResponse {
	s.StatusCode = &v
	return s
}

func (s *AddDomainRecordResponse) SetBody(v *AddDomainRecordResponseBody) *AddDomainRecordResponse {
	s.Body = v
	return s
}

type AddGtmAccessStrategyRequest struct {
	// The line codes of access regions.
	AccessLines *string `json:"AccessLines,omitempty" xml:"AccessLines,omitempty"`
	// The ID of the default address pool.
	DefaultAddrPoolId *string `json:"DefaultAddrPoolId,omitempty" xml:"DefaultAddrPoolId,omitempty"`
	// The ID of the failover address pool.
	//
	// If the failover address pool is not set, pass the **Empty** value.
	FailoverAddrPoolId *string `json:"FailoverAddrPoolId,omitempty" xml:"FailoverAddrPoolId,omitempty"`
	// The ID of the GTM instance for which you want to create an access policy.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The language used by the user.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The name of the access policy.
	StrategyName *string `json:"StrategyName,omitempty" xml:"StrategyName,omitempty"`
}

func (s AddGtmAccessStrategyRequest) String() string {
	return tea.Prettify(s)
}

func (s AddGtmAccessStrategyRequest) GoString() string {
	return s.String()
}

func (s *AddGtmAccessStrategyRequest) SetAccessLines(v string) *AddGtmAccessStrategyRequest {
	s.AccessLines = &v
	return s
}

func (s *AddGtmAccessStrategyRequest) SetDefaultAddrPoolId(v string) *AddGtmAccessStrategyRequest {
	s.DefaultAddrPoolId = &v
	return s
}

func (s *AddGtmAccessStrategyRequest) SetFailoverAddrPoolId(v string) *AddGtmAccessStrategyRequest {
	s.FailoverAddrPoolId = &v
	return s
}

func (s *AddGtmAccessStrategyRequest) SetInstanceId(v string) *AddGtmAccessStrategyRequest {
	s.InstanceId = &v
	return s
}

func (s *AddGtmAccessStrategyRequest) SetLang(v string) *AddGtmAccessStrategyRequest {
	s.Lang = &v
	return s
}

func (s *AddGtmAccessStrategyRequest) SetStrategyName(v string) *AddGtmAccessStrategyRequest {
	s.StrategyName = &v
	return s
}

type AddGtmAccessStrategyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the access policy created.
	StrategyId *string `json:"StrategyId,omitempty" xml:"StrategyId,omitempty"`
}

func (s AddGtmAccessStrategyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddGtmAccessStrategyResponseBody) GoString() string {
	return s.String()
}

func (s *AddGtmAccessStrategyResponseBody) SetRequestId(v string) *AddGtmAccessStrategyResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddGtmAccessStrategyResponseBody) SetStrategyId(v string) *AddGtmAccessStrategyResponseBody {
	s.StrategyId = &v
	return s
}

type AddGtmAccessStrategyResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddGtmAccessStrategyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddGtmAccessStrategyResponse) String() string {
	return tea.Prettify(s)
}

func (s AddGtmAccessStrategyResponse) GoString() string {
	return s.String()
}

func (s *AddGtmAccessStrategyResponse) SetHeaders(v map[string]*string) *AddGtmAccessStrategyResponse {
	s.Headers = v
	return s
}

func (s *AddGtmAccessStrategyResponse) SetStatusCode(v int32) *AddGtmAccessStrategyResponse {
	s.StatusCode = &v
	return s
}

func (s *AddGtmAccessStrategyResponse) SetBody(v *AddGtmAccessStrategyResponseBody) *AddGtmAccessStrategyResponse {
	s.Body = v
	return s
}

type AddGtmAddressPoolRequest struct {
	// The addresses in the address pool.
	Addr []*AddGtmAddressPoolRequestAddr `json:"Addr,omitempty" xml:"Addr,omitempty" type:"Repeated"`
	// The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.
	EvaluationCount *int32 `json:"EvaluationCount,omitempty" xml:"EvaluationCount,omitempty"`
	// The ID of the GTM instance for which you want to create an address pool.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The health check interval. Unit: seconds. Set the value to 60.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The monitored nodes.
	IspCityNode []*AddGtmAddressPoolRequestIspCityNode `json:"IspCityNode,omitempty" xml:"IspCityNode,omitempty" type:"Repeated"`
	// The language of the values of specific response parameters.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The minimum number of available addresses in the address pool.
	MinAvailableAddrNum *int32 `json:"MinAvailableAddrNum,omitempty" xml:"MinAvailableAddrNum,omitempty"`
	// The extended information, that is, the parameters required for the protocol. Different protocols require different parameters:
	//
	// HTTP or HTTPS:
	//
	// *   port: the port to check.
	// *   failureRate: the failure rate.
	// *   code: the status code threshold. If the returned status code is greater than the specified threshold, the application service is deemed abnormal. Valid values: 400 and 500.
	// *   host: the host configuration.
	// *   path: the health check URL.
	//
	// PING:
	//
	// *   packetNum: the number of ping packets.
	// *   packetLossRate: the loss rate of ping packets.
	// *   failureRate: the failure rate.
	//
	// TCP:
	//
	// *   port: the port to check.
	// *   failureRate: the failure rate.
	MonitorExtendInfo *string `json:"MonitorExtendInfo,omitempty" xml:"MonitorExtendInfo,omitempty"`
	// Specifies whether to enable the health check. Valid values:
	//
	// *   **OPEN**: enables the health check.
	// *   **CLOSE**: disables the health check. This is the default value.
	MonitorStatus *string `json:"MonitorStatus,omitempty" xml:"MonitorStatus,omitempty"`
	// The name of the address pool that you want to create.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The protocol used for the health check. Valid values:
	//
	// *   HTTP
	// *   HTTPS
	// *   PING
	// *   TCP
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The health check timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	// The type of the address pool. Valid values:
	//
	// *   **IP**: IPv4 address
	// *   **DOMAIN**: domain name
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s AddGtmAddressPoolRequest) String() string {
	return tea.Prettify(s)
}

func (s AddGtmAddressPoolRequest) GoString() string {
	return s.String()
}

func (s *AddGtmAddressPoolRequest) SetAddr(v []*AddGtmAddressPoolRequestAddr) *AddGtmAddressPoolRequest {
	s.Addr = v
	return s
}

func (s *AddGtmAddressPoolRequest) SetEvaluationCount(v int32) *AddGtmAddressPoolRequest {
	s.EvaluationCount = &v
	return s
}

func (s *AddGtmAddressPoolRequest) SetInstanceId(v string) *AddGtmAddressPoolRequest {
	s.InstanceId = &v
	return s
}

func (s *AddGtmAddressPoolRequest) SetInterval(v int32) *AddGtmAddressPoolRequest {
	s.Interval = &v
	return s
}

func (s *AddGtmAddressPoolRequest) SetIspCityNode(v []*AddGtmAddressPoolRequestIspCityNode) *AddGtmAddressPoolRequest {
	s.IspCityNode = v
	return s
}

func (s *AddGtmAddressPoolRequest) SetLang(v string) *AddGtmAddressPoolRequest {
	s.Lang = &v
	return s
}

func (s *AddGtmAddressPoolRequest) SetMinAvailableAddrNum(v int32) *AddGtmAddressPoolRequest {
	s.MinAvailableAddrNum = &v
	return s
}

func (s *AddGtmAddressPoolRequest) SetMonitorExtendInfo(v string) *AddGtmAddressPoolRequest {
	s.MonitorExtendInfo = &v
	return s
}

func (s *AddGtmAddressPoolRequest) SetMonitorStatus(v string) *AddGtmAddressPoolRequest {
	s.MonitorStatus = &v
	return s
}

func (s *AddGtmAddressPoolRequest) SetName(v string) *AddGtmAddressPoolRequest {
	s.Name = &v
	return s
}

func (s *AddGtmAddressPoolRequest) SetProtocolType(v string) *AddGtmAddressPoolRequest {
	s.ProtocolType = &v
	return s
}

func (s *AddGtmAddressPoolRequest) SetTimeout(v int32) *AddGtmAddressPoolRequest {
	s.Timeout = &v
	return s
}

func (s *AddGtmAddressPoolRequest) SetType(v string) *AddGtmAddressPoolRequest {
	s.Type = &v
	return s
}

type AddGtmAddressPoolRequestAddr struct {
	// The weight of the address.
	LbaWeight *int32 `json:"LbaWeight,omitempty" xml:"LbaWeight,omitempty"`
	// The mode of the address. Valid values:
	//
	// *   **SMART**: smart return
	// *   **ONLINE**: always online
	// *   **OFFLINE**: always offline
	Mode *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The address.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s AddGtmAddressPoolRequestAddr) String() string {
	return tea.Prettify(s)
}

func (s AddGtmAddressPoolRequestAddr) GoString() string {
	return s.String()
}

func (s *AddGtmAddressPoolRequestAddr) SetLbaWeight(v int32) *AddGtmAddressPoolRequestAddr {
	s.LbaWeight = &v
	return s
}

func (s *AddGtmAddressPoolRequestAddr) SetMode(v string) *AddGtmAddressPoolRequestAddr {
	s.Mode = &v
	return s
}

func (s *AddGtmAddressPoolRequestAddr) SetValue(v string) *AddGtmAddressPoolRequestAddr {
	s.Value = &v
	return s
}

type AddGtmAddressPoolRequestIspCityNode struct {
	// The code of the city where the monitored node is deployed. For more information about specific values, see the response parameters of DescribeGtmMonitorAvailableConfig.
	CityCode *string `json:"CityCode,omitempty" xml:"CityCode,omitempty"`
	// *   The code of the Internet service provider (ISP) to which the monitored node belongs. For more information about specific values, see the response parameters of DescribeGtmMonitorAvailableConfig.
	// *   If the value of the GroupType parameter is BGP or OVERSEAS, IspCode is optional. The default value is 465.
	// *   If the value of the GroupType parameter is not BGP or OVERSEAS, IspCode is required and is used together with CityCode.
	IspCode *string `json:"IspCode,omitempty" xml:"IspCode,omitempty"`
}

func (s AddGtmAddressPoolRequestIspCityNode) String() string {
	return tea.Prettify(s)
}

func (s AddGtmAddressPoolRequestIspCityNode) GoString() string {
	return s.String()
}

func (s *AddGtmAddressPoolRequestIspCityNode) SetCityCode(v string) *AddGtmAddressPoolRequestIspCityNode {
	s.CityCode = &v
	return s
}

func (s *AddGtmAddressPoolRequestIspCityNode) SetIspCode(v string) *AddGtmAddressPoolRequestIspCityNode {
	s.IspCode = &v
	return s
}

type AddGtmAddressPoolResponseBody struct {
	// The ID of the address pool created.
	AddrPoolId *string `json:"AddrPoolId,omitempty" xml:"AddrPoolId,omitempty"`
	// The ID of the health check configuration.
	MonitorConfigId *string `json:"MonitorConfigId,omitempty" xml:"MonitorConfigId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddGtmAddressPoolResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddGtmAddressPoolResponseBody) GoString() string {
	return s.String()
}

func (s *AddGtmAddressPoolResponseBody) SetAddrPoolId(v string) *AddGtmAddressPoolResponseBody {
	s.AddrPoolId = &v
	return s
}

func (s *AddGtmAddressPoolResponseBody) SetMonitorConfigId(v string) *AddGtmAddressPoolResponseBody {
	s.MonitorConfigId = &v
	return s
}

func (s *AddGtmAddressPoolResponseBody) SetRequestId(v string) *AddGtmAddressPoolResponseBody {
	s.RequestId = &v
	return s
}

type AddGtmAddressPoolResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddGtmAddressPoolResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddGtmAddressPoolResponse) String() string {
	return tea.Prettify(s)
}

func (s AddGtmAddressPoolResponse) GoString() string {
	return s.String()
}

func (s *AddGtmAddressPoolResponse) SetHeaders(v map[string]*string) *AddGtmAddressPoolResponse {
	s.Headers = v
	return s
}

func (s *AddGtmAddressPoolResponse) SetStatusCode(v int32) *AddGtmAddressPoolResponse {
	s.StatusCode = &v
	return s
}

func (s *AddGtmAddressPoolResponse) SetBody(v *AddGtmAddressPoolResponseBody) *AddGtmAddressPoolResponse {
	s.Body = v
	return s
}

type AddGtmMonitorRequest struct {
	// The ID of the address pool.
	AddrPoolId *string `json:"AddrPoolId,omitempty" xml:"AddrPoolId,omitempty"`
	// The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.
	EvaluationCount *int32 `json:"EvaluationCount,omitempty" xml:"EvaluationCount,omitempty"`
	// The health check interval. Unit: seconds. Set the value to 60.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The monitored nodes.
	IspCityNode []*AddGtmMonitorRequestIspCityNode `json:"IspCityNode,omitempty" xml:"IspCityNode,omitempty" type:"Repeated"`
	// The language of the values of specific response parameters.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The extended information, that is, the parameters required for the protocol. Different protocols require different parameters:
	//
	// HTTP or HTTPS:
	//
	// *   port: the port to check.
	// *   failureRate: the failure rate.
	// *   code: the status code threshold. If the returned status code is greater than the specified threshold, the application service is deemed abnormal. Valid values: 400 and 500.
	// *   host: the host configuration.
	// *   path: the health check URL.
	//
	// PING:
	//
	// *   packetNum: the number of ping packets.
	// *   packetLossRate: the loss rate of ping packets.
	// *   failureRate: the failure rate.
	//
	// TCP:
	//
	// *   port: the port to check.
	// *   failureRate: the failure rate.
	MonitorExtendInfo *string `json:"MonitorExtendInfo,omitempty" xml:"MonitorExtendInfo,omitempty"`
	// The protocol used for the health check. Valid values:
	//
	// *   HTTP
	// *   HTTPS
	// *   PING
	// *   TCP
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The health check timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
}

func (s AddGtmMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s AddGtmMonitorRequest) GoString() string {
	return s.String()
}

func (s *AddGtmMonitorRequest) SetAddrPoolId(v string) *AddGtmMonitorRequest {
	s.AddrPoolId = &v
	return s
}

func (s *AddGtmMonitorRequest) SetEvaluationCount(v int32) *AddGtmMonitorRequest {
	s.EvaluationCount = &v
	return s
}

func (s *AddGtmMonitorRequest) SetInterval(v int32) *AddGtmMonitorRequest {
	s.Interval = &v
	return s
}

func (s *AddGtmMonitorRequest) SetIspCityNode(v []*AddGtmMonitorRequestIspCityNode) *AddGtmMonitorRequest {
	s.IspCityNode = v
	return s
}

func (s *AddGtmMonitorRequest) SetLang(v string) *AddGtmMonitorRequest {
	s.Lang = &v
	return s
}

func (s *AddGtmMonitorRequest) SetMonitorExtendInfo(v string) *AddGtmMonitorRequest {
	s.MonitorExtendInfo = &v
	return s
}

func (s *AddGtmMonitorRequest) SetProtocolType(v string) *AddGtmMonitorRequest {
	s.ProtocolType = &v
	return s
}

func (s *AddGtmMonitorRequest) SetTimeout(v int32) *AddGtmMonitorRequest {
	s.Timeout = &v
	return s
}

type AddGtmMonitorRequestIspCityNode struct {
	// The code of the city where the monitored node is deployed.
	//
	// For more information about specific values, see the response parameters of DescribeGtmMonitorAvailableConfig.
	CityCode *string `json:"CityCode,omitempty" xml:"CityCode,omitempty"`
	// The code of the Internet service provider (ISP) to which the monitored node belongs. For more information about specific values, see the response parameters of DescribeGtmMonitorAvailableConfig.
	//
	// *   If the value of the GroupType parameter is BGP or OVERSEAS, IspCode is optional. The default value is 465.
	// *   If the value of the GroupType parameter is not BGP or OVERSEAS, IspCode is required and is used together with CityCode.
	IspCode *string `json:"IspCode,omitempty" xml:"IspCode,omitempty"`
}

func (s AddGtmMonitorRequestIspCityNode) String() string {
	return tea.Prettify(s)
}

func (s AddGtmMonitorRequestIspCityNode) GoString() string {
	return s.String()
}

func (s *AddGtmMonitorRequestIspCityNode) SetCityCode(v string) *AddGtmMonitorRequestIspCityNode {
	s.CityCode = &v
	return s
}

func (s *AddGtmMonitorRequestIspCityNode) SetIspCode(v string) *AddGtmMonitorRequestIspCityNode {
	s.IspCode = &v
	return s
}

type AddGtmMonitorResponseBody struct {
	// The ID of the health check configuration.
	MonitorConfigId *string `json:"MonitorConfigId,omitempty" xml:"MonitorConfigId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddGtmMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddGtmMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *AddGtmMonitorResponseBody) SetMonitorConfigId(v string) *AddGtmMonitorResponseBody {
	s.MonitorConfigId = &v
	return s
}

func (s *AddGtmMonitorResponseBody) SetRequestId(v string) *AddGtmMonitorResponseBody {
	s.RequestId = &v
	return s
}

type AddGtmMonitorResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddGtmMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddGtmMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s AddGtmMonitorResponse) GoString() string {
	return s.String()
}

func (s *AddGtmMonitorResponse) SetHeaders(v map[string]*string) *AddGtmMonitorResponse {
	s.Headers = v
	return s
}

func (s *AddGtmMonitorResponse) SetStatusCode(v int32) *AddGtmMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *AddGtmMonitorResponse) SetBody(v *AddGtmMonitorResponseBody) *AddGtmMonitorResponse {
	s.Body = v
	return s
}

type AddGtmRecoveryPlanRequest struct {
	// The list of IDs of faulty address pools.
	FaultAddrPool *string `json:"FaultAddrPool,omitempty" xml:"FaultAddrPool,omitempty"`
	// The language used by the user.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The name of the disaster recovery plan that you want to create.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The remarks on the disaster recovery plan.
	Remark *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
}

func (s AddGtmRecoveryPlanRequest) String() string {
	return tea.Prettify(s)
}

func (s AddGtmRecoveryPlanRequest) GoString() string {
	return s.String()
}

func (s *AddGtmRecoveryPlanRequest) SetFaultAddrPool(v string) *AddGtmRecoveryPlanRequest {
	s.FaultAddrPool = &v
	return s
}

func (s *AddGtmRecoveryPlanRequest) SetLang(v string) *AddGtmRecoveryPlanRequest {
	s.Lang = &v
	return s
}

func (s *AddGtmRecoveryPlanRequest) SetName(v string) *AddGtmRecoveryPlanRequest {
	s.Name = &v
	return s
}

func (s *AddGtmRecoveryPlanRequest) SetRemark(v string) *AddGtmRecoveryPlanRequest {
	s.Remark = &v
	return s
}

type AddGtmRecoveryPlanResponseBody struct {
	// The ID of the disaster recovery plan created.
	RecoveryPlanId *string `json:"RecoveryPlanId,omitempty" xml:"RecoveryPlanId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddGtmRecoveryPlanResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddGtmRecoveryPlanResponseBody) GoString() string {
	return s.String()
}

func (s *AddGtmRecoveryPlanResponseBody) SetRecoveryPlanId(v string) *AddGtmRecoveryPlanResponseBody {
	s.RecoveryPlanId = &v
	return s
}

func (s *AddGtmRecoveryPlanResponseBody) SetRequestId(v string) *AddGtmRecoveryPlanResponseBody {
	s.RequestId = &v
	return s
}

type AddGtmRecoveryPlanResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddGtmRecoveryPlanResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddGtmRecoveryPlanResponse) String() string {
	return tea.Prettify(s)
}

func (s AddGtmRecoveryPlanResponse) GoString() string {
	return s.String()
}

func (s *AddGtmRecoveryPlanResponse) SetHeaders(v map[string]*string) *AddGtmRecoveryPlanResponse {
	s.Headers = v
	return s
}

func (s *AddGtmRecoveryPlanResponse) SetStatusCode(v int32) *AddGtmRecoveryPlanResponse {
	s.StatusCode = &v
	return s
}

func (s *AddGtmRecoveryPlanResponse) SetBody(v *AddGtmRecoveryPlanResponseBody) *AddGtmRecoveryPlanResponse {
	s.Body = v
	return s
}

type BindInstanceDomainsRequest struct {
	// The list of domain names.
	//
	// >  Separate multiple domain names with commas (,). A maximum of 100 domain names can be entered.
	DomainNames *string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s BindInstanceDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s BindInstanceDomainsRequest) GoString() string {
	return s.String()
}

func (s *BindInstanceDomainsRequest) SetDomainNames(v string) *BindInstanceDomainsRequest {
	s.DomainNames = &v
	return s
}

func (s *BindInstanceDomainsRequest) SetInstanceId(v string) *BindInstanceDomainsRequest {
	s.InstanceId = &v
	return s
}

func (s *BindInstanceDomainsRequest) SetLang(v string) *BindInstanceDomainsRequest {
	s.Lang = &v
	return s
}

type BindInstanceDomainsResponseBody struct {
	// The number of domain names that failed to be bound.
	FailedCount *int32 `json:"FailedCount,omitempty" xml:"FailedCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of domain names that have been bound.
	SuccessCount *int32 `json:"SuccessCount,omitempty" xml:"SuccessCount,omitempty"`
}

func (s BindInstanceDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BindInstanceDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *BindInstanceDomainsResponseBody) SetFailedCount(v int32) *BindInstanceDomainsResponseBody {
	s.FailedCount = &v
	return s
}

func (s *BindInstanceDomainsResponseBody) SetRequestId(v string) *BindInstanceDomainsResponseBody {
	s.RequestId = &v
	return s
}

func (s *BindInstanceDomainsResponseBody) SetSuccessCount(v int32) *BindInstanceDomainsResponseBody {
	s.SuccessCount = &v
	return s
}

type BindInstanceDomainsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BindInstanceDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BindInstanceDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s BindInstanceDomainsResponse) GoString() string {
	return s.String()
}

func (s *BindInstanceDomainsResponse) SetHeaders(v map[string]*string) *BindInstanceDomainsResponse {
	s.Headers = v
	return s
}

func (s *BindInstanceDomainsResponse) SetStatusCode(v int32) *BindInstanceDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *BindInstanceDomainsResponse) SetBody(v *BindInstanceDomainsResponseBody) *BindInstanceDomainsResponse {
	s.Body = v
	return s
}

type ChangeDomainGroupRequest struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The ID of the target domain name group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s ChangeDomainGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ChangeDomainGroupRequest) GoString() string {
	return s.String()
}

func (s *ChangeDomainGroupRequest) SetDomainName(v string) *ChangeDomainGroupRequest {
	s.DomainName = &v
	return s
}

func (s *ChangeDomainGroupRequest) SetGroupId(v string) *ChangeDomainGroupRequest {
	s.GroupId = &v
	return s
}

func (s *ChangeDomainGroupRequest) SetLang(v string) *ChangeDomainGroupRequest {
	s.Lang = &v
	return s
}

type ChangeDomainGroupResponseBody struct {
	// The ID of the target domain name group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the target domain name group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ChangeDomainGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ChangeDomainGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ChangeDomainGroupResponseBody) SetGroupId(v string) *ChangeDomainGroupResponseBody {
	s.GroupId = &v
	return s
}

func (s *ChangeDomainGroupResponseBody) SetGroupName(v string) *ChangeDomainGroupResponseBody {
	s.GroupName = &v
	return s
}

func (s *ChangeDomainGroupResponseBody) SetRequestId(v string) *ChangeDomainGroupResponseBody {
	s.RequestId = &v
	return s
}

type ChangeDomainGroupResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ChangeDomainGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ChangeDomainGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ChangeDomainGroupResponse) GoString() string {
	return s.String()
}

func (s *ChangeDomainGroupResponse) SetHeaders(v map[string]*string) *ChangeDomainGroupResponse {
	s.Headers = v
	return s
}

func (s *ChangeDomainGroupResponse) SetStatusCode(v int32) *ChangeDomainGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ChangeDomainGroupResponse) SetBody(v *ChangeDomainGroupResponseBody) *ChangeDomainGroupResponse {
	s.Body = v
	return s
}

type ChangeDomainOfDnsProductRequest struct {
	// Specifies whether to force bind a domain name to the instance.
	Force *bool `json:"Force,omitempty" xml:"Force,omitempty"`
	// The ID of the Alibaba Cloud DNS instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The domain name that you want to bind to the instance. If you do not specify this parameter, this operation unbinds the original domain name from the instance.
	NewDomain *string `json:"NewDomain,omitempty" xml:"NewDomain,omitempty"`
	// The IP address of the client.
	UserClientIp *string `json:"UserClientIp,omitempty" xml:"UserClientIp,omitempty"`
}

func (s ChangeDomainOfDnsProductRequest) String() string {
	return tea.Prettify(s)
}

func (s ChangeDomainOfDnsProductRequest) GoString() string {
	return s.String()
}

func (s *ChangeDomainOfDnsProductRequest) SetForce(v bool) *ChangeDomainOfDnsProductRequest {
	s.Force = &v
	return s
}

func (s *ChangeDomainOfDnsProductRequest) SetInstanceId(v string) *ChangeDomainOfDnsProductRequest {
	s.InstanceId = &v
	return s
}

func (s *ChangeDomainOfDnsProductRequest) SetLang(v string) *ChangeDomainOfDnsProductRequest {
	s.Lang = &v
	return s
}

func (s *ChangeDomainOfDnsProductRequest) SetNewDomain(v string) *ChangeDomainOfDnsProductRequest {
	s.NewDomain = &v
	return s
}

func (s *ChangeDomainOfDnsProductRequest) SetUserClientIp(v string) *ChangeDomainOfDnsProductRequest {
	s.UserClientIp = &v
	return s
}

type ChangeDomainOfDnsProductResponseBody struct {
	// The original domain name that was bound to the instance. If the value of this parameter is empty, the instance is bound with a domain name for the first time.
	OriginalDomain *string `json:"OriginalDomain,omitempty" xml:"OriginalDomain,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ChangeDomainOfDnsProductResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ChangeDomainOfDnsProductResponseBody) GoString() string {
	return s.String()
}

func (s *ChangeDomainOfDnsProductResponseBody) SetOriginalDomain(v string) *ChangeDomainOfDnsProductResponseBody {
	s.OriginalDomain = &v
	return s
}

func (s *ChangeDomainOfDnsProductResponseBody) SetRequestId(v string) *ChangeDomainOfDnsProductResponseBody {
	s.RequestId = &v
	return s
}

type ChangeDomainOfDnsProductResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ChangeDomainOfDnsProductResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ChangeDomainOfDnsProductResponse) String() string {
	return tea.Prettify(s)
}

func (s ChangeDomainOfDnsProductResponse) GoString() string {
	return s.String()
}

func (s *ChangeDomainOfDnsProductResponse) SetHeaders(v map[string]*string) *ChangeDomainOfDnsProductResponse {
	s.Headers = v
	return s
}

func (s *ChangeDomainOfDnsProductResponse) SetStatusCode(v int32) *ChangeDomainOfDnsProductResponse {
	s.StatusCode = &v
	return s
}

func (s *ChangeDomainOfDnsProductResponse) SetBody(v *ChangeDomainOfDnsProductResponseBody) *ChangeDomainOfDnsProductResponse {
	s.Body = v
	return s
}

type CopyGtmConfigRequest struct {
	// The type of the object that you want to copy. Only the INSTANCE type is supported.
	CopyType *string `json:"CopyType,omitempty" xml:"CopyType,omitempty"`
	// The language that specific response parameters will use.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the source object. Only instance IDs are supported.
	SourceId *string `json:"SourceId,omitempty" xml:"SourceId,omitempty"`
	// The ID of the target object. Only instance IDs are supported.
	TargetId *string `json:"TargetId,omitempty" xml:"TargetId,omitempty"`
}

func (s CopyGtmConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s CopyGtmConfigRequest) GoString() string {
	return s.String()
}

func (s *CopyGtmConfigRequest) SetCopyType(v string) *CopyGtmConfigRequest {
	s.CopyType = &v
	return s
}

func (s *CopyGtmConfigRequest) SetLang(v string) *CopyGtmConfigRequest {
	s.Lang = &v
	return s
}

func (s *CopyGtmConfigRequest) SetSourceId(v string) *CopyGtmConfigRequest {
	s.SourceId = &v
	return s
}

func (s *CopyGtmConfigRequest) SetTargetId(v string) *CopyGtmConfigRequest {
	s.TargetId = &v
	return s
}

type CopyGtmConfigResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CopyGtmConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CopyGtmConfigResponseBody) GoString() string {
	return s.String()
}

func (s *CopyGtmConfigResponseBody) SetRequestId(v string) *CopyGtmConfigResponseBody {
	s.RequestId = &v
	return s
}

type CopyGtmConfigResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CopyGtmConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CopyGtmConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s CopyGtmConfigResponse) GoString() string {
	return s.String()
}

func (s *CopyGtmConfigResponse) SetHeaders(v map[string]*string) *CopyGtmConfigResponse {
	s.Headers = v
	return s
}

func (s *CopyGtmConfigResponse) SetStatusCode(v int32) *CopyGtmConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *CopyGtmConfigResponse) SetBody(v *CopyGtmConfigResponseBody) *CopyGtmConfigResponse {
	s.Body = v
	return s
}

type CreatePdnsAppKeyRequest struct {
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s CreatePdnsAppKeyRequest) String() string {
	return tea.Prettify(s)
}

func (s CreatePdnsAppKeyRequest) GoString() string {
	return s.String()
}

func (s *CreatePdnsAppKeyRequest) SetLang(v string) *CreatePdnsAppKeyRequest {
	s.Lang = &v
	return s
}

type CreatePdnsAppKeyResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreatePdnsAppKeyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreatePdnsAppKeyResponseBody) GoString() string {
	return s.String()
}

func (s *CreatePdnsAppKeyResponseBody) SetRequestId(v string) *CreatePdnsAppKeyResponseBody {
	s.RequestId = &v
	return s
}

type CreatePdnsAppKeyResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreatePdnsAppKeyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreatePdnsAppKeyResponse) String() string {
	return tea.Prettify(s)
}

func (s CreatePdnsAppKeyResponse) GoString() string {
	return s.String()
}

func (s *CreatePdnsAppKeyResponse) SetHeaders(v map[string]*string) *CreatePdnsAppKeyResponse {
	s.Headers = v
	return s
}

func (s *CreatePdnsAppKeyResponse) SetStatusCode(v int32) *CreatePdnsAppKeyResponse {
	s.StatusCode = &v
	return s
}

func (s *CreatePdnsAppKeyResponse) SetBody(v *CreatePdnsAppKeyResponseBody) *CreatePdnsAppKeyResponse {
	s.Body = v
	return s
}

type CreatePdnsUdpIpSegmentRequest struct {
	Ip   *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s CreatePdnsUdpIpSegmentRequest) String() string {
	return tea.Prettify(s)
}

func (s CreatePdnsUdpIpSegmentRequest) GoString() string {
	return s.String()
}

func (s *CreatePdnsUdpIpSegmentRequest) SetIp(v string) *CreatePdnsUdpIpSegmentRequest {
	s.Ip = &v
	return s
}

func (s *CreatePdnsUdpIpSegmentRequest) SetLang(v string) *CreatePdnsUdpIpSegmentRequest {
	s.Lang = &v
	return s
}

func (s *CreatePdnsUdpIpSegmentRequest) SetName(v string) *CreatePdnsUdpIpSegmentRequest {
	s.Name = &v
	return s
}

type CreatePdnsUdpIpSegmentResponseBody struct {
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	ValidMessage *string `json:"ValidMessage,omitempty" xml:"ValidMessage,omitempty"`
}

func (s CreatePdnsUdpIpSegmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreatePdnsUdpIpSegmentResponseBody) GoString() string {
	return s.String()
}

func (s *CreatePdnsUdpIpSegmentResponseBody) SetRequestId(v string) *CreatePdnsUdpIpSegmentResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreatePdnsUdpIpSegmentResponseBody) SetValidMessage(v string) *CreatePdnsUdpIpSegmentResponseBody {
	s.ValidMessage = &v
	return s
}

type CreatePdnsUdpIpSegmentResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreatePdnsUdpIpSegmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreatePdnsUdpIpSegmentResponse) String() string {
	return tea.Prettify(s)
}

func (s CreatePdnsUdpIpSegmentResponse) GoString() string {
	return s.String()
}

func (s *CreatePdnsUdpIpSegmentResponse) SetHeaders(v map[string]*string) *CreatePdnsUdpIpSegmentResponse {
	s.Headers = v
	return s
}

func (s *CreatePdnsUdpIpSegmentResponse) SetStatusCode(v int32) *CreatePdnsUdpIpSegmentResponse {
	s.StatusCode = &v
	return s
}

func (s *CreatePdnsUdpIpSegmentResponse) SetBody(v *CreatePdnsUdpIpSegmentResponseBody) *CreatePdnsUdpIpSegmentResponse {
	s.Body = v
	return s
}

type DeleteCustomLinesRequest struct {
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The unique IDs of the custom lines that you want to delete. Separate the unique IDs with commas (,).
	LineIds *string `json:"LineIds,omitempty" xml:"LineIds,omitempty"`
}

func (s DeleteCustomLinesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCustomLinesRequest) GoString() string {
	return s.String()
}

func (s *DeleteCustomLinesRequest) SetLang(v string) *DeleteCustomLinesRequest {
	s.Lang = &v
	return s
}

func (s *DeleteCustomLinesRequest) SetLineIds(v string) *DeleteCustomLinesRequest {
	s.LineIds = &v
	return s
}

type DeleteCustomLinesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteCustomLinesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCustomLinesResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCustomLinesResponseBody) SetRequestId(v string) *DeleteCustomLinesResponseBody {
	s.RequestId = &v
	return s
}

type DeleteCustomLinesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCustomLinesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCustomLinesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCustomLinesResponse) GoString() string {
	return s.String()
}

func (s *DeleteCustomLinesResponse) SetHeaders(v map[string]*string) *DeleteCustomLinesResponse {
	s.Headers = v
	return s
}

func (s *DeleteCustomLinesResponse) SetStatusCode(v int32) *DeleteCustomLinesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCustomLinesResponse) SetBody(v *DeleteCustomLinesResponseBody) *DeleteCustomLinesResponse {
	s.Body = v
	return s
}

type DeleteDnsCacheDomainRequest struct {
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	Lang       *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DeleteDnsCacheDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDnsCacheDomainRequest) GoString() string {
	return s.String()
}

func (s *DeleteDnsCacheDomainRequest) SetDomainName(v string) *DeleteDnsCacheDomainRequest {
	s.DomainName = &v
	return s
}

func (s *DeleteDnsCacheDomainRequest) SetLang(v string) *DeleteDnsCacheDomainRequest {
	s.Lang = &v
	return s
}

type DeleteDnsCacheDomainResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDnsCacheDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDnsCacheDomainResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDnsCacheDomainResponseBody) SetRequestId(v string) *DeleteDnsCacheDomainResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDnsCacheDomainResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDnsCacheDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDnsCacheDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDnsCacheDomainResponse) GoString() string {
	return s.String()
}

func (s *DeleteDnsCacheDomainResponse) SetHeaders(v map[string]*string) *DeleteDnsCacheDomainResponse {
	s.Headers = v
	return s
}

func (s *DeleteDnsCacheDomainResponse) SetStatusCode(v int32) *DeleteDnsCacheDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDnsCacheDomainResponse) SetBody(v *DeleteDnsCacheDomainResponseBody) *DeleteDnsCacheDomainResponse {
	s.Body = v
	return s
}

type DeleteDnsGtmAccessStrategyRequest struct {
	// The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the access policy.
	StrategyId *string `json:"StrategyId,omitempty" xml:"StrategyId,omitempty"`
}

func (s DeleteDnsGtmAccessStrategyRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDnsGtmAccessStrategyRequest) GoString() string {
	return s.String()
}

func (s *DeleteDnsGtmAccessStrategyRequest) SetLang(v string) *DeleteDnsGtmAccessStrategyRequest {
	s.Lang = &v
	return s
}

func (s *DeleteDnsGtmAccessStrategyRequest) SetStrategyId(v string) *DeleteDnsGtmAccessStrategyRequest {
	s.StrategyId = &v
	return s
}

type DeleteDnsGtmAccessStrategyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDnsGtmAccessStrategyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDnsGtmAccessStrategyResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDnsGtmAccessStrategyResponseBody) SetRequestId(v string) *DeleteDnsGtmAccessStrategyResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDnsGtmAccessStrategyResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDnsGtmAccessStrategyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDnsGtmAccessStrategyResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDnsGtmAccessStrategyResponse) GoString() string {
	return s.String()
}

func (s *DeleteDnsGtmAccessStrategyResponse) SetHeaders(v map[string]*string) *DeleteDnsGtmAccessStrategyResponse {
	s.Headers = v
	return s
}

func (s *DeleteDnsGtmAccessStrategyResponse) SetStatusCode(v int32) *DeleteDnsGtmAccessStrategyResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDnsGtmAccessStrategyResponse) SetBody(v *DeleteDnsGtmAccessStrategyResponseBody) *DeleteDnsGtmAccessStrategyResponse {
	s.Body = v
	return s
}

type DeleteDnsGtmAddressPoolRequest struct {
	// The ID of the address pool.
	AddrPoolId *string `json:"AddrPoolId,omitempty" xml:"AddrPoolId,omitempty"`
	// The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DeleteDnsGtmAddressPoolRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDnsGtmAddressPoolRequest) GoString() string {
	return s.String()
}

func (s *DeleteDnsGtmAddressPoolRequest) SetAddrPoolId(v string) *DeleteDnsGtmAddressPoolRequest {
	s.AddrPoolId = &v
	return s
}

func (s *DeleteDnsGtmAddressPoolRequest) SetLang(v string) *DeleteDnsGtmAddressPoolRequest {
	s.Lang = &v
	return s
}

type DeleteDnsGtmAddressPoolResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDnsGtmAddressPoolResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDnsGtmAddressPoolResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDnsGtmAddressPoolResponseBody) SetRequestId(v string) *DeleteDnsGtmAddressPoolResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDnsGtmAddressPoolResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDnsGtmAddressPoolResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDnsGtmAddressPoolResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDnsGtmAddressPoolResponse) GoString() string {
	return s.String()
}

func (s *DeleteDnsGtmAddressPoolResponse) SetHeaders(v map[string]*string) *DeleteDnsGtmAddressPoolResponse {
	s.Headers = v
	return s
}

func (s *DeleteDnsGtmAddressPoolResponse) SetStatusCode(v int32) *DeleteDnsGtmAddressPoolResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDnsGtmAddressPoolResponse) SetBody(v *DeleteDnsGtmAddressPoolResponseBody) *DeleteDnsGtmAddressPoolResponse {
	s.Body = v
	return s
}

type DeleteDomainRequest struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DeleteDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDomainRequest) GoString() string {
	return s.String()
}

func (s *DeleteDomainRequest) SetDomainName(v string) *DeleteDomainRequest {
	s.DomainName = &v
	return s
}

func (s *DeleteDomainRequest) SetLang(v string) *DeleteDomainRequest {
	s.Lang = &v
	return s
}

type DeleteDomainResponseBody struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDomainResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDomainResponseBody) SetDomainName(v string) *DeleteDomainResponseBody {
	s.DomainName = &v
	return s
}

func (s *DeleteDomainResponseBody) SetRequestId(v string) *DeleteDomainResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDomainResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDomainResponse) GoString() string {
	return s.String()
}

func (s *DeleteDomainResponse) SetHeaders(v map[string]*string) *DeleteDomainResponse {
	s.Headers = v
	return s
}

func (s *DeleteDomainResponse) SetStatusCode(v int32) *DeleteDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDomainResponse) SetBody(v *DeleteDomainResponseBody) *DeleteDomainResponse {
	s.Body = v
	return s
}

type DeleteDomainGroupRequest struct {
	// The ID of the domain name group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DeleteDomainGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDomainGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteDomainGroupRequest) SetGroupId(v string) *DeleteDomainGroupRequest {
	s.GroupId = &v
	return s
}

func (s *DeleteDomainGroupRequest) SetLang(v string) *DeleteDomainGroupRequest {
	s.Lang = &v
	return s
}

type DeleteDomainGroupResponseBody struct {
	// The name of the domain name group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDomainGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDomainGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDomainGroupResponseBody) SetGroupName(v string) *DeleteDomainGroupResponseBody {
	s.GroupName = &v
	return s
}

func (s *DeleteDomainGroupResponseBody) SetRequestId(v string) *DeleteDomainGroupResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDomainGroupResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDomainGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDomainGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDomainGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteDomainGroupResponse) SetHeaders(v map[string]*string) *DeleteDomainGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteDomainGroupResponse) SetStatusCode(v int32) *DeleteDomainGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDomainGroupResponse) SetBody(v *DeleteDomainGroupResponseBody) *DeleteDomainGroupResponse {
	s.Body = v
	return s
}

type DeleteDomainRecordRequest struct {
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the DNS record.
	//
	// This parameter is returned when you add a DNS record or when you query the list of DNS records.
	RecordId *string `json:"RecordId,omitempty" xml:"RecordId,omitempty"`
	// The IP address of the client.
	UserClientIp *string `json:"UserClientIp,omitempty" xml:"UserClientIp,omitempty"`
}

func (s DeleteDomainRecordRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDomainRecordRequest) GoString() string {
	return s.String()
}

func (s *DeleteDomainRecordRequest) SetLang(v string) *DeleteDomainRecordRequest {
	s.Lang = &v
	return s
}

func (s *DeleteDomainRecordRequest) SetRecordId(v string) *DeleteDomainRecordRequest {
	s.RecordId = &v
	return s
}

func (s *DeleteDomainRecordRequest) SetUserClientIp(v string) *DeleteDomainRecordRequest {
	s.UserClientIp = &v
	return s
}

type DeleteDomainRecordResponseBody struct {
	// The ID of the DNS record.
	RecordId *string `json:"RecordId,omitempty" xml:"RecordId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDomainRecordResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDomainRecordResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDomainRecordResponseBody) SetRecordId(v string) *DeleteDomainRecordResponseBody {
	s.RecordId = &v
	return s
}

func (s *DeleteDomainRecordResponseBody) SetRequestId(v string) *DeleteDomainRecordResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDomainRecordResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDomainRecordResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDomainRecordResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDomainRecordResponse) GoString() string {
	return s.String()
}

func (s *DeleteDomainRecordResponse) SetHeaders(v map[string]*string) *DeleteDomainRecordResponse {
	s.Headers = v
	return s
}

func (s *DeleteDomainRecordResponse) SetStatusCode(v int32) *DeleteDomainRecordResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDomainRecordResponse) SetBody(v *DeleteDomainRecordResponseBody) *DeleteDomainRecordResponse {
	s.Body = v
	return s
}

type DeleteGtmAccessStrategyRequest struct {
	// The language used by the user.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the access policy that you want to delete.
	StrategyId *string `json:"StrategyId,omitempty" xml:"StrategyId,omitempty"`
}

func (s DeleteGtmAccessStrategyRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteGtmAccessStrategyRequest) GoString() string {
	return s.String()
}

func (s *DeleteGtmAccessStrategyRequest) SetLang(v string) *DeleteGtmAccessStrategyRequest {
	s.Lang = &v
	return s
}

func (s *DeleteGtmAccessStrategyRequest) SetStrategyId(v string) *DeleteGtmAccessStrategyRequest {
	s.StrategyId = &v
	return s
}

type DeleteGtmAccessStrategyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteGtmAccessStrategyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteGtmAccessStrategyResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteGtmAccessStrategyResponseBody) SetRequestId(v string) *DeleteGtmAccessStrategyResponseBody {
	s.RequestId = &v
	return s
}

type DeleteGtmAccessStrategyResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteGtmAccessStrategyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteGtmAccessStrategyResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteGtmAccessStrategyResponse) GoString() string {
	return s.String()
}

func (s *DeleteGtmAccessStrategyResponse) SetHeaders(v map[string]*string) *DeleteGtmAccessStrategyResponse {
	s.Headers = v
	return s
}

func (s *DeleteGtmAccessStrategyResponse) SetStatusCode(v int32) *DeleteGtmAccessStrategyResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteGtmAccessStrategyResponse) SetBody(v *DeleteGtmAccessStrategyResponseBody) *DeleteGtmAccessStrategyResponse {
	s.Body = v
	return s
}

type DeleteGtmAddressPoolRequest struct {
	// The ID of the address pool that you want to delete.
	AddrPoolId *string `json:"AddrPoolId,omitempty" xml:"AddrPoolId,omitempty"`
	// The language used by the user.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DeleteGtmAddressPoolRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteGtmAddressPoolRequest) GoString() string {
	return s.String()
}

func (s *DeleteGtmAddressPoolRequest) SetAddrPoolId(v string) *DeleteGtmAddressPoolRequest {
	s.AddrPoolId = &v
	return s
}

func (s *DeleteGtmAddressPoolRequest) SetLang(v string) *DeleteGtmAddressPoolRequest {
	s.Lang = &v
	return s
}

type DeleteGtmAddressPoolResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteGtmAddressPoolResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteGtmAddressPoolResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteGtmAddressPoolResponseBody) SetRequestId(v string) *DeleteGtmAddressPoolResponseBody {
	s.RequestId = &v
	return s
}

type DeleteGtmAddressPoolResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteGtmAddressPoolResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteGtmAddressPoolResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteGtmAddressPoolResponse) GoString() string {
	return s.String()
}

func (s *DeleteGtmAddressPoolResponse) SetHeaders(v map[string]*string) *DeleteGtmAddressPoolResponse {
	s.Headers = v
	return s
}

func (s *DeleteGtmAddressPoolResponse) SetStatusCode(v int32) *DeleteGtmAddressPoolResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteGtmAddressPoolResponse) SetBody(v *DeleteGtmAddressPoolResponseBody) *DeleteGtmAddressPoolResponse {
	s.Body = v
	return s
}

type DeleteGtmRecoveryPlanRequest struct {
	// The language used by the user.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the disaster recovery plan that you want to delete.
	RecoveryPlanId *int64 `json:"RecoveryPlanId,omitempty" xml:"RecoveryPlanId,omitempty"`
}

func (s DeleteGtmRecoveryPlanRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteGtmRecoveryPlanRequest) GoString() string {
	return s.String()
}

func (s *DeleteGtmRecoveryPlanRequest) SetLang(v string) *DeleteGtmRecoveryPlanRequest {
	s.Lang = &v
	return s
}

func (s *DeleteGtmRecoveryPlanRequest) SetRecoveryPlanId(v int64) *DeleteGtmRecoveryPlanRequest {
	s.RecoveryPlanId = &v
	return s
}

type DeleteGtmRecoveryPlanResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteGtmRecoveryPlanResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteGtmRecoveryPlanResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteGtmRecoveryPlanResponseBody) SetRequestId(v string) *DeleteGtmRecoveryPlanResponseBody {
	s.RequestId = &v
	return s
}

type DeleteGtmRecoveryPlanResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteGtmRecoveryPlanResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteGtmRecoveryPlanResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteGtmRecoveryPlanResponse) GoString() string {
	return s.String()
}

func (s *DeleteGtmRecoveryPlanResponse) SetHeaders(v map[string]*string) *DeleteGtmRecoveryPlanResponse {
	s.Headers = v
	return s
}

func (s *DeleteGtmRecoveryPlanResponse) SetStatusCode(v int32) *DeleteGtmRecoveryPlanResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteGtmRecoveryPlanResponse) SetBody(v *DeleteGtmRecoveryPlanResponseBody) *DeleteGtmRecoveryPlanResponse {
	s.Body = v
	return s
}

type DeleteSubDomainRecordsRequest struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The host record.
	//
	// For example, to resolve @.example.com, you must set RR to an at sign (@) instead of leaving it blank.
	RR *string `json:"RR,omitempty" xml:"RR,omitempty"`
	// The type of the DNS record. If you do not specify this parameter, all DNS record types corresponding to the subdomain name are returned.
	//
	// DNS record types include **A, MX, CNAME, TXT, REDIRECT_URL, FORWORD_URL, NS, AAAA, and SRV**. The value is not case-sensitive.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The IP address of the client.
	UserClientIp *string `json:"UserClientIp,omitempty" xml:"UserClientIp,omitempty"`
}

func (s DeleteSubDomainRecordsRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSubDomainRecordsRequest) GoString() string {
	return s.String()
}

func (s *DeleteSubDomainRecordsRequest) SetDomainName(v string) *DeleteSubDomainRecordsRequest {
	s.DomainName = &v
	return s
}

func (s *DeleteSubDomainRecordsRequest) SetLang(v string) *DeleteSubDomainRecordsRequest {
	s.Lang = &v
	return s
}

func (s *DeleteSubDomainRecordsRequest) SetRR(v string) *DeleteSubDomainRecordsRequest {
	s.RR = &v
	return s
}

func (s *DeleteSubDomainRecordsRequest) SetType(v string) *DeleteSubDomainRecordsRequest {
	s.Type = &v
	return s
}

func (s *DeleteSubDomainRecordsRequest) SetUserClientIp(v string) *DeleteSubDomainRecordsRequest {
	s.UserClientIp = &v
	return s
}

type DeleteSubDomainRecordsResponseBody struct {
	// The host record.
	RR *string `json:"RR,omitempty" xml:"RR,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of deleted DNS records.
	TotalCount *string `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DeleteSubDomainRecordsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSubDomainRecordsResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSubDomainRecordsResponseBody) SetRR(v string) *DeleteSubDomainRecordsResponseBody {
	s.RR = &v
	return s
}

func (s *DeleteSubDomainRecordsResponseBody) SetRequestId(v string) *DeleteSubDomainRecordsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteSubDomainRecordsResponseBody) SetTotalCount(v string) *DeleteSubDomainRecordsResponseBody {
	s.TotalCount = &v
	return s
}

type DeleteSubDomainRecordsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSubDomainRecordsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSubDomainRecordsResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSubDomainRecordsResponse) GoString() string {
	return s.String()
}

func (s *DeleteSubDomainRecordsResponse) SetHeaders(v map[string]*string) *DeleteSubDomainRecordsResponse {
	s.Headers = v
	return s
}

func (s *DeleteSubDomainRecordsResponse) SetStatusCode(v int32) *DeleteSubDomainRecordsResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSubDomainRecordsResponse) SetBody(v *DeleteSubDomainRecordsResponseBody) *DeleteSubDomainRecordsResponse {
	s.Body = v
	return s
}

type DescribeBatchResultCountRequest struct {
	// The type of the batch operation. Valid values:
	//
	// *   **DOMAIN_ADD**: adds domain names in batches.
	// *   **DOMAIN_DEL**: deletes domain names in batches.
	// *   **RR_ADD**: adds DNS records in batches.
	// *   **RR_DEL**: deletes DNS records in batches.
	BatchType *string `json:"BatchType,omitempty" xml:"BatchType,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the task.
	//
	// If you specify TaskId, the execution result of the specified task is returned. If you do not specify TaskId, the execution result of the last task is returned.
	TaskId *int64 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DescribeBatchResultCountRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeBatchResultCountRequest) GoString() string {
	return s.String()
}

func (s *DescribeBatchResultCountRequest) SetBatchType(v string) *DescribeBatchResultCountRequest {
	s.BatchType = &v
	return s
}

func (s *DescribeBatchResultCountRequest) SetLang(v string) *DescribeBatchResultCountRequest {
	s.Lang = &v
	return s
}

func (s *DescribeBatchResultCountRequest) SetTaskId(v int64) *DescribeBatchResultCountRequest {
	s.TaskId = &v
	return s
}

type DescribeBatchResultCountResponseBody struct {
	// The type of the batch operation.
	BatchType *string `json:"BatchType,omitempty" xml:"BatchType,omitempty"`
	// The total number of domain names or DNS records that failed to be processed.
	FailedCount *int32 `json:"FailedCount,omitempty" xml:"FailedCount,omitempty"`
	// The cause of the execution failure.
	Reason *string `json:"Reason,omitempty" xml:"Reason,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the task. Valid values:
	//
	// *   **-1**: No task for importing domain names or DNS records is submitted.
	// *   **0**: The task is being processed.
	// *   **1**: The task is completed.
	// *   **2**: The task failed.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The total number of successfully processed domain names or DNS records.
	SuccessCount *int32 `json:"SuccessCount,omitempty" xml:"SuccessCount,omitempty"`
	// The ID of the last task.
	TaskId *int64 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The total number of DNS records that were processed in batches.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeBatchResultCountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeBatchResultCountResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeBatchResultCountResponseBody) SetBatchType(v string) *DescribeBatchResultCountResponseBody {
	s.BatchType = &v
	return s
}

func (s *DescribeBatchResultCountResponseBody) SetFailedCount(v int32) *DescribeBatchResultCountResponseBody {
	s.FailedCount = &v
	return s
}

func (s *DescribeBatchResultCountResponseBody) SetReason(v string) *DescribeBatchResultCountResponseBody {
	s.Reason = &v
	return s
}

func (s *DescribeBatchResultCountResponseBody) SetRequestId(v string) *DescribeBatchResultCountResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeBatchResultCountResponseBody) SetStatus(v int32) *DescribeBatchResultCountResponseBody {
	s.Status = &v
	return s
}

func (s *DescribeBatchResultCountResponseBody) SetSuccessCount(v int32) *DescribeBatchResultCountResponseBody {
	s.SuccessCount = &v
	return s
}

func (s *DescribeBatchResultCountResponseBody) SetTaskId(v int64) *DescribeBatchResultCountResponseBody {
	s.TaskId = &v
	return s
}

func (s *DescribeBatchResultCountResponseBody) SetTotalCount(v int32) *DescribeBatchResultCountResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeBatchResultCountResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeBatchResultCountResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeBatchResultCountResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeBatchResultCountResponse) GoString() string {
	return s.String()
}

func (s *DescribeBatchResultCountResponse) SetHeaders(v map[string]*string) *DescribeBatchResultCountResponse {
	s.Headers = v
	return s
}

func (s *DescribeBatchResultCountResponse) SetStatusCode(v int32) *DescribeBatchResultCountResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeBatchResultCountResponse) SetBody(v *DescribeBatchResultCountResponseBody) *DescribeBatchResultCountResponse {
	s.Body = v
	return s
}

type DescribeBatchResultDetailRequest struct {
	// The type of the batch operation. Valid values:
	//
	// *   **DOMAIN_ADD**: adds domain names in batches.
	// *   **DOMAIN_DEL**: deletes domain names in batches.
	// *   **RR_ADD**: adds DNS records in batches.
	// *   **RR_DEL**: deletes DNS records in batches.
	BatchType *string `json:"BatchType,omitempty" xml:"BatchType,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Status   *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the task.
	TaskId *int64 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DescribeBatchResultDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeBatchResultDetailRequest) GoString() string {
	return s.String()
}

func (s *DescribeBatchResultDetailRequest) SetBatchType(v string) *DescribeBatchResultDetailRequest {
	s.BatchType = &v
	return s
}

func (s *DescribeBatchResultDetailRequest) SetLang(v string) *DescribeBatchResultDetailRequest {
	s.Lang = &v
	return s
}

func (s *DescribeBatchResultDetailRequest) SetPageNumber(v int32) *DescribeBatchResultDetailRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeBatchResultDetailRequest) SetPageSize(v int32) *DescribeBatchResultDetailRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeBatchResultDetailRequest) SetStatus(v string) *DescribeBatchResultDetailRequest {
	s.Status = &v
	return s
}

func (s *DescribeBatchResultDetailRequest) SetTaskId(v int64) *DescribeBatchResultDetailRequest {
	s.TaskId = &v
	return s
}

type DescribeBatchResultDetailResponseBody struct {
	// Detailed information about the batch operation result.
	BatchResultDetails *DescribeBatchResultDetailResponseBodyBatchResultDetails `json:"BatchResultDetails,omitempty" xml:"BatchResultDetails,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeBatchResultDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeBatchResultDetailResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeBatchResultDetailResponseBody) SetBatchResultDetails(v *DescribeBatchResultDetailResponseBodyBatchResultDetails) *DescribeBatchResultDetailResponseBody {
	s.BatchResultDetails = v
	return s
}

func (s *DescribeBatchResultDetailResponseBody) SetPageNumber(v int64) *DescribeBatchResultDetailResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeBatchResultDetailResponseBody) SetPageSize(v int64) *DescribeBatchResultDetailResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeBatchResultDetailResponseBody) SetRequestId(v string) *DescribeBatchResultDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeBatchResultDetailResponseBody) SetTotalCount(v int64) *DescribeBatchResultDetailResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeBatchResultDetailResponseBodyBatchResultDetails struct {
	BatchResultDetail []*DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail `json:"BatchResultDetail,omitempty" xml:"BatchResultDetail,omitempty" type:"Repeated"`
}

func (s DescribeBatchResultDetailResponseBodyBatchResultDetails) String() string {
	return tea.Prettify(s)
}

func (s DescribeBatchResultDetailResponseBodyBatchResultDetails) GoString() string {
	return s.String()
}

func (s *DescribeBatchResultDetailResponseBodyBatchResultDetails) SetBatchResultDetail(v []*DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail) *DescribeBatchResultDetailResponseBodyBatchResultDetails {
	s.BatchResultDetail = v
	return s
}

type DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail struct {
	// The type of the batch operation.
	BatchType *string `json:"BatchType,omitempty" xml:"BatchType,omitempty"`
	// The domain name.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The line code.
	Line *string `json:"Line,omitempty" xml:"Line,omitempty"`
	// The new host record.
	NewRr *string `json:"NewRr,omitempty" xml:"NewRr,omitempty"`
	// The new record value.
	NewValue *string `json:"NewValue,omitempty" xml:"NewValue,omitempty"`
	// The time when the operation was performed.
	OperateDateStr *string `json:"OperateDateStr,omitempty" xml:"OperateDateStr,omitempty"`
	// The priority of an MX-type DNS record.
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The cause of the execution failure.
	Reason *string `json:"Reason,omitempty" xml:"Reason,omitempty"`
	// The ID of the DNS record.
	RecordId *string `json:"RecordId,omitempty" xml:"RecordId,omitempty"`
	// The description of the DNS record.
	Remark *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
	// The host record.
	Rr *string `json:"Rr,omitempty" xml:"Rr,omitempty"`
	// The status of the DNS record.
	RrStatus *string `json:"RrStatus,omitempty" xml:"RrStatus,omitempty"`
	// The execution result. Valid values:**true**: The execution succeeded.**false**: The execution failed.
	Status *bool `json:"Status,omitempty" xml:"Status,omitempty"`
	// The TTL of the DNS record.
	Ttl *string `json:"Ttl,omitempty" xml:"Ttl,omitempty"`
	// The type of the DNS record.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value of the DNS record.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail) String() string {
	return tea.Prettify(s)
}

func (s DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail) GoString() string {
	return s.String()
}

func (s *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail) SetBatchType(v string) *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail {
	s.BatchType = &v
	return s
}

func (s *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail) SetDomain(v string) *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail {
	s.Domain = &v
	return s
}

func (s *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail) SetLine(v string) *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail {
	s.Line = &v
	return s
}

func (s *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail) SetNewRr(v string) *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail {
	s.NewRr = &v
	return s
}

func (s *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail) SetNewValue(v string) *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail {
	s.NewValue = &v
	return s
}

func (s *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail) SetOperateDateStr(v string) *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail {
	s.OperateDateStr = &v
	return s
}

func (s *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail) SetPriority(v string) *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail {
	s.Priority = &v
	return s
}

func (s *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail) SetReason(v string) *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail {
	s.Reason = &v
	return s
}

func (s *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail) SetRecordId(v string) *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail {
	s.RecordId = &v
	return s
}

func (s *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail) SetRemark(v string) *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail {
	s.Remark = &v
	return s
}

func (s *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail) SetRr(v string) *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail {
	s.Rr = &v
	return s
}

func (s *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail) SetRrStatus(v string) *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail {
	s.RrStatus = &v
	return s
}

func (s *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail) SetStatus(v bool) *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail {
	s.Status = &v
	return s
}

func (s *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail) SetTtl(v string) *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail {
	s.Ttl = &v
	return s
}

func (s *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail) SetType(v string) *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail {
	s.Type = &v
	return s
}

func (s *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail) SetValue(v string) *DescribeBatchResultDetailResponseBodyBatchResultDetailsBatchResultDetail {
	s.Value = &v
	return s
}

type DescribeBatchResultDetailResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeBatchResultDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeBatchResultDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeBatchResultDetailResponse) GoString() string {
	return s.String()
}

func (s *DescribeBatchResultDetailResponse) SetHeaders(v map[string]*string) *DescribeBatchResultDetailResponse {
	s.Headers = v
	return s
}

func (s *DescribeBatchResultDetailResponse) SetStatusCode(v int32) *DescribeBatchResultDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeBatchResultDetailResponse) SetBody(v *DescribeBatchResultDetailResponseBody) *DescribeBatchResultDetailResponse {
	s.Body = v
	return s
}

type DescribeCustomLineRequest struct {
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The unique ID of the custom line.
	LineId *int64 `json:"LineId,omitempty" xml:"LineId,omitempty"`
}

func (s DescribeCustomLineRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomLineRequest) GoString() string {
	return s.String()
}

func (s *DescribeCustomLineRequest) SetLang(v string) *DescribeCustomLineRequest {
	s.Lang = &v
	return s
}

func (s *DescribeCustomLineRequest) SetLineId(v int64) *DescribeCustomLineRequest {
	s.LineId = &v
	return s
}

type DescribeCustomLineResponseBody struct {
	// The code of the custom line. The code is used when you configure a resolution record.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The domain name for which the custom line is configured.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The unique ID of the custom line.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The list of CIDR blocks.
	IpSegmentList []*DescribeCustomLineResponseBodyIpSegmentList `json:"IpSegmentList,omitempty" xml:"IpSegmentList,omitempty" type:"Repeated"`
	// The name of the custom line.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCustomLineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomLineResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCustomLineResponseBody) SetCode(v string) *DescribeCustomLineResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeCustomLineResponseBody) SetDomainName(v string) *DescribeCustomLineResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeCustomLineResponseBody) SetId(v int64) *DescribeCustomLineResponseBody {
	s.Id = &v
	return s
}

func (s *DescribeCustomLineResponseBody) SetIpSegmentList(v []*DescribeCustomLineResponseBodyIpSegmentList) *DescribeCustomLineResponseBody {
	s.IpSegmentList = v
	return s
}

func (s *DescribeCustomLineResponseBody) SetName(v string) *DescribeCustomLineResponseBody {
	s.Name = &v
	return s
}

func (s *DescribeCustomLineResponseBody) SetRequestId(v string) *DescribeCustomLineResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCustomLineResponseBodyIpSegmentList struct {
	// The end IP address.
	EndIp *string `json:"EndIp,omitempty" xml:"EndIp,omitempty"`
	// The start IP address.
	StartIp *string `json:"StartIp,omitempty" xml:"StartIp,omitempty"`
}

func (s DescribeCustomLineResponseBodyIpSegmentList) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomLineResponseBodyIpSegmentList) GoString() string {
	return s.String()
}

func (s *DescribeCustomLineResponseBodyIpSegmentList) SetEndIp(v string) *DescribeCustomLineResponseBodyIpSegmentList {
	s.EndIp = &v
	return s
}

func (s *DescribeCustomLineResponseBodyIpSegmentList) SetStartIp(v string) *DescribeCustomLineResponseBodyIpSegmentList {
	s.StartIp = &v
	return s
}

type DescribeCustomLineResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCustomLineResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCustomLineResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomLineResponse) GoString() string {
	return s.String()
}

func (s *DescribeCustomLineResponse) SetHeaders(v map[string]*string) *DescribeCustomLineResponse {
	s.Headers = v
	return s
}

func (s *DescribeCustomLineResponse) SetStatusCode(v int32) *DescribeCustomLineResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCustomLineResponse) SetBody(v *DescribeCustomLineResponseBody) *DescribeCustomLineResponse {
	s.Body = v
	return s
}

type DescribeCustomLinesRequest struct {
	// The domain name for which the custom lines to be queried are configured.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The number of the page to return.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeCustomLinesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomLinesRequest) GoString() string {
	return s.String()
}

func (s *DescribeCustomLinesRequest) SetDomainName(v string) *DescribeCustomLinesRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeCustomLinesRequest) SetLang(v string) *DescribeCustomLinesRequest {
	s.Lang = &v
	return s
}

func (s *DescribeCustomLinesRequest) SetPageNumber(v int64) *DescribeCustomLinesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCustomLinesRequest) SetPageSize(v int64) *DescribeCustomLinesRequest {
	s.PageSize = &v
	return s
}

type DescribeCustomLinesResponseBody struct {
	// The list of custom lines.
	CustomLines []*DescribeCustomLinesResponseBodyCustomLines `json:"CustomLines,omitempty" xml:"CustomLines,omitempty" type:"Repeated"`
	// The number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries that were returned on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of custom lines.
	TotalItems *int32 `json:"TotalItems,omitempty" xml:"TotalItems,omitempty"`
	// The number of pages that were returned.
	TotalPages *int32 `json:"TotalPages,omitempty" xml:"TotalPages,omitempty"`
}

func (s DescribeCustomLinesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomLinesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCustomLinesResponseBody) SetCustomLines(v []*DescribeCustomLinesResponseBodyCustomLines) *DescribeCustomLinesResponseBody {
	s.CustomLines = v
	return s
}

func (s *DescribeCustomLinesResponseBody) SetPageNumber(v int32) *DescribeCustomLinesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeCustomLinesResponseBody) SetPageSize(v int32) *DescribeCustomLinesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeCustomLinesResponseBody) SetRequestId(v string) *DescribeCustomLinesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCustomLinesResponseBody) SetTotalItems(v int32) *DescribeCustomLinesResponseBody {
	s.TotalItems = &v
	return s
}

func (s *DescribeCustomLinesResponseBody) SetTotalPages(v int32) *DescribeCustomLinesResponseBody {
	s.TotalPages = &v
	return s
}

type DescribeCustomLinesResponseBodyCustomLines struct {
	// The code of the custom line.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The unique ID of the custom line.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the custom line.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s DescribeCustomLinesResponseBodyCustomLines) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomLinesResponseBodyCustomLines) GoString() string {
	return s.String()
}

func (s *DescribeCustomLinesResponseBodyCustomLines) SetCode(v string) *DescribeCustomLinesResponseBodyCustomLines {
	s.Code = &v
	return s
}

func (s *DescribeCustomLinesResponseBodyCustomLines) SetId(v int64) *DescribeCustomLinesResponseBodyCustomLines {
	s.Id = &v
	return s
}

func (s *DescribeCustomLinesResponseBodyCustomLines) SetName(v string) *DescribeCustomLinesResponseBodyCustomLines {
	s.Name = &v
	return s
}

type DescribeCustomLinesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCustomLinesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCustomLinesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCustomLinesResponse) GoString() string {
	return s.String()
}

func (s *DescribeCustomLinesResponse) SetHeaders(v map[string]*string) *DescribeCustomLinesResponse {
	s.Headers = v
	return s
}

func (s *DescribeCustomLinesResponse) SetStatusCode(v int32) *DescribeCustomLinesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCustomLinesResponse) SetBody(v *DescribeCustomLinesResponseBody) *DescribeCustomLinesResponse {
	s.Body = v
	return s
}

type DescribeDNSSLBSubDomainsRequest struct {
	// The domain name whose subdomains you want to query.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The language of the domain name.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The number of the page to return. Pages start from page **1**. Default value: **1**.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **100**. Default value: **20**.
	PageSize *int64  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Rr       *string `json:"Rr,omitempty" xml:"Rr,omitempty"`
	// The IP address of the client that you use to query subdomains.
	UserClientIp *string `json:"UserClientIp,omitempty" xml:"UserClientIp,omitempty"`
}

func (s DescribeDNSSLBSubDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDNSSLBSubDomainsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDNSSLBSubDomainsRequest) SetDomainName(v string) *DescribeDNSSLBSubDomainsRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDNSSLBSubDomainsRequest) SetLang(v string) *DescribeDNSSLBSubDomainsRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDNSSLBSubDomainsRequest) SetPageNumber(v int64) *DescribeDNSSLBSubDomainsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDNSSLBSubDomainsRequest) SetPageSize(v int64) *DescribeDNSSLBSubDomainsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDNSSLBSubDomainsRequest) SetRr(v string) *DescribeDNSSLBSubDomainsRequest {
	s.Rr = &v
	return s
}

func (s *DescribeDNSSLBSubDomainsRequest) SetUserClientIp(v string) *DescribeDNSSLBSubDomainsRequest {
	s.UserClientIp = &v
	return s
}

type DescribeDNSSLBSubDomainsResponseBody struct {
	// The page number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The total number of subdomains returned.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details of the subdomains.
	SlbSubDomains *DescribeDNSSLBSubDomainsResponseBodySlbSubDomains `json:"SlbSubDomains,omitempty" xml:"SlbSubDomains,omitempty" type:"Struct"`
	// The number of domain name groups.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDNSSLBSubDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDNSSLBSubDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDNSSLBSubDomainsResponseBody) SetPageNumber(v int64) *DescribeDNSSLBSubDomainsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDNSSLBSubDomainsResponseBody) SetPageSize(v int64) *DescribeDNSSLBSubDomainsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDNSSLBSubDomainsResponseBody) SetRequestId(v string) *DescribeDNSSLBSubDomainsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDNSSLBSubDomainsResponseBody) SetSlbSubDomains(v *DescribeDNSSLBSubDomainsResponseBodySlbSubDomains) *DescribeDNSSLBSubDomainsResponseBody {
	s.SlbSubDomains = v
	return s
}

func (s *DescribeDNSSLBSubDomainsResponseBody) SetTotalCount(v int64) *DescribeDNSSLBSubDomainsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDNSSLBSubDomainsResponseBodySlbSubDomains struct {
	SlbSubDomain []*DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain `json:"SlbSubDomain,omitempty" xml:"SlbSubDomain,omitempty" type:"Repeated"`
}

func (s DescribeDNSSLBSubDomainsResponseBodySlbSubDomains) String() string {
	return tea.Prettify(s)
}

func (s DescribeDNSSLBSubDomainsResponseBodySlbSubDomains) GoString() string {
	return s.String()
}

func (s *DescribeDNSSLBSubDomainsResponseBodySlbSubDomains) SetSlbSubDomain(v []*DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain) *DescribeDNSSLBSubDomainsResponseBodySlbSubDomains {
	s.SlbSubDomain = v
	return s
}

type DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain struct {
	LineAlgorithms *DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithms `json:"LineAlgorithms,omitempty" xml:"LineAlgorithms,omitempty" type:"Struct"`
	// Indicates whether weighted round-robin is enabled for the subdomain.
	Open *bool `json:"Open,omitempty" xml:"Open,omitempty"`
	// The number of DNS records added for the subdomain.
	RecordCount *int64 `json:"RecordCount,omitempty" xml:"RecordCount,omitempty"`
	// The subdomain.
	SubDomain *string `json:"SubDomain,omitempty" xml:"SubDomain,omitempty"`
	// The type of the DNS record that supports weighted round-robin. Valid values: A, AAAA, and CNAME.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain) String() string {
	return tea.Prettify(s)
}

func (s DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain) GoString() string {
	return s.String()
}

func (s *DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain) SetLineAlgorithms(v *DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithms) *DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain {
	s.LineAlgorithms = v
	return s
}

func (s *DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain) SetOpen(v bool) *DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain {
	s.Open = &v
	return s
}

func (s *DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain) SetRecordCount(v int64) *DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain {
	s.RecordCount = &v
	return s
}

func (s *DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain) SetSubDomain(v string) *DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain {
	s.SubDomain = &v
	return s
}

func (s *DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain) SetType(v string) *DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomain {
	s.Type = &v
	return s
}

type DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithms struct {
	LineAlgorithm []*DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithmsLineAlgorithm `json:"LineAlgorithm,omitempty" xml:"LineAlgorithm,omitempty" type:"Repeated"`
}

func (s DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithms) String() string {
	return tea.Prettify(s)
}

func (s DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithms) GoString() string {
	return s.String()
}

func (s *DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithms) SetLineAlgorithm(v []*DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithmsLineAlgorithm) *DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithms {
	s.LineAlgorithm = v
	return s
}

type DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithmsLineAlgorithm struct {
	Line *string `json:"Line,omitempty" xml:"Line,omitempty"`
	Open *bool   `json:"Open,omitempty" xml:"Open,omitempty"`
}

func (s DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithmsLineAlgorithm) String() string {
	return tea.Prettify(s)
}

func (s DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithmsLineAlgorithm) GoString() string {
	return s.String()
}

func (s *DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithmsLineAlgorithm) SetLine(v string) *DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithmsLineAlgorithm {
	s.Line = &v
	return s
}

func (s *DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithmsLineAlgorithm) SetOpen(v bool) *DescribeDNSSLBSubDomainsResponseBodySlbSubDomainsSlbSubDomainLineAlgorithmsLineAlgorithm {
	s.Open = &v
	return s
}

type DescribeDNSSLBSubDomainsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDNSSLBSubDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDNSSLBSubDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDNSSLBSubDomainsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDNSSLBSubDomainsResponse) SetHeaders(v map[string]*string) *DescribeDNSSLBSubDomainsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDNSSLBSubDomainsResponse) SetStatusCode(v int32) *DescribeDNSSLBSubDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDNSSLBSubDomainsResponse) SetBody(v *DescribeDNSSLBSubDomainsResponseBody) *DescribeDNSSLBSubDomainsResponse {
	s.Body = v
	return s
}

type DescribeDnsCacheDomainsRequest struct {
	Keyword    *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	Lang       *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	PageNumber *int64  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int64  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeDnsCacheDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsCacheDomainsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDnsCacheDomainsRequest) SetKeyword(v string) *DescribeDnsCacheDomainsRequest {
	s.Keyword = &v
	return s
}

func (s *DescribeDnsCacheDomainsRequest) SetLang(v string) *DescribeDnsCacheDomainsRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDnsCacheDomainsRequest) SetPageNumber(v int64) *DescribeDnsCacheDomainsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDnsCacheDomainsRequest) SetPageSize(v int64) *DescribeDnsCacheDomainsRequest {
	s.PageSize = &v
	return s
}

type DescribeDnsCacheDomainsResponseBody struct {
	Domains    []*DescribeDnsCacheDomainsResponseBodyDomains `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Repeated"`
	PageNumber *int64                                        `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int64                                        `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RequestId  *string                                       `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount *int64                                        `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDnsCacheDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsCacheDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDnsCacheDomainsResponseBody) SetDomains(v []*DescribeDnsCacheDomainsResponseBodyDomains) *DescribeDnsCacheDomainsResponseBody {
	s.Domains = v
	return s
}

func (s *DescribeDnsCacheDomainsResponseBody) SetPageNumber(v int64) *DescribeDnsCacheDomainsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDnsCacheDomainsResponseBody) SetPageSize(v int64) *DescribeDnsCacheDomainsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDnsCacheDomainsResponseBody) SetRequestId(v string) *DescribeDnsCacheDomainsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDnsCacheDomainsResponseBody) SetTotalCount(v int64) *DescribeDnsCacheDomainsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDnsCacheDomainsResponseBodyDomains struct {
	CacheTtlMax      *int32                                                        `json:"CacheTtlMax,omitempty" xml:"CacheTtlMax,omitempty"`
	CacheTtlMin      *int32                                                        `json:"CacheTtlMin,omitempty" xml:"CacheTtlMin,omitempty"`
	CreateTime       *string                                                       `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	CreateTimestamp  *int64                                                        `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	DomainId         *string                                                       `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	DomainName       *string                                                       `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	ExpireTime       *string                                                       `json:"ExpireTime,omitempty" xml:"ExpireTime,omitempty"`
	ExpireTimestamp  *int64                                                        `json:"ExpireTimestamp,omitempty" xml:"ExpireTimestamp,omitempty"`
	InstanceId       *string                                                       `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	Remark           *string                                                       `json:"Remark,omitempty" xml:"Remark,omitempty"`
	SourceDnsServers []*DescribeDnsCacheDomainsResponseBodyDomainsSourceDnsServers `json:"SourceDnsServers,omitempty" xml:"SourceDnsServers,omitempty" type:"Repeated"`
	SourceEdns       *string                                                       `json:"SourceEdns,omitempty" xml:"SourceEdns,omitempty"`
	SourceProtocol   *string                                                       `json:"SourceProtocol,omitempty" xml:"SourceProtocol,omitempty"`
	UpdateTime       *string                                                       `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	UpdateTimestamp  *int64                                                        `json:"UpdateTimestamp,omitempty" xml:"UpdateTimestamp,omitempty"`
	VersionCode      *string                                                       `json:"VersionCode,omitempty" xml:"VersionCode,omitempty"`
}

func (s DescribeDnsCacheDomainsResponseBodyDomains) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsCacheDomainsResponseBodyDomains) GoString() string {
	return s.String()
}

func (s *DescribeDnsCacheDomainsResponseBodyDomains) SetCacheTtlMax(v int32) *DescribeDnsCacheDomainsResponseBodyDomains {
	s.CacheTtlMax = &v
	return s
}

func (s *DescribeDnsCacheDomainsResponseBodyDomains) SetCacheTtlMin(v int32) *DescribeDnsCacheDomainsResponseBodyDomains {
	s.CacheTtlMin = &v
	return s
}

func (s *DescribeDnsCacheDomainsResponseBodyDomains) SetCreateTime(v string) *DescribeDnsCacheDomainsResponseBodyDomains {
	s.CreateTime = &v
	return s
}

func (s *DescribeDnsCacheDomainsResponseBodyDomains) SetCreateTimestamp(v int64) *DescribeDnsCacheDomainsResponseBodyDomains {
	s.CreateTimestamp = &v
	return s
}

func (s *DescribeDnsCacheDomainsResponseBodyDomains) SetDomainId(v string) *DescribeDnsCacheDomainsResponseBodyDomains {
	s.DomainId = &v
	return s
}

func (s *DescribeDnsCacheDomainsResponseBodyDomains) SetDomainName(v string) *DescribeDnsCacheDomainsResponseBodyDomains {
	s.DomainName = &v
	return s
}

func (s *DescribeDnsCacheDomainsResponseBodyDomains) SetExpireTime(v string) *DescribeDnsCacheDomainsResponseBodyDomains {
	s.ExpireTime = &v
	return s
}

func (s *DescribeDnsCacheDomainsResponseBodyDomains) SetExpireTimestamp(v int64) *DescribeDnsCacheDomainsResponseBodyDomains {
	s.ExpireTimestamp = &v
	return s
}

func (s *DescribeDnsCacheDomainsResponseBodyDomains) SetInstanceId(v string) *DescribeDnsCacheDomainsResponseBodyDomains {
	s.InstanceId = &v
	return s
}

func (s *DescribeDnsCacheDomainsResponseBodyDomains) SetRemark(v string) *DescribeDnsCacheDomainsResponseBodyDomains {
	s.Remark = &v
	return s
}

func (s *DescribeDnsCacheDomainsResponseBodyDomains) SetSourceDnsServers(v []*DescribeDnsCacheDomainsResponseBodyDomainsSourceDnsServers) *DescribeDnsCacheDomainsResponseBodyDomains {
	s.SourceDnsServers = v
	return s
}

func (s *DescribeDnsCacheDomainsResponseBodyDomains) SetSourceEdns(v string) *DescribeDnsCacheDomainsResponseBodyDomains {
	s.SourceEdns = &v
	return s
}

func (s *DescribeDnsCacheDomainsResponseBodyDomains) SetSourceProtocol(v string) *DescribeDnsCacheDomainsResponseBodyDomains {
	s.SourceProtocol = &v
	return s
}

func (s *DescribeDnsCacheDomainsResponseBodyDomains) SetUpdateTime(v string) *DescribeDnsCacheDomainsResponseBodyDomains {
	s.UpdateTime = &v
	return s
}

func (s *DescribeDnsCacheDomainsResponseBodyDomains) SetUpdateTimestamp(v int64) *DescribeDnsCacheDomainsResponseBodyDomains {
	s.UpdateTimestamp = &v
	return s
}

func (s *DescribeDnsCacheDomainsResponseBodyDomains) SetVersionCode(v string) *DescribeDnsCacheDomainsResponseBodyDomains {
	s.VersionCode = &v
	return s
}

type DescribeDnsCacheDomainsResponseBodyDomainsSourceDnsServers struct {
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
}

func (s DescribeDnsCacheDomainsResponseBodyDomainsSourceDnsServers) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsCacheDomainsResponseBodyDomainsSourceDnsServers) GoString() string {
	return s.String()
}

func (s *DescribeDnsCacheDomainsResponseBodyDomainsSourceDnsServers) SetHost(v string) *DescribeDnsCacheDomainsResponseBodyDomainsSourceDnsServers {
	s.Host = &v
	return s
}

func (s *DescribeDnsCacheDomainsResponseBodyDomainsSourceDnsServers) SetPort(v string) *DescribeDnsCacheDomainsResponseBodyDomainsSourceDnsServers {
	s.Port = &v
	return s
}

type DescribeDnsCacheDomainsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDnsCacheDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDnsCacheDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsCacheDomainsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDnsCacheDomainsResponse) SetHeaders(v map[string]*string) *DescribeDnsCacheDomainsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDnsCacheDomainsResponse) SetStatusCode(v int32) *DescribeDnsCacheDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDnsCacheDomainsResponse) SetBody(v *DescribeDnsCacheDomainsResponseBody) *DescribeDnsCacheDomainsResponse {
	s.Body = v
	return s
}

type DescribeDnsGtmAccessStrategiesRequest struct {
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The type of the access policy. Valid values:
	//
	// *   GEO: geographical location-based
	// *   LATENCY: latency-based
	StrategyMode *string `json:"StrategyMode,omitempty" xml:"StrategyMode,omitempty"`
}

func (s DescribeDnsGtmAccessStrategiesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategiesRequest) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategiesRequest) SetInstanceId(v string) *DescribeDnsGtmAccessStrategiesRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesRequest) SetLang(v string) *DescribeDnsGtmAccessStrategiesRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesRequest) SetPageNumber(v int32) *DescribeDnsGtmAccessStrategiesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesRequest) SetPageSize(v int32) *DescribeDnsGtmAccessStrategiesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesRequest) SetStrategyMode(v string) *DescribeDnsGtmAccessStrategiesRequest {
	s.StrategyMode = &v
	return s
}

type DescribeDnsGtmAccessStrategiesResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The access policies.
	Strategies *DescribeDnsGtmAccessStrategiesResponseBodyStrategies `json:"Strategies,omitempty" xml:"Strategies,omitempty" type:"Struct"`
	// The total number of entries returned on all pages.
	TotalItems *int32 `json:"TotalItems,omitempty" xml:"TotalItems,omitempty"`
	// The total number of pages returned.
	TotalPages *int32 `json:"TotalPages,omitempty" xml:"TotalPages,omitempty"`
}

func (s DescribeDnsGtmAccessStrategiesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategiesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategiesResponseBody) SetPageNumber(v int32) *DescribeDnsGtmAccessStrategiesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesResponseBody) SetPageSize(v int32) *DescribeDnsGtmAccessStrategiesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesResponseBody) SetRequestId(v string) *DescribeDnsGtmAccessStrategiesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesResponseBody) SetStrategies(v *DescribeDnsGtmAccessStrategiesResponseBodyStrategies) *DescribeDnsGtmAccessStrategiesResponseBody {
	s.Strategies = v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesResponseBody) SetTotalItems(v int32) *DescribeDnsGtmAccessStrategiesResponseBody {
	s.TotalItems = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesResponseBody) SetTotalPages(v int32) *DescribeDnsGtmAccessStrategiesResponseBody {
	s.TotalPages = &v
	return s
}

type DescribeDnsGtmAccessStrategiesResponseBodyStrategies struct {
	Strategy []*DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy `json:"Strategy,omitempty" xml:"Strategy,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmAccessStrategiesResponseBodyStrategies) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategiesResponseBodyStrategies) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategiesResponseBodyStrategies) SetStrategy(v []*DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy) *DescribeDnsGtmAccessStrategiesResponseBodyStrategies {
	s.Strategy = v
	return s
}

type DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy struct {
	// The time when the access policy was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The timestamp that indicates when the access policy was created.
	CreateTimestamp *int64 `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The type of the active address pool group. Valid values:
	//
	// *   DEFAULT: the primary address pool group
	// *   FAILOVER: the secondary address pool group
	EffectiveAddrPoolGroupType *string `json:"EffectiveAddrPoolGroupType,omitempty" xml:"EffectiveAddrPoolGroupType,omitempty"`
	// The type of the active address pools. Valid values:
	//
	// *   IPV4
	// *   IPV6
	// *   DOMAIN
	EffectiveAddrPoolType *string `json:"EffectiveAddrPoolType,omitempty" xml:"EffectiveAddrPoolType,omitempty"`
	// The active address pool groups.
	EffectiveAddrPools *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPools `json:"EffectiveAddrPools,omitempty" xml:"EffectiveAddrPools,omitempty" type:"Struct"`
	// The load balancing policy of the active address pool group. Data is returned when StrategyMode is set to GEO. Valid values:
	//
	// - ALL_RR: returns all addresses.
	// - RATIO: returns addresses by weight.
	EffectiveLbaStrategy *string `json:"EffectiveLbaStrategy,omitempty" xml:"EffectiveLbaStrategy,omitempty"`
	// The source regions. Data is returned when StrategyMode is set to GEO. Valid values:
	Lines *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLines `json:"Lines,omitempty" xml:"Lines,omitempty" type:"Struct"`
	// The ID of the access policy.
	StrategyId *string `json:"StrategyId,omitempty" xml:"StrategyId,omitempty"`
	// The name of the access policy.
	StrategyName *string `json:"StrategyName,omitempty" xml:"StrategyName,omitempty"`
}

func (s DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy) SetCreateTime(v string) *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.CreateTime = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy) SetCreateTimestamp(v int64) *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.CreateTimestamp = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy) SetEffectiveAddrPoolGroupType(v string) *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.EffectiveAddrPoolGroupType = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy) SetEffectiveAddrPoolType(v string) *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.EffectiveAddrPoolType = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy) SetEffectiveAddrPools(v *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPools) *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.EffectiveAddrPools = v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy) SetEffectiveLbaStrategy(v string) *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.EffectiveLbaStrategy = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy) SetLines(v *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLines) *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.Lines = v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy) SetStrategyId(v string) *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.StrategyId = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy) SetStrategyName(v string) *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.StrategyName = &v
	return s
}

type DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPools struct {
	EffectiveAddrPool []*DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool `json:"EffectiveAddrPool,omitempty" xml:"EffectiveAddrPool,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPools) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPools) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPools) SetEffectiveAddrPool(v []*DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool) *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPools {
	s.EffectiveAddrPool = v
	return s
}

type DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool struct {
	// The number of addresses in the address pool.
	AddrCount *int32 `json:"AddrCount,omitempty" xml:"AddrCount,omitempty"`
	// The ID of the address pool.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The weight of the address pool.
	LbaWeight *int32 `json:"LbaWeight,omitempty" xml:"LbaWeight,omitempty"`
	// The name of the address pool.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool) SetAddrCount(v int32) *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool {
	s.AddrCount = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool) SetId(v string) *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool {
	s.Id = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool) SetLbaWeight(v int32) *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool {
	s.LbaWeight = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool) SetName(v string) *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyEffectiveAddrPoolsEffectiveAddrPool {
	s.Name = &v
	return s
}

type DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLines struct {
	Line []*DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine `json:"Line,omitempty" xml:"Line,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLines) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLines) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLines) SetLine(v []*DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine) *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLines {
	s.Line = v
	return s
}

type DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine struct {
	// The code of the source region group.
	GroupCode *string `json:"GroupCode,omitempty" xml:"GroupCode,omitempty"`
	// The name of the source region group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The line code of the source region.
	LineCode *string `json:"LineCode,omitempty" xml:"LineCode,omitempty"`
	// The line name of the source region.
	LineName *string `json:"LineName,omitempty" xml:"LineName,omitempty"`
}

func (s DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine) SetGroupCode(v string) *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine {
	s.GroupCode = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine) SetGroupName(v string) *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine {
	s.GroupName = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine) SetLineCode(v string) *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine {
	s.LineCode = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine) SetLineName(v string) *DescribeDnsGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine {
	s.LineName = &v
	return s
}

type DescribeDnsGtmAccessStrategiesResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDnsGtmAccessStrategiesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDnsGtmAccessStrategiesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategiesResponse) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategiesResponse) SetHeaders(v map[string]*string) *DescribeDnsGtmAccessStrategiesResponse {
	s.Headers = v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesResponse) SetStatusCode(v int32) *DescribeDnsGtmAccessStrategiesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategiesResponse) SetBody(v *DescribeDnsGtmAccessStrategiesResponseBody) *DescribeDnsGtmAccessStrategiesResponse {
	s.Body = v
	return s
}

type DescribeDnsGtmAccessStrategyRequest struct {
	// The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the access policy.
	StrategyId *string `json:"StrategyId,omitempty" xml:"StrategyId,omitempty"`
}

func (s DescribeDnsGtmAccessStrategyRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategyRequest) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategyRequest) SetLang(v string) *DescribeDnsGtmAccessStrategyRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyRequest) SetStrategyId(v string) *DescribeDnsGtmAccessStrategyRequest {
	s.StrategyId = &v
	return s
}

type DescribeDnsGtmAccessStrategyResponseBody struct {
	// The primary/secondary switchover policy for address pool groups. Valid values:
	//
	// *   AUTO: performs automatic switchover between the primary and secondary address pool groups upon failures.
	// *   DEFAULT: uses the primary address pool group.
	// *   FAILOVER: uses the secondary address pool group.
	AccessMode *string `json:"AccessMode,omitempty" xml:"AccessMode,omitempty"`
	// The time when the access policy was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The timestamp that indicates when the access policy was created.
	CreateTimestamp *int64 `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The status of the primary address pool group. Valid values:
	//
	// *   AVAILABLE: available
	// *   NOT_AVAILABLE: unavailable
	DefaultAddrPoolGroupStatus *string `json:"DefaultAddrPoolGroupStatus,omitempty" xml:"DefaultAddrPoolGroupStatus,omitempty"`
	// The type of the primary address pool. Valid values:
	//
	// *   IPV4
	// *   IPV6
	// *   DOMAIN
	DefaultAddrPoolType *string `json:"DefaultAddrPoolType,omitempty" xml:"DefaultAddrPoolType,omitempty"`
	// The address pools in the primary address pool group.
	DefaultAddrPools *DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPools `json:"DefaultAddrPools,omitempty" xml:"DefaultAddrPools,omitempty" type:"Struct"`
	// The number of available addresses in the primary address pool.
	DefaultAvailableAddrNum *int32 `json:"DefaultAvailableAddrNum,omitempty" xml:"DefaultAvailableAddrNum,omitempty"`
	// Indicates whether scheduling optimization for latency resolution was enabled for the primary address pool group. Valid values:
	//
	// *   OPEN: enabled
	// *   CLOSE: disabled
	DefaultLatencyOptimization *string `json:"DefaultLatencyOptimization,omitempty" xml:"DefaultLatencyOptimization,omitempty"`
	// The load balancing policy of the primary address pool group. Valid values:
	//
	// *   ALL_RR: returns all addresses.
	// *   RATIO: returns addresses by weight.
	DefaultLbaStrategy *string `json:"DefaultLbaStrategy,omitempty" xml:"DefaultLbaStrategy,omitempty"`
	// The maximum number of addresses returned from the primary address pool group.
	DefaultMaxReturnAddrNum *int32 `json:"DefaultMaxReturnAddrNum,omitempty" xml:"DefaultMaxReturnAddrNum,omitempty"`
	// The minimum number of available addresses in the primary address pool group.
	DefaultMinAvailableAddrNum *int32 `json:"DefaultMinAvailableAddrNum,omitempty" xml:"DefaultMinAvailableAddrNum,omitempty"`
	// The type of the active address pool group. Valid values:
	//
	// *   DEFAULT: the primary address pool group
	// *   FAILOVER: the secondary address pool group
	EffectiveAddrPoolGroupType *string `json:"EffectiveAddrPoolGroupType,omitempty" xml:"EffectiveAddrPoolGroupType,omitempty"`
	// The status of the secondary address pool group. Valid values:
	//
	// *   AVAILABLE: available
	// *   NOT_AVAILABLE: unavailable
	FailoverAddrPoolGroupStatus *string `json:"FailoverAddrPoolGroupStatus,omitempty" xml:"FailoverAddrPoolGroupStatus,omitempty"`
	// The type of the secondary address pool. Valid values:
	//
	// *   IPV4
	// *   IPV6
	// *   DOMAIN
	FailoverAddrPoolType *string `json:"FailoverAddrPoolType,omitempty" xml:"FailoverAddrPoolType,omitempty"`
	// The address pools in the secondary address pool group.
	FailoverAddrPools *DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPools `json:"FailoverAddrPools,omitempty" xml:"FailoverAddrPools,omitempty" type:"Struct"`
	// The number of available addresses in the secondary address pool.
	FailoverAvailableAddrNum *int32 `json:"FailoverAvailableAddrNum,omitempty" xml:"FailoverAvailableAddrNum,omitempty"`
	// Indicates whether scheduling optimization for latency resolution was enabled for the secondary address pool group. Valid values:
	//
	// *   OPEN: enabled
	// *   CLOSE: disabled
	FailoverLatencyOptimization *string `json:"FailoverLatencyOptimization,omitempty" xml:"FailoverLatencyOptimization,omitempty"`
	// The load balancing policy of the secondary address pool group. Valid values:
	//
	// *   ALL_RR: returns all addresses.
	// *   RATIO: returns addresses by weight.
	FailoverLbaStrategy *string `json:"FailoverLbaStrategy,omitempty" xml:"FailoverLbaStrategy,omitempty"`
	// The maximum number of addresses returned from the secondary address pool group.
	FailoverMaxReturnAddrNum *int32 `json:"FailoverMaxReturnAddrNum,omitempty" xml:"FailoverMaxReturnAddrNum,omitempty"`
	// The minimum number of available addresses in the secondary address pool group.
	FailoverMinAvailableAddrNum *int32 `json:"FailoverMinAvailableAddrNum,omitempty" xml:"FailoverMinAvailableAddrNum,omitempty"`
	// The ID of the associated instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The source regions.
	Lines *DescribeDnsGtmAccessStrategyResponseBodyLines `json:"Lines,omitempty" xml:"Lines,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the access policy.
	StrategyId *string `json:"StrategyId,omitempty" xml:"StrategyId,omitempty"`
	// The type of the access policy. Valid values:
	//
	// *   GEO: geographical location-based
	// *   LATENCY: latency-based
	StrategyMode *string `json:"StrategyMode,omitempty" xml:"StrategyMode,omitempty"`
	// The name of the access policy.
	StrategyName *string `json:"StrategyName,omitempty" xml:"StrategyName,omitempty"`
}

func (s DescribeDnsGtmAccessStrategyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategyResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetAccessMode(v string) *DescribeDnsGtmAccessStrategyResponseBody {
	s.AccessMode = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetCreateTime(v string) *DescribeDnsGtmAccessStrategyResponseBody {
	s.CreateTime = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetCreateTimestamp(v int64) *DescribeDnsGtmAccessStrategyResponseBody {
	s.CreateTimestamp = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetDefaultAddrPoolGroupStatus(v string) *DescribeDnsGtmAccessStrategyResponseBody {
	s.DefaultAddrPoolGroupStatus = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetDefaultAddrPoolType(v string) *DescribeDnsGtmAccessStrategyResponseBody {
	s.DefaultAddrPoolType = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetDefaultAddrPools(v *DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPools) *DescribeDnsGtmAccessStrategyResponseBody {
	s.DefaultAddrPools = v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetDefaultAvailableAddrNum(v int32) *DescribeDnsGtmAccessStrategyResponseBody {
	s.DefaultAvailableAddrNum = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetDefaultLatencyOptimization(v string) *DescribeDnsGtmAccessStrategyResponseBody {
	s.DefaultLatencyOptimization = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetDefaultLbaStrategy(v string) *DescribeDnsGtmAccessStrategyResponseBody {
	s.DefaultLbaStrategy = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetDefaultMaxReturnAddrNum(v int32) *DescribeDnsGtmAccessStrategyResponseBody {
	s.DefaultMaxReturnAddrNum = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetDefaultMinAvailableAddrNum(v int32) *DescribeDnsGtmAccessStrategyResponseBody {
	s.DefaultMinAvailableAddrNum = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetEffectiveAddrPoolGroupType(v string) *DescribeDnsGtmAccessStrategyResponseBody {
	s.EffectiveAddrPoolGroupType = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetFailoverAddrPoolGroupStatus(v string) *DescribeDnsGtmAccessStrategyResponseBody {
	s.FailoverAddrPoolGroupStatus = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetFailoverAddrPoolType(v string) *DescribeDnsGtmAccessStrategyResponseBody {
	s.FailoverAddrPoolType = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetFailoverAddrPools(v *DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPools) *DescribeDnsGtmAccessStrategyResponseBody {
	s.FailoverAddrPools = v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetFailoverAvailableAddrNum(v int32) *DescribeDnsGtmAccessStrategyResponseBody {
	s.FailoverAvailableAddrNum = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetFailoverLatencyOptimization(v string) *DescribeDnsGtmAccessStrategyResponseBody {
	s.FailoverLatencyOptimization = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetFailoverLbaStrategy(v string) *DescribeDnsGtmAccessStrategyResponseBody {
	s.FailoverLbaStrategy = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetFailoverMaxReturnAddrNum(v int32) *DescribeDnsGtmAccessStrategyResponseBody {
	s.FailoverMaxReturnAddrNum = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetFailoverMinAvailableAddrNum(v int32) *DescribeDnsGtmAccessStrategyResponseBody {
	s.FailoverMinAvailableAddrNum = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetInstanceId(v string) *DescribeDnsGtmAccessStrategyResponseBody {
	s.InstanceId = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetLines(v *DescribeDnsGtmAccessStrategyResponseBodyLines) *DescribeDnsGtmAccessStrategyResponseBody {
	s.Lines = v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetRequestId(v string) *DescribeDnsGtmAccessStrategyResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetStrategyId(v string) *DescribeDnsGtmAccessStrategyResponseBody {
	s.StrategyId = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetStrategyMode(v string) *DescribeDnsGtmAccessStrategyResponseBody {
	s.StrategyMode = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBody) SetStrategyName(v string) *DescribeDnsGtmAccessStrategyResponseBody {
	s.StrategyName = &v
	return s
}

type DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPools struct {
	DefaultAddrPool []*DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool `json:"DefaultAddrPool,omitempty" xml:"DefaultAddrPool,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPools) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPools) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPools) SetDefaultAddrPool(v []*DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool) *DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPools {
	s.DefaultAddrPool = v
	return s
}

type DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool struct {
	// The number of addresses in the address pool.
	AddrCount *int32 `json:"AddrCount,omitempty" xml:"AddrCount,omitempty"`
	// The ID of the address pool.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The weight of the address pool.
	LbaWeight *int32 `json:"LbaWeight,omitempty" xml:"LbaWeight,omitempty"`
	// The name of the address pool.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool) SetAddrCount(v int32) *DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool {
	s.AddrCount = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool) SetId(v string) *DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool {
	s.Id = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool) SetLbaWeight(v int32) *DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool {
	s.LbaWeight = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool) SetName(v string) *DescribeDnsGtmAccessStrategyResponseBodyDefaultAddrPoolsDefaultAddrPool {
	s.Name = &v
	return s
}

type DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPools struct {
	FailoverAddrPool []*DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool `json:"FailoverAddrPool,omitempty" xml:"FailoverAddrPool,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPools) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPools) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPools) SetFailoverAddrPool(v []*DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool) *DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPools {
	s.FailoverAddrPool = v
	return s
}

type DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool struct {
	// The number of addresses in the address pool.
	AddrCount *int32 `json:"AddrCount,omitempty" xml:"AddrCount,omitempty"`
	// The ID of the address pool.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The weight of the address pool.
	LbaWeight *int32 `json:"LbaWeight,omitempty" xml:"LbaWeight,omitempty"`
	// The name of the address pool.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool) SetAddrCount(v int32) *DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool {
	s.AddrCount = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool) SetId(v string) *DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool {
	s.Id = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool) SetLbaWeight(v int32) *DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool {
	s.LbaWeight = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool) SetName(v string) *DescribeDnsGtmAccessStrategyResponseBodyFailoverAddrPoolsFailoverAddrPool {
	s.Name = &v
	return s
}

type DescribeDnsGtmAccessStrategyResponseBodyLines struct {
	Line []*DescribeDnsGtmAccessStrategyResponseBodyLinesLine `json:"Line,omitempty" xml:"Line,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmAccessStrategyResponseBodyLines) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategyResponseBodyLines) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategyResponseBodyLines) SetLine(v []*DescribeDnsGtmAccessStrategyResponseBodyLinesLine) *DescribeDnsGtmAccessStrategyResponseBodyLines {
	s.Line = v
	return s
}

type DescribeDnsGtmAccessStrategyResponseBodyLinesLine struct {
	// The code of the source region group.
	GroupCode *string `json:"GroupCode,omitempty" xml:"GroupCode,omitempty"`
	// The name of the source region group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The line code of the source region.
	LineCode *string `json:"LineCode,omitempty" xml:"LineCode,omitempty"`
	// The line name of the source region.
	LineName *string `json:"LineName,omitempty" xml:"LineName,omitempty"`
}

func (s DescribeDnsGtmAccessStrategyResponseBodyLinesLine) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategyResponseBodyLinesLine) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategyResponseBodyLinesLine) SetGroupCode(v string) *DescribeDnsGtmAccessStrategyResponseBodyLinesLine {
	s.GroupCode = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBodyLinesLine) SetGroupName(v string) *DescribeDnsGtmAccessStrategyResponseBodyLinesLine {
	s.GroupName = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBodyLinesLine) SetLineCode(v string) *DescribeDnsGtmAccessStrategyResponseBodyLinesLine {
	s.LineCode = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponseBodyLinesLine) SetLineName(v string) *DescribeDnsGtmAccessStrategyResponseBodyLinesLine {
	s.LineName = &v
	return s
}

type DescribeDnsGtmAccessStrategyResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDnsGtmAccessStrategyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDnsGtmAccessStrategyResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategyResponse) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategyResponse) SetHeaders(v map[string]*string) *DescribeDnsGtmAccessStrategyResponse {
	s.Headers = v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponse) SetStatusCode(v int32) *DescribeDnsGtmAccessStrategyResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyResponse) SetBody(v *DescribeDnsGtmAccessStrategyResponseBody) *DescribeDnsGtmAccessStrategyResponse {
	s.Body = v
	return s
}

type DescribeDnsGtmAccessStrategyAvailableConfigRequest struct {
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The type of the access policy. Valid values:
	//
	// *   GEO: geographical location-based
	// *   LATENCY: latency-based
	StrategyMode *string `json:"StrategyMode,omitempty" xml:"StrategyMode,omitempty"`
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigRequest) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigRequest) SetInstanceId(v string) *DescribeDnsGtmAccessStrategyAvailableConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigRequest) SetLang(v string) *DescribeDnsGtmAccessStrategyAvailableConfigRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigRequest) SetStrategyMode(v string) *DescribeDnsGtmAccessStrategyAvailableConfigRequest {
	s.StrategyMode = &v
	return s
}

type DescribeDnsGtmAccessStrategyAvailableConfigResponseBody struct {
	// The available address pools of the domain name type.
	DomainAddrPools *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPools `json:"DomainAddrPools,omitempty" xml:"DomainAddrPools,omitempty" type:"Struct"`
	// The available address pools of the IPv4 type.
	Ipv4AddrPools *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPools `json:"Ipv4AddrPools,omitempty" xml:"Ipv4AddrPools,omitempty" type:"Struct"`
	// The available address pools of the IPv6 type.
	Ipv6AddrPools *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPools `json:"Ipv6AddrPools,omitempty" xml:"Ipv6AddrPools,omitempty" type:"Struct"`
	// The source regions.
	Lines *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLines `json:"Lines,omitempty" xml:"Lines,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId           *string                                                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	SelectedDomainLines *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedDomainLines `json:"SelectedDomainLines,omitempty" xml:"SelectedDomainLines,omitempty" type:"Struct"`
	SelectedIpv4Lines   *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv4Lines   `json:"SelectedIpv4Lines,omitempty" xml:"SelectedIpv4Lines,omitempty" type:"Struct"`
	SelectedIpv6Lines   *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv6Lines   `json:"SelectedIpv6Lines,omitempty" xml:"SelectedIpv6Lines,omitempty" type:"Struct"`
	// Indicates whether we recommend that you set the source region to global.
	SuggestSetDefaultLine *bool `json:"SuggestSetDefaultLine,omitempty" xml:"SuggestSetDefaultLine,omitempty"`
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBody) SetDomainAddrPools(v *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPools) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBody {
	s.DomainAddrPools = v
	return s
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBody) SetIpv4AddrPools(v *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPools) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBody {
	s.Ipv4AddrPools = v
	return s
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBody) SetIpv6AddrPools(v *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPools) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBody {
	s.Ipv6AddrPools = v
	return s
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBody) SetLines(v *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLines) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBody {
	s.Lines = v
	return s
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBody) SetRequestId(v string) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBody) SetSelectedDomainLines(v *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedDomainLines) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBody {
	s.SelectedDomainLines = v
	return s
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBody) SetSelectedIpv4Lines(v *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv4Lines) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBody {
	s.SelectedIpv4Lines = v
	return s
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBody) SetSelectedIpv6Lines(v *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv6Lines) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBody {
	s.SelectedIpv6Lines = v
	return s
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBody) SetSuggestSetDefaultLine(v bool) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBody {
	s.SuggestSetDefaultLine = &v
	return s
}

type DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPools struct {
	DomainAddrPool []*DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool `json:"DomainAddrPool,omitempty" xml:"DomainAddrPool,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPools) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPools) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPools) SetDomainAddrPool(v []*DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPools {
	s.DomainAddrPool = v
	return s
}

type DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool struct {
	// The number of addresses in the address pool.
	AddrCount *int32 `json:"AddrCount,omitempty" xml:"AddrCount,omitempty"`
	// The ID of the address pool.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the address pool.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool) SetAddrCount(v int32) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool {
	s.AddrCount = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool) SetId(v string) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool {
	s.Id = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool) SetName(v string) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyDomainAddrPoolsDomainAddrPool {
	s.Name = &v
	return s
}

type DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPools struct {
	Ipv4AddrPool []*DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool `json:"Ipv4AddrPool,omitempty" xml:"Ipv4AddrPool,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPools) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPools) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPools) SetIpv4AddrPool(v []*DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPools {
	s.Ipv4AddrPool = v
	return s
}

type DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool struct {
	// The number of addresses in the address pool.
	AddrCount *int32 `json:"AddrCount,omitempty" xml:"AddrCount,omitempty"`
	// The ID of the address pool.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the address pool.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool) SetAddrCount(v int32) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool {
	s.AddrCount = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool) SetId(v string) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool {
	s.Id = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool) SetName(v string) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv4AddrPoolsIpv4AddrPool {
	s.Name = &v
	return s
}

type DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPools struct {
	Ipv6AddrPool []*DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool `json:"Ipv6AddrPool,omitempty" xml:"Ipv6AddrPool,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPools) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPools) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPools) SetIpv6AddrPool(v []*DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPools {
	s.Ipv6AddrPool = v
	return s
}

type DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool struct {
	// The number of addresses in the address pool.
	AddrCount *int32 `json:"AddrCount,omitempty" xml:"AddrCount,omitempty"`
	// The ID of the address pool.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the address pool.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool) SetAddrCount(v int32) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool {
	s.AddrCount = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool) SetId(v string) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool {
	s.Id = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool) SetName(v string) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyIpv6AddrPoolsIpv6AddrPool {
	s.Name = &v
	return s
}

type DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLines struct {
	Line []*DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine `json:"Line,omitempty" xml:"Line,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLines) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLines) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLines) SetLine(v []*DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLines {
	s.Line = v
	return s
}

type DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine struct {
	// The parent line code of the source region. Leave it blank if no parent line exists.
	FatherCode *string `json:"FatherCode,omitempty" xml:"FatherCode,omitempty"`
	// The line name of the source region.
	GroupCode *string `json:"GroupCode,omitempty" xml:"GroupCode,omitempty"`
	// The name of the source region group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The line code of the source region.
	LineCode *string `json:"LineCode,omitempty" xml:"LineCode,omitempty"`
	// The code of the source region group.
	LineName *string `json:"LineName,omitempty" xml:"LineName,omitempty"`
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine) SetFatherCode(v string) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine {
	s.FatherCode = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine) SetGroupCode(v string) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine {
	s.GroupCode = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine) SetGroupName(v string) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine {
	s.GroupName = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine) SetLineCode(v string) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine {
	s.LineCode = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine) SetLineName(v string) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodyLinesLine {
	s.LineName = &v
	return s
}

type DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedDomainLines struct {
	SelectedDomainLine []*string `json:"SelectedDomainLine,omitempty" xml:"SelectedDomainLine,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedDomainLines) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedDomainLines) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedDomainLines) SetSelectedDomainLine(v []*string) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedDomainLines {
	s.SelectedDomainLine = v
	return s
}

type DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv4Lines struct {
	SelectedIpv4Line []*string `json:"SelectedIpv4Line,omitempty" xml:"SelectedIpv4Line,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv4Lines) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv4Lines) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv4Lines) SetSelectedIpv4Line(v []*string) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv4Lines {
	s.SelectedIpv4Line = v
	return s
}

type DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv6Lines struct {
	SelectedIpv6Line []*string `json:"SelectedIpv6Line,omitempty" xml:"SelectedIpv6Line,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv6Lines) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv6Lines) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv6Lines) SetSelectedIpv6Line(v []*string) *DescribeDnsGtmAccessStrategyAvailableConfigResponseBodySelectedIpv6Lines {
	s.SelectedIpv6Line = v
	return s
}

type DescribeDnsGtmAccessStrategyAvailableConfigResponse struct {
	Headers    map[string]*string                                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDnsGtmAccessStrategyAvailableConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAccessStrategyAvailableConfigResponse) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponse) SetHeaders(v map[string]*string) *DescribeDnsGtmAccessStrategyAvailableConfigResponse {
	s.Headers = v
	return s
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponse) SetStatusCode(v int32) *DescribeDnsGtmAccessStrategyAvailableConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDnsGtmAccessStrategyAvailableConfigResponse) SetBody(v *DescribeDnsGtmAccessStrategyAvailableConfigResponseBody) *DescribeDnsGtmAccessStrategyAvailableConfigResponse {
	s.Body = v
	return s
}

type DescribeDnsGtmAddrAttributeInfoRequest struct {
	// The addresses whose source regions you want to query.
	Addrs *string `json:"Addrs,omitempty" xml:"Addrs,omitempty"`
	// The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The type of the addresses. Valid values:
	//
	// *   IPV4: IPv4 address
	// *   IPV6: IPv6 address
	// *   DOMAIN: domain name
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeDnsGtmAddrAttributeInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAddrAttributeInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAddrAttributeInfoRequest) SetAddrs(v string) *DescribeDnsGtmAddrAttributeInfoRequest {
	s.Addrs = &v
	return s
}

func (s *DescribeDnsGtmAddrAttributeInfoRequest) SetLang(v string) *DescribeDnsGtmAddrAttributeInfoRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDnsGtmAddrAttributeInfoRequest) SetType(v string) *DescribeDnsGtmAddrAttributeInfoRequest {
	s.Type = &v
	return s
}

type DescribeDnsGtmAddrAttributeInfoResponseBody struct {
	// The addresses that were queried.
	Addr *DescribeDnsGtmAddrAttributeInfoResponseBodyAddr `json:"Addr,omitempty" xml:"Addr,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDnsGtmAddrAttributeInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAddrAttributeInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAddrAttributeInfoResponseBody) SetAddr(v *DescribeDnsGtmAddrAttributeInfoResponseBodyAddr) *DescribeDnsGtmAddrAttributeInfoResponseBody {
	s.Addr = v
	return s
}

func (s *DescribeDnsGtmAddrAttributeInfoResponseBody) SetRequestId(v string) *DescribeDnsGtmAddrAttributeInfoResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDnsGtmAddrAttributeInfoResponseBodyAddr struct {
	Addr []*DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddr `json:"Addr,omitempty" xml:"Addr,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmAddrAttributeInfoResponseBodyAddr) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAddrAttributeInfoResponseBodyAddr) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAddrAttributeInfoResponseBodyAddr) SetAddr(v []*DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddr) *DescribeDnsGtmAddrAttributeInfoResponseBodyAddr {
	s.Addr = v
	return s
}

type DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddr struct {
	// The address that was queried.
	Addr *string `json:"Addr,omitempty" xml:"Addr,omitempty"`
	// The source region of the address.
	AttributeInfo *DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo `json:"AttributeInfo,omitempty" xml:"AttributeInfo,omitempty" type:"Struct"`
}

func (s DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddr) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddr) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddr) SetAddr(v string) *DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddr {
	s.Addr = &v
	return s
}

func (s *DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddr) SetAttributeInfo(v *DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo) *DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddr {
	s.AttributeInfo = v
	return s
}

type DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo struct {
	// The parent line code of the source region.
	FatherCode *string `json:"FatherCode,omitempty" xml:"FatherCode,omitempty"`
	// The code of the source region group.
	GroupCode *string `json:"GroupCode,omitempty" xml:"GroupCode,omitempty"`
	// The name of the source region group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The line code of the source region.
	LineCode *string `json:"LineCode,omitempty" xml:"LineCode,omitempty"`
	// The line name of the source region.
	LineName *string `json:"LineName,omitempty" xml:"LineName,omitempty"`
}

func (s DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo) SetFatherCode(v string) *DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo {
	s.FatherCode = &v
	return s
}

func (s *DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo) SetGroupCode(v string) *DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo {
	s.GroupCode = &v
	return s
}

func (s *DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo) SetGroupName(v string) *DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo {
	s.GroupName = &v
	return s
}

func (s *DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo) SetLineCode(v string) *DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo {
	s.LineCode = &v
	return s
}

func (s *DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo) SetLineName(v string) *DescribeDnsGtmAddrAttributeInfoResponseBodyAddrAddrAttributeInfo {
	s.LineName = &v
	return s
}

type DescribeDnsGtmAddrAttributeInfoResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDnsGtmAddrAttributeInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDnsGtmAddrAttributeInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAddrAttributeInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAddrAttributeInfoResponse) SetHeaders(v map[string]*string) *DescribeDnsGtmAddrAttributeInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeDnsGtmAddrAttributeInfoResponse) SetStatusCode(v int32) *DescribeDnsGtmAddrAttributeInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDnsGtmAddrAttributeInfoResponse) SetBody(v *DescribeDnsGtmAddrAttributeInfoResponseBody) *DescribeDnsGtmAddrAttributeInfoResponse {
	s.Body = v
	return s
}

type DescribeDnsGtmAddressPoolAvailableConfigRequest struct {
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DescribeDnsGtmAddressPoolAvailableConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAddressPoolAvailableConfigRequest) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAddressPoolAvailableConfigRequest) SetInstanceId(v string) *DescribeDnsGtmAddressPoolAvailableConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeDnsGtmAddressPoolAvailableConfigRequest) SetLang(v string) *DescribeDnsGtmAddressPoolAvailableConfigRequest {
	s.Lang = &v
	return s
}

type DescribeDnsGtmAddressPoolAvailableConfigResponseBody struct {
	// The supported source regions.
	AttributeInfos *DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfos `json:"AttributeInfos,omitempty" xml:"AttributeInfos,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDnsGtmAddressPoolAvailableConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAddressPoolAvailableConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAddressPoolAvailableConfigResponseBody) SetAttributeInfos(v *DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfos) *DescribeDnsGtmAddressPoolAvailableConfigResponseBody {
	s.AttributeInfos = v
	return s
}

func (s *DescribeDnsGtmAddressPoolAvailableConfigResponseBody) SetRequestId(v string) *DescribeDnsGtmAddressPoolAvailableConfigResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfos struct {
	AttributeInfo []*DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo `json:"AttributeInfo,omitempty" xml:"AttributeInfo,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfos) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfos) SetAttributeInfo(v []*DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo) *DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfos {
	s.AttributeInfo = v
	return s
}

type DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo struct {
	// The parent line code of the source region.
	FatherCode *string `json:"FatherCode,omitempty" xml:"FatherCode,omitempty"`
	// The code of the source region group.
	GroupCode *string `json:"GroupCode,omitempty" xml:"GroupCode,omitempty"`
	// The name of the request source group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The line code of the source region.
	LineCode *string `json:"LineCode,omitempty" xml:"LineCode,omitempty"`
	// The line name of the source region.
	LineName *string `json:"LineName,omitempty" xml:"LineName,omitempty"`
}

func (s DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo) SetFatherCode(v string) *DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo {
	s.FatherCode = &v
	return s
}

func (s *DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo) SetGroupCode(v string) *DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo {
	s.GroupCode = &v
	return s
}

func (s *DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo) SetGroupName(v string) *DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo {
	s.GroupName = &v
	return s
}

func (s *DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo) SetLineCode(v string) *DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo {
	s.LineCode = &v
	return s
}

func (s *DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo) SetLineName(v string) *DescribeDnsGtmAddressPoolAvailableConfigResponseBodyAttributeInfosAttributeInfo {
	s.LineName = &v
	return s
}

type DescribeDnsGtmAddressPoolAvailableConfigResponse struct {
	Headers    map[string]*string                                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDnsGtmAddressPoolAvailableConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDnsGtmAddressPoolAvailableConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAddressPoolAvailableConfigResponse) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAddressPoolAvailableConfigResponse) SetHeaders(v map[string]*string) *DescribeDnsGtmAddressPoolAvailableConfigResponse {
	s.Headers = v
	return s
}

func (s *DescribeDnsGtmAddressPoolAvailableConfigResponse) SetStatusCode(v int32) *DescribeDnsGtmAddressPoolAvailableConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDnsGtmAddressPoolAvailableConfigResponse) SetBody(v *DescribeDnsGtmAddressPoolAvailableConfigResponseBody) *DescribeDnsGtmAddressPoolAvailableConfigResponse {
	s.Body = v
	return s
}

type DescribeDnsGtmAvailableAlertGroupRequest struct {
	// The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DescribeDnsGtmAvailableAlertGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAvailableAlertGroupRequest) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAvailableAlertGroupRequest) SetLang(v string) *DescribeDnsGtmAvailableAlertGroupRequest {
	s.Lang = &v
	return s
}

type DescribeDnsGtmAvailableAlertGroupResponseBody struct {
	// The returned available alert groups.
	AvailableAlertGroup *string `json:"AvailableAlertGroup,omitempty" xml:"AvailableAlertGroup,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDnsGtmAvailableAlertGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAvailableAlertGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAvailableAlertGroupResponseBody) SetAvailableAlertGroup(v string) *DescribeDnsGtmAvailableAlertGroupResponseBody {
	s.AvailableAlertGroup = &v
	return s
}

func (s *DescribeDnsGtmAvailableAlertGroupResponseBody) SetRequestId(v string) *DescribeDnsGtmAvailableAlertGroupResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDnsGtmAvailableAlertGroupResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDnsGtmAvailableAlertGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDnsGtmAvailableAlertGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmAvailableAlertGroupResponse) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmAvailableAlertGroupResponse) SetHeaders(v map[string]*string) *DescribeDnsGtmAvailableAlertGroupResponse {
	s.Headers = v
	return s
}

func (s *DescribeDnsGtmAvailableAlertGroupResponse) SetStatusCode(v int32) *DescribeDnsGtmAvailableAlertGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDnsGtmAvailableAlertGroupResponse) SetBody(v *DescribeDnsGtmAvailableAlertGroupResponseBody) *DescribeDnsGtmAvailableAlertGroupResponse {
	s.Body = v
	return s
}

type DescribeDnsGtmInstanceRequest struct {
	// The ID of the instance about which you want to query the information.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DescribeDnsGtmInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstanceRequest) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstanceRequest) SetInstanceId(v string) *DescribeDnsGtmInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeDnsGtmInstanceRequest) SetLang(v string) *DescribeDnsGtmInstanceRequest {
	s.Lang = &v
	return s
}

type DescribeDnsGtmInstanceResponseBody struct {
	// The configurations of the instance.
	Config *DescribeDnsGtmInstanceResponseBodyConfig `json:"Config,omitempty" xml:"Config,omitempty" type:"Struct"`
	// The time when the instance was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The UNIX timestamp that indicates when the instance was created.
	CreateTimestamp *int64 `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The time when the instance expires.
	ExpireTime *string `json:"ExpireTime,omitempty" xml:"ExpireTime,omitempty"`
	// The UNIX timestamp that indicates when the instance expires.
	ExpireTimestamp *int64 `json:"ExpireTimestamp,omitempty" xml:"ExpireTimestamp,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The billing method. Valid value:
	//
	// *   Subscription: You can pay in advance for the use of resources.
	PaymentType *string `json:"PaymentType,omitempty" xml:"PaymentType,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group to which the instance belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The total number of SMS notifications.
	SmsQuota *int32 `json:"SmsQuota,omitempty" xml:"SmsQuota,omitempty"`
	// The total number of detection tasks.
	TaskQuota *int32 `json:"TaskQuota,omitempty" xml:"TaskQuota,omitempty"`
	// The used quota.
	UsedQuota *DescribeDnsGtmInstanceResponseBodyUsedQuota `json:"UsedQuota,omitempty" xml:"UsedQuota,omitempty" type:"Struct"`
	// The version of the instance.
	VersionCode *string `json:"VersionCode,omitempty" xml:"VersionCode,omitempty"`
}

func (s DescribeDnsGtmInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstanceResponseBody) SetConfig(v *DescribeDnsGtmInstanceResponseBodyConfig) *DescribeDnsGtmInstanceResponseBody {
	s.Config = v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBody) SetCreateTime(v string) *DescribeDnsGtmInstanceResponseBody {
	s.CreateTime = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBody) SetCreateTimestamp(v int64) *DescribeDnsGtmInstanceResponseBody {
	s.CreateTimestamp = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBody) SetExpireTime(v string) *DescribeDnsGtmInstanceResponseBody {
	s.ExpireTime = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBody) SetExpireTimestamp(v int64) *DescribeDnsGtmInstanceResponseBody {
	s.ExpireTimestamp = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBody) SetInstanceId(v string) *DescribeDnsGtmInstanceResponseBody {
	s.InstanceId = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBody) SetPaymentType(v string) *DescribeDnsGtmInstanceResponseBody {
	s.PaymentType = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBody) SetRequestId(v string) *DescribeDnsGtmInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBody) SetResourceGroupId(v string) *DescribeDnsGtmInstanceResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBody) SetSmsQuota(v int32) *DescribeDnsGtmInstanceResponseBody {
	s.SmsQuota = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBody) SetTaskQuota(v int32) *DescribeDnsGtmInstanceResponseBody {
	s.TaskQuota = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBody) SetUsedQuota(v *DescribeDnsGtmInstanceResponseBodyUsedQuota) *DescribeDnsGtmInstanceResponseBody {
	s.UsedQuota = v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBody) SetVersionCode(v string) *DescribeDnsGtmInstanceResponseBody {
	s.VersionCode = &v
	return s
}

type DescribeDnsGtmInstanceResponseBodyConfig struct {
	// The alert notification method.
	AlertConfig *DescribeDnsGtmInstanceResponseBodyConfigAlertConfig `json:"AlertConfig,omitempty" xml:"AlertConfig,omitempty" type:"Struct"`
	// The name of the alert group.
	AlertGroup *string `json:"AlertGroup,omitempty" xml:"AlertGroup,omitempty"`
	// The type of the CNAME domain name that is used to access the instance. Valid value:
	//
	// *   PUBLIC: The CNAME domain name is used to access the instance over the Internet.
	CnameType *string `json:"CnameType,omitempty" xml:"CnameType,omitempty"`
	// The name of the instance.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The domain name that is used to access the instance over the Internet.
	PubicZoneName *string `json:"PubicZoneName,omitempty" xml:"PubicZoneName,omitempty"`
	// Indicates whether a custom CNAME domain name or a CNAME domain name assigned by the system is used to access the instance over the Internet. Valid values:
	//
	// *   CUSTOM: A custom CNAME domain name is used.
	// *   SYSTEM_ASSIGN: A CNAME domain name assigned by the system is used.
	PublicCnameMode *string `json:"PublicCnameMode,omitempty" xml:"PublicCnameMode,omitempty"`
	// The hostname corresponding to the CNAME domain name that is used to access the instance over the Internet.
	PublicRr *string `json:"PublicRr,omitempty" xml:"PublicRr,omitempty"`
	// The service domain name that is used over the Internet.
	PublicUserDomainName *string `json:"PublicUserDomainName,omitempty" xml:"PublicUserDomainName,omitempty"`
	// The type of the access policy. Valid values:
	//
	// *   LATENCY: Latency-based
	// *   GEO: Geographical location-based
	StrategyMode *string `json:"StrategyMode,omitempty" xml:"StrategyMode,omitempty"`
	// The global time to live (TTL).
	Ttl *int32 `json:"Ttl,omitempty" xml:"Ttl,omitempty"`
}

func (s DescribeDnsGtmInstanceResponseBodyConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstanceResponseBodyConfig) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstanceResponseBodyConfig) SetAlertConfig(v *DescribeDnsGtmInstanceResponseBodyConfigAlertConfig) *DescribeDnsGtmInstanceResponseBodyConfig {
	s.AlertConfig = v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBodyConfig) SetAlertGroup(v string) *DescribeDnsGtmInstanceResponseBodyConfig {
	s.AlertGroup = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBodyConfig) SetCnameType(v string) *DescribeDnsGtmInstanceResponseBodyConfig {
	s.CnameType = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBodyConfig) SetInstanceName(v string) *DescribeDnsGtmInstanceResponseBodyConfig {
	s.InstanceName = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBodyConfig) SetPubicZoneName(v string) *DescribeDnsGtmInstanceResponseBodyConfig {
	s.PubicZoneName = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBodyConfig) SetPublicCnameMode(v string) *DescribeDnsGtmInstanceResponseBodyConfig {
	s.PublicCnameMode = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBodyConfig) SetPublicRr(v string) *DescribeDnsGtmInstanceResponseBodyConfig {
	s.PublicRr = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBodyConfig) SetPublicUserDomainName(v string) *DescribeDnsGtmInstanceResponseBodyConfig {
	s.PublicUserDomainName = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBodyConfig) SetStrategyMode(v string) *DescribeDnsGtmInstanceResponseBodyConfig {
	s.StrategyMode = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBodyConfig) SetTtl(v int32) *DescribeDnsGtmInstanceResponseBodyConfig {
	s.Ttl = &v
	return s
}

type DescribeDnsGtmInstanceResponseBodyConfigAlertConfig struct {
	AlertConfig []*DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig `json:"AlertConfig,omitempty" xml:"AlertConfig,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmInstanceResponseBodyConfigAlertConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstanceResponseBodyConfigAlertConfig) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstanceResponseBodyConfigAlertConfig) SetAlertConfig(v []*DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig) *DescribeDnsGtmInstanceResponseBodyConfigAlertConfig {
	s.AlertConfig = v
	return s
}

type DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig struct {
	DingtalkNotice *bool `json:"DingtalkNotice,omitempty" xml:"DingtalkNotice,omitempty"`
	// Indicates whether email notification is configured. Valid values:
	//
	// *   true: Email notification is configured.
	// *   false: Email notification is not configured. null: Email notification is not configured.
	EmailNotice *bool `json:"EmailNotice,omitempty" xml:"EmailNotice,omitempty"`
	// The type of the alert event. Valid values:
	//
	// *   ADDR_ALERT: The address is unavailable.
	// *   ADDR_RESUME: The address is restored and becomes available.
	// *   ADDR_POOL_GROUP_UNAVAILABLE: The address pool group is unavailable.
	// *   ADDR_POOL_GROUP_AVAILABLE: The address pool group is restored and becomes available.
	// *   ACCESS_STRATEGY_POOL_GROUP_SWITCH: Switchover is triggered between the primary and secondary address pools.
	// *   MONITOR_NODE_IP_CHANGE: The IP address of the monitoring node has changed.
	NoticeType *string `json:"NoticeType,omitempty" xml:"NoticeType,omitempty"`
	// Indicates whether SMS notification is configured. Valid values:
	//
	// *   true: SMS notification is configured.
	// *   false: SMS notification is not configured. null: SMS notification is not configured.
	SmsNotice *bool `json:"SmsNotice,omitempty" xml:"SmsNotice,omitempty"`
}

func (s DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig) SetDingtalkNotice(v bool) *DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig {
	s.DingtalkNotice = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig) SetEmailNotice(v bool) *DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig {
	s.EmailNotice = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig) SetNoticeType(v string) *DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig {
	s.NoticeType = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig) SetSmsNotice(v bool) *DescribeDnsGtmInstanceResponseBodyConfigAlertConfigAlertConfig {
	s.SmsNotice = &v
	return s
}

type DescribeDnsGtmInstanceResponseBodyUsedQuota struct {
	DingtalkUsedCount *int32 `json:"DingtalkUsedCount,omitempty" xml:"DingtalkUsedCount,omitempty"`
	// The total number of emails that were sent.
	EmailUsedCount *int32 `json:"EmailUsedCount,omitempty" xml:"EmailUsedCount,omitempty"`
	// The total number of short messages that were sent.
	SmsUsedCount *int32 `json:"SmsUsedCount,omitempty" xml:"SmsUsedCount,omitempty"`
	// The number of detection tasks that were created.
	TaskUsedCount *int32 `json:"TaskUsedCount,omitempty" xml:"TaskUsedCount,omitempty"`
}

func (s DescribeDnsGtmInstanceResponseBodyUsedQuota) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstanceResponseBodyUsedQuota) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstanceResponseBodyUsedQuota) SetDingtalkUsedCount(v int32) *DescribeDnsGtmInstanceResponseBodyUsedQuota {
	s.DingtalkUsedCount = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBodyUsedQuota) SetEmailUsedCount(v int32) *DescribeDnsGtmInstanceResponseBodyUsedQuota {
	s.EmailUsedCount = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBodyUsedQuota) SetSmsUsedCount(v int32) *DescribeDnsGtmInstanceResponseBodyUsedQuota {
	s.SmsUsedCount = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponseBodyUsedQuota) SetTaskUsedCount(v int32) *DescribeDnsGtmInstanceResponseBodyUsedQuota {
	s.TaskUsedCount = &v
	return s
}

type DescribeDnsGtmInstanceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDnsGtmInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDnsGtmInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstanceResponse) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstanceResponse) SetHeaders(v map[string]*string) *DescribeDnsGtmInstanceResponse {
	s.Headers = v
	return s
}

func (s *DescribeDnsGtmInstanceResponse) SetStatusCode(v int32) *DescribeDnsGtmInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDnsGtmInstanceResponse) SetBody(v *DescribeDnsGtmInstanceResponseBody) *DescribeDnsGtmInstanceResponse {
	s.Body = v
	return s
}

type DescribeDnsGtmInstanceAddressPoolRequest struct {
	// The ID of the address pool.
	AddrPoolId *string `json:"AddrPoolId,omitempty" xml:"AddrPoolId,omitempty"`
	// The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DescribeDnsGtmInstanceAddressPoolRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstanceAddressPoolRequest) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstanceAddressPoolRequest) SetAddrPoolId(v string) *DescribeDnsGtmInstanceAddressPoolRequest {
	s.AddrPoolId = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolRequest) SetLang(v string) *DescribeDnsGtmInstanceAddressPoolRequest {
	s.Lang = &v
	return s
}

type DescribeDnsGtmInstanceAddressPoolResponseBody struct {
	// The number of addresses in the address pool.
	AddrCount *int32 `json:"AddrCount,omitempty" xml:"AddrCount,omitempty"`
	// The ID of the address pool.
	AddrPoolId *string `json:"AddrPoolId,omitempty" xml:"AddrPoolId,omitempty"`
	// The addresses in the address pool.
	Addrs *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrs `json:"Addrs,omitempty" xml:"Addrs,omitempty" type:"Struct"`
	// The time when the address pool was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The timestamp that indicates the time when the address pool was created.
	CreateTimestamp *int64 `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The load balancing policy for the address pool. Valid values:
	//
	// *   ALL_RR: returns all addresses.
	// *   RATIO: returns addresses by weight.
	LbaStrategy *string `json:"LbaStrategy,omitempty" xml:"LbaStrategy,omitempty"`
	// The ID of the health check configuration.
	MonitorConfigId *string `json:"MonitorConfigId,omitempty" xml:"MonitorConfigId,omitempty"`
	// Indicates the status of the health check. Valid values:
	//
	// *   OPEN: The health check is enabled.
	// *   CLOSE: The health check is disabled.
	// *   UNCONFIGURED: The health check is not configured.
	MonitorStatus *string `json:"MonitorStatus,omitempty" xml:"MonitorStatus,omitempty"`
	// The name of the address pool.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The type of the address pool. Valid values:
	//
	// *   IPV4: IPv4 address
	// *   IPV6: IPv6 address
	// *   DOMAIN: domain name
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The time when the address pool was last updated.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The timestamp that indicates the time when the address pool was last updated.
	UpdateTimestamp *int64 `json:"UpdateTimestamp,omitempty" xml:"UpdateTimestamp,omitempty"`
}

func (s DescribeDnsGtmInstanceAddressPoolResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstanceAddressPoolResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBody) SetAddrCount(v int32) *DescribeDnsGtmInstanceAddressPoolResponseBody {
	s.AddrCount = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBody) SetAddrPoolId(v string) *DescribeDnsGtmInstanceAddressPoolResponseBody {
	s.AddrPoolId = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBody) SetAddrs(v *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrs) *DescribeDnsGtmInstanceAddressPoolResponseBody {
	s.Addrs = v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBody) SetCreateTime(v string) *DescribeDnsGtmInstanceAddressPoolResponseBody {
	s.CreateTime = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBody) SetCreateTimestamp(v int64) *DescribeDnsGtmInstanceAddressPoolResponseBody {
	s.CreateTimestamp = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBody) SetLbaStrategy(v string) *DescribeDnsGtmInstanceAddressPoolResponseBody {
	s.LbaStrategy = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBody) SetMonitorConfigId(v string) *DescribeDnsGtmInstanceAddressPoolResponseBody {
	s.MonitorConfigId = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBody) SetMonitorStatus(v string) *DescribeDnsGtmInstanceAddressPoolResponseBody {
	s.MonitorStatus = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBody) SetName(v string) *DescribeDnsGtmInstanceAddressPoolResponseBody {
	s.Name = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBody) SetRequestId(v string) *DescribeDnsGtmInstanceAddressPoolResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBody) SetType(v string) *DescribeDnsGtmInstanceAddressPoolResponseBody {
	s.Type = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBody) SetUpdateTime(v string) *DescribeDnsGtmInstanceAddressPoolResponseBody {
	s.UpdateTime = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBody) SetUpdateTimestamp(v int64) *DescribeDnsGtmInstanceAddressPoolResponseBody {
	s.UpdateTimestamp = &v
	return s
}

type DescribeDnsGtmInstanceAddressPoolResponseBodyAddrs struct {
	Addr []*DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr `json:"Addr,omitempty" xml:"Addr,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmInstanceAddressPoolResponseBodyAddrs) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstanceAddressPoolResponseBodyAddrs) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrs) SetAddr(v []*DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr) *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrs {
	s.Addr = v
	return s
}

type DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr struct {
	// The address.
	Addr *string `json:"Addr,omitempty" xml:"Addr,omitempty"`
	// The status of the last health check on the address. Valid values:
	//
	// *   OK: No active alerts are triggered.
	// *   ALERT: Alerts are triggered based on the alert rules.
	AlertStatus *string `json:"AlertStatus,omitempty" xml:"AlertStatus,omitempty"`
	// The source region of the address.
	//
	// *   lineCode: the line code of the source region of the address. This parameter is deprecated, and lineCodes prevails.
	// *   lineName: the line name of the source region of the address. This parameter is deprecated.
	// *   lineCodes: the line codes of the source regions of the address.
	AttributeInfo *string `json:"AttributeInfo,omitempty" xml:"AttributeInfo,omitempty"`
	// The time when the address was added into the address pool.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The timestamp that indicates the time when the address was added into the address pool.
	CreateTimestamp *int64 `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The weight of the address.
	LbaWeight *int32 `json:"LbaWeight,omitempty" xml:"LbaWeight,omitempty"`
	// The mode of the address. Valid values:
	//
	// *   SMART: smart return
	// *   ONLINE: always online
	// *   OFFLINE: always offline
	Mode *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The description of the address.
	Remark *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
	// The time when the address was last updated.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The timestamp that indicates the time when the address was last updated.
	UpdateTimestamp *int64 `json:"UpdateTimestamp,omitempty" xml:"UpdateTimestamp,omitempty"`
}

func (s DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr) SetAddr(v string) *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr {
	s.Addr = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr) SetAlertStatus(v string) *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr {
	s.AlertStatus = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr) SetAttributeInfo(v string) *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr {
	s.AttributeInfo = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr) SetCreateTime(v string) *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr {
	s.CreateTime = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr) SetCreateTimestamp(v int64) *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr {
	s.CreateTimestamp = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr) SetLbaWeight(v int32) *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr {
	s.LbaWeight = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr) SetMode(v string) *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr {
	s.Mode = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr) SetRemark(v string) *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr {
	s.Remark = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr) SetUpdateTime(v string) *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr {
	s.UpdateTime = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr) SetUpdateTimestamp(v int64) *DescribeDnsGtmInstanceAddressPoolResponseBodyAddrsAddr {
	s.UpdateTimestamp = &v
	return s
}

type DescribeDnsGtmInstanceAddressPoolResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDnsGtmInstanceAddressPoolResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDnsGtmInstanceAddressPoolResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstanceAddressPoolResponse) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstanceAddressPoolResponse) SetHeaders(v map[string]*string) *DescribeDnsGtmInstanceAddressPoolResponse {
	s.Headers = v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolResponse) SetStatusCode(v int32) *DescribeDnsGtmInstanceAddressPoolResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolResponse) SetBody(v *DescribeDnsGtmInstanceAddressPoolResponseBody) *DescribeDnsGtmInstanceAddressPoolResponse {
	s.Body = v
	return s
}

type DescribeDnsGtmInstanceAddressPoolsRequest struct {
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The number of the page to return. Pages start from page 1. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: 100. Default value: 20.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeDnsGtmInstanceAddressPoolsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstanceAddressPoolsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstanceAddressPoolsRequest) SetInstanceId(v string) *DescribeDnsGtmInstanceAddressPoolsRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolsRequest) SetLang(v string) *DescribeDnsGtmInstanceAddressPoolsRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolsRequest) SetPageNumber(v int32) *DescribeDnsGtmInstanceAddressPoolsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolsRequest) SetPageSize(v int32) *DescribeDnsGtmInstanceAddressPoolsRequest {
	s.PageSize = &v
	return s
}

type DescribeDnsGtmInstanceAddressPoolsResponseBody struct {
	// The returned address pools.
	AddrPools *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPools `json:"AddrPools,omitempty" xml:"AddrPools,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned on all pages.
	TotalItems *int32 `json:"TotalItems,omitempty" xml:"TotalItems,omitempty"`
	// The total number of pages returned.
	TotalPages *int32 `json:"TotalPages,omitempty" xml:"TotalPages,omitempty"`
}

func (s DescribeDnsGtmInstanceAddressPoolsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstanceAddressPoolsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstanceAddressPoolsResponseBody) SetAddrPools(v *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPools) *DescribeDnsGtmInstanceAddressPoolsResponseBody {
	s.AddrPools = v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolsResponseBody) SetPageNumber(v int32) *DescribeDnsGtmInstanceAddressPoolsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolsResponseBody) SetPageSize(v int32) *DescribeDnsGtmInstanceAddressPoolsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolsResponseBody) SetRequestId(v string) *DescribeDnsGtmInstanceAddressPoolsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolsResponseBody) SetTotalItems(v int32) *DescribeDnsGtmInstanceAddressPoolsResponseBody {
	s.TotalItems = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolsResponseBody) SetTotalPages(v int32) *DescribeDnsGtmInstanceAddressPoolsResponseBody {
	s.TotalPages = &v
	return s
}

type DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPools struct {
	AddrPool []*DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool `json:"AddrPool,omitempty" xml:"AddrPool,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPools) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPools) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPools) SetAddrPool(v []*DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPools {
	s.AddrPool = v
	return s
}

type DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool struct {
	// The number of addresses in the address pool.
	AddrCount *int32 `json:"AddrCount,omitempty" xml:"AddrCount,omitempty"`
	// The ID of the address pool.
	AddrPoolId *string `json:"AddrPoolId,omitempty" xml:"AddrPoolId,omitempty"`
	// The time when the address pool was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The timestamp that indicates when the address pool was created.
	CreateTimestamp *int64 `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The load balancing policy of the address pool. Valid values:
	//
	// *   ALL_RR: returns all addresses.
	// *   RATIO: returns addresses by weight.
	LbaStrategy *string `json:"LbaStrategy,omitempty" xml:"LbaStrategy,omitempty"`
	// The ID of the health check task.
	MonitorConfigId *string `json:"MonitorConfigId,omitempty" xml:"MonitorConfigId,omitempty"`
	// Indicates whether health checks are configured. Valid values:
	//
	// *   OPEN: enabled
	// *   CLOSE: disabled
	// *   UNCONFIGURED: not configured
	MonitorStatus *string `json:"MonitorStatus,omitempty" xml:"MonitorStatus,omitempty"`
	// The name of the address pool.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the address pool. Valid values:
	//
	// *   IPV4: IPv4 address
	// *   IPV6: IPv6 address
	// *   DOMAIN: domain name
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The time when the address pool was updated.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The timestamp that indicates when the address pool was updated.
	UpdateTimestamp *int64 `json:"UpdateTimestamp,omitempty" xml:"UpdateTimestamp,omitempty"`
}

func (s DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) SetAddrCount(v int32) *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool {
	s.AddrCount = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) SetAddrPoolId(v string) *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool {
	s.AddrPoolId = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) SetCreateTime(v string) *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool {
	s.CreateTime = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) SetCreateTimestamp(v int64) *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool {
	s.CreateTimestamp = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) SetLbaStrategy(v string) *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool {
	s.LbaStrategy = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) SetMonitorConfigId(v string) *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool {
	s.MonitorConfigId = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) SetMonitorStatus(v string) *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool {
	s.MonitorStatus = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) SetName(v string) *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool {
	s.Name = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) SetType(v string) *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool {
	s.Type = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) SetUpdateTime(v string) *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool {
	s.UpdateTime = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) SetUpdateTimestamp(v int64) *DescribeDnsGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool {
	s.UpdateTimestamp = &v
	return s
}

type DescribeDnsGtmInstanceAddressPoolsResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDnsGtmInstanceAddressPoolsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDnsGtmInstanceAddressPoolsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstanceAddressPoolsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstanceAddressPoolsResponse) SetHeaders(v map[string]*string) *DescribeDnsGtmInstanceAddressPoolsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolsResponse) SetStatusCode(v int32) *DescribeDnsGtmInstanceAddressPoolsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDnsGtmInstanceAddressPoolsResponse) SetBody(v *DescribeDnsGtmInstanceAddressPoolsResponseBody) *DescribeDnsGtmInstanceAddressPoolsResponse {
	s.Body = v
	return s
}

type DescribeDnsGtmInstanceStatusRequest struct {
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DescribeDnsGtmInstanceStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstanceStatusRequest) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstanceStatusRequest) SetInstanceId(v string) *DescribeDnsGtmInstanceStatusRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeDnsGtmInstanceStatusRequest) SetLang(v string) *DescribeDnsGtmInstanceStatusRequest {
	s.Lang = &v
	return s
}

type DescribeDnsGtmInstanceStatusResponseBody struct {
	// The number of available addresses.
	AddrAvailableNum *int32 `json:"AddrAvailableNum,omitempty" xml:"AddrAvailableNum,omitempty"`
	// The number of unavailable addresses.
	AddrNotAvailableNum *int32 `json:"AddrNotAvailableNum,omitempty" xml:"AddrNotAvailableNum,omitempty"`
	// The number of unavailable address pool groups.
	AddrPoolGroupNotAvailableNum *int32 `json:"AddrPoolGroupNotAvailableNum,omitempty" xml:"AddrPoolGroupNotAvailableNum,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of access policies that are unavailable in the current active address pool group.
	StrategyNotAvailableNum *int32 `json:"StrategyNotAvailableNum,omitempty" xml:"StrategyNotAvailableNum,omitempty"`
	// The number of access policies switched to the secondary address pool group.
	SwitchToFailoverStrategyNum *int32 `json:"SwitchToFailoverStrategyNum,omitempty" xml:"SwitchToFailoverStrategyNum,omitempty"`
}

func (s DescribeDnsGtmInstanceStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstanceStatusResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstanceStatusResponseBody) SetAddrAvailableNum(v int32) *DescribeDnsGtmInstanceStatusResponseBody {
	s.AddrAvailableNum = &v
	return s
}

func (s *DescribeDnsGtmInstanceStatusResponseBody) SetAddrNotAvailableNum(v int32) *DescribeDnsGtmInstanceStatusResponseBody {
	s.AddrNotAvailableNum = &v
	return s
}

func (s *DescribeDnsGtmInstanceStatusResponseBody) SetAddrPoolGroupNotAvailableNum(v int32) *DescribeDnsGtmInstanceStatusResponseBody {
	s.AddrPoolGroupNotAvailableNum = &v
	return s
}

func (s *DescribeDnsGtmInstanceStatusResponseBody) SetRequestId(v string) *DescribeDnsGtmInstanceStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDnsGtmInstanceStatusResponseBody) SetStrategyNotAvailableNum(v int32) *DescribeDnsGtmInstanceStatusResponseBody {
	s.StrategyNotAvailableNum = &v
	return s
}

func (s *DescribeDnsGtmInstanceStatusResponseBody) SetSwitchToFailoverStrategyNum(v int32) *DescribeDnsGtmInstanceStatusResponseBody {
	s.SwitchToFailoverStrategyNum = &v
	return s
}

type DescribeDnsGtmInstanceStatusResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDnsGtmInstanceStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDnsGtmInstanceStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstanceStatusResponse) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstanceStatusResponse) SetHeaders(v map[string]*string) *DescribeDnsGtmInstanceStatusResponse {
	s.Headers = v
	return s
}

func (s *DescribeDnsGtmInstanceStatusResponse) SetStatusCode(v int32) *DescribeDnsGtmInstanceStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDnsGtmInstanceStatusResponse) SetBody(v *DescribeDnsGtmInstanceStatusResponseBody) *DescribeDnsGtmInstanceStatusResponse {
	s.Body = v
	return s
}

type DescribeDnsGtmInstanceSystemCnameRequest struct {
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DescribeDnsGtmInstanceSystemCnameRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstanceSystemCnameRequest) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstanceSystemCnameRequest) SetInstanceId(v string) *DescribeDnsGtmInstanceSystemCnameRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeDnsGtmInstanceSystemCnameRequest) SetLang(v string) *DescribeDnsGtmInstanceSystemCnameRequest {
	s.Lang = &v
	return s
}

type DescribeDnsGtmInstanceSystemCnameResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The CNAME domain name assigned by the system.
	SystemCname *string `json:"SystemCname,omitempty" xml:"SystemCname,omitempty"`
}

func (s DescribeDnsGtmInstanceSystemCnameResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstanceSystemCnameResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstanceSystemCnameResponseBody) SetRequestId(v string) *DescribeDnsGtmInstanceSystemCnameResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDnsGtmInstanceSystemCnameResponseBody) SetSystemCname(v string) *DescribeDnsGtmInstanceSystemCnameResponseBody {
	s.SystemCname = &v
	return s
}

type DescribeDnsGtmInstanceSystemCnameResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDnsGtmInstanceSystemCnameResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDnsGtmInstanceSystemCnameResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstanceSystemCnameResponse) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstanceSystemCnameResponse) SetHeaders(v map[string]*string) *DescribeDnsGtmInstanceSystemCnameResponse {
	s.Headers = v
	return s
}

func (s *DescribeDnsGtmInstanceSystemCnameResponse) SetStatusCode(v int32) *DescribeDnsGtmInstanceSystemCnameResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDnsGtmInstanceSystemCnameResponse) SetBody(v *DescribeDnsGtmInstanceSystemCnameResponseBody) *DescribeDnsGtmInstanceSystemCnameResponse {
	s.Body = v
	return s
}

type DescribeDnsGtmInstancesRequest struct {
	// The keyword that you use for query. Fuzzy search by instance ID or instance name is supported.
	Keyword *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	// The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group where you want to query instances.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeDnsGtmInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstancesRequest) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstancesRequest) SetKeyword(v string) *DescribeDnsGtmInstancesRequest {
	s.Keyword = &v
	return s
}

func (s *DescribeDnsGtmInstancesRequest) SetLang(v string) *DescribeDnsGtmInstancesRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDnsGtmInstancesRequest) SetPageNumber(v int32) *DescribeDnsGtmInstancesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDnsGtmInstancesRequest) SetPageSize(v int32) *DescribeDnsGtmInstancesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDnsGtmInstancesRequest) SetResourceGroupId(v string) *DescribeDnsGtmInstancesRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeDnsGtmInstancesResponseBody struct {
	// The returned instances.
	GtmInstances []*DescribeDnsGtmInstancesResponseBodyGtmInstances `json:"GtmInstances,omitempty" xml:"GtmInstances,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned on all pages.
	TotalItems *int32 `json:"TotalItems,omitempty" xml:"TotalItems,omitempty"`
	// The total number of returned pages.
	TotalPages *int32 `json:"TotalPages,omitempty" xml:"TotalPages,omitempty"`
}

func (s DescribeDnsGtmInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstancesResponseBody) SetGtmInstances(v []*DescribeDnsGtmInstancesResponseBodyGtmInstances) *DescribeDnsGtmInstancesResponseBody {
	s.GtmInstances = v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBody) SetPageNumber(v int32) *DescribeDnsGtmInstancesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBody) SetPageSize(v int32) *DescribeDnsGtmInstancesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBody) SetRequestId(v string) *DescribeDnsGtmInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBody) SetTotalItems(v int32) *DescribeDnsGtmInstancesResponseBody {
	s.TotalItems = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBody) SetTotalPages(v int32) *DescribeDnsGtmInstancesResponseBody {
	s.TotalPages = &v
	return s
}

type DescribeDnsGtmInstancesResponseBodyGtmInstances struct {
	// The configurations of the instance.
	Config *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig `json:"Config,omitempty" xml:"Config,omitempty" type:"Struct"`
	// The time when the instance was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The timestamp that indicates when the instance was created.
	CreateTimestamp *int64 `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The time when the instance expires.
	ExpireTime *string `json:"ExpireTime,omitempty" xml:"ExpireTime,omitempty"`
	// The timestamp that indicates when the instance expires.
	ExpireTimestamp *int64 `json:"ExpireTimestamp,omitempty" xml:"ExpireTimestamp,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The billing method of the instance.
	//
	// *   The value is set to Subscription.
	PaymentType *string `json:"PaymentType,omitempty" xml:"PaymentType,omitempty"`
	// The ID of the resource group to which the instance belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The total number of SMS notifications.
	SmsQuota *int32 `json:"SmsQuota,omitempty" xml:"SmsQuota,omitempty"`
	// The total number of detection tasks.
	TaskQuota *int32 `json:"TaskQuota,omitempty" xml:"TaskQuota,omitempty"`
	// The used quota.
	UsedQuota *DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota `json:"UsedQuota,omitempty" xml:"UsedQuota,omitempty" type:"Struct"`
	// The version of the instance.
	VersionCode *string `json:"VersionCode,omitempty" xml:"VersionCode,omitempty"`
}

func (s DescribeDnsGtmInstancesResponseBodyGtmInstances) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstancesResponseBodyGtmInstances) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstances) SetConfig(v *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig) *DescribeDnsGtmInstancesResponseBodyGtmInstances {
	s.Config = v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstances) SetCreateTime(v string) *DescribeDnsGtmInstancesResponseBodyGtmInstances {
	s.CreateTime = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstances) SetCreateTimestamp(v int64) *DescribeDnsGtmInstancesResponseBodyGtmInstances {
	s.CreateTimestamp = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstances) SetExpireTime(v string) *DescribeDnsGtmInstancesResponseBodyGtmInstances {
	s.ExpireTime = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstances) SetExpireTimestamp(v int64) *DescribeDnsGtmInstancesResponseBodyGtmInstances {
	s.ExpireTimestamp = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstances) SetInstanceId(v string) *DescribeDnsGtmInstancesResponseBodyGtmInstances {
	s.InstanceId = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstances) SetPaymentType(v string) *DescribeDnsGtmInstancesResponseBodyGtmInstances {
	s.PaymentType = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstances) SetResourceGroupId(v string) *DescribeDnsGtmInstancesResponseBodyGtmInstances {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstances) SetSmsQuota(v int32) *DescribeDnsGtmInstancesResponseBodyGtmInstances {
	s.SmsQuota = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstances) SetTaskQuota(v int32) *DescribeDnsGtmInstancesResponseBodyGtmInstances {
	s.TaskQuota = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstances) SetUsedQuota(v *DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota) *DescribeDnsGtmInstancesResponseBodyGtmInstances {
	s.UsedQuota = v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstances) SetVersionCode(v string) *DescribeDnsGtmInstancesResponseBodyGtmInstances {
	s.VersionCode = &v
	return s
}

type DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig struct {
	// The alert notification methods.
	AlertConfig []*DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig `json:"AlertConfig,omitempty" xml:"AlertConfig,omitempty" type:"Repeated"`
	// The alert group.
	AlertGroup *string `json:"AlertGroup,omitempty" xml:"AlertGroup,omitempty"`
	// The access type of the CNAME domain name.
	//
	// *   The value was set to PUBLIC, which indicates Internet access.
	CnameType *string `json:"CnameType,omitempty" xml:"CnameType,omitempty"`
	// The name of the instance.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// Indicates whether a custom CNAME domain name or a CNAME domain name assigned by the system is used to access GTM over the Internet. Valid values:
	//
	// *   CUSTOM: a custom CNAME domain name
	// *   SYSTEM_ASSIGN: a CNAME domain name assigned by the system
	PublicCnameMode *string `json:"PublicCnameMode,omitempty" xml:"PublicCnameMode,omitempty"`
	PublicRr        *string `json:"PublicRr,omitempty" xml:"PublicRr,omitempty"`
	// The website domain name that the user uses on the Internet.
	PublicUserDomainName *string `json:"PublicUserDomainName,omitempty" xml:"PublicUserDomainName,omitempty"`
	// The domain name that is used to access GTM over the Internet.
	PublicZoneName *string `json:"PublicZoneName,omitempty" xml:"PublicZoneName,omitempty"`
	// The type of the access policy. Valid values:
	//
	// *   LATENCY: latency-based
	// *   GEO: geographical location-based
	StrategyMode *string `json:"StrategyMode,omitempty" xml:"StrategyMode,omitempty"`
	// The global time to live (TTL).
	Ttl *int32 `json:"Ttl,omitempty" xml:"Ttl,omitempty"`
}

func (s DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig) SetAlertConfig(v []*DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig) *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig {
	s.AlertConfig = v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig) SetAlertGroup(v string) *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig {
	s.AlertGroup = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig) SetCnameType(v string) *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig {
	s.CnameType = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig) SetInstanceName(v string) *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig {
	s.InstanceName = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig) SetPublicCnameMode(v string) *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig {
	s.PublicCnameMode = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig) SetPublicRr(v string) *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig {
	s.PublicRr = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig) SetPublicUserDomainName(v string) *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig {
	s.PublicUserDomainName = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig) SetPublicZoneName(v string) *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig {
	s.PublicZoneName = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig) SetStrategyMode(v string) *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig {
	s.StrategyMode = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig) SetTtl(v int32) *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfig {
	s.Ttl = &v
	return s
}

type DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig struct {
	DingtalkNotice *string `json:"DingtalkNotice,omitempty" xml:"DingtalkNotice,omitempty"`
	// Indicates whether email notifications were configured. Valid values:
	//
	// *   true: configured
	// *   false | null: not configured
	EmailNotice *string `json:"EmailNotice,omitempty" xml:"EmailNotice,omitempty"`
	// The type of the alert event. Valid values:
	//
	// *   ADDR_ALERT: The address is unavailable.
	// *   ADDR_RESUME: The address is restored and becomes available.
	// *   ADDR_POOL_GROUP_UNAVAILABLE: The address pool group is unavailable.
	// *   ADDR_POOL_GROUP_AVAILABLE: The address pool group is restored and becomes available.
	// *   ACCESS_STRATEGY_POOL_GROUP_SWITCH: Switchover is triggered between the primary and secondary address pools.
	NoticeType *string `json:"NoticeType,omitempty" xml:"NoticeType,omitempty"`
	// Indicates whether SMS notifications were configured. Valid values:
	//
	// *   true: configured
	// *   false | null: not configured
	SmsNotice *string `json:"SmsNotice,omitempty" xml:"SmsNotice,omitempty"`
}

func (s DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig) SetDingtalkNotice(v string) *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig {
	s.DingtalkNotice = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig) SetEmailNotice(v string) *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig {
	s.EmailNotice = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig) SetNoticeType(v string) *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig {
	s.NoticeType = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig) SetSmsNotice(v string) *DescribeDnsGtmInstancesResponseBodyGtmInstancesConfigAlertConfig {
	s.SmsNotice = &v
	return s
}

type DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota struct {
	DingtalkUsedCount *int32 `json:"DingtalkUsedCount,omitempty" xml:"DingtalkUsedCount,omitempty"`
	// The total number of email notifications that were sent.
	EmailUsedCount *int32 `json:"EmailUsedCount,omitempty" xml:"EmailUsedCount,omitempty"`
	// The total number of SMS notifications that were sent.
	SmsUsedCount *int32 `json:"SmsUsedCount,omitempty" xml:"SmsUsedCount,omitempty"`
	// The number of detection tasks that were created.
	TaskUsedCount *int32 `json:"TaskUsedCount,omitempty" xml:"TaskUsedCount,omitempty"`
}

func (s DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota) SetDingtalkUsedCount(v int32) *DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota {
	s.DingtalkUsedCount = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota) SetEmailUsedCount(v int32) *DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota {
	s.EmailUsedCount = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota) SetSmsUsedCount(v int32) *DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota {
	s.SmsUsedCount = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota) SetTaskUsedCount(v int32) *DescribeDnsGtmInstancesResponseBodyGtmInstancesUsedQuota {
	s.TaskUsedCount = &v
	return s
}

type DescribeDnsGtmInstancesResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDnsGtmInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDnsGtmInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmInstancesResponse) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmInstancesResponse) SetHeaders(v map[string]*string) *DescribeDnsGtmInstancesResponse {
	s.Headers = v
	return s
}

func (s *DescribeDnsGtmInstancesResponse) SetStatusCode(v int32) *DescribeDnsGtmInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDnsGtmInstancesResponse) SetBody(v *DescribeDnsGtmInstancesResponseBody) *DescribeDnsGtmInstancesResponse {
	s.Body = v
	return s
}

type DescribeDnsGtmLogsRequest struct {
	// The timestamp that specifies the end of the time range to query.
	EndTimestamp *int64 `json:"EndTimestamp,omitempty" xml:"EndTimestamp,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The keyword for searches in "%KeyWord%" mode. The value is not case-sensitive.
	Keyword *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	// The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The number of the page to return. Pages start from page 1. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: 100. Default value: 20.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The timestamp that specifies the beginning of the time range to query.
	StartTimestamp *int64 `json:"StartTimestamp,omitempty" xml:"StartTimestamp,omitempty"`
}

func (s DescribeDnsGtmLogsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmLogsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmLogsRequest) SetEndTimestamp(v int64) *DescribeDnsGtmLogsRequest {
	s.EndTimestamp = &v
	return s
}

func (s *DescribeDnsGtmLogsRequest) SetInstanceId(v string) *DescribeDnsGtmLogsRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeDnsGtmLogsRequest) SetKeyword(v string) *DescribeDnsGtmLogsRequest {
	s.Keyword = &v
	return s
}

func (s *DescribeDnsGtmLogsRequest) SetLang(v string) *DescribeDnsGtmLogsRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDnsGtmLogsRequest) SetPageNumber(v int32) *DescribeDnsGtmLogsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDnsGtmLogsRequest) SetPageSize(v int32) *DescribeDnsGtmLogsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDnsGtmLogsRequest) SetStartTimestamp(v int64) *DescribeDnsGtmLogsRequest {
	s.StartTimestamp = &v
	return s
}

type DescribeDnsGtmLogsResponseBody struct {
	// The returned logs.
	Logs *DescribeDnsGtmLogsResponseBodyLogs `json:"Logs,omitempty" xml:"Logs,omitempty" type:"Struct"`
	// The number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned on all pages.
	TotalItems *int32 `json:"TotalItems,omitempty" xml:"TotalItems,omitempty"`
	// The total number of pages returned.
	TotalPages *int32 `json:"TotalPages,omitempty" xml:"TotalPages,omitempty"`
}

func (s DescribeDnsGtmLogsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmLogsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmLogsResponseBody) SetLogs(v *DescribeDnsGtmLogsResponseBodyLogs) *DescribeDnsGtmLogsResponseBody {
	s.Logs = v
	return s
}

func (s *DescribeDnsGtmLogsResponseBody) SetPageNumber(v int32) *DescribeDnsGtmLogsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDnsGtmLogsResponseBody) SetPageSize(v int32) *DescribeDnsGtmLogsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDnsGtmLogsResponseBody) SetRequestId(v string) *DescribeDnsGtmLogsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDnsGtmLogsResponseBody) SetTotalItems(v int32) *DescribeDnsGtmLogsResponseBody {
	s.TotalItems = &v
	return s
}

func (s *DescribeDnsGtmLogsResponseBody) SetTotalPages(v int32) *DescribeDnsGtmLogsResponseBody {
	s.TotalPages = &v
	return s
}

type DescribeDnsGtmLogsResponseBodyLogs struct {
	Log []*DescribeDnsGtmLogsResponseBodyLogsLog `json:"Log,omitempty" xml:"Log,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmLogsResponseBodyLogs) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmLogsResponseBodyLogs) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmLogsResponseBodyLogs) SetLog(v []*DescribeDnsGtmLogsResponseBodyLogsLog) *DescribeDnsGtmLogsResponseBodyLogs {
	s.Log = v
	return s
}

type DescribeDnsGtmLogsResponseBodyLogsLog struct {
	// The formatted message content.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the object on which the operation was performed.
	EntityId *string `json:"EntityId,omitempty" xml:"EntityId,omitempty"`
	// The name of the object on which the operation was performed.
	EntityName *string `json:"EntityName,omitempty" xml:"EntityName,omitempty"`
	// The type of the object on which the operation was performed.
	EntityType *string `json:"EntityType,omitempty" xml:"EntityType,omitempty"`
	// The ID of the record.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The operation performed.
	OperAction *string `json:"OperAction,omitempty" xml:"OperAction,omitempty"`
	// The time when the operation was performed.
	OperTime *string `json:"OperTime,omitempty" xml:"OperTime,omitempty"`
	// The timestamp of the operation.
	OperTimestamp *int64 `json:"OperTimestamp,omitempty" xml:"OperTimestamp,omitempty"`
}

func (s DescribeDnsGtmLogsResponseBodyLogsLog) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmLogsResponseBodyLogsLog) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmLogsResponseBodyLogsLog) SetContent(v string) *DescribeDnsGtmLogsResponseBodyLogsLog {
	s.Content = &v
	return s
}

func (s *DescribeDnsGtmLogsResponseBodyLogsLog) SetEntityId(v string) *DescribeDnsGtmLogsResponseBodyLogsLog {
	s.EntityId = &v
	return s
}

func (s *DescribeDnsGtmLogsResponseBodyLogsLog) SetEntityName(v string) *DescribeDnsGtmLogsResponseBodyLogsLog {
	s.EntityName = &v
	return s
}

func (s *DescribeDnsGtmLogsResponseBodyLogsLog) SetEntityType(v string) *DescribeDnsGtmLogsResponseBodyLogsLog {
	s.EntityType = &v
	return s
}

func (s *DescribeDnsGtmLogsResponseBodyLogsLog) SetId(v int64) *DescribeDnsGtmLogsResponseBodyLogsLog {
	s.Id = &v
	return s
}

func (s *DescribeDnsGtmLogsResponseBodyLogsLog) SetOperAction(v string) *DescribeDnsGtmLogsResponseBodyLogsLog {
	s.OperAction = &v
	return s
}

func (s *DescribeDnsGtmLogsResponseBodyLogsLog) SetOperTime(v string) *DescribeDnsGtmLogsResponseBodyLogsLog {
	s.OperTime = &v
	return s
}

func (s *DescribeDnsGtmLogsResponseBodyLogsLog) SetOperTimestamp(v int64) *DescribeDnsGtmLogsResponseBodyLogsLog {
	s.OperTimestamp = &v
	return s
}

type DescribeDnsGtmLogsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDnsGtmLogsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDnsGtmLogsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmLogsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmLogsResponse) SetHeaders(v map[string]*string) *DescribeDnsGtmLogsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDnsGtmLogsResponse) SetStatusCode(v int32) *DescribeDnsGtmLogsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDnsGtmLogsResponse) SetBody(v *DescribeDnsGtmLogsResponseBody) *DescribeDnsGtmLogsResponse {
	s.Body = v
	return s
}

type DescribeDnsGtmMonitorAvailableConfigRequest struct {
	// The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DescribeDnsGtmMonitorAvailableConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmMonitorAvailableConfigRequest) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmMonitorAvailableConfigRequest) SetLang(v string) *DescribeDnsGtmMonitorAvailableConfigRequest {
	s.Lang = &v
	return s
}

type DescribeDnsGtmMonitorAvailableConfigResponseBody struct {
	// The monitored nodes that can be used to perform health checks on address pools that contain public domain names that are resolved to IPv4 addresses.
	DomainIpv4IspCityNodes *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodes `json:"DomainIpv4IspCityNodes,omitempty" xml:"DomainIpv4IspCityNodes,omitempty" type:"Struct"`
	// The monitored nodes that can be used to perform health checks on address pools that contain public domain names that are resolved to IPv6 addresses.
	DomainIpv6IspCityNodes *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodes `json:"DomainIpv6IspCityNodes,omitempty" xml:"DomainIpv6IspCityNodes,omitempty" type:"Struct"`
	// The monitored nodes that can be used to perform health checks on address pools that contain public IPv4 addresses.
	Ipv4IspCityNodes *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodes `json:"Ipv4IspCityNodes,omitempty" xml:"Ipv4IspCityNodes,omitempty" type:"Struct"`
	// The monitored nodes that can be used to perform health checks on address pools that contain public IPv6 addresses.
	Ipv6IspCityNodes *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodes `json:"Ipv6IspCityNodes,omitempty" xml:"Ipv6IspCityNodes,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBody) SetDomainIpv4IspCityNodes(v *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodes) *DescribeDnsGtmMonitorAvailableConfigResponseBody {
	s.DomainIpv4IspCityNodes = v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBody) SetDomainIpv6IspCityNodes(v *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodes) *DescribeDnsGtmMonitorAvailableConfigResponseBody {
	s.DomainIpv6IspCityNodes = v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBody) SetIpv4IspCityNodes(v *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodes) *DescribeDnsGtmMonitorAvailableConfigResponseBody {
	s.Ipv4IspCityNodes = v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBody) SetIpv6IspCityNodes(v *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodes) *DescribeDnsGtmMonitorAvailableConfigResponseBody {
	s.Ipv6IspCityNodes = v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBody) SetRequestId(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodes struct {
	DomainIpv4IspCityNode []*DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode `json:"DomainIpv4IspCityNode,omitempty" xml:"DomainIpv4IspCityNode,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodes) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodes) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodes) SetDomainIpv4IspCityNode(v []*DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode) *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodes {
	s.DomainIpv4IspCityNode = v
	return s
}

type DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode struct {
	// The code of the city where the monitored node is deployed.
	CityCode *string `json:"CityCode,omitempty" xml:"CityCode,omitempty"`
	// The display name of the city where the monitored node is deployed.
	CityName *string `json:"CityName,omitempty" xml:"CityName,omitempty"`
	// Indicates whether the monitored node is selected for the health check by default.
	DefaultSelected *bool `json:"DefaultSelected,omitempty" xml:"DefaultSelected,omitempty"`
	// The name of the group to which the monitored node belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The type of the group to which the monitored node belongs. Valid values:
	//
	// *   BGP: BGP nodes
	// *   OVERSEAS: nodes outside the Chinese mainland
	// *   ISP: ISP nodes
	GroupType *string                                                                                         `json:"GroupType,omitempty" xml:"GroupType,omitempty"`
	Ips       *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNodeIps `json:"Ips,omitempty" xml:"Ips,omitempty" type:"Struct"`
	// The code of the ISP to which the monitored node belongs.
	IspCode *string `json:"IspCode,omitempty" xml:"IspCode,omitempty"`
	// The display name of the ISP to which the monitored node belongs.
	IspName *string `json:"IspName,omitempty" xml:"IspName,omitempty"`
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode) SetCityCode(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode {
	s.CityCode = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode) SetCityName(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode {
	s.CityName = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode) SetDefaultSelected(v bool) *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode {
	s.DefaultSelected = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode) SetGroupName(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode {
	s.GroupName = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode) SetGroupType(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode {
	s.GroupType = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode) SetIps(v *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNodeIps) *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode {
	s.Ips = v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode) SetIspCode(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode {
	s.IspCode = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode) SetIspName(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNode {
	s.IspName = &v
	return s
}

type DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNodeIps struct {
	Ip []*string `json:"Ip,omitempty" xml:"Ip,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNodeIps) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNodeIps) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNodeIps) SetIp(v []*string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv4IspCityNodesDomainIpv4IspCityNodeIps {
	s.Ip = v
	return s
}

type DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodes struct {
	DomainIpv6IspCityNode []*DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode `json:"DomainIpv6IspCityNode,omitempty" xml:"DomainIpv6IspCityNode,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodes) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodes) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodes) SetDomainIpv6IspCityNode(v []*DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode) *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodes {
	s.DomainIpv6IspCityNode = v
	return s
}

type DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode struct {
	// The code of the city where the monitored node is deployed.
	CityCode *string `json:"CityCode,omitempty" xml:"CityCode,omitempty"`
	// The display name of the city where the monitored node is deployed.
	CityName *string `json:"CityName,omitempty" xml:"CityName,omitempty"`
	// Indicates whether the monitored node is selected for the health check by default.
	DefaultSelected *bool `json:"DefaultSelected,omitempty" xml:"DefaultSelected,omitempty"`
	// The name of the group to which the monitored node belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The type of the group to which the monitored node belongs. Valid values:
	//
	// *   BGP: BGP nodes
	// *   OVERSEAS: nodes outside the Chinese mainland
	// *   ISP: ISP nodes
	GroupType *string                                                                                         `json:"GroupType,omitempty" xml:"GroupType,omitempty"`
	Ips       *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNodeIps `json:"Ips,omitempty" xml:"Ips,omitempty" type:"Struct"`
	// The code of the ISP to which the monitored node belongs.
	IspCode *string `json:"IspCode,omitempty" xml:"IspCode,omitempty"`
	// The display name of the ISP to which the monitored node belongs.
	IspName *string `json:"IspName,omitempty" xml:"IspName,omitempty"`
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode) SetCityCode(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode {
	s.CityCode = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode) SetCityName(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode {
	s.CityName = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode) SetDefaultSelected(v bool) *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode {
	s.DefaultSelected = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode) SetGroupName(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode {
	s.GroupName = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode) SetGroupType(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode {
	s.GroupType = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode) SetIps(v *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNodeIps) *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode {
	s.Ips = v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode) SetIspCode(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode {
	s.IspCode = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode) SetIspName(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNode {
	s.IspName = &v
	return s
}

type DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNodeIps struct {
	Ip []*string `json:"ip,omitempty" xml:"ip,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNodeIps) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNodeIps) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNodeIps) SetIp(v []*string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyDomainIpv6IspCityNodesDomainIpv6IspCityNodeIps {
	s.Ip = v
	return s
}

type DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodes struct {
	Ipv4IspCityNode []*DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode `json:"Ipv4IspCityNode,omitempty" xml:"Ipv4IspCityNode,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodes) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodes) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodes) SetIpv4IspCityNode(v []*DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode) *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodes {
	s.Ipv4IspCityNode = v
	return s
}

type DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode struct {
	// The code of the city where the monitored node is deployed.
	CityCode *string `json:"CityCode,omitempty" xml:"CityCode,omitempty"`
	// The display name of the city where the monitored node is deployed.
	CityName *string `json:"CityName,omitempty" xml:"CityName,omitempty"`
	// Indicates whether the monitored node is selected for the health check by default.
	DefaultSelected *bool `json:"DefaultSelected,omitempty" xml:"DefaultSelected,omitempty"`
	// The name of the group to which the monitored node belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The type of the group to which the monitored node belongs. Valid values:
	//
	// *   BGP: Border Gateway Protocol (BGP) nodes
	// *   OVERSEAS: nodes outside the Chinese mainland
	// *   ISP: ISP nodes
	GroupType *string                                                                             `json:"GroupType,omitempty" xml:"GroupType,omitempty"`
	Ips       *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps `json:"Ips,omitempty" xml:"Ips,omitempty" type:"Struct"`
	// The code of the Internet service provider (ISP) to which the monitored node belongs.
	IspCode *string `json:"IspCode,omitempty" xml:"IspCode,omitempty"`
	// The display name of the ISP to which the monitored node belongs.
	IspName *string `json:"IspName,omitempty" xml:"IspName,omitempty"`
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode) SetCityCode(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode {
	s.CityCode = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode) SetCityName(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode {
	s.CityName = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode) SetDefaultSelected(v bool) *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode {
	s.DefaultSelected = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode) SetGroupName(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode {
	s.GroupName = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode) SetGroupType(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode {
	s.GroupType = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode) SetIps(v *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps) *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode {
	s.Ips = v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode) SetIspCode(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode {
	s.IspCode = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode) SetIspName(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNode {
	s.IspName = &v
	return s
}

type DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps struct {
	Ip []*string `json:"Ip,omitempty" xml:"Ip,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps) SetIp(v []*string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv4IspCityNodesIpv4IspCityNodeIps {
	s.Ip = v
	return s
}

type DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodes struct {
	Ipv6IspCityNode []*DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode `json:"Ipv6IspCityNode,omitempty" xml:"Ipv6IspCityNode,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodes) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodes) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodes) SetIpv6IspCityNode(v []*DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode) *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodes {
	s.Ipv6IspCityNode = v
	return s
}

type DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode struct {
	// The code of the city where the monitored node is deployed.
	CityCode *string `json:"CityCode,omitempty" xml:"CityCode,omitempty"`
	// The display name of the city where the monitored node is deployed.
	CityName *string `json:"CityName,omitempty" xml:"CityName,omitempty"`
	// Indicates whether the monitored node is selected for the health check by default.
	DefaultSelected *bool `json:"DefaultSelected,omitempty" xml:"DefaultSelected,omitempty"`
	// The name of the group to which the monitored node belongs.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The type of the group to which the monitored node belongs. Valid values:
	//
	// *   BGP: BGP nodes
	// *   OVERSEAS: nodes outside the Chinese mainland
	// *   ISP: ISP nodes
	GroupType *string                                                                             `json:"GroupType,omitempty" xml:"GroupType,omitempty"`
	Ips       *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps `json:"Ips,omitempty" xml:"Ips,omitempty" type:"Struct"`
	// The code of the ISP to which the monitored node belongs.
	IspCode *string `json:"IspCode,omitempty" xml:"IspCode,omitempty"`
	// The display name of the ISP to which the monitored node belongs.
	IspName *string `json:"IspName,omitempty" xml:"IspName,omitempty"`
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode) SetCityCode(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode {
	s.CityCode = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode) SetCityName(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode {
	s.CityName = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode) SetDefaultSelected(v bool) *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode {
	s.DefaultSelected = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode) SetGroupName(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode {
	s.GroupName = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode) SetGroupType(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode {
	s.GroupType = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode) SetIps(v *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps) *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode {
	s.Ips = v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode) SetIspCode(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode {
	s.IspCode = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode) SetIspName(v string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNode {
	s.IspName = &v
	return s
}

type DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps struct {
	Ip []*string `json:"Ip,omitempty" xml:"Ip,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps) SetIp(v []*string) *DescribeDnsGtmMonitorAvailableConfigResponseBodyIpv6IspCityNodesIpv6IspCityNodeIps {
	s.Ip = v
	return s
}

type DescribeDnsGtmMonitorAvailableConfigResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDnsGtmMonitorAvailableConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDnsGtmMonitorAvailableConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmMonitorAvailableConfigResponse) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponse) SetHeaders(v map[string]*string) *DescribeDnsGtmMonitorAvailableConfigResponse {
	s.Headers = v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponse) SetStatusCode(v int32) *DescribeDnsGtmMonitorAvailableConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDnsGtmMonitorAvailableConfigResponse) SetBody(v *DescribeDnsGtmMonitorAvailableConfigResponseBody) *DescribeDnsGtmMonitorAvailableConfigResponse {
	s.Body = v
	return s
}

type DescribeDnsGtmMonitorConfigRequest struct {
	// The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the health check task.
	MonitorConfigId *string `json:"MonitorConfigId,omitempty" xml:"MonitorConfigId,omitempty"`
}

func (s DescribeDnsGtmMonitorConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmMonitorConfigRequest) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmMonitorConfigRequest) SetLang(v string) *DescribeDnsGtmMonitorConfigRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDnsGtmMonitorConfigRequest) SetMonitorConfigId(v string) *DescribeDnsGtmMonitorConfigRequest {
	s.MonitorConfigId = &v
	return s
}

type DescribeDnsGtmMonitorConfigResponseBody struct {
	// The time when the health check task was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The timestamp that indicates when the health check task was created.
	CreateTimestamp *int64 `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The number of consecutive times of failed health check attempts.
	EvaluationCount *int32 `json:"EvaluationCount,omitempty" xml:"EvaluationCount,omitempty"`
	// The interval at which the health check task is executed. Unit: seconds.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The monitored node.
	IspCityNodes *DescribeDnsGtmMonitorConfigResponseBodyIspCityNodes `json:"IspCityNodes,omitempty" xml:"IspCityNodes,omitempty" type:"Struct"`
	// The ID of the health check task.
	MonitorConfigId *string `json:"MonitorConfigId,omitempty" xml:"MonitorConfigId,omitempty"`
	// The extended information. The following parameters are required for different health check protocols:
	//
	// *   HTTP or HTTPS:
	//
	//     *   port: the check port.
	//
	//     *   host: the host settings.
	//
	//     *   path: the URL path.
	//
	//     *   code: the return code greater than the specified value.
	//
	//     *   failureRate: the failure rate.
	//
	//     *   sni: specifies whether to enable server name indication (SNI). This parameter is used only for the HTTPS protocol. Valid values:
	//
	//         *   true: enable SNI.
	//         *   false: disable SNI.
	//
	//     *   nodeType: the type of the node to monitor when the address pool type is DOMAIN. Valid values:
	//
	//         *   IPV4
	//         *   IPV6
	//
	// *   PING:
	//
	//     *   failureRate: the failure rate.
	//
	//     *   packetNum: the number of ping packets.
	//
	//     *   packetLossRate: the loss rate of ping packets.
	//
	//     *   nodeType: the type of the node to monitor when the address pool type is DOMAIN. Valid values:
	//
	//         *   IPV4
	//         *   IPV6
	//
	// *   TCP:
	//
	//     *   port: the check port.
	//
	//     *   failureRate: the failure rate.
	//
	//     *   nodeType: the type of the node to monitor when the address pool type is DOMAIN. Valid values:
	//
	//         *   IPV4
	//         *   IPV6
	MonitorExtendInfo *string `json:"MonitorExtendInfo,omitempty" xml:"MonitorExtendInfo,omitempty"`
	// The health check protocol. Valid values:
	//
	// *   HTTP
	// *   HTTPS
	// *   PING
	// *   TCP
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The timeout period. Unit: milliseconds.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	// The time when the information about the health check task was updated.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The timestamp that indicates when the information about the health check task was updated.
	UpdateTimestamp *int64 `json:"UpdateTimestamp,omitempty" xml:"UpdateTimestamp,omitempty"`
}

func (s DescribeDnsGtmMonitorConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmMonitorConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmMonitorConfigResponseBody) SetCreateTime(v string) *DescribeDnsGtmMonitorConfigResponseBody {
	s.CreateTime = &v
	return s
}

func (s *DescribeDnsGtmMonitorConfigResponseBody) SetCreateTimestamp(v int64) *DescribeDnsGtmMonitorConfigResponseBody {
	s.CreateTimestamp = &v
	return s
}

func (s *DescribeDnsGtmMonitorConfigResponseBody) SetEvaluationCount(v int32) *DescribeDnsGtmMonitorConfigResponseBody {
	s.EvaluationCount = &v
	return s
}

func (s *DescribeDnsGtmMonitorConfigResponseBody) SetInterval(v int32) *DescribeDnsGtmMonitorConfigResponseBody {
	s.Interval = &v
	return s
}

func (s *DescribeDnsGtmMonitorConfigResponseBody) SetIspCityNodes(v *DescribeDnsGtmMonitorConfigResponseBodyIspCityNodes) *DescribeDnsGtmMonitorConfigResponseBody {
	s.IspCityNodes = v
	return s
}

func (s *DescribeDnsGtmMonitorConfigResponseBody) SetMonitorConfigId(v string) *DescribeDnsGtmMonitorConfigResponseBody {
	s.MonitorConfigId = &v
	return s
}

func (s *DescribeDnsGtmMonitorConfigResponseBody) SetMonitorExtendInfo(v string) *DescribeDnsGtmMonitorConfigResponseBody {
	s.MonitorExtendInfo = &v
	return s
}

func (s *DescribeDnsGtmMonitorConfigResponseBody) SetProtocolType(v string) *DescribeDnsGtmMonitorConfigResponseBody {
	s.ProtocolType = &v
	return s
}

func (s *DescribeDnsGtmMonitorConfigResponseBody) SetRequestId(v string) *DescribeDnsGtmMonitorConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDnsGtmMonitorConfigResponseBody) SetTimeout(v int32) *DescribeDnsGtmMonitorConfigResponseBody {
	s.Timeout = &v
	return s
}

func (s *DescribeDnsGtmMonitorConfigResponseBody) SetUpdateTime(v string) *DescribeDnsGtmMonitorConfigResponseBody {
	s.UpdateTime = &v
	return s
}

func (s *DescribeDnsGtmMonitorConfigResponseBody) SetUpdateTimestamp(v int64) *DescribeDnsGtmMonitorConfigResponseBody {
	s.UpdateTimestamp = &v
	return s
}

type DescribeDnsGtmMonitorConfigResponseBodyIspCityNodes struct {
	IspCityNode []*DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode `json:"IspCityNode,omitempty" xml:"IspCityNode,omitempty" type:"Repeated"`
}

func (s DescribeDnsGtmMonitorConfigResponseBodyIspCityNodes) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmMonitorConfigResponseBodyIspCityNodes) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmMonitorConfigResponseBodyIspCityNodes) SetIspCityNode(v []*DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode) *DescribeDnsGtmMonitorConfigResponseBodyIspCityNodes {
	s.IspCityNode = v
	return s
}

type DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode struct {
	// The code of the monitored city node.
	CityCode *string `json:"CityCode,omitempty" xml:"CityCode,omitempty"`
	// The display name of the monitored city node.
	CityName *string `json:"CityName,omitempty" xml:"CityName,omitempty"`
	// The code of the country or region.
	CountryCode *string `json:"CountryCode,omitempty" xml:"CountryCode,omitempty"`
	// The display name of the country or region.
	CountryName *string `json:"CountryName,omitempty" xml:"CountryName,omitempty"`
	// The code of the monitored Internet service provider (ISP) node.
	IspCode *string `json:"IspCode,omitempty" xml:"IspCode,omitempty"`
	// The name of the ISP.
	IspName *string `json:"IspName,omitempty" xml:"IspName,omitempty"`
}

func (s DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode) SetCityCode(v string) *DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode {
	s.CityCode = &v
	return s
}

func (s *DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode) SetCityName(v string) *DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode {
	s.CityName = &v
	return s
}

func (s *DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode) SetCountryCode(v string) *DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode {
	s.CountryCode = &v
	return s
}

func (s *DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode) SetCountryName(v string) *DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode {
	s.CountryName = &v
	return s
}

func (s *DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode) SetIspCode(v string) *DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode {
	s.IspCode = &v
	return s
}

func (s *DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode) SetIspName(v string) *DescribeDnsGtmMonitorConfigResponseBodyIspCityNodesIspCityNode {
	s.IspName = &v
	return s
}

type DescribeDnsGtmMonitorConfigResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDnsGtmMonitorConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDnsGtmMonitorConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsGtmMonitorConfigResponse) GoString() string {
	return s.String()
}

func (s *DescribeDnsGtmMonitorConfigResponse) SetHeaders(v map[string]*string) *DescribeDnsGtmMonitorConfigResponse {
	s.Headers = v
	return s
}

func (s *DescribeDnsGtmMonitorConfigResponse) SetStatusCode(v int32) *DescribeDnsGtmMonitorConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDnsGtmMonitorConfigResponse) SetBody(v *DescribeDnsGtmMonitorConfigResponseBody) *DescribeDnsGtmMonitorConfigResponse {
	s.Body = v
	return s
}

type DescribeDnsProductInstanceRequest struct {
	// The ID of the instance. You can call the **DescribeDomainInfo** operation to obtain the instance ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The IP address of the client.
	UserClientIp *string `json:"UserClientIp,omitempty" xml:"UserClientIp,omitempty"`
}

func (s DescribeDnsProductInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsProductInstanceRequest) GoString() string {
	return s.String()
}

func (s *DescribeDnsProductInstanceRequest) SetInstanceId(v string) *DescribeDnsProductInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeDnsProductInstanceRequest) SetLang(v string) *DescribeDnsProductInstanceRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDnsProductInstanceRequest) SetUserClientIp(v string) *DescribeDnsProductInstanceRequest {
	s.UserClientIp = &v
	return s
}

type DescribeDnsProductInstanceResponseBody struct {
	// The number of times you can change domain names that are bound to the DNS instance. It can be specified by the user who uses Alibaba Cloud DNS of the custom version.
	BindCount *int64 `json:"BindCount,omitempty" xml:"BindCount,omitempty"`
	// The number of domain names that you can bind to the DNS instance.
	BindDomainCount *int64 `json:"BindDomainCount,omitempty" xml:"BindDomainCount,omitempty"`
	// The number of domain names that have been bound to the DNS instance.
	BindDomainUsedCount *int64 `json:"BindDomainUsedCount,omitempty" xml:"BindDomainUsedCount,omitempty"`
	// The number of times you have changed domain names that are bound to the DNS instance. It can be specified by the user who uses Alibaba Cloud DNS of the custom version.
	BindUsedCount *int64 `json:"BindUsedCount,omitempty" xml:"BindUsedCount,omitempty"`
	// The DDoS protection traffic. Unit: GB.
	DDosDefendFlow *int64 `json:"DDosDefendFlow,omitempty" xml:"DDosDefendFlow,omitempty"`
	// The DDoS protection frequency. Unit: 10,000 QPS.
	DDosDefendQuery *int64 `json:"DDosDefendQuery,omitempty" xml:"DDosDefendQuery,omitempty"`
	// The number of IP addresses supported by a domain name or line.
	DnsSLBCount *int64 `json:"DnsSLBCount,omitempty" xml:"DnsSLBCount,omitempty"`
	// The DNS security policy. Valid values:
	//
	// *   **no**: not required.
	// *   **basic**: anti-DDoS basic.
	// *   **advanced**: anti-DDoS advanced.
	DnsSecurity *string `json:"DnsSecurity,omitempty" xml:"DnsSecurity,omitempty"`
	// The list of DNS servers.
	DnsServers *DescribeDnsProductInstanceResponseBodyDnsServers `json:"DnsServers,omitempty" xml:"DnsServers,omitempty" type:"Struct"`
	// The bound domain name.
	//
	// If this parameter is not specified, no domain name is bound.
	Domain     *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	DomainType *string `json:"DomainType,omitempty" xml:"DomainType,omitempty"`
	// The time at which the instance expired.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The UNIX timestamp representing the expiration time of the instance.
	EndTimestamp *int64 `json:"EndTimestamp,omitempty" xml:"EndTimestamp,omitempty"`
	// Indicates whether GSLB was allowed.
	Gslb *bool `json:"Gslb,omitempty" xml:"Gslb,omitempty"`
	// The list of ISP lines.
	ISPLines *string `json:"ISPLines,omitempty" xml:"ISPLines,omitempty"`
	// The list of ISP line subdivisions.
	ISPRegionLines *string `json:"ISPRegionLines,omitempty" xml:"ISPRegionLines,omitempty"`
	// Indicates whether the request for domain name resolution was in the black hole.
	InBlackHole *bool `json:"InBlackHole,omitempty" xml:"InBlackHole,omitempty"`
	// Indicates whether the request for domain name resolution was being cleared.
	InClean *bool `json:"InClean,omitempty" xml:"InClean,omitempty"`
	// The ID of the Alibaba Cloud DNS instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The monitoring frequency. Unit: minutes.
	MonitorFrequency *int64 `json:"MonitorFrequency,omitempty" xml:"MonitorFrequency,omitempty"`
	// The number of monitored nodes.
	MonitorNodeCount *int64 `json:"MonitorNodeCount,omitempty" xml:"MonitorNodeCount,omitempty"`
	// The number of monitoring tasks.
	MonitorTaskCount *int64 `json:"MonitorTaskCount,omitempty" xml:"MonitorTaskCount,omitempty"`
	// DDoS protection traffic outside China. Unit: GB.
	OverseaDDosDefendFlow *int64 `json:"OverseaDDosDefendFlow,omitempty" xml:"OverseaDDosDefendFlow,omitempty"`
	// The type of the overseas line.
	OverseaLine *string `json:"OverseaLine,omitempty" xml:"OverseaLine,omitempty"`
	PaymentType *string `json:"PaymentType,omitempty" xml:"PaymentType,omitempty"`
	// Indicates whether regional lines were allowed.
	RegionLines *bool `json:"RegionLines,omitempty" xml:"RegionLines,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of search engine lines.
	SearchEngineLines *string `json:"SearchEngineLines,omitempty" xml:"SearchEngineLines,omitempty"`
	// The time when the DNS instance was purchased.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The UNIX timestamp representing when the DNS instance was purchased.
	StartTimestamp *int64 `json:"StartTimestamp,omitempty" xml:"StartTimestamp,omitempty"`
	// The number of subdomain name levels.
	SubDomainLevel *int64 `json:"SubDomainLevel,omitempty" xml:"SubDomainLevel,omitempty"`
	// The minimum TTL. Unit: seconds.
	TTLMinValue *int64 `json:"TTLMinValue,omitempty" xml:"TTLMinValue,omitempty"`
	// The URL forwarding quantity.
	URLForwardCount *int64 `json:"URLForwardCount,omitempty" xml:"URLForwardCount,omitempty"`
	// The version code of the Alibaba Cloud DNS instance.
	VersionCode *string `json:"VersionCode,omitempty" xml:"VersionCode,omitempty"`
	// The version name of the Alibaba Cloud DNS instance.
	VersionName *string `json:"VersionName,omitempty" xml:"VersionName,omitempty"`
}

func (s DescribeDnsProductInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsProductInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDnsProductInstanceResponseBody) SetBindCount(v int64) *DescribeDnsProductInstanceResponseBody {
	s.BindCount = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetBindDomainCount(v int64) *DescribeDnsProductInstanceResponseBody {
	s.BindDomainCount = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetBindDomainUsedCount(v int64) *DescribeDnsProductInstanceResponseBody {
	s.BindDomainUsedCount = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetBindUsedCount(v int64) *DescribeDnsProductInstanceResponseBody {
	s.BindUsedCount = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetDDosDefendFlow(v int64) *DescribeDnsProductInstanceResponseBody {
	s.DDosDefendFlow = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetDDosDefendQuery(v int64) *DescribeDnsProductInstanceResponseBody {
	s.DDosDefendQuery = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetDnsSLBCount(v int64) *DescribeDnsProductInstanceResponseBody {
	s.DnsSLBCount = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetDnsSecurity(v string) *DescribeDnsProductInstanceResponseBody {
	s.DnsSecurity = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetDnsServers(v *DescribeDnsProductInstanceResponseBodyDnsServers) *DescribeDnsProductInstanceResponseBody {
	s.DnsServers = v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetDomain(v string) *DescribeDnsProductInstanceResponseBody {
	s.Domain = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetDomainType(v string) *DescribeDnsProductInstanceResponseBody {
	s.DomainType = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetEndTime(v string) *DescribeDnsProductInstanceResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetEndTimestamp(v int64) *DescribeDnsProductInstanceResponseBody {
	s.EndTimestamp = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetGslb(v bool) *DescribeDnsProductInstanceResponseBody {
	s.Gslb = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetISPLines(v string) *DescribeDnsProductInstanceResponseBody {
	s.ISPLines = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetISPRegionLines(v string) *DescribeDnsProductInstanceResponseBody {
	s.ISPRegionLines = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetInBlackHole(v bool) *DescribeDnsProductInstanceResponseBody {
	s.InBlackHole = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetInClean(v bool) *DescribeDnsProductInstanceResponseBody {
	s.InClean = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetInstanceId(v string) *DescribeDnsProductInstanceResponseBody {
	s.InstanceId = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetMonitorFrequency(v int64) *DescribeDnsProductInstanceResponseBody {
	s.MonitorFrequency = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetMonitorNodeCount(v int64) *DescribeDnsProductInstanceResponseBody {
	s.MonitorNodeCount = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetMonitorTaskCount(v int64) *DescribeDnsProductInstanceResponseBody {
	s.MonitorTaskCount = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetOverseaDDosDefendFlow(v int64) *DescribeDnsProductInstanceResponseBody {
	s.OverseaDDosDefendFlow = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetOverseaLine(v string) *DescribeDnsProductInstanceResponseBody {
	s.OverseaLine = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetPaymentType(v string) *DescribeDnsProductInstanceResponseBody {
	s.PaymentType = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetRegionLines(v bool) *DescribeDnsProductInstanceResponseBody {
	s.RegionLines = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetRequestId(v string) *DescribeDnsProductInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetSearchEngineLines(v string) *DescribeDnsProductInstanceResponseBody {
	s.SearchEngineLines = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetStartTime(v string) *DescribeDnsProductInstanceResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetStartTimestamp(v int64) *DescribeDnsProductInstanceResponseBody {
	s.StartTimestamp = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetSubDomainLevel(v int64) *DescribeDnsProductInstanceResponseBody {
	s.SubDomainLevel = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetTTLMinValue(v int64) *DescribeDnsProductInstanceResponseBody {
	s.TTLMinValue = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetURLForwardCount(v int64) *DescribeDnsProductInstanceResponseBody {
	s.URLForwardCount = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetVersionCode(v string) *DescribeDnsProductInstanceResponseBody {
	s.VersionCode = &v
	return s
}

func (s *DescribeDnsProductInstanceResponseBody) SetVersionName(v string) *DescribeDnsProductInstanceResponseBody {
	s.VersionName = &v
	return s
}

type DescribeDnsProductInstanceResponseBodyDnsServers struct {
	DnsServer []*string `json:"DnsServer,omitempty" xml:"DnsServer,omitempty" type:"Repeated"`
}

func (s DescribeDnsProductInstanceResponseBodyDnsServers) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsProductInstanceResponseBodyDnsServers) GoString() string {
	return s.String()
}

func (s *DescribeDnsProductInstanceResponseBodyDnsServers) SetDnsServer(v []*string) *DescribeDnsProductInstanceResponseBodyDnsServers {
	s.DnsServer = v
	return s
}

type DescribeDnsProductInstanceResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDnsProductInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDnsProductInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsProductInstanceResponse) GoString() string {
	return s.String()
}

func (s *DescribeDnsProductInstanceResponse) SetHeaders(v map[string]*string) *DescribeDnsProductInstanceResponse {
	s.Headers = v
	return s
}

func (s *DescribeDnsProductInstanceResponse) SetStatusCode(v int32) *DescribeDnsProductInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDnsProductInstanceResponse) SetBody(v *DescribeDnsProductInstanceResponseBody) *DescribeDnsProductInstanceResponse {
	s.Body = v
	return s
}

type DescribeDnsProductInstancesRequest struct {
	DomainType *string `json:"DomainType,omitempty" xml:"DomainType,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The number of the page to return. Pages start from page **1**. Default value: **1**.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **100**. Default value: **20**.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The IP address of the client.
	UserClientIp *string `json:"UserClientIp,omitempty" xml:"UserClientIp,omitempty"`
	// The version code of the Alibaba Cloud DNS instance.
	VersionCode *string `json:"VersionCode,omitempty" xml:"VersionCode,omitempty"`
}

func (s DescribeDnsProductInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsProductInstancesRequest) GoString() string {
	return s.String()
}

func (s *DescribeDnsProductInstancesRequest) SetDomainType(v string) *DescribeDnsProductInstancesRequest {
	s.DomainType = &v
	return s
}

func (s *DescribeDnsProductInstancesRequest) SetLang(v string) *DescribeDnsProductInstancesRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDnsProductInstancesRequest) SetPageNumber(v int64) *DescribeDnsProductInstancesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDnsProductInstancesRequest) SetPageSize(v int64) *DescribeDnsProductInstancesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDnsProductInstancesRequest) SetUserClientIp(v string) *DescribeDnsProductInstancesRequest {
	s.UserClientIp = &v
	return s
}

func (s *DescribeDnsProductInstancesRequest) SetVersionCode(v string) *DescribeDnsProductInstancesRequest {
	s.VersionCode = &v
	return s
}

type DescribeDnsProductInstancesResponseBody struct {
	// The list of Alibaba Cloud DNS instances obtained by this operation.
	DnsProducts *DescribeDnsProductInstancesResponseBodyDnsProducts `json:"DnsProducts,omitempty" xml:"DnsProducts,omitempty" type:"Struct"`
	DomainType  *string                                             `json:"DomainType,omitempty" xml:"DomainType,omitempty"`
	// The page number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of domain names.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDnsProductInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsProductInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDnsProductInstancesResponseBody) SetDnsProducts(v *DescribeDnsProductInstancesResponseBodyDnsProducts) *DescribeDnsProductInstancesResponseBody {
	s.DnsProducts = v
	return s
}

func (s *DescribeDnsProductInstancesResponseBody) SetDomainType(v string) *DescribeDnsProductInstancesResponseBody {
	s.DomainType = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBody) SetPageNumber(v int64) *DescribeDnsProductInstancesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBody) SetPageSize(v int64) *DescribeDnsProductInstancesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBody) SetRequestId(v string) *DescribeDnsProductInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBody) SetTotalCount(v int64) *DescribeDnsProductInstancesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDnsProductInstancesResponseBodyDnsProducts struct {
	DnsProduct []*DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct `json:"DnsProduct,omitempty" xml:"DnsProduct,omitempty" type:"Repeated"`
}

func (s DescribeDnsProductInstancesResponseBodyDnsProducts) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsProductInstancesResponseBodyDnsProducts) GoString() string {
	return s.String()
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProducts) SetDnsProduct(v []*DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) *DescribeDnsProductInstancesResponseBodyDnsProducts {
	s.DnsProduct = v
	return s
}

type DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct struct {
	// The number of times you can change domain names that are bound to the DNS instance. It can be specified by the user who uses Alibaba Cloud DNS of the custom version.
	BindCount *int64 `json:"BindCount,omitempty" xml:"BindCount,omitempty"`
	// The number of domain names that can be bound to the DNS instance.
	BindDomainCount *int64 `json:"BindDomainCount,omitempty" xml:"BindDomainCount,omitempty"`
	// The number of domain names that have been bound to the DNS instance.
	BindDomainUsedCount *int64 `json:"BindDomainUsedCount,omitempty" xml:"BindDomainUsedCount,omitempty"`
	// The number of times you have changed domain names that are bound to the DNS instance. It can be specified by the user who uses Alibaba Cloud DNS of the custom version.
	BindUsedCount *int64 `json:"BindUsedCount,omitempty" xml:"BindUsedCount,omitempty"`
	// The DDoS protection traffic. Unit: GB.
	DDosDefendFlow *int64 `json:"DDosDefendFlow,omitempty" xml:"DDosDefendFlow,omitempty"`
	// The DDoS protection frequency. Unit: 10,000 QPS.
	DDosDefendQuery *int64 `json:"DDosDefendQuery,omitempty" xml:"DDosDefendQuery,omitempty"`
	// The number of IP addresses supported by a domain name or line.
	DnsSLBCount *int64 `json:"DnsSLBCount,omitempty" xml:"DnsSLBCount,omitempty"`
	// The DNS security policy. Valid values:
	//
	// *   **no**: not required.
	// *   **basic**: anti-DDoS basic.
	// *   **advanced**: anti-DDoS advanced.
	DnsSecurity *string `json:"DnsSecurity,omitempty" xml:"DnsSecurity,omitempty"`
	// The bound domain name.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The time at which the instance expired.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The UNIX timestamp representing the expiration time of the instance.
	EndTimestamp *int64 `json:"EndTimestamp,omitempty" xml:"EndTimestamp,omitempty"`
	// Indicates whether global server load balancing (GSLB) was allowed.
	Gslb *bool `json:"Gslb,omitempty" xml:"Gslb,omitempty"`
	// The list of ISP lines.
	ISPLines *string `json:"ISPLines,omitempty" xml:"ISPLines,omitempty"`
	// The list of ISP line subdivisions.
	ISPRegionLines *string `json:"ISPRegionLines,omitempty" xml:"ISPRegionLines,omitempty"`
	// Indicates whether the request for domain name resolution was in the black hole.
	InBlackHole *bool `json:"InBlackHole,omitempty" xml:"InBlackHole,omitempty"`
	// Indicates whether the request for domain name resolution was being cleared.
	InClean *bool `json:"InClean,omitempty" xml:"InClean,omitempty"`
	// The ID of the Alibaba Cloud DNS instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The monitoring frequency. Unit: minutes.
	MonitorFrequency *int64 `json:"MonitorFrequency,omitempty" xml:"MonitorFrequency,omitempty"`
	// The number of monitored nodes.
	MonitorNodeCount *int64 `json:"MonitorNodeCount,omitempty" xml:"MonitorNodeCount,omitempty"`
	// The number of monitoring tasks.
	MonitorTaskCount *int64 `json:"MonitorTaskCount,omitempty" xml:"MonitorTaskCount,omitempty"`
	// DDoS protection traffic outside China. Unit: GB.
	OverseaDDosDefendFlow *int64 `json:"OverseaDDosDefendFlow,omitempty" xml:"OverseaDDosDefendFlow,omitempty"`
	// The type of the overseas line.
	OverseaLine *string `json:"OverseaLine,omitempty" xml:"OverseaLine,omitempty"`
	PaymentType *string `json:"PaymentType,omitempty" xml:"PaymentType,omitempty"`
	// Indicates whether regional lines were allowed.
	RegionLines *bool `json:"RegionLines,omitempty" xml:"RegionLines,omitempty"`
	// The list of search engine lines.
	SearchEngineLines *string `json:"SearchEngineLines,omitempty" xml:"SearchEngineLines,omitempty"`
	// The time when the DNS instance was purchased.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The UNIX timestamp representing when the DNS instance was purchased.
	StartTimestamp *int64 `json:"StartTimestamp,omitempty" xml:"StartTimestamp,omitempty"`
	// The number of subdomain name levels.
	SubDomainLevel *int64 `json:"SubDomainLevel,omitempty" xml:"SubDomainLevel,omitempty"`
	// The minimum TTL. Unit: seconds.
	TTLMinValue *int64 `json:"TTLMinValue,omitempty" xml:"TTLMinValue,omitempty"`
	// The URL forwarding quantity.
	URLForwardCount *int64 `json:"URLForwardCount,omitempty" xml:"URLForwardCount,omitempty"`
	// The version code of the Alibaba Cloud DNS instance.
	VersionCode *string `json:"VersionCode,omitempty" xml:"VersionCode,omitempty"`
	// The version name of the Alibaba Cloud DNS instance.
	VersionName *string `json:"VersionName,omitempty" xml:"VersionName,omitempty"`
}

func (s DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) GoString() string {
	return s.String()
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetBindCount(v int64) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.BindCount = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetBindDomainCount(v int64) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.BindDomainCount = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetBindDomainUsedCount(v int64) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.BindDomainUsedCount = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetBindUsedCount(v int64) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.BindUsedCount = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetDDosDefendFlow(v int64) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.DDosDefendFlow = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetDDosDefendQuery(v int64) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.DDosDefendQuery = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetDnsSLBCount(v int64) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.DnsSLBCount = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetDnsSecurity(v string) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.DnsSecurity = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetDomain(v string) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.Domain = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetEndTime(v string) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.EndTime = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetEndTimestamp(v int64) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.EndTimestamp = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetGslb(v bool) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.Gslb = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetISPLines(v string) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.ISPLines = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetISPRegionLines(v string) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.ISPRegionLines = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetInBlackHole(v bool) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.InBlackHole = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetInClean(v bool) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.InClean = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetInstanceId(v string) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.InstanceId = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetMonitorFrequency(v int64) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.MonitorFrequency = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetMonitorNodeCount(v int64) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.MonitorNodeCount = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetMonitorTaskCount(v int64) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.MonitorTaskCount = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetOverseaDDosDefendFlow(v int64) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.OverseaDDosDefendFlow = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetOverseaLine(v string) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.OverseaLine = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetPaymentType(v string) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.PaymentType = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetRegionLines(v bool) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.RegionLines = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetSearchEngineLines(v string) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.SearchEngineLines = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetStartTime(v string) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.StartTime = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetStartTimestamp(v int64) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.StartTimestamp = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetSubDomainLevel(v int64) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.SubDomainLevel = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetTTLMinValue(v int64) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.TTLMinValue = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetURLForwardCount(v int64) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.URLForwardCount = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetVersionCode(v string) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.VersionCode = &v
	return s
}

func (s *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct) SetVersionName(v string) *DescribeDnsProductInstancesResponseBodyDnsProductsDnsProduct {
	s.VersionName = &v
	return s
}

type DescribeDnsProductInstancesResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDnsProductInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDnsProductInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDnsProductInstancesResponse) GoString() string {
	return s.String()
}

func (s *DescribeDnsProductInstancesResponse) SetHeaders(v map[string]*string) *DescribeDnsProductInstancesResponse {
	s.Headers = v
	return s
}

func (s *DescribeDnsProductInstancesResponse) SetStatusCode(v int32) *DescribeDnsProductInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDnsProductInstancesResponse) SetBody(v *DescribeDnsProductInstancesResponseBody) *DescribeDnsProductInstancesResponse {
	s.Body = v
	return s
}

type DescribeDohAccountStatisticsRequest struct {
	// The end of the time range to query. Specify the time in the YYYY-MM-DD format.
	//
	// The default value is the day when you perform the operation.
	EndDate *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.
	//
	// You can query only the DNS records of the latest 90 days.`The value of StartDate must be greater than or equal to the difference between the current date and 90`.
	StartDate *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
}

func (s DescribeDohAccountStatisticsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDohAccountStatisticsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDohAccountStatisticsRequest) SetEndDate(v string) *DescribeDohAccountStatisticsRequest {
	s.EndDate = &v
	return s
}

func (s *DescribeDohAccountStatisticsRequest) SetLang(v string) *DescribeDohAccountStatisticsRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDohAccountStatisticsRequest) SetStartDate(v string) *DescribeDohAccountStatisticsRequest {
	s.StartDate = &v
	return s
}

type DescribeDohAccountStatisticsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The statistics list.
	Statistics []*DescribeDohAccountStatisticsResponseBodyStatistics `json:"Statistics,omitempty" xml:"Statistics,omitempty" type:"Repeated"`
}

func (s DescribeDohAccountStatisticsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDohAccountStatisticsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDohAccountStatisticsResponseBody) SetRequestId(v string) *DescribeDohAccountStatisticsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDohAccountStatisticsResponseBody) SetStatistics(v []*DescribeDohAccountStatisticsResponseBodyStatistics) *DescribeDohAccountStatisticsResponseBody {
	s.Statistics = v
	return s
}

type DescribeDohAccountStatisticsResponseBodyStatistics struct {
	// The timestamp.
	Timestamp *int64 `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The total number of requests.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The number of IPv4-based HTTP requests.
	V4HttpCount *int64 `json:"V4HttpCount,omitempty" xml:"V4HttpCount,omitempty"`
	// The number of IPv4-based HTTPS requests.
	V4HttpsCount *int64 `json:"V4HttpsCount,omitempty" xml:"V4HttpsCount,omitempty"`
	// The number of IPv6-based HTTP requests.
	V6HttpCount *int64 `json:"V6HttpCount,omitempty" xml:"V6HttpCount,omitempty"`
	// The number of IPv6-based HTTPS requests.
	V6HttpsCount *int64 `json:"V6HttpsCount,omitempty" xml:"V6HttpsCount,omitempty"`
}

func (s DescribeDohAccountStatisticsResponseBodyStatistics) String() string {
	return tea.Prettify(s)
}

func (s DescribeDohAccountStatisticsResponseBodyStatistics) GoString() string {
	return s.String()
}

func (s *DescribeDohAccountStatisticsResponseBodyStatistics) SetTimestamp(v int64) *DescribeDohAccountStatisticsResponseBodyStatistics {
	s.Timestamp = &v
	return s
}

func (s *DescribeDohAccountStatisticsResponseBodyStatistics) SetTotalCount(v int64) *DescribeDohAccountStatisticsResponseBodyStatistics {
	s.TotalCount = &v
	return s
}

func (s *DescribeDohAccountStatisticsResponseBodyStatistics) SetV4HttpCount(v int64) *DescribeDohAccountStatisticsResponseBodyStatistics {
	s.V4HttpCount = &v
	return s
}

func (s *DescribeDohAccountStatisticsResponseBodyStatistics) SetV4HttpsCount(v int64) *DescribeDohAccountStatisticsResponseBodyStatistics {
	s.V4HttpsCount = &v
	return s
}

func (s *DescribeDohAccountStatisticsResponseBodyStatistics) SetV6HttpCount(v int64) *DescribeDohAccountStatisticsResponseBodyStatistics {
	s.V6HttpCount = &v
	return s
}

func (s *DescribeDohAccountStatisticsResponseBodyStatistics) SetV6HttpsCount(v int64) *DescribeDohAccountStatisticsResponseBodyStatistics {
	s.V6HttpsCount = &v
	return s
}

type DescribeDohAccountStatisticsResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDohAccountStatisticsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDohAccountStatisticsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDohAccountStatisticsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDohAccountStatisticsResponse) SetHeaders(v map[string]*string) *DescribeDohAccountStatisticsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDohAccountStatisticsResponse) SetStatusCode(v int32) *DescribeDohAccountStatisticsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDohAccountStatisticsResponse) SetBody(v *DescribeDohAccountStatisticsResponseBody) *DescribeDohAccountStatisticsResponse {
	s.Body = v
	return s
}

type DescribeDohDomainStatisticsRequest struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the YYYY-MM-DD format.
	//
	// The default value is the day when you perform the operation.
	EndDate *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.
	//
	// You can query only the DNS records of the latest 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.
	StartDate *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
}

func (s DescribeDohDomainStatisticsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDohDomainStatisticsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDohDomainStatisticsRequest) SetDomainName(v string) *DescribeDohDomainStatisticsRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDohDomainStatisticsRequest) SetEndDate(v string) *DescribeDohDomainStatisticsRequest {
	s.EndDate = &v
	return s
}

func (s *DescribeDohDomainStatisticsRequest) SetLang(v string) *DescribeDohDomainStatisticsRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDohDomainStatisticsRequest) SetStartDate(v string) *DescribeDohDomainStatisticsRequest {
	s.StartDate = &v
	return s
}

type DescribeDohDomainStatisticsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The statistics list.
	Statistics []*DescribeDohDomainStatisticsResponseBodyStatistics `json:"Statistics,omitempty" xml:"Statistics,omitempty" type:"Repeated"`
}

func (s DescribeDohDomainStatisticsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDohDomainStatisticsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDohDomainStatisticsResponseBody) SetRequestId(v string) *DescribeDohDomainStatisticsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDohDomainStatisticsResponseBody) SetStatistics(v []*DescribeDohDomainStatisticsResponseBodyStatistics) *DescribeDohDomainStatisticsResponseBody {
	s.Statistics = v
	return s
}

type DescribeDohDomainStatisticsResponseBodyStatistics struct {
	// The timestamp.
	Timestamp *int64 `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The total number of requests.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The number of IPv4-based HTTP requests.
	V4HttpCount *int64 `json:"V4HttpCount,omitempty" xml:"V4HttpCount,omitempty"`
	// The number of IPv4-based HTTPS requests.
	V4HttpsCount *int64 `json:"V4HttpsCount,omitempty" xml:"V4HttpsCount,omitempty"`
	// The number of IPv6-based HTTP requests.
	V6HttpCount *int64 `json:"V6HttpCount,omitempty" xml:"V6HttpCount,omitempty"`
	// The number of IPv6-based HTTPS requests.
	V6HttpsCount *int64 `json:"V6HttpsCount,omitempty" xml:"V6HttpsCount,omitempty"`
}

func (s DescribeDohDomainStatisticsResponseBodyStatistics) String() string {
	return tea.Prettify(s)
}

func (s DescribeDohDomainStatisticsResponseBodyStatistics) GoString() string {
	return s.String()
}

func (s *DescribeDohDomainStatisticsResponseBodyStatistics) SetTimestamp(v int64) *DescribeDohDomainStatisticsResponseBodyStatistics {
	s.Timestamp = &v
	return s
}

func (s *DescribeDohDomainStatisticsResponseBodyStatistics) SetTotalCount(v int64) *DescribeDohDomainStatisticsResponseBodyStatistics {
	s.TotalCount = &v
	return s
}

func (s *DescribeDohDomainStatisticsResponseBodyStatistics) SetV4HttpCount(v int64) *DescribeDohDomainStatisticsResponseBodyStatistics {
	s.V4HttpCount = &v
	return s
}

func (s *DescribeDohDomainStatisticsResponseBodyStatistics) SetV4HttpsCount(v int64) *DescribeDohDomainStatisticsResponseBodyStatistics {
	s.V4HttpsCount = &v
	return s
}

func (s *DescribeDohDomainStatisticsResponseBodyStatistics) SetV6HttpCount(v int64) *DescribeDohDomainStatisticsResponseBodyStatistics {
	s.V6HttpCount = &v
	return s
}

func (s *DescribeDohDomainStatisticsResponseBodyStatistics) SetV6HttpsCount(v int64) *DescribeDohDomainStatisticsResponseBodyStatistics {
	s.V6HttpsCount = &v
	return s
}

type DescribeDohDomainStatisticsResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDohDomainStatisticsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDohDomainStatisticsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDohDomainStatisticsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDohDomainStatisticsResponse) SetHeaders(v map[string]*string) *DescribeDohDomainStatisticsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDohDomainStatisticsResponse) SetStatusCode(v int32) *DescribeDohDomainStatisticsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDohDomainStatisticsResponse) SetBody(v *DescribeDohDomainStatisticsResponseBody) *DescribeDohDomainStatisticsResponse {
	s.Body = v
	return s
}

type DescribeDohDomainStatisticsSummaryRequest struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the YYYY-MM-DD format.
	//
	// The default value is the day when you perform the operation.
	EndDate *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The number of the page to return. Pages start from page 1. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: 100. Default value: 20.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.
	//
	// You can query only the DNS records of the last 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.
	StartDate *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
}

func (s DescribeDohDomainStatisticsSummaryRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDohDomainStatisticsSummaryRequest) GoString() string {
	return s.String()
}

func (s *DescribeDohDomainStatisticsSummaryRequest) SetDomainName(v string) *DescribeDohDomainStatisticsSummaryRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDohDomainStatisticsSummaryRequest) SetEndDate(v string) *DescribeDohDomainStatisticsSummaryRequest {
	s.EndDate = &v
	return s
}

func (s *DescribeDohDomainStatisticsSummaryRequest) SetLang(v string) *DescribeDohDomainStatisticsSummaryRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDohDomainStatisticsSummaryRequest) SetPageNumber(v int32) *DescribeDohDomainStatisticsSummaryRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDohDomainStatisticsSummaryRequest) SetPageSize(v int32) *DescribeDohDomainStatisticsSummaryRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDohDomainStatisticsSummaryRequest) SetStartDate(v string) *DescribeDohDomainStatisticsSummaryRequest {
	s.StartDate = &v
	return s
}

type DescribeDohDomainStatisticsSummaryResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The statistics list.
	Statistics []*DescribeDohDomainStatisticsSummaryResponseBodyStatistics `json:"Statistics,omitempty" xml:"Statistics,omitempty" type:"Repeated"`
	// The total number of entries returned.
	TotalItems *int32 `json:"TotalItems,omitempty" xml:"TotalItems,omitempty"`
	// The total number of pages returned.
	TotalPages *int32 `json:"TotalPages,omitempty" xml:"TotalPages,omitempty"`
}

func (s DescribeDohDomainStatisticsSummaryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDohDomainStatisticsSummaryResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDohDomainStatisticsSummaryResponseBody) SetPageNumber(v int32) *DescribeDohDomainStatisticsSummaryResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDohDomainStatisticsSummaryResponseBody) SetPageSize(v int32) *DescribeDohDomainStatisticsSummaryResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDohDomainStatisticsSummaryResponseBody) SetRequestId(v string) *DescribeDohDomainStatisticsSummaryResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDohDomainStatisticsSummaryResponseBody) SetStatistics(v []*DescribeDohDomainStatisticsSummaryResponseBodyStatistics) *DescribeDohDomainStatisticsSummaryResponseBody {
	s.Statistics = v
	return s
}

func (s *DescribeDohDomainStatisticsSummaryResponseBody) SetTotalItems(v int32) *DescribeDohDomainStatisticsSummaryResponseBody {
	s.TotalItems = &v
	return s
}

func (s *DescribeDohDomainStatisticsSummaryResponseBody) SetTotalPages(v int32) *DescribeDohDomainStatisticsSummaryResponseBody {
	s.TotalPages = &v
	return s
}

type DescribeDohDomainStatisticsSummaryResponseBodyStatistics struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The number of HTTP requests.
	HttpCount *int64 `json:"HttpCount,omitempty" xml:"HttpCount,omitempty"`
	// The number of HTTPS requests.
	HttpsCount *int64 `json:"HttpsCount,omitempty" xml:"HttpsCount,omitempty"`
	// The number of IP addresses.
	IpCount *int64 `json:"IpCount,omitempty" xml:"IpCount,omitempty"`
	// The total number of requests.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The number of IPv4-based HTTP requests.
	V4HttpCount *int64 `json:"V4HttpCount,omitempty" xml:"V4HttpCount,omitempty"`
	// The number of IPv4-based HTTPS requests.
	V4HttpsCount *int64 `json:"V4HttpsCount,omitempty" xml:"V4HttpsCount,omitempty"`
	// The number of IPv6-based HTTP requests.
	V6HttpCount *int64 `json:"V6HttpCount,omitempty" xml:"V6HttpCount,omitempty"`
	// The number of IPv6-based HTTPS requests.
	V6HttpsCount *int64 `json:"V6HttpsCount,omitempty" xml:"V6HttpsCount,omitempty"`
}

func (s DescribeDohDomainStatisticsSummaryResponseBodyStatistics) String() string {
	return tea.Prettify(s)
}

func (s DescribeDohDomainStatisticsSummaryResponseBodyStatistics) GoString() string {
	return s.String()
}

func (s *DescribeDohDomainStatisticsSummaryResponseBodyStatistics) SetDomainName(v string) *DescribeDohDomainStatisticsSummaryResponseBodyStatistics {
	s.DomainName = &v
	return s
}

func (s *DescribeDohDomainStatisticsSummaryResponseBodyStatistics) SetHttpCount(v int64) *DescribeDohDomainStatisticsSummaryResponseBodyStatistics {
	s.HttpCount = &v
	return s
}

func (s *DescribeDohDomainStatisticsSummaryResponseBodyStatistics) SetHttpsCount(v int64) *DescribeDohDomainStatisticsSummaryResponseBodyStatistics {
	s.HttpsCount = &v
	return s
}

func (s *DescribeDohDomainStatisticsSummaryResponseBodyStatistics) SetIpCount(v int64) *DescribeDohDomainStatisticsSummaryResponseBodyStatistics {
	s.IpCount = &v
	return s
}

func (s *DescribeDohDomainStatisticsSummaryResponseBodyStatistics) SetTotalCount(v int64) *DescribeDohDomainStatisticsSummaryResponseBodyStatistics {
	s.TotalCount = &v
	return s
}

func (s *DescribeDohDomainStatisticsSummaryResponseBodyStatistics) SetV4HttpCount(v int64) *DescribeDohDomainStatisticsSummaryResponseBodyStatistics {
	s.V4HttpCount = &v
	return s
}

func (s *DescribeDohDomainStatisticsSummaryResponseBodyStatistics) SetV4HttpsCount(v int64) *DescribeDohDomainStatisticsSummaryResponseBodyStatistics {
	s.V4HttpsCount = &v
	return s
}

func (s *DescribeDohDomainStatisticsSummaryResponseBodyStatistics) SetV6HttpCount(v int64) *DescribeDohDomainStatisticsSummaryResponseBodyStatistics {
	s.V6HttpCount = &v
	return s
}

func (s *DescribeDohDomainStatisticsSummaryResponseBodyStatistics) SetV6HttpsCount(v int64) *DescribeDohDomainStatisticsSummaryResponseBodyStatistics {
	s.V6HttpsCount = &v
	return s
}

type DescribeDohDomainStatisticsSummaryResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDohDomainStatisticsSummaryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDohDomainStatisticsSummaryResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDohDomainStatisticsSummaryResponse) GoString() string {
	return s.String()
}

func (s *DescribeDohDomainStatisticsSummaryResponse) SetHeaders(v map[string]*string) *DescribeDohDomainStatisticsSummaryResponse {
	s.Headers = v
	return s
}

func (s *DescribeDohDomainStatisticsSummaryResponse) SetStatusCode(v int32) *DescribeDohDomainStatisticsSummaryResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDohDomainStatisticsSummaryResponse) SetBody(v *DescribeDohDomainStatisticsSummaryResponseBody) *DescribeDohDomainStatisticsSummaryResponse {
	s.Body = v
	return s
}

type DescribeDohSubDomainStatisticsRequest struct {
	// The end of the time range to query. Specify the time in the YYYY-MM-DD format.
	//
	// The default value is the day when you perform the operation.
	EndDate *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.
	//
	// You can query only the DNS records of the latest 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.
	StartDate *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
	// The subdomain whose statistics you want to query.
	SubDomain *string `json:"SubDomain,omitempty" xml:"SubDomain,omitempty"`
}

func (s DescribeDohSubDomainStatisticsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDohSubDomainStatisticsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDohSubDomainStatisticsRequest) SetEndDate(v string) *DescribeDohSubDomainStatisticsRequest {
	s.EndDate = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsRequest) SetLang(v string) *DescribeDohSubDomainStatisticsRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsRequest) SetStartDate(v string) *DescribeDohSubDomainStatisticsRequest {
	s.StartDate = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsRequest) SetSubDomain(v string) *DescribeDohSubDomainStatisticsRequest {
	s.SubDomain = &v
	return s
}

type DescribeDohSubDomainStatisticsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The statistics list.
	Statistics []*DescribeDohSubDomainStatisticsResponseBodyStatistics `json:"Statistics,omitempty" xml:"Statistics,omitempty" type:"Repeated"`
}

func (s DescribeDohSubDomainStatisticsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDohSubDomainStatisticsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDohSubDomainStatisticsResponseBody) SetRequestId(v string) *DescribeDohSubDomainStatisticsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsResponseBody) SetStatistics(v []*DescribeDohSubDomainStatisticsResponseBodyStatistics) *DescribeDohSubDomainStatisticsResponseBody {
	s.Statistics = v
	return s
}

type DescribeDohSubDomainStatisticsResponseBodyStatistics struct {
	// The timestamp.
	Timestamp *int64 `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The total number of requests.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The number of IPv4-based HTTP requests.
	V4HttpCount *int64 `json:"V4HttpCount,omitempty" xml:"V4HttpCount,omitempty"`
	// The number of IPv4-based HTTPS requests.
	V4HttpsCount *int64 `json:"V4HttpsCount,omitempty" xml:"V4HttpsCount,omitempty"`
	// The number of IPv6-based HTTP requests.
	V6HttpCount *int64 `json:"V6HttpCount,omitempty" xml:"V6HttpCount,omitempty"`
	// The number of IPv6-based HTTPS requests.
	V6HttpsCount *int64 `json:"V6HttpsCount,omitempty" xml:"V6HttpsCount,omitempty"`
}

func (s DescribeDohSubDomainStatisticsResponseBodyStatistics) String() string {
	return tea.Prettify(s)
}

func (s DescribeDohSubDomainStatisticsResponseBodyStatistics) GoString() string {
	return s.String()
}

func (s *DescribeDohSubDomainStatisticsResponseBodyStatistics) SetTimestamp(v int64) *DescribeDohSubDomainStatisticsResponseBodyStatistics {
	s.Timestamp = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsResponseBodyStatistics) SetTotalCount(v int64) *DescribeDohSubDomainStatisticsResponseBodyStatistics {
	s.TotalCount = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsResponseBodyStatistics) SetV4HttpCount(v int64) *DescribeDohSubDomainStatisticsResponseBodyStatistics {
	s.V4HttpCount = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsResponseBodyStatistics) SetV4HttpsCount(v int64) *DescribeDohSubDomainStatisticsResponseBodyStatistics {
	s.V4HttpsCount = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsResponseBodyStatistics) SetV6HttpCount(v int64) *DescribeDohSubDomainStatisticsResponseBodyStatistics {
	s.V6HttpCount = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsResponseBodyStatistics) SetV6HttpsCount(v int64) *DescribeDohSubDomainStatisticsResponseBodyStatistics {
	s.V6HttpsCount = &v
	return s
}

type DescribeDohSubDomainStatisticsResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDohSubDomainStatisticsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDohSubDomainStatisticsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDohSubDomainStatisticsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDohSubDomainStatisticsResponse) SetHeaders(v map[string]*string) *DescribeDohSubDomainStatisticsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDohSubDomainStatisticsResponse) SetStatusCode(v int32) *DescribeDohSubDomainStatisticsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsResponse) SetBody(v *DescribeDohSubDomainStatisticsResponseBody) *DescribeDohSubDomainStatisticsResponse {
	s.Body = v
	return s
}

type DescribeDohSubDomainStatisticsSummaryRequest struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the YYYY-MM-DD format.
	//
	// The default value is the day when you query the required data.
	EndDate *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The number of the page to return. Pages start from page 1. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: 100. Default value: 20.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The beginning of the time range to query. Specify the time in the YYYY-MM-DD format.
	//
	// You can query only the DNS records of the last 90 days. `The value of StartDate must be greater than or equal to the difference between the current date and 90`.
	StartDate *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
	// The subdomain.
	SubDomain *string `json:"SubDomain,omitempty" xml:"SubDomain,omitempty"`
}

func (s DescribeDohSubDomainStatisticsSummaryRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDohSubDomainStatisticsSummaryRequest) GoString() string {
	return s.String()
}

func (s *DescribeDohSubDomainStatisticsSummaryRequest) SetDomainName(v string) *DescribeDohSubDomainStatisticsSummaryRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsSummaryRequest) SetEndDate(v string) *DescribeDohSubDomainStatisticsSummaryRequest {
	s.EndDate = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsSummaryRequest) SetLang(v string) *DescribeDohSubDomainStatisticsSummaryRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsSummaryRequest) SetPageNumber(v int32) *DescribeDohSubDomainStatisticsSummaryRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsSummaryRequest) SetPageSize(v int32) *DescribeDohSubDomainStatisticsSummaryRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsSummaryRequest) SetStartDate(v string) *DescribeDohSubDomainStatisticsSummaryRequest {
	s.StartDate = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsSummaryRequest) SetSubDomain(v string) *DescribeDohSubDomainStatisticsSummaryRequest {
	s.SubDomain = &v
	return s
}

type DescribeDohSubDomainStatisticsSummaryResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The statistics list.
	Statistics []*DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics `json:"Statistics,omitempty" xml:"Statistics,omitempty" type:"Repeated"`
	// Total number of entries returned.
	TotalItems *int32 `json:"TotalItems,omitempty" xml:"TotalItems,omitempty"`
	// Total number of pages returned.
	TotalPages *int32 `json:"TotalPages,omitempty" xml:"TotalPages,omitempty"`
}

func (s DescribeDohSubDomainStatisticsSummaryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDohSubDomainStatisticsSummaryResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDohSubDomainStatisticsSummaryResponseBody) SetPageNumber(v int32) *DescribeDohSubDomainStatisticsSummaryResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsSummaryResponseBody) SetPageSize(v int32) *DescribeDohSubDomainStatisticsSummaryResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsSummaryResponseBody) SetRequestId(v string) *DescribeDohSubDomainStatisticsSummaryResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsSummaryResponseBody) SetStatistics(v []*DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics) *DescribeDohSubDomainStatisticsSummaryResponseBody {
	s.Statistics = v
	return s
}

func (s *DescribeDohSubDomainStatisticsSummaryResponseBody) SetTotalItems(v int32) *DescribeDohSubDomainStatisticsSummaryResponseBody {
	s.TotalItems = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsSummaryResponseBody) SetTotalPages(v int32) *DescribeDohSubDomainStatisticsSummaryResponseBody {
	s.TotalPages = &v
	return s
}

type DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics struct {
	// The number of HTTP requests.
	HttpCount *int64 `json:"HttpCount,omitempty" xml:"HttpCount,omitempty"`
	// The number of HTTPS requests.
	HttpsCount *int64 `json:"HttpsCount,omitempty" xml:"HttpsCount,omitempty"`
	// The number of IP addresses.
	IpCount *int64 `json:"IpCount,omitempty" xml:"IpCount,omitempty"`
	// The subdomain.
	SubDomain *string `json:"SubDomain,omitempty" xml:"SubDomain,omitempty"`
	// Total number of requests.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The number of IPv4-based HTTP requests.
	V4HttpCount *int64 `json:"V4HttpCount,omitempty" xml:"V4HttpCount,omitempty"`
	// The number of IPv4-based HTTPS requests.
	V4HttpsCount *int64 `json:"V4HttpsCount,omitempty" xml:"V4HttpsCount,omitempty"`
	// The number of IPv6-based HTTP requests.
	V6HttpCount *int64 `json:"V6HttpCount,omitempty" xml:"V6HttpCount,omitempty"`
	// The number of IPv6-based HTTPS requests.
	V6HttpsCount *int64 `json:"V6HttpsCount,omitempty" xml:"V6HttpsCount,omitempty"`
}

func (s DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics) String() string {
	return tea.Prettify(s)
}

func (s DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics) GoString() string {
	return s.String()
}

func (s *DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics) SetHttpCount(v int64) *DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics {
	s.HttpCount = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics) SetHttpsCount(v int64) *DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics {
	s.HttpsCount = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics) SetIpCount(v int64) *DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics {
	s.IpCount = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics) SetSubDomain(v string) *DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics {
	s.SubDomain = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics) SetTotalCount(v int64) *DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics {
	s.TotalCount = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics) SetV4HttpCount(v int64) *DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics {
	s.V4HttpCount = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics) SetV4HttpsCount(v int64) *DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics {
	s.V4HttpsCount = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics) SetV6HttpCount(v int64) *DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics {
	s.V6HttpCount = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics) SetV6HttpsCount(v int64) *DescribeDohSubDomainStatisticsSummaryResponseBodyStatistics {
	s.V6HttpsCount = &v
	return s
}

type DescribeDohSubDomainStatisticsSummaryResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDohSubDomainStatisticsSummaryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDohSubDomainStatisticsSummaryResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDohSubDomainStatisticsSummaryResponse) GoString() string {
	return s.String()
}

func (s *DescribeDohSubDomainStatisticsSummaryResponse) SetHeaders(v map[string]*string) *DescribeDohSubDomainStatisticsSummaryResponse {
	s.Headers = v
	return s
}

func (s *DescribeDohSubDomainStatisticsSummaryResponse) SetStatusCode(v int32) *DescribeDohSubDomainStatisticsSummaryResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDohSubDomainStatisticsSummaryResponse) SetBody(v *DescribeDohSubDomainStatisticsSummaryResponseBody) *DescribeDohSubDomainStatisticsSummaryResponse {
	s.Body = v
	return s
}

type DescribeDohUserInfoRequest struct {
	// The end time for the query. Format: YYYY-MM-DD
	//
	// If you do not specify this parameter, the default value is the time when you perform the query.
	EndDate *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	// The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The start time for the query. Format: YYYY-MM-DD
	//
	// You can query the user information of the last 90 days only. `Set the parameter to a value no earlier than 90 days from the current time`.
	StartDate *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
}

func (s DescribeDohUserInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDohUserInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribeDohUserInfoRequest) SetEndDate(v string) *DescribeDohUserInfoRequest {
	s.EndDate = &v
	return s
}

func (s *DescribeDohUserInfoRequest) SetLang(v string) *DescribeDohUserInfoRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDohUserInfoRequest) SetStartDate(v string) *DescribeDohUserInfoRequest {
	s.StartDate = &v
	return s
}

type DescribeDohUserInfoResponseBody struct {
	// The number of accessed domains.
	DomainCount *int32 `json:"DomainCount,omitempty" xml:"DomainCount,omitempty"`
	// The ID of the Alibaba Cloud public DNS user.
	PdnsId *int64 `json:"PdnsId,omitempty" xml:"PdnsId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of accessed subdomains.
	SubDomainCount *int32 `json:"SubDomainCount,omitempty" xml:"SubDomainCount,omitempty"`
}

func (s DescribeDohUserInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDohUserInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDohUserInfoResponseBody) SetDomainCount(v int32) *DescribeDohUserInfoResponseBody {
	s.DomainCount = &v
	return s
}

func (s *DescribeDohUserInfoResponseBody) SetPdnsId(v int64) *DescribeDohUserInfoResponseBody {
	s.PdnsId = &v
	return s
}

func (s *DescribeDohUserInfoResponseBody) SetRequestId(v string) *DescribeDohUserInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDohUserInfoResponseBody) SetSubDomainCount(v int32) *DescribeDohUserInfoResponseBody {
	s.SubDomainCount = &v
	return s
}

type DescribeDohUserInfoResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDohUserInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDohUserInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDohUserInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeDohUserInfoResponse) SetHeaders(v map[string]*string) *DescribeDohUserInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeDohUserInfoResponse) SetStatusCode(v int32) *DescribeDohUserInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDohUserInfoResponse) SetBody(v *DescribeDohUserInfoResponseBody) *DescribeDohUserInfoResponse {
	s.Body = v
	return s
}

type DescribeDomainDnssecInfoRequest struct {
	// The domain name for which DNSSEC configurations to query.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages, such as the region parameter. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DescribeDomainDnssecInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainDnssecInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainDnssecInfoRequest) SetDomainName(v string) *DescribeDomainDnssecInfoRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainDnssecInfoRequest) SetLang(v string) *DescribeDomainDnssecInfoRequest {
	s.Lang = &v
	return s
}

type DescribeDomainDnssecInfoResponseBody struct {
	// The algorithm configured in a DNSSEC record. This parameter is returned if DNSSEC is enabled.
	Algorithm *string `json:"Algorithm,omitempty" xml:"Algorithm,omitempty"`
	// The digest configured in a DNSSEC record. This parameter is returned if DNSSEC is enabled.
	Digest *string `json:"Digest,omitempty" xml:"Digest,omitempty"`
	// The digest type configured in a DNSSEC record. This parameter is returned if DNSSEC is enabled.
	DigestType *string `json:"DigestType,omitempty" xml:"DigestType,omitempty"`
	// The domain name that is queried.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The DS record. This parameter is returned if DNSSEC is enabled.
	DsRecord *string `json:"DsRecord,omitempty" xml:"DsRecord,omitempty"`
	// The flag of a DNSSEC record. This parameter is returned if DNSSEC is enabled.
	Flags *string `json:"Flags,omitempty" xml:"Flags,omitempty"`
	// The key tag of a DNSSEC record. This parameter is returned if DNSSEC is enabled.
	KeyTag *string `json:"KeyTag,omitempty" xml:"KeyTag,omitempty"`
	// The public key for a DNSSEC record. This parameter is returned if DNSSEC is enabled.
	PublicKey *string `json:"PublicKey,omitempty" xml:"PublicKey,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether DNSSEC is enabled for the specified domain name.
	//
	// *   ON: DNSSEC is enabled.
	// *   OFF: DNSSEC is disabled.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeDomainDnssecInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainDnssecInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainDnssecInfoResponseBody) SetAlgorithm(v string) *DescribeDomainDnssecInfoResponseBody {
	s.Algorithm = &v
	return s
}

func (s *DescribeDomainDnssecInfoResponseBody) SetDigest(v string) *DescribeDomainDnssecInfoResponseBody {
	s.Digest = &v
	return s
}

func (s *DescribeDomainDnssecInfoResponseBody) SetDigestType(v string) *DescribeDomainDnssecInfoResponseBody {
	s.DigestType = &v
	return s
}

func (s *DescribeDomainDnssecInfoResponseBody) SetDomainName(v string) *DescribeDomainDnssecInfoResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainDnssecInfoResponseBody) SetDsRecord(v string) *DescribeDomainDnssecInfoResponseBody {
	s.DsRecord = &v
	return s
}

func (s *DescribeDomainDnssecInfoResponseBody) SetFlags(v string) *DescribeDomainDnssecInfoResponseBody {
	s.Flags = &v
	return s
}

func (s *DescribeDomainDnssecInfoResponseBody) SetKeyTag(v string) *DescribeDomainDnssecInfoResponseBody {
	s.KeyTag = &v
	return s
}

func (s *DescribeDomainDnssecInfoResponseBody) SetPublicKey(v string) *DescribeDomainDnssecInfoResponseBody {
	s.PublicKey = &v
	return s
}

func (s *DescribeDomainDnssecInfoResponseBody) SetRequestId(v string) *DescribeDomainDnssecInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainDnssecInfoResponseBody) SetStatus(v string) *DescribeDomainDnssecInfoResponseBody {
	s.Status = &v
	return s
}

type DescribeDomainDnssecInfoResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainDnssecInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainDnssecInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainDnssecInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainDnssecInfoResponse) SetHeaders(v map[string]*string) *DescribeDomainDnssecInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainDnssecInfoResponse) SetStatusCode(v int32) *DescribeDomainDnssecInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainDnssecInfoResponse) SetBody(v *DescribeDomainDnssecInfoResponseBody) *DescribeDomainDnssecInfoResponse {
	s.Body = v
	return s
}

type DescribeDomainGroupsRequest struct {
	// The keyword of the domain name group for searches in %KeyWord% mode. The value is not case-sensitive.
	KeyWord *string `json:"KeyWord,omitempty" xml:"KeyWord,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The number of the page to return. Pages start from page **1**. Default value: **1**.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **100**. Default value: **20**.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeDomainGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainGroupsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainGroupsRequest) SetKeyWord(v string) *DescribeDomainGroupsRequest {
	s.KeyWord = &v
	return s
}

func (s *DescribeDomainGroupsRequest) SetLang(v string) *DescribeDomainGroupsRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDomainGroupsRequest) SetPageNumber(v int64) *DescribeDomainGroupsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDomainGroupsRequest) SetPageSize(v int64) *DescribeDomainGroupsRequest {
	s.PageSize = &v
	return s
}

type DescribeDomainGroupsResponseBody struct {
	// The list of domain name groups.
	DomainGroups *DescribeDomainGroupsResponseBodyDomainGroups `json:"DomainGroups,omitempty" xml:"DomainGroups,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of domain name groups.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDomainGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainGroupsResponseBody) SetDomainGroups(v *DescribeDomainGroupsResponseBodyDomainGroups) *DescribeDomainGroupsResponseBody {
	s.DomainGroups = v
	return s
}

func (s *DescribeDomainGroupsResponseBody) SetPageNumber(v int64) *DescribeDomainGroupsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDomainGroupsResponseBody) SetPageSize(v int64) *DescribeDomainGroupsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDomainGroupsResponseBody) SetRequestId(v string) *DescribeDomainGroupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainGroupsResponseBody) SetTotalCount(v int64) *DescribeDomainGroupsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDomainGroupsResponseBodyDomainGroups struct {
	DomainGroup []*DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup `json:"DomainGroup,omitempty" xml:"DomainGroup,omitempty" type:"Repeated"`
}

func (s DescribeDomainGroupsResponseBodyDomainGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainGroupsResponseBodyDomainGroups) GoString() string {
	return s.String()
}

func (s *DescribeDomainGroupsResponseBodyDomainGroups) SetDomainGroup(v []*DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup) *DescribeDomainGroupsResponseBodyDomainGroups {
	s.DomainGroup = v
	return s
}

type DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup struct {
	// The number of domain name groups.
	DomainCount *int64 `json:"DomainCount,omitempty" xml:"DomainCount,omitempty"`
	// The ID of the domain name group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the domain name group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
}

func (s DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup) GoString() string {
	return s.String()
}

func (s *DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup) SetDomainCount(v int64) *DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup {
	s.DomainCount = &v
	return s
}

func (s *DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup) SetGroupId(v string) *DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup {
	s.GroupId = &v
	return s
}

func (s *DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup) SetGroupName(v string) *DescribeDomainGroupsResponseBodyDomainGroupsDomainGroup {
	s.GroupName = &v
	return s
}

type DescribeDomainGroupsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainGroupsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainGroupsResponse) SetHeaders(v map[string]*string) *DescribeDomainGroupsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainGroupsResponse) SetStatusCode(v int32) *DescribeDomainGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainGroupsResponse) SetBody(v *DescribeDomainGroupsResponseBody) *DescribeDomainGroupsResponse {
	s.Body = v
	return s
}

type DescribeDomainInfoRequest struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// Specifies whether detailed attributes are required. Default value: **false**, which indicates that detailed attributes are not required.
	//
	// If you set this parameter to **true**, the values of the following parameters are returned: LineType, MinTtl, RecordLineTreeJson, RecordLines, LineCode, LineDisplayName, LineName, RegionLines, and SlaveDns.
	NeedDetailAttributes *bool `json:"NeedDetailAttributes,omitempty" xml:"NeedDetailAttributes,omitempty"`
}

func (s DescribeDomainInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainInfoRequest) SetDomainName(v string) *DescribeDomainInfoRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainInfoRequest) SetLang(v string) *DescribeDomainInfoRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDomainInfoRequest) SetNeedDetailAttributes(v bool) *DescribeDomainInfoRequest {
	s.NeedDetailAttributes = &v
	return s
}

type DescribeDomainInfoResponseBody struct {
	// Indicates whether the domain name is an Alibaba Cloud HiChina domain name.
	AliDomain *bool `json:"AliDomain,omitempty" xml:"AliDomain,omitempty"`
	// The available time to live (TTL) values.
	AvailableTtls *DescribeDomainInfoResponseBodyAvailableTtls `json:"AvailableTtls,omitempty" xml:"AvailableTtls,omitempty" type:"Struct"`
	// The time when the domain name was added to Alibaba Cloud CDN.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The information about DNS servers.
	DnsServers *DescribeDomainInfoResponseBodyDnsServers `json:"DnsServers,omitempty" xml:"DnsServers,omitempty" type:"Struct"`
	// The ID of the domain name.
	DomainId *string `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The ID of the domain name group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the domain name group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// Indicates whether blackhole filtering was triggered.
	InBlackHole *bool `json:"InBlackHole,omitempty" xml:"InBlackHole,omitempty"`
	// Indicates whether traffic scrubbing was started.
	InClean *bool `json:"InClean,omitempty" xml:"InClean,omitempty"`
	// The ID of the Alibaba Cloud DNS instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of line.
	LineType *string `json:"LineType,omitempty" xml:"LineType,omitempty"`
	// The minimum TTL.
	MinTtl *int64 `json:"MinTtl,omitempty" xml:"MinTtl,omitempty"`
	// The Punycode for the domain name. This parameter is returned only for Chinese domain names.
	PunyCode *string `json:"PunyCode,omitempty" xml:"PunyCode,omitempty"`
	// The tree-based lines.
	RecordLineTreeJson *string `json:"RecordLineTreeJson,omitempty" xml:"RecordLineTreeJson,omitempty"`
	// The information about lines.
	RecordLines *DescribeDomainInfoResponseBodyRecordLines `json:"RecordLines,omitempty" xml:"RecordLines,omitempty" type:"Struct"`
	// Indicates whether the lines are regional lines.
	RegionLines *bool `json:"RegionLines,omitempty" xml:"RegionLines,omitempty"`
	// The description of the domain name.
	Remark *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Indicates whether secondary DNS is allowed.
	SlaveDns *bool `json:"SlaveDns,omitempty" xml:"SlaveDns,omitempty"`
	// The version of the Alibaba Cloud DNS instance.
	VersionCode *string `json:"VersionCode,omitempty" xml:"VersionCode,omitempty"`
	// The edition of the Alibaba Cloud DNS instance.
	VersionName *string `json:"VersionName,omitempty" xml:"VersionName,omitempty"`
}

func (s DescribeDomainInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainInfoResponseBody) SetAliDomain(v bool) *DescribeDomainInfoResponseBody {
	s.AliDomain = &v
	return s
}

func (s *DescribeDomainInfoResponseBody) SetAvailableTtls(v *DescribeDomainInfoResponseBodyAvailableTtls) *DescribeDomainInfoResponseBody {
	s.AvailableTtls = v
	return s
}

func (s *DescribeDomainInfoResponseBody) SetCreateTime(v string) *DescribeDomainInfoResponseBody {
	s.CreateTime = &v
	return s
}

func (s *DescribeDomainInfoResponseBody) SetDnsServers(v *DescribeDomainInfoResponseBodyDnsServers) *DescribeDomainInfoResponseBody {
	s.DnsServers = v
	return s
}

func (s *DescribeDomainInfoResponseBody) SetDomainId(v string) *DescribeDomainInfoResponseBody {
	s.DomainId = &v
	return s
}

func (s *DescribeDomainInfoResponseBody) SetDomainName(v string) *DescribeDomainInfoResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainInfoResponseBody) SetGroupId(v string) *DescribeDomainInfoResponseBody {
	s.GroupId = &v
	return s
}

func (s *DescribeDomainInfoResponseBody) SetGroupName(v string) *DescribeDomainInfoResponseBody {
	s.GroupName = &v
	return s
}

func (s *DescribeDomainInfoResponseBody) SetInBlackHole(v bool) *DescribeDomainInfoResponseBody {
	s.InBlackHole = &v
	return s
}

func (s *DescribeDomainInfoResponseBody) SetInClean(v bool) *DescribeDomainInfoResponseBody {
	s.InClean = &v
	return s
}

func (s *DescribeDomainInfoResponseBody) SetInstanceId(v string) *DescribeDomainInfoResponseBody {
	s.InstanceId = &v
	return s
}

func (s *DescribeDomainInfoResponseBody) SetLineType(v string) *DescribeDomainInfoResponseBody {
	s.LineType = &v
	return s
}

func (s *DescribeDomainInfoResponseBody) SetMinTtl(v int64) *DescribeDomainInfoResponseBody {
	s.MinTtl = &v
	return s
}

func (s *DescribeDomainInfoResponseBody) SetPunyCode(v string) *DescribeDomainInfoResponseBody {
	s.PunyCode = &v
	return s
}

func (s *DescribeDomainInfoResponseBody) SetRecordLineTreeJson(v string) *DescribeDomainInfoResponseBody {
	s.RecordLineTreeJson = &v
	return s
}

func (s *DescribeDomainInfoResponseBody) SetRecordLines(v *DescribeDomainInfoResponseBodyRecordLines) *DescribeDomainInfoResponseBody {
	s.RecordLines = v
	return s
}

func (s *DescribeDomainInfoResponseBody) SetRegionLines(v bool) *DescribeDomainInfoResponseBody {
	s.RegionLines = &v
	return s
}

func (s *DescribeDomainInfoResponseBody) SetRemark(v string) *DescribeDomainInfoResponseBody {
	s.Remark = &v
	return s
}

func (s *DescribeDomainInfoResponseBody) SetRequestId(v string) *DescribeDomainInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainInfoResponseBody) SetResourceGroupId(v string) *DescribeDomainInfoResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDomainInfoResponseBody) SetSlaveDns(v bool) *DescribeDomainInfoResponseBody {
	s.SlaveDns = &v
	return s
}

func (s *DescribeDomainInfoResponseBody) SetVersionCode(v string) *DescribeDomainInfoResponseBody {
	s.VersionCode = &v
	return s
}

func (s *DescribeDomainInfoResponseBody) SetVersionName(v string) *DescribeDomainInfoResponseBody {
	s.VersionName = &v
	return s
}

type DescribeDomainInfoResponseBodyAvailableTtls struct {
	AvailableTtl []*string `json:"AvailableTtl,omitempty" xml:"AvailableTtl,omitempty" type:"Repeated"`
}

func (s DescribeDomainInfoResponseBodyAvailableTtls) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainInfoResponseBodyAvailableTtls) GoString() string {
	return s.String()
}

func (s *DescribeDomainInfoResponseBodyAvailableTtls) SetAvailableTtl(v []*string) *DescribeDomainInfoResponseBodyAvailableTtls {
	s.AvailableTtl = v
	return s
}

type DescribeDomainInfoResponseBodyDnsServers struct {
	DnsServer []*string `json:"DnsServer,omitempty" xml:"DnsServer,omitempty" type:"Repeated"`
}

func (s DescribeDomainInfoResponseBodyDnsServers) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainInfoResponseBodyDnsServers) GoString() string {
	return s.String()
}

func (s *DescribeDomainInfoResponseBodyDnsServers) SetDnsServer(v []*string) *DescribeDomainInfoResponseBodyDnsServers {
	s.DnsServer = v
	return s
}

type DescribeDomainInfoResponseBodyRecordLines struct {
	RecordLine []*DescribeDomainInfoResponseBodyRecordLinesRecordLine `json:"RecordLine,omitempty" xml:"RecordLine,omitempty" type:"Repeated"`
}

func (s DescribeDomainInfoResponseBodyRecordLines) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainInfoResponseBodyRecordLines) GoString() string {
	return s.String()
}

func (s *DescribeDomainInfoResponseBodyRecordLines) SetRecordLine(v []*DescribeDomainInfoResponseBodyRecordLinesRecordLine) *DescribeDomainInfoResponseBodyRecordLines {
	s.RecordLine = v
	return s
}

type DescribeDomainInfoResponseBodyRecordLinesRecordLine struct {
	// The code of the parent line. This parameter is left empty if the line has no parent line.
	FatherCode *string `json:"FatherCode,omitempty" xml:"FatherCode,omitempty"`
	// The code of the line.
	LineCode *string `json:"LineCode,omitempty" xml:"LineCode,omitempty"`
	// The name of the parent line.
	LineDisplayName *string `json:"LineDisplayName,omitempty" xml:"LineDisplayName,omitempty"`
	// The name of the line.
	LineName *string `json:"LineName,omitempty" xml:"LineName,omitempty"`
}

func (s DescribeDomainInfoResponseBodyRecordLinesRecordLine) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainInfoResponseBodyRecordLinesRecordLine) GoString() string {
	return s.String()
}

func (s *DescribeDomainInfoResponseBodyRecordLinesRecordLine) SetFatherCode(v string) *DescribeDomainInfoResponseBodyRecordLinesRecordLine {
	s.FatherCode = &v
	return s
}

func (s *DescribeDomainInfoResponseBodyRecordLinesRecordLine) SetLineCode(v string) *DescribeDomainInfoResponseBodyRecordLinesRecordLine {
	s.LineCode = &v
	return s
}

func (s *DescribeDomainInfoResponseBodyRecordLinesRecordLine) SetLineDisplayName(v string) *DescribeDomainInfoResponseBodyRecordLinesRecordLine {
	s.LineDisplayName = &v
	return s
}

func (s *DescribeDomainInfoResponseBodyRecordLinesRecordLine) SetLineName(v string) *DescribeDomainInfoResponseBodyRecordLinesRecordLine {
	s.LineName = &v
	return s
}

type DescribeDomainInfoResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainInfoResponse) SetHeaders(v map[string]*string) *DescribeDomainInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainInfoResponse) SetStatusCode(v int32) *DescribeDomainInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainInfoResponse) SetBody(v *DescribeDomainInfoResponseBody) *DescribeDomainInfoResponse {
	s.Body = v
	return s
}

type DescribeDomainLogsRequest struct {
	// The ID of the domain name group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The keyword for the query in "%KeyWord%" mode. The keyword is not case-sensitive.
	KeyWord *string `json:"KeyWord,omitempty" xml:"KeyWord,omitempty"`
	// The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The page number to return. The page number starts from **1**. Default value: **1**.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return per page. Maximum value: **100**. Default value: **20**.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The start time for the query. Format: **YYYY-MM-DD**
	StartDate *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
	// The type of object of which you want to query operation logs. Valid values:
	//
	// *   domain: domain name
	// *   slavedns: secondary Domain Name System (DNS)
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The end time for the query. Format: **YYYY-MM-DD**
	EndDate *string `json:"endDate,omitempty" xml:"endDate,omitempty"`
}

func (s DescribeDomainLogsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainLogsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainLogsRequest) SetGroupId(v string) *DescribeDomainLogsRequest {
	s.GroupId = &v
	return s
}

func (s *DescribeDomainLogsRequest) SetKeyWord(v string) *DescribeDomainLogsRequest {
	s.KeyWord = &v
	return s
}

func (s *DescribeDomainLogsRequest) SetLang(v string) *DescribeDomainLogsRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDomainLogsRequest) SetPageNumber(v int64) *DescribeDomainLogsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDomainLogsRequest) SetPageSize(v int64) *DescribeDomainLogsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDomainLogsRequest) SetStartDate(v string) *DescribeDomainLogsRequest {
	s.StartDate = &v
	return s
}

func (s *DescribeDomainLogsRequest) SetType(v string) *DescribeDomainLogsRequest {
	s.Type = &v
	return s
}

func (s *DescribeDomainLogsRequest) SetEndDate(v string) *DescribeDomainLogsRequest {
	s.EndDate = &v
	return s
}

type DescribeDomainLogsResponseBody struct {
	// The details about the operation logs that are queried.
	DomainLogs *DescribeDomainLogsResponseBodyDomainLogs `json:"DomainLogs,omitempty" xml:"DomainLogs,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of operation logs returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of operation logs returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDomainLogsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainLogsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainLogsResponseBody) SetDomainLogs(v *DescribeDomainLogsResponseBodyDomainLogs) *DescribeDomainLogsResponseBody {
	s.DomainLogs = v
	return s
}

func (s *DescribeDomainLogsResponseBody) SetPageNumber(v int64) *DescribeDomainLogsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDomainLogsResponseBody) SetPageSize(v int64) *DescribeDomainLogsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDomainLogsResponseBody) SetRequestId(v string) *DescribeDomainLogsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainLogsResponseBody) SetTotalCount(v int64) *DescribeDomainLogsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDomainLogsResponseBodyDomainLogs struct {
	DomainLog []*DescribeDomainLogsResponseBodyDomainLogsDomainLog `json:"DomainLog,omitempty" xml:"DomainLog,omitempty" type:"Repeated"`
}

func (s DescribeDomainLogsResponseBodyDomainLogs) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainLogsResponseBodyDomainLogs) GoString() string {
	return s.String()
}

func (s *DescribeDomainLogsResponseBodyDomainLogs) SetDomainLog(v []*DescribeDomainLogsResponseBodyDomainLogsDomainLog) *DescribeDomainLogsResponseBodyDomainLogs {
	s.DomainLog = v
	return s
}

type DescribeDomainLogsResponseBodyDomainLogsDomainLog struct {
	// The operation performed.
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// The time when the operation was performed.
	ActionTime *string `json:"ActionTime,omitempty" xml:"ActionTime,omitempty"`
	// The UNIX timestamp that indicates when the operation was performed.
	ActionTimestamp *int64 `json:"ActionTimestamp,omitempty" xml:"ActionTimestamp,omitempty"`
	// The IP address from which the operation was performed.
	ClientIp *string `json:"ClientIp,omitempty" xml:"ClientIp,omitempty"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The message for the operation.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the zone.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeDomainLogsResponseBodyDomainLogsDomainLog) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainLogsResponseBodyDomainLogsDomainLog) GoString() string {
	return s.String()
}

func (s *DescribeDomainLogsResponseBodyDomainLogsDomainLog) SetAction(v string) *DescribeDomainLogsResponseBodyDomainLogsDomainLog {
	s.Action = &v
	return s
}

func (s *DescribeDomainLogsResponseBodyDomainLogsDomainLog) SetActionTime(v string) *DescribeDomainLogsResponseBodyDomainLogsDomainLog {
	s.ActionTime = &v
	return s
}

func (s *DescribeDomainLogsResponseBodyDomainLogsDomainLog) SetActionTimestamp(v int64) *DescribeDomainLogsResponseBodyDomainLogsDomainLog {
	s.ActionTimestamp = &v
	return s
}

func (s *DescribeDomainLogsResponseBodyDomainLogsDomainLog) SetClientIp(v string) *DescribeDomainLogsResponseBodyDomainLogsDomainLog {
	s.ClientIp = &v
	return s
}

func (s *DescribeDomainLogsResponseBodyDomainLogsDomainLog) SetDomainName(v string) *DescribeDomainLogsResponseBodyDomainLogsDomainLog {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainLogsResponseBodyDomainLogsDomainLog) SetMessage(v string) *DescribeDomainLogsResponseBodyDomainLogsDomainLog {
	s.Message = &v
	return s
}

func (s *DescribeDomainLogsResponseBodyDomainLogsDomainLog) SetZoneId(v string) *DescribeDomainLogsResponseBodyDomainLogsDomainLog {
	s.ZoneId = &v
	return s
}

type DescribeDomainLogsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainLogsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainLogsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainLogsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainLogsResponse) SetHeaders(v map[string]*string) *DescribeDomainLogsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainLogsResponse) SetStatusCode(v int32) *DescribeDomainLogsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainLogsResponse) SetBody(v *DescribeDomainLogsResponseBody) *DescribeDomainLogsResponse {
	s.Body = v
	return s
}

type DescribeDomainNsRequest struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DescribeDomainNsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainNsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainNsRequest) SetDomainName(v string) *DescribeDomainNsRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainNsRequest) SetLang(v string) *DescribeDomainNsRequest {
	s.Lang = &v
	return s
}

type DescribeDomainNsResponseBody struct {
	// Indicates whether all the name servers were Alibaba Cloud DNS servers.
	AllAliDns              *bool   `json:"AllAliDns,omitempty" xml:"AllAliDns,omitempty"`
	DetectFailedReasonCode *string `json:"DetectFailedReasonCode,omitempty" xml:"DetectFailedReasonCode,omitempty"`
	// The list of DNS servers for the domain name.
	DnsServers *DescribeDomainNsResponseBodyDnsServers `json:"DnsServers,omitempty" xml:"DnsServers,omitempty" type:"Struct"`
	// The list of DNS servers assigned by Alibaba Cloud.
	ExpectDnsServers *DescribeDomainNsResponseBodyExpectDnsServers `json:"ExpectDnsServers,omitempty" xml:"ExpectDnsServers,omitempty" type:"Struct"`
	// Indicates whether the name servers included Alibaba Cloud DNS servers.
	IncludeAliDns *bool `json:"IncludeAliDns,omitempty" xml:"IncludeAliDns,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDomainNsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainNsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainNsResponseBody) SetAllAliDns(v bool) *DescribeDomainNsResponseBody {
	s.AllAliDns = &v
	return s
}

func (s *DescribeDomainNsResponseBody) SetDetectFailedReasonCode(v string) *DescribeDomainNsResponseBody {
	s.DetectFailedReasonCode = &v
	return s
}

func (s *DescribeDomainNsResponseBody) SetDnsServers(v *DescribeDomainNsResponseBodyDnsServers) *DescribeDomainNsResponseBody {
	s.DnsServers = v
	return s
}

func (s *DescribeDomainNsResponseBody) SetExpectDnsServers(v *DescribeDomainNsResponseBodyExpectDnsServers) *DescribeDomainNsResponseBody {
	s.ExpectDnsServers = v
	return s
}

func (s *DescribeDomainNsResponseBody) SetIncludeAliDns(v bool) *DescribeDomainNsResponseBody {
	s.IncludeAliDns = &v
	return s
}

func (s *DescribeDomainNsResponseBody) SetRequestId(v string) *DescribeDomainNsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDomainNsResponseBodyDnsServers struct {
	DnsServer []*string `json:"DnsServer,omitempty" xml:"DnsServer,omitempty" type:"Repeated"`
}

func (s DescribeDomainNsResponseBodyDnsServers) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainNsResponseBodyDnsServers) GoString() string {
	return s.String()
}

func (s *DescribeDomainNsResponseBodyDnsServers) SetDnsServer(v []*string) *DescribeDomainNsResponseBodyDnsServers {
	s.DnsServer = v
	return s
}

type DescribeDomainNsResponseBodyExpectDnsServers struct {
	ExpectDnsServer []*string `json:"ExpectDnsServer,omitempty" xml:"ExpectDnsServer,omitempty" type:"Repeated"`
}

func (s DescribeDomainNsResponseBodyExpectDnsServers) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainNsResponseBodyExpectDnsServers) GoString() string {
	return s.String()
}

func (s *DescribeDomainNsResponseBodyExpectDnsServers) SetExpectDnsServer(v []*string) *DescribeDomainNsResponseBodyExpectDnsServers {
	s.ExpectDnsServer = v
	return s
}

type DescribeDomainNsResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainNsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainNsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainNsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainNsResponse) SetHeaders(v map[string]*string) *DescribeDomainNsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainNsResponse) SetStatusCode(v int32) *DescribeDomainNsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainNsResponse) SetBody(v *DescribeDomainNsResponseBody) *DescribeDomainNsResponse {
	s.Body = v
	return s
}

type DescribeDomainRecordInfoRequest struct {
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the DNS record.
	//
	// This parameter is returned when you add a DNS record or when you query the list of DNS records.
	RecordId *string `json:"RecordId,omitempty" xml:"RecordId,omitempty"`
	// The IP address of the client.
	UserClientIp *string `json:"UserClientIp,omitempty" xml:"UserClientIp,omitempty"`
}

func (s DescribeDomainRecordInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRecordInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainRecordInfoRequest) SetLang(v string) *DescribeDomainRecordInfoRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDomainRecordInfoRequest) SetRecordId(v string) *DescribeDomainRecordInfoRequest {
	s.RecordId = &v
	return s
}

func (s *DescribeDomainRecordInfoRequest) SetUserClientIp(v string) *DescribeDomainRecordInfoRequest {
	s.UserClientIp = &v
	return s
}

type DescribeDomainRecordInfoResponseBody struct {
	// The ID of the domain name.
	DomainId *string `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The ID of the domain name group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the domain name group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The resolution line.
	Line *string `json:"Line,omitempty" xml:"Line,omitempty"`
	// The lock status of the DNS record. Valid values: true and false.
	Locked *bool `json:"Locked,omitempty" xml:"Locked,omitempty"`
	// The priority of the MX-type DNS record.
	Priority *int64 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The punycode is only returned for Chinese domain names.
	PunyCode *string `json:"PunyCode,omitempty" xml:"PunyCode,omitempty"`
	// The host record.
	RR *string `json:"RR,omitempty" xml:"RR,omitempty"`
	// The ID of the DNS record.
	RecordId *string `json:"RecordId,omitempty" xml:"RecordId,omitempty"`
	Remark   *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the DNS record. Valid values: Enable and Disable.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The TTL of the resolution.
	TTL *int64 `json:"TTL,omitempty" xml:"TTL,omitempty"`
	// The type of the DNS record.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value of the DNS record.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDomainRecordInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRecordInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainRecordInfoResponseBody) SetDomainId(v string) *DescribeDomainRecordInfoResponseBody {
	s.DomainId = &v
	return s
}

func (s *DescribeDomainRecordInfoResponseBody) SetDomainName(v string) *DescribeDomainRecordInfoResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainRecordInfoResponseBody) SetGroupId(v string) *DescribeDomainRecordInfoResponseBody {
	s.GroupId = &v
	return s
}

func (s *DescribeDomainRecordInfoResponseBody) SetGroupName(v string) *DescribeDomainRecordInfoResponseBody {
	s.GroupName = &v
	return s
}

func (s *DescribeDomainRecordInfoResponseBody) SetLine(v string) *DescribeDomainRecordInfoResponseBody {
	s.Line = &v
	return s
}

func (s *DescribeDomainRecordInfoResponseBody) SetLocked(v bool) *DescribeDomainRecordInfoResponseBody {
	s.Locked = &v
	return s
}

func (s *DescribeDomainRecordInfoResponseBody) SetPriority(v int64) *DescribeDomainRecordInfoResponseBody {
	s.Priority = &v
	return s
}

func (s *DescribeDomainRecordInfoResponseBody) SetPunyCode(v string) *DescribeDomainRecordInfoResponseBody {
	s.PunyCode = &v
	return s
}

func (s *DescribeDomainRecordInfoResponseBody) SetRR(v string) *DescribeDomainRecordInfoResponseBody {
	s.RR = &v
	return s
}

func (s *DescribeDomainRecordInfoResponseBody) SetRecordId(v string) *DescribeDomainRecordInfoResponseBody {
	s.RecordId = &v
	return s
}

func (s *DescribeDomainRecordInfoResponseBody) SetRemark(v string) *DescribeDomainRecordInfoResponseBody {
	s.Remark = &v
	return s
}

func (s *DescribeDomainRecordInfoResponseBody) SetRequestId(v string) *DescribeDomainRecordInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainRecordInfoResponseBody) SetStatus(v string) *DescribeDomainRecordInfoResponseBody {
	s.Status = &v
	return s
}

func (s *DescribeDomainRecordInfoResponseBody) SetTTL(v int64) *DescribeDomainRecordInfoResponseBody {
	s.TTL = &v
	return s
}

func (s *DescribeDomainRecordInfoResponseBody) SetType(v string) *DescribeDomainRecordInfoResponseBody {
	s.Type = &v
	return s
}

func (s *DescribeDomainRecordInfoResponseBody) SetValue(v string) *DescribeDomainRecordInfoResponseBody {
	s.Value = &v
	return s
}

type DescribeDomainRecordInfoResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainRecordInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainRecordInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRecordInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainRecordInfoResponse) SetHeaders(v map[string]*string) *DescribeDomainRecordInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainRecordInfoResponse) SetStatusCode(v int32) *DescribeDomainRecordInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainRecordInfoResponse) SetBody(v *DescribeDomainRecordInfoResponseBody) *DescribeDomainRecordInfoResponse {
	s.Body = v
	return s
}

type DescribeDomainRecordsRequest struct {
	// The order in which the returned DNS records are sorted. Valid values: DESC and ASC. Default value: DESC.
	Direction *string `json:"Direction,omitempty" xml:"Direction,omitempty"`
	// The domain name for which you want to query DNS records.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The ID of the domain name group.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The keyword based on which the system queries DNS records.
	KeyWord *string `json:"KeyWord,omitempty" xml:"KeyWord,omitempty"`
	// The language of the domain name.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The line based on which the system queries DNS records. Default value: **default**.
	//
	// For more information, see the following topic:
	//
	// [DNS lines](https://www.alibabacloud.com/help/zh/doc-detail/29807.htm)
	Line *string `json:"Line,omitempty" xml:"Line,omitempty"`
	// The method that is used to sort the returned DNS records. By default, the DNS records are sorted in reverse chronological order based on the time when they were added.
	OrderBy *string `json:"OrderBy,omitempty" xml:"OrderBy,omitempty"`
	// The number of the page to return. Pages start from page **1**. Default value: **1**.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **500**. Default value: **20**.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The resource record (RR) keyword based on which the system queries DNS records. The system queries DNS records based on the value of this parameter in fuzzy match mode. The value is not case-sensitive.
	RRKeyWord *string `json:"RRKeyWord,omitempty" xml:"RRKeyWord,omitempty"`
	// The search mode. Valid values: **LIKE, EXACT, and ADVANCED**.
	//
	// *   If you set this parameter to LIKE or EXACT, specify the KeyWord parameter.In this case, the RRKeyWord, TypeKeyWord, ValueKeyWord, Type, Line, and Status parameters are ignored.
	//
	// *   If you set this parameter to ADVANCED, specify the RRKeyWord, TypeKeyWord, ValueKeyWord, Type, Line, and Status parameters.
	//
	// *   If you do not specify this parameter, the system determines the search mode based on the following rules:
	//
	//     *   If the KeyWord parameter is specified, the system uses the LIKE mode.
	//     *   If the KeyWord parameter is not specified, the system queries DNS records based on values of the RRKeyWord and ValueKeyWord parameters in fuzzy match mode, and based on the values of the TypeKeyWord, Type, Line, and Status parameters in exact match mode.
	SearchMode *string `json:"SearchMode,omitempty" xml:"SearchMode,omitempty"`
	// The status of the DNS records to query. Valid values: **Enable and Disable**.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the DNS records to query. For more information, see the following topic:
	//
	// [DNS record types](https://www.alibabacloud.com/help/zh/doc-detail/29805.htm)
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The type keyword based on which the system queries DNS records. The system queries DNS records based on the value of this parameter in exact match mode. The value is not case-sensitive.
	TypeKeyWord *string `json:"TypeKeyWord,omitempty" xml:"TypeKeyWord,omitempty"`
	// The record value keyword based on which the system queries DNS records. The system queries DNS records based on the value of this parameter in fuzzy match mode. The value is not case-sensitive.
	ValueKeyWord *string `json:"ValueKeyWord,omitempty" xml:"ValueKeyWord,omitempty"`
}

func (s DescribeDomainRecordsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRecordsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainRecordsRequest) SetDirection(v string) *DescribeDomainRecordsRequest {
	s.Direction = &v
	return s
}

func (s *DescribeDomainRecordsRequest) SetDomainName(v string) *DescribeDomainRecordsRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainRecordsRequest) SetGroupId(v int64) *DescribeDomainRecordsRequest {
	s.GroupId = &v
	return s
}

func (s *DescribeDomainRecordsRequest) SetKeyWord(v string) *DescribeDomainRecordsRequest {
	s.KeyWord = &v
	return s
}

func (s *DescribeDomainRecordsRequest) SetLang(v string) *DescribeDomainRecordsRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDomainRecordsRequest) SetLine(v string) *DescribeDomainRecordsRequest {
	s.Line = &v
	return s
}

func (s *DescribeDomainRecordsRequest) SetOrderBy(v string) *DescribeDomainRecordsRequest {
	s.OrderBy = &v
	return s
}

func (s *DescribeDomainRecordsRequest) SetPageNumber(v int64) *DescribeDomainRecordsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDomainRecordsRequest) SetPageSize(v int64) *DescribeDomainRecordsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDomainRecordsRequest) SetRRKeyWord(v string) *DescribeDomainRecordsRequest {
	s.RRKeyWord = &v
	return s
}

func (s *DescribeDomainRecordsRequest) SetSearchMode(v string) *DescribeDomainRecordsRequest {
	s.SearchMode = &v
	return s
}

func (s *DescribeDomainRecordsRequest) SetStatus(v string) *DescribeDomainRecordsRequest {
	s.Status = &v
	return s
}

func (s *DescribeDomainRecordsRequest) SetType(v string) *DescribeDomainRecordsRequest {
	s.Type = &v
	return s
}

func (s *DescribeDomainRecordsRequest) SetTypeKeyWord(v string) *DescribeDomainRecordsRequest {
	s.TypeKeyWord = &v
	return s
}

func (s *DescribeDomainRecordsRequest) SetValueKeyWord(v string) *DescribeDomainRecordsRequest {
	s.ValueKeyWord = &v
	return s
}

type DescribeDomainRecordsResponseBody struct {
	// The DNS records returned.
	DomainRecords *DescribeDomainRecordsResponseBodyDomainRecords `json:"DomainRecords,omitempty" xml:"DomainRecords,omitempty" type:"Struct"`
	// The number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of DNS records.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDomainRecordsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRecordsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainRecordsResponseBody) SetDomainRecords(v *DescribeDomainRecordsResponseBodyDomainRecords) *DescribeDomainRecordsResponseBody {
	s.DomainRecords = v
	return s
}

func (s *DescribeDomainRecordsResponseBody) SetPageNumber(v int64) *DescribeDomainRecordsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDomainRecordsResponseBody) SetPageSize(v int64) *DescribeDomainRecordsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDomainRecordsResponseBody) SetRequestId(v string) *DescribeDomainRecordsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainRecordsResponseBody) SetTotalCount(v int64) *DescribeDomainRecordsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDomainRecordsResponseBodyDomainRecords struct {
	Record []*DescribeDomainRecordsResponseBodyDomainRecordsRecord `json:"Record,omitempty" xml:"Record,omitempty" type:"Repeated"`
}

func (s DescribeDomainRecordsResponseBodyDomainRecords) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRecordsResponseBodyDomainRecords) GoString() string {
	return s.String()
}

func (s *DescribeDomainRecordsResponseBodyDomainRecords) SetRecord(v []*DescribeDomainRecordsResponseBodyDomainRecordsRecord) *DescribeDomainRecordsResponseBodyDomainRecords {
	s.Record = v
	return s
}

type DescribeDomainRecordsResponseBodyDomainRecordsRecord struct {
	// The domain name to which the DNS record belongs.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The line that is used by the DNS record.
	Line *string `json:"Line,omitempty" xml:"Line,omitempty"`
	// Indicates whether the DNS record is locked.
	Locked *bool `json:"Locked,omitempty" xml:"Locked,omitempty"`
	// The priority of the MX record.
	Priority *int64 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The RR value.
	RR *string `json:"RR,omitempty" xml:"RR,omitempty"`
	// The ID of the DNS record.
	RecordId *string `json:"RecordId,omitempty" xml:"RecordId,omitempty"`
	// The description of the DNS record.
	Remark *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
	// The status of the DNS record.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The time-to-live (TTL) of the DNS record.
	TTL *int64 `json:"TTL,omitempty" xml:"TTL,omitempty"`
	// The type of the DNS record.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The record value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
	// The weight of the DNS record.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeDomainRecordsResponseBodyDomainRecordsRecord) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRecordsResponseBodyDomainRecordsRecord) GoString() string {
	return s.String()
}

func (s *DescribeDomainRecordsResponseBodyDomainRecordsRecord) SetDomainName(v string) *DescribeDomainRecordsResponseBodyDomainRecordsRecord {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainRecordsResponseBodyDomainRecordsRecord) SetLine(v string) *DescribeDomainRecordsResponseBodyDomainRecordsRecord {
	s.Line = &v
	return s
}

func (s *DescribeDomainRecordsResponseBodyDomainRecordsRecord) SetLocked(v bool) *DescribeDomainRecordsResponseBodyDomainRecordsRecord {
	s.Locked = &v
	return s
}

func (s *DescribeDomainRecordsResponseBodyDomainRecordsRecord) SetPriority(v int64) *DescribeDomainRecordsResponseBodyDomainRecordsRecord {
	s.Priority = &v
	return s
}

func (s *DescribeDomainRecordsResponseBodyDomainRecordsRecord) SetRR(v string) *DescribeDomainRecordsResponseBodyDomainRecordsRecord {
	s.RR = &v
	return s
}

func (s *DescribeDomainRecordsResponseBodyDomainRecordsRecord) SetRecordId(v string) *DescribeDomainRecordsResponseBodyDomainRecordsRecord {
	s.RecordId = &v
	return s
}

func (s *DescribeDomainRecordsResponseBodyDomainRecordsRecord) SetRemark(v string) *DescribeDomainRecordsResponseBodyDomainRecordsRecord {
	s.Remark = &v
	return s
}

func (s *DescribeDomainRecordsResponseBodyDomainRecordsRecord) SetStatus(v string) *DescribeDomainRecordsResponseBodyDomainRecordsRecord {
	s.Status = &v
	return s
}

func (s *DescribeDomainRecordsResponseBodyDomainRecordsRecord) SetTTL(v int64) *DescribeDomainRecordsResponseBodyDomainRecordsRecord {
	s.TTL = &v
	return s
}

func (s *DescribeDomainRecordsResponseBodyDomainRecordsRecord) SetType(v string) *DescribeDomainRecordsResponseBodyDomainRecordsRecord {
	s.Type = &v
	return s
}

func (s *DescribeDomainRecordsResponseBodyDomainRecordsRecord) SetValue(v string) *DescribeDomainRecordsResponseBodyDomainRecordsRecord {
	s.Value = &v
	return s
}

func (s *DescribeDomainRecordsResponseBodyDomainRecordsRecord) SetWeight(v int32) *DescribeDomainRecordsResponseBodyDomainRecordsRecord {
	s.Weight = &v
	return s
}

type DescribeDomainRecordsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainRecordsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainRecordsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainRecordsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainRecordsResponse) SetHeaders(v map[string]*string) *DescribeDomainRecordsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainRecordsResponse) SetStatusCode(v int32) *DescribeDomainRecordsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainRecordsResponse) SetBody(v *DescribeDomainRecordsResponseBody) *DescribeDomainRecordsResponse {
	s.Body = v
	return s
}

type DescribeDomainResolveStatisticsSummaryRequest struct {
	Direction  *string `json:"Direction,omitempty" xml:"Direction,omitempty"`
	EndDate    *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	Keyword    *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	Lang       *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	PageNumber *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	SearchMode *string `json:"SearchMode,omitempty" xml:"SearchMode,omitempty"`
	StartDate  *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
	Threshold  *int64  `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s DescribeDomainResolveStatisticsSummaryRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainResolveStatisticsSummaryRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainResolveStatisticsSummaryRequest) SetDirection(v string) *DescribeDomainResolveStatisticsSummaryRequest {
	s.Direction = &v
	return s
}

func (s *DescribeDomainResolveStatisticsSummaryRequest) SetEndDate(v string) *DescribeDomainResolveStatisticsSummaryRequest {
	s.EndDate = &v
	return s
}

func (s *DescribeDomainResolveStatisticsSummaryRequest) SetKeyword(v string) *DescribeDomainResolveStatisticsSummaryRequest {
	s.Keyword = &v
	return s
}

func (s *DescribeDomainResolveStatisticsSummaryRequest) SetLang(v string) *DescribeDomainResolveStatisticsSummaryRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDomainResolveStatisticsSummaryRequest) SetPageNumber(v int32) *DescribeDomainResolveStatisticsSummaryRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDomainResolveStatisticsSummaryRequest) SetPageSize(v int32) *DescribeDomainResolveStatisticsSummaryRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDomainResolveStatisticsSummaryRequest) SetSearchMode(v string) *DescribeDomainResolveStatisticsSummaryRequest {
	s.SearchMode = &v
	return s
}

func (s *DescribeDomainResolveStatisticsSummaryRequest) SetStartDate(v string) *DescribeDomainResolveStatisticsSummaryRequest {
	s.StartDate = &v
	return s
}

func (s *DescribeDomainResolveStatisticsSummaryRequest) SetThreshold(v int64) *DescribeDomainResolveStatisticsSummaryRequest {
	s.Threshold = &v
	return s
}

type DescribeDomainResolveStatisticsSummaryResponseBody struct {
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// RequestId
	RequestId  *string                                                         `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Statistics []*DescribeDomainResolveStatisticsSummaryResponseBodyStatistics `json:"Statistics,omitempty" xml:"Statistics,omitempty" type:"Repeated"`
	TotalItems *int32                                                          `json:"TotalItems,omitempty" xml:"TotalItems,omitempty"`
	TotalPages *int32                                                          `json:"TotalPages,omitempty" xml:"TotalPages,omitempty"`
}

func (s DescribeDomainResolveStatisticsSummaryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainResolveStatisticsSummaryResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainResolveStatisticsSummaryResponseBody) SetPageNumber(v int32) *DescribeDomainResolveStatisticsSummaryResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDomainResolveStatisticsSummaryResponseBody) SetPageSize(v int32) *DescribeDomainResolveStatisticsSummaryResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDomainResolveStatisticsSummaryResponseBody) SetRequestId(v string) *DescribeDomainResolveStatisticsSummaryResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainResolveStatisticsSummaryResponseBody) SetStatistics(v []*DescribeDomainResolveStatisticsSummaryResponseBodyStatistics) *DescribeDomainResolveStatisticsSummaryResponseBody {
	s.Statistics = v
	return s
}

func (s *DescribeDomainResolveStatisticsSummaryResponseBody) SetTotalItems(v int32) *DescribeDomainResolveStatisticsSummaryResponseBody {
	s.TotalItems = &v
	return s
}

func (s *DescribeDomainResolveStatisticsSummaryResponseBody) SetTotalPages(v int32) *DescribeDomainResolveStatisticsSummaryResponseBody {
	s.TotalPages = &v
	return s
}

type DescribeDomainResolveStatisticsSummaryResponseBodyStatistics struct {
	Count      *string `json:"Count,omitempty" xml:"Count,omitempty"`
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	DomainType *string `json:"DomainType,omitempty" xml:"DomainType,omitempty"`
}

func (s DescribeDomainResolveStatisticsSummaryResponseBodyStatistics) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainResolveStatisticsSummaryResponseBodyStatistics) GoString() string {
	return s.String()
}

func (s *DescribeDomainResolveStatisticsSummaryResponseBodyStatistics) SetCount(v string) *DescribeDomainResolveStatisticsSummaryResponseBodyStatistics {
	s.Count = &v
	return s
}

func (s *DescribeDomainResolveStatisticsSummaryResponseBodyStatistics) SetDomainName(v string) *DescribeDomainResolveStatisticsSummaryResponseBodyStatistics {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainResolveStatisticsSummaryResponseBodyStatistics) SetDomainType(v string) *DescribeDomainResolveStatisticsSummaryResponseBodyStatistics {
	s.DomainType = &v
	return s
}

type DescribeDomainResolveStatisticsSummaryResponse struct {
	Headers    map[string]*string                                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainResolveStatisticsSummaryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainResolveStatisticsSummaryResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainResolveStatisticsSummaryResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainResolveStatisticsSummaryResponse) SetHeaders(v map[string]*string) *DescribeDomainResolveStatisticsSummaryResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainResolveStatisticsSummaryResponse) SetStatusCode(v int32) *DescribeDomainResolveStatisticsSummaryResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainResolveStatisticsSummaryResponse) SetBody(v *DescribeDomainResolveStatisticsSummaryResponseBody) *DescribeDomainResolveStatisticsSummaryResponse {
	s.Body = v
	return s
}

type DescribeDomainStatisticsRequest struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	DomainType *string `json:"DomainType,omitempty" xml:"DomainType,omitempty"`
	// The end of the time range to query. Specify the time in the **YYYY-MM-DD** format.
	//
	// The default value is the day when you perform the operation.
	EndDate *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The beginning of the time range to query. Specify the time in the **YYYY-MM-DD** format.
	//
	// You can only query the DNS records of the last 90 days.
	StartDate *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
}

func (s DescribeDomainStatisticsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainStatisticsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainStatisticsRequest) SetDomainName(v string) *DescribeDomainStatisticsRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainStatisticsRequest) SetDomainType(v string) *DescribeDomainStatisticsRequest {
	s.DomainType = &v
	return s
}

func (s *DescribeDomainStatisticsRequest) SetEndDate(v string) *DescribeDomainStatisticsRequest {
	s.EndDate = &v
	return s
}

func (s *DescribeDomainStatisticsRequest) SetLang(v string) *DescribeDomainStatisticsRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDomainStatisticsRequest) SetStartDate(v string) *DescribeDomainStatisticsRequest {
	s.StartDate = &v
	return s
}

type DescribeDomainStatisticsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of query volume records.
	Statistics *DescribeDomainStatisticsResponseBodyStatistics `json:"Statistics,omitempty" xml:"Statistics,omitempty" type:"Struct"`
}

func (s DescribeDomainStatisticsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainStatisticsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainStatisticsResponseBody) SetRequestId(v string) *DescribeDomainStatisticsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainStatisticsResponseBody) SetStatistics(v *DescribeDomainStatisticsResponseBodyStatistics) *DescribeDomainStatisticsResponseBody {
	s.Statistics = v
	return s
}

type DescribeDomainStatisticsResponseBodyStatistics struct {
	Statistic []*DescribeDomainStatisticsResponseBodyStatisticsStatistic `json:"Statistic,omitempty" xml:"Statistic,omitempty" type:"Repeated"`
}

func (s DescribeDomainStatisticsResponseBodyStatistics) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainStatisticsResponseBodyStatistics) GoString() string {
	return s.String()
}

func (s *DescribeDomainStatisticsResponseBodyStatistics) SetStatistic(v []*DescribeDomainStatisticsResponseBodyStatisticsStatistic) *DescribeDomainStatisticsResponseBodyStatistics {
	s.Statistic = v
	return s
}

type DescribeDomainStatisticsResponseBodyStatisticsStatistic struct {
	// The number of queries.
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The UNIX timestamp representing the collection time.
	Timestamp *int64 `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
}

func (s DescribeDomainStatisticsResponseBodyStatisticsStatistic) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainStatisticsResponseBodyStatisticsStatistic) GoString() string {
	return s.String()
}

func (s *DescribeDomainStatisticsResponseBodyStatisticsStatistic) SetCount(v int64) *DescribeDomainStatisticsResponseBodyStatisticsStatistic {
	s.Count = &v
	return s
}

func (s *DescribeDomainStatisticsResponseBodyStatisticsStatistic) SetTimestamp(v int64) *DescribeDomainStatisticsResponseBodyStatisticsStatistic {
	s.Timestamp = &v
	return s
}

type DescribeDomainStatisticsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainStatisticsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainStatisticsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainStatisticsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainStatisticsResponse) SetHeaders(v map[string]*string) *DescribeDomainStatisticsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainStatisticsResponse) SetStatusCode(v int32) *DescribeDomainStatisticsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainStatisticsResponse) SetBody(v *DescribeDomainStatisticsResponseBody) *DescribeDomainStatisticsResponse {
	s.Body = v
	return s
}

type DescribeDomainStatisticsSummaryRequest struct {
	// The end of the time range to query. Specify the time in the **YYYY-MM-DD** format.
	//
	// The default value is the day when you perform the operation.
	EndDate *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	// The keyword for searches in %KeyWord% mode. The value is not case-sensitive.
	Keyword *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The number of the page to return. Pages start from page **1**. Default value: **1**.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **100**. Minimum value: **1**. Default value: **20**.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The search mode of the keyword. Valid values:
	//
	// *   **LIKE**: fuzzy match (default).
	// *   **EXACT**: exact match.
	SearchMode *string `json:"SearchMode,omitempty" xml:"SearchMode,omitempty"`
	// The beginning of the time range to query. Specify the time in the **YYYY-MM-DD** format.
	//
	// You can only query DNS records of the last 90 days.
	StartDate *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
	// The threshold of query volume that can be obtained. You can also obtain data about a domain name with the query volume less than or equal to the threshold. For example, if you set this parameter to 100, you can query domain names with less than 100 queries.
	Threshold *int64 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s DescribeDomainStatisticsSummaryRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainStatisticsSummaryRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainStatisticsSummaryRequest) SetEndDate(v string) *DescribeDomainStatisticsSummaryRequest {
	s.EndDate = &v
	return s
}

func (s *DescribeDomainStatisticsSummaryRequest) SetKeyword(v string) *DescribeDomainStatisticsSummaryRequest {
	s.Keyword = &v
	return s
}

func (s *DescribeDomainStatisticsSummaryRequest) SetLang(v string) *DescribeDomainStatisticsSummaryRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDomainStatisticsSummaryRequest) SetPageNumber(v int64) *DescribeDomainStatisticsSummaryRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDomainStatisticsSummaryRequest) SetPageSize(v int64) *DescribeDomainStatisticsSummaryRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDomainStatisticsSummaryRequest) SetSearchMode(v string) *DescribeDomainStatisticsSummaryRequest {
	s.SearchMode = &v
	return s
}

func (s *DescribeDomainStatisticsSummaryRequest) SetStartDate(v string) *DescribeDomainStatisticsSummaryRequest {
	s.StartDate = &v
	return s
}

func (s *DescribeDomainStatisticsSummaryRequest) SetThreshold(v int64) *DescribeDomainStatisticsSummaryRequest {
	s.Threshold = &v
	return s
}

type DescribeDomainStatisticsSummaryResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of query volume records.
	Statistics *DescribeDomainStatisticsSummaryResponseBodyStatistics `json:"Statistics,omitempty" xml:"Statistics,omitempty" type:"Struct"`
	// The total number of data records.
	TotalItems *int32 `json:"TotalItems,omitempty" xml:"TotalItems,omitempty"`
	// The total number of returned pages.
	TotalPages *int32 `json:"TotalPages,omitempty" xml:"TotalPages,omitempty"`
}

func (s DescribeDomainStatisticsSummaryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainStatisticsSummaryResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainStatisticsSummaryResponseBody) SetPageNumber(v int32) *DescribeDomainStatisticsSummaryResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDomainStatisticsSummaryResponseBody) SetPageSize(v int32) *DescribeDomainStatisticsSummaryResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDomainStatisticsSummaryResponseBody) SetRequestId(v string) *DescribeDomainStatisticsSummaryResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainStatisticsSummaryResponseBody) SetStatistics(v *DescribeDomainStatisticsSummaryResponseBodyStatistics) *DescribeDomainStatisticsSummaryResponseBody {
	s.Statistics = v
	return s
}

func (s *DescribeDomainStatisticsSummaryResponseBody) SetTotalItems(v int32) *DescribeDomainStatisticsSummaryResponseBody {
	s.TotalItems = &v
	return s
}

func (s *DescribeDomainStatisticsSummaryResponseBody) SetTotalPages(v int32) *DescribeDomainStatisticsSummaryResponseBody {
	s.TotalPages = &v
	return s
}

type DescribeDomainStatisticsSummaryResponseBodyStatistics struct {
	Statistic []*DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic `json:"Statistic,omitempty" xml:"Statistic,omitempty" type:"Repeated"`
}

func (s DescribeDomainStatisticsSummaryResponseBodyStatistics) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainStatisticsSummaryResponseBodyStatistics) GoString() string {
	return s.String()
}

func (s *DescribeDomainStatisticsSummaryResponseBodyStatistics) SetStatistic(v []*DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic) *DescribeDomainStatisticsSummaryResponseBodyStatistics {
	s.Statistic = v
	return s
}

type DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic struct {
	// The number of queries.
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	DomainType *string `json:"DomainType,omitempty" xml:"DomainType,omitempty"`
}

func (s DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic) GoString() string {
	return s.String()
}

func (s *DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic) SetCount(v int64) *DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic {
	s.Count = &v
	return s
}

func (s *DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic) SetDomainName(v string) *DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic) SetDomainType(v string) *DescribeDomainStatisticsSummaryResponseBodyStatisticsStatistic {
	s.DomainType = &v
	return s
}

type DescribeDomainStatisticsSummaryResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainStatisticsSummaryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainStatisticsSummaryResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainStatisticsSummaryResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainStatisticsSummaryResponse) SetHeaders(v map[string]*string) *DescribeDomainStatisticsSummaryResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainStatisticsSummaryResponse) SetStatusCode(v int32) *DescribeDomainStatisticsSummaryResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainStatisticsSummaryResponse) SetBody(v *DescribeDomainStatisticsSummaryResponseBody) *DescribeDomainStatisticsSummaryResponse {
	s.Body = v
	return s
}

type DescribeDomainsRequest struct {
	// The ID of the domain name group. If you do not specify this parameter, all domain names are queried by default.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The keyword for searches in "%KeyWord%" mode. The value is not case-sensitive.
	KeyWord *string `json:"KeyWord,omitempty" xml:"KeyWord,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The number of the page to return. Pages start from page **1**. Default value: **1**.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **100**. Default value: **20**.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The search mode. Valid values:
	//
	// *   **LIKE**: fuzzy match.
	// *   **EXACT**: exact match.
	SearchMode *string `json:"SearchMode,omitempty" xml:"SearchMode,omitempty"`
	// Specifies whether to query the starmark of the domain name.
	Starmark *bool `json:"Starmark,omitempty" xml:"Starmark,omitempty"`
}

func (s DescribeDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainsRequest) SetGroupId(v string) *DescribeDomainsRequest {
	s.GroupId = &v
	return s
}

func (s *DescribeDomainsRequest) SetKeyWord(v string) *DescribeDomainsRequest {
	s.KeyWord = &v
	return s
}

func (s *DescribeDomainsRequest) SetLang(v string) *DescribeDomainsRequest {
	s.Lang = &v
	return s
}

func (s *DescribeDomainsRequest) SetPageNumber(v int64) *DescribeDomainsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDomainsRequest) SetPageSize(v int64) *DescribeDomainsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDomainsRequest) SetResourceGroupId(v string) *DescribeDomainsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDomainsRequest) SetSearchMode(v string) *DescribeDomainsRequest {
	s.SearchMode = &v
	return s
}

func (s *DescribeDomainsRequest) SetStarmark(v bool) *DescribeDomainsRequest {
	s.Starmark = &v
	return s
}

type DescribeDomainsResponseBody struct {
	// The list of domain names queried by this operation.
	Domains *DescribeDomainsResponseBodyDomains `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of domain names.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainsResponseBody) SetDomains(v *DescribeDomainsResponseBodyDomains) *DescribeDomainsResponseBody {
	s.Domains = v
	return s
}

func (s *DescribeDomainsResponseBody) SetPageNumber(v int64) *DescribeDomainsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDomainsResponseBody) SetPageSize(v int64) *DescribeDomainsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDomainsResponseBody) SetRequestId(v string) *DescribeDomainsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainsResponseBody) SetTotalCount(v int64) *DescribeDomainsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDomainsResponseBodyDomains struct {
	Domain []*DescribeDomainsResponseBodyDomainsDomain `json:"Domain,omitempty" xml:"Domain,omitempty" type:"Repeated"`
}

func (s DescribeDomainsResponseBodyDomains) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsResponseBodyDomains) GoString() string {
	return s.String()
}

func (s *DescribeDomainsResponseBodyDomains) SetDomain(v []*DescribeDomainsResponseBodyDomainsDomain) *DescribeDomainsResponseBodyDomains {
	s.Domain = v
	return s
}

type DescribeDomainsResponseBodyDomainsDomain struct {
	// Indicates whether the domain name is an Alibaba Cloud HiChina domain name.
	AliDomain       *bool   `json:"AliDomain,omitempty" xml:"AliDomain,omitempty"`
	CreateTime      *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	CreateTimestamp *int64  `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The list of DNS servers of the domain name in the DNS system.
	DnsServers *DescribeDomainsResponseBodyDomainsDomainDnsServers `json:"DnsServers,omitempty" xml:"DnsServers,omitempty" type:"Struct"`
	// The ID of the domain name.
	DomainId *string `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The ID of the domain name group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the domain name group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The expiration time of the instance.
	InstanceEndTime *string `json:"InstanceEndTime,omitempty" xml:"InstanceEndTime,omitempty"`
	// Indicates whether the instance expired.
	InstanceExpired *bool `json:"InstanceExpired,omitempty" xml:"InstanceExpired,omitempty"`
	// The ID of the Alibaba Cloud DNS instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The punycode is returned for Chinese domain names and is left blank for English domain names.
	PunyCode *string `json:"PunyCode,omitempty" xml:"PunyCode,omitempty"`
	// The number of DNS records of the domain name.
	RecordCount *int64 `json:"RecordCount,omitempty" xml:"RecordCount,omitempty"`
	// The email address of the registrant.
	RegistrantEmail *string `json:"RegistrantEmail,omitempty" xml:"RegistrantEmail,omitempty"`
	// The description.
	Remark          *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Indicates whether to query the starmark of the domain name.
	Starmark *bool                                         `json:"Starmark,omitempty" xml:"Starmark,omitempty"`
	Tags     *DescribeDomainsResponseBodyDomainsDomainTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The version code of the Alibaba Cloud DNS instance.
	VersionCode *string `json:"VersionCode,omitempty" xml:"VersionCode,omitempty"`
	// The version name of the Alibaba Cloud DNS instance.
	VersionName *string `json:"VersionName,omitempty" xml:"VersionName,omitempty"`
}

func (s DescribeDomainsResponseBodyDomainsDomain) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsResponseBodyDomainsDomain) GoString() string {
	return s.String()
}

func (s *DescribeDomainsResponseBodyDomainsDomain) SetAliDomain(v bool) *DescribeDomainsResponseBodyDomainsDomain {
	s.AliDomain = &v
	return s
}

func (s *DescribeDomainsResponseBodyDomainsDomain) SetCreateTime(v string) *DescribeDomainsResponseBodyDomainsDomain {
	s.CreateTime = &v
	return s
}

func (s *DescribeDomainsResponseBodyDomainsDomain) SetCreateTimestamp(v int64) *DescribeDomainsResponseBodyDomainsDomain {
	s.CreateTimestamp = &v
	return s
}

func (s *DescribeDomainsResponseBodyDomainsDomain) SetDnsServers(v *DescribeDomainsResponseBodyDomainsDomainDnsServers) *DescribeDomainsResponseBodyDomainsDomain {
	s.DnsServers = v
	return s
}

func (s *DescribeDomainsResponseBodyDomainsDomain) SetDomainId(v string) *DescribeDomainsResponseBodyDomainsDomain {
	s.DomainId = &v
	return s
}

func (s *DescribeDomainsResponseBodyDomainsDomain) SetDomainName(v string) *DescribeDomainsResponseBodyDomainsDomain {
	s.DomainName = &v
	return s
}

func (s *DescribeDomainsResponseBodyDomainsDomain) SetGroupId(v string) *DescribeDomainsResponseBodyDomainsDomain {
	s.GroupId = &v
	return s
}

func (s *DescribeDomainsResponseBodyDomainsDomain) SetGroupName(v string) *DescribeDomainsResponseBodyDomainsDomain {
	s.GroupName = &v
	return s
}

func (s *DescribeDomainsResponseBodyDomainsDomain) SetInstanceEndTime(v string) *DescribeDomainsResponseBodyDomainsDomain {
	s.InstanceEndTime = &v
	return s
}

func (s *DescribeDomainsResponseBodyDomainsDomain) SetInstanceExpired(v bool) *DescribeDomainsResponseBodyDomainsDomain {
	s.InstanceExpired = &v
	return s
}

func (s *DescribeDomainsResponseBodyDomainsDomain) SetInstanceId(v string) *DescribeDomainsResponseBodyDomainsDomain {
	s.InstanceId = &v
	return s
}

func (s *DescribeDomainsResponseBodyDomainsDomain) SetPunyCode(v string) *DescribeDomainsResponseBodyDomainsDomain {
	s.PunyCode = &v
	return s
}

func (s *DescribeDomainsResponseBodyDomainsDomain) SetRecordCount(v int64) *DescribeDomainsResponseBodyDomainsDomain {
	s.RecordCount = &v
	return s
}

func (s *DescribeDomainsResponseBodyDomainsDomain) SetRegistrantEmail(v string) *DescribeDomainsResponseBodyDomainsDomain {
	s.RegistrantEmail = &v
	return s
}

func (s *DescribeDomainsResponseBodyDomainsDomain) SetRemark(v string) *DescribeDomainsResponseBodyDomainsDomain {
	s.Remark = &v
	return s
}

func (s *DescribeDomainsResponseBodyDomainsDomain) SetResourceGroupId(v string) *DescribeDomainsResponseBodyDomainsDomain {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDomainsResponseBodyDomainsDomain) SetStarmark(v bool) *DescribeDomainsResponseBodyDomainsDomain {
	s.Starmark = &v
	return s
}

func (s *DescribeDomainsResponseBodyDomainsDomain) SetTags(v *DescribeDomainsResponseBodyDomainsDomainTags) *DescribeDomainsResponseBodyDomainsDomain {
	s.Tags = v
	return s
}

func (s *DescribeDomainsResponseBodyDomainsDomain) SetVersionCode(v string) *DescribeDomainsResponseBodyDomainsDomain {
	s.VersionCode = &v
	return s
}

func (s *DescribeDomainsResponseBodyDomainsDomain) SetVersionName(v string) *DescribeDomainsResponseBodyDomainsDomain {
	s.VersionName = &v
	return s
}

type DescribeDomainsResponseBodyDomainsDomainDnsServers struct {
	DnsServer []*string `json:"DnsServer,omitempty" xml:"DnsServer,omitempty" type:"Repeated"`
}

func (s DescribeDomainsResponseBodyDomainsDomainDnsServers) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsResponseBodyDomainsDomainDnsServers) GoString() string {
	return s.String()
}

func (s *DescribeDomainsResponseBodyDomainsDomainDnsServers) SetDnsServer(v []*string) *DescribeDomainsResponseBodyDomainsDomainDnsServers {
	s.DnsServer = v
	return s
}

type DescribeDomainsResponseBodyDomainsDomainTags struct {
	Tag []*DescribeDomainsResponseBodyDomainsDomainTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeDomainsResponseBodyDomainsDomainTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsResponseBodyDomainsDomainTags) GoString() string {
	return s.String()
}

func (s *DescribeDomainsResponseBodyDomainsDomainTags) SetTag(v []*DescribeDomainsResponseBodyDomainsDomainTagsTag) *DescribeDomainsResponseBodyDomainsDomainTags {
	s.Tag = v
	return s
}

type DescribeDomainsResponseBodyDomainsDomainTagsTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDomainsResponseBodyDomainsDomainTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsResponseBodyDomainsDomainTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeDomainsResponseBodyDomainsDomainTagsTag) SetKey(v string) *DescribeDomainsResponseBodyDomainsDomainTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeDomainsResponseBodyDomainsDomainTagsTag) SetValue(v string) *DescribeDomainsResponseBodyDomainsDomainTagsTag {
	s.Value = &v
	return s
}

type DescribeDomainsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainsResponse) SetHeaders(v map[string]*string) *DescribeDomainsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainsResponse) SetStatusCode(v int32) *DescribeDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainsResponse) SetBody(v *DescribeDomainsResponseBody) *DescribeDomainsResponse {
	s.Body = v
	return s
}

type DescribeGtmAccessStrategiesRequest struct {
	// The ID of the GTM instance whose access policies you want to query.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The language used by the user.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeGtmAccessStrategiesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmAccessStrategiesRequest) GoString() string {
	return s.String()
}

func (s *DescribeGtmAccessStrategiesRequest) SetInstanceId(v string) *DescribeGtmAccessStrategiesRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeGtmAccessStrategiesRequest) SetLang(v string) *DescribeGtmAccessStrategiesRequest {
	s.Lang = &v
	return s
}

func (s *DescribeGtmAccessStrategiesRequest) SetPageNumber(v int32) *DescribeGtmAccessStrategiesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeGtmAccessStrategiesRequest) SetPageSize(v int32) *DescribeGtmAccessStrategiesRequest {
	s.PageSize = &v
	return s
}

type DescribeGtmAccessStrategiesResponseBody struct {
	// The number of the page returned.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned list of access policies of the GTM instance.
	Strategies *DescribeGtmAccessStrategiesResponseBodyStrategies `json:"Strategies,omitempty" xml:"Strategies,omitempty" type:"Struct"`
	// The total number of entries returned on all pages.
	TotalItems *int32 `json:"TotalItems,omitempty" xml:"TotalItems,omitempty"`
	// The total number of pages returned.
	TotalPages *int32 `json:"TotalPages,omitempty" xml:"TotalPages,omitempty"`
}

func (s DescribeGtmAccessStrategiesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmAccessStrategiesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeGtmAccessStrategiesResponseBody) SetPageNumber(v int32) *DescribeGtmAccessStrategiesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBody) SetPageSize(v int32) *DescribeGtmAccessStrategiesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBody) SetRequestId(v string) *DescribeGtmAccessStrategiesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBody) SetStrategies(v *DescribeGtmAccessStrategiesResponseBodyStrategies) *DescribeGtmAccessStrategiesResponseBody {
	s.Strategies = v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBody) SetTotalItems(v int32) *DescribeGtmAccessStrategiesResponseBody {
	s.TotalItems = &v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBody) SetTotalPages(v int32) *DescribeGtmAccessStrategiesResponseBody {
	s.TotalPages = &v
	return s
}

type DescribeGtmAccessStrategiesResponseBodyStrategies struct {
	Strategy []*DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy `json:"Strategy,omitempty" xml:"Strategy,omitempty" type:"Repeated"`
}

func (s DescribeGtmAccessStrategiesResponseBodyStrategies) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmAccessStrategiesResponseBodyStrategies) GoString() string {
	return s.String()
}

func (s *DescribeGtmAccessStrategiesResponseBodyStrategies) SetStrategy(v []*DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy) *DescribeGtmAccessStrategiesResponseBodyStrategies {
	s.Strategy = v
	return s
}

type DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy struct {
	// The access policy. Valid values:
	//
	// *   **AUTO**: Automatic switch
	// *   **DEFAULT**: Default address pool
	// *   **FAILOVER**: Failover address pool
	AccessMode *string `json:"AccessMode,omitempty" xml:"AccessMode,omitempty"`
	// The access status. Valid values:
	//
	// *   **DEFAULT**: The default address pool is currently accessed.
	// *   **FAILOVER**: The failover address pool is currently accessed.
	AccessStatus *string `json:"AccessStatus,omitempty" xml:"AccessStatus,omitempty"`
	// The time when the access policy was created.
	CreateTime      *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	CreateTimestamp *int64  `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The ID of the default address pool.
	DefaultAddrPoolId *string `json:"DefaultAddrPoolId,omitempty" xml:"DefaultAddrPoolId,omitempty"`
	// Indicates whether health check was enabled for the default address pool. Valid values:
	//
	// *   **OPEN**: Enabled
	// *   **CLOSE**: Disabled
	// *   **UNCONFIGURED**: Not configured
	DefaultAddrPoolMonitorStatus *string `json:"DefaultAddrPoolMonitorStatus,omitempty" xml:"DefaultAddrPoolMonitorStatus,omitempty"`
	// The name of the default address pool.
	DefaultAddrPoolName *string `json:"DefaultAddrPoolName,omitempty" xml:"DefaultAddrPoolName,omitempty"`
	// The availability status of the default address pool. Valid values:
	//
	// *   **AVAILABLE**: Available
	// *   **NOT_AVAILABLE**: Unavailable
	DefaultAddrPoolStatus *string `json:"DefaultAddrPoolStatus,omitempty" xml:"DefaultAddrPoolStatus,omitempty"`
	// The ID of the failover address pool.
	FailoverAddrPoolId *string `json:"FailoverAddrPoolId,omitempty" xml:"FailoverAddrPoolId,omitempty"`
	// Indicates whether health check was enabled for the failover address pool.
	FailoverAddrPoolMonitorStatus *string `json:"FailoverAddrPoolMonitorStatus,omitempty" xml:"FailoverAddrPoolMonitorStatus,omitempty"`
	// The name of the failover address pool.
	FailoverAddrPoolName *string `json:"FailoverAddrPoolName,omitempty" xml:"FailoverAddrPoolName,omitempty"`
	// The availability status of the failover address pool.
	FailoverAddrPoolStatus *string `json:"FailoverAddrPoolStatus,omitempty" xml:"FailoverAddrPoolStatus,omitempty"`
	// The ID of the GTM instance whose access policies you want to query.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The returned lines of access regions.
	Lines *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLines `json:"Lines,omitempty" xml:"Lines,omitempty" type:"Struct"`
	// The ID of the access policy.
	StrategyId *string `json:"StrategyId,omitempty" xml:"StrategyId,omitempty"`
	// The mode of the access policy. **SELF_DEFINED** indicates that the access policy is user-defined.
	StrategyMode *string `json:"StrategyMode,omitempty" xml:"StrategyMode,omitempty"`
	// The name of the access policy.
	StrategyName *string `json:"StrategyName,omitempty" xml:"StrategyName,omitempty"`
}

func (s DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy) GoString() string {
	return s.String()
}

func (s *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy) SetAccessMode(v string) *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.AccessMode = &v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy) SetAccessStatus(v string) *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.AccessStatus = &v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy) SetCreateTime(v string) *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.CreateTime = &v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy) SetCreateTimestamp(v int64) *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.CreateTimestamp = &v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy) SetDefaultAddrPoolId(v string) *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.DefaultAddrPoolId = &v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy) SetDefaultAddrPoolMonitorStatus(v string) *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.DefaultAddrPoolMonitorStatus = &v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy) SetDefaultAddrPoolName(v string) *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.DefaultAddrPoolName = &v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy) SetDefaultAddrPoolStatus(v string) *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.DefaultAddrPoolStatus = &v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy) SetFailoverAddrPoolId(v string) *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.FailoverAddrPoolId = &v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy) SetFailoverAddrPoolMonitorStatus(v string) *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.FailoverAddrPoolMonitorStatus = &v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy) SetFailoverAddrPoolName(v string) *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.FailoverAddrPoolName = &v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy) SetFailoverAddrPoolStatus(v string) *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.FailoverAddrPoolStatus = &v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy) SetInstanceId(v string) *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.InstanceId = &v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy) SetLines(v *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLines) *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.Lines = v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy) SetStrategyId(v string) *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.StrategyId = &v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy) SetStrategyMode(v string) *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.StrategyMode = &v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy) SetStrategyName(v string) *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategy {
	s.StrategyName = &v
	return s
}

type DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLines struct {
	Line []*DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine `json:"Line,omitempty" xml:"Line,omitempty" type:"Repeated"`
}

func (s DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLines) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLines) GoString() string {
	return s.String()
}

func (s *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLines) SetLine(v []*DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine) *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLines {
	s.Line = v
	return s
}

type DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine struct {
	// The code of the access region group.
	GroupCode *string `json:"GroupCode,omitempty" xml:"GroupCode,omitempty"`
	// The name of the access region group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The code for the line of the access region.
	LineCode *string `json:"LineCode,omitempty" xml:"LineCode,omitempty"`
	// The name for the line of the access region.
	LineName *string `json:"LineName,omitempty" xml:"LineName,omitempty"`
}

func (s DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine) GoString() string {
	return s.String()
}

func (s *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine) SetGroupCode(v string) *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine {
	s.GroupCode = &v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine) SetGroupName(v string) *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine {
	s.GroupName = &v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine) SetLineCode(v string) *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine {
	s.LineCode = &v
	return s
}

func (s *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine) SetLineName(v string) *DescribeGtmAccessStrategiesResponseBodyStrategiesStrategyLinesLine {
	s.LineName = &v
	return s
}

type DescribeGtmAccessStrategiesResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeGtmAccessStrategiesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeGtmAccessStrategiesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmAccessStrategiesResponse) GoString() string {
	return s.String()
}

func (s *DescribeGtmAccessStrategiesResponse) SetHeaders(v map[string]*string) *DescribeGtmAccessStrategiesResponse {
	s.Headers = v
	return s
}

func (s *DescribeGtmAccessStrategiesResponse) SetStatusCode(v int32) *DescribeGtmAccessStrategiesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeGtmAccessStrategiesResponse) SetBody(v *DescribeGtmAccessStrategiesResponseBody) *DescribeGtmAccessStrategiesResponse {
	s.Body = v
	return s
}

type DescribeGtmAccessStrategyRequest struct {
	// The language used by the user.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the access policy that you want to query.
	StrategyId *string `json:"StrategyId,omitempty" xml:"StrategyId,omitempty"`
}

func (s DescribeGtmAccessStrategyRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmAccessStrategyRequest) GoString() string {
	return s.String()
}

func (s *DescribeGtmAccessStrategyRequest) SetLang(v string) *DescribeGtmAccessStrategyRequest {
	s.Lang = &v
	return s
}

func (s *DescribeGtmAccessStrategyRequest) SetStrategyId(v string) *DescribeGtmAccessStrategyRequest {
	s.StrategyId = &v
	return s
}

type DescribeGtmAccessStrategyResponseBody struct {
	// The access policy.
	AccessMode *string `json:"AccessMode,omitempty" xml:"AccessMode,omitempty"`
	// The access status. Valid values:
	//
	// *   **DEFAULT**: Indicates normal when the default address pool is accessed.
	// *   **FAILOVER**: Indicates an exception when a failover address pool is accessed.
	AccessStatus *string `json:"AccessStatus,omitempty" xml:"AccessStatus,omitempty"`
	// Indicates whether health check is enabled for the default address pool.
	DefaultAddrPoolMonitorStatus *string `json:"DefaultAddrPoolMonitorStatus,omitempty" xml:"DefaultAddrPoolMonitorStatus,omitempty"`
	// The name of the default address pool.
	DefaultAddrPoolName *string `json:"DefaultAddrPoolName,omitempty" xml:"DefaultAddrPoolName,omitempty"`
	// The availability status of the default address pool.
	DefaultAddrPoolStatus *string `json:"DefaultAddrPoolStatus,omitempty" xml:"DefaultAddrPoolStatus,omitempty"`
	// The ID of the default address pool.
	DefultAddrPoolId *string `json:"DefultAddrPoolId,omitempty" xml:"DefultAddrPoolId,omitempty"`
	// The ID of the failover address pool.
	FailoverAddrPoolId *string `json:"FailoverAddrPoolId,omitempty" xml:"FailoverAddrPoolId,omitempty"`
	// Indicates whether health check is enabled for the failover address pool.
	FailoverAddrPoolMonitorStatus *string `json:"FailoverAddrPoolMonitorStatus,omitempty" xml:"FailoverAddrPoolMonitorStatus,omitempty"`
	// The name of the failover address pool.
	FailoverAddrPoolName *string `json:"FailoverAddrPoolName,omitempty" xml:"FailoverAddrPoolName,omitempty"`
	// The availability status of the failover address pool.
	FailoverAddrPoolStatus *string `json:"FailoverAddrPoolStatus,omitempty" xml:"FailoverAddrPoolStatus,omitempty"`
	// The ID of the GTM instance whose access policy details you want to query.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The returned lines of access regions.
	Lines *DescribeGtmAccessStrategyResponseBodyLines `json:"Lines,omitempty" xml:"Lines,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the access policy queried.
	StrategyId *string `json:"StrategyId,omitempty" xml:"StrategyId,omitempty"`
	// The mode of traffic scheduling.
	StrategyMode *string `json:"StrategyMode,omitempty" xml:"StrategyMode,omitempty"`
	// The name of the access policy queried.
	StrategyName *string `json:"StrategyName,omitempty" xml:"StrategyName,omitempty"`
}

func (s DescribeGtmAccessStrategyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmAccessStrategyResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeGtmAccessStrategyResponseBody) SetAccessMode(v string) *DescribeGtmAccessStrategyResponseBody {
	s.AccessMode = &v
	return s
}

func (s *DescribeGtmAccessStrategyResponseBody) SetAccessStatus(v string) *DescribeGtmAccessStrategyResponseBody {
	s.AccessStatus = &v
	return s
}

func (s *DescribeGtmAccessStrategyResponseBody) SetDefaultAddrPoolMonitorStatus(v string) *DescribeGtmAccessStrategyResponseBody {
	s.DefaultAddrPoolMonitorStatus = &v
	return s
}

func (s *DescribeGtmAccessStrategyResponseBody) SetDefaultAddrPoolName(v string) *DescribeGtmAccessStrategyResponseBody {
	s.DefaultAddrPoolName = &v
	return s
}

func (s *DescribeGtmAccessStrategyResponseBody) SetDefaultAddrPoolStatus(v string) *DescribeGtmAccessStrategyResponseBody {
	s.DefaultAddrPoolStatus = &v
	return s
}

func (s *DescribeGtmAccessStrategyResponseBody) SetDefultAddrPoolId(v string) *DescribeGtmAccessStrategyResponseBody {
	s.DefultAddrPoolId = &v
	return s
}

func (s *DescribeGtmAccessStrategyResponseBody) SetFailoverAddrPoolId(v string) *DescribeGtmAccessStrategyResponseBody {
	s.FailoverAddrPoolId = &v
	return s
}

func (s *DescribeGtmAccessStrategyResponseBody) SetFailoverAddrPoolMonitorStatus(v string) *DescribeGtmAccessStrategyResponseBody {
	s.FailoverAddrPoolMonitorStatus = &v
	return s
}

func (s *DescribeGtmAccessStrategyResponseBody) SetFailoverAddrPoolName(v string) *DescribeGtmAccessStrategyResponseBody {
	s.FailoverAddrPoolName = &v
	return s
}

func (s *DescribeGtmAccessStrategyResponseBody) SetFailoverAddrPoolStatus(v string) *DescribeGtmAccessStrategyResponseBody {
	s.FailoverAddrPoolStatus = &v
	return s
}

func (s *DescribeGtmAccessStrategyResponseBody) SetInstanceId(v string) *DescribeGtmAccessStrategyResponseBody {
	s.InstanceId = &v
	return s
}

func (s *DescribeGtmAccessStrategyResponseBody) SetLines(v *DescribeGtmAccessStrategyResponseBodyLines) *DescribeGtmAccessStrategyResponseBody {
	s.Lines = v
	return s
}

func (s *DescribeGtmAccessStrategyResponseBody) SetRequestId(v string) *DescribeGtmAccessStrategyResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeGtmAccessStrategyResponseBody) SetStrategyId(v string) *DescribeGtmAccessStrategyResponseBody {
	s.StrategyId = &v
	return s
}

func (s *DescribeGtmAccessStrategyResponseBody) SetStrategyMode(v string) *DescribeGtmAccessStrategyResponseBody {
	s.StrategyMode = &v
	return s
}

func (s *DescribeGtmAccessStrategyResponseBody) SetStrategyName(v string) *DescribeGtmAccessStrategyResponseBody {
	s.StrategyName = &v
	return s
}

type DescribeGtmAccessStrategyResponseBodyLines struct {
	Line []*DescribeGtmAccessStrategyResponseBodyLinesLine `json:"Line,omitempty" xml:"Line,omitempty" type:"Repeated"`
}

func (s DescribeGtmAccessStrategyResponseBodyLines) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmAccessStrategyResponseBodyLines) GoString() string {
	return s.String()
}

func (s *DescribeGtmAccessStrategyResponseBodyLines) SetLine(v []*DescribeGtmAccessStrategyResponseBodyLinesLine) *DescribeGtmAccessStrategyResponseBodyLines {
	s.Line = v
	return s
}

type DescribeGtmAccessStrategyResponseBodyLinesLine struct {
	// The code of the access region group.
	GroupCode *string `json:"GroupCode,omitempty" xml:"GroupCode,omitempty"`
	// The name of the access region group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The code for the line of the access region.
	LineCode *string `json:"LineCode,omitempty" xml:"LineCode,omitempty"`
	// The name for the line of the access region.
	LineName *string `json:"LineName,omitempty" xml:"LineName,omitempty"`
}

func (s DescribeGtmAccessStrategyResponseBodyLinesLine) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmAccessStrategyResponseBodyLinesLine) GoString() string {
	return s.String()
}

func (s *DescribeGtmAccessStrategyResponseBodyLinesLine) SetGroupCode(v string) *DescribeGtmAccessStrategyResponseBodyLinesLine {
	s.GroupCode = &v
	return s
}

func (s *DescribeGtmAccessStrategyResponseBodyLinesLine) SetGroupName(v string) *DescribeGtmAccessStrategyResponseBodyLinesLine {
	s.GroupName = &v
	return s
}

func (s *DescribeGtmAccessStrategyResponseBodyLinesLine) SetLineCode(v string) *DescribeGtmAccessStrategyResponseBodyLinesLine {
	s.LineCode = &v
	return s
}

func (s *DescribeGtmAccessStrategyResponseBodyLinesLine) SetLineName(v string) *DescribeGtmAccessStrategyResponseBodyLinesLine {
	s.LineName = &v
	return s
}

type DescribeGtmAccessStrategyResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeGtmAccessStrategyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeGtmAccessStrategyResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmAccessStrategyResponse) GoString() string {
	return s.String()
}

func (s *DescribeGtmAccessStrategyResponse) SetHeaders(v map[string]*string) *DescribeGtmAccessStrategyResponse {
	s.Headers = v
	return s
}

func (s *DescribeGtmAccessStrategyResponse) SetStatusCode(v int32) *DescribeGtmAccessStrategyResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeGtmAccessStrategyResponse) SetBody(v *DescribeGtmAccessStrategyResponseBody) *DescribeGtmAccessStrategyResponse {
	s.Body = v
	return s
}

type DescribeGtmAccessStrategyAvailableConfigRequest struct {
	// The ID of the GTM instance for which you want to query the available configurations of the current access policy.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The language used by the user.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DescribeGtmAccessStrategyAvailableConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmAccessStrategyAvailableConfigRequest) GoString() string {
	return s.String()
}

func (s *DescribeGtmAccessStrategyAvailableConfigRequest) SetInstanceId(v string) *DescribeGtmAccessStrategyAvailableConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeGtmAccessStrategyAvailableConfigRequest) SetLang(v string) *DescribeGtmAccessStrategyAvailableConfigRequest {
	s.Lang = &v
	return s
}

type DescribeGtmAccessStrategyAvailableConfigResponseBody struct {
	// The returned list of address pools.
	AddrPools *DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPools `json:"AddrPools,omitempty" xml:"AddrPools,omitempty" type:"Struct"`
	// The returned lines of access regions.
	Lines *DescribeGtmAccessStrategyAvailableConfigResponseBodyLines `json:"Lines,omitempty" xml:"Lines,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId             *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	SuggestSetDefaultLine *bool   `json:"SuggestSetDefaultLine,omitempty" xml:"SuggestSetDefaultLine,omitempty"`
}

func (s DescribeGtmAccessStrategyAvailableConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmAccessStrategyAvailableConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeGtmAccessStrategyAvailableConfigResponseBody) SetAddrPools(v *DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPools) *DescribeGtmAccessStrategyAvailableConfigResponseBody {
	s.AddrPools = v
	return s
}

func (s *DescribeGtmAccessStrategyAvailableConfigResponseBody) SetLines(v *DescribeGtmAccessStrategyAvailableConfigResponseBodyLines) *DescribeGtmAccessStrategyAvailableConfigResponseBody {
	s.Lines = v
	return s
}

func (s *DescribeGtmAccessStrategyAvailableConfigResponseBody) SetRequestId(v string) *DescribeGtmAccessStrategyAvailableConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeGtmAccessStrategyAvailableConfigResponseBody) SetSuggestSetDefaultLine(v bool) *DescribeGtmAccessStrategyAvailableConfigResponseBody {
	s.SuggestSetDefaultLine = &v
	return s
}

type DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPools struct {
	AddrPool []*DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPoolsAddrPool `json:"AddrPool,omitempty" xml:"AddrPool,omitempty" type:"Repeated"`
}

func (s DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPools) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPools) GoString() string {
	return s.String()
}

func (s *DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPools) SetAddrPool(v []*DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPoolsAddrPool) *DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPools {
	s.AddrPool = v
	return s
}

type DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPoolsAddrPool struct {
	// The ID of the address pool.
	AddrPoolId *string `json:"AddrPoolId,omitempty" xml:"AddrPoolId,omitempty"`
	// The name of the address pool.
	AddrPoolName *string `json:"AddrPoolName,omitempty" xml:"AddrPoolName,omitempty"`
}

func (s DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPoolsAddrPool) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPoolsAddrPool) GoString() string {
	return s.String()
}

func (s *DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPoolsAddrPool) SetAddrPoolId(v string) *DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPoolsAddrPool {
	s.AddrPoolId = &v
	return s
}

func (s *DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPoolsAddrPool) SetAddrPoolName(v string) *DescribeGtmAccessStrategyAvailableConfigResponseBodyAddrPoolsAddrPool {
	s.AddrPoolName = &v
	return s
}

type DescribeGtmAccessStrategyAvailableConfigResponseBodyLines struct {
	Line []*DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine `json:"Line,omitempty" xml:"Line,omitempty" type:"Repeated"`
}

func (s DescribeGtmAccessStrategyAvailableConfigResponseBodyLines) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmAccessStrategyAvailableConfigResponseBodyLines) GoString() string {
	return s.String()
}

func (s *DescribeGtmAccessStrategyAvailableConfigResponseBodyLines) SetLine(v []*DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine) *DescribeGtmAccessStrategyAvailableConfigResponseBodyLines {
	s.Line = v
	return s
}

type DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine struct {
	// The code of the parent line for the access region. If no parent line exists, leave this parameter blank.
	FatherCode *string `json:"FatherCode,omitempty" xml:"FatherCode,omitempty"`
	// The code of the access region group.
	GroupCode *string `json:"GroupCode,omitempty" xml:"GroupCode,omitempty"`
	// The name of the access region group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The code for the line of the access region.
	LineCode *string `json:"LineCode,omitempty" xml:"LineCode,omitempty"`
	// The name for the line of the access region.
	LineName *string `json:"LineName,omitempty" xml:"LineName,omitempty"`
	// The current status of the line. Valid values:
	//
	// - **FORBIDDEN**: Unavailable
	// - **OPTIONAL**: Availabe
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine) GoString() string {
	return s.String()
}

func (s *DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine) SetFatherCode(v string) *DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine {
	s.FatherCode = &v
	return s
}

func (s *DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine) SetGroupCode(v string) *DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine {
	s.GroupCode = &v
	return s
}

func (s *DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine) SetGroupName(v string) *DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine {
	s.GroupName = &v
	return s
}

func (s *DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine) SetLineCode(v string) *DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine {
	s.LineCode = &v
	return s
}

func (s *DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine) SetLineName(v string) *DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine {
	s.LineName = &v
	return s
}

func (s *DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine) SetStatus(v string) *DescribeGtmAccessStrategyAvailableConfigResponseBodyLinesLine {
	s.Status = &v
	return s
}

type DescribeGtmAccessStrategyAvailableConfigResponse struct {
	Headers    map[string]*string                                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeGtmAccessStrategyAvailableConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeGtmAccessStrategyAvailableConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmAccessStrategyAvailableConfigResponse) GoString() string {
	return s.String()
}

func (s *DescribeGtmAccessStrategyAvailableConfigResponse) SetHeaders(v map[string]*string) *DescribeGtmAccessStrategyAvailableConfigResponse {
	s.Headers = v
	return s
}

func (s *DescribeGtmAccessStrategyAvailableConfigResponse) SetStatusCode(v int32) *DescribeGtmAccessStrategyAvailableConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeGtmAccessStrategyAvailableConfigResponse) SetBody(v *DescribeGtmAccessStrategyAvailableConfigResponseBody) *DescribeGtmAccessStrategyAvailableConfigResponse {
	s.Body = v
	return s
}

type DescribeGtmAvailableAlertGroupRequest struct {
	// The language used by the user.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DescribeGtmAvailableAlertGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmAvailableAlertGroupRequest) GoString() string {
	return s.String()
}

func (s *DescribeGtmAvailableAlertGroupRequest) SetLang(v string) *DescribeGtmAvailableAlertGroupRequest {
	s.Lang = &v
	return s
}

type DescribeGtmAvailableAlertGroupResponseBody struct {
	// The available alert groups of the GTM instance.
	AvailableAlertGroup *string `json:"AvailableAlertGroup,omitempty" xml:"AvailableAlertGroup,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeGtmAvailableAlertGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmAvailableAlertGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeGtmAvailableAlertGroupResponseBody) SetAvailableAlertGroup(v string) *DescribeGtmAvailableAlertGroupResponseBody {
	s.AvailableAlertGroup = &v
	return s
}

func (s *DescribeGtmAvailableAlertGroupResponseBody) SetRequestId(v string) *DescribeGtmAvailableAlertGroupResponseBody {
	s.RequestId = &v
	return s
}

type DescribeGtmAvailableAlertGroupResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeGtmAvailableAlertGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeGtmAvailableAlertGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmAvailableAlertGroupResponse) GoString() string {
	return s.String()
}

func (s *DescribeGtmAvailableAlertGroupResponse) SetHeaders(v map[string]*string) *DescribeGtmAvailableAlertGroupResponse {
	s.Headers = v
	return s
}

func (s *DescribeGtmAvailableAlertGroupResponse) SetStatusCode(v int32) *DescribeGtmAvailableAlertGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeGtmAvailableAlertGroupResponse) SetBody(v *DescribeGtmAvailableAlertGroupResponseBody) *DescribeGtmAvailableAlertGroupResponse {
	s.Body = v
	return s
}

type DescribeGtmInstanceRequest struct {
	// The ID of the GTM instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The language of the values of specific response parameters.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// Specifies whether additional information is required. Default value: **false**. If the value is **true**, the AccessStrategyNum and AddressPoolNum parameters are returned.
	NeedDetailAttributes *bool `json:"NeedDetailAttributes,omitempty" xml:"NeedDetailAttributes,omitempty"`
}

func (s DescribeGtmInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstanceRequest) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstanceRequest) SetInstanceId(v string) *DescribeGtmInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeGtmInstanceRequest) SetLang(v string) *DescribeGtmInstanceRequest {
	s.Lang = &v
	return s
}

func (s *DescribeGtmInstanceRequest) SetNeedDetailAttributes(v bool) *DescribeGtmInstanceRequest {
	s.NeedDetailAttributes = &v
	return s
}

type DescribeGtmInstanceResponseBody struct {
	// The number of access policies of the GTM instance.
	AccessStrategyNum *int32 `json:"AccessStrategyNum,omitempty" xml:"AccessStrategyNum,omitempty"`
	// The number of address pools of the GTM instance.
	AddressPoolNum *int32 `json:"AddressPoolNum,omitempty" xml:"AddressPoolNum,omitempty"`
	// The alert group of the GTM instance.
	AlertGroup *string `json:"AlertGroup,omitempty" xml:"AlertGroup,omitempty"`
	// The domain name of the GTM instance to which the service domain name is mapped by using a CNAME record.
	Cname *string `json:"Cname,omitempty" xml:"Cname,omitempty"`
	// Indicates whether the CNAME is a custom domain name or is assigned by the system. Valid values:
	//
	// *   **SYSTEM_ASSIGN**
	// *   **CUSTOM**
	CnameMode *string `json:"CnameMode,omitempty" xml:"CnameMode,omitempty"`
	// The time when the GTM instance was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The timestamp that indicates the time when the GTM instance was created.
	CreateTimestamp *int64 `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The time when the GTM instance expires.
	ExpireTime *string `json:"ExpireTime,omitempty" xml:"ExpireTime,omitempty"`
	// The timestamp that indicates the time when the GTM instance expires.
	ExpireTimestamp *int64 `json:"ExpireTimestamp,omitempty" xml:"ExpireTimestamp,omitempty"`
	// The ID of the GTM instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the GTM instance.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The load balancing policy. Valid values:
	//
	// *   **ALL_RR**: round robin
	// *   **RATIO**: weighted round-robin
	LbaStrategy *string `json:"LbaStrategy,omitempty" xml:"LbaStrategy,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The global time to live (TTL).
	Ttl *int32 `json:"Ttl,omitempty" xml:"Ttl,omitempty"`
	// The domain name of the application.
	UserDomainName *string `json:"UserDomainName,omitempty" xml:"UserDomainName,omitempty"`
	// The version code.
	VersionCode *string `json:"VersionCode,omitempty" xml:"VersionCode,omitempty"`
}

func (s DescribeGtmInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstanceResponseBody) SetAccessStrategyNum(v int32) *DescribeGtmInstanceResponseBody {
	s.AccessStrategyNum = &v
	return s
}

func (s *DescribeGtmInstanceResponseBody) SetAddressPoolNum(v int32) *DescribeGtmInstanceResponseBody {
	s.AddressPoolNum = &v
	return s
}

func (s *DescribeGtmInstanceResponseBody) SetAlertGroup(v string) *DescribeGtmInstanceResponseBody {
	s.AlertGroup = &v
	return s
}

func (s *DescribeGtmInstanceResponseBody) SetCname(v string) *DescribeGtmInstanceResponseBody {
	s.Cname = &v
	return s
}

func (s *DescribeGtmInstanceResponseBody) SetCnameMode(v string) *DescribeGtmInstanceResponseBody {
	s.CnameMode = &v
	return s
}

func (s *DescribeGtmInstanceResponseBody) SetCreateTime(v string) *DescribeGtmInstanceResponseBody {
	s.CreateTime = &v
	return s
}

func (s *DescribeGtmInstanceResponseBody) SetCreateTimestamp(v int64) *DescribeGtmInstanceResponseBody {
	s.CreateTimestamp = &v
	return s
}

func (s *DescribeGtmInstanceResponseBody) SetExpireTime(v string) *DescribeGtmInstanceResponseBody {
	s.ExpireTime = &v
	return s
}

func (s *DescribeGtmInstanceResponseBody) SetExpireTimestamp(v int64) *DescribeGtmInstanceResponseBody {
	s.ExpireTimestamp = &v
	return s
}

func (s *DescribeGtmInstanceResponseBody) SetInstanceId(v string) *DescribeGtmInstanceResponseBody {
	s.InstanceId = &v
	return s
}

func (s *DescribeGtmInstanceResponseBody) SetInstanceName(v string) *DescribeGtmInstanceResponseBody {
	s.InstanceName = &v
	return s
}

func (s *DescribeGtmInstanceResponseBody) SetLbaStrategy(v string) *DescribeGtmInstanceResponseBody {
	s.LbaStrategy = &v
	return s
}

func (s *DescribeGtmInstanceResponseBody) SetRequestId(v string) *DescribeGtmInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeGtmInstanceResponseBody) SetResourceGroupId(v string) *DescribeGtmInstanceResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeGtmInstanceResponseBody) SetTtl(v int32) *DescribeGtmInstanceResponseBody {
	s.Ttl = &v
	return s
}

func (s *DescribeGtmInstanceResponseBody) SetUserDomainName(v string) *DescribeGtmInstanceResponseBody {
	s.UserDomainName = &v
	return s
}

func (s *DescribeGtmInstanceResponseBody) SetVersionCode(v string) *DescribeGtmInstanceResponseBody {
	s.VersionCode = &v
	return s
}

type DescribeGtmInstanceResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeGtmInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeGtmInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstanceResponse) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstanceResponse) SetHeaders(v map[string]*string) *DescribeGtmInstanceResponse {
	s.Headers = v
	return s
}

func (s *DescribeGtmInstanceResponse) SetStatusCode(v int32) *DescribeGtmInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeGtmInstanceResponse) SetBody(v *DescribeGtmInstanceResponseBody) *DescribeGtmInstanceResponse {
	s.Body = v
	return s
}

type DescribeGtmInstanceAddressPoolRequest struct {
	// The ID of the address pool that you want to query.
	AddrPoolId *string `json:"AddrPoolId,omitempty" xml:"AddrPoolId,omitempty"`
	// The language used by the user.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DescribeGtmInstanceAddressPoolRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstanceAddressPoolRequest) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstanceAddressPoolRequest) SetAddrPoolId(v string) *DescribeGtmInstanceAddressPoolRequest {
	s.AddrPoolId = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolRequest) SetLang(v string) *DescribeGtmInstanceAddressPoolRequest {
	s.Lang = &v
	return s
}

type DescribeGtmInstanceAddressPoolResponseBody struct {
	// The number of addresses in the address pool queried.
	AddrCount *int32 `json:"AddrCount,omitempty" xml:"AddrCount,omitempty"`
	// The ID of the address pool.
	AddrPoolId *string `json:"AddrPoolId,omitempty" xml:"AddrPoolId,omitempty"`
	// The addresses in the address pool.
	Addrs *DescribeGtmInstanceAddressPoolResponseBodyAddrs `json:"Addrs,omitempty" xml:"Addrs,omitempty" type:"Struct"`
	// The time when the address pool was created.
	CreateTime      *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	CreateTimestamp *int64  `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The minimum number of available addresses in the address pool.
	MinAvailableAddrNum *int32 `json:"MinAvailableAddrNum,omitempty" xml:"MinAvailableAddrNum,omitempty"`
	// The health check ID of the address pool.
	MonitorConfigId *string `json:"MonitorConfigId,omitempty" xml:"MonitorConfigId,omitempty"`
	// Indicates whether health check was enabled for the address pool. Valid values:
	//
	// *   **OPEN**: Enabled
	// *   **CLOSE**: Disabled
	// *   **UNCONFIGURED**: Not configured
	MonitorStatus *string `json:"MonitorStatus,omitempty" xml:"MonitorStatus,omitempty"`
	// The name of the address pool.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The availability status of the address pool. Valid values:
	//
	// *   **AVAILABLE**: Available
	// *   **NOT_AVAILABLE**: Unavailable
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the address pool. Valid values:
	//
	// *   **IP**: IP address
	// *   **DOMAIN**: Domain name
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The last time when the address pool was updated.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// A timestamp that indicates the last time the address pool was updated.
	UpdateTimestamp *int64 `json:"UpdateTimestamp,omitempty" xml:"UpdateTimestamp,omitempty"`
}

func (s DescribeGtmInstanceAddressPoolResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstanceAddressPoolResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstanceAddressPoolResponseBody) SetAddrCount(v int32) *DescribeGtmInstanceAddressPoolResponseBody {
	s.AddrCount = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolResponseBody) SetAddrPoolId(v string) *DescribeGtmInstanceAddressPoolResponseBody {
	s.AddrPoolId = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolResponseBody) SetAddrs(v *DescribeGtmInstanceAddressPoolResponseBodyAddrs) *DescribeGtmInstanceAddressPoolResponseBody {
	s.Addrs = v
	return s
}

func (s *DescribeGtmInstanceAddressPoolResponseBody) SetCreateTime(v string) *DescribeGtmInstanceAddressPoolResponseBody {
	s.CreateTime = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolResponseBody) SetCreateTimestamp(v int64) *DescribeGtmInstanceAddressPoolResponseBody {
	s.CreateTimestamp = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolResponseBody) SetMinAvailableAddrNum(v int32) *DescribeGtmInstanceAddressPoolResponseBody {
	s.MinAvailableAddrNum = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolResponseBody) SetMonitorConfigId(v string) *DescribeGtmInstanceAddressPoolResponseBody {
	s.MonitorConfigId = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolResponseBody) SetMonitorStatus(v string) *DescribeGtmInstanceAddressPoolResponseBody {
	s.MonitorStatus = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolResponseBody) SetName(v string) *DescribeGtmInstanceAddressPoolResponseBody {
	s.Name = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolResponseBody) SetRequestId(v string) *DescribeGtmInstanceAddressPoolResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolResponseBody) SetStatus(v string) *DescribeGtmInstanceAddressPoolResponseBody {
	s.Status = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolResponseBody) SetType(v string) *DescribeGtmInstanceAddressPoolResponseBody {
	s.Type = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolResponseBody) SetUpdateTime(v string) *DescribeGtmInstanceAddressPoolResponseBody {
	s.UpdateTime = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolResponseBody) SetUpdateTimestamp(v int64) *DescribeGtmInstanceAddressPoolResponseBody {
	s.UpdateTimestamp = &v
	return s
}

type DescribeGtmInstanceAddressPoolResponseBodyAddrs struct {
	Addr []*DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr `json:"Addr,omitempty" xml:"Addr,omitempty" type:"Repeated"`
}

func (s DescribeGtmInstanceAddressPoolResponseBodyAddrs) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstanceAddressPoolResponseBodyAddrs) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstanceAddressPoolResponseBodyAddrs) SetAddr(v []*DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr) *DescribeGtmInstanceAddressPoolResponseBodyAddrs {
	s.Addr = v
	return s
}

type DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr struct {
	// The ID of the address.
	AddrId *int64 `json:"AddrId,omitempty" xml:"AddrId,omitempty"`
	// Indicates whether health check was enabled for the address. Valid values:
	//
	// *   **OK**: Normal
	// *   **ALERT**: Alert
	AlertStatus *string `json:"AlertStatus,omitempty" xml:"AlertStatus,omitempty"`
	// The time when the address pool was created.
	CreateTime      *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	CreateTimestamp *int64  `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The weight of the address.
	LbaWeight *int32 `json:"LbaWeight,omitempty" xml:"LbaWeight,omitempty"`
	// The mode of the address. Valid values:
	//
	// *   **SMART**: Intelligent return
	// *   **ONLINE**: Always online
	// *   **OFFLINE**: Always offline
	Mode *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The last time when the address was updated.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// A timestamp that indicates the last time when the address was updated.
	UpdateTimestamp *int64 `json:"UpdateTimestamp,omitempty" xml:"UpdateTimestamp,omitempty"`
	// The address.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr) SetAddrId(v int64) *DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr {
	s.AddrId = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr) SetAlertStatus(v string) *DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr {
	s.AlertStatus = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr) SetCreateTime(v string) *DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr {
	s.CreateTime = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr) SetCreateTimestamp(v int64) *DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr {
	s.CreateTimestamp = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr) SetLbaWeight(v int32) *DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr {
	s.LbaWeight = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr) SetMode(v string) *DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr {
	s.Mode = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr) SetUpdateTime(v string) *DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr {
	s.UpdateTime = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr) SetUpdateTimestamp(v int64) *DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr {
	s.UpdateTimestamp = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr) SetValue(v string) *DescribeGtmInstanceAddressPoolResponseBodyAddrsAddr {
	s.Value = &v
	return s
}

type DescribeGtmInstanceAddressPoolResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeGtmInstanceAddressPoolResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeGtmInstanceAddressPoolResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstanceAddressPoolResponse) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstanceAddressPoolResponse) SetHeaders(v map[string]*string) *DescribeGtmInstanceAddressPoolResponse {
	s.Headers = v
	return s
}

func (s *DescribeGtmInstanceAddressPoolResponse) SetStatusCode(v int32) *DescribeGtmInstanceAddressPoolResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolResponse) SetBody(v *DescribeGtmInstanceAddressPoolResponseBody) *DescribeGtmInstanceAddressPoolResponse {
	s.Body = v
	return s
}

type DescribeGtmInstanceAddressPoolsRequest struct {
	// The ID of the GTM instance that you want to query.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The language used by the user.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The number of the page to return. Pages start from page **1**. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return per page. Maximum value: **100**. Default value: **20**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeGtmInstanceAddressPoolsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstanceAddressPoolsRequest) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstanceAddressPoolsRequest) SetInstanceId(v string) *DescribeGtmInstanceAddressPoolsRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolsRequest) SetLang(v string) *DescribeGtmInstanceAddressPoolsRequest {
	s.Lang = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolsRequest) SetPageNumber(v int32) *DescribeGtmInstanceAddressPoolsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolsRequest) SetPageSize(v int32) *DescribeGtmInstanceAddressPoolsRequest {
	s.PageSize = &v
	return s
}

type DescribeGtmInstanceAddressPoolsResponseBody struct {
	// The returned list of address pools of the GTM instance.
	AddrPools *DescribeGtmInstanceAddressPoolsResponseBodyAddrPools `json:"AddrPools,omitempty" xml:"AddrPools,omitempty" type:"Struct"`
	// The number of the page returned.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned on all pages.
	TotalItems *int32 `json:"TotalItems,omitempty" xml:"TotalItems,omitempty"`
	// The total number of pages returned.
	TotalPages *int32 `json:"TotalPages,omitempty" xml:"TotalPages,omitempty"`
}

func (s DescribeGtmInstanceAddressPoolsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstanceAddressPoolsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstanceAddressPoolsResponseBody) SetAddrPools(v *DescribeGtmInstanceAddressPoolsResponseBodyAddrPools) *DescribeGtmInstanceAddressPoolsResponseBody {
	s.AddrPools = v
	return s
}

func (s *DescribeGtmInstanceAddressPoolsResponseBody) SetPageNumber(v int32) *DescribeGtmInstanceAddressPoolsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolsResponseBody) SetPageSize(v int32) *DescribeGtmInstanceAddressPoolsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolsResponseBody) SetRequestId(v string) *DescribeGtmInstanceAddressPoolsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolsResponseBody) SetTotalItems(v int32) *DescribeGtmInstanceAddressPoolsResponseBody {
	s.TotalItems = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolsResponseBody) SetTotalPages(v int32) *DescribeGtmInstanceAddressPoolsResponseBody {
	s.TotalPages = &v
	return s
}

type DescribeGtmInstanceAddressPoolsResponseBodyAddrPools struct {
	AddrPool []*DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool `json:"AddrPool,omitempty" xml:"AddrPool,omitempty" type:"Repeated"`
}

func (s DescribeGtmInstanceAddressPoolsResponseBodyAddrPools) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstanceAddressPoolsResponseBodyAddrPools) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstanceAddressPoolsResponseBodyAddrPools) SetAddrPool(v []*DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) *DescribeGtmInstanceAddressPoolsResponseBodyAddrPools {
	s.AddrPool = v
	return s
}

type DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool struct {
	// The number of addresses in the address pool.
	AddrCount *int32 `json:"AddrCount,omitempty" xml:"AddrCount,omitempty"`
	// The ID of the address pool.
	AddrPoolId *string `json:"AddrPoolId,omitempty" xml:"AddrPoolId,omitempty"`
	// The time when this address pool was created.
	CreateTime      *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	CreateTimestamp *int64  `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The minimum number of available addresses in the address pool.
	MinAvailableAddrNum *int32 `json:"MinAvailableAddrNum,omitempty" xml:"MinAvailableAddrNum,omitempty"`
	// The health check ID of the address pool.
	MonitorConfigId *string `json:"MonitorConfigId,omitempty" xml:"MonitorConfigId,omitempty"`
	// Indicates whether health check was enabled for the address pool. Valid values:
	//
	// *   **OPEN**: Enabled
	// *   **CLOSE**: Disabled
	// *   **UNCONFIGURED**: Not configured
	MonitorStatus *string `json:"MonitorStatus,omitempty" xml:"MonitorStatus,omitempty"`
	// The name of the address pool.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The availability status of the address pool. Valid values:
	//
	// *   **AVAILABLE**: Available
	// *   **NOT_AVAILABLE**: Unavailable
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the address pool. Valid values:
	//
	// *   **IP**: IP address
	// *   **DOMAIN**: Domain name
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The last time when the address pool was updated.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// A timestamp that indicates the last time the address pool was updated.
	UpdateTimestamp *int64 `json:"UpdateTimestamp,omitempty" xml:"UpdateTimestamp,omitempty"`
}

func (s DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) SetAddrCount(v int32) *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool {
	s.AddrCount = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) SetAddrPoolId(v string) *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool {
	s.AddrPoolId = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) SetCreateTime(v string) *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool {
	s.CreateTime = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) SetCreateTimestamp(v int64) *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool {
	s.CreateTimestamp = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) SetMinAvailableAddrNum(v int32) *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool {
	s.MinAvailableAddrNum = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) SetMonitorConfigId(v string) *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool {
	s.MonitorConfigId = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) SetMonitorStatus(v string) *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool {
	s.MonitorStatus = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) SetName(v string) *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool {
	s.Name = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) SetStatus(v string) *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool {
	s.Status = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) SetType(v string) *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool {
	s.Type = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) SetUpdateTime(v string) *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool {
	s.UpdateTime = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool) SetUpdateTimestamp(v int64) *DescribeGtmInstanceAddressPoolsResponseBodyAddrPoolsAddrPool {
	s.UpdateTimestamp = &v
	return s
}

type DescribeGtmInstanceAddressPoolsResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeGtmInstanceAddressPoolsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeGtmInstanceAddressPoolsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstanceAddressPoolsResponse) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstanceAddressPoolsResponse) SetHeaders(v map[string]*string) *DescribeGtmInstanceAddressPoolsResponse {
	s.Headers = v
	return s
}

func (s *DescribeGtmInstanceAddressPoolsResponse) SetStatusCode(v int32) *DescribeGtmInstanceAddressPoolsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeGtmInstanceAddressPoolsResponse) SetBody(v *DescribeGtmInstanceAddressPoolsResponseBody) *DescribeGtmInstanceAddressPoolsResponse {
	s.Body = v
	return s
}

type DescribeGtmInstanceStatusRequest struct {
	// The ID of the instance to query.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DescribeGtmInstanceStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstanceStatusRequest) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstanceStatusRequest) SetInstanceId(v string) *DescribeGtmInstanceStatusRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeGtmInstanceStatusRequest) SetLang(v string) *DescribeGtmInstanceStatusRequest {
	s.Lang = &v
	return s
}

type DescribeGtmInstanceStatusResponseBody struct {
	// The number of unavailable addresses.
	AddrNotAvailableNum *int32 `json:"AddrNotAvailableNum,omitempty" xml:"AddrNotAvailableNum,omitempty"`
	// The number of unavailable address pools.
	AddrPoolNotAvailableNum *int32 `json:"AddrPoolNotAvailableNum,omitempty" xml:"AddrPoolNotAvailableNum,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the instance. Valid values:
	//
	// *   ALLOW: Operations on the instance are allowed.
	// *   DENY: Operations on the instance are not allowed.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// List of reasons for an instance status. Valid values:
	//
	// *   INSTANCE_OPERATE_BLACK_LIST: The instance is in the blacklist.
	// *   BETA_INSTANCE: The instance is in public preview.
	StatusReason *string `json:"StatusReason,omitempty" xml:"StatusReason,omitempty"`
	// The number of access policies that are unavailable in the active address pool.
	StrategyNotAvailableNum *int32 `json:"StrategyNotAvailableNum,omitempty" xml:"StrategyNotAvailableNum,omitempty"`
	// The number of access policies that fail over to the secondary address pool.
	SwitchToFailoverStrategyNum *int32 `json:"SwitchToFailoverStrategyNum,omitempty" xml:"SwitchToFailoverStrategyNum,omitempty"`
}

func (s DescribeGtmInstanceStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstanceStatusResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstanceStatusResponseBody) SetAddrNotAvailableNum(v int32) *DescribeGtmInstanceStatusResponseBody {
	s.AddrNotAvailableNum = &v
	return s
}

func (s *DescribeGtmInstanceStatusResponseBody) SetAddrPoolNotAvailableNum(v int32) *DescribeGtmInstanceStatusResponseBody {
	s.AddrPoolNotAvailableNum = &v
	return s
}

func (s *DescribeGtmInstanceStatusResponseBody) SetRequestId(v string) *DescribeGtmInstanceStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeGtmInstanceStatusResponseBody) SetStatus(v string) *DescribeGtmInstanceStatusResponseBody {
	s.Status = &v
	return s
}

func (s *DescribeGtmInstanceStatusResponseBody) SetStatusReason(v string) *DescribeGtmInstanceStatusResponseBody {
	s.StatusReason = &v
	return s
}

func (s *DescribeGtmInstanceStatusResponseBody) SetStrategyNotAvailableNum(v int32) *DescribeGtmInstanceStatusResponseBody {
	s.StrategyNotAvailableNum = &v
	return s
}

func (s *DescribeGtmInstanceStatusResponseBody) SetSwitchToFailoverStrategyNum(v int32) *DescribeGtmInstanceStatusResponseBody {
	s.SwitchToFailoverStrategyNum = &v
	return s
}

type DescribeGtmInstanceStatusResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeGtmInstanceStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeGtmInstanceStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstanceStatusResponse) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstanceStatusResponse) SetHeaders(v map[string]*string) *DescribeGtmInstanceStatusResponse {
	s.Headers = v
	return s
}

func (s *DescribeGtmInstanceStatusResponse) SetStatusCode(v int32) *DescribeGtmInstanceStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeGtmInstanceStatusResponse) SetBody(v *DescribeGtmInstanceStatusResponseBody) *DescribeGtmInstanceStatusResponse {
	s.Body = v
	return s
}

type DescribeGtmInstanceSystemCnameRequest struct {
	// The ID of the Global Traffic Manager (GTM) instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The language used by the user.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DescribeGtmInstanceSystemCnameRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstanceSystemCnameRequest) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstanceSystemCnameRequest) SetInstanceId(v string) *DescribeGtmInstanceSystemCnameRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeGtmInstanceSystemCnameRequest) SetLang(v string) *DescribeGtmInstanceSystemCnameRequest {
	s.Lang = &v
	return s
}

type DescribeGtmInstanceSystemCnameResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The CNAME record assigned by the system.
	SystemCname *string `json:"SystemCname,omitempty" xml:"SystemCname,omitempty"`
}

func (s DescribeGtmInstanceSystemCnameResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstanceSystemCnameResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstanceSystemCnameResponseBody) SetRequestId(v string) *DescribeGtmInstanceSystemCnameResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeGtmInstanceSystemCnameResponseBody) SetSystemCname(v string) *DescribeGtmInstanceSystemCnameResponseBody {
	s.SystemCname = &v
	return s
}

type DescribeGtmInstanceSystemCnameResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeGtmInstanceSystemCnameResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeGtmInstanceSystemCnameResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstanceSystemCnameResponse) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstanceSystemCnameResponse) SetHeaders(v map[string]*string) *DescribeGtmInstanceSystemCnameResponse {
	s.Headers = v
	return s
}

func (s *DescribeGtmInstanceSystemCnameResponse) SetStatusCode(v int32) *DescribeGtmInstanceSystemCnameResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeGtmInstanceSystemCnameResponse) SetBody(v *DescribeGtmInstanceSystemCnameResponseBody) *DescribeGtmInstanceSystemCnameResponse {
	s.Body = v
	return s
}

type DescribeGtmInstancesRequest struct {
	// The keyword that you use for query. Exact match is supported by instance ID or instance name.
	Keyword *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	// The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// Specifies whether additional information is required. Default value: **false**.
	NeedDetailAttributes *bool `json:"NeedDetailAttributes,omitempty" xml:"NeedDetailAttributes,omitempty"`
	// The page number to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeGtmInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstancesRequest) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstancesRequest) SetKeyword(v string) *DescribeGtmInstancesRequest {
	s.Keyword = &v
	return s
}

func (s *DescribeGtmInstancesRequest) SetLang(v string) *DescribeGtmInstancesRequest {
	s.Lang = &v
	return s
}

func (s *DescribeGtmInstancesRequest) SetNeedDetailAttributes(v bool) *DescribeGtmInstancesRequest {
	s.NeedDetailAttributes = &v
	return s
}

func (s *DescribeGtmInstancesRequest) SetPageNumber(v int32) *DescribeGtmInstancesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeGtmInstancesRequest) SetPageSize(v int32) *DescribeGtmInstancesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeGtmInstancesRequest) SetResourceGroupId(v string) *DescribeGtmInstancesRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeGtmInstancesResponseBody struct {
	// The list of queried instances.
	GtmInstances *DescribeGtmInstancesResponseBodyGtmInstances `json:"GtmInstances,omitempty" xml:"GtmInstances,omitempty" type:"Struct"`
	// The returned page number.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalItems *int32 `json:"TotalItems,omitempty" xml:"TotalItems,omitempty"`
	// The total number of pages returned.
	TotalPages *int32 `json:"TotalPages,omitempty" xml:"TotalPages,omitempty"`
}

func (s DescribeGtmInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstancesResponseBody) SetGtmInstances(v *DescribeGtmInstancesResponseBodyGtmInstances) *DescribeGtmInstancesResponseBody {
	s.GtmInstances = v
	return s
}

func (s *DescribeGtmInstancesResponseBody) SetPageNumber(v int32) *DescribeGtmInstancesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeGtmInstancesResponseBody) SetPageSize(v int32) *DescribeGtmInstancesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeGtmInstancesResponseBody) SetRequestId(v string) *DescribeGtmInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeGtmInstancesResponseBody) SetTotalItems(v int32) *DescribeGtmInstancesResponseBody {
	s.TotalItems = &v
	return s
}

func (s *DescribeGtmInstancesResponseBody) SetTotalPages(v int32) *DescribeGtmInstancesResponseBody {
	s.TotalPages = &v
	return s
}

type DescribeGtmInstancesResponseBodyGtmInstances struct {
	GtmInstance []*DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance `json:"GtmInstance,omitempty" xml:"GtmInstance,omitempty" type:"Repeated"`
}

func (s DescribeGtmInstancesResponseBodyGtmInstances) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstancesResponseBodyGtmInstances) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstancesResponseBodyGtmInstances) SetGtmInstance(v []*DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance) *DescribeGtmInstancesResponseBodyGtmInstances {
	s.GtmInstance = v
	return s
}

type DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance struct {
	// The number of access policies.
	AccessStrategyNum *int32 `json:"AccessStrategyNum,omitempty" xml:"AccessStrategyNum,omitempty"`
	// The number of address pools.
	AddressPoolNum *int32 `json:"AddressPoolNum,omitempty" xml:"AddressPoolNum,omitempty"`
	// The name of the alert group.
	AlertGroup *string `json:"AlertGroup,omitempty" xml:"AlertGroup,omitempty"`
	// The CNAME domain name that is used to access the instance.
	Cname *string `json:"Cname,omitempty" xml:"Cname,omitempty"`
	// The CNAME domain name used to access the instance. Valid values:
	//
	// *   **SYSTEM_ASSIGN**: A CNAME domain name assigned by the system is used.
	// *   **CUSTOM**: A custom CNAME domain name is used.
	CnameMode *string `json:"CnameMode,omitempty" xml:"CnameMode,omitempty"`
	// The time when the instance was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The UNIX timestamp that indicates when the instance was created.
	CreateTimestamp *int64 `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The time when the instance expires.
	ExpireTime *string `json:"ExpireTime,omitempty" xml:"ExpireTime,omitempty"`
	// The UNIX timestamp that indicates when the instance expires.
	ExpireTimestamp *int64 `json:"ExpireTimestamp,omitempty" xml:"ExpireTimestamp,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the instance.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The load balancing policy that is used. Valid values:
	//
	// *   **ALL_RR**: Load balancing
	// *   **RATIO**: Weighted round-robin
	LbaStrategy *string `json:"LbaStrategy,omitempty" xml:"LbaStrategy,omitempty"`
	// The ID of the resource group to which the instance belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The global time to live (TTL).
	Ttl *int32 `json:"Ttl,omitempty" xml:"Ttl,omitempty"`
	// The domain name of the user.
	UserDomainName *string `json:"UserDomainName,omitempty" xml:"UserDomainName,omitempty"`
	// The version code of the instance.
	VersionCode *string `json:"VersionCode,omitempty" xml:"VersionCode,omitempty"`
}

func (s DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance) SetAccessStrategyNum(v int32) *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance {
	s.AccessStrategyNum = &v
	return s
}

func (s *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance) SetAddressPoolNum(v int32) *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance {
	s.AddressPoolNum = &v
	return s
}

func (s *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance) SetAlertGroup(v string) *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance {
	s.AlertGroup = &v
	return s
}

func (s *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance) SetCname(v string) *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance {
	s.Cname = &v
	return s
}

func (s *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance) SetCnameMode(v string) *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance {
	s.CnameMode = &v
	return s
}

func (s *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance) SetCreateTime(v string) *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance {
	s.CreateTime = &v
	return s
}

func (s *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance) SetCreateTimestamp(v int64) *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance {
	s.CreateTimestamp = &v
	return s
}

func (s *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance) SetExpireTime(v string) *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance {
	s.ExpireTime = &v
	return s
}

func (s *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance) SetExpireTimestamp(v int64) *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance {
	s.ExpireTimestamp = &v
	return s
}

func (s *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance) SetInstanceId(v string) *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance {
	s.InstanceId = &v
	return s
}

func (s *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance) SetInstanceName(v string) *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance {
	s.InstanceName = &v
	return s
}

func (s *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance) SetLbaStrategy(v string) *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance {
	s.LbaStrategy = &v
	return s
}

func (s *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance) SetResourceGroupId(v string) *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance) SetTtl(v int32) *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance {
	s.Ttl = &v
	return s
}

func (s *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance) SetUserDomainName(v string) *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance {
	s.UserDomainName = &v
	return s
}

func (s *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance) SetVersionCode(v string) *DescribeGtmInstancesResponseBodyGtmInstancesGtmInstance {
	s.VersionCode = &v
	return s
}

type DescribeGtmInstancesResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeGtmInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeGtmInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmInstancesResponse) GoString() string {
	return s.String()
}

func (s *DescribeGtmInstancesResponse) SetHeaders(v map[string]*string) *DescribeGtmInstancesResponse {
	s.Headers = v
	return s
}

func (s *DescribeGtmInstancesResponse) SetStatusCode(v int32) *DescribeGtmInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeGtmInstancesResponse) SetBody(v *DescribeGtmInstancesResponseBody) *DescribeGtmInstancesResponse {
	s.Body = v
	return s
}

type DescribeGtmLogsRequest struct {
	EndTimestamp *int64 `json:"EndTimestamp,omitempty" xml:"EndTimestamp,omitempty"`
	// The ID of the GTM instance whose logs you want to query.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The keyword for searching logs, in case-insensitive "%Keyword%" format.
	Keyword *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	// The language used by the user.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The number of the page to return. Pages start from page **1**. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on per page. Maximum value: **100**. Default value: **20**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The beginning of the time range to query.
	StartTimestamp *int64 `json:"StartTimestamp,omitempty" xml:"StartTimestamp,omitempty"`
}

func (s DescribeGtmLogsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmLogsRequest) GoString() string {
	return s.String()
}

func (s *DescribeGtmLogsRequest) SetEndTimestamp(v int64) *DescribeGtmLogsRequest {
	s.EndTimestamp = &v
	return s
}

func (s *DescribeGtmLogsRequest) SetInstanceId(v string) *DescribeGtmLogsRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeGtmLogsRequest) SetKeyword(v string) *DescribeGtmLogsRequest {
	s.Keyword = &v
	return s
}

func (s *DescribeGtmLogsRequest) SetLang(v string) *DescribeGtmLogsRequest {
	s.Lang = &v
	return s
}

func (s *DescribeGtmLogsRequest) SetPageNumber(v int32) *DescribeGtmLogsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeGtmLogsRequest) SetPageSize(v int32) *DescribeGtmLogsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeGtmLogsRequest) SetStartTimestamp(v int64) *DescribeGtmLogsRequest {
	s.StartTimestamp = &v
	return s
}

type DescribeGtmLogsResponseBody struct {
	// The list of logs returned.
	Logs *DescribeGtmLogsResponseBodyLogs `json:"Logs,omitempty" xml:"Logs,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned on all pages.
	TotalItems *int32 `json:"TotalItems,omitempty" xml:"TotalItems,omitempty"`
	// The total number of pages returned.
	TotalPages *int32 `json:"TotalPages,omitempty" xml:"TotalPages,omitempty"`
}

func (s DescribeGtmLogsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmLogsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeGtmLogsResponseBody) SetLogs(v *DescribeGtmLogsResponseBodyLogs) *DescribeGtmLogsResponseBody {
	s.Logs = v
	return s
}

func (s *DescribeGtmLogsResponseBody) SetPageNumber(v int32) *DescribeGtmLogsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeGtmLogsResponseBody) SetPageSize(v int32) *DescribeGtmLogsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeGtmLogsResponseBody) SetRequestId(v string) *DescribeGtmLogsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeGtmLogsResponseBody) SetTotalItems(v int32) *DescribeGtmLogsResponseBody {
	s.TotalItems = &v
	return s
}

func (s *DescribeGtmLogsResponseBody) SetTotalPages(v int32) *DescribeGtmLogsResponseBody {
	s.TotalPages = &v
	return s
}

type DescribeGtmLogsResponseBodyLogs struct {
	Log []*DescribeGtmLogsResponseBodyLogsLog `json:"Log,omitempty" xml:"Log,omitempty" type:"Repeated"`
}

func (s DescribeGtmLogsResponseBodyLogs) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmLogsResponseBodyLogs) GoString() string {
	return s.String()
}

func (s *DescribeGtmLogsResponseBodyLogs) SetLog(v []*DescribeGtmLogsResponseBodyLogsLog) *DescribeGtmLogsResponseBodyLogs {
	s.Log = v
	return s
}

type DescribeGtmLogsResponseBodyLogsLog struct {
	// The formatted message content.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the object that was operated on.
	EntityId *string `json:"EntityId,omitempty" xml:"EntityId,omitempty"`
	// The name of the object that was operated on.
	EntityName *string `json:"EntityName,omitempty" xml:"EntityName,omitempty"`
	// The type of the object that was operated on.
	EntityType *string `json:"EntityType,omitempty" xml:"EntityType,omitempty"`
	// The ID of the log record.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The operation performed.
	OperAction *string `json:"OperAction,omitempty" xml:"OperAction,omitempty"`
	// The IP address subject to the operation.
	OperIp *string `json:"OperIp,omitempty" xml:"OperIp,omitempty"`
	// The time when the operation was performed.
	OperTime *string `json:"OperTime,omitempty" xml:"OperTime,omitempty"`
	// A timestamp that indicates the time when the operation was performed.
	OperTimestamp *int64 `json:"OperTimestamp,omitempty" xml:"OperTimestamp,omitempty"`
}

func (s DescribeGtmLogsResponseBodyLogsLog) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmLogsResponseBodyLogsLog) GoString() string {
	return s.String()
}

func (s *DescribeGtmLogsResponseBodyLogsLog) SetContent(v string) *DescribeGtmLogsResponseBodyLogsLog {
	s.Content = &v
	return s
}

func (s *DescribeGtmLogsResponseBodyLogsLog) SetEntityId(v string) *DescribeGtmLogsResponseBodyLogsLog {
	s.EntityId = &v
	return s
}

func (s *DescribeGtmLogsResponseBodyLogsLog) SetEntityName(v string) *DescribeGtmLogsResponseBodyLogsLog {
	s.EntityName = &v
	return s
}

func (s *DescribeGtmLogsResponseBodyLogsLog) SetEntityType(v string) *DescribeGtmLogsResponseBodyLogsLog {
	s.EntityType = &v
	return s
}

func (s *DescribeGtmLogsResponseBodyLogsLog) SetId(v int64) *DescribeGtmLogsResponseBodyLogsLog {
	s.Id = &v
	return s
}

func (s *DescribeGtmLogsResponseBodyLogsLog) SetOperAction(v string) *DescribeGtmLogsResponseBodyLogsLog {
	s.OperAction = &v
	return s
}

func (s *DescribeGtmLogsResponseBodyLogsLog) SetOperIp(v string) *DescribeGtmLogsResponseBodyLogsLog {
	s.OperIp = &v
	return s
}

func (s *DescribeGtmLogsResponseBodyLogsLog) SetOperTime(v string) *DescribeGtmLogsResponseBodyLogsLog {
	s.OperTime = &v
	return s
}

func (s *DescribeGtmLogsResponseBodyLogsLog) SetOperTimestamp(v int64) *DescribeGtmLogsResponseBodyLogsLog {
	s.OperTimestamp = &v
	return s
}

type DescribeGtmLogsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeGtmLogsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeGtmLogsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmLogsResponse) GoString() string {
	return s.String()
}

func (s *DescribeGtmLogsResponse) SetHeaders(v map[string]*string) *DescribeGtmLogsResponse {
	s.Headers = v
	return s
}

func (s *DescribeGtmLogsResponse) SetStatusCode(v int32) *DescribeGtmLogsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeGtmLogsResponse) SetBody(v *DescribeGtmLogsResponseBody) *DescribeGtmLogsResponse {
	s.Body = v
	return s
}

type DescribeGtmMonitorAvailableConfigRequest struct {
	// The language of the values of specific response parameters.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DescribeGtmMonitorAvailableConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmMonitorAvailableConfigRequest) GoString() string {
	return s.String()
}

func (s *DescribeGtmMonitorAvailableConfigRequest) SetLang(v string) *DescribeGtmMonitorAvailableConfigRequest {
	s.Lang = &v
	return s
}

type DescribeGtmMonitorAvailableConfigResponseBody struct {
	// The monitored nodes.
	IspCityNodes *DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodes `json:"IspCityNodes,omitempty" xml:"IspCityNodes,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeGtmMonitorAvailableConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmMonitorAvailableConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeGtmMonitorAvailableConfigResponseBody) SetIspCityNodes(v *DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodes) *DescribeGtmMonitorAvailableConfigResponseBody {
	s.IspCityNodes = v
	return s
}

func (s *DescribeGtmMonitorAvailableConfigResponseBody) SetRequestId(v string) *DescribeGtmMonitorAvailableConfigResponseBody {
	s.RequestId = &v
	return s
}

type DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodes struct {
	IspCityNode []*DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode `json:"IspCityNode,omitempty" xml:"IspCityNode,omitempty" type:"Repeated"`
}

func (s DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodes) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodes) GoString() string {
	return s.String()
}

func (s *DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodes) SetIspCityNode(v []*DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode) *DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodes {
	s.IspCityNode = v
	return s
}

type DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode struct {
	// The code of the city where the monitored node is deployed.
	CityCode *string `json:"CityCode,omitempty" xml:"CityCode,omitempty"`
	// The display name of the city where the monitored node is deployed.
	CityName *string `json:"CityName,omitempty" xml:"CityName,omitempty"`
	// Indicates whether the monitored node is selected for the health check by default.
	DefaultSelected *bool `json:"DefaultSelected,omitempty" xml:"DefaultSelected,omitempty"`
	// The name of the group to which the monitored node belongs.
	//
	// Valid values: Overseas Nodes, BGP Nodes, and ISP Nodes.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The type of the group to which the monitored node belongs.
	//
	// Valid values: BGP, OVERSEAS, and ISP.
	GroupType *string `json:"GroupType,omitempty" xml:"GroupType,omitempty"`
	// The code of the Internet service provider (ISP) to which the monitored node belongs.
	//
	// *   If the value of the GroupType parameter is BGP or OVERSEAS, the value of IspCode is 465 by default.
	// *   If the value of the GroupType parameter is not BGP or OVERSEAS, valid values of IspCode are 232, 132, and 5. and is used together with CityCode.
	IspCode *string `json:"IspCode,omitempty" xml:"IspCode,omitempty"`
	// The display name of the ISP to which the monitored node belongs.
	IspName *string `json:"IspName,omitempty" xml:"IspName,omitempty"`
	// Indicates whether the monitored node is deployed in the Chinese mainland.
	Mainland *bool `json:"Mainland,omitempty" xml:"Mainland,omitempty"`
}

func (s DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode) GoString() string {
	return s.String()
}

func (s *DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode) SetCityCode(v string) *DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode {
	s.CityCode = &v
	return s
}

func (s *DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode) SetCityName(v string) *DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode {
	s.CityName = &v
	return s
}

func (s *DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode) SetDefaultSelected(v bool) *DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode {
	s.DefaultSelected = &v
	return s
}

func (s *DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode) SetGroupName(v string) *DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode {
	s.GroupName = &v
	return s
}

func (s *DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode) SetGroupType(v string) *DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode {
	s.GroupType = &v
	return s
}

func (s *DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode) SetIspCode(v string) *DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode {
	s.IspCode = &v
	return s
}

func (s *DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode) SetIspName(v string) *DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode {
	s.IspName = &v
	return s
}

func (s *DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode) SetMainland(v bool) *DescribeGtmMonitorAvailableConfigResponseBodyIspCityNodesIspCityNode {
	s.Mainland = &v
	return s
}

type DescribeGtmMonitorAvailableConfigResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeGtmMonitorAvailableConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeGtmMonitorAvailableConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmMonitorAvailableConfigResponse) GoString() string {
	return s.String()
}

func (s *DescribeGtmMonitorAvailableConfigResponse) SetHeaders(v map[string]*string) *DescribeGtmMonitorAvailableConfigResponse {
	s.Headers = v
	return s
}

func (s *DescribeGtmMonitorAvailableConfigResponse) SetStatusCode(v int32) *DescribeGtmMonitorAvailableConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeGtmMonitorAvailableConfigResponse) SetBody(v *DescribeGtmMonitorAvailableConfigResponseBody) *DescribeGtmMonitorAvailableConfigResponse {
	s.Body = v
	return s
}

type DescribeGtmMonitorConfigRequest struct {
	// The language of the values of specific response parameters.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the health check configuration.
	MonitorConfigId *string `json:"MonitorConfigId,omitempty" xml:"MonitorConfigId,omitempty"`
}

func (s DescribeGtmMonitorConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmMonitorConfigRequest) GoString() string {
	return s.String()
}

func (s *DescribeGtmMonitorConfigRequest) SetLang(v string) *DescribeGtmMonitorConfigRequest {
	s.Lang = &v
	return s
}

func (s *DescribeGtmMonitorConfigRequest) SetMonitorConfigId(v string) *DescribeGtmMonitorConfigRequest {
	s.MonitorConfigId = &v
	return s
}

type DescribeGtmMonitorConfigResponseBody struct {
	// The time when the health check configuration was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The timestamp that indicates the time when the health check configuration was created.
	CreateTimestamp *int64 `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.
	EvaluationCount *int32 `json:"EvaluationCount,omitempty" xml:"EvaluationCount,omitempty"`
	// The health check interval. Unit: seconds. The value is 60.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The monitored nodes.
	IspCityNodes *DescribeGtmMonitorConfigResponseBodyIspCityNodes `json:"IspCityNodes,omitempty" xml:"IspCityNodes,omitempty" type:"Struct"`
	// The ID of the health check configuration.
	MonitorConfigId *string `json:"MonitorConfigId,omitempty" xml:"MonitorConfigId,omitempty"`
	// The extended information, that is, the parameters required for the protocol. Different protocols require different parameters:
	//
	// HTTP or HTTPS:
	//
	// *   port: the port to check.
	// *   failureRate: the failure rate.
	// *   code: the status code threshold. If the returned status code is greater than the specified threshold, the application service is deemed abnormal. Valid values: 400 and 500.
	// *   host: the host configuration.
	// *   path: the health check URL.
	//
	// PING:
	//
	// *   packetNum: the number of ping packets.
	// *   packetLossRate: the loss rate of ping packets.
	// *   failureRate: the failure rate.
	//
	// TCP:
	//
	// *   port: the port to check.
	// *   failureRate: the failure rate.
	MonitorExtendInfo *string `json:"MonitorExtendInfo,omitempty" xml:"MonitorExtendInfo,omitempty"`
	// The protocol used for the health check.
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The health check timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	// The time when the health check configuration was last updated.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The timestamp that indicates the time when the health check configuration was last updated.
	UpdateTimestamp *int64 `json:"UpdateTimestamp,omitempty" xml:"UpdateTimestamp,omitempty"`
}

func (s DescribeGtmMonitorConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmMonitorConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeGtmMonitorConfigResponseBody) SetCreateTime(v string) *DescribeGtmMonitorConfigResponseBody {
	s.CreateTime = &v
	return s
}

func (s *DescribeGtmMonitorConfigResponseBody) SetCreateTimestamp(v int64) *DescribeGtmMonitorConfigResponseBody {
	s.CreateTimestamp = &v
	return s
}

func (s *DescribeGtmMonitorConfigResponseBody) SetEvaluationCount(v int32) *DescribeGtmMonitorConfigResponseBody {
	s.EvaluationCount = &v
	return s
}

func (s *DescribeGtmMonitorConfigResponseBody) SetInterval(v int32) *DescribeGtmMonitorConfigResponseBody {
	s.Interval = &v
	return s
}

func (s *DescribeGtmMonitorConfigResponseBody) SetIspCityNodes(v *DescribeGtmMonitorConfigResponseBodyIspCityNodes) *DescribeGtmMonitorConfigResponseBody {
	s.IspCityNodes = v
	return s
}

func (s *DescribeGtmMonitorConfigResponseBody) SetMonitorConfigId(v string) *DescribeGtmMonitorConfigResponseBody {
	s.MonitorConfigId = &v
	return s
}

func (s *DescribeGtmMonitorConfigResponseBody) SetMonitorExtendInfo(v string) *DescribeGtmMonitorConfigResponseBody {
	s.MonitorExtendInfo = &v
	return s
}

func (s *DescribeGtmMonitorConfigResponseBody) SetProtocolType(v string) *DescribeGtmMonitorConfigResponseBody {
	s.ProtocolType = &v
	return s
}

func (s *DescribeGtmMonitorConfigResponseBody) SetRequestId(v string) *DescribeGtmMonitorConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeGtmMonitorConfigResponseBody) SetTimeout(v int32) *DescribeGtmMonitorConfigResponseBody {
	s.Timeout = &v
	return s
}

func (s *DescribeGtmMonitorConfigResponseBody) SetUpdateTime(v string) *DescribeGtmMonitorConfigResponseBody {
	s.UpdateTime = &v
	return s
}

func (s *DescribeGtmMonitorConfigResponseBody) SetUpdateTimestamp(v int64) *DescribeGtmMonitorConfigResponseBody {
	s.UpdateTimestamp = &v
	return s
}

type DescribeGtmMonitorConfigResponseBodyIspCityNodes struct {
	IspCityNode []*DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode `json:"IspCityNode,omitempty" xml:"IspCityNode,omitempty" type:"Repeated"`
}

func (s DescribeGtmMonitorConfigResponseBodyIspCityNodes) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmMonitorConfigResponseBodyIspCityNodes) GoString() string {
	return s.String()
}

func (s *DescribeGtmMonitorConfigResponseBodyIspCityNodes) SetIspCityNode(v []*DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode) *DescribeGtmMonitorConfigResponseBodyIspCityNodes {
	s.IspCityNode = v
	return s
}

type DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode struct {
	// The code of the city where the monitored node is deployed.
	CityCode *string `json:"CityCode,omitempty" xml:"CityCode,omitempty"`
	// The display name of the city where the monitored node is deployed.
	CityName *string `json:"CityName,omitempty" xml:"CityName,omitempty"`
	// The code of the country where the monitored node is deployed.
	CountryCode *string `json:"CountryCode,omitempty" xml:"CountryCode,omitempty"`
	// The display name of the country where the monitored node is deployed.
	CountryName *string `json:"CountryName,omitempty" xml:"CountryName,omitempty"`
	// The code of the Internet service provider (ISP) to which the monitored node belongs.
	IspCode *string `json:"IspCode,omitempty" xml:"IspCode,omitempty"`
	// The display name of the ISP to which the monitored node belongs.
	IspName *string `json:"IspName,omitempty" xml:"IspName,omitempty"`
}

func (s DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode) GoString() string {
	return s.String()
}

func (s *DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode) SetCityCode(v string) *DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode {
	s.CityCode = &v
	return s
}

func (s *DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode) SetCityName(v string) *DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode {
	s.CityName = &v
	return s
}

func (s *DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode) SetCountryCode(v string) *DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode {
	s.CountryCode = &v
	return s
}

func (s *DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode) SetCountryName(v string) *DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode {
	s.CountryName = &v
	return s
}

func (s *DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode) SetIspCode(v string) *DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode {
	s.IspCode = &v
	return s
}

func (s *DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode) SetIspName(v string) *DescribeGtmMonitorConfigResponseBodyIspCityNodesIspCityNode {
	s.IspName = &v
	return s
}

type DescribeGtmMonitorConfigResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeGtmMonitorConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeGtmMonitorConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmMonitorConfigResponse) GoString() string {
	return s.String()
}

func (s *DescribeGtmMonitorConfigResponse) SetHeaders(v map[string]*string) *DescribeGtmMonitorConfigResponse {
	s.Headers = v
	return s
}

func (s *DescribeGtmMonitorConfigResponse) SetStatusCode(v int32) *DescribeGtmMonitorConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeGtmMonitorConfigResponse) SetBody(v *DescribeGtmMonitorConfigResponseBody) *DescribeGtmMonitorConfigResponse {
	s.Body = v
	return s
}

type DescribeGtmRecoveryPlanRequest struct {
	// The language used by the user.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the disaster recovery plan that you want to query.
	RecoveryPlanId *int64 `json:"RecoveryPlanId,omitempty" xml:"RecoveryPlanId,omitempty"`
}

func (s DescribeGtmRecoveryPlanRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmRecoveryPlanRequest) GoString() string {
	return s.String()
}

func (s *DescribeGtmRecoveryPlanRequest) SetLang(v string) *DescribeGtmRecoveryPlanRequest {
	s.Lang = &v
	return s
}

func (s *DescribeGtmRecoveryPlanRequest) SetRecoveryPlanId(v int64) *DescribeGtmRecoveryPlanRequest {
	s.RecoveryPlanId = &v
	return s
}

type DescribeGtmRecoveryPlanResponseBody struct {
	// The time when the disaster recovery plan was created.
	CreateTime      *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	CreateTimestamp *int64  `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The number of faulty address pools.
	FaultAddrPoolNum *int32 `json:"FaultAddrPoolNum,omitempty" xml:"FaultAddrPoolNum,omitempty"`
	// The list of faulty address pools.
	FaultAddrPools *DescribeGtmRecoveryPlanResponseBodyFaultAddrPools `json:"FaultAddrPools,omitempty" xml:"FaultAddrPools,omitempty" type:"Struct"`
	// The last time when the recovery plan was executed.
	LastExecuteTime *string `json:"LastExecuteTime,omitempty" xml:"LastExecuteTime,omitempty"`
	// A timestamp that indicates the last time when the recovery plan was executed.
	LastExecuteTimestamp *int64 `json:"LastExecuteTimestamp,omitempty" xml:"LastExecuteTimestamp,omitempty"`
	// The last time when the disaster recovery plan was rolled back.
	LastRollbackTime *string `json:"LastRollbackTime,omitempty" xml:"LastRollbackTime,omitempty"`
	// A timestamp that indicates the last time when the disaster recovery plan was rolled back.
	LastRollbackTimestamp *int64 `json:"LastRollbackTimestamp,omitempty" xml:"LastRollbackTimestamp,omitempty"`
	// The name of the disaster recovery plan queried.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the disaster recovery plan queried.
	RecoveryPlanId *int64 `json:"RecoveryPlanId,omitempty" xml:"RecoveryPlanId,omitempty"`
	// The remarks on the disaster recovery plan.
	Remark *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the disaster recovery plan queried.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The last time when the disaster recovery plan was updated.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// A timestamp that indicates the last time when the disaster recovery plan was updated.
	UpdateTimestamp *int64 `json:"UpdateTimestamp,omitempty" xml:"UpdateTimestamp,omitempty"`
}

func (s DescribeGtmRecoveryPlanResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmRecoveryPlanResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeGtmRecoveryPlanResponseBody) SetCreateTime(v string) *DescribeGtmRecoveryPlanResponseBody {
	s.CreateTime = &v
	return s
}

func (s *DescribeGtmRecoveryPlanResponseBody) SetCreateTimestamp(v int64) *DescribeGtmRecoveryPlanResponseBody {
	s.CreateTimestamp = &v
	return s
}

func (s *DescribeGtmRecoveryPlanResponseBody) SetFaultAddrPoolNum(v int32) *DescribeGtmRecoveryPlanResponseBody {
	s.FaultAddrPoolNum = &v
	return s
}

func (s *DescribeGtmRecoveryPlanResponseBody) SetFaultAddrPools(v *DescribeGtmRecoveryPlanResponseBodyFaultAddrPools) *DescribeGtmRecoveryPlanResponseBody {
	s.FaultAddrPools = v
	return s
}

func (s *DescribeGtmRecoveryPlanResponseBody) SetLastExecuteTime(v string) *DescribeGtmRecoveryPlanResponseBody {
	s.LastExecuteTime = &v
	return s
}

func (s *DescribeGtmRecoveryPlanResponseBody) SetLastExecuteTimestamp(v int64) *DescribeGtmRecoveryPlanResponseBody {
	s.LastExecuteTimestamp = &v
	return s
}

func (s *DescribeGtmRecoveryPlanResponseBody) SetLastRollbackTime(v string) *DescribeGtmRecoveryPlanResponseBody {
	s.LastRollbackTime = &v
	return s
}

func (s *DescribeGtmRecoveryPlanResponseBody) SetLastRollbackTimestamp(v int64) *DescribeGtmRecoveryPlanResponseBody {
	s.LastRollbackTimestamp = &v
	return s
}

func (s *DescribeGtmRecoveryPlanResponseBody) SetName(v string) *DescribeGtmRecoveryPlanResponseBody {
	s.Name = &v
	return s
}

func (s *DescribeGtmRecoveryPlanResponseBody) SetRecoveryPlanId(v int64) *DescribeGtmRecoveryPlanResponseBody {
	s.RecoveryPlanId = &v
	return s
}

func (s *DescribeGtmRecoveryPlanResponseBody) SetRemark(v string) *DescribeGtmRecoveryPlanResponseBody {
	s.Remark = &v
	return s
}

func (s *DescribeGtmRecoveryPlanResponseBody) SetRequestId(v string) *DescribeGtmRecoveryPlanResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeGtmRecoveryPlanResponseBody) SetStatus(v string) *DescribeGtmRecoveryPlanResponseBody {
	s.Status = &v
	return s
}

func (s *DescribeGtmRecoveryPlanResponseBody) SetUpdateTime(v string) *DescribeGtmRecoveryPlanResponseBody {
	s.UpdateTime = &v
	return s
}

func (s *DescribeGtmRecoveryPlanResponseBody) SetUpdateTimestamp(v int64) *DescribeGtmRecoveryPlanResponseBody {
	s.UpdateTimestamp = &v
	return s
}

type DescribeGtmRecoveryPlanResponseBodyFaultAddrPools struct {
	FaultAddrPool []*DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool `json:"FaultAddrPool,omitempty" xml:"FaultAddrPool,omitempty" type:"Repeated"`
}

func (s DescribeGtmRecoveryPlanResponseBodyFaultAddrPools) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmRecoveryPlanResponseBodyFaultAddrPools) GoString() string {
	return s.String()
}

func (s *DescribeGtmRecoveryPlanResponseBodyFaultAddrPools) SetFaultAddrPool(v []*DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool) *DescribeGtmRecoveryPlanResponseBodyFaultAddrPools {
	s.FaultAddrPool = v
	return s
}

type DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool struct {
	// The ID of the address pool.
	AddrPoolId *string `json:"AddrPoolId,omitempty" xml:"AddrPoolId,omitempty"`
	// The name of the address pool.
	AddrPoolName *string `json:"AddrPoolName,omitempty" xml:"AddrPoolName,omitempty"`
	// The list of addresses in the address pool.
	Addrs *DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrs `json:"Addrs,omitempty" xml:"Addrs,omitempty" type:"Struct"`
	// The ID of the GTM instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool) GoString() string {
	return s.String()
}

func (s *DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool) SetAddrPoolId(v string) *DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool {
	s.AddrPoolId = &v
	return s
}

func (s *DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool) SetAddrPoolName(v string) *DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool {
	s.AddrPoolName = &v
	return s
}

func (s *DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool) SetAddrs(v *DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrs) *DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool {
	s.Addrs = v
	return s
}

func (s *DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool) SetInstanceId(v string) *DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPool {
	s.InstanceId = &v
	return s
}

type DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrs struct {
	Addr []*DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr `json:"Addr,omitempty" xml:"Addr,omitempty" type:"Repeated"`
}

func (s DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrs) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrs) GoString() string {
	return s.String()
}

func (s *DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrs) SetAddr(v []*DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr) *DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrs {
	s.Addr = v
	return s
}

type DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr struct {
	// The ID of the address.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The address work mode. It is the mode that was set for the IP address to work.
	Mode *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The address value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr) GoString() string {
	return s.String()
}

func (s *DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr) SetId(v int64) *DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr {
	s.Id = &v
	return s
}

func (s *DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr) SetMode(v string) *DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr {
	s.Mode = &v
	return s
}

func (s *DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr) SetValue(v string) *DescribeGtmRecoveryPlanResponseBodyFaultAddrPoolsFaultAddrPoolAddrsAddr {
	s.Value = &v
	return s
}

type DescribeGtmRecoveryPlanResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeGtmRecoveryPlanResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeGtmRecoveryPlanResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmRecoveryPlanResponse) GoString() string {
	return s.String()
}

func (s *DescribeGtmRecoveryPlanResponse) SetHeaders(v map[string]*string) *DescribeGtmRecoveryPlanResponse {
	s.Headers = v
	return s
}

func (s *DescribeGtmRecoveryPlanResponse) SetStatusCode(v int32) *DescribeGtmRecoveryPlanResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeGtmRecoveryPlanResponse) SetBody(v *DescribeGtmRecoveryPlanResponseBody) *DescribeGtmRecoveryPlanResponse {
	s.Body = v
	return s
}

type DescribeGtmRecoveryPlanAvailableConfigRequest struct {
	// The language used by the user.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DescribeGtmRecoveryPlanAvailableConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmRecoveryPlanAvailableConfigRequest) GoString() string {
	return s.String()
}

func (s *DescribeGtmRecoveryPlanAvailableConfigRequest) SetLang(v string) *DescribeGtmRecoveryPlanAvailableConfigRequest {
	s.Lang = &v
	return s
}

type DescribeGtmRecoveryPlanAvailableConfigResponseBody struct {
	// The list of GTM instances involved in the disaster recovery plan.
	Instances *DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstances `json:"Instances,omitempty" xml:"Instances,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeGtmRecoveryPlanAvailableConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmRecoveryPlanAvailableConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeGtmRecoveryPlanAvailableConfigResponseBody) SetInstances(v *DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstances) *DescribeGtmRecoveryPlanAvailableConfigResponseBody {
	s.Instances = v
	return s
}

func (s *DescribeGtmRecoveryPlanAvailableConfigResponseBody) SetRequestId(v string) *DescribeGtmRecoveryPlanAvailableConfigResponseBody {
	s.RequestId = &v
	return s
}

type DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstances struct {
	Instance []*DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance `json:"Instance,omitempty" xml:"Instance,omitempty" type:"Repeated"`
}

func (s DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstances) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstances) GoString() string {
	return s.String()
}

func (s *DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstances) SetInstance(v []*DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance) *DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstances {
	s.Instance = v
	return s
}

type DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance struct {
	// The list of address pools for the GTM instance.
	AddrPools *DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPools `json:"AddrPools,omitempty" xml:"AddrPools,omitempty" type:"Struct"`
	// The ID of the GTM instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the GTM instance.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
}

func (s DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance) GoString() string {
	return s.String()
}

func (s *DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance) SetAddrPools(v *DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPools) *DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance {
	s.AddrPools = v
	return s
}

func (s *DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance) SetInstanceId(v string) *DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance {
	s.InstanceId = &v
	return s
}

func (s *DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance) SetInstanceName(v string) *DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstance {
	s.InstanceName = &v
	return s
}

type DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPools struct {
	AddrPool []*DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPoolsAddrPool `json:"AddrPool,omitempty" xml:"AddrPool,omitempty" type:"Repeated"`
}

func (s DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPools) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPools) GoString() string {
	return s.String()
}

func (s *DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPools) SetAddrPool(v []*DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPoolsAddrPool) *DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPools {
	s.AddrPool = v
	return s
}

type DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPoolsAddrPool struct {
	// The ID of the address pool.
	AddrPoolId *string `json:"AddrPoolId,omitempty" xml:"AddrPoolId,omitempty"`
	// The name of the address pool.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPoolsAddrPool) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPoolsAddrPool) GoString() string {
	return s.String()
}

func (s *DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPoolsAddrPool) SetAddrPoolId(v string) *DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPoolsAddrPool {
	s.AddrPoolId = &v
	return s
}

func (s *DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPoolsAddrPool) SetName(v string) *DescribeGtmRecoveryPlanAvailableConfigResponseBodyInstancesInstanceAddrPoolsAddrPool {
	s.Name = &v
	return s
}

type DescribeGtmRecoveryPlanAvailableConfigResponse struct {
	Headers    map[string]*string                                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeGtmRecoveryPlanAvailableConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeGtmRecoveryPlanAvailableConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmRecoveryPlanAvailableConfigResponse) GoString() string {
	return s.String()
}

func (s *DescribeGtmRecoveryPlanAvailableConfigResponse) SetHeaders(v map[string]*string) *DescribeGtmRecoveryPlanAvailableConfigResponse {
	s.Headers = v
	return s
}

func (s *DescribeGtmRecoveryPlanAvailableConfigResponse) SetStatusCode(v int32) *DescribeGtmRecoveryPlanAvailableConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeGtmRecoveryPlanAvailableConfigResponse) SetBody(v *DescribeGtmRecoveryPlanAvailableConfigResponseBody) *DescribeGtmRecoveryPlanAvailableConfigResponse {
	s.Body = v
	return s
}

type DescribeGtmRecoveryPlansRequest struct {
	// The keyword for the query. Fuzzy match is supported by disaster recovery plan name.
	Keyword *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	// The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The page number to return. The page number starts from **1**. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return per page. Maximum value: **100**. Default value: **20**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeGtmRecoveryPlansRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmRecoveryPlansRequest) GoString() string {
	return s.String()
}

func (s *DescribeGtmRecoveryPlansRequest) SetKeyword(v string) *DescribeGtmRecoveryPlansRequest {
	s.Keyword = &v
	return s
}

func (s *DescribeGtmRecoveryPlansRequest) SetLang(v string) *DescribeGtmRecoveryPlansRequest {
	s.Lang = &v
	return s
}

func (s *DescribeGtmRecoveryPlansRequest) SetPageNumber(v int32) *DescribeGtmRecoveryPlansRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeGtmRecoveryPlansRequest) SetPageSize(v int32) *DescribeGtmRecoveryPlansRequest {
	s.PageSize = &v
	return s
}

type DescribeGtmRecoveryPlansResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The details about the queried disaster recovery plans.
	RecoveryPlans *DescribeGtmRecoveryPlansResponseBodyRecoveryPlans `json:"RecoveryPlans,omitempty" xml:"RecoveryPlans,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalItems *int32 `json:"TotalItems,omitempty" xml:"TotalItems,omitempty"`
	// The total number of pages returned.
	TotalPages *int32 `json:"TotalPages,omitempty" xml:"TotalPages,omitempty"`
}

func (s DescribeGtmRecoveryPlansResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmRecoveryPlansResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeGtmRecoveryPlansResponseBody) SetPageNumber(v int32) *DescribeGtmRecoveryPlansResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeGtmRecoveryPlansResponseBody) SetPageSize(v int32) *DescribeGtmRecoveryPlansResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeGtmRecoveryPlansResponseBody) SetRecoveryPlans(v *DescribeGtmRecoveryPlansResponseBodyRecoveryPlans) *DescribeGtmRecoveryPlansResponseBody {
	s.RecoveryPlans = v
	return s
}

func (s *DescribeGtmRecoveryPlansResponseBody) SetRequestId(v string) *DescribeGtmRecoveryPlansResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeGtmRecoveryPlansResponseBody) SetTotalItems(v int32) *DescribeGtmRecoveryPlansResponseBody {
	s.TotalItems = &v
	return s
}

func (s *DescribeGtmRecoveryPlansResponseBody) SetTotalPages(v int32) *DescribeGtmRecoveryPlansResponseBody {
	s.TotalPages = &v
	return s
}

type DescribeGtmRecoveryPlansResponseBodyRecoveryPlans struct {
	RecoveryPlan []*DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan `json:"RecoveryPlan,omitempty" xml:"RecoveryPlan,omitempty" type:"Repeated"`
}

func (s DescribeGtmRecoveryPlansResponseBodyRecoveryPlans) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmRecoveryPlansResponseBodyRecoveryPlans) GoString() string {
	return s.String()
}

func (s *DescribeGtmRecoveryPlansResponseBodyRecoveryPlans) SetRecoveryPlan(v []*DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan) *DescribeGtmRecoveryPlansResponseBodyRecoveryPlans {
	s.RecoveryPlan = v
	return s
}

type DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan struct {
	// The time when the disaster recovery plan was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The UNIX timestamp that indicates when the disaster recovery plan was created.
	CreateTimestamp *int64 `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The number of faulty address pools.
	FaultAddrPoolNum *int32 `json:"FaultAddrPoolNum,omitempty" xml:"FaultAddrPoolNum,omitempty"`
	// The last time when the disaster recovery plan was executed.
	LastExecuteTime *string `json:"LastExecuteTime,omitempty" xml:"LastExecuteTime,omitempty"`
	// The UNIX timestamp that indicates the last time when the disaster recovery plan was executed.
	LastExecuteTimestamp *int64 `json:"LastExecuteTimestamp,omitempty" xml:"LastExecuteTimestamp,omitempty"`
	// The last time when the disaster recovery plan was rolled back.
	LastRollbackTime *string `json:"LastRollbackTime,omitempty" xml:"LastRollbackTime,omitempty"`
	// The UNIX timestamp that indicates the last time when the disaster recovery plan was rolled back.
	LastRollbackTimestamp *int64 `json:"LastRollbackTimestamp,omitempty" xml:"LastRollbackTimestamp,omitempty"`
	// The name of the disaster recovery plan.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the disaster recovery plan.
	RecoveryPlanId *int64 `json:"RecoveryPlanId,omitempty" xml:"RecoveryPlanId,omitempty"`
	// The remarks about the disaster recovery plan.
	Remark *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
	// The status of the disaster recovery plan. Valid values:
	//
	// *   **UNEXECUTED**: The plan is not executed.
	// *   **EXECUTED**: The plan is executed.
	// *   **ROLLED_BACK**: The plan is rolled back.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The last time when the disaster recovery plan was updated.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The UNIX timestamp that indicates the last time when the disaster recovery plan was updated.
	UpdateTimestamp *int64 `json:"UpdateTimestamp,omitempty" xml:"UpdateTimestamp,omitempty"`
}

func (s DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan) GoString() string {
	return s.String()
}

func (s *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan) SetCreateTime(v string) *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan {
	s.CreateTime = &v
	return s
}

func (s *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan) SetCreateTimestamp(v int64) *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan {
	s.CreateTimestamp = &v
	return s
}

func (s *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan) SetFaultAddrPoolNum(v int32) *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan {
	s.FaultAddrPoolNum = &v
	return s
}

func (s *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan) SetLastExecuteTime(v string) *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan {
	s.LastExecuteTime = &v
	return s
}

func (s *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan) SetLastExecuteTimestamp(v int64) *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan {
	s.LastExecuteTimestamp = &v
	return s
}

func (s *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan) SetLastRollbackTime(v string) *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan {
	s.LastRollbackTime = &v
	return s
}

func (s *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan) SetLastRollbackTimestamp(v int64) *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan {
	s.LastRollbackTimestamp = &v
	return s
}

func (s *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan) SetName(v string) *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan {
	s.Name = &v
	return s
}

func (s *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan) SetRecoveryPlanId(v int64) *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan {
	s.RecoveryPlanId = &v
	return s
}

func (s *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan) SetRemark(v string) *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan {
	s.Remark = &v
	return s
}

func (s *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan) SetStatus(v string) *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan {
	s.Status = &v
	return s
}

func (s *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan) SetUpdateTime(v string) *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan {
	s.UpdateTime = &v
	return s
}

func (s *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan) SetUpdateTimestamp(v int64) *DescribeGtmRecoveryPlansResponseBodyRecoveryPlansRecoveryPlan {
	s.UpdateTimestamp = &v
	return s
}

type DescribeGtmRecoveryPlansResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeGtmRecoveryPlansResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeGtmRecoveryPlansResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeGtmRecoveryPlansResponse) GoString() string {
	return s.String()
}

func (s *DescribeGtmRecoveryPlansResponse) SetHeaders(v map[string]*string) *DescribeGtmRecoveryPlansResponse {
	s.Headers = v
	return s
}

func (s *DescribeGtmRecoveryPlansResponse) SetStatusCode(v int32) *DescribeGtmRecoveryPlansResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeGtmRecoveryPlansResponse) SetBody(v *DescribeGtmRecoveryPlansResponseBody) *DescribeGtmRecoveryPlansResponse {
	s.Body = v
	return s
}

type DescribeInstanceDomainsRequest struct {
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The page number to return. The page number starts from 1. Default value: 1.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return per page. Maximum value: 100. Default value: 20.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeInstanceDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceDomainsRequest) GoString() string {
	return s.String()
}

func (s *DescribeInstanceDomainsRequest) SetInstanceId(v string) *DescribeInstanceDomainsRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeInstanceDomainsRequest) SetLang(v string) *DescribeInstanceDomainsRequest {
	s.Lang = &v
	return s
}

func (s *DescribeInstanceDomainsRequest) SetPageNumber(v int64) *DescribeInstanceDomainsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeInstanceDomainsRequest) SetPageSize(v int64) *DescribeInstanceDomainsRequest {
	s.PageSize = &v
	return s
}

type DescribeInstanceDomainsResponseBody struct {
	// The domain names that are bound to the instance.
	InstanceDomains []*DescribeInstanceDomainsResponseBodyInstanceDomains `json:"InstanceDomains,omitempty" xml:"InstanceDomains,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalItems *int32 `json:"TotalItems,omitempty" xml:"TotalItems,omitempty"`
	// The total number of pages returned.
	TotalPages *int32 `json:"TotalPages,omitempty" xml:"TotalPages,omitempty"`
}

func (s DescribeInstanceDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeInstanceDomainsResponseBody) SetInstanceDomains(v []*DescribeInstanceDomainsResponseBodyInstanceDomains) *DescribeInstanceDomainsResponseBody {
	s.InstanceDomains = v
	return s
}

func (s *DescribeInstanceDomainsResponseBody) SetPageNumber(v int32) *DescribeInstanceDomainsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeInstanceDomainsResponseBody) SetPageSize(v int32) *DescribeInstanceDomainsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeInstanceDomainsResponseBody) SetRequestId(v string) *DescribeInstanceDomainsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeInstanceDomainsResponseBody) SetTotalItems(v int32) *DescribeInstanceDomainsResponseBody {
	s.TotalItems = &v
	return s
}

func (s *DescribeInstanceDomainsResponseBody) SetTotalPages(v int32) *DescribeInstanceDomainsResponseBody {
	s.TotalPages = &v
	return s
}

type DescribeInstanceDomainsResponseBodyInstanceDomains struct {
	// The time when the domain name was bound with the instance.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The UNIX timestamp that indicates when the domain name was bound with the instance.
	CreateTimestamp *int64 `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
}

func (s DescribeInstanceDomainsResponseBodyInstanceDomains) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceDomainsResponseBodyInstanceDomains) GoString() string {
	return s.String()
}

func (s *DescribeInstanceDomainsResponseBodyInstanceDomains) SetCreateTime(v string) *DescribeInstanceDomainsResponseBodyInstanceDomains {
	s.CreateTime = &v
	return s
}

func (s *DescribeInstanceDomainsResponseBodyInstanceDomains) SetCreateTimestamp(v int64) *DescribeInstanceDomainsResponseBodyInstanceDomains {
	s.CreateTimestamp = &v
	return s
}

func (s *DescribeInstanceDomainsResponseBodyInstanceDomains) SetDomainName(v string) *DescribeInstanceDomainsResponseBodyInstanceDomains {
	s.DomainName = &v
	return s
}

type DescribeInstanceDomainsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeInstanceDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeInstanceDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceDomainsResponse) GoString() string {
	return s.String()
}

func (s *DescribeInstanceDomainsResponse) SetHeaders(v map[string]*string) *DescribeInstanceDomainsResponse {
	s.Headers = v
	return s
}

func (s *DescribeInstanceDomainsResponse) SetStatusCode(v int32) *DescribeInstanceDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeInstanceDomainsResponse) SetBody(v *DescribeInstanceDomainsResponseBody) *DescribeInstanceDomainsResponse {
	s.Body = v
	return s
}

type DescribeIspFlushCacheInstancesRequest struct {
	Direction  *string `json:"Direction,omitempty" xml:"Direction,omitempty"`
	Isp        *string `json:"Isp,omitempty" xml:"Isp,omitempty"`
	Keyword    *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	Lang       *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	OrderBy    *string `json:"OrderBy,omitempty" xml:"OrderBy,omitempty"`
	PageNumber *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Type       *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeIspFlushCacheInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeIspFlushCacheInstancesRequest) GoString() string {
	return s.String()
}

func (s *DescribeIspFlushCacheInstancesRequest) SetDirection(v string) *DescribeIspFlushCacheInstancesRequest {
	s.Direction = &v
	return s
}

func (s *DescribeIspFlushCacheInstancesRequest) SetIsp(v string) *DescribeIspFlushCacheInstancesRequest {
	s.Isp = &v
	return s
}

func (s *DescribeIspFlushCacheInstancesRequest) SetKeyword(v string) *DescribeIspFlushCacheInstancesRequest {
	s.Keyword = &v
	return s
}

func (s *DescribeIspFlushCacheInstancesRequest) SetLang(v string) *DescribeIspFlushCacheInstancesRequest {
	s.Lang = &v
	return s
}

func (s *DescribeIspFlushCacheInstancesRequest) SetOrderBy(v string) *DescribeIspFlushCacheInstancesRequest {
	s.OrderBy = &v
	return s
}

func (s *DescribeIspFlushCacheInstancesRequest) SetPageNumber(v int32) *DescribeIspFlushCacheInstancesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeIspFlushCacheInstancesRequest) SetPageSize(v int32) *DescribeIspFlushCacheInstancesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeIspFlushCacheInstancesRequest) SetType(v string) *DescribeIspFlushCacheInstancesRequest {
	s.Type = &v
	return s
}

type DescribeIspFlushCacheInstancesResponseBody struct {
	IspFlushCacheInstances []*DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances `json:"IspFlushCacheInstances,omitempty" xml:"IspFlushCacheInstances,omitempty" type:"Repeated"`
	PageNumber             *int32                                                              `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize               *int32                                                              `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RequestId              *string                                                             `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalItems             *int32                                                              `json:"TotalItems,omitempty" xml:"TotalItems,omitempty"`
	TotalPages             *int32                                                              `json:"TotalPages,omitempty" xml:"TotalPages,omitempty"`
}

func (s DescribeIspFlushCacheInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeIspFlushCacheInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeIspFlushCacheInstancesResponseBody) SetIspFlushCacheInstances(v []*DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances) *DescribeIspFlushCacheInstancesResponseBody {
	s.IspFlushCacheInstances = v
	return s
}

func (s *DescribeIspFlushCacheInstancesResponseBody) SetPageNumber(v int32) *DescribeIspFlushCacheInstancesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeIspFlushCacheInstancesResponseBody) SetPageSize(v int32) *DescribeIspFlushCacheInstancesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeIspFlushCacheInstancesResponseBody) SetRequestId(v string) *DescribeIspFlushCacheInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeIspFlushCacheInstancesResponseBody) SetTotalItems(v int32) *DescribeIspFlushCacheInstancesResponseBody {
	s.TotalItems = &v
	return s
}

func (s *DescribeIspFlushCacheInstancesResponseBody) SetTotalPages(v int32) *DescribeIspFlushCacheInstancesResponseBody {
	s.TotalPages = &v
	return s
}

type DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances struct {
	ExpireTime      *string                                                                    `json:"ExpireTime,omitempty" xml:"ExpireTime,omitempty"`
	ExpireTimestamp *int64                                                                     `json:"ExpireTimestamp,omitempty" xml:"ExpireTimestamp,omitempty"`
	InstanceId      *string                                                                    `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	InstanceName    *string                                                                    `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	Isp             *string                                                                    `json:"Isp,omitempty" xml:"Isp,omitempty"`
	QuotaInfo       *DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstancesQuotaInfo `json:"QuotaInfo,omitempty" xml:"QuotaInfo,omitempty" type:"Struct"`
	Status          *string                                                                    `json:"Status,omitempty" xml:"Status,omitempty"`
	VersionCode     *string                                                                    `json:"VersionCode,omitempty" xml:"VersionCode,omitempty"`
}

func (s DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances) String() string {
	return tea.Prettify(s)
}

func (s DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances) GoString() string {
	return s.String()
}

func (s *DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances) SetExpireTime(v string) *DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances {
	s.ExpireTime = &v
	return s
}

func (s *DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances) SetExpireTimestamp(v int64) *DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances {
	s.ExpireTimestamp = &v
	return s
}

func (s *DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances) SetInstanceId(v string) *DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances {
	s.InstanceId = &v
	return s
}

func (s *DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances) SetInstanceName(v string) *DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances {
	s.InstanceName = &v
	return s
}

func (s *DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances) SetIsp(v string) *DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances {
	s.Isp = &v
	return s
}

func (s *DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances) SetQuotaInfo(v *DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstancesQuotaInfo) *DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances {
	s.QuotaInfo = v
	return s
}

func (s *DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances) SetStatus(v string) *DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances {
	s.Status = &v
	return s
}

func (s *DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances) SetVersionCode(v string) *DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstances {
	s.VersionCode = &v
	return s
}

type DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstancesQuotaInfo struct {
	InstanceQuota     *int32 `json:"InstanceQuota,omitempty" xml:"InstanceQuota,omitempty"`
	InstanceQuotaUsed *int32 `json:"InstanceQuotaUsed,omitempty" xml:"InstanceQuotaUsed,omitempty"`
}

func (s DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstancesQuotaInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstancesQuotaInfo) GoString() string {
	return s.String()
}

func (s *DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstancesQuotaInfo) SetInstanceQuota(v int32) *DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstancesQuotaInfo {
	s.InstanceQuota = &v
	return s
}

func (s *DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstancesQuotaInfo) SetInstanceQuotaUsed(v int32) *DescribeIspFlushCacheInstancesResponseBodyIspFlushCacheInstancesQuotaInfo {
	s.InstanceQuotaUsed = &v
	return s
}

type DescribeIspFlushCacheInstancesResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeIspFlushCacheInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeIspFlushCacheInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeIspFlushCacheInstancesResponse) GoString() string {
	return s.String()
}

func (s *DescribeIspFlushCacheInstancesResponse) SetHeaders(v map[string]*string) *DescribeIspFlushCacheInstancesResponse {
	s.Headers = v
	return s
}

func (s *DescribeIspFlushCacheInstancesResponse) SetStatusCode(v int32) *DescribeIspFlushCacheInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeIspFlushCacheInstancesResponse) SetBody(v *DescribeIspFlushCacheInstancesResponseBody) *DescribeIspFlushCacheInstancesResponse {
	s.Body = v
	return s
}

type DescribeIspFlushCacheRemainQuotaRequest struct {
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DescribeIspFlushCacheRemainQuotaRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeIspFlushCacheRemainQuotaRequest) GoString() string {
	return s.String()
}

func (s *DescribeIspFlushCacheRemainQuotaRequest) SetLang(v string) *DescribeIspFlushCacheRemainQuotaRequest {
	s.Lang = &v
	return s
}

type DescribeIspFlushCacheRemainQuotaResponseBody struct {
	RequestId          *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TelecomRemainQuota *int32  `json:"TelecomRemainQuota,omitempty" xml:"TelecomRemainQuota,omitempty"`
}

func (s DescribeIspFlushCacheRemainQuotaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeIspFlushCacheRemainQuotaResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeIspFlushCacheRemainQuotaResponseBody) SetRequestId(v string) *DescribeIspFlushCacheRemainQuotaResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeIspFlushCacheRemainQuotaResponseBody) SetTelecomRemainQuota(v int32) *DescribeIspFlushCacheRemainQuotaResponseBody {
	s.TelecomRemainQuota = &v
	return s
}

type DescribeIspFlushCacheRemainQuotaResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeIspFlushCacheRemainQuotaResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeIspFlushCacheRemainQuotaResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeIspFlushCacheRemainQuotaResponse) GoString() string {
	return s.String()
}

func (s *DescribeIspFlushCacheRemainQuotaResponse) SetHeaders(v map[string]*string) *DescribeIspFlushCacheRemainQuotaResponse {
	s.Headers = v
	return s
}

func (s *DescribeIspFlushCacheRemainQuotaResponse) SetStatusCode(v int32) *DescribeIspFlushCacheRemainQuotaResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeIspFlushCacheRemainQuotaResponse) SetBody(v *DescribeIspFlushCacheRemainQuotaResponseBody) *DescribeIspFlushCacheRemainQuotaResponse {
	s.Body = v
	return s
}

type DescribeIspFlushCacheTaskRequest struct {
	Lang   *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DescribeIspFlushCacheTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeIspFlushCacheTaskRequest) GoString() string {
	return s.String()
}

func (s *DescribeIspFlushCacheTaskRequest) SetLang(v string) *DescribeIspFlushCacheTaskRequest {
	s.Lang = &v
	return s
}

func (s *DescribeIspFlushCacheTaskRequest) SetTaskId(v string) *DescribeIspFlushCacheTaskRequest {
	s.TaskId = &v
	return s
}

type DescribeIspFlushCacheTaskResponseBody struct {
	CreateTime        *string                                                   `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	CreateTimestamp   *int64                                                    `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	DomainName        *string                                                   `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	FlushCacheResults []*DescribeIspFlushCacheTaskResponseBodyFlushCacheResults `json:"FlushCacheResults,omitempty" xml:"FlushCacheResults,omitempty" type:"Repeated"`
	InstanceId        *string                                                   `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	InstanceName      *string                                                   `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	Isp               *string                                                   `json:"Isp,omitempty" xml:"Isp,omitempty"`
	RequestId         *string                                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TaskId            *string                                                   `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	TaskStatus        *string                                                   `json:"TaskStatus,omitempty" xml:"TaskStatus,omitempty"`
}

func (s DescribeIspFlushCacheTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeIspFlushCacheTaskResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeIspFlushCacheTaskResponseBody) SetCreateTime(v string) *DescribeIspFlushCacheTaskResponseBody {
	s.CreateTime = &v
	return s
}

func (s *DescribeIspFlushCacheTaskResponseBody) SetCreateTimestamp(v int64) *DescribeIspFlushCacheTaskResponseBody {
	s.CreateTimestamp = &v
	return s
}

func (s *DescribeIspFlushCacheTaskResponseBody) SetDomainName(v string) *DescribeIspFlushCacheTaskResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeIspFlushCacheTaskResponseBody) SetFlushCacheResults(v []*DescribeIspFlushCacheTaskResponseBodyFlushCacheResults) *DescribeIspFlushCacheTaskResponseBody {
	s.FlushCacheResults = v
	return s
}

func (s *DescribeIspFlushCacheTaskResponseBody) SetInstanceId(v string) *DescribeIspFlushCacheTaskResponseBody {
	s.InstanceId = &v
	return s
}

func (s *DescribeIspFlushCacheTaskResponseBody) SetInstanceName(v string) *DescribeIspFlushCacheTaskResponseBody {
	s.InstanceName = &v
	return s
}

func (s *DescribeIspFlushCacheTaskResponseBody) SetIsp(v string) *DescribeIspFlushCacheTaskResponseBody {
	s.Isp = &v
	return s
}

func (s *DescribeIspFlushCacheTaskResponseBody) SetRequestId(v string) *DescribeIspFlushCacheTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeIspFlushCacheTaskResponseBody) SetTaskId(v string) *DescribeIspFlushCacheTaskResponseBody {
	s.TaskId = &v
	return s
}

func (s *DescribeIspFlushCacheTaskResponseBody) SetTaskStatus(v string) *DescribeIspFlushCacheTaskResponseBody {
	s.TaskStatus = &v
	return s
}

type DescribeIspFlushCacheTaskResponseBodyFlushCacheResults struct {
	DnsNodes []*DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes `json:"DnsNodes,omitempty" xml:"DnsNodes,omitempty" type:"Repeated"`
	Province *string                                                           `json:"Province,omitempty" xml:"Province,omitempty"`
}

func (s DescribeIspFlushCacheTaskResponseBodyFlushCacheResults) String() string {
	return tea.Prettify(s)
}

func (s DescribeIspFlushCacheTaskResponseBodyFlushCacheResults) GoString() string {
	return s.String()
}

func (s *DescribeIspFlushCacheTaskResponseBodyFlushCacheResults) SetDnsNodes(v []*DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes) *DescribeIspFlushCacheTaskResponseBodyFlushCacheResults {
	s.DnsNodes = v
	return s
}

func (s *DescribeIspFlushCacheTaskResponseBodyFlushCacheResults) SetProvince(v string) *DescribeIspFlushCacheTaskResponseBodyFlushCacheResults {
	s.Province = &v
	return s
}

type DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes struct {
	Answers []*DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers `json:"Answers,omitempty" xml:"Answers,omitempty" type:"Repeated"`
	NodeIp  *string                                                                  `json:"NodeIp,omitempty" xml:"NodeIp,omitempty"`
	SpName  *string                                                                  `json:"SpName,omitempty" xml:"SpName,omitempty"`
	Status  *string                                                                  `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes) String() string {
	return tea.Prettify(s)
}

func (s DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes) GoString() string {
	return s.String()
}

func (s *DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes) SetAnswers(v []*DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers) *DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes {
	s.Answers = v
	return s
}

func (s *DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes) SetNodeIp(v string) *DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes {
	s.NodeIp = &v
	return s
}

func (s *DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes) SetSpName(v string) *DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes {
	s.SpName = &v
	return s
}

func (s *DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes) SetStatus(v string) *DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodes {
	s.Status = &v
	return s
}

type DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers struct {
	Name   *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Record *string `json:"Record,omitempty" xml:"Record,omitempty"`
	Ttl    *int64  `json:"Ttl,omitempty" xml:"Ttl,omitempty"`
	Type   *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers) String() string {
	return tea.Prettify(s)
}

func (s DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers) GoString() string {
	return s.String()
}

func (s *DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers) SetName(v string) *DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers {
	s.Name = &v
	return s
}

func (s *DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers) SetRecord(v string) *DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers {
	s.Record = &v
	return s
}

func (s *DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers) SetTtl(v int64) *DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers {
	s.Ttl = &v
	return s
}

func (s *DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers) SetType(v string) *DescribeIspFlushCacheTaskResponseBodyFlushCacheResultsDnsNodesAnswers {
	s.Type = &v
	return s
}

type DescribeIspFlushCacheTaskResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeIspFlushCacheTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeIspFlushCacheTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeIspFlushCacheTaskResponse) GoString() string {
	return s.String()
}

func (s *DescribeIspFlushCacheTaskResponse) SetHeaders(v map[string]*string) *DescribeIspFlushCacheTaskResponse {
	s.Headers = v
	return s
}

func (s *DescribeIspFlushCacheTaskResponse) SetStatusCode(v int32) *DescribeIspFlushCacheTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeIspFlushCacheTaskResponse) SetBody(v *DescribeIspFlushCacheTaskResponseBody) *DescribeIspFlushCacheTaskResponse {
	s.Body = v
	return s
}

type DescribeIspFlushCacheTasksRequest struct {
	Direction  *string `json:"Direction,omitempty" xml:"Direction,omitempty"`
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	Isp        *string `json:"Isp,omitempty" xml:"Isp,omitempty"`
	Lang       *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	OrderBy    *string `json:"OrderBy,omitempty" xml:"OrderBy,omitempty"`
	PageNumber *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeIspFlushCacheTasksRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeIspFlushCacheTasksRequest) GoString() string {
	return s.String()
}

func (s *DescribeIspFlushCacheTasksRequest) SetDirection(v string) *DescribeIspFlushCacheTasksRequest {
	s.Direction = &v
	return s
}

func (s *DescribeIspFlushCacheTasksRequest) SetDomainName(v string) *DescribeIspFlushCacheTasksRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeIspFlushCacheTasksRequest) SetInstanceId(v string) *DescribeIspFlushCacheTasksRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeIspFlushCacheTasksRequest) SetIsp(v string) *DescribeIspFlushCacheTasksRequest {
	s.Isp = &v
	return s
}

func (s *DescribeIspFlushCacheTasksRequest) SetLang(v string) *DescribeIspFlushCacheTasksRequest {
	s.Lang = &v
	return s
}

func (s *DescribeIspFlushCacheTasksRequest) SetOrderBy(v string) *DescribeIspFlushCacheTasksRequest {
	s.OrderBy = &v
	return s
}

func (s *DescribeIspFlushCacheTasksRequest) SetPageNumber(v int32) *DescribeIspFlushCacheTasksRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeIspFlushCacheTasksRequest) SetPageSize(v int32) *DescribeIspFlushCacheTasksRequest {
	s.PageSize = &v
	return s
}

type DescribeIspFlushCacheTasksResponseBody struct {
	IspFlushCacheTasks []*DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks `json:"IspFlushCacheTasks,omitempty" xml:"IspFlushCacheTasks,omitempty" type:"Repeated"`
	PageNumber         *int32                                                      `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize           *int32                                                      `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RequestId          *string                                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalItems         *int32                                                      `json:"TotalItems,omitempty" xml:"TotalItems,omitempty"`
	TotalPages         *int32                                                      `json:"TotalPages,omitempty" xml:"TotalPages,omitempty"`
}

func (s DescribeIspFlushCacheTasksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeIspFlushCacheTasksResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeIspFlushCacheTasksResponseBody) SetIspFlushCacheTasks(v []*DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks) *DescribeIspFlushCacheTasksResponseBody {
	s.IspFlushCacheTasks = v
	return s
}

func (s *DescribeIspFlushCacheTasksResponseBody) SetPageNumber(v int32) *DescribeIspFlushCacheTasksResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeIspFlushCacheTasksResponseBody) SetPageSize(v int32) *DescribeIspFlushCacheTasksResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeIspFlushCacheTasksResponseBody) SetRequestId(v string) *DescribeIspFlushCacheTasksResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeIspFlushCacheTasksResponseBody) SetTotalItems(v int32) *DescribeIspFlushCacheTasksResponseBody {
	s.TotalItems = &v
	return s
}

func (s *DescribeIspFlushCacheTasksResponseBody) SetTotalPages(v int32) *DescribeIspFlushCacheTasksResponseBody {
	s.TotalPages = &v
	return s
}

type DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks struct {
	CreateTime      *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	CreateTimestamp *int64  `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	DomainName      *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	InstanceId      *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	InstanceName    *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	Isp             *string `json:"Isp,omitempty" xml:"Isp,omitempty"`
	TaskId          *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	TaskStatus      *string `json:"TaskStatus,omitempty" xml:"TaskStatus,omitempty"`
}

func (s DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks) String() string {
	return tea.Prettify(s)
}

func (s DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks) GoString() string {
	return s.String()
}

func (s *DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks) SetCreateTime(v string) *DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks {
	s.CreateTime = &v
	return s
}

func (s *DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks) SetCreateTimestamp(v int64) *DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks {
	s.CreateTimestamp = &v
	return s
}

func (s *DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks) SetDomainName(v string) *DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks {
	s.DomainName = &v
	return s
}

func (s *DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks) SetInstanceId(v string) *DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks {
	s.InstanceId = &v
	return s
}

func (s *DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks) SetInstanceName(v string) *DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks {
	s.InstanceName = &v
	return s
}

func (s *DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks) SetIsp(v string) *DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks {
	s.Isp = &v
	return s
}

func (s *DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks) SetTaskId(v string) *DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks {
	s.TaskId = &v
	return s
}

func (s *DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks) SetTaskStatus(v string) *DescribeIspFlushCacheTasksResponseBodyIspFlushCacheTasks {
	s.TaskStatus = &v
	return s
}

type DescribeIspFlushCacheTasksResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeIspFlushCacheTasksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeIspFlushCacheTasksResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeIspFlushCacheTasksResponse) GoString() string {
	return s.String()
}

func (s *DescribeIspFlushCacheTasksResponse) SetHeaders(v map[string]*string) *DescribeIspFlushCacheTasksResponse {
	s.Headers = v
	return s
}

func (s *DescribeIspFlushCacheTasksResponse) SetStatusCode(v int32) *DescribeIspFlushCacheTasksResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeIspFlushCacheTasksResponse) SetBody(v *DescribeIspFlushCacheTasksResponseBody) *DescribeIspFlushCacheTasksResponse {
	s.Body = v
	return s
}

type DescribePdnsAccountSummaryRequest struct {
	EndDate   *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	Lang      *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	StartDate *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
}

func (s DescribePdnsAccountSummaryRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsAccountSummaryRequest) GoString() string {
	return s.String()
}

func (s *DescribePdnsAccountSummaryRequest) SetEndDate(v string) *DescribePdnsAccountSummaryRequest {
	s.EndDate = &v
	return s
}

func (s *DescribePdnsAccountSummaryRequest) SetLang(v string) *DescribePdnsAccountSummaryRequest {
	s.Lang = &v
	return s
}

func (s *DescribePdnsAccountSummaryRequest) SetStartDate(v string) *DescribePdnsAccountSummaryRequest {
	s.StartDate = &v
	return s
}

type DescribePdnsAccountSummaryResponseBody struct {
	Data      *DescribePdnsAccountSummaryResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	RequestId *string                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribePdnsAccountSummaryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsAccountSummaryResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePdnsAccountSummaryResponseBody) SetData(v *DescribePdnsAccountSummaryResponseBodyData) *DescribePdnsAccountSummaryResponseBody {
	s.Data = v
	return s
}

func (s *DescribePdnsAccountSummaryResponseBody) SetRequestId(v string) *DescribePdnsAccountSummaryResponseBody {
	s.RequestId = &v
	return s
}

type DescribePdnsAccountSummaryResponseBodyData struct {
	DomainCount    *int64 `json:"DomainCount,omitempty" xml:"DomainCount,omitempty"`
	HttpCount      *int64 `json:"HttpCount,omitempty" xml:"HttpCount,omitempty"`
	HttpsCount     *int64 `json:"HttpsCount,omitempty" xml:"HttpsCount,omitempty"`
	SubDomainCount *int64 `json:"SubDomainCount,omitempty" xml:"SubDomainCount,omitempty"`
	ThreatCount    *int64 `json:"ThreatCount,omitempty" xml:"ThreatCount,omitempty"`
	TotalCount     *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	UserId         *int64 `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s DescribePdnsAccountSummaryResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsAccountSummaryResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribePdnsAccountSummaryResponseBodyData) SetDomainCount(v int64) *DescribePdnsAccountSummaryResponseBodyData {
	s.DomainCount = &v
	return s
}

func (s *DescribePdnsAccountSummaryResponseBodyData) SetHttpCount(v int64) *DescribePdnsAccountSummaryResponseBodyData {
	s.HttpCount = &v
	return s
}

func (s *DescribePdnsAccountSummaryResponseBodyData) SetHttpsCount(v int64) *DescribePdnsAccountSummaryResponseBodyData {
	s.HttpsCount = &v
	return s
}

func (s *DescribePdnsAccountSummaryResponseBodyData) SetSubDomainCount(v int64) *DescribePdnsAccountSummaryResponseBodyData {
	s.SubDomainCount = &v
	return s
}

func (s *DescribePdnsAccountSummaryResponseBodyData) SetThreatCount(v int64) *DescribePdnsAccountSummaryResponseBodyData {
	s.ThreatCount = &v
	return s
}

func (s *DescribePdnsAccountSummaryResponseBodyData) SetTotalCount(v int64) *DescribePdnsAccountSummaryResponseBodyData {
	s.TotalCount = &v
	return s
}

func (s *DescribePdnsAccountSummaryResponseBodyData) SetUserId(v int64) *DescribePdnsAccountSummaryResponseBodyData {
	s.UserId = &v
	return s
}

type DescribePdnsAccountSummaryResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePdnsAccountSummaryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePdnsAccountSummaryResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsAccountSummaryResponse) GoString() string {
	return s.String()
}

func (s *DescribePdnsAccountSummaryResponse) SetHeaders(v map[string]*string) *DescribePdnsAccountSummaryResponse {
	s.Headers = v
	return s
}

func (s *DescribePdnsAccountSummaryResponse) SetStatusCode(v int32) *DescribePdnsAccountSummaryResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePdnsAccountSummaryResponse) SetBody(v *DescribePdnsAccountSummaryResponseBody) *DescribePdnsAccountSummaryResponse {
	s.Body = v
	return s
}

type DescribePdnsAppKeyRequest struct {
	AppKeyId *string `json:"AppKeyId,omitempty" xml:"AppKeyId,omitempty"`
	Lang     *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DescribePdnsAppKeyRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsAppKeyRequest) GoString() string {
	return s.String()
}

func (s *DescribePdnsAppKeyRequest) SetAppKeyId(v string) *DescribePdnsAppKeyRequest {
	s.AppKeyId = &v
	return s
}

func (s *DescribePdnsAppKeyRequest) SetLang(v string) *DescribePdnsAppKeyRequest {
	s.Lang = &v
	return s
}

type DescribePdnsAppKeyResponseBody struct {
	AppKey    *DescribePdnsAppKeyResponseBodyAppKey `json:"AppKey,omitempty" xml:"AppKey,omitempty" type:"Struct"`
	RequestId *string                               `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribePdnsAppKeyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsAppKeyResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePdnsAppKeyResponseBody) SetAppKey(v *DescribePdnsAppKeyResponseBodyAppKey) *DescribePdnsAppKeyResponseBody {
	s.AppKey = v
	return s
}

func (s *DescribePdnsAppKeyResponseBody) SetRequestId(v string) *DescribePdnsAppKeyResponseBody {
	s.RequestId = &v
	return s
}

type DescribePdnsAppKeyResponseBodyAppKey struct {
	AppKeyId     *string `json:"AppKeyId,omitempty" xml:"AppKeyId,omitempty"`
	AppKeySecret *string `json:"AppKeySecret,omitempty" xml:"AppKeySecret,omitempty"`
	CreateDate   *string `json:"CreateDate,omitempty" xml:"CreateDate,omitempty"`
	State        *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s DescribePdnsAppKeyResponseBodyAppKey) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsAppKeyResponseBodyAppKey) GoString() string {
	return s.String()
}

func (s *DescribePdnsAppKeyResponseBodyAppKey) SetAppKeyId(v string) *DescribePdnsAppKeyResponseBodyAppKey {
	s.AppKeyId = &v
	return s
}

func (s *DescribePdnsAppKeyResponseBodyAppKey) SetAppKeySecret(v string) *DescribePdnsAppKeyResponseBodyAppKey {
	s.AppKeySecret = &v
	return s
}

func (s *DescribePdnsAppKeyResponseBodyAppKey) SetCreateDate(v string) *DescribePdnsAppKeyResponseBodyAppKey {
	s.CreateDate = &v
	return s
}

func (s *DescribePdnsAppKeyResponseBodyAppKey) SetState(v string) *DescribePdnsAppKeyResponseBodyAppKey {
	s.State = &v
	return s
}

type DescribePdnsAppKeyResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePdnsAppKeyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePdnsAppKeyResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsAppKeyResponse) GoString() string {
	return s.String()
}

func (s *DescribePdnsAppKeyResponse) SetHeaders(v map[string]*string) *DescribePdnsAppKeyResponse {
	s.Headers = v
	return s
}

func (s *DescribePdnsAppKeyResponse) SetStatusCode(v int32) *DescribePdnsAppKeyResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePdnsAppKeyResponse) SetBody(v *DescribePdnsAppKeyResponseBody) *DescribePdnsAppKeyResponse {
	s.Body = v
	return s
}

type DescribePdnsAppKeysRequest struct {
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DescribePdnsAppKeysRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsAppKeysRequest) GoString() string {
	return s.String()
}

func (s *DescribePdnsAppKeysRequest) SetLang(v string) *DescribePdnsAppKeysRequest {
	s.Lang = &v
	return s
}

type DescribePdnsAppKeysResponseBody struct {
	AppKeys   []*DescribePdnsAppKeysResponseBodyAppKeys `json:"AppKeys,omitempty" xml:"AppKeys,omitempty" type:"Repeated"`
	RequestId *string                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribePdnsAppKeysResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsAppKeysResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePdnsAppKeysResponseBody) SetAppKeys(v []*DescribePdnsAppKeysResponseBodyAppKeys) *DescribePdnsAppKeysResponseBody {
	s.AppKeys = v
	return s
}

func (s *DescribePdnsAppKeysResponseBody) SetRequestId(v string) *DescribePdnsAppKeysResponseBody {
	s.RequestId = &v
	return s
}

type DescribePdnsAppKeysResponseBodyAppKeys struct {
	AppKeyId   *string `json:"AppKeyId,omitempty" xml:"AppKeyId,omitempty"`
	CreateDate *string `json:"CreateDate,omitempty" xml:"CreateDate,omitempty"`
	State      *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s DescribePdnsAppKeysResponseBodyAppKeys) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsAppKeysResponseBodyAppKeys) GoString() string {
	return s.String()
}

func (s *DescribePdnsAppKeysResponseBodyAppKeys) SetAppKeyId(v string) *DescribePdnsAppKeysResponseBodyAppKeys {
	s.AppKeyId = &v
	return s
}

func (s *DescribePdnsAppKeysResponseBodyAppKeys) SetCreateDate(v string) *DescribePdnsAppKeysResponseBodyAppKeys {
	s.CreateDate = &v
	return s
}

func (s *DescribePdnsAppKeysResponseBodyAppKeys) SetState(v string) *DescribePdnsAppKeysResponseBodyAppKeys {
	s.State = &v
	return s
}

type DescribePdnsAppKeysResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePdnsAppKeysResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePdnsAppKeysResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsAppKeysResponse) GoString() string {
	return s.String()
}

func (s *DescribePdnsAppKeysResponse) SetHeaders(v map[string]*string) *DescribePdnsAppKeysResponse {
	s.Headers = v
	return s
}

func (s *DescribePdnsAppKeysResponse) SetStatusCode(v int32) *DescribePdnsAppKeysResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePdnsAppKeysResponse) SetBody(v *DescribePdnsAppKeysResponseBody) *DescribePdnsAppKeysResponse {
	s.Body = v
	return s
}

type DescribePdnsOperateLogsRequest struct {
	ActionType *string `json:"ActionType,omitempty" xml:"ActionType,omitempty"`
	EndDate    *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	Keyword    *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	Lang       *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	PageNumber *int64  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int64  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	StartDate  *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
}

func (s DescribePdnsOperateLogsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsOperateLogsRequest) GoString() string {
	return s.String()
}

func (s *DescribePdnsOperateLogsRequest) SetActionType(v string) *DescribePdnsOperateLogsRequest {
	s.ActionType = &v
	return s
}

func (s *DescribePdnsOperateLogsRequest) SetEndDate(v string) *DescribePdnsOperateLogsRequest {
	s.EndDate = &v
	return s
}

func (s *DescribePdnsOperateLogsRequest) SetKeyword(v string) *DescribePdnsOperateLogsRequest {
	s.Keyword = &v
	return s
}

func (s *DescribePdnsOperateLogsRequest) SetLang(v string) *DescribePdnsOperateLogsRequest {
	s.Lang = &v
	return s
}

func (s *DescribePdnsOperateLogsRequest) SetPageNumber(v int64) *DescribePdnsOperateLogsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribePdnsOperateLogsRequest) SetPageSize(v int64) *DescribePdnsOperateLogsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribePdnsOperateLogsRequest) SetStartDate(v string) *DescribePdnsOperateLogsRequest {
	s.StartDate = &v
	return s
}

type DescribePdnsOperateLogsResponseBody struct {
	Logs       []*DescribePdnsOperateLogsResponseBodyLogs `json:"Logs,omitempty" xml:"Logs,omitempty" type:"Repeated"`
	PageNumber *int64                                     `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int64                                     `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RequestId  *string                                    `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount *int64                                     `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribePdnsOperateLogsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsOperateLogsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePdnsOperateLogsResponseBody) SetLogs(v []*DescribePdnsOperateLogsResponseBodyLogs) *DescribePdnsOperateLogsResponseBody {
	s.Logs = v
	return s
}

func (s *DescribePdnsOperateLogsResponseBody) SetPageNumber(v int64) *DescribePdnsOperateLogsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribePdnsOperateLogsResponseBody) SetPageSize(v int64) *DescribePdnsOperateLogsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribePdnsOperateLogsResponseBody) SetRequestId(v string) *DescribePdnsOperateLogsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePdnsOperateLogsResponseBody) SetTotalCount(v int64) *DescribePdnsOperateLogsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribePdnsOperateLogsResponseBodyLogs struct {
	Action      *string `json:"Action,omitempty" xml:"Action,omitempty"`
	OperateTime *string `json:"OperateTime,omitempty" xml:"OperateTime,omitempty"`
	Type        *string `json:"Type,omitempty" xml:"Type,omitempty"`
	Content     *string `json:"content,omitempty" xml:"content,omitempty"`
}

func (s DescribePdnsOperateLogsResponseBodyLogs) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsOperateLogsResponseBodyLogs) GoString() string {
	return s.String()
}

func (s *DescribePdnsOperateLogsResponseBodyLogs) SetAction(v string) *DescribePdnsOperateLogsResponseBodyLogs {
	s.Action = &v
	return s
}

func (s *DescribePdnsOperateLogsResponseBodyLogs) SetOperateTime(v string) *DescribePdnsOperateLogsResponseBodyLogs {
	s.OperateTime = &v
	return s
}

func (s *DescribePdnsOperateLogsResponseBodyLogs) SetType(v string) *DescribePdnsOperateLogsResponseBodyLogs {
	s.Type = &v
	return s
}

func (s *DescribePdnsOperateLogsResponseBodyLogs) SetContent(v string) *DescribePdnsOperateLogsResponseBodyLogs {
	s.Content = &v
	return s
}

type DescribePdnsOperateLogsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePdnsOperateLogsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePdnsOperateLogsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsOperateLogsResponse) GoString() string {
	return s.String()
}

func (s *DescribePdnsOperateLogsResponse) SetHeaders(v map[string]*string) *DescribePdnsOperateLogsResponse {
	s.Headers = v
	return s
}

func (s *DescribePdnsOperateLogsResponse) SetStatusCode(v int32) *DescribePdnsOperateLogsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePdnsOperateLogsResponse) SetBody(v *DescribePdnsOperateLogsResponseBody) *DescribePdnsOperateLogsResponse {
	s.Body = v
	return s
}

type DescribePdnsRequestStatisticRequest struct {
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	EndDate    *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	Lang       *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	StartDate  *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
	SubDomain  *string `json:"SubDomain,omitempty" xml:"SubDomain,omitempty"`
}

func (s DescribePdnsRequestStatisticRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsRequestStatisticRequest) GoString() string {
	return s.String()
}

func (s *DescribePdnsRequestStatisticRequest) SetDomainName(v string) *DescribePdnsRequestStatisticRequest {
	s.DomainName = &v
	return s
}

func (s *DescribePdnsRequestStatisticRequest) SetEndDate(v string) *DescribePdnsRequestStatisticRequest {
	s.EndDate = &v
	return s
}

func (s *DescribePdnsRequestStatisticRequest) SetLang(v string) *DescribePdnsRequestStatisticRequest {
	s.Lang = &v
	return s
}

func (s *DescribePdnsRequestStatisticRequest) SetStartDate(v string) *DescribePdnsRequestStatisticRequest {
	s.StartDate = &v
	return s
}

func (s *DescribePdnsRequestStatisticRequest) SetSubDomain(v string) *DescribePdnsRequestStatisticRequest {
	s.SubDomain = &v
	return s
}

type DescribePdnsRequestStatisticResponseBody struct {
	Data      []*DescribePdnsRequestStatisticResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	RequestId *string                                         `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribePdnsRequestStatisticResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsRequestStatisticResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePdnsRequestStatisticResponseBody) SetData(v []*DescribePdnsRequestStatisticResponseBodyData) *DescribePdnsRequestStatisticResponseBody {
	s.Data = v
	return s
}

func (s *DescribePdnsRequestStatisticResponseBody) SetRequestId(v string) *DescribePdnsRequestStatisticResponseBody {
	s.RequestId = &v
	return s
}

type DescribePdnsRequestStatisticResponseBodyData struct {
	DohTotalCount *int64 `json:"DohTotalCount,omitempty" xml:"DohTotalCount,omitempty"`
	HttpCount     *int64 `json:"HttpCount,omitempty" xml:"HttpCount,omitempty"`
	HttpsCount    *int64 `json:"HttpsCount,omitempty" xml:"HttpsCount,omitempty"`
	IpCount       *int64 `json:"IpCount,omitempty" xml:"IpCount,omitempty"`
	Timestamp     *int64 `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	TotalCount    *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	UdpTotalCount *int64 `json:"UdpTotalCount,omitempty" xml:"UdpTotalCount,omitempty"`
	V4Count       *int64 `json:"V4Count,omitempty" xml:"V4Count,omitempty"`
	V4HttpCount   *int64 `json:"V4HttpCount,omitempty" xml:"V4HttpCount,omitempty"`
	V4HttpsCount  *int64 `json:"V4HttpsCount,omitempty" xml:"V4HttpsCount,omitempty"`
	V6Count       *int64 `json:"V6Count,omitempty" xml:"V6Count,omitempty"`
	V6HttpCount   *int64 `json:"V6HttpCount,omitempty" xml:"V6HttpCount,omitempty"`
	V6HttpsCount  *int64 `json:"V6HttpsCount,omitempty" xml:"V6HttpsCount,omitempty"`
}

func (s DescribePdnsRequestStatisticResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsRequestStatisticResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribePdnsRequestStatisticResponseBodyData) SetDohTotalCount(v int64) *DescribePdnsRequestStatisticResponseBodyData {
	s.DohTotalCount = &v
	return s
}

func (s *DescribePdnsRequestStatisticResponseBodyData) SetHttpCount(v int64) *DescribePdnsRequestStatisticResponseBodyData {
	s.HttpCount = &v
	return s
}

func (s *DescribePdnsRequestStatisticResponseBodyData) SetHttpsCount(v int64) *DescribePdnsRequestStatisticResponseBodyData {
	s.HttpsCount = &v
	return s
}

func (s *DescribePdnsRequestStatisticResponseBodyData) SetIpCount(v int64) *DescribePdnsRequestStatisticResponseBodyData {
	s.IpCount = &v
	return s
}

func (s *DescribePdnsRequestStatisticResponseBodyData) SetTimestamp(v int64) *DescribePdnsRequestStatisticResponseBodyData {
	s.Timestamp = &v
	return s
}

func (s *DescribePdnsRequestStatisticResponseBodyData) SetTotalCount(v int64) *DescribePdnsRequestStatisticResponseBodyData {
	s.TotalCount = &v
	return s
}

func (s *DescribePdnsRequestStatisticResponseBodyData) SetUdpTotalCount(v int64) *DescribePdnsRequestStatisticResponseBodyData {
	s.UdpTotalCount = &v
	return s
}

func (s *DescribePdnsRequestStatisticResponseBodyData) SetV4Count(v int64) *DescribePdnsRequestStatisticResponseBodyData {
	s.V4Count = &v
	return s
}

func (s *DescribePdnsRequestStatisticResponseBodyData) SetV4HttpCount(v int64) *DescribePdnsRequestStatisticResponseBodyData {
	s.V4HttpCount = &v
	return s
}

func (s *DescribePdnsRequestStatisticResponseBodyData) SetV4HttpsCount(v int64) *DescribePdnsRequestStatisticResponseBodyData {
	s.V4HttpsCount = &v
	return s
}

func (s *DescribePdnsRequestStatisticResponseBodyData) SetV6Count(v int64) *DescribePdnsRequestStatisticResponseBodyData {
	s.V6Count = &v
	return s
}

func (s *DescribePdnsRequestStatisticResponseBodyData) SetV6HttpCount(v int64) *DescribePdnsRequestStatisticResponseBodyData {
	s.V6HttpCount = &v
	return s
}

func (s *DescribePdnsRequestStatisticResponseBodyData) SetV6HttpsCount(v int64) *DescribePdnsRequestStatisticResponseBodyData {
	s.V6HttpsCount = &v
	return s
}

type DescribePdnsRequestStatisticResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePdnsRequestStatisticResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePdnsRequestStatisticResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsRequestStatisticResponse) GoString() string {
	return s.String()
}

func (s *DescribePdnsRequestStatisticResponse) SetHeaders(v map[string]*string) *DescribePdnsRequestStatisticResponse {
	s.Headers = v
	return s
}

func (s *DescribePdnsRequestStatisticResponse) SetStatusCode(v int32) *DescribePdnsRequestStatisticResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePdnsRequestStatisticResponse) SetBody(v *DescribePdnsRequestStatisticResponseBody) *DescribePdnsRequestStatisticResponse {
	s.Body = v
	return s
}

type DescribePdnsRequestStatisticsRequest struct {
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	EndDate    *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	Lang       *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	PageNumber *int64  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int64  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	StartDate  *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
	SubDomain  *string `json:"SubDomain,omitempty" xml:"SubDomain,omitempty"`
	Type       *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribePdnsRequestStatisticsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsRequestStatisticsRequest) GoString() string {
	return s.String()
}

func (s *DescribePdnsRequestStatisticsRequest) SetDomainName(v string) *DescribePdnsRequestStatisticsRequest {
	s.DomainName = &v
	return s
}

func (s *DescribePdnsRequestStatisticsRequest) SetEndDate(v string) *DescribePdnsRequestStatisticsRequest {
	s.EndDate = &v
	return s
}

func (s *DescribePdnsRequestStatisticsRequest) SetLang(v string) *DescribePdnsRequestStatisticsRequest {
	s.Lang = &v
	return s
}

func (s *DescribePdnsRequestStatisticsRequest) SetPageNumber(v int64) *DescribePdnsRequestStatisticsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribePdnsRequestStatisticsRequest) SetPageSize(v int64) *DescribePdnsRequestStatisticsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribePdnsRequestStatisticsRequest) SetStartDate(v string) *DescribePdnsRequestStatisticsRequest {
	s.StartDate = &v
	return s
}

func (s *DescribePdnsRequestStatisticsRequest) SetSubDomain(v string) *DescribePdnsRequestStatisticsRequest {
	s.SubDomain = &v
	return s
}

func (s *DescribePdnsRequestStatisticsRequest) SetType(v string) *DescribePdnsRequestStatisticsRequest {
	s.Type = &v
	return s
}

type DescribePdnsRequestStatisticsResponseBody struct {
	Data       []*DescribePdnsRequestStatisticsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	PageNumber *int64                                           `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int64                                           `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RequestId  *string                                          `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount *int64                                           `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribePdnsRequestStatisticsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsRequestStatisticsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePdnsRequestStatisticsResponseBody) SetData(v []*DescribePdnsRequestStatisticsResponseBodyData) *DescribePdnsRequestStatisticsResponseBody {
	s.Data = v
	return s
}

func (s *DescribePdnsRequestStatisticsResponseBody) SetPageNumber(v int64) *DescribePdnsRequestStatisticsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribePdnsRequestStatisticsResponseBody) SetPageSize(v int64) *DescribePdnsRequestStatisticsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribePdnsRequestStatisticsResponseBody) SetRequestId(v string) *DescribePdnsRequestStatisticsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePdnsRequestStatisticsResponseBody) SetTotalCount(v int64) *DescribePdnsRequestStatisticsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribePdnsRequestStatisticsResponseBodyData struct {
	DohTotalCount  *int64                                                     `json:"DohTotalCount,omitempty" xml:"DohTotalCount,omitempty"`
	DomainName     *string                                                    `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	HttpCount      *int64                                                     `json:"HttpCount,omitempty" xml:"HttpCount,omitempty"`
	HttpsCount     *int64                                                     `json:"HttpsCount,omitempty" xml:"HttpsCount,omitempty"`
	IpCount        *int64                                                     `json:"IpCount,omitempty" xml:"IpCount,omitempty"`
	MaxThreatLevel *string                                                    `json:"MaxThreatLevel,omitempty" xml:"MaxThreatLevel,omitempty"`
	SubDomain      *string                                                    `json:"SubDomain,omitempty" xml:"SubDomain,omitempty"`
	ThreatCount    *int64                                                     `json:"ThreatCount,omitempty" xml:"ThreatCount,omitempty"`
	ThreatInfo     []*DescribePdnsRequestStatisticsResponseBodyDataThreatInfo `json:"ThreatInfo,omitempty" xml:"ThreatInfo,omitempty" type:"Repeated"`
	TotalCount     *int64                                                     `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	UdpTotalCount  *int64                                                     `json:"UdpTotalCount,omitempty" xml:"UdpTotalCount,omitempty"`
	V4Count        *int64                                                     `json:"V4Count,omitempty" xml:"V4Count,omitempty"`
	V4HttpCount    *int64                                                     `json:"V4HttpCount,omitempty" xml:"V4HttpCount,omitempty"`
	V4HttpsCount   *int64                                                     `json:"V4HttpsCount,omitempty" xml:"V4HttpsCount,omitempty"`
	V6Count        *int64                                                     `json:"V6Count,omitempty" xml:"V6Count,omitempty"`
	V6HttpCount    *int64                                                     `json:"V6HttpCount,omitempty" xml:"V6HttpCount,omitempty"`
	V6HttpsCount   *int64                                                     `json:"V6HttpsCount,omitempty" xml:"V6HttpsCount,omitempty"`
}

func (s DescribePdnsRequestStatisticsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsRequestStatisticsResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribePdnsRequestStatisticsResponseBodyData) SetDohTotalCount(v int64) *DescribePdnsRequestStatisticsResponseBodyData {
	s.DohTotalCount = &v
	return s
}

func (s *DescribePdnsRequestStatisticsResponseBodyData) SetDomainName(v string) *DescribePdnsRequestStatisticsResponseBodyData {
	s.DomainName = &v
	return s
}

func (s *DescribePdnsRequestStatisticsResponseBodyData) SetHttpCount(v int64) *DescribePdnsRequestStatisticsResponseBodyData {
	s.HttpCount = &v
	return s
}

func (s *DescribePdnsRequestStatisticsResponseBodyData) SetHttpsCount(v int64) *DescribePdnsRequestStatisticsResponseBodyData {
	s.HttpsCount = &v
	return s
}

func (s *DescribePdnsRequestStatisticsResponseBodyData) SetIpCount(v int64) *DescribePdnsRequestStatisticsResponseBodyData {
	s.IpCount = &v
	return s
}

func (s *DescribePdnsRequestStatisticsResponseBodyData) SetMaxThreatLevel(v string) *DescribePdnsRequestStatisticsResponseBodyData {
	s.MaxThreatLevel = &v
	return s
}

func (s *DescribePdnsRequestStatisticsResponseBodyData) SetSubDomain(v string) *DescribePdnsRequestStatisticsResponseBodyData {
	s.SubDomain = &v
	return s
}

func (s *DescribePdnsRequestStatisticsResponseBodyData) SetThreatCount(v int64) *DescribePdnsRequestStatisticsResponseBodyData {
	s.ThreatCount = &v
	return s
}

func (s *DescribePdnsRequestStatisticsResponseBodyData) SetThreatInfo(v []*DescribePdnsRequestStatisticsResponseBodyDataThreatInfo) *DescribePdnsRequestStatisticsResponseBodyData {
	s.ThreatInfo = v
	return s
}

func (s *DescribePdnsRequestStatisticsResponseBodyData) SetTotalCount(v int64) *DescribePdnsRequestStatisticsResponseBodyData {
	s.TotalCount = &v
	return s
}

func (s *DescribePdnsRequestStatisticsResponseBodyData) SetUdpTotalCount(v int64) *DescribePdnsRequestStatisticsResponseBodyData {
	s.UdpTotalCount = &v
	return s
}

func (s *DescribePdnsRequestStatisticsResponseBodyData) SetV4Count(v int64) *DescribePdnsRequestStatisticsResponseBodyData {
	s.V4Count = &v
	return s
}

func (s *DescribePdnsRequestStatisticsResponseBodyData) SetV4HttpCount(v int64) *DescribePdnsRequestStatisticsResponseBodyData {
	s.V4HttpCount = &v
	return s
}

func (s *DescribePdnsRequestStatisticsResponseBodyData) SetV4HttpsCount(v int64) *DescribePdnsRequestStatisticsResponseBodyData {
	s.V4HttpsCount = &v
	return s
}

func (s *DescribePdnsRequestStatisticsResponseBodyData) SetV6Count(v int64) *DescribePdnsRequestStatisticsResponseBodyData {
	s.V6Count = &v
	return s
}

func (s *DescribePdnsRequestStatisticsResponseBodyData) SetV6HttpCount(v int64) *DescribePdnsRequestStatisticsResponseBodyData {
	s.V6HttpCount = &v
	return s
}

func (s *DescribePdnsRequestStatisticsResponseBodyData) SetV6HttpsCount(v int64) *DescribePdnsRequestStatisticsResponseBodyData {
	s.V6HttpsCount = &v
	return s
}

type DescribePdnsRequestStatisticsResponseBodyDataThreatInfo struct {
	ThreatLevel *string `json:"ThreatLevel,omitempty" xml:"ThreatLevel,omitempty"`
	ThreatType  *string `json:"ThreatType,omitempty" xml:"ThreatType,omitempty"`
}

func (s DescribePdnsRequestStatisticsResponseBodyDataThreatInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsRequestStatisticsResponseBodyDataThreatInfo) GoString() string {
	return s.String()
}

func (s *DescribePdnsRequestStatisticsResponseBodyDataThreatInfo) SetThreatLevel(v string) *DescribePdnsRequestStatisticsResponseBodyDataThreatInfo {
	s.ThreatLevel = &v
	return s
}

func (s *DescribePdnsRequestStatisticsResponseBodyDataThreatInfo) SetThreatType(v string) *DescribePdnsRequestStatisticsResponseBodyDataThreatInfo {
	s.ThreatType = &v
	return s
}

type DescribePdnsRequestStatisticsResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePdnsRequestStatisticsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePdnsRequestStatisticsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsRequestStatisticsResponse) GoString() string {
	return s.String()
}

func (s *DescribePdnsRequestStatisticsResponse) SetHeaders(v map[string]*string) *DescribePdnsRequestStatisticsResponse {
	s.Headers = v
	return s
}

func (s *DescribePdnsRequestStatisticsResponse) SetStatusCode(v int32) *DescribePdnsRequestStatisticsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePdnsRequestStatisticsResponse) SetBody(v *DescribePdnsRequestStatisticsResponseBody) *DescribePdnsRequestStatisticsResponse {
	s.Body = v
	return s
}

type DescribePdnsThreatLogsRequest struct {
	EndDate        *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	Keyword        *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	Lang           *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	PageNumber     *int64  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize       *int64  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	StartDate      *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
	ThreatLevel    *string `json:"ThreatLevel,omitempty" xml:"ThreatLevel,omitempty"`
	ThreatSourceIp *string `json:"ThreatSourceIp,omitempty" xml:"ThreatSourceIp,omitempty"`
	ThreatType     *string `json:"ThreatType,omitempty" xml:"ThreatType,omitempty"`
}

func (s DescribePdnsThreatLogsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsThreatLogsRequest) GoString() string {
	return s.String()
}

func (s *DescribePdnsThreatLogsRequest) SetEndDate(v string) *DescribePdnsThreatLogsRequest {
	s.EndDate = &v
	return s
}

func (s *DescribePdnsThreatLogsRequest) SetKeyword(v string) *DescribePdnsThreatLogsRequest {
	s.Keyword = &v
	return s
}

func (s *DescribePdnsThreatLogsRequest) SetLang(v string) *DescribePdnsThreatLogsRequest {
	s.Lang = &v
	return s
}

func (s *DescribePdnsThreatLogsRequest) SetPageNumber(v int64) *DescribePdnsThreatLogsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribePdnsThreatLogsRequest) SetPageSize(v int64) *DescribePdnsThreatLogsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribePdnsThreatLogsRequest) SetStartDate(v string) *DescribePdnsThreatLogsRequest {
	s.StartDate = &v
	return s
}

func (s *DescribePdnsThreatLogsRequest) SetThreatLevel(v string) *DescribePdnsThreatLogsRequest {
	s.ThreatLevel = &v
	return s
}

func (s *DescribePdnsThreatLogsRequest) SetThreatSourceIp(v string) *DescribePdnsThreatLogsRequest {
	s.ThreatSourceIp = &v
	return s
}

func (s *DescribePdnsThreatLogsRequest) SetThreatType(v string) *DescribePdnsThreatLogsRequest {
	s.ThreatType = &v
	return s
}

type DescribePdnsThreatLogsResponseBody struct {
	Logs       []*DescribePdnsThreatLogsResponseBodyLogs `json:"Logs,omitempty" xml:"Logs,omitempty" type:"Repeated"`
	PageNumber *int64                                    `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int64                                    `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RequestId  *string                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount *int64                                    `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribePdnsThreatLogsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsThreatLogsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePdnsThreatLogsResponseBody) SetLogs(v []*DescribePdnsThreatLogsResponseBodyLogs) *DescribePdnsThreatLogsResponseBody {
	s.Logs = v
	return s
}

func (s *DescribePdnsThreatLogsResponseBody) SetPageNumber(v int64) *DescribePdnsThreatLogsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribePdnsThreatLogsResponseBody) SetPageSize(v int64) *DescribePdnsThreatLogsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribePdnsThreatLogsResponseBody) SetRequestId(v string) *DescribePdnsThreatLogsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePdnsThreatLogsResponseBody) SetTotalCount(v int64) *DescribePdnsThreatLogsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribePdnsThreatLogsResponseBodyLogs struct {
	SourceIp    *string `json:"SourceIp,omitempty" xml:"SourceIp,omitempty"`
	SubDomain   *string `json:"SubDomain,omitempty" xml:"SubDomain,omitempty"`
	ThreatLevel *string `json:"ThreatLevel,omitempty" xml:"ThreatLevel,omitempty"`
	ThreatTime  *string `json:"ThreatTime,omitempty" xml:"ThreatTime,omitempty"`
	ThreatType  *string `json:"ThreatType,omitempty" xml:"ThreatType,omitempty"`
}

func (s DescribePdnsThreatLogsResponseBodyLogs) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsThreatLogsResponseBodyLogs) GoString() string {
	return s.String()
}

func (s *DescribePdnsThreatLogsResponseBodyLogs) SetSourceIp(v string) *DescribePdnsThreatLogsResponseBodyLogs {
	s.SourceIp = &v
	return s
}

func (s *DescribePdnsThreatLogsResponseBodyLogs) SetSubDomain(v string) *DescribePdnsThreatLogsResponseBodyLogs {
	s.SubDomain = &v
	return s
}

func (s *DescribePdnsThreatLogsResponseBodyLogs) SetThreatLevel(v string) *DescribePdnsThreatLogsResponseBodyLogs {
	s.ThreatLevel = &v
	return s
}

func (s *DescribePdnsThreatLogsResponseBodyLogs) SetThreatTime(v string) *DescribePdnsThreatLogsResponseBodyLogs {
	s.ThreatTime = &v
	return s
}

func (s *DescribePdnsThreatLogsResponseBodyLogs) SetThreatType(v string) *DescribePdnsThreatLogsResponseBodyLogs {
	s.ThreatType = &v
	return s
}

type DescribePdnsThreatLogsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePdnsThreatLogsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePdnsThreatLogsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsThreatLogsResponse) GoString() string {
	return s.String()
}

func (s *DescribePdnsThreatLogsResponse) SetHeaders(v map[string]*string) *DescribePdnsThreatLogsResponse {
	s.Headers = v
	return s
}

func (s *DescribePdnsThreatLogsResponse) SetStatusCode(v int32) *DescribePdnsThreatLogsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePdnsThreatLogsResponse) SetBody(v *DescribePdnsThreatLogsResponseBody) *DescribePdnsThreatLogsResponse {
	s.Body = v
	return s
}

type DescribePdnsThreatStatisticRequest struct {
	EndDate        *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	Lang           *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	StartDate      *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
	ThreatSourceIp *string `json:"ThreatSourceIp,omitempty" xml:"ThreatSourceIp,omitempty"`
}

func (s DescribePdnsThreatStatisticRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsThreatStatisticRequest) GoString() string {
	return s.String()
}

func (s *DescribePdnsThreatStatisticRequest) SetEndDate(v string) *DescribePdnsThreatStatisticRequest {
	s.EndDate = &v
	return s
}

func (s *DescribePdnsThreatStatisticRequest) SetLang(v string) *DescribePdnsThreatStatisticRequest {
	s.Lang = &v
	return s
}

func (s *DescribePdnsThreatStatisticRequest) SetStartDate(v string) *DescribePdnsThreatStatisticRequest {
	s.StartDate = &v
	return s
}

func (s *DescribePdnsThreatStatisticRequest) SetThreatSourceIp(v string) *DescribePdnsThreatStatisticRequest {
	s.ThreatSourceIp = &v
	return s
}

type DescribePdnsThreatStatisticResponseBody struct {
	Data      []*DescribePdnsThreatStatisticResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	RequestId *string                                        `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribePdnsThreatStatisticResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsThreatStatisticResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePdnsThreatStatisticResponseBody) SetData(v []*DescribePdnsThreatStatisticResponseBodyData) *DescribePdnsThreatStatisticResponseBody {
	s.Data = v
	return s
}

func (s *DescribePdnsThreatStatisticResponseBody) SetRequestId(v string) *DescribePdnsThreatStatisticResponseBody {
	s.RequestId = &v
	return s
}

type DescribePdnsThreatStatisticResponseBodyData struct {
	DohTotalCount *int64  `json:"DohTotalCount,omitempty" xml:"DohTotalCount,omitempty"`
	ThreatLevel   *string `json:"ThreatLevel,omitempty" xml:"ThreatLevel,omitempty"`
	ThreatType    *string `json:"ThreatType,omitempty" xml:"ThreatType,omitempty"`
	Timestamp     *int64  `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	TotalCount    *int64  `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	UdpTotalCount *int64  `json:"UdpTotalCount,omitempty" xml:"UdpTotalCount,omitempty"`
}

func (s DescribePdnsThreatStatisticResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsThreatStatisticResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribePdnsThreatStatisticResponseBodyData) SetDohTotalCount(v int64) *DescribePdnsThreatStatisticResponseBodyData {
	s.DohTotalCount = &v
	return s
}

func (s *DescribePdnsThreatStatisticResponseBodyData) SetThreatLevel(v string) *DescribePdnsThreatStatisticResponseBodyData {
	s.ThreatLevel = &v
	return s
}

func (s *DescribePdnsThreatStatisticResponseBodyData) SetThreatType(v string) *DescribePdnsThreatStatisticResponseBodyData {
	s.ThreatType = &v
	return s
}

func (s *DescribePdnsThreatStatisticResponseBodyData) SetTimestamp(v int64) *DescribePdnsThreatStatisticResponseBodyData {
	s.Timestamp = &v
	return s
}

func (s *DescribePdnsThreatStatisticResponseBodyData) SetTotalCount(v int64) *DescribePdnsThreatStatisticResponseBodyData {
	s.TotalCount = &v
	return s
}

func (s *DescribePdnsThreatStatisticResponseBodyData) SetUdpTotalCount(v int64) *DescribePdnsThreatStatisticResponseBodyData {
	s.UdpTotalCount = &v
	return s
}

type DescribePdnsThreatStatisticResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePdnsThreatStatisticResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePdnsThreatStatisticResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsThreatStatisticResponse) GoString() string {
	return s.String()
}

func (s *DescribePdnsThreatStatisticResponse) SetHeaders(v map[string]*string) *DescribePdnsThreatStatisticResponse {
	s.Headers = v
	return s
}

func (s *DescribePdnsThreatStatisticResponse) SetStatusCode(v int32) *DescribePdnsThreatStatisticResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePdnsThreatStatisticResponse) SetBody(v *DescribePdnsThreatStatisticResponseBody) *DescribePdnsThreatStatisticResponse {
	s.Body = v
	return s
}

type DescribePdnsThreatStatisticsRequest struct {
	Direction      *string `json:"Direction,omitempty" xml:"Direction,omitempty"`
	DomainName     *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	EndDate        *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	Lang           *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	OrderBy        *string `json:"OrderBy,omitempty" xml:"OrderBy,omitempty"`
	PageNumber     *int64  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize       *int64  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	StartDate      *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
	SubDomain      *string `json:"SubDomain,omitempty" xml:"SubDomain,omitempty"`
	ThreatLevel    *string `json:"ThreatLevel,omitempty" xml:"ThreatLevel,omitempty"`
	ThreatSourceIp *string `json:"ThreatSourceIp,omitempty" xml:"ThreatSourceIp,omitempty"`
	ThreatType     *string `json:"ThreatType,omitempty" xml:"ThreatType,omitempty"`
	Type           *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribePdnsThreatStatisticsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsThreatStatisticsRequest) GoString() string {
	return s.String()
}

func (s *DescribePdnsThreatStatisticsRequest) SetDirection(v string) *DescribePdnsThreatStatisticsRequest {
	s.Direction = &v
	return s
}

func (s *DescribePdnsThreatStatisticsRequest) SetDomainName(v string) *DescribePdnsThreatStatisticsRequest {
	s.DomainName = &v
	return s
}

func (s *DescribePdnsThreatStatisticsRequest) SetEndDate(v string) *DescribePdnsThreatStatisticsRequest {
	s.EndDate = &v
	return s
}

func (s *DescribePdnsThreatStatisticsRequest) SetLang(v string) *DescribePdnsThreatStatisticsRequest {
	s.Lang = &v
	return s
}

func (s *DescribePdnsThreatStatisticsRequest) SetOrderBy(v string) *DescribePdnsThreatStatisticsRequest {
	s.OrderBy = &v
	return s
}

func (s *DescribePdnsThreatStatisticsRequest) SetPageNumber(v int64) *DescribePdnsThreatStatisticsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribePdnsThreatStatisticsRequest) SetPageSize(v int64) *DescribePdnsThreatStatisticsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribePdnsThreatStatisticsRequest) SetStartDate(v string) *DescribePdnsThreatStatisticsRequest {
	s.StartDate = &v
	return s
}

func (s *DescribePdnsThreatStatisticsRequest) SetSubDomain(v string) *DescribePdnsThreatStatisticsRequest {
	s.SubDomain = &v
	return s
}

func (s *DescribePdnsThreatStatisticsRequest) SetThreatLevel(v string) *DescribePdnsThreatStatisticsRequest {
	s.ThreatLevel = &v
	return s
}

func (s *DescribePdnsThreatStatisticsRequest) SetThreatSourceIp(v string) *DescribePdnsThreatStatisticsRequest {
	s.ThreatSourceIp = &v
	return s
}

func (s *DescribePdnsThreatStatisticsRequest) SetThreatType(v string) *DescribePdnsThreatStatisticsRequest {
	s.ThreatType = &v
	return s
}

func (s *DescribePdnsThreatStatisticsRequest) SetType(v string) *DescribePdnsThreatStatisticsRequest {
	s.Type = &v
	return s
}

type DescribePdnsThreatStatisticsResponseBody struct {
	Data       []*DescribePdnsThreatStatisticsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	PageNumber *int64                                          `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int64                                          `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RequestId  *string                                         `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount *int64                                          `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribePdnsThreatStatisticsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsThreatStatisticsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePdnsThreatStatisticsResponseBody) SetData(v []*DescribePdnsThreatStatisticsResponseBodyData) *DescribePdnsThreatStatisticsResponseBody {
	s.Data = v
	return s
}

func (s *DescribePdnsThreatStatisticsResponseBody) SetPageNumber(v int64) *DescribePdnsThreatStatisticsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribePdnsThreatStatisticsResponseBody) SetPageSize(v int64) *DescribePdnsThreatStatisticsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribePdnsThreatStatisticsResponseBody) SetRequestId(v string) *DescribePdnsThreatStatisticsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePdnsThreatStatisticsResponseBody) SetTotalCount(v int64) *DescribePdnsThreatStatisticsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribePdnsThreatStatisticsResponseBodyData struct {
	DohTotalCount    *int64  `json:"DohTotalCount,omitempty" xml:"DohTotalCount,omitempty"`
	DomainCount      *int64  `json:"DomainCount,omitempty" xml:"DomainCount,omitempty"`
	DomainName       *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	LatestThreatTime *int64  `json:"LatestThreatTime,omitempty" xml:"LatestThreatTime,omitempty"`
	MaxThreatLevel   *string `json:"MaxThreatLevel,omitempty" xml:"MaxThreatLevel,omitempty"`
	SourceIp         *string `json:"SourceIp,omitempty" xml:"SourceIp,omitempty"`
	SubDomain        *string `json:"SubDomain,omitempty" xml:"SubDomain,omitempty"`
	ThreatLevel      *string `json:"ThreatLevel,omitempty" xml:"ThreatLevel,omitempty"`
	ThreatType       *string `json:"ThreatType,omitempty" xml:"ThreatType,omitempty"`
	TotalCount       *int64  `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	UdpTotalCount    *int64  `json:"UdpTotalCount,omitempty" xml:"UdpTotalCount,omitempty"`
}

func (s DescribePdnsThreatStatisticsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsThreatStatisticsResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribePdnsThreatStatisticsResponseBodyData) SetDohTotalCount(v int64) *DescribePdnsThreatStatisticsResponseBodyData {
	s.DohTotalCount = &v
	return s
}

func (s *DescribePdnsThreatStatisticsResponseBodyData) SetDomainCount(v int64) *DescribePdnsThreatStatisticsResponseBodyData {
	s.DomainCount = &v
	return s
}

func (s *DescribePdnsThreatStatisticsResponseBodyData) SetDomainName(v string) *DescribePdnsThreatStatisticsResponseBodyData {
	s.DomainName = &v
	return s
}

func (s *DescribePdnsThreatStatisticsResponseBodyData) SetLatestThreatTime(v int64) *DescribePdnsThreatStatisticsResponseBodyData {
	s.LatestThreatTime = &v
	return s
}

func (s *DescribePdnsThreatStatisticsResponseBodyData) SetMaxThreatLevel(v string) *DescribePdnsThreatStatisticsResponseBodyData {
	s.MaxThreatLevel = &v
	return s
}

func (s *DescribePdnsThreatStatisticsResponseBodyData) SetSourceIp(v string) *DescribePdnsThreatStatisticsResponseBodyData {
	s.SourceIp = &v
	return s
}

func (s *DescribePdnsThreatStatisticsResponseBodyData) SetSubDomain(v string) *DescribePdnsThreatStatisticsResponseBodyData {
	s.SubDomain = &v
	return s
}

func (s *DescribePdnsThreatStatisticsResponseBodyData) SetThreatLevel(v string) *DescribePdnsThreatStatisticsResponseBodyData {
	s.ThreatLevel = &v
	return s
}

func (s *DescribePdnsThreatStatisticsResponseBodyData) SetThreatType(v string) *DescribePdnsThreatStatisticsResponseBodyData {
	s.ThreatType = &v
	return s
}

func (s *DescribePdnsThreatStatisticsResponseBodyData) SetTotalCount(v int64) *DescribePdnsThreatStatisticsResponseBodyData {
	s.TotalCount = &v
	return s
}

func (s *DescribePdnsThreatStatisticsResponseBodyData) SetUdpTotalCount(v int64) *DescribePdnsThreatStatisticsResponseBodyData {
	s.UdpTotalCount = &v
	return s
}

type DescribePdnsThreatStatisticsResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePdnsThreatStatisticsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePdnsThreatStatisticsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsThreatStatisticsResponse) GoString() string {
	return s.String()
}

func (s *DescribePdnsThreatStatisticsResponse) SetHeaders(v map[string]*string) *DescribePdnsThreatStatisticsResponse {
	s.Headers = v
	return s
}

func (s *DescribePdnsThreatStatisticsResponse) SetStatusCode(v int32) *DescribePdnsThreatStatisticsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePdnsThreatStatisticsResponse) SetBody(v *DescribePdnsThreatStatisticsResponseBody) *DescribePdnsThreatStatisticsResponse {
	s.Body = v
	return s
}

type DescribePdnsUdpIpSegmentsRequest struct {
	Lang       *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	PageNumber *int64  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int64  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribePdnsUdpIpSegmentsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsUdpIpSegmentsRequest) GoString() string {
	return s.String()
}

func (s *DescribePdnsUdpIpSegmentsRequest) SetLang(v string) *DescribePdnsUdpIpSegmentsRequest {
	s.Lang = &v
	return s
}

func (s *DescribePdnsUdpIpSegmentsRequest) SetPageNumber(v int64) *DescribePdnsUdpIpSegmentsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribePdnsUdpIpSegmentsRequest) SetPageSize(v int64) *DescribePdnsUdpIpSegmentsRequest {
	s.PageSize = &v
	return s
}

type DescribePdnsUdpIpSegmentsResponseBody struct {
	IpSegments []*DescribePdnsUdpIpSegmentsResponseBodyIpSegments `json:"IpSegments,omitempty" xml:"IpSegments,omitempty" type:"Repeated"`
	PageNumber *int64                                             `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int64                                             `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RequestId  *string                                            `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount *int64                                             `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribePdnsUdpIpSegmentsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsUdpIpSegmentsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePdnsUdpIpSegmentsResponseBody) SetIpSegments(v []*DescribePdnsUdpIpSegmentsResponseBodyIpSegments) *DescribePdnsUdpIpSegmentsResponseBody {
	s.IpSegments = v
	return s
}

func (s *DescribePdnsUdpIpSegmentsResponseBody) SetPageNumber(v int64) *DescribePdnsUdpIpSegmentsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribePdnsUdpIpSegmentsResponseBody) SetPageSize(v int64) *DescribePdnsUdpIpSegmentsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribePdnsUdpIpSegmentsResponseBody) SetRequestId(v string) *DescribePdnsUdpIpSegmentsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePdnsUdpIpSegmentsResponseBody) SetTotalCount(v int64) *DescribePdnsUdpIpSegmentsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribePdnsUdpIpSegmentsResponseBodyIpSegments struct {
	CreateDate *string `json:"CreateDate,omitempty" xml:"CreateDate,omitempty"`
	Ip         *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	Mask       *int64  `json:"Mask,omitempty" xml:"Mask,omitempty"`
	Name       *string `json:"Name,omitempty" xml:"Name,omitempty"`
	State      *string `json:"State,omitempty" xml:"State,omitempty"`
	UpdateDate *string `json:"UpdateDate,omitempty" xml:"UpdateDate,omitempty"`
}

func (s DescribePdnsUdpIpSegmentsResponseBodyIpSegments) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsUdpIpSegmentsResponseBodyIpSegments) GoString() string {
	return s.String()
}

func (s *DescribePdnsUdpIpSegmentsResponseBodyIpSegments) SetCreateDate(v string) *DescribePdnsUdpIpSegmentsResponseBodyIpSegments {
	s.CreateDate = &v
	return s
}

func (s *DescribePdnsUdpIpSegmentsResponseBodyIpSegments) SetIp(v string) *DescribePdnsUdpIpSegmentsResponseBodyIpSegments {
	s.Ip = &v
	return s
}

func (s *DescribePdnsUdpIpSegmentsResponseBodyIpSegments) SetMask(v int64) *DescribePdnsUdpIpSegmentsResponseBodyIpSegments {
	s.Mask = &v
	return s
}

func (s *DescribePdnsUdpIpSegmentsResponseBodyIpSegments) SetName(v string) *DescribePdnsUdpIpSegmentsResponseBodyIpSegments {
	s.Name = &v
	return s
}

func (s *DescribePdnsUdpIpSegmentsResponseBodyIpSegments) SetState(v string) *DescribePdnsUdpIpSegmentsResponseBodyIpSegments {
	s.State = &v
	return s
}

func (s *DescribePdnsUdpIpSegmentsResponseBodyIpSegments) SetUpdateDate(v string) *DescribePdnsUdpIpSegmentsResponseBodyIpSegments {
	s.UpdateDate = &v
	return s
}

type DescribePdnsUdpIpSegmentsResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePdnsUdpIpSegmentsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePdnsUdpIpSegmentsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsUdpIpSegmentsResponse) GoString() string {
	return s.String()
}

func (s *DescribePdnsUdpIpSegmentsResponse) SetHeaders(v map[string]*string) *DescribePdnsUdpIpSegmentsResponse {
	s.Headers = v
	return s
}

func (s *DescribePdnsUdpIpSegmentsResponse) SetStatusCode(v int32) *DescribePdnsUdpIpSegmentsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePdnsUdpIpSegmentsResponse) SetBody(v *DescribePdnsUdpIpSegmentsResponseBody) *DescribePdnsUdpIpSegmentsResponse {
	s.Body = v
	return s
}

type DescribePdnsUserInfoRequest struct {
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s DescribePdnsUserInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsUserInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribePdnsUserInfoRequest) SetLang(v string) *DescribePdnsUserInfoRequest {
	s.Lang = &v
	return s
}

type DescribePdnsUserInfoResponseBody struct {
	RequestId *string                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	UserInfo  *DescribePdnsUserInfoResponseBodyUserInfo `json:"UserInfo,omitempty" xml:"UserInfo,omitempty" type:"Struct"`
}

func (s DescribePdnsUserInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsUserInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePdnsUserInfoResponseBody) SetRequestId(v string) *DescribePdnsUserInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePdnsUserInfoResponseBody) SetUserInfo(v *DescribePdnsUserInfoResponseBodyUserInfo) *DescribePdnsUserInfoResponseBody {
	s.UserInfo = v
	return s
}

type DescribePdnsUserInfoResponseBodyUserInfo struct {
	AvailableService *string `json:"AvailableService,omitempty" xml:"AvailableService,omitempty"`
	PdnsId           *int64  `json:"PdnsId,omitempty" xml:"PdnsId,omitempty"`
	ServiceType      *string `json:"ServiceType,omitempty" xml:"ServiceType,omitempty"`
	State            *string `json:"State,omitempty" xml:"State,omitempty"`
	StoppedService   *string `json:"StoppedService,omitempty" xml:"StoppedService,omitempty"`
}

func (s DescribePdnsUserInfoResponseBodyUserInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsUserInfoResponseBodyUserInfo) GoString() string {
	return s.String()
}

func (s *DescribePdnsUserInfoResponseBodyUserInfo) SetAvailableService(v string) *DescribePdnsUserInfoResponseBodyUserInfo {
	s.AvailableService = &v
	return s
}

func (s *DescribePdnsUserInfoResponseBodyUserInfo) SetPdnsId(v int64) *DescribePdnsUserInfoResponseBodyUserInfo {
	s.PdnsId = &v
	return s
}

func (s *DescribePdnsUserInfoResponseBodyUserInfo) SetServiceType(v string) *DescribePdnsUserInfoResponseBodyUserInfo {
	s.ServiceType = &v
	return s
}

func (s *DescribePdnsUserInfoResponseBodyUserInfo) SetState(v string) *DescribePdnsUserInfoResponseBodyUserInfo {
	s.State = &v
	return s
}

func (s *DescribePdnsUserInfoResponseBodyUserInfo) SetStoppedService(v string) *DescribePdnsUserInfoResponseBodyUserInfo {
	s.StoppedService = &v
	return s
}

type DescribePdnsUserInfoResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePdnsUserInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePdnsUserInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePdnsUserInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribePdnsUserInfoResponse) SetHeaders(v map[string]*string) *DescribePdnsUserInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribePdnsUserInfoResponse) SetStatusCode(v int32) *DescribePdnsUserInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePdnsUserInfoResponse) SetBody(v *DescribePdnsUserInfoResponseBody) *DescribePdnsUserInfoResponse {
	s.Body = v
	return s
}

type DescribeRecordLogsRequest struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The keyword for searches in %KeyWord% mode. The value is not case-sensitive.
	KeyWord *string `json:"KeyWord,omitempty" xml:"KeyWord,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The number of the page to return. Pages start from page **1**. Default value: **1**.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **100**. Default value: **20**.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the **yyyy-MM-ddTHH:mm:ssZ** format.
	StartDate *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
	// The IP address of the client.
	UserClientIp *string `json:"UserClientIp,omitempty" xml:"UserClientIp,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the **yyyy-MM-ddTHH:mm:ssZ** format.
	EndDate *string `json:"endDate,omitempty" xml:"endDate,omitempty"`
}

func (s DescribeRecordLogsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRecordLogsRequest) GoString() string {
	return s.String()
}

func (s *DescribeRecordLogsRequest) SetDomainName(v string) *DescribeRecordLogsRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeRecordLogsRequest) SetKeyWord(v string) *DescribeRecordLogsRequest {
	s.KeyWord = &v
	return s
}

func (s *DescribeRecordLogsRequest) SetLang(v string) *DescribeRecordLogsRequest {
	s.Lang = &v
	return s
}

func (s *DescribeRecordLogsRequest) SetPageNumber(v int64) *DescribeRecordLogsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeRecordLogsRequest) SetPageSize(v int64) *DescribeRecordLogsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeRecordLogsRequest) SetStartDate(v string) *DescribeRecordLogsRequest {
	s.StartDate = &v
	return s
}

func (s *DescribeRecordLogsRequest) SetUserClientIp(v string) *DescribeRecordLogsRequest {
	s.UserClientIp = &v
	return s
}

func (s *DescribeRecordLogsRequest) SetEndDate(v string) *DescribeRecordLogsRequest {
	s.EndDate = &v
	return s
}

type DescribeRecordLogsResponseBody struct {
	// The page number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The list of the operation logs of the domain name.
	RecordLogs *DescribeRecordLogsResponseBodyRecordLogs `json:"RecordLogs,omitempty" xml:"RecordLogs,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of operation logs.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeRecordLogsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRecordLogsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRecordLogsResponseBody) SetPageNumber(v int64) *DescribeRecordLogsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeRecordLogsResponseBody) SetPageSize(v int64) *DescribeRecordLogsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeRecordLogsResponseBody) SetRecordLogs(v *DescribeRecordLogsResponseBodyRecordLogs) *DescribeRecordLogsResponseBody {
	s.RecordLogs = v
	return s
}

func (s *DescribeRecordLogsResponseBody) SetRequestId(v string) *DescribeRecordLogsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeRecordLogsResponseBody) SetTotalCount(v int64) *DescribeRecordLogsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeRecordLogsResponseBodyRecordLogs struct {
	RecordLog []*DescribeRecordLogsResponseBodyRecordLogsRecordLog `json:"RecordLog,omitempty" xml:"RecordLog,omitempty" type:"Repeated"`
}

func (s DescribeRecordLogsResponseBodyRecordLogs) String() string {
	return tea.Prettify(s)
}

func (s DescribeRecordLogsResponseBodyRecordLogs) GoString() string {
	return s.String()
}

func (s *DescribeRecordLogsResponseBodyRecordLogs) SetRecordLog(v []*DescribeRecordLogsResponseBodyRecordLogsRecordLog) *DescribeRecordLogsResponseBodyRecordLogs {
	s.RecordLog = v
	return s
}

type DescribeRecordLogsResponseBodyRecordLogsRecordLog struct {
	// The operation that you performed.
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// The time when the operation was performed.
	ActionTime *string `json:"ActionTime,omitempty" xml:"ActionTime,omitempty"`
	// The UNIX timestamp representing the time of the operation.
	ActionTimestamp *int64 `json:"ActionTimestamp,omitempty" xml:"ActionTimestamp,omitempty"`
	// The IP address of the operator.
	ClientIp *string `json:"ClientIp,omitempty" xml:"ClientIp,omitempty"`
	// The returned operation message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
}

func (s DescribeRecordLogsResponseBodyRecordLogsRecordLog) String() string {
	return tea.Prettify(s)
}

func (s DescribeRecordLogsResponseBodyRecordLogsRecordLog) GoString() string {
	return s.String()
}

func (s *DescribeRecordLogsResponseBodyRecordLogsRecordLog) SetAction(v string) *DescribeRecordLogsResponseBodyRecordLogsRecordLog {
	s.Action = &v
	return s
}

func (s *DescribeRecordLogsResponseBodyRecordLogsRecordLog) SetActionTime(v string) *DescribeRecordLogsResponseBodyRecordLogsRecordLog {
	s.ActionTime = &v
	return s
}

func (s *DescribeRecordLogsResponseBodyRecordLogsRecordLog) SetActionTimestamp(v int64) *DescribeRecordLogsResponseBodyRecordLogsRecordLog {
	s.ActionTimestamp = &v
	return s
}

func (s *DescribeRecordLogsResponseBodyRecordLogsRecordLog) SetClientIp(v string) *DescribeRecordLogsResponseBodyRecordLogsRecordLog {
	s.ClientIp = &v
	return s
}

func (s *DescribeRecordLogsResponseBodyRecordLogsRecordLog) SetMessage(v string) *DescribeRecordLogsResponseBodyRecordLogsRecordLog {
	s.Message = &v
	return s
}

type DescribeRecordLogsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRecordLogsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRecordLogsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRecordLogsResponse) GoString() string {
	return s.String()
}

func (s *DescribeRecordLogsResponse) SetHeaders(v map[string]*string) *DescribeRecordLogsResponse {
	s.Headers = v
	return s
}

func (s *DescribeRecordLogsResponse) SetStatusCode(v int32) *DescribeRecordLogsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRecordLogsResponse) SetBody(v *DescribeRecordLogsResponseBody) *DescribeRecordLogsResponse {
	s.Body = v
	return s
}

type DescribeRecordResolveStatisticsSummaryRequest struct {
	Direction  *string `json:"Direction,omitempty" xml:"Direction,omitempty"`
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	DomainType *string `json:"DomainType,omitempty" xml:"DomainType,omitempty"`
	EndDate    *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	Keyword    *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	Lang       *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	PageNumber *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	SearchMode *string `json:"SearchMode,omitempty" xml:"SearchMode,omitempty"`
	StartDate  *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
	Threshold  *int64  `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s DescribeRecordResolveStatisticsSummaryRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRecordResolveStatisticsSummaryRequest) GoString() string {
	return s.String()
}

func (s *DescribeRecordResolveStatisticsSummaryRequest) SetDirection(v string) *DescribeRecordResolveStatisticsSummaryRequest {
	s.Direction = &v
	return s
}

func (s *DescribeRecordResolveStatisticsSummaryRequest) SetDomainName(v string) *DescribeRecordResolveStatisticsSummaryRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeRecordResolveStatisticsSummaryRequest) SetDomainType(v string) *DescribeRecordResolveStatisticsSummaryRequest {
	s.DomainType = &v
	return s
}

func (s *DescribeRecordResolveStatisticsSummaryRequest) SetEndDate(v string) *DescribeRecordResolveStatisticsSummaryRequest {
	s.EndDate = &v
	return s
}

func (s *DescribeRecordResolveStatisticsSummaryRequest) SetKeyword(v string) *DescribeRecordResolveStatisticsSummaryRequest {
	s.Keyword = &v
	return s
}

func (s *DescribeRecordResolveStatisticsSummaryRequest) SetLang(v string) *DescribeRecordResolveStatisticsSummaryRequest {
	s.Lang = &v
	return s
}

func (s *DescribeRecordResolveStatisticsSummaryRequest) SetPageNumber(v int32) *DescribeRecordResolveStatisticsSummaryRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeRecordResolveStatisticsSummaryRequest) SetPageSize(v int32) *DescribeRecordResolveStatisticsSummaryRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeRecordResolveStatisticsSummaryRequest) SetSearchMode(v string) *DescribeRecordResolveStatisticsSummaryRequest {
	s.SearchMode = &v
	return s
}

func (s *DescribeRecordResolveStatisticsSummaryRequest) SetStartDate(v string) *DescribeRecordResolveStatisticsSummaryRequest {
	s.StartDate = &v
	return s
}

func (s *DescribeRecordResolveStatisticsSummaryRequest) SetThreshold(v int64) *DescribeRecordResolveStatisticsSummaryRequest {
	s.Threshold = &v
	return s
}

type DescribeRecordResolveStatisticsSummaryResponseBody struct {
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// RequestId
	RequestId  *string                                                         `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Statistics []*DescribeRecordResolveStatisticsSummaryResponseBodyStatistics `json:"Statistics,omitempty" xml:"Statistics,omitempty" type:"Repeated"`
	TotalItems *int32                                                          `json:"TotalItems,omitempty" xml:"TotalItems,omitempty"`
	TotalPages *int32                                                          `json:"TotalPages,omitempty" xml:"TotalPages,omitempty"`
}

func (s DescribeRecordResolveStatisticsSummaryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRecordResolveStatisticsSummaryResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRecordResolveStatisticsSummaryResponseBody) SetPageNumber(v int32) *DescribeRecordResolveStatisticsSummaryResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeRecordResolveStatisticsSummaryResponseBody) SetPageSize(v int32) *DescribeRecordResolveStatisticsSummaryResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeRecordResolveStatisticsSummaryResponseBody) SetRequestId(v string) *DescribeRecordResolveStatisticsSummaryResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeRecordResolveStatisticsSummaryResponseBody) SetStatistics(v []*DescribeRecordResolveStatisticsSummaryResponseBodyStatistics) *DescribeRecordResolveStatisticsSummaryResponseBody {
	s.Statistics = v
	return s
}

func (s *DescribeRecordResolveStatisticsSummaryResponseBody) SetTotalItems(v int32) *DescribeRecordResolveStatisticsSummaryResponseBody {
	s.TotalItems = &v
	return s
}

func (s *DescribeRecordResolveStatisticsSummaryResponseBody) SetTotalPages(v int32) *DescribeRecordResolveStatisticsSummaryResponseBody {
	s.TotalPages = &v
	return s
}

type DescribeRecordResolveStatisticsSummaryResponseBodyStatistics struct {
	Count      *string `json:"Count,omitempty" xml:"Count,omitempty"`
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	DomainType *string `json:"DomainType,omitempty" xml:"DomainType,omitempty"`
	SubDomain  *string `json:"SubDomain,omitempty" xml:"SubDomain,omitempty"`
}

func (s DescribeRecordResolveStatisticsSummaryResponseBodyStatistics) String() string {
	return tea.Prettify(s)
}

func (s DescribeRecordResolveStatisticsSummaryResponseBodyStatistics) GoString() string {
	return s.String()
}

func (s *DescribeRecordResolveStatisticsSummaryResponseBodyStatistics) SetCount(v string) *DescribeRecordResolveStatisticsSummaryResponseBodyStatistics {
	s.Count = &v
	return s
}

func (s *DescribeRecordResolveStatisticsSummaryResponseBodyStatistics) SetDomainName(v string) *DescribeRecordResolveStatisticsSummaryResponseBodyStatistics {
	s.DomainName = &v
	return s
}

func (s *DescribeRecordResolveStatisticsSummaryResponseBodyStatistics) SetDomainType(v string) *DescribeRecordResolveStatisticsSummaryResponseBodyStatistics {
	s.DomainType = &v
	return s
}

func (s *DescribeRecordResolveStatisticsSummaryResponseBodyStatistics) SetSubDomain(v string) *DescribeRecordResolveStatisticsSummaryResponseBodyStatistics {
	s.SubDomain = &v
	return s
}

type DescribeRecordResolveStatisticsSummaryResponse struct {
	Headers    map[string]*string                                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRecordResolveStatisticsSummaryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRecordResolveStatisticsSummaryResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRecordResolveStatisticsSummaryResponse) GoString() string {
	return s.String()
}

func (s *DescribeRecordResolveStatisticsSummaryResponse) SetHeaders(v map[string]*string) *DescribeRecordResolveStatisticsSummaryResponse {
	s.Headers = v
	return s
}

func (s *DescribeRecordResolveStatisticsSummaryResponse) SetStatusCode(v int32) *DescribeRecordResolveStatisticsSummaryResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRecordResolveStatisticsSummaryResponse) SetBody(v *DescribeRecordResolveStatisticsSummaryResponseBody) *DescribeRecordResolveStatisticsSummaryResponse {
	s.Body = v
	return s
}

type DescribeRecordStatisticsRequest struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	DomainType *string `json:"DomainType,omitempty" xml:"DomainType,omitempty"`
	// The end of the time range to query. Specify the time in the **YYYY-MM-DD** format.
	//
	// The default value is the day when you perform the operation.
	EndDate *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The DNS record.
	//
	// The host record. For example, to resolve `www.dns-exmaple.com`, you must set Rr to www.
	Rr *string `json:"Rr,omitempty" xml:"Rr,omitempty"`
	// The beginning of the time range to query. Specify the time in the **YYYY-MM-DD** format.
	//
	// You can only query DNS records of the last 90 days.
	StartDate *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
}

func (s DescribeRecordStatisticsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRecordStatisticsRequest) GoString() string {
	return s.String()
}

func (s *DescribeRecordStatisticsRequest) SetDomainName(v string) *DescribeRecordStatisticsRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeRecordStatisticsRequest) SetDomainType(v string) *DescribeRecordStatisticsRequest {
	s.DomainType = &v
	return s
}

func (s *DescribeRecordStatisticsRequest) SetEndDate(v string) *DescribeRecordStatisticsRequest {
	s.EndDate = &v
	return s
}

func (s *DescribeRecordStatisticsRequest) SetLang(v string) *DescribeRecordStatisticsRequest {
	s.Lang = &v
	return s
}

func (s *DescribeRecordStatisticsRequest) SetRr(v string) *DescribeRecordStatisticsRequest {
	s.Rr = &v
	return s
}

func (s *DescribeRecordStatisticsRequest) SetStartDate(v string) *DescribeRecordStatisticsRequest {
	s.StartDate = &v
	return s
}

type DescribeRecordStatisticsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of query volume records.
	Statistics *DescribeRecordStatisticsResponseBodyStatistics `json:"Statistics,omitempty" xml:"Statistics,omitempty" type:"Struct"`
}

func (s DescribeRecordStatisticsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRecordStatisticsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRecordStatisticsResponseBody) SetRequestId(v string) *DescribeRecordStatisticsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeRecordStatisticsResponseBody) SetStatistics(v *DescribeRecordStatisticsResponseBodyStatistics) *DescribeRecordStatisticsResponseBody {
	s.Statistics = v
	return s
}

type DescribeRecordStatisticsResponseBodyStatistics struct {
	Statistic []*DescribeRecordStatisticsResponseBodyStatisticsStatistic `json:"Statistic,omitempty" xml:"Statistic,omitempty" type:"Repeated"`
}

func (s DescribeRecordStatisticsResponseBodyStatistics) String() string {
	return tea.Prettify(s)
}

func (s DescribeRecordStatisticsResponseBodyStatistics) GoString() string {
	return s.String()
}

func (s *DescribeRecordStatisticsResponseBodyStatistics) SetStatistic(v []*DescribeRecordStatisticsResponseBodyStatisticsStatistic) *DescribeRecordStatisticsResponseBodyStatistics {
	s.Statistic = v
	return s
}

type DescribeRecordStatisticsResponseBodyStatisticsStatistic struct {
	// The number of queries.
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The UNIX timestamp representing the collection time.
	Timestamp *int64 `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
}

func (s DescribeRecordStatisticsResponseBodyStatisticsStatistic) String() string {
	return tea.Prettify(s)
}

func (s DescribeRecordStatisticsResponseBodyStatisticsStatistic) GoString() string {
	return s.String()
}

func (s *DescribeRecordStatisticsResponseBodyStatisticsStatistic) SetCount(v int64) *DescribeRecordStatisticsResponseBodyStatisticsStatistic {
	s.Count = &v
	return s
}

func (s *DescribeRecordStatisticsResponseBodyStatisticsStatistic) SetTimestamp(v int64) *DescribeRecordStatisticsResponseBodyStatisticsStatistic {
	s.Timestamp = &v
	return s
}

type DescribeRecordStatisticsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRecordStatisticsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRecordStatisticsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRecordStatisticsResponse) GoString() string {
	return s.String()
}

func (s *DescribeRecordStatisticsResponse) SetHeaders(v map[string]*string) *DescribeRecordStatisticsResponse {
	s.Headers = v
	return s
}

func (s *DescribeRecordStatisticsResponse) SetStatusCode(v int32) *DescribeRecordStatisticsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRecordStatisticsResponse) SetBody(v *DescribeRecordStatisticsResponseBody) *DescribeRecordStatisticsResponse {
	s.Body = v
	return s
}

type DescribeRecordStatisticsSummaryRequest struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	DomainType *string `json:"DomainType,omitempty" xml:"DomainType,omitempty"`
	// The end of the time range to query. Specify the time in the **YYYY-MM-DD** format.
	//
	// The default value is the day when you perform the operation.
	EndDate *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	// The keyword for searches in %KeyWord% mode. The value is not case-sensitive.
	Keyword *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The number of the page to return. Pages start from page **1**. Default value: **1**.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **100**. Minimum value: **1**. Default value: **20**.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The search mode of the keyword. Valid values:
	//
	// *   **LIKE**: fuzzy match (default).
	// *   **EXACT**: exact match.
	SearchMode *string `json:"SearchMode,omitempty" xml:"SearchMode,omitempty"`
	// The beginning of the time range to query. Specify the time in the **YYYY-MM-DD** format.
	//
	// You can only query DNS records of the last 90 days.
	StartDate *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
	// The threshold of query volume that can be obtained. You can also obtain data about a domain name with the query volume less than or equal to the threshold. For example, if you set this parameter to 100, you can query domain names with less than 100 queries.
	Threshold *int64 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s DescribeRecordStatisticsSummaryRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRecordStatisticsSummaryRequest) GoString() string {
	return s.String()
}

func (s *DescribeRecordStatisticsSummaryRequest) SetDomainName(v string) *DescribeRecordStatisticsSummaryRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeRecordStatisticsSummaryRequest) SetDomainType(v string) *DescribeRecordStatisticsSummaryRequest {
	s.DomainType = &v
	return s
}

func (s *DescribeRecordStatisticsSummaryRequest) SetEndDate(v string) *DescribeRecordStatisticsSummaryRequest {
	s.EndDate = &v
	return s
}

func (s *DescribeRecordStatisticsSummaryRequest) SetKeyword(v string) *DescribeRecordStatisticsSummaryRequest {
	s.Keyword = &v
	return s
}

func (s *DescribeRecordStatisticsSummaryRequest) SetLang(v string) *DescribeRecordStatisticsSummaryRequest {
	s.Lang = &v
	return s
}

func (s *DescribeRecordStatisticsSummaryRequest) SetPageNumber(v int64) *DescribeRecordStatisticsSummaryRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeRecordStatisticsSummaryRequest) SetPageSize(v int64) *DescribeRecordStatisticsSummaryRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeRecordStatisticsSummaryRequest) SetSearchMode(v string) *DescribeRecordStatisticsSummaryRequest {
	s.SearchMode = &v
	return s
}

func (s *DescribeRecordStatisticsSummaryRequest) SetStartDate(v string) *DescribeRecordStatisticsSummaryRequest {
	s.StartDate = &v
	return s
}

func (s *DescribeRecordStatisticsSummaryRequest) SetThreshold(v int64) *DescribeRecordStatisticsSummaryRequest {
	s.Threshold = &v
	return s
}

type DescribeRecordStatisticsSummaryResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of query volume records.
	Statistics *DescribeRecordStatisticsSummaryResponseBodyStatistics `json:"Statistics,omitempty" xml:"Statistics,omitempty" type:"Struct"`
	// The total number of data records.The total number of data records.
	TotalItems *int32 `json:"TotalItems,omitempty" xml:"TotalItems,omitempty"`
	// The total number of returned pages.
	TotalPages *int32 `json:"TotalPages,omitempty" xml:"TotalPages,omitempty"`
}

func (s DescribeRecordStatisticsSummaryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRecordStatisticsSummaryResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRecordStatisticsSummaryResponseBody) SetPageNumber(v int32) *DescribeRecordStatisticsSummaryResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeRecordStatisticsSummaryResponseBody) SetPageSize(v int32) *DescribeRecordStatisticsSummaryResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeRecordStatisticsSummaryResponseBody) SetRequestId(v string) *DescribeRecordStatisticsSummaryResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeRecordStatisticsSummaryResponseBody) SetStatistics(v *DescribeRecordStatisticsSummaryResponseBodyStatistics) *DescribeRecordStatisticsSummaryResponseBody {
	s.Statistics = v
	return s
}

func (s *DescribeRecordStatisticsSummaryResponseBody) SetTotalItems(v int32) *DescribeRecordStatisticsSummaryResponseBody {
	s.TotalItems = &v
	return s
}

func (s *DescribeRecordStatisticsSummaryResponseBody) SetTotalPages(v int32) *DescribeRecordStatisticsSummaryResponseBody {
	s.TotalPages = &v
	return s
}

type DescribeRecordStatisticsSummaryResponseBodyStatistics struct {
	Statistic []*DescribeRecordStatisticsSummaryResponseBodyStatisticsStatistic `json:"Statistic,omitempty" xml:"Statistic,omitempty" type:"Repeated"`
}

func (s DescribeRecordStatisticsSummaryResponseBodyStatistics) String() string {
	return tea.Prettify(s)
}

func (s DescribeRecordStatisticsSummaryResponseBodyStatistics) GoString() string {
	return s.String()
}

func (s *DescribeRecordStatisticsSummaryResponseBodyStatistics) SetStatistic(v []*DescribeRecordStatisticsSummaryResponseBodyStatisticsStatistic) *DescribeRecordStatisticsSummaryResponseBodyStatistics {
	s.Statistic = v
	return s
}

type DescribeRecordStatisticsSummaryResponseBodyStatisticsStatistic struct {
	// The number of queries.
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The subdomain name.
	SubDomain *string `json:"SubDomain,omitempty" xml:"SubDomain,omitempty"`
}

func (s DescribeRecordStatisticsSummaryResponseBodyStatisticsStatistic) String() string {
	return tea.Prettify(s)
}

func (s DescribeRecordStatisticsSummaryResponseBodyStatisticsStatistic) GoString() string {
	return s.String()
}

func (s *DescribeRecordStatisticsSummaryResponseBodyStatisticsStatistic) SetCount(v int64) *DescribeRecordStatisticsSummaryResponseBodyStatisticsStatistic {
	s.Count = &v
	return s
}

func (s *DescribeRecordStatisticsSummaryResponseBodyStatisticsStatistic) SetSubDomain(v string) *DescribeRecordStatisticsSummaryResponseBodyStatisticsStatistic {
	s.SubDomain = &v
	return s
}

type DescribeRecordStatisticsSummaryResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRecordStatisticsSummaryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRecordStatisticsSummaryResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRecordStatisticsSummaryResponse) GoString() string {
	return s.String()
}

func (s *DescribeRecordStatisticsSummaryResponse) SetHeaders(v map[string]*string) *DescribeRecordStatisticsSummaryResponse {
	s.Headers = v
	return s
}

func (s *DescribeRecordStatisticsSummaryResponse) SetStatusCode(v int32) *DescribeRecordStatisticsSummaryResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRecordStatisticsSummaryResponse) SetBody(v *DescribeRecordStatisticsSummaryResponseBody) *DescribeRecordStatisticsSummaryResponse {
	s.Body = v
	return s
}

type DescribeSubDomainRecordsRequest struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The language.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The resolution line.
	Line *string `json:"Line,omitempty" xml:"Line,omitempty"`
	// The number of the page to return. Pages start from page **1**. Default value: **1**.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **500**. Default value: **20**.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The subdomain. For example, assume that the SubDomain parameter is set to a.www.example.com.
	//
	// If the DomainName parameter is empty, the DNS records of the subdomain whose domain name is example.com and hostname is "a.www" are queried.
	//
	// If the DomainName parameter is set to www.example.com, the DNS records of the subdomain whose domain name is www.example.com and hostname is "a" are queried.
	//
	// If the DomainName parameter is set to a.www.example.com, the DNS records of the subdomain whose domain name is a.www.example.com and hostname is "@" are queried.
	SubDomain *string `json:"SubDomain,omitempty" xml:"SubDomain,omitempty"`
	// The type of DNS records to query. If you do not specify this parameter, all types of DNS records corresponding to the subdomain are returned.
	//
	// DNS record types include **A, MX, CNAME, TXT, REDIRECT_URL, FORWORD_URL, NS, AAAA, and SRV**. The value is not case-sensitive.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The IP address of the client.
	UserClientIp *string `json:"UserClientIp,omitempty" xml:"UserClientIp,omitempty"`
}

func (s DescribeSubDomainRecordsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSubDomainRecordsRequest) GoString() string {
	return s.String()
}

func (s *DescribeSubDomainRecordsRequest) SetDomainName(v string) *DescribeSubDomainRecordsRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeSubDomainRecordsRequest) SetLang(v string) *DescribeSubDomainRecordsRequest {
	s.Lang = &v
	return s
}

func (s *DescribeSubDomainRecordsRequest) SetLine(v string) *DescribeSubDomainRecordsRequest {
	s.Line = &v
	return s
}

func (s *DescribeSubDomainRecordsRequest) SetPageNumber(v int64) *DescribeSubDomainRecordsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeSubDomainRecordsRequest) SetPageSize(v int64) *DescribeSubDomainRecordsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeSubDomainRecordsRequest) SetSubDomain(v string) *DescribeSubDomainRecordsRequest {
	s.SubDomain = &v
	return s
}

func (s *DescribeSubDomainRecordsRequest) SetType(v string) *DescribeSubDomainRecordsRequest {
	s.Type = &v
	return s
}

func (s *DescribeSubDomainRecordsRequest) SetUserClientIp(v string) *DescribeSubDomainRecordsRequest {
	s.UserClientIp = &v
	return s
}

type DescribeSubDomainRecordsResponseBody struct {
	// The list of DNS records returned.
	DomainRecords *DescribeSubDomainRecordsResponseBodyDomainRecords `json:"DomainRecords,omitempty" xml:"DomainRecords,omitempty" type:"Struct"`
	// The number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of DNS records returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeSubDomainRecordsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSubDomainRecordsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSubDomainRecordsResponseBody) SetDomainRecords(v *DescribeSubDomainRecordsResponseBodyDomainRecords) *DescribeSubDomainRecordsResponseBody {
	s.DomainRecords = v
	return s
}

func (s *DescribeSubDomainRecordsResponseBody) SetPageNumber(v int64) *DescribeSubDomainRecordsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeSubDomainRecordsResponseBody) SetPageSize(v int64) *DescribeSubDomainRecordsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeSubDomainRecordsResponseBody) SetRequestId(v string) *DescribeSubDomainRecordsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSubDomainRecordsResponseBody) SetTotalCount(v int64) *DescribeSubDomainRecordsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeSubDomainRecordsResponseBodyDomainRecords struct {
	Record []*DescribeSubDomainRecordsResponseBodyDomainRecordsRecord `json:"Record,omitempty" xml:"Record,omitempty" type:"Repeated"`
}

func (s DescribeSubDomainRecordsResponseBodyDomainRecords) String() string {
	return tea.Prettify(s)
}

func (s DescribeSubDomainRecordsResponseBodyDomainRecords) GoString() string {
	return s.String()
}

func (s *DescribeSubDomainRecordsResponseBodyDomainRecords) SetRecord(v []*DescribeSubDomainRecordsResponseBodyDomainRecordsRecord) *DescribeSubDomainRecordsResponseBodyDomainRecords {
	s.Record = v
	return s
}

type DescribeSubDomainRecordsResponseBodyDomainRecordsRecord struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The resolution line.
	Line *string `json:"Line,omitempty" xml:"Line,omitempty"`
	// Indicates whether the DNS record is locked.
	Locked *bool `json:"Locked,omitempty" xml:"Locked,omitempty"`
	// The priority of the MX record.
	Priority *int64 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The hostname.
	RR *string `json:"RR,omitempty" xml:"RR,omitempty"`
	// The ID of the DNS record.
	RecordId *string `json:"RecordId,omitempty" xml:"RecordId,omitempty"`
	// The description of the DNS record.
	Remark *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
	// The status of the DNS record.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The Time-to-Live (TTL) of the DNS record.
	TTL *int64 `json:"TTL,omitempty" xml:"TTL,omitempty"`
	// The type of the DNS record.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The record value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
	// The weight of the DNS record.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeSubDomainRecordsResponseBodyDomainRecordsRecord) String() string {
	return tea.Prettify(s)
}

func (s DescribeSubDomainRecordsResponseBodyDomainRecordsRecord) GoString() string {
	return s.String()
}

func (s *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord) SetDomainName(v string) *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord {
	s.DomainName = &v
	return s
}

func (s *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord) SetLine(v string) *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord {
	s.Line = &v
	return s
}

func (s *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord) SetLocked(v bool) *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord {
	s.Locked = &v
	return s
}

func (s *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord) SetPriority(v int64) *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord {
	s.Priority = &v
	return s
}

func (s *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord) SetRR(v string) *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord {
	s.RR = &v
	return s
}

func (s *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord) SetRecordId(v string) *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord {
	s.RecordId = &v
	return s
}

func (s *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord) SetRemark(v string) *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord {
	s.Remark = &v
	return s
}

func (s *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord) SetStatus(v string) *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord {
	s.Status = &v
	return s
}

func (s *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord) SetTTL(v int64) *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord {
	s.TTL = &v
	return s
}

func (s *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord) SetType(v string) *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord {
	s.Type = &v
	return s
}

func (s *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord) SetValue(v string) *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord {
	s.Value = &v
	return s
}

func (s *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord) SetWeight(v int32) *DescribeSubDomainRecordsResponseBodyDomainRecordsRecord {
	s.Weight = &v
	return s
}

type DescribeSubDomainRecordsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeSubDomainRecordsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeSubDomainRecordsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSubDomainRecordsResponse) GoString() string {
	return s.String()
}

func (s *DescribeSubDomainRecordsResponse) SetHeaders(v map[string]*string) *DescribeSubDomainRecordsResponse {
	s.Headers = v
	return s
}

func (s *DescribeSubDomainRecordsResponse) SetStatusCode(v int32) *DescribeSubDomainRecordsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSubDomainRecordsResponse) SetBody(v *DescribeSubDomainRecordsResponseBody) *DescribeSubDomainRecordsResponse {
	s.Body = v
	return s
}

type DescribeSupportLinesRequest struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The IP address of the client.
	UserClientIp *string `json:"UserClientIp,omitempty" xml:"UserClientIp,omitempty"`
}

func (s DescribeSupportLinesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSupportLinesRequest) GoString() string {
	return s.String()
}

func (s *DescribeSupportLinesRequest) SetDomainName(v string) *DescribeSupportLinesRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeSupportLinesRequest) SetLang(v string) *DescribeSupportLinesRequest {
	s.Lang = &v
	return s
}

func (s *DescribeSupportLinesRequest) SetUserClientIp(v string) *DescribeSupportLinesRequest {
	s.UserClientIp = &v
	return s
}

type DescribeSupportLinesResponseBody struct {
	// The list of Alibaba Cloud DNS lines.
	RecordLines *DescribeSupportLinesResponseBodyRecordLines `json:"RecordLines,omitempty" xml:"RecordLines,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeSupportLinesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSupportLinesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSupportLinesResponseBody) SetRecordLines(v *DescribeSupportLinesResponseBodyRecordLines) *DescribeSupportLinesResponseBody {
	s.RecordLines = v
	return s
}

func (s *DescribeSupportLinesResponseBody) SetRequestId(v string) *DescribeSupportLinesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeSupportLinesResponseBodyRecordLines struct {
	RecordLine []*DescribeSupportLinesResponseBodyRecordLinesRecordLine `json:"RecordLine,omitempty" xml:"RecordLine,omitempty" type:"Repeated"`
}

func (s DescribeSupportLinesResponseBodyRecordLines) String() string {
	return tea.Prettify(s)
}

func (s DescribeSupportLinesResponseBodyRecordLines) GoString() string {
	return s.String()
}

func (s *DescribeSupportLinesResponseBodyRecordLines) SetRecordLine(v []*DescribeSupportLinesResponseBodyRecordLinesRecordLine) *DescribeSupportLinesResponseBodyRecordLines {
	s.RecordLine = v
	return s
}

type DescribeSupportLinesResponseBodyRecordLinesRecordLine struct {
	// The code of the parent line. Leave it blank if there is no parent line.
	FatherCode *string `json:"FatherCode,omitempty" xml:"FatherCode,omitempty"`
	// The code of the child line.
	LineCode *string `json:"LineCode,omitempty" xml:"LineCode,omitempty"`
	// The name of the parent line.
	LineDisplayName *string `json:"LineDisplayName,omitempty" xml:"LineDisplayName,omitempty"`
	// The name of the child line.
	LineName *string `json:"LineName,omitempty" xml:"LineName,omitempty"`
}

func (s DescribeSupportLinesResponseBodyRecordLinesRecordLine) String() string {
	return tea.Prettify(s)
}

func (s DescribeSupportLinesResponseBodyRecordLinesRecordLine) GoString() string {
	return s.String()
}

func (s *DescribeSupportLinesResponseBodyRecordLinesRecordLine) SetFatherCode(v string) *DescribeSupportLinesResponseBodyRecordLinesRecordLine {
	s.FatherCode = &v
	return s
}

func (s *DescribeSupportLinesResponseBodyRecordLinesRecordLine) SetLineCode(v string) *DescribeSupportLinesResponseBodyRecordLinesRecordLine {
	s.LineCode = &v
	return s
}

func (s *DescribeSupportLinesResponseBodyRecordLinesRecordLine) SetLineDisplayName(v string) *DescribeSupportLinesResponseBodyRecordLinesRecordLine {
	s.LineDisplayName = &v
	return s
}

func (s *DescribeSupportLinesResponseBodyRecordLinesRecordLine) SetLineName(v string) *DescribeSupportLinesResponseBodyRecordLinesRecordLine {
	s.LineName = &v
	return s
}

type DescribeSupportLinesResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeSupportLinesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeSupportLinesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSupportLinesResponse) GoString() string {
	return s.String()
}

func (s *DescribeSupportLinesResponse) SetHeaders(v map[string]*string) *DescribeSupportLinesResponse {
	s.Headers = v
	return s
}

func (s *DescribeSupportLinesResponse) SetStatusCode(v int32) *DescribeSupportLinesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSupportLinesResponse) SetBody(v *DescribeSupportLinesResponseBody) *DescribeSupportLinesResponse {
	s.Body = v
	return s
}

type DescribeTagsRequest struct {
	// The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The page number to return. Default value: 1.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return per page. Default value: 200.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The type of the resources from which you want to query tags. Set the value to DOMAIN.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s DescribeTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagsRequest) GoString() string {
	return s.String()
}

func (s *DescribeTagsRequest) SetLang(v string) *DescribeTagsRequest {
	s.Lang = &v
	return s
}

func (s *DescribeTagsRequest) SetPageNumber(v int64) *DescribeTagsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeTagsRequest) SetPageSize(v int64) *DescribeTagsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeTagsRequest) SetResourceType(v string) *DescribeTagsRequest {
	s.ResourceType = &v
	return s
}

type DescribeTagsResponseBody struct {
	// The returned page number. Default value: 1.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page. Default value: 200.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of tags.
	Tags []*DescribeTagsResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The total number of tags returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeTagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeTagsResponseBody) SetPageNumber(v int64) *DescribeTagsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeTagsResponseBody) SetPageSize(v int64) *DescribeTagsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeTagsResponseBody) SetRequestId(v string) *DescribeTagsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeTagsResponseBody) SetTags(v []*DescribeTagsResponseBodyTags) *DescribeTagsResponseBody {
	s.Tags = v
	return s
}

func (s *DescribeTagsResponseBody) SetTotalCount(v int64) *DescribeTagsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeTagsResponseBodyTags struct {
	// The key of the tag.
	Key    *string   `json:"Key,omitempty" xml:"Key,omitempty"`
	Values []*string `json:"Values,omitempty" xml:"Values,omitempty" type:"Repeated"`
}

func (s DescribeTagsResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagsResponseBodyTags) GoString() string {
	return s.String()
}

func (s *DescribeTagsResponseBodyTags) SetKey(v string) *DescribeTagsResponseBodyTags {
	s.Key = &v
	return s
}

func (s *DescribeTagsResponseBodyTags) SetValues(v []*string) *DescribeTagsResponseBodyTags {
	s.Values = v
	return s
}

type DescribeTagsResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeTagsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagsResponse) GoString() string {
	return s.String()
}

func (s *DescribeTagsResponse) SetHeaders(v map[string]*string) *DescribeTagsResponse {
	s.Headers = v
	return s
}

func (s *DescribeTagsResponse) SetStatusCode(v int32) *DescribeTagsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeTagsResponse) SetBody(v *DescribeTagsResponseBody) *DescribeTagsResponse {
	s.Body = v
	return s
}

type DescribeTransferDomainsRequest struct {
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	FromUserId *int64  `json:"FromUserId,omitempty" xml:"FromUserId,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The number of the page to return. Pages start from page 1. Default value: 1.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: 100. Default value: 20.
	PageSize     *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	TargetUserId *int64 `json:"TargetUserId,omitempty" xml:"TargetUserId,omitempty"`
	// The transfer type. Valid values:
	//
	// *   IN: transferred to this account.
	// *   OUT: transferred from this account.
	TransferType *string `json:"TransferType,omitempty" xml:"TransferType,omitempty"`
}

func (s DescribeTransferDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeTransferDomainsRequest) GoString() string {
	return s.String()
}

func (s *DescribeTransferDomainsRequest) SetDomainName(v string) *DescribeTransferDomainsRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeTransferDomainsRequest) SetFromUserId(v int64) *DescribeTransferDomainsRequest {
	s.FromUserId = &v
	return s
}

func (s *DescribeTransferDomainsRequest) SetLang(v string) *DescribeTransferDomainsRequest {
	s.Lang = &v
	return s
}

func (s *DescribeTransferDomainsRequest) SetPageNumber(v int64) *DescribeTransferDomainsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeTransferDomainsRequest) SetPageSize(v int64) *DescribeTransferDomainsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeTransferDomainsRequest) SetTargetUserId(v int64) *DescribeTransferDomainsRequest {
	s.TargetUserId = &v
	return s
}

func (s *DescribeTransferDomainsRequest) SetTransferType(v string) *DescribeTransferDomainsRequest {
	s.TransferType = &v
	return s
}

type DescribeTransferDomainsResponseBody struct {
	// The list of domain names that were transferred between accounts.
	DomainTransfers *DescribeTransferDomainsResponseBodyDomainTransfers `json:"DomainTransfers,omitempty" xml:"DomainTransfers,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of domain names.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeTransferDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeTransferDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeTransferDomainsResponseBody) SetDomainTransfers(v *DescribeTransferDomainsResponseBodyDomainTransfers) *DescribeTransferDomainsResponseBody {
	s.DomainTransfers = v
	return s
}

func (s *DescribeTransferDomainsResponseBody) SetPageNumber(v int64) *DescribeTransferDomainsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeTransferDomainsResponseBody) SetPageSize(v int64) *DescribeTransferDomainsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeTransferDomainsResponseBody) SetRequestId(v string) *DescribeTransferDomainsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeTransferDomainsResponseBody) SetTotalCount(v int64) *DescribeTransferDomainsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeTransferDomainsResponseBodyDomainTransfers struct {
	DomainTransfer []*DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer `json:"DomainTransfer,omitempty" xml:"DomainTransfer,omitempty" type:"Repeated"`
}

func (s DescribeTransferDomainsResponseBodyDomainTransfers) String() string {
	return tea.Prettify(s)
}

func (s DescribeTransferDomainsResponseBodyDomainTransfers) GoString() string {
	return s.String()
}

func (s *DescribeTransferDomainsResponseBodyDomainTransfers) SetDomainTransfer(v []*DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer) *DescribeTransferDomainsResponseBodyDomainTransfers {
	s.DomainTransfer = v
	return s
}

type DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer struct {
	// The time when the task for transferring domain names was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The UNIX timestamp representing when the task for transferring domain names was created.
	CreateTimestamp *int64 `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The ID of the user from which the domain name was transferred.
	FromUserId *int64 `json:"FromUserId,omitempty" xml:"FromUserId,omitempty"`
	// The ID of the domain name that was transferred.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the user to which the domain name was transferred.
	TargetUserId *int64 `json:"TargetUserId,omitempty" xml:"TargetUserId,omitempty"`
}

func (s DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer) String() string {
	return tea.Prettify(s)
}

func (s DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer) GoString() string {
	return s.String()
}

func (s *DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer) SetCreateTime(v string) *DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer {
	s.CreateTime = &v
	return s
}

func (s *DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer) SetCreateTimestamp(v int64) *DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer {
	s.CreateTimestamp = &v
	return s
}

func (s *DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer) SetDomainName(v string) *DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer {
	s.DomainName = &v
	return s
}

func (s *DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer) SetFromUserId(v int64) *DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer {
	s.FromUserId = &v
	return s
}

func (s *DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer) SetId(v int64) *DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer {
	s.Id = &v
	return s
}

func (s *DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer) SetTargetUserId(v int64) *DescribeTransferDomainsResponseBodyDomainTransfersDomainTransfer {
	s.TargetUserId = &v
	return s
}

type DescribeTransferDomainsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeTransferDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeTransferDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeTransferDomainsResponse) GoString() string {
	return s.String()
}

func (s *DescribeTransferDomainsResponse) SetHeaders(v map[string]*string) *DescribeTransferDomainsResponse {
	s.Headers = v
	return s
}

func (s *DescribeTransferDomainsResponse) SetStatusCode(v int32) *DescribeTransferDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeTransferDomainsResponse) SetBody(v *DescribeTransferDomainsResponseBody) *DescribeTransferDomainsResponse {
	s.Body = v
	return s
}

type ExecuteGtmRecoveryPlanRequest struct {
	// The language used by the user.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the disaster recovery plan that you want to executed.
	RecoveryPlanId *int64 `json:"RecoveryPlanId,omitempty" xml:"RecoveryPlanId,omitempty"`
}

func (s ExecuteGtmRecoveryPlanRequest) String() string {
	return tea.Prettify(s)
}

func (s ExecuteGtmRecoveryPlanRequest) GoString() string {
	return s.String()
}

func (s *ExecuteGtmRecoveryPlanRequest) SetLang(v string) *ExecuteGtmRecoveryPlanRequest {
	s.Lang = &v
	return s
}

func (s *ExecuteGtmRecoveryPlanRequest) SetRecoveryPlanId(v int64) *ExecuteGtmRecoveryPlanRequest {
	s.RecoveryPlanId = &v
	return s
}

type ExecuteGtmRecoveryPlanResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ExecuteGtmRecoveryPlanResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ExecuteGtmRecoveryPlanResponseBody) GoString() string {
	return s.String()
}

func (s *ExecuteGtmRecoveryPlanResponseBody) SetRequestId(v string) *ExecuteGtmRecoveryPlanResponseBody {
	s.RequestId = &v
	return s
}

type ExecuteGtmRecoveryPlanResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ExecuteGtmRecoveryPlanResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ExecuteGtmRecoveryPlanResponse) String() string {
	return tea.Prettify(s)
}

func (s ExecuteGtmRecoveryPlanResponse) GoString() string {
	return s.String()
}

func (s *ExecuteGtmRecoveryPlanResponse) SetHeaders(v map[string]*string) *ExecuteGtmRecoveryPlanResponse {
	s.Headers = v
	return s
}

func (s *ExecuteGtmRecoveryPlanResponse) SetStatusCode(v int32) *ExecuteGtmRecoveryPlanResponse {
	s.StatusCode = &v
	return s
}

func (s *ExecuteGtmRecoveryPlanResponse) SetBody(v *ExecuteGtmRecoveryPlanResponseBody) *ExecuteGtmRecoveryPlanResponse {
	s.Body = v
	return s
}

type GetMainDomainNameRequest struct {
	// The input string. The string can be up to 128 characters in length.
	InputString *string `json:"InputString,omitempty" xml:"InputString,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s GetMainDomainNameRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMainDomainNameRequest) GoString() string {
	return s.String()
}

func (s *GetMainDomainNameRequest) SetInputString(v string) *GetMainDomainNameRequest {
	s.InputString = &v
	return s
}

func (s *GetMainDomainNameRequest) SetLang(v string) *GetMainDomainNameRequest {
	s.Lang = &v
	return s
}

type GetMainDomainNameResponseBody struct {
	// The level of the entered domain name.
	DomainLevel *int64 `json:"DomainLevel,omitempty" xml:"DomainLevel,omitempty"`
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The host record.
	RR *string `json:"RR,omitempty" xml:"RR,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetMainDomainNameResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMainDomainNameResponseBody) GoString() string {
	return s.String()
}

func (s *GetMainDomainNameResponseBody) SetDomainLevel(v int64) *GetMainDomainNameResponseBody {
	s.DomainLevel = &v
	return s
}

func (s *GetMainDomainNameResponseBody) SetDomainName(v string) *GetMainDomainNameResponseBody {
	s.DomainName = &v
	return s
}

func (s *GetMainDomainNameResponseBody) SetRR(v string) *GetMainDomainNameResponseBody {
	s.RR = &v
	return s
}

func (s *GetMainDomainNameResponseBody) SetRequestId(v string) *GetMainDomainNameResponseBody {
	s.RequestId = &v
	return s
}

type GetMainDomainNameResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetMainDomainNameResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetMainDomainNameResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMainDomainNameResponse) GoString() string {
	return s.String()
}

func (s *GetMainDomainNameResponse) SetHeaders(v map[string]*string) *GetMainDomainNameResponse {
	s.Headers = v
	return s
}

func (s *GetMainDomainNameResponse) SetStatusCode(v int32) *GetMainDomainNameResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMainDomainNameResponse) SetBody(v *GetMainDomainNameResponseBody) *GetMainDomainNameResponse {
	s.Body = v
	return s
}

type GetTxtRecordForVerifyRequest struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The function verified by using the TXT record. Valid values:
	//
	// *   ADD_SUBDOMAIN
	// *   RETRIEVAL
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetTxtRecordForVerifyRequest) String() string {
	return tea.Prettify(s)
}

func (s GetTxtRecordForVerifyRequest) GoString() string {
	return s.String()
}

func (s *GetTxtRecordForVerifyRequest) SetDomainName(v string) *GetTxtRecordForVerifyRequest {
	s.DomainName = &v
	return s
}

func (s *GetTxtRecordForVerifyRequest) SetLang(v string) *GetTxtRecordForVerifyRequest {
	s.Lang = &v
	return s
}

func (s *GetTxtRecordForVerifyRequest) SetType(v string) *GetTxtRecordForVerifyRequest {
	s.Type = &v
	return s
}

type GetTxtRecordForVerifyResponseBody struct {
	// The domain name.
	//
	// >  If you do not specify this parameter, it is not returned.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The host record.
	RR *string `json:"RR,omitempty" xml:"RR,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The value of the DNS record.
	//
	// >  The validity period is three days.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetTxtRecordForVerifyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetTxtRecordForVerifyResponseBody) GoString() string {
	return s.String()
}

func (s *GetTxtRecordForVerifyResponseBody) SetDomainName(v string) *GetTxtRecordForVerifyResponseBody {
	s.DomainName = &v
	return s
}

func (s *GetTxtRecordForVerifyResponseBody) SetRR(v string) *GetTxtRecordForVerifyResponseBody {
	s.RR = &v
	return s
}

func (s *GetTxtRecordForVerifyResponseBody) SetRequestId(v string) *GetTxtRecordForVerifyResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetTxtRecordForVerifyResponseBody) SetValue(v string) *GetTxtRecordForVerifyResponseBody {
	s.Value = &v
	return s
}

type GetTxtRecordForVerifyResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetTxtRecordForVerifyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetTxtRecordForVerifyResponse) String() string {
	return tea.Prettify(s)
}

func (s GetTxtRecordForVerifyResponse) GoString() string {
	return s.String()
}

func (s *GetTxtRecordForVerifyResponse) SetHeaders(v map[string]*string) *GetTxtRecordForVerifyResponse {
	s.Headers = v
	return s
}

func (s *GetTxtRecordForVerifyResponse) SetStatusCode(v int32) *GetTxtRecordForVerifyResponse {
	s.StatusCode = &v
	return s
}

func (s *GetTxtRecordForVerifyResponse) SetBody(v *GetTxtRecordForVerifyResponseBody) *GetTxtRecordForVerifyResponse {
	s.Body = v
	return s
}

type ListTagResourcesRequest struct {
	// The language.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the resource.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The key-value pairs of tags.
	Tag []*ListTagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s ListTagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequest) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequest) SetLang(v string) *ListTagResourcesRequest {
	s.Lang = &v
	return s
}

func (s *ListTagResourcesRequest) SetNextToken(v string) *ListTagResourcesRequest {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceId(v []*string) *ListTagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *ListTagResourcesRequest) SetResourceType(v string) *ListTagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesRequest) SetTag(v []*ListTagResourcesRequestTag) *ListTagResourcesRequest {
	s.Tag = v
	return s
}

type ListTagResourcesRequestTag struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequestTag) SetKey(v string) *ListTagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *ListTagResourcesRequestTag) SetValue(v string) *ListTagResourcesRequestTag {
	s.Value = &v
	return s
}

type ListTagResourcesResponseBody struct {
	// The returned value of NextToken is a pagination token, which can be used in the next request to retrieve a new page of results. If the NextToken parameter is empty, no next page exists.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The unique ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Details of the resource and tags, such as the resource ID, the resource type, tag keys, and tag values.
	TagResources []*ListTagResourcesResponseBodyTagResources `json:"TagResources,omitempty" xml:"TagResources,omitempty" type:"Repeated"`
}

func (s ListTagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBody) SetNextToken(v string) *ListTagResourcesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetRequestId(v string) *ListTagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetTagResources(v []*ListTagResourcesResponseBodyTagResources) *ListTagResourcesResponseBody {
	s.TagResources = v
	return s
}

type ListTagResourcesResponseBodyTagResources struct {
	// The ID of the resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource. The returned parameter value is fixed to DOMAIN.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The key of the tag.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The tag value.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s ListTagResourcesResponseBodyTagResources) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResources) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResources) SetResourceId(v string) *ListTagResourcesResponseBodyTagResources {
	s.ResourceId = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResources) SetResourceType(v string) *ListTagResourcesResponseBodyTagResources {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResources) SetTagKey(v string) *ListTagResourcesResponseBodyTagResources {
	s.TagKey = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResources) SetTagValue(v string) *ListTagResourcesResponseBodyTagResources {
	s.TagValue = &v
	return s
}

type ListTagResourcesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponse) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponse) SetHeaders(v map[string]*string) *ListTagResourcesResponse {
	s.Headers = v
	return s
}

func (s *ListTagResourcesResponse) SetStatusCode(v int32) *ListTagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTagResourcesResponse) SetBody(v *ListTagResourcesResponseBody) *ListTagResourcesResponse {
	s.Body = v
	return s
}

type ModifyHichinaDomainDNSRequest struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The IP address of the client.
	UserClientIp *string `json:"UserClientIp,omitempty" xml:"UserClientIp,omitempty"`
}

func (s ModifyHichinaDomainDNSRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyHichinaDomainDNSRequest) GoString() string {
	return s.String()
}

func (s *ModifyHichinaDomainDNSRequest) SetDomainName(v string) *ModifyHichinaDomainDNSRequest {
	s.DomainName = &v
	return s
}

func (s *ModifyHichinaDomainDNSRequest) SetLang(v string) *ModifyHichinaDomainDNSRequest {
	s.Lang = &v
	return s
}

func (s *ModifyHichinaDomainDNSRequest) SetUserClientIp(v string) *ModifyHichinaDomainDNSRequest {
	s.UserClientIp = &v
	return s
}

type ModifyHichinaDomainDNSResponseBody struct {
	// The list of DNS servers after the domain name is changed.
	NewDnsServers *ModifyHichinaDomainDNSResponseBodyNewDnsServers `json:"NewDnsServers,omitempty" xml:"NewDnsServers,omitempty" type:"Struct"`
	// The list of DNS servers before the domain name is changed.
	OriginalDnsServers *ModifyHichinaDomainDNSResponseBodyOriginalDnsServers `json:"OriginalDnsServers,omitempty" xml:"OriginalDnsServers,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyHichinaDomainDNSResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyHichinaDomainDNSResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyHichinaDomainDNSResponseBody) SetNewDnsServers(v *ModifyHichinaDomainDNSResponseBodyNewDnsServers) *ModifyHichinaDomainDNSResponseBody {
	s.NewDnsServers = v
	return s
}

func (s *ModifyHichinaDomainDNSResponseBody) SetOriginalDnsServers(v *ModifyHichinaDomainDNSResponseBodyOriginalDnsServers) *ModifyHichinaDomainDNSResponseBody {
	s.OriginalDnsServers = v
	return s
}

func (s *ModifyHichinaDomainDNSResponseBody) SetRequestId(v string) *ModifyHichinaDomainDNSResponseBody {
	s.RequestId = &v
	return s
}

type ModifyHichinaDomainDNSResponseBodyNewDnsServers struct {
	DnsServer []*string `json:"DnsServer,omitempty" xml:"DnsServer,omitempty" type:"Repeated"`
}

func (s ModifyHichinaDomainDNSResponseBodyNewDnsServers) String() string {
	return tea.Prettify(s)
}

func (s ModifyHichinaDomainDNSResponseBodyNewDnsServers) GoString() string {
	return s.String()
}

func (s *ModifyHichinaDomainDNSResponseBodyNewDnsServers) SetDnsServer(v []*string) *ModifyHichinaDomainDNSResponseBodyNewDnsServers {
	s.DnsServer = v
	return s
}

type ModifyHichinaDomainDNSResponseBodyOriginalDnsServers struct {
	DnsServer []*string `json:"DnsServer,omitempty" xml:"DnsServer,omitempty" type:"Repeated"`
}

func (s ModifyHichinaDomainDNSResponseBodyOriginalDnsServers) String() string {
	return tea.Prettify(s)
}

func (s ModifyHichinaDomainDNSResponseBodyOriginalDnsServers) GoString() string {
	return s.String()
}

func (s *ModifyHichinaDomainDNSResponseBodyOriginalDnsServers) SetDnsServer(v []*string) *ModifyHichinaDomainDNSResponseBodyOriginalDnsServers {
	s.DnsServer = v
	return s
}

type ModifyHichinaDomainDNSResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyHichinaDomainDNSResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyHichinaDomainDNSResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyHichinaDomainDNSResponse) GoString() string {
	return s.String()
}

func (s *ModifyHichinaDomainDNSResponse) SetHeaders(v map[string]*string) *ModifyHichinaDomainDNSResponse {
	s.Headers = v
	return s
}

func (s *ModifyHichinaDomainDNSResponse) SetStatusCode(v int32) *ModifyHichinaDomainDNSResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyHichinaDomainDNSResponse) SetBody(v *ModifyHichinaDomainDNSResponseBody) *ModifyHichinaDomainDNSResponse {
	s.Body = v
	return s
}

type MoveDomainResourceGroupRequest struct {
	// The language of some returned parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the resource group.
	NewResourceGroupId *string `json:"NewResourceGroupId,omitempty" xml:"NewResourceGroupId,omitempty"`
	// The domain name.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
}

func (s MoveDomainResourceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s MoveDomainResourceGroupRequest) GoString() string {
	return s.String()
}

func (s *MoveDomainResourceGroupRequest) SetLang(v string) *MoveDomainResourceGroupRequest {
	s.Lang = &v
	return s
}

func (s *MoveDomainResourceGroupRequest) SetNewResourceGroupId(v string) *MoveDomainResourceGroupRequest {
	s.NewResourceGroupId = &v
	return s
}

func (s *MoveDomainResourceGroupRequest) SetResourceId(v string) *MoveDomainResourceGroupRequest {
	s.ResourceId = &v
	return s
}

type MoveDomainResourceGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s MoveDomainResourceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s MoveDomainResourceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *MoveDomainResourceGroupResponseBody) SetRequestId(v string) *MoveDomainResourceGroupResponseBody {
	s.RequestId = &v
	return s
}

type MoveDomainResourceGroupResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *MoveDomainResourceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s MoveDomainResourceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s MoveDomainResourceGroupResponse) GoString() string {
	return s.String()
}

func (s *MoveDomainResourceGroupResponse) SetHeaders(v map[string]*string) *MoveDomainResourceGroupResponse {
	s.Headers = v
	return s
}

func (s *MoveDomainResourceGroupResponse) SetStatusCode(v int32) *MoveDomainResourceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *MoveDomainResourceGroupResponse) SetBody(v *MoveDomainResourceGroupResponseBody) *MoveDomainResourceGroupResponse {
	s.Body = v
	return s
}

type MoveGtmResourceGroupRequest struct {
	Lang               *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	NewResourceGroupId *string `json:"NewResourceGroupId,omitempty" xml:"NewResourceGroupId,omitempty"`
	ResourceId         *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
}

func (s MoveGtmResourceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s MoveGtmResourceGroupRequest) GoString() string {
	return s.String()
}

func (s *MoveGtmResourceGroupRequest) SetLang(v string) *MoveGtmResourceGroupRequest {
	s.Lang = &v
	return s
}

func (s *MoveGtmResourceGroupRequest) SetNewResourceGroupId(v string) *MoveGtmResourceGroupRequest {
	s.NewResourceGroupId = &v
	return s
}

func (s *MoveGtmResourceGroupRequest) SetResourceId(v string) *MoveGtmResourceGroupRequest {
	s.ResourceId = &v
	return s
}

type MoveGtmResourceGroupResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s MoveGtmResourceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s MoveGtmResourceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *MoveGtmResourceGroupResponseBody) SetRequestId(v string) *MoveGtmResourceGroupResponseBody {
	s.RequestId = &v
	return s
}

type MoveGtmResourceGroupResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *MoveGtmResourceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s MoveGtmResourceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s MoveGtmResourceGroupResponse) GoString() string {
	return s.String()
}

func (s *MoveGtmResourceGroupResponse) SetHeaders(v map[string]*string) *MoveGtmResourceGroupResponse {
	s.Headers = v
	return s
}

func (s *MoveGtmResourceGroupResponse) SetStatusCode(v int32) *MoveGtmResourceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *MoveGtmResourceGroupResponse) SetBody(v *MoveGtmResourceGroupResponseBody) *MoveGtmResourceGroupResponse {
	s.Body = v
	return s
}

type OperateBatchDomainRequest struct {
	DomainRecordInfo []*OperateBatchDomainRequestDomainRecordInfo `json:"DomainRecordInfo,omitempty" xml:"DomainRecordInfo,omitempty" type:"Repeated"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The type of the batch operation. Valid values:
	//
	// *   **DOMAIN_ADD**: adds domain names in batches.
	// *   **DOMAIN_DEL**: deletes domain names in batches.
	// *   **RR_ADD**: adds DNS records in batches.
	// *   **RR_DEL**: deletes DNS records in batches. (If RR or VALUE exists, DNS records corresponding to the specified RR or VALUE are deleted. If both of them exist, DNS records corresponding to the specified RR and VALUE are deleted. If no RR or VALUE is specified, the DNS records corresponding to the DomainName parameter are deleted.)
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s OperateBatchDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s OperateBatchDomainRequest) GoString() string {
	return s.String()
}

func (s *OperateBatchDomainRequest) SetDomainRecordInfo(v []*OperateBatchDomainRequestDomainRecordInfo) *OperateBatchDomainRequest {
	s.DomainRecordInfo = v
	return s
}

func (s *OperateBatchDomainRequest) SetLang(v string) *OperateBatchDomainRequest {
	s.Lang = &v
	return s
}

func (s *OperateBatchDomainRequest) SetType(v string) *OperateBatchDomainRequest {
	s.Type = &v
	return s
}

type OperateBatchDomainRequestDomainRecordInfo struct {
	// The domain name corresponding to DNS record N.
	//
	// >  N is specified by users. **N** starts from **1**. The maximum value of N is **1000**. Extra data entries are ignored.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The resolution line of DNS record N. Default value: default.
	//
	// For more information, see [Resolution line enumeration](https://www.alibabacloud.com/help/zh/doc-detail/29807.htm).
	Line     *string `json:"Line,omitempty" xml:"Line,omitempty"`
	NewRr    *string `json:"NewRr,omitempty" xml:"NewRr,omitempty"`
	NewType  *string `json:"NewType,omitempty" xml:"NewType,omitempty"`
	NewValue *string `json:"NewValue,omitempty" xml:"NewValue,omitempty"`
	// The priority of MX-type DNS record N.
	//
	// This parameter must be specified if the type of the DNS record is MX. Default value: 10.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The host record corresponding to DNS record N.
	//
	// >  If you set the Type parameter to **RR_ADD**, you must also specify this parameter.
	Rr *string `json:"Rr,omitempty" xml:"Rr,omitempty"`
	// The TTL of DNS record N. Unit: seconds. Default value: **600**.
	Ttl *int32 `json:"Ttl,omitempty" xml:"Ttl,omitempty"`
	// The type of DNS record N. For the DNS record types supported by Alibaba Cloud DNS, see [Resolution record type formats](https://www.alibabacloud.com/help/zh/doc-detail/29805.htm).
	//
	// >  If you set the Type parameter to **RR_ADD**, you must also specify this parameter.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value of DNS record N.
	//
	// >  If you set the Type parameter to **RR_ADD**, you must also specify this parameter.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s OperateBatchDomainRequestDomainRecordInfo) String() string {
	return tea.Prettify(s)
}

func (s OperateBatchDomainRequestDomainRecordInfo) GoString() string {
	return s.String()
}

func (s *OperateBatchDomainRequestDomainRecordInfo) SetDomain(v string) *OperateBatchDomainRequestDomainRecordInfo {
	s.Domain = &v
	return s
}

func (s *OperateBatchDomainRequestDomainRecordInfo) SetLine(v string) *OperateBatchDomainRequestDomainRecordInfo {
	s.Line = &v
	return s
}

func (s *OperateBatchDomainRequestDomainRecordInfo) SetNewRr(v string) *OperateBatchDomainRequestDomainRecordInfo {
	s.NewRr = &v
	return s
}

func (s *OperateBatchDomainRequestDomainRecordInfo) SetNewType(v string) *OperateBatchDomainRequestDomainRecordInfo {
	s.NewType = &v
	return s
}

func (s *OperateBatchDomainRequestDomainRecordInfo) SetNewValue(v string) *OperateBatchDomainRequestDomainRecordInfo {
	s.NewValue = &v
	return s
}

func (s *OperateBatchDomainRequestDomainRecordInfo) SetPriority(v int32) *OperateBatchDomainRequestDomainRecordInfo {
	s.Priority = &v
	return s
}

func (s *OperateBatchDomainRequestDomainRecordInfo) SetRr(v string) *OperateBatchDomainRequestDomainRecordInfo {
	s.Rr = &v
	return s
}

func (s *OperateBatchDomainRequestDomainRecordInfo) SetTtl(v int32) *OperateBatchDomainRequestDomainRecordInfo {
	s.Ttl = &v
	return s
}

func (s *OperateBatchDomainRequestDomainRecordInfo) SetType(v string) *OperateBatchDomainRequestDomainRecordInfo {
	s.Type = &v
	return s
}

func (s *OperateBatchDomainRequestDomainRecordInfo) SetValue(v string) *OperateBatchDomainRequestDomainRecordInfo {
	s.Value = &v
	return s
}

type OperateBatchDomainResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the task.
	TaskId *int64 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s OperateBatchDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s OperateBatchDomainResponseBody) GoString() string {
	return s.String()
}

func (s *OperateBatchDomainResponseBody) SetRequestId(v string) *OperateBatchDomainResponseBody {
	s.RequestId = &v
	return s
}

func (s *OperateBatchDomainResponseBody) SetTaskId(v int64) *OperateBatchDomainResponseBody {
	s.TaskId = &v
	return s
}

type OperateBatchDomainResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *OperateBatchDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s OperateBatchDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s OperateBatchDomainResponse) GoString() string {
	return s.String()
}

func (s *OperateBatchDomainResponse) SetHeaders(v map[string]*string) *OperateBatchDomainResponse {
	s.Headers = v
	return s
}

func (s *OperateBatchDomainResponse) SetStatusCode(v int32) *OperateBatchDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *OperateBatchDomainResponse) SetBody(v *OperateBatchDomainResponseBody) *OperateBatchDomainResponse {
	s.Body = v
	return s
}

type PausePdnsServiceRequest struct {
	Lang        *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	ServiceType *string `json:"ServiceType,omitempty" xml:"ServiceType,omitempty"`
}

func (s PausePdnsServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s PausePdnsServiceRequest) GoString() string {
	return s.String()
}

func (s *PausePdnsServiceRequest) SetLang(v string) *PausePdnsServiceRequest {
	s.Lang = &v
	return s
}

func (s *PausePdnsServiceRequest) SetServiceType(v string) *PausePdnsServiceRequest {
	s.ServiceType = &v
	return s
}

type PausePdnsServiceResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s PausePdnsServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PausePdnsServiceResponseBody) GoString() string {
	return s.String()
}

func (s *PausePdnsServiceResponseBody) SetRequestId(v string) *PausePdnsServiceResponseBody {
	s.RequestId = &v
	return s
}

type PausePdnsServiceResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PausePdnsServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PausePdnsServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s PausePdnsServiceResponse) GoString() string {
	return s.String()
}

func (s *PausePdnsServiceResponse) SetHeaders(v map[string]*string) *PausePdnsServiceResponse {
	s.Headers = v
	return s
}

func (s *PausePdnsServiceResponse) SetStatusCode(v int32) *PausePdnsServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *PausePdnsServiceResponse) SetBody(v *PausePdnsServiceResponseBody) *PausePdnsServiceResponse {
	s.Body = v
	return s
}

type PreviewGtmRecoveryPlanRequest struct {
	// The language used by the user.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The number of the page to return. Pages start from page **1**. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on per page. Maximum value: **20**. Default value: **5**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the disaster recovery plan that you want to preview.
	RecoveryPlanId *int64 `json:"RecoveryPlanId,omitempty" xml:"RecoveryPlanId,omitempty"`
}

func (s PreviewGtmRecoveryPlanRequest) String() string {
	return tea.Prettify(s)
}

func (s PreviewGtmRecoveryPlanRequest) GoString() string {
	return s.String()
}

func (s *PreviewGtmRecoveryPlanRequest) SetLang(v string) *PreviewGtmRecoveryPlanRequest {
	s.Lang = &v
	return s
}

func (s *PreviewGtmRecoveryPlanRequest) SetPageNumber(v int32) *PreviewGtmRecoveryPlanRequest {
	s.PageNumber = &v
	return s
}

func (s *PreviewGtmRecoveryPlanRequest) SetPageSize(v int32) *PreviewGtmRecoveryPlanRequest {
	s.PageSize = &v
	return s
}

func (s *PreviewGtmRecoveryPlanRequest) SetRecoveryPlanId(v int64) *PreviewGtmRecoveryPlanRequest {
	s.RecoveryPlanId = &v
	return s
}

type PreviewGtmRecoveryPlanResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The returned preview information of the disaster recovery plan.
	Previews *PreviewGtmRecoveryPlanResponseBodyPreviews `json:"Previews,omitempty" xml:"Previews,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned on all pages.
	TotalItems *int32 `json:"TotalItems,omitempty" xml:"TotalItems,omitempty"`
	// The total number of pages returned.
	TotalPages *int32 `json:"TotalPages,omitempty" xml:"TotalPages,omitempty"`
}

func (s PreviewGtmRecoveryPlanResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PreviewGtmRecoveryPlanResponseBody) GoString() string {
	return s.String()
}

func (s *PreviewGtmRecoveryPlanResponseBody) SetPageNumber(v int32) *PreviewGtmRecoveryPlanResponseBody {
	s.PageNumber = &v
	return s
}

func (s *PreviewGtmRecoveryPlanResponseBody) SetPageSize(v int32) *PreviewGtmRecoveryPlanResponseBody {
	s.PageSize = &v
	return s
}

func (s *PreviewGtmRecoveryPlanResponseBody) SetPreviews(v *PreviewGtmRecoveryPlanResponseBodyPreviews) *PreviewGtmRecoveryPlanResponseBody {
	s.Previews = v
	return s
}

func (s *PreviewGtmRecoveryPlanResponseBody) SetRequestId(v string) *PreviewGtmRecoveryPlanResponseBody {
	s.RequestId = &v
	return s
}

func (s *PreviewGtmRecoveryPlanResponseBody) SetTotalItems(v int32) *PreviewGtmRecoveryPlanResponseBody {
	s.TotalItems = &v
	return s
}

func (s *PreviewGtmRecoveryPlanResponseBody) SetTotalPages(v int32) *PreviewGtmRecoveryPlanResponseBody {
	s.TotalPages = &v
	return s
}

type PreviewGtmRecoveryPlanResponseBodyPreviews struct {
	Preview []*PreviewGtmRecoveryPlanResponseBodyPreviewsPreview `json:"Preview,omitempty" xml:"Preview,omitempty" type:"Repeated"`
}

func (s PreviewGtmRecoveryPlanResponseBodyPreviews) String() string {
	return tea.Prettify(s)
}

func (s PreviewGtmRecoveryPlanResponseBodyPreviews) GoString() string {
	return s.String()
}

func (s *PreviewGtmRecoveryPlanResponseBodyPreviews) SetPreview(v []*PreviewGtmRecoveryPlanResponseBodyPreviewsPreview) *PreviewGtmRecoveryPlanResponseBodyPreviews {
	s.Preview = v
	return s
}

type PreviewGtmRecoveryPlanResponseBodyPreviewsPreview struct {
	// The ID of the GTM instance to which the previewed disaster recovery plan belongs.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the GTM instance to which the previewed disaster recovery plan belongs.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The returned information of the switching policies for address pools.
	SwitchInfos *PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfos `json:"SwitchInfos,omitempty" xml:"SwitchInfos,omitempty" type:"Struct"`
	// The user\"s domain name or domain name list.
	UserDomainName *string `json:"UserDomainName,omitempty" xml:"UserDomainName,omitempty"`
}

func (s PreviewGtmRecoveryPlanResponseBodyPreviewsPreview) String() string {
	return tea.Prettify(s)
}

func (s PreviewGtmRecoveryPlanResponseBodyPreviewsPreview) GoString() string {
	return s.String()
}

func (s *PreviewGtmRecoveryPlanResponseBodyPreviewsPreview) SetInstanceId(v string) *PreviewGtmRecoveryPlanResponseBodyPreviewsPreview {
	s.InstanceId = &v
	return s
}

func (s *PreviewGtmRecoveryPlanResponseBodyPreviewsPreview) SetName(v string) *PreviewGtmRecoveryPlanResponseBodyPreviewsPreview {
	s.Name = &v
	return s
}

func (s *PreviewGtmRecoveryPlanResponseBodyPreviewsPreview) SetSwitchInfos(v *PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfos) *PreviewGtmRecoveryPlanResponseBodyPreviewsPreview {
	s.SwitchInfos = v
	return s
}

func (s *PreviewGtmRecoveryPlanResponseBodyPreviewsPreview) SetUserDomainName(v string) *PreviewGtmRecoveryPlanResponseBodyPreviewsPreview {
	s.UserDomainName = &v
	return s
}

type PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfos struct {
	SwitchInfo []*PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfosSwitchInfo `json:"SwitchInfo,omitempty" xml:"SwitchInfo,omitempty" type:"Repeated"`
}

func (s PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfos) String() string {
	return tea.Prettify(s)
}

func (s PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfos) GoString() string {
	return s.String()
}

func (s *PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfos) SetSwitchInfo(v []*PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfosSwitchInfo) *PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfos {
	s.SwitchInfo = v
	return s
}

type PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfosSwitchInfo struct {
	// The formatted message content.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The name of the switching policy for address pools.
	StrategyName *string `json:"StrategyName,omitempty" xml:"StrategyName,omitempty"`
}

func (s PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfosSwitchInfo) String() string {
	return tea.Prettify(s)
}

func (s PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfosSwitchInfo) GoString() string {
	return s.String()
}

func (s *PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfosSwitchInfo) SetContent(v string) *PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfosSwitchInfo {
	s.Content = &v
	return s
}

func (s *PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfosSwitchInfo) SetStrategyName(v string) *PreviewGtmRecoveryPlanResponseBodyPreviewsPreviewSwitchInfosSwitchInfo {
	s.StrategyName = &v
	return s
}

type PreviewGtmRecoveryPlanResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PreviewGtmRecoveryPlanResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PreviewGtmRecoveryPlanResponse) String() string {
	return tea.Prettify(s)
}

func (s PreviewGtmRecoveryPlanResponse) GoString() string {
	return s.String()
}

func (s *PreviewGtmRecoveryPlanResponse) SetHeaders(v map[string]*string) *PreviewGtmRecoveryPlanResponse {
	s.Headers = v
	return s
}

func (s *PreviewGtmRecoveryPlanResponse) SetStatusCode(v int32) *PreviewGtmRecoveryPlanResponse {
	s.StatusCode = &v
	return s
}

func (s *PreviewGtmRecoveryPlanResponse) SetBody(v *PreviewGtmRecoveryPlanResponseBody) *PreviewGtmRecoveryPlanResponse {
	s.Body = v
	return s
}

type RemovePdnsAppKeyRequest struct {
	AppKeyId *string `json:"AppKeyId,omitempty" xml:"AppKeyId,omitempty"`
	Lang     *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s RemovePdnsAppKeyRequest) String() string {
	return tea.Prettify(s)
}

func (s RemovePdnsAppKeyRequest) GoString() string {
	return s.String()
}

func (s *RemovePdnsAppKeyRequest) SetAppKeyId(v string) *RemovePdnsAppKeyRequest {
	s.AppKeyId = &v
	return s
}

func (s *RemovePdnsAppKeyRequest) SetLang(v string) *RemovePdnsAppKeyRequest {
	s.Lang = &v
	return s
}

type RemovePdnsAppKeyResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RemovePdnsAppKeyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemovePdnsAppKeyResponseBody) GoString() string {
	return s.String()
}

func (s *RemovePdnsAppKeyResponseBody) SetRequestId(v string) *RemovePdnsAppKeyResponseBody {
	s.RequestId = &v
	return s
}

type RemovePdnsAppKeyResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemovePdnsAppKeyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemovePdnsAppKeyResponse) String() string {
	return tea.Prettify(s)
}

func (s RemovePdnsAppKeyResponse) GoString() string {
	return s.String()
}

func (s *RemovePdnsAppKeyResponse) SetHeaders(v map[string]*string) *RemovePdnsAppKeyResponse {
	s.Headers = v
	return s
}

func (s *RemovePdnsAppKeyResponse) SetStatusCode(v int32) *RemovePdnsAppKeyResponse {
	s.StatusCode = &v
	return s
}

func (s *RemovePdnsAppKeyResponse) SetBody(v *RemovePdnsAppKeyResponseBody) *RemovePdnsAppKeyResponse {
	s.Body = v
	return s
}

type RemovePdnsUdpIpSegmentRequest struct {
	Ip   *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s RemovePdnsUdpIpSegmentRequest) String() string {
	return tea.Prettify(s)
}

func (s RemovePdnsUdpIpSegmentRequest) GoString() string {
	return s.String()
}

func (s *RemovePdnsUdpIpSegmentRequest) SetIp(v string) *RemovePdnsUdpIpSegmentRequest {
	s.Ip = &v
	return s
}

func (s *RemovePdnsUdpIpSegmentRequest) SetLang(v string) *RemovePdnsUdpIpSegmentRequest {
	s.Lang = &v
	return s
}

type RemovePdnsUdpIpSegmentResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RemovePdnsUdpIpSegmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemovePdnsUdpIpSegmentResponseBody) GoString() string {
	return s.String()
}

func (s *RemovePdnsUdpIpSegmentResponseBody) SetRequestId(v string) *RemovePdnsUdpIpSegmentResponseBody {
	s.RequestId = &v
	return s
}

type RemovePdnsUdpIpSegmentResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemovePdnsUdpIpSegmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemovePdnsUdpIpSegmentResponse) String() string {
	return tea.Prettify(s)
}

func (s RemovePdnsUdpIpSegmentResponse) GoString() string {
	return s.String()
}

func (s *RemovePdnsUdpIpSegmentResponse) SetHeaders(v map[string]*string) *RemovePdnsUdpIpSegmentResponse {
	s.Headers = v
	return s
}

func (s *RemovePdnsUdpIpSegmentResponse) SetStatusCode(v int32) *RemovePdnsUdpIpSegmentResponse {
	s.StatusCode = &v
	return s
}

func (s *RemovePdnsUdpIpSegmentResponse) SetBody(v *RemovePdnsUdpIpSegmentResponseBody) *RemovePdnsUdpIpSegmentResponse {
	s.Body = v
	return s
}

type ResumePdnsServiceRequest struct {
	Lang        *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	ServiceType *string `json:"ServiceType,omitempty" xml:"ServiceType,omitempty"`
}

func (s ResumePdnsServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s ResumePdnsServiceRequest) GoString() string {
	return s.String()
}

func (s *ResumePdnsServiceRequest) SetLang(v string) *ResumePdnsServiceRequest {
	s.Lang = &v
	return s
}

func (s *ResumePdnsServiceRequest) SetServiceType(v string) *ResumePdnsServiceRequest {
	s.ServiceType = &v
	return s
}

type ResumePdnsServiceResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ResumePdnsServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ResumePdnsServiceResponseBody) GoString() string {
	return s.String()
}

func (s *ResumePdnsServiceResponseBody) SetRequestId(v string) *ResumePdnsServiceResponseBody {
	s.RequestId = &v
	return s
}

type ResumePdnsServiceResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ResumePdnsServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ResumePdnsServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s ResumePdnsServiceResponse) GoString() string {
	return s.String()
}

func (s *ResumePdnsServiceResponse) SetHeaders(v map[string]*string) *ResumePdnsServiceResponse {
	s.Headers = v
	return s
}

func (s *ResumePdnsServiceResponse) SetStatusCode(v int32) *ResumePdnsServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *ResumePdnsServiceResponse) SetBody(v *ResumePdnsServiceResponseBody) *ResumePdnsServiceResponse {
	s.Body = v
	return s
}

type RetrieveDomainRequest struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s RetrieveDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s RetrieveDomainRequest) GoString() string {
	return s.String()
}

func (s *RetrieveDomainRequest) SetDomainName(v string) *RetrieveDomainRequest {
	s.DomainName = &v
	return s
}

func (s *RetrieveDomainRequest) SetLang(v string) *RetrieveDomainRequest {
	s.Lang = &v
	return s
}

type RetrieveDomainResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RetrieveDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RetrieveDomainResponseBody) GoString() string {
	return s.String()
}

func (s *RetrieveDomainResponseBody) SetRequestId(v string) *RetrieveDomainResponseBody {
	s.RequestId = &v
	return s
}

type RetrieveDomainResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RetrieveDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RetrieveDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s RetrieveDomainResponse) GoString() string {
	return s.String()
}

func (s *RetrieveDomainResponse) SetHeaders(v map[string]*string) *RetrieveDomainResponse {
	s.Headers = v
	return s
}

func (s *RetrieveDomainResponse) SetStatusCode(v int32) *RetrieveDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *RetrieveDomainResponse) SetBody(v *RetrieveDomainResponseBody) *RetrieveDomainResponse {
	s.Body = v
	return s
}

type RollbackGtmRecoveryPlanRequest struct {
	// The language used by the user.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the disaster recovery plan that you want to roll back.
	RecoveryPlanId *int64 `json:"RecoveryPlanId,omitempty" xml:"RecoveryPlanId,omitempty"`
}

func (s RollbackGtmRecoveryPlanRequest) String() string {
	return tea.Prettify(s)
}

func (s RollbackGtmRecoveryPlanRequest) GoString() string {
	return s.String()
}

func (s *RollbackGtmRecoveryPlanRequest) SetLang(v string) *RollbackGtmRecoveryPlanRequest {
	s.Lang = &v
	return s
}

func (s *RollbackGtmRecoveryPlanRequest) SetRecoveryPlanId(v int64) *RollbackGtmRecoveryPlanRequest {
	s.RecoveryPlanId = &v
	return s
}

type RollbackGtmRecoveryPlanResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RollbackGtmRecoveryPlanResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RollbackGtmRecoveryPlanResponseBody) GoString() string {
	return s.String()
}

func (s *RollbackGtmRecoveryPlanResponseBody) SetRequestId(v string) *RollbackGtmRecoveryPlanResponseBody {
	s.RequestId = &v
	return s
}

type RollbackGtmRecoveryPlanResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RollbackGtmRecoveryPlanResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RollbackGtmRecoveryPlanResponse) String() string {
	return tea.Prettify(s)
}

func (s RollbackGtmRecoveryPlanResponse) GoString() string {
	return s.String()
}

func (s *RollbackGtmRecoveryPlanResponse) SetHeaders(v map[string]*string) *RollbackGtmRecoveryPlanResponse {
	s.Headers = v
	return s
}

func (s *RollbackGtmRecoveryPlanResponse) SetStatusCode(v int32) *RollbackGtmRecoveryPlanResponse {
	s.StatusCode = &v
	return s
}

func (s *RollbackGtmRecoveryPlanResponse) SetBody(v *RollbackGtmRecoveryPlanResponseBody) *RollbackGtmRecoveryPlanResponse {
	s.Body = v
	return s
}

type SetDNSSLBStatusRequest struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The language of the subdomain.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	Line *string `json:"Line,omitempty" xml:"Line,omitempty"`
	// Specifies whether to enable or disable weighted round-robin. Valid values:
	//
	// *   **true**: enables weighted round-robin. This is the default value.
	// *   **false**: disables weighted round-robin.
	Open *bool `json:"Open,omitempty" xml:"Open,omitempty"`
	// The subdomain for which you want to configure weighted round-robin. Do not set the value to a string such as aliyun.com. Instead, set the value to @.aliyun.com.
	SubDomain *string `json:"SubDomain,omitempty" xml:"SubDomain,omitempty"`
	// The type of the DNS record. Valid values: A and AAAA. Default value: A.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The IP address of the client that you use to configure weighted round-robin.
	UserClientIp *string `json:"UserClientIp,omitempty" xml:"UserClientIp,omitempty"`
}

func (s SetDNSSLBStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDNSSLBStatusRequest) GoString() string {
	return s.String()
}

func (s *SetDNSSLBStatusRequest) SetDomainName(v string) *SetDNSSLBStatusRequest {
	s.DomainName = &v
	return s
}

func (s *SetDNSSLBStatusRequest) SetLang(v string) *SetDNSSLBStatusRequest {
	s.Lang = &v
	return s
}

func (s *SetDNSSLBStatusRequest) SetLine(v string) *SetDNSSLBStatusRequest {
	s.Line = &v
	return s
}

func (s *SetDNSSLBStatusRequest) SetOpen(v bool) *SetDNSSLBStatusRequest {
	s.Open = &v
	return s
}

func (s *SetDNSSLBStatusRequest) SetSubDomain(v string) *SetDNSSLBStatusRequest {
	s.SubDomain = &v
	return s
}

func (s *SetDNSSLBStatusRequest) SetType(v string) *SetDNSSLBStatusRequest {
	s.Type = &v
	return s
}

func (s *SetDNSSLBStatusRequest) SetUserClientIp(v string) *SetDNSSLBStatusRequest {
	s.UserClientIp = &v
	return s
}

type SetDNSSLBStatusResponseBody struct {
	// Indicates whether weighted round-robin is enabled for the subdomain.
	Open *bool `json:"Open,omitempty" xml:"Open,omitempty"`
	// The number of A records that are matched.
	RecordCount *int64 `json:"RecordCount,omitempty" xml:"RecordCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetDNSSLBStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDNSSLBStatusResponseBody) GoString() string {
	return s.String()
}

func (s *SetDNSSLBStatusResponseBody) SetOpen(v bool) *SetDNSSLBStatusResponseBody {
	s.Open = &v
	return s
}

func (s *SetDNSSLBStatusResponseBody) SetRecordCount(v int64) *SetDNSSLBStatusResponseBody {
	s.RecordCount = &v
	return s
}

func (s *SetDNSSLBStatusResponseBody) SetRequestId(v string) *SetDNSSLBStatusResponseBody {
	s.RequestId = &v
	return s
}

type SetDNSSLBStatusResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDNSSLBStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDNSSLBStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDNSSLBStatusResponse) GoString() string {
	return s.String()
}

func (s *SetDNSSLBStatusResponse) SetHeaders(v map[string]*string) *SetDNSSLBStatusResponse {
	s.Headers = v
	return s
}

func (s *SetDNSSLBStatusResponse) SetStatusCode(v int32) *SetDNSSLBStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDNSSLBStatusResponse) SetBody(v *SetDNSSLBStatusResponseBody) *SetDNSSLBStatusResponse {
	s.Body = v
	return s
}

type SetDnsGtmAccessModeRequest struct {
	// The primary/secondary switchover policy for address pool groups. Valid values:
	//
	// *   AUTO: performs automatic switchover between the primary and secondary address pool groups upon failures.
	// *   DEFAULT: uses the primary address pool group.
	// *   FAILOVER: uses the secondary address pool group.
	AccessMode *string `json:"AccessMode,omitempty" xml:"AccessMode,omitempty"`
	// The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the policy.
	StrategyId *string `json:"StrategyId,omitempty" xml:"StrategyId,omitempty"`
}

func (s SetDnsGtmAccessModeRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDnsGtmAccessModeRequest) GoString() string {
	return s.String()
}

func (s *SetDnsGtmAccessModeRequest) SetAccessMode(v string) *SetDnsGtmAccessModeRequest {
	s.AccessMode = &v
	return s
}

func (s *SetDnsGtmAccessModeRequest) SetLang(v string) *SetDnsGtmAccessModeRequest {
	s.Lang = &v
	return s
}

func (s *SetDnsGtmAccessModeRequest) SetStrategyId(v string) *SetDnsGtmAccessModeRequest {
	s.StrategyId = &v
	return s
}

type SetDnsGtmAccessModeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetDnsGtmAccessModeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDnsGtmAccessModeResponseBody) GoString() string {
	return s.String()
}

func (s *SetDnsGtmAccessModeResponseBody) SetRequestId(v string) *SetDnsGtmAccessModeResponseBody {
	s.RequestId = &v
	return s
}

type SetDnsGtmAccessModeResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDnsGtmAccessModeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDnsGtmAccessModeResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDnsGtmAccessModeResponse) GoString() string {
	return s.String()
}

func (s *SetDnsGtmAccessModeResponse) SetHeaders(v map[string]*string) *SetDnsGtmAccessModeResponse {
	s.Headers = v
	return s
}

func (s *SetDnsGtmAccessModeResponse) SetStatusCode(v int32) *SetDnsGtmAccessModeResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDnsGtmAccessModeResponse) SetBody(v *SetDnsGtmAccessModeResponseBody) *SetDnsGtmAccessModeResponse {
	s.Body = v
	return s
}

type SetDnsGtmMonitorStatusRequest struct {
	// The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the health check task.
	MonitorConfigId *string `json:"MonitorConfigId,omitempty" xml:"MonitorConfigId,omitempty"`
	// Specifies whether to enable the health check feature. Valid values:
	//
	// *   OPEN: enable
	// *   CLOSE: disable
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s SetDnsGtmMonitorStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDnsGtmMonitorStatusRequest) GoString() string {
	return s.String()
}

func (s *SetDnsGtmMonitorStatusRequest) SetLang(v string) *SetDnsGtmMonitorStatusRequest {
	s.Lang = &v
	return s
}

func (s *SetDnsGtmMonitorStatusRequest) SetMonitorConfigId(v string) *SetDnsGtmMonitorStatusRequest {
	s.MonitorConfigId = &v
	return s
}

func (s *SetDnsGtmMonitorStatusRequest) SetStatus(v string) *SetDnsGtmMonitorStatusRequest {
	s.Status = &v
	return s
}

type SetDnsGtmMonitorStatusResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetDnsGtmMonitorStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDnsGtmMonitorStatusResponseBody) GoString() string {
	return s.String()
}

func (s *SetDnsGtmMonitorStatusResponseBody) SetRequestId(v string) *SetDnsGtmMonitorStatusResponseBody {
	s.RequestId = &v
	return s
}

type SetDnsGtmMonitorStatusResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDnsGtmMonitorStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDnsGtmMonitorStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDnsGtmMonitorStatusResponse) GoString() string {
	return s.String()
}

func (s *SetDnsGtmMonitorStatusResponse) SetHeaders(v map[string]*string) *SetDnsGtmMonitorStatusResponse {
	s.Headers = v
	return s
}

func (s *SetDnsGtmMonitorStatusResponse) SetStatusCode(v int32) *SetDnsGtmMonitorStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDnsGtmMonitorStatusResponse) SetBody(v *SetDnsGtmMonitorStatusResponseBody) *SetDnsGtmMonitorStatusResponse {
	s.Body = v
	return s
}

type SetDomainDnssecStatusRequest struct {
	// The domain name for which you want to set the DNSSEC status.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The DNSSEC status. Valid values:
	//
	// *   ON: enables DNSSEC for the domain name.
	// *   OFF: disables DNSSEC for the domain name.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s SetDomainDnssecStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDomainDnssecStatusRequest) GoString() string {
	return s.String()
}

func (s *SetDomainDnssecStatusRequest) SetDomainName(v string) *SetDomainDnssecStatusRequest {
	s.DomainName = &v
	return s
}

func (s *SetDomainDnssecStatusRequest) SetLang(v string) *SetDomainDnssecStatusRequest {
	s.Lang = &v
	return s
}

func (s *SetDomainDnssecStatusRequest) SetStatus(v string) *SetDomainDnssecStatusRequest {
	s.Status = &v
	return s
}

type SetDomainDnssecStatusResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetDomainDnssecStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDomainDnssecStatusResponseBody) GoString() string {
	return s.String()
}

func (s *SetDomainDnssecStatusResponseBody) SetRequestId(v string) *SetDomainDnssecStatusResponseBody {
	s.RequestId = &v
	return s
}

type SetDomainDnssecStatusResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDomainDnssecStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDomainDnssecStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDomainDnssecStatusResponse) GoString() string {
	return s.String()
}

func (s *SetDomainDnssecStatusResponse) SetHeaders(v map[string]*string) *SetDomainDnssecStatusResponse {
	s.Headers = v
	return s
}

func (s *SetDomainDnssecStatusResponse) SetStatusCode(v int32) *SetDomainDnssecStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDomainDnssecStatusResponse) SetBody(v *SetDomainDnssecStatusResponseBody) *SetDomainDnssecStatusResponse {
	s.Body = v
	return s
}

type SetDomainRecordStatusRequest struct {
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the DNS record.
	RecordId *string `json:"RecordId,omitempty" xml:"RecordId,omitempty"`
	// The status of the DNS record. Valid values:
	//
	// *   **Enable**: enables resolution.
	// *   **Disable**: suspends resolution.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The IP address of the client.
	UserClientIp *string `json:"UserClientIp,omitempty" xml:"UserClientIp,omitempty"`
}

func (s SetDomainRecordStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDomainRecordStatusRequest) GoString() string {
	return s.String()
}

func (s *SetDomainRecordStatusRequest) SetLang(v string) *SetDomainRecordStatusRequest {
	s.Lang = &v
	return s
}

func (s *SetDomainRecordStatusRequest) SetRecordId(v string) *SetDomainRecordStatusRequest {
	s.RecordId = &v
	return s
}

func (s *SetDomainRecordStatusRequest) SetStatus(v string) *SetDomainRecordStatusRequest {
	s.Status = &v
	return s
}

func (s *SetDomainRecordStatusRequest) SetUserClientIp(v string) *SetDomainRecordStatusRequest {
	s.UserClientIp = &v
	return s
}

type SetDomainRecordStatusResponseBody struct {
	// The ID of the DNS record.
	RecordId *string `json:"RecordId,omitempty" xml:"RecordId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the DNS record.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s SetDomainRecordStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDomainRecordStatusResponseBody) GoString() string {
	return s.String()
}

func (s *SetDomainRecordStatusResponseBody) SetRecordId(v string) *SetDomainRecordStatusResponseBody {
	s.RecordId = &v
	return s
}

func (s *SetDomainRecordStatusResponseBody) SetRequestId(v string) *SetDomainRecordStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *SetDomainRecordStatusResponseBody) SetStatus(v string) *SetDomainRecordStatusResponseBody {
	s.Status = &v
	return s
}

type SetDomainRecordStatusResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDomainRecordStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDomainRecordStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDomainRecordStatusResponse) GoString() string {
	return s.String()
}

func (s *SetDomainRecordStatusResponse) SetHeaders(v map[string]*string) *SetDomainRecordStatusResponse {
	s.Headers = v
	return s
}

func (s *SetDomainRecordStatusResponse) SetStatusCode(v int32) *SetDomainRecordStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDomainRecordStatusResponse) SetBody(v *SetDomainRecordStatusResponseBody) *SetDomainRecordStatusResponse {
	s.Body = v
	return s
}

type SetGtmAccessModeRequest struct {
	// The target access policy of the GTM instance. Valid values:
	//
	// *   **AUTO**: Automatic switch
	// *   **DEFAULT**: Default address pool
	// *   **FAILOVER**: Failover address pool
	AccessMode *string `json:"AccessMode,omitempty" xml:"AccessMode,omitempty"`
	// The language used by the user.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the access policy.
	StrategyId *string `json:"StrategyId,omitempty" xml:"StrategyId,omitempty"`
}

func (s SetGtmAccessModeRequest) String() string {
	return tea.Prettify(s)
}

func (s SetGtmAccessModeRequest) GoString() string {
	return s.String()
}

func (s *SetGtmAccessModeRequest) SetAccessMode(v string) *SetGtmAccessModeRequest {
	s.AccessMode = &v
	return s
}

func (s *SetGtmAccessModeRequest) SetLang(v string) *SetGtmAccessModeRequest {
	s.Lang = &v
	return s
}

func (s *SetGtmAccessModeRequest) SetStrategyId(v string) *SetGtmAccessModeRequest {
	s.StrategyId = &v
	return s
}

type SetGtmAccessModeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetGtmAccessModeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetGtmAccessModeResponseBody) GoString() string {
	return s.String()
}

func (s *SetGtmAccessModeResponseBody) SetRequestId(v string) *SetGtmAccessModeResponseBody {
	s.RequestId = &v
	return s
}

type SetGtmAccessModeResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetGtmAccessModeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetGtmAccessModeResponse) String() string {
	return tea.Prettify(s)
}

func (s SetGtmAccessModeResponse) GoString() string {
	return s.String()
}

func (s *SetGtmAccessModeResponse) SetHeaders(v map[string]*string) *SetGtmAccessModeResponse {
	s.Headers = v
	return s
}

func (s *SetGtmAccessModeResponse) SetStatusCode(v int32) *SetGtmAccessModeResponse {
	s.StatusCode = &v
	return s
}

func (s *SetGtmAccessModeResponse) SetBody(v *SetGtmAccessModeResponseBody) *SetGtmAccessModeResponse {
	s.Body = v
	return s
}

type SetGtmMonitorStatusRequest struct {
	// The language used by the user.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The health check ID.
	MonitorConfigId *string `json:"MonitorConfigId,omitempty" xml:"MonitorConfigId,omitempty"`
	// Specifies whether health check is enabled for the address pool. Valid values:
	//
	// *   **OPEN**: Enabled
	// *   **CLOSE**: Disabled
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s SetGtmMonitorStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s SetGtmMonitorStatusRequest) GoString() string {
	return s.String()
}

func (s *SetGtmMonitorStatusRequest) SetLang(v string) *SetGtmMonitorStatusRequest {
	s.Lang = &v
	return s
}

func (s *SetGtmMonitorStatusRequest) SetMonitorConfigId(v string) *SetGtmMonitorStatusRequest {
	s.MonitorConfigId = &v
	return s
}

func (s *SetGtmMonitorStatusRequest) SetStatus(v string) *SetGtmMonitorStatusRequest {
	s.Status = &v
	return s
}

type SetGtmMonitorStatusResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetGtmMonitorStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetGtmMonitorStatusResponseBody) GoString() string {
	return s.String()
}

func (s *SetGtmMonitorStatusResponseBody) SetRequestId(v string) *SetGtmMonitorStatusResponseBody {
	s.RequestId = &v
	return s
}

type SetGtmMonitorStatusResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetGtmMonitorStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetGtmMonitorStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s SetGtmMonitorStatusResponse) GoString() string {
	return s.String()
}

func (s *SetGtmMonitorStatusResponse) SetHeaders(v map[string]*string) *SetGtmMonitorStatusResponse {
	s.Headers = v
	return s
}

func (s *SetGtmMonitorStatusResponse) SetStatusCode(v int32) *SetGtmMonitorStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *SetGtmMonitorStatusResponse) SetBody(v *SetGtmMonitorStatusResponseBody) *SetGtmMonitorStatusResponse {
	s.Body = v
	return s
}

type SubmitIspFlushCacheTaskRequest struct {
	ClientToken *string   `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DomainName  *string   `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	Isp         []*string `json:"Isp,omitempty" xml:"Isp,omitempty" type:"Repeated"`
	Lang        *string   `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s SubmitIspFlushCacheTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitIspFlushCacheTaskRequest) GoString() string {
	return s.String()
}

func (s *SubmitIspFlushCacheTaskRequest) SetClientToken(v string) *SubmitIspFlushCacheTaskRequest {
	s.ClientToken = &v
	return s
}

func (s *SubmitIspFlushCacheTaskRequest) SetDomainName(v string) *SubmitIspFlushCacheTaskRequest {
	s.DomainName = &v
	return s
}

func (s *SubmitIspFlushCacheTaskRequest) SetIsp(v []*string) *SubmitIspFlushCacheTaskRequest {
	s.Isp = v
	return s
}

func (s *SubmitIspFlushCacheTaskRequest) SetLang(v string) *SubmitIspFlushCacheTaskRequest {
	s.Lang = &v
	return s
}

type SubmitIspFlushCacheTaskResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SubmitIspFlushCacheTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitIspFlushCacheTaskResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitIspFlushCacheTaskResponseBody) SetRequestId(v string) *SubmitIspFlushCacheTaskResponseBody {
	s.RequestId = &v
	return s
}

type SubmitIspFlushCacheTaskResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SubmitIspFlushCacheTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SubmitIspFlushCacheTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitIspFlushCacheTaskResponse) GoString() string {
	return s.String()
}

func (s *SubmitIspFlushCacheTaskResponse) SetHeaders(v map[string]*string) *SubmitIspFlushCacheTaskResponse {
	s.Headers = v
	return s
}

func (s *SubmitIspFlushCacheTaskResponse) SetStatusCode(v int32) *SubmitIspFlushCacheTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitIspFlushCacheTaskResponse) SetBody(v *SubmitIspFlushCacheTaskResponseBody) *SubmitIspFlushCacheTaskResponse {
	s.Body = v
	return s
}

type SwitchDnsGtmInstanceStrategyModeRequest struct {
	// The ID of the GTM instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The access policy type. Valid values:
	//
	// *   GEO: geographical location-based
	// *   LATENCY: latency-based
	StrategyMode *string `json:"StrategyMode,omitempty" xml:"StrategyMode,omitempty"`
}

func (s SwitchDnsGtmInstanceStrategyModeRequest) String() string {
	return tea.Prettify(s)
}

func (s SwitchDnsGtmInstanceStrategyModeRequest) GoString() string {
	return s.String()
}

func (s *SwitchDnsGtmInstanceStrategyModeRequest) SetInstanceId(v string) *SwitchDnsGtmInstanceStrategyModeRequest {
	s.InstanceId = &v
	return s
}

func (s *SwitchDnsGtmInstanceStrategyModeRequest) SetLang(v string) *SwitchDnsGtmInstanceStrategyModeRequest {
	s.Lang = &v
	return s
}

func (s *SwitchDnsGtmInstanceStrategyModeRequest) SetStrategyMode(v string) *SwitchDnsGtmInstanceStrategyModeRequest {
	s.StrategyMode = &v
	return s
}

type SwitchDnsGtmInstanceStrategyModeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SwitchDnsGtmInstanceStrategyModeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SwitchDnsGtmInstanceStrategyModeResponseBody) GoString() string {
	return s.String()
}

func (s *SwitchDnsGtmInstanceStrategyModeResponseBody) SetRequestId(v string) *SwitchDnsGtmInstanceStrategyModeResponseBody {
	s.RequestId = &v
	return s
}

type SwitchDnsGtmInstanceStrategyModeResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SwitchDnsGtmInstanceStrategyModeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SwitchDnsGtmInstanceStrategyModeResponse) String() string {
	return tea.Prettify(s)
}

func (s SwitchDnsGtmInstanceStrategyModeResponse) GoString() string {
	return s.String()
}

func (s *SwitchDnsGtmInstanceStrategyModeResponse) SetHeaders(v map[string]*string) *SwitchDnsGtmInstanceStrategyModeResponse {
	s.Headers = v
	return s
}

func (s *SwitchDnsGtmInstanceStrategyModeResponse) SetStatusCode(v int32) *SwitchDnsGtmInstanceStrategyModeResponse {
	s.StatusCode = &v
	return s
}

func (s *SwitchDnsGtmInstanceStrategyModeResponse) SetBody(v *SwitchDnsGtmInstanceStrategyModeResponseBody) *SwitchDnsGtmInstanceStrategyModeResponse {
	s.Body = v
	return s
}

type TagResourcesRequest struct {
	// The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The domain name.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The type of the resource.
	ResourceType *string                   `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	Tag          []*TagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s TagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequest) GoString() string {
	return s.String()
}

func (s *TagResourcesRequest) SetLang(v string) *TagResourcesRequest {
	s.Lang = &v
	return s
}

func (s *TagResourcesRequest) SetResourceId(v []*string) *TagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *TagResourcesRequest) SetResourceType(v string) *TagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *TagResourcesRequest) SetTag(v []*TagResourcesRequestTag) *TagResourcesRequest {
	s.Tag = v
	return s
}

type TagResourcesRequestTag struct {
	// The key of the tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s TagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *TagResourcesRequestTag) SetKey(v string) *TagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *TagResourcesRequestTag) SetValue(v string) *TagResourcesRequestTag {
	s.Value = &v
	return s
}

type TagResourcesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *TagResourcesResponseBody) SetRequestId(v string) *TagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type TagResourcesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponse) GoString() string {
	return s.String()
}

func (s *TagResourcesResponse) SetHeaders(v map[string]*string) *TagResourcesResponse {
	s.Headers = v
	return s
}

func (s *TagResourcesResponse) SetStatusCode(v int32) *TagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *TagResourcesResponse) SetBody(v *TagResourcesResponseBody) *TagResourcesResponse {
	s.Body = v
	return s
}

type TransferDomainRequest struct {
	// The list of domain names. Separate multiple domain names with commas (,). Only domain names registered with Alibaba Cloud are supported.
	DomainNames *string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The detailed information.
	Remark *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
	// The ID of the user to which domain names were transferred.
	TargetUserId *int64 `json:"TargetUserId,omitempty" xml:"TargetUserId,omitempty"`
}

func (s TransferDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s TransferDomainRequest) GoString() string {
	return s.String()
}

func (s *TransferDomainRequest) SetDomainNames(v string) *TransferDomainRequest {
	s.DomainNames = &v
	return s
}

func (s *TransferDomainRequest) SetLang(v string) *TransferDomainRequest {
	s.Lang = &v
	return s
}

func (s *TransferDomainRequest) SetRemark(v string) *TransferDomainRequest {
	s.Remark = &v
	return s
}

func (s *TransferDomainRequest) SetTargetUserId(v int64) *TransferDomainRequest {
	s.TargetUserId = &v
	return s
}

type TransferDomainResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TaskId    *int64  `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s TransferDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TransferDomainResponseBody) GoString() string {
	return s.String()
}

func (s *TransferDomainResponseBody) SetRequestId(v string) *TransferDomainResponseBody {
	s.RequestId = &v
	return s
}

func (s *TransferDomainResponseBody) SetTaskId(v int64) *TransferDomainResponseBody {
	s.TaskId = &v
	return s
}

type TransferDomainResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TransferDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TransferDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s TransferDomainResponse) GoString() string {
	return s.String()
}

func (s *TransferDomainResponse) SetHeaders(v map[string]*string) *TransferDomainResponse {
	s.Headers = v
	return s
}

func (s *TransferDomainResponse) SetStatusCode(v int32) *TransferDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *TransferDomainResponse) SetBody(v *TransferDomainResponseBody) *TransferDomainResponse {
	s.Body = v
	return s
}

type UnbindInstanceDomainsRequest struct {
	// The list of domain names.
	//
	// Separate multiple domain names with commas (,). A maximum of 100 domain names can be entered.
	DomainNames *string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s UnbindInstanceDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s UnbindInstanceDomainsRequest) GoString() string {
	return s.String()
}

func (s *UnbindInstanceDomainsRequest) SetDomainNames(v string) *UnbindInstanceDomainsRequest {
	s.DomainNames = &v
	return s
}

func (s *UnbindInstanceDomainsRequest) SetInstanceId(v string) *UnbindInstanceDomainsRequest {
	s.InstanceId = &v
	return s
}

func (s *UnbindInstanceDomainsRequest) SetLang(v string) *UnbindInstanceDomainsRequest {
	s.Lang = &v
	return s
}

type UnbindInstanceDomainsResponseBody struct {
	// The number of domain names that failed to be unbound.
	FailedCount *int32 `json:"FailedCount,omitempty" xml:"FailedCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of domain names that have been unbound.
	SuccessCount *int32 `json:"SuccessCount,omitempty" xml:"SuccessCount,omitempty"`
}

func (s UnbindInstanceDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UnbindInstanceDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *UnbindInstanceDomainsResponseBody) SetFailedCount(v int32) *UnbindInstanceDomainsResponseBody {
	s.FailedCount = &v
	return s
}

func (s *UnbindInstanceDomainsResponseBody) SetRequestId(v string) *UnbindInstanceDomainsResponseBody {
	s.RequestId = &v
	return s
}

func (s *UnbindInstanceDomainsResponseBody) SetSuccessCount(v int32) *UnbindInstanceDomainsResponseBody {
	s.SuccessCount = &v
	return s
}

type UnbindInstanceDomainsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UnbindInstanceDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UnbindInstanceDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s UnbindInstanceDomainsResponse) GoString() string {
	return s.String()
}

func (s *UnbindInstanceDomainsResponse) SetHeaders(v map[string]*string) *UnbindInstanceDomainsResponse {
	s.Headers = v
	return s
}

func (s *UnbindInstanceDomainsResponse) SetStatusCode(v int32) *UnbindInstanceDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *UnbindInstanceDomainsResponse) SetBody(v *UnbindInstanceDomainsResponseBody) *UnbindInstanceDomainsResponse {
	s.Body = v
	return s
}

type UntagResourcesRequest struct {
	All  *bool   `json:"All,omitempty" xml:"All,omitempty"`
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// Resource Type
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// Specifies whether to remove all tags from the specified resource. Default value: false. This parameter takes effect only when the TagKey.N parameter is not specified. Valid values:
	//
	// *   true
	// *   false
	TagKey []*string `json:"TagKey,omitempty" xml:"TagKey,omitempty" type:"Repeated"`
}

func (s UntagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesRequest) GoString() string {
	return s.String()
}

func (s *UntagResourcesRequest) SetAll(v bool) *UntagResourcesRequest {
	s.All = &v
	return s
}

func (s *UntagResourcesRequest) SetLang(v string) *UntagResourcesRequest {
	s.Lang = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceId(v []*string) *UntagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *UntagResourcesRequest) SetResourceType(v string) *UntagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *UntagResourcesRequest) SetTagKey(v []*string) *UntagResourcesRequest {
	s.TagKey = v
	return s
}

type UntagResourcesResponseBody struct {
	// "dns-example.com","dns-test.com"
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UntagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponseBody) SetRequestId(v string) *UntagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type UntagResourcesResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UntagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UntagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponse) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponse) SetHeaders(v map[string]*string) *UntagResourcesResponse {
	s.Headers = v
	return s
}

func (s *UntagResourcesResponse) SetStatusCode(v int32) *UntagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *UntagResourcesResponse) SetBody(v *UntagResourcesResponseBody) *UntagResourcesResponse {
	s.Body = v
	return s
}

type UpdateAppKeyStateRequest struct {
	AppKeyId *string `json:"AppKeyId,omitempty" xml:"AppKeyId,omitempty"`
	Lang     *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	State    *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s UpdateAppKeyStateRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAppKeyStateRequest) GoString() string {
	return s.String()
}

func (s *UpdateAppKeyStateRequest) SetAppKeyId(v string) *UpdateAppKeyStateRequest {
	s.AppKeyId = &v
	return s
}

func (s *UpdateAppKeyStateRequest) SetLang(v string) *UpdateAppKeyStateRequest {
	s.Lang = &v
	return s
}

func (s *UpdateAppKeyStateRequest) SetState(v string) *UpdateAppKeyStateRequest {
	s.State = &v
	return s
}

type UpdateAppKeyStateResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateAppKeyStateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAppKeyStateResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAppKeyStateResponseBody) SetRequestId(v string) *UpdateAppKeyStateResponseBody {
	s.RequestId = &v
	return s
}

type UpdateAppKeyStateResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateAppKeyStateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateAppKeyStateResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAppKeyStateResponse) GoString() string {
	return s.String()
}

func (s *UpdateAppKeyStateResponse) SetHeaders(v map[string]*string) *UpdateAppKeyStateResponse {
	s.Headers = v
	return s
}

func (s *UpdateAppKeyStateResponse) SetStatusCode(v int32) *UpdateAppKeyStateResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAppKeyStateResponse) SetBody(v *UpdateAppKeyStateResponseBody) *UpdateAppKeyStateResponse {
	s.Body = v
	return s
}

type UpdateCustomLineRequest struct {
	IpSegment []*UpdateCustomLineRequestIpSegment `json:"IpSegment,omitempty" xml:"IpSegment,omitempty" type:"Repeated"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The unique ID of the custom line.
	LineId *int64 `json:"LineId,omitempty" xml:"LineId,omitempty"`
	// The new name of the custom line.
	LineName *string `json:"LineName,omitempty" xml:"LineName,omitempty"`
}

func (s UpdateCustomLineRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateCustomLineRequest) GoString() string {
	return s.String()
}

func (s *UpdateCustomLineRequest) SetIpSegment(v []*UpdateCustomLineRequestIpSegment) *UpdateCustomLineRequest {
	s.IpSegment = v
	return s
}

func (s *UpdateCustomLineRequest) SetLang(v string) *UpdateCustomLineRequest {
	s.Lang = &v
	return s
}

func (s *UpdateCustomLineRequest) SetLineId(v int64) *UpdateCustomLineRequest {
	s.LineId = &v
	return s
}

func (s *UpdateCustomLineRequest) SetLineName(v string) *UpdateCustomLineRequest {
	s.LineName = &v
	return s
}

type UpdateCustomLineRequestIpSegment struct {
	// The end IP address of the CIDR block.
	EndIp *string `json:"EndIp,omitempty" xml:"EndIp,omitempty"`
	// The start IP address of the CIDR block.
	StartIp *string `json:"StartIp,omitempty" xml:"StartIp,omitempty"`
}

func (s UpdateCustomLineRequestIpSegment) String() string {
	return tea.Prettify(s)
}

func (s UpdateCustomLineRequestIpSegment) GoString() string {
	return s.String()
}

func (s *UpdateCustomLineRequestIpSegment) SetEndIp(v string) *UpdateCustomLineRequestIpSegment {
	s.EndIp = &v
	return s
}

func (s *UpdateCustomLineRequestIpSegment) SetStartIp(v string) *UpdateCustomLineRequestIpSegment {
	s.StartIp = &v
	return s
}

type UpdateCustomLineResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateCustomLineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateCustomLineResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateCustomLineResponseBody) SetRequestId(v string) *UpdateCustomLineResponseBody {
	s.RequestId = &v
	return s
}

type UpdateCustomLineResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateCustomLineResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateCustomLineResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateCustomLineResponse) GoString() string {
	return s.String()
}

func (s *UpdateCustomLineResponse) SetHeaders(v map[string]*string) *UpdateCustomLineResponse {
	s.Headers = v
	return s
}

func (s *UpdateCustomLineResponse) SetStatusCode(v int32) *UpdateCustomLineResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateCustomLineResponse) SetBody(v *UpdateCustomLineResponseBody) *UpdateCustomLineResponse {
	s.Body = v
	return s
}

type UpdateDNSSLBWeightRequest struct {
	// The language of the domain name.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the DNS record.
	RecordId *string `json:"RecordId,omitempty" xml:"RecordId,omitempty"`
	// The IP address of the client that you use to change the weight.
	UserClientIp *string `json:"UserClientIp,omitempty" xml:"UserClientIp,omitempty"`
	// The updated weight of the DNS record. Valid values: `1 to 100`.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s UpdateDNSSLBWeightRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDNSSLBWeightRequest) GoString() string {
	return s.String()
}

func (s *UpdateDNSSLBWeightRequest) SetLang(v string) *UpdateDNSSLBWeightRequest {
	s.Lang = &v
	return s
}

func (s *UpdateDNSSLBWeightRequest) SetRecordId(v string) *UpdateDNSSLBWeightRequest {
	s.RecordId = &v
	return s
}

func (s *UpdateDNSSLBWeightRequest) SetUserClientIp(v string) *UpdateDNSSLBWeightRequest {
	s.UserClientIp = &v
	return s
}

func (s *UpdateDNSSLBWeightRequest) SetWeight(v int32) *UpdateDNSSLBWeightRequest {
	s.Weight = &v
	return s
}

type UpdateDNSSLBWeightResponseBody struct {
	// The ID of the DNS record.
	RecordId *string `json:"RecordId,omitempty" xml:"RecordId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The updated weight.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s UpdateDNSSLBWeightResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDNSSLBWeightResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDNSSLBWeightResponseBody) SetRecordId(v string) *UpdateDNSSLBWeightResponseBody {
	s.RecordId = &v
	return s
}

func (s *UpdateDNSSLBWeightResponseBody) SetRequestId(v string) *UpdateDNSSLBWeightResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateDNSSLBWeightResponseBody) SetWeight(v int32) *UpdateDNSSLBWeightResponseBody {
	s.Weight = &v
	return s
}

type UpdateDNSSLBWeightResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDNSSLBWeightResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDNSSLBWeightResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDNSSLBWeightResponse) GoString() string {
	return s.String()
}

func (s *UpdateDNSSLBWeightResponse) SetHeaders(v map[string]*string) *UpdateDNSSLBWeightResponse {
	s.Headers = v
	return s
}

func (s *UpdateDNSSLBWeightResponse) SetStatusCode(v int32) *UpdateDNSSLBWeightResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDNSSLBWeightResponse) SetBody(v *UpdateDNSSLBWeightResponseBody) *UpdateDNSSLBWeightResponse {
	s.Body = v
	return s
}

type UpdateDnsCacheDomainRequest struct {
	CacheTtlMax     *int32                                        `json:"CacheTtlMax,omitempty" xml:"CacheTtlMax,omitempty"`
	CacheTtlMin     *int32                                        `json:"CacheTtlMin,omitempty" xml:"CacheTtlMin,omitempty"`
	DomainName      *string                                       `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	InstanceId      *string                                       `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	Lang            *string                                       `json:"Lang,omitempty" xml:"Lang,omitempty"`
	SourceDnsServer []*UpdateDnsCacheDomainRequestSourceDnsServer `json:"SourceDnsServer,omitempty" xml:"SourceDnsServer,omitempty" type:"Repeated"`
	SourceEdns      *string                                       `json:"SourceEdns,omitempty" xml:"SourceEdns,omitempty"`
	SourceProtocol  *string                                       `json:"SourceProtocol,omitempty" xml:"SourceProtocol,omitempty"`
}

func (s UpdateDnsCacheDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsCacheDomainRequest) GoString() string {
	return s.String()
}

func (s *UpdateDnsCacheDomainRequest) SetCacheTtlMax(v int32) *UpdateDnsCacheDomainRequest {
	s.CacheTtlMax = &v
	return s
}

func (s *UpdateDnsCacheDomainRequest) SetCacheTtlMin(v int32) *UpdateDnsCacheDomainRequest {
	s.CacheTtlMin = &v
	return s
}

func (s *UpdateDnsCacheDomainRequest) SetDomainName(v string) *UpdateDnsCacheDomainRequest {
	s.DomainName = &v
	return s
}

func (s *UpdateDnsCacheDomainRequest) SetInstanceId(v string) *UpdateDnsCacheDomainRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateDnsCacheDomainRequest) SetLang(v string) *UpdateDnsCacheDomainRequest {
	s.Lang = &v
	return s
}

func (s *UpdateDnsCacheDomainRequest) SetSourceDnsServer(v []*UpdateDnsCacheDomainRequestSourceDnsServer) *UpdateDnsCacheDomainRequest {
	s.SourceDnsServer = v
	return s
}

func (s *UpdateDnsCacheDomainRequest) SetSourceEdns(v string) *UpdateDnsCacheDomainRequest {
	s.SourceEdns = &v
	return s
}

func (s *UpdateDnsCacheDomainRequest) SetSourceProtocol(v string) *UpdateDnsCacheDomainRequest {
	s.SourceProtocol = &v
	return s
}

type UpdateDnsCacheDomainRequestSourceDnsServer struct {
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
}

func (s UpdateDnsCacheDomainRequestSourceDnsServer) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsCacheDomainRequestSourceDnsServer) GoString() string {
	return s.String()
}

func (s *UpdateDnsCacheDomainRequestSourceDnsServer) SetHost(v string) *UpdateDnsCacheDomainRequestSourceDnsServer {
	s.Host = &v
	return s
}

func (s *UpdateDnsCacheDomainRequestSourceDnsServer) SetPort(v string) *UpdateDnsCacheDomainRequestSourceDnsServer {
	s.Port = &v
	return s
}

type UpdateDnsCacheDomainResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateDnsCacheDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsCacheDomainResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDnsCacheDomainResponseBody) SetRequestId(v string) *UpdateDnsCacheDomainResponseBody {
	s.RequestId = &v
	return s
}

type UpdateDnsCacheDomainResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDnsCacheDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDnsCacheDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsCacheDomainResponse) GoString() string {
	return s.String()
}

func (s *UpdateDnsCacheDomainResponse) SetHeaders(v map[string]*string) *UpdateDnsCacheDomainResponse {
	s.Headers = v
	return s
}

func (s *UpdateDnsCacheDomainResponse) SetStatusCode(v int32) *UpdateDnsCacheDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDnsCacheDomainResponse) SetBody(v *UpdateDnsCacheDomainResponseBody) *UpdateDnsCacheDomainResponse {
	s.Body = v
	return s
}

type UpdateDnsCacheDomainRemarkRequest struct {
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	Lang       *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	Remark     *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
}

func (s UpdateDnsCacheDomainRemarkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsCacheDomainRemarkRequest) GoString() string {
	return s.String()
}

func (s *UpdateDnsCacheDomainRemarkRequest) SetDomainName(v string) *UpdateDnsCacheDomainRemarkRequest {
	s.DomainName = &v
	return s
}

func (s *UpdateDnsCacheDomainRemarkRequest) SetLang(v string) *UpdateDnsCacheDomainRemarkRequest {
	s.Lang = &v
	return s
}

func (s *UpdateDnsCacheDomainRemarkRequest) SetRemark(v string) *UpdateDnsCacheDomainRemarkRequest {
	s.Remark = &v
	return s
}

type UpdateDnsCacheDomainRemarkResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateDnsCacheDomainRemarkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsCacheDomainRemarkResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDnsCacheDomainRemarkResponseBody) SetRequestId(v string) *UpdateDnsCacheDomainRemarkResponseBody {
	s.RequestId = &v
	return s
}

type UpdateDnsCacheDomainRemarkResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDnsCacheDomainRemarkResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDnsCacheDomainRemarkResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsCacheDomainRemarkResponse) GoString() string {
	return s.String()
}

func (s *UpdateDnsCacheDomainRemarkResponse) SetHeaders(v map[string]*string) *UpdateDnsCacheDomainRemarkResponse {
	s.Headers = v
	return s
}

func (s *UpdateDnsCacheDomainRemarkResponse) SetStatusCode(v int32) *UpdateDnsCacheDomainRemarkResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDnsCacheDomainRemarkResponse) SetBody(v *UpdateDnsCacheDomainRemarkResponseBody) *UpdateDnsCacheDomainRemarkResponse {
	s.Body = v
	return s
}

type UpdateDnsGtmAccessStrategyRequest struct {
	AccessMode      *string                                             `json:"AccessMode,omitempty" xml:"AccessMode,omitempty"`
	DefaultAddrPool []*UpdateDnsGtmAccessStrategyRequestDefaultAddrPool `json:"DefaultAddrPool,omitempty" xml:"DefaultAddrPool,omitempty" type:"Repeated"`
	// The type of the primary address pool. Valid values:
	//
	// *   IPV4
	// *   IPV6
	// *   DOMAIN
	DefaultAddrPoolType *string `json:"DefaultAddrPoolType,omitempty" xml:"DefaultAddrPoolType,omitempty"`
	// Specifies whether to enable scheduling optimization for latency resolution for the primary address pool group. Valid values:
	//
	// *   OPEN: enable
	// *   CLOSE: disable
	DefaultLatencyOptimization *string `json:"DefaultLatencyOptimization,omitempty" xml:"DefaultLatencyOptimization,omitempty"`
	// The load balancing policy of the primary address pool group. Valid values:
	//
	// *   ALL_RR: returns all addresses.
	// *   RATIO: returns addresses by weight.
	DefaultLbaStrategy *string `json:"DefaultLbaStrategy,omitempty" xml:"DefaultLbaStrategy,omitempty"`
	// The maximum number of addresses returned from the primary address pool group.
	DefaultMaxReturnAddrNum *int32 `json:"DefaultMaxReturnAddrNum,omitempty" xml:"DefaultMaxReturnAddrNum,omitempty"`
	// The minimum number of available addresses in the primary address pool group.
	DefaultMinAvailableAddrNum *int32                                               `json:"DefaultMinAvailableAddrNum,omitempty" xml:"DefaultMinAvailableAddrNum,omitempty"`
	FailoverAddrPool           []*UpdateDnsGtmAccessStrategyRequestFailoverAddrPool `json:"FailoverAddrPool,omitempty" xml:"FailoverAddrPool,omitempty" type:"Repeated"`
	// The type of the secondary address pool. Valid values:
	//
	// *   IPV4
	// *   IPV6
	// *   DOMAIN
	FailoverAddrPoolType *string `json:"FailoverAddrPoolType,omitempty" xml:"FailoverAddrPoolType,omitempty"`
	// Specifies whether to enable scheduling optimization for latency resolution for the secondary address pool group. Valid values:
	//
	// *   OPEN: enable
	// *   CLOSE: disable
	FailoverLatencyOptimization *string `json:"FailoverLatencyOptimization,omitempty" xml:"FailoverLatencyOptimization,omitempty"`
	// The load balancing policy of the secondary address pool group. Valid values:
	//
	// *   ALL_RR: returns all addresses.
	// *   RATIO: returns addresses by weight.
	FailoverLbaStrategy *string `json:"FailoverLbaStrategy,omitempty" xml:"FailoverLbaStrategy,omitempty"`
	// The maximum number of addresses returned from the secondary address pool group.
	FailoverMaxReturnAddrNum *int32 `json:"FailoverMaxReturnAddrNum,omitempty" xml:"FailoverMaxReturnAddrNum,omitempty"`
	// The minimum number of available addresses in the secondary address pool group.
	FailoverMinAvailableAddrNum *int32 `json:"FailoverMinAvailableAddrNum,omitempty" xml:"FailoverMinAvailableAddrNum,omitempty"`
	// The language to return some response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The line codes of source regions. For example: `["default", "drpeng"]` indicates Global and Dr. Peng Telecom & Media Group.
	Lines *string `json:"Lines,omitempty" xml:"Lines,omitempty"`
	// The ID of the access policy.
	StrategyId *string `json:"StrategyId,omitempty" xml:"StrategyId,omitempty"`
	// The name of the access policy.
	StrategyName *string `json:"StrategyName,omitempty" xml:"StrategyName,omitempty"`
}

func (s UpdateDnsGtmAccessStrategyRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsGtmAccessStrategyRequest) GoString() string {
	return s.String()
}

func (s *UpdateDnsGtmAccessStrategyRequest) SetAccessMode(v string) *UpdateDnsGtmAccessStrategyRequest {
	s.AccessMode = &v
	return s
}

func (s *UpdateDnsGtmAccessStrategyRequest) SetDefaultAddrPool(v []*UpdateDnsGtmAccessStrategyRequestDefaultAddrPool) *UpdateDnsGtmAccessStrategyRequest {
	s.DefaultAddrPool = v
	return s
}

func (s *UpdateDnsGtmAccessStrategyRequest) SetDefaultAddrPoolType(v string) *UpdateDnsGtmAccessStrategyRequest {
	s.DefaultAddrPoolType = &v
	return s
}

func (s *UpdateDnsGtmAccessStrategyRequest) SetDefaultLatencyOptimization(v string) *UpdateDnsGtmAccessStrategyRequest {
	s.DefaultLatencyOptimization = &v
	return s
}

func (s *UpdateDnsGtmAccessStrategyRequest) SetDefaultLbaStrategy(v string) *UpdateDnsGtmAccessStrategyRequest {
	s.DefaultLbaStrategy = &v
	return s
}

func (s *UpdateDnsGtmAccessStrategyRequest) SetDefaultMaxReturnAddrNum(v int32) *UpdateDnsGtmAccessStrategyRequest {
	s.DefaultMaxReturnAddrNum = &v
	return s
}

func (s *UpdateDnsGtmAccessStrategyRequest) SetDefaultMinAvailableAddrNum(v int32) *UpdateDnsGtmAccessStrategyRequest {
	s.DefaultMinAvailableAddrNum = &v
	return s
}

func (s *UpdateDnsGtmAccessStrategyRequest) SetFailoverAddrPool(v []*UpdateDnsGtmAccessStrategyRequestFailoverAddrPool) *UpdateDnsGtmAccessStrategyRequest {
	s.FailoverAddrPool = v
	return s
}

func (s *UpdateDnsGtmAccessStrategyRequest) SetFailoverAddrPoolType(v string) *UpdateDnsGtmAccessStrategyRequest {
	s.FailoverAddrPoolType = &v
	return s
}

func (s *UpdateDnsGtmAccessStrategyRequest) SetFailoverLatencyOptimization(v string) *UpdateDnsGtmAccessStrategyRequest {
	s.FailoverLatencyOptimization = &v
	return s
}

func (s *UpdateDnsGtmAccessStrategyRequest) SetFailoverLbaStrategy(v string) *UpdateDnsGtmAccessStrategyRequest {
	s.FailoverLbaStrategy = &v
	return s
}

func (s *UpdateDnsGtmAccessStrategyRequest) SetFailoverMaxReturnAddrNum(v int32) *UpdateDnsGtmAccessStrategyRequest {
	s.FailoverMaxReturnAddrNum = &v
	return s
}

func (s *UpdateDnsGtmAccessStrategyRequest) SetFailoverMinAvailableAddrNum(v int32) *UpdateDnsGtmAccessStrategyRequest {
	s.FailoverMinAvailableAddrNum = &v
	return s
}

func (s *UpdateDnsGtmAccessStrategyRequest) SetLang(v string) *UpdateDnsGtmAccessStrategyRequest {
	s.Lang = &v
	return s
}

func (s *UpdateDnsGtmAccessStrategyRequest) SetLines(v string) *UpdateDnsGtmAccessStrategyRequest {
	s.Lines = &v
	return s
}

func (s *UpdateDnsGtmAccessStrategyRequest) SetStrategyId(v string) *UpdateDnsGtmAccessStrategyRequest {
	s.StrategyId = &v
	return s
}

func (s *UpdateDnsGtmAccessStrategyRequest) SetStrategyName(v string) *UpdateDnsGtmAccessStrategyRequest {
	s.StrategyName = &v
	return s
}

type UpdateDnsGtmAccessStrategyRequestDefaultAddrPool struct {
	// The ID of the address pool in the primary address pool group.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The weight of the address pool in the primary address pool group.
	LbaWeight *int32 `json:"LbaWeight,omitempty" xml:"LbaWeight,omitempty"`
}

func (s UpdateDnsGtmAccessStrategyRequestDefaultAddrPool) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsGtmAccessStrategyRequestDefaultAddrPool) GoString() string {
	return s.String()
}

func (s *UpdateDnsGtmAccessStrategyRequestDefaultAddrPool) SetId(v string) *UpdateDnsGtmAccessStrategyRequestDefaultAddrPool {
	s.Id = &v
	return s
}

func (s *UpdateDnsGtmAccessStrategyRequestDefaultAddrPool) SetLbaWeight(v int32) *UpdateDnsGtmAccessStrategyRequestDefaultAddrPool {
	s.LbaWeight = &v
	return s
}

type UpdateDnsGtmAccessStrategyRequestFailoverAddrPool struct {
	// The ID of the address pool in the secondary address pool group.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The weight of the address pool in the secondary address pool group.
	LbaWeight *int32 `json:"LbaWeight,omitempty" xml:"LbaWeight,omitempty"`
}

func (s UpdateDnsGtmAccessStrategyRequestFailoverAddrPool) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsGtmAccessStrategyRequestFailoverAddrPool) GoString() string {
	return s.String()
}

func (s *UpdateDnsGtmAccessStrategyRequestFailoverAddrPool) SetId(v string) *UpdateDnsGtmAccessStrategyRequestFailoverAddrPool {
	s.Id = &v
	return s
}

func (s *UpdateDnsGtmAccessStrategyRequestFailoverAddrPool) SetLbaWeight(v int32) *UpdateDnsGtmAccessStrategyRequestFailoverAddrPool {
	s.LbaWeight = &v
	return s
}

type UpdateDnsGtmAccessStrategyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the access policy.
	StrategyId *string `json:"StrategyId,omitempty" xml:"StrategyId,omitempty"`
}

func (s UpdateDnsGtmAccessStrategyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsGtmAccessStrategyResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDnsGtmAccessStrategyResponseBody) SetRequestId(v string) *UpdateDnsGtmAccessStrategyResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateDnsGtmAccessStrategyResponseBody) SetStrategyId(v string) *UpdateDnsGtmAccessStrategyResponseBody {
	s.StrategyId = &v
	return s
}

type UpdateDnsGtmAccessStrategyResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDnsGtmAccessStrategyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDnsGtmAccessStrategyResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsGtmAccessStrategyResponse) GoString() string {
	return s.String()
}

func (s *UpdateDnsGtmAccessStrategyResponse) SetHeaders(v map[string]*string) *UpdateDnsGtmAccessStrategyResponse {
	s.Headers = v
	return s
}

func (s *UpdateDnsGtmAccessStrategyResponse) SetStatusCode(v int32) *UpdateDnsGtmAccessStrategyResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDnsGtmAccessStrategyResponse) SetBody(v *UpdateDnsGtmAccessStrategyResponseBody) *UpdateDnsGtmAccessStrategyResponse {
	s.Body = v
	return s
}

type UpdateDnsGtmAddressPoolRequest struct {
	// The addresses in the address pool.
	Addr []*UpdateDnsGtmAddressPoolRequestAddr `json:"Addr,omitempty" xml:"Addr,omitempty" type:"Repeated"`
	// The ID of the address pool.
	AddrPoolId *string `json:"AddrPoolId,omitempty" xml:"AddrPoolId,omitempty"`
	// The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The load balancing policy for the address pool. Valid values:
	//
	// *   ALL_RR: returns all addresses.
	// *   RATIO: returns addresses by weight.
	LbaStrategy *string `json:"LbaStrategy,omitempty" xml:"LbaStrategy,omitempty"`
	// The name of the address pool.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s UpdateDnsGtmAddressPoolRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsGtmAddressPoolRequest) GoString() string {
	return s.String()
}

func (s *UpdateDnsGtmAddressPoolRequest) SetAddr(v []*UpdateDnsGtmAddressPoolRequestAddr) *UpdateDnsGtmAddressPoolRequest {
	s.Addr = v
	return s
}

func (s *UpdateDnsGtmAddressPoolRequest) SetAddrPoolId(v string) *UpdateDnsGtmAddressPoolRequest {
	s.AddrPoolId = &v
	return s
}

func (s *UpdateDnsGtmAddressPoolRequest) SetLang(v string) *UpdateDnsGtmAddressPoolRequest {
	s.Lang = &v
	return s
}

func (s *UpdateDnsGtmAddressPoolRequest) SetLbaStrategy(v string) *UpdateDnsGtmAddressPoolRequest {
	s.LbaStrategy = &v
	return s
}

func (s *UpdateDnsGtmAddressPoolRequest) SetName(v string) *UpdateDnsGtmAddressPoolRequest {
	s.Name = &v
	return s
}

type UpdateDnsGtmAddressPoolRequestAddr struct {
	// The address.
	Addr *string `json:"Addr,omitempty" xml:"Addr,omitempty"`
	// The source region of the address. The value is a JSON string.
	//
	// *   lineCode: the line code of the source region of the address. This parameter is deprecated, and lineCodes prevails.
	//
	// *   lineCodes: the line codes of the source regions of the address.
	//
	// *   lineCodeRectifyType: the rectification type of the line code. Default value: AUTO. Valid values:
	//
	//     *   NO_NEED: no need for rectification
	//     *   RECTIFIED: rectified
	//     *   AUTO: automatic rectification
	AttributeInfo *string `json:"AttributeInfo,omitempty" xml:"AttributeInfo,omitempty"`
	// The weight of the address.
	LbaWeight *int32 `json:"LbaWeight,omitempty" xml:"LbaWeight,omitempty"`
	// The mode of the address. Valid values:
	//
	// *   SMART: smart return
	// *   ONLINE: always online
	// *   OFFLINE: always offline
	Mode *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The description of the address.
	Remark *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
}

func (s UpdateDnsGtmAddressPoolRequestAddr) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsGtmAddressPoolRequestAddr) GoString() string {
	return s.String()
}

func (s *UpdateDnsGtmAddressPoolRequestAddr) SetAddr(v string) *UpdateDnsGtmAddressPoolRequestAddr {
	s.Addr = &v
	return s
}

func (s *UpdateDnsGtmAddressPoolRequestAddr) SetAttributeInfo(v string) *UpdateDnsGtmAddressPoolRequestAddr {
	s.AttributeInfo = &v
	return s
}

func (s *UpdateDnsGtmAddressPoolRequestAddr) SetLbaWeight(v int32) *UpdateDnsGtmAddressPoolRequestAddr {
	s.LbaWeight = &v
	return s
}

func (s *UpdateDnsGtmAddressPoolRequestAddr) SetMode(v string) *UpdateDnsGtmAddressPoolRequestAddr {
	s.Mode = &v
	return s
}

func (s *UpdateDnsGtmAddressPoolRequestAddr) SetRemark(v string) *UpdateDnsGtmAddressPoolRequestAddr {
	s.Remark = &v
	return s
}

type UpdateDnsGtmAddressPoolResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateDnsGtmAddressPoolResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsGtmAddressPoolResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDnsGtmAddressPoolResponseBody) SetRequestId(v string) *UpdateDnsGtmAddressPoolResponseBody {
	s.RequestId = &v
	return s
}

type UpdateDnsGtmAddressPoolResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDnsGtmAddressPoolResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDnsGtmAddressPoolResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsGtmAddressPoolResponse) GoString() string {
	return s.String()
}

func (s *UpdateDnsGtmAddressPoolResponse) SetHeaders(v map[string]*string) *UpdateDnsGtmAddressPoolResponse {
	s.Headers = v
	return s
}

func (s *UpdateDnsGtmAddressPoolResponse) SetStatusCode(v int32) *UpdateDnsGtmAddressPoolResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDnsGtmAddressPoolResponse) SetBody(v *UpdateDnsGtmAddressPoolResponseBody) *UpdateDnsGtmAddressPoolResponse {
	s.Body = v
	return s
}

type UpdateDnsGtmInstanceGlobalConfigRequest struct {
	AlertConfig []*UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig `json:"AlertConfig,omitempty" xml:"AlertConfig,omitempty" type:"Repeated"`
	// The name of the alert group in the JSON format.
	AlertGroup *string `json:"AlertGroup,omitempty" xml:"AlertGroup,omitempty"`
	// The type of the CNAME domain name that is used to access the instance. Valid value:
	//
	// *   PUBLIC: The CNAME domain name is used to access the instance over the Internet.
	CnameType *string `json:"CnameType,omitempty" xml:"CnameType,omitempty"`
	// Specifies whether to enable force updates. Valid values:
	//
	// *   true: enables force update without a conflict alert.
	// *   false: disables force update. If a conflict occurs, the system displays an alert. null: This valid value of ForceUpdate provides the same information as the false value.
	ForceUpdate *bool `json:"ForceUpdate,omitempty" xml:"ForceUpdate,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the instance. This parameter is required only for the first update.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// Specifies whether to use a custom CNAME domain name or a CNAME domain name assigned by the system to access the instance over the Internet. Valid values:
	//
	// *   SYSTEM_ASSIGN: a CNAME domain name assigned by the system
	// *   CUSTOM: a custom CNAME domain name
	PublicCnameMode *string `json:"PublicCnameMode,omitempty" xml:"PublicCnameMode,omitempty"`
	// The hostname corresponding to the CNAME domain name that is used to access the instance over the Internet.
	PublicRr *string `json:"PublicRr,omitempty" xml:"PublicRr,omitempty"`
	// The service domain name that is used over the Internet.
	PublicUserDomainName *string `json:"PublicUserDomainName,omitempty" xml:"PublicUserDomainName,omitempty"`
	// The CNAME domain name that is used to access the instance over the Internet, which is the primary domain name. This parameter is required when the PublicCnameMode parameter is set to CUSTOM.
	//
	// >  You must use the primary domain name. Do not include the hostname specified by the PublicRr parameter.
	PublicZoneName *string `json:"PublicZoneName,omitempty" xml:"PublicZoneName,omitempty"`
	// The global time to live (TTL).
	Ttl *int32 `json:"Ttl,omitempty" xml:"Ttl,omitempty"`
}

func (s UpdateDnsGtmInstanceGlobalConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsGtmInstanceGlobalConfigRequest) GoString() string {
	return s.String()
}

func (s *UpdateDnsGtmInstanceGlobalConfigRequest) SetAlertConfig(v []*UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig) *UpdateDnsGtmInstanceGlobalConfigRequest {
	s.AlertConfig = v
	return s
}

func (s *UpdateDnsGtmInstanceGlobalConfigRequest) SetAlertGroup(v string) *UpdateDnsGtmInstanceGlobalConfigRequest {
	s.AlertGroup = &v
	return s
}

func (s *UpdateDnsGtmInstanceGlobalConfigRequest) SetCnameType(v string) *UpdateDnsGtmInstanceGlobalConfigRequest {
	s.CnameType = &v
	return s
}

func (s *UpdateDnsGtmInstanceGlobalConfigRequest) SetForceUpdate(v bool) *UpdateDnsGtmInstanceGlobalConfigRequest {
	s.ForceUpdate = &v
	return s
}

func (s *UpdateDnsGtmInstanceGlobalConfigRequest) SetInstanceId(v string) *UpdateDnsGtmInstanceGlobalConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateDnsGtmInstanceGlobalConfigRequest) SetInstanceName(v string) *UpdateDnsGtmInstanceGlobalConfigRequest {
	s.InstanceName = &v
	return s
}

func (s *UpdateDnsGtmInstanceGlobalConfigRequest) SetLang(v string) *UpdateDnsGtmInstanceGlobalConfigRequest {
	s.Lang = &v
	return s
}

func (s *UpdateDnsGtmInstanceGlobalConfigRequest) SetPublicCnameMode(v string) *UpdateDnsGtmInstanceGlobalConfigRequest {
	s.PublicCnameMode = &v
	return s
}

func (s *UpdateDnsGtmInstanceGlobalConfigRequest) SetPublicRr(v string) *UpdateDnsGtmInstanceGlobalConfigRequest {
	s.PublicRr = &v
	return s
}

func (s *UpdateDnsGtmInstanceGlobalConfigRequest) SetPublicUserDomainName(v string) *UpdateDnsGtmInstanceGlobalConfigRequest {
	s.PublicUserDomainName = &v
	return s
}

func (s *UpdateDnsGtmInstanceGlobalConfigRequest) SetPublicZoneName(v string) *UpdateDnsGtmInstanceGlobalConfigRequest {
	s.PublicZoneName = &v
	return s
}

func (s *UpdateDnsGtmInstanceGlobalConfigRequest) SetTtl(v int32) *UpdateDnsGtmInstanceGlobalConfigRequest {
	s.Ttl = &v
	return s
}

type UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig struct {
	DingtalkNotice *bool   `json:"DingtalkNotice,omitempty" xml:"DingtalkNotice,omitempty"`
	EmailNotice    *bool   `json:"EmailNotice,omitempty" xml:"EmailNotice,omitempty"`
	NoticeType     *string `json:"NoticeType,omitempty" xml:"NoticeType,omitempty"`
	SmsNotice      *bool   `json:"SmsNotice,omitempty" xml:"SmsNotice,omitempty"`
}

func (s UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig) GoString() string {
	return s.String()
}

func (s *UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig) SetDingtalkNotice(v bool) *UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig {
	s.DingtalkNotice = &v
	return s
}

func (s *UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig) SetEmailNotice(v bool) *UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig {
	s.EmailNotice = &v
	return s
}

func (s *UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig) SetNoticeType(v string) *UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig {
	s.NoticeType = &v
	return s
}

func (s *UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig) SetSmsNotice(v bool) *UpdateDnsGtmInstanceGlobalConfigRequestAlertConfig {
	s.SmsNotice = &v
	return s
}

type UpdateDnsGtmInstanceGlobalConfigResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateDnsGtmInstanceGlobalConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsGtmInstanceGlobalConfigResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDnsGtmInstanceGlobalConfigResponseBody) SetRequestId(v string) *UpdateDnsGtmInstanceGlobalConfigResponseBody {
	s.RequestId = &v
	return s
}

type UpdateDnsGtmInstanceGlobalConfigResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDnsGtmInstanceGlobalConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDnsGtmInstanceGlobalConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsGtmInstanceGlobalConfigResponse) GoString() string {
	return s.String()
}

func (s *UpdateDnsGtmInstanceGlobalConfigResponse) SetHeaders(v map[string]*string) *UpdateDnsGtmInstanceGlobalConfigResponse {
	s.Headers = v
	return s
}

func (s *UpdateDnsGtmInstanceGlobalConfigResponse) SetStatusCode(v int32) *UpdateDnsGtmInstanceGlobalConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDnsGtmInstanceGlobalConfigResponse) SetBody(v *UpdateDnsGtmInstanceGlobalConfigResponseBody) *UpdateDnsGtmInstanceGlobalConfigResponse {
	s.Body = v
	return s
}

type UpdateDnsGtmMonitorRequest struct {
	// The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.
	EvaluationCount *int32 `json:"EvaluationCount,omitempty" xml:"EvaluationCount,omitempty"`
	// The health check interval. Unit: seconds.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The monitored nodes.
	IspCityNode []*UpdateDnsGtmMonitorRequestIspCityNode `json:"IspCityNode,omitempty" xml:"IspCityNode,omitempty" type:"Repeated"`
	// The language of the values of specific response parameters. Default value: en. Valid values: en, zh, and ja.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the health check configuration.
	MonitorConfigId *string `json:"MonitorConfigId,omitempty" xml:"MonitorConfigId,omitempty"`
	// The extended information, that is, the parameters required for the protocol. Different protocols require different parameters:
	//
	// *   HTTP or HTTPS:
	//
	//     *   port: the port to check.
	//
	//     *   host: the host configuration.
	//
	//     *   path: the health check URL.
	//
	//     *   code: the status code threshold. If the returned status code is greater than the specified threshold, the application service is deemed abnormal.
	//
	//     *   failureRate: the failure rate.
	//
	//     *   sni: specifies whether to enable Server Name Indication (SNI). This parameter is only required for the HTTPS protocol. Valid values:
	//
	//         *   true: enables SNI.
	//         *   false: disables SNI.
	//
	//     *   nodeType: the type of the monitored node when the address pool type is DOMAIN. Valid values:
	//
	//         *   IPV4
	//         *   IPV6
	//
	// *   PING:
	//
	//     *   failureRate: the failure rate.
	//
	//     *   packetNum: the number of ping packets.
	//
	//     *   packetLossRate: the loss rate of ping packets.
	//
	//     *   nodeType: the type of the monitored node when the address pool type is DOMAIN. Valid values:
	//
	//         *   IPV4
	//         *   IPV6
	//
	// *   TCP:
	//
	//     *   port: the port to check.
	//
	//     *   failureRate: the failure rate.
	//
	//     *   nodeType: the type of the monitored node when the address pool type is DOMAIN. Valid values:
	//
	//         *   IPV4
	//         *   IPV6
	MonitorExtendInfo *string `json:"MonitorExtendInfo,omitempty" xml:"MonitorExtendInfo,omitempty"`
	// The protocol used for the health check. Valid values:
	//
	// *   HTTP
	// *   HTTPS
	// *   PING
	// *   TCP
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The health check timeout period. Unit: milliseconds.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
}

func (s UpdateDnsGtmMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsGtmMonitorRequest) GoString() string {
	return s.String()
}

func (s *UpdateDnsGtmMonitorRequest) SetEvaluationCount(v int32) *UpdateDnsGtmMonitorRequest {
	s.EvaluationCount = &v
	return s
}

func (s *UpdateDnsGtmMonitorRequest) SetInterval(v int32) *UpdateDnsGtmMonitorRequest {
	s.Interval = &v
	return s
}

func (s *UpdateDnsGtmMonitorRequest) SetIspCityNode(v []*UpdateDnsGtmMonitorRequestIspCityNode) *UpdateDnsGtmMonitorRequest {
	s.IspCityNode = v
	return s
}

func (s *UpdateDnsGtmMonitorRequest) SetLang(v string) *UpdateDnsGtmMonitorRequest {
	s.Lang = &v
	return s
}

func (s *UpdateDnsGtmMonitorRequest) SetMonitorConfigId(v string) *UpdateDnsGtmMonitorRequest {
	s.MonitorConfigId = &v
	return s
}

func (s *UpdateDnsGtmMonitorRequest) SetMonitorExtendInfo(v string) *UpdateDnsGtmMonitorRequest {
	s.MonitorExtendInfo = &v
	return s
}

func (s *UpdateDnsGtmMonitorRequest) SetProtocolType(v string) *UpdateDnsGtmMonitorRequest {
	s.ProtocolType = &v
	return s
}

func (s *UpdateDnsGtmMonitorRequest) SetTimeout(v int32) *UpdateDnsGtmMonitorRequest {
	s.Timeout = &v
	return s
}

type UpdateDnsGtmMonitorRequestIspCityNode struct {
	// The code of the city where the monitored node is deployed.
	CityCode *string `json:"CityCode,omitempty" xml:"CityCode,omitempty"`
	// The code of the Internet service provider (ISP) to which the monitored node belongs.
	IspCode *string `json:"IspCode,omitempty" xml:"IspCode,omitempty"`
}

func (s UpdateDnsGtmMonitorRequestIspCityNode) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsGtmMonitorRequestIspCityNode) GoString() string {
	return s.String()
}

func (s *UpdateDnsGtmMonitorRequestIspCityNode) SetCityCode(v string) *UpdateDnsGtmMonitorRequestIspCityNode {
	s.CityCode = &v
	return s
}

func (s *UpdateDnsGtmMonitorRequestIspCityNode) SetIspCode(v string) *UpdateDnsGtmMonitorRequestIspCityNode {
	s.IspCode = &v
	return s
}

type UpdateDnsGtmMonitorResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateDnsGtmMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsGtmMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDnsGtmMonitorResponseBody) SetRequestId(v string) *UpdateDnsGtmMonitorResponseBody {
	s.RequestId = &v
	return s
}

type UpdateDnsGtmMonitorResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDnsGtmMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDnsGtmMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDnsGtmMonitorResponse) GoString() string {
	return s.String()
}

func (s *UpdateDnsGtmMonitorResponse) SetHeaders(v map[string]*string) *UpdateDnsGtmMonitorResponse {
	s.Headers = v
	return s
}

func (s *UpdateDnsGtmMonitorResponse) SetStatusCode(v int32) *UpdateDnsGtmMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDnsGtmMonitorResponse) SetBody(v *UpdateDnsGtmMonitorResponseBody) *UpdateDnsGtmMonitorResponse {
	s.Body = v
	return s
}

type UpdateDomainGroupRequest struct {
	// The ID of the domain name group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The new name of the domain name group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s UpdateDomainGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDomainGroupRequest) GoString() string {
	return s.String()
}

func (s *UpdateDomainGroupRequest) SetGroupId(v string) *UpdateDomainGroupRequest {
	s.GroupId = &v
	return s
}

func (s *UpdateDomainGroupRequest) SetGroupName(v string) *UpdateDomainGroupRequest {
	s.GroupName = &v
	return s
}

func (s *UpdateDomainGroupRequest) SetLang(v string) *UpdateDomainGroupRequest {
	s.Lang = &v
	return s
}

type UpdateDomainGroupResponseBody struct {
	// The ID of the domain name group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The new name of the domain name group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateDomainGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDomainGroupResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDomainGroupResponseBody) SetGroupId(v string) *UpdateDomainGroupResponseBody {
	s.GroupId = &v
	return s
}

func (s *UpdateDomainGroupResponseBody) SetGroupName(v string) *UpdateDomainGroupResponseBody {
	s.GroupName = &v
	return s
}

func (s *UpdateDomainGroupResponseBody) SetRequestId(v string) *UpdateDomainGroupResponseBody {
	s.RequestId = &v
	return s
}

type UpdateDomainGroupResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDomainGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDomainGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDomainGroupResponse) GoString() string {
	return s.String()
}

func (s *UpdateDomainGroupResponse) SetHeaders(v map[string]*string) *UpdateDomainGroupResponse {
	s.Headers = v
	return s
}

func (s *UpdateDomainGroupResponse) SetStatusCode(v int32) *UpdateDomainGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDomainGroupResponse) SetBody(v *UpdateDomainGroupResponseBody) *UpdateDomainGroupResponse {
	s.Body = v
	return s
}

type UpdateDomainRecordRequest struct {
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The resolution line. Default value: **default**.
	Line *string `json:"Line,omitempty" xml:"Line,omitempty"`
	// The priority of an MX-type DNS record. Valid values: `[1,50]`.
	//
	// This parameter must be specified if the type of the DNS record is MX.
	Priority *int64 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The host record.
	//
	// For example, to resolve @.example.com, you must set RR to an at sign (@) instead of leaving it blank.
	RR *string `json:"RR,omitempty" xml:"RR,omitempty"`
	// The ID of the DNS record.
	RecordId *string `json:"RecordId,omitempty" xml:"RecordId,omitempty"`
	// The TTL of the resolution. Default value: 600. Unit: seconds.
	TTL *int64 `json:"TTL,omitempty" xml:"TTL,omitempty"`
	// The type of the DNS record.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The IP address of the client.
	UserClientIp *string `json:"UserClientIp,omitempty" xml:"UserClientIp,omitempty"`
	// The value of the DNS record.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s UpdateDomainRecordRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDomainRecordRequest) GoString() string {
	return s.String()
}

func (s *UpdateDomainRecordRequest) SetLang(v string) *UpdateDomainRecordRequest {
	s.Lang = &v
	return s
}

func (s *UpdateDomainRecordRequest) SetLine(v string) *UpdateDomainRecordRequest {
	s.Line = &v
	return s
}

func (s *UpdateDomainRecordRequest) SetPriority(v int64) *UpdateDomainRecordRequest {
	s.Priority = &v
	return s
}

func (s *UpdateDomainRecordRequest) SetRR(v string) *UpdateDomainRecordRequest {
	s.RR = &v
	return s
}

func (s *UpdateDomainRecordRequest) SetRecordId(v string) *UpdateDomainRecordRequest {
	s.RecordId = &v
	return s
}

func (s *UpdateDomainRecordRequest) SetTTL(v int64) *UpdateDomainRecordRequest {
	s.TTL = &v
	return s
}

func (s *UpdateDomainRecordRequest) SetType(v string) *UpdateDomainRecordRequest {
	s.Type = &v
	return s
}

func (s *UpdateDomainRecordRequest) SetUserClientIp(v string) *UpdateDomainRecordRequest {
	s.UserClientIp = &v
	return s
}

func (s *UpdateDomainRecordRequest) SetValue(v string) *UpdateDomainRecordRequest {
	s.Value = &v
	return s
}

type UpdateDomainRecordResponseBody struct {
	// The ID of the DNS record.
	RecordId *string `json:"RecordId,omitempty" xml:"RecordId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateDomainRecordResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDomainRecordResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDomainRecordResponseBody) SetRecordId(v string) *UpdateDomainRecordResponseBody {
	s.RecordId = &v
	return s
}

func (s *UpdateDomainRecordResponseBody) SetRequestId(v string) *UpdateDomainRecordResponseBody {
	s.RequestId = &v
	return s
}

type UpdateDomainRecordResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDomainRecordResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDomainRecordResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDomainRecordResponse) GoString() string {
	return s.String()
}

func (s *UpdateDomainRecordResponse) SetHeaders(v map[string]*string) *UpdateDomainRecordResponse {
	s.Headers = v
	return s
}

func (s *UpdateDomainRecordResponse) SetStatusCode(v int32) *UpdateDomainRecordResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDomainRecordResponse) SetBody(v *UpdateDomainRecordResponseBody) *UpdateDomainRecordResponse {
	s.Body = v
	return s
}

type UpdateDomainRecordRemarkRequest struct {
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the DNS record.
	RecordId *string `json:"RecordId,omitempty" xml:"RecordId,omitempty"`
	// The description of your DNS record.
	Remark *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
	// The IP address of the client.
	UserClientIp *string `json:"UserClientIp,omitempty" xml:"UserClientIp,omitempty"`
}

func (s UpdateDomainRecordRemarkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDomainRecordRemarkRequest) GoString() string {
	return s.String()
}

func (s *UpdateDomainRecordRemarkRequest) SetLang(v string) *UpdateDomainRecordRemarkRequest {
	s.Lang = &v
	return s
}

func (s *UpdateDomainRecordRemarkRequest) SetRecordId(v string) *UpdateDomainRecordRemarkRequest {
	s.RecordId = &v
	return s
}

func (s *UpdateDomainRecordRemarkRequest) SetRemark(v string) *UpdateDomainRecordRemarkRequest {
	s.Remark = &v
	return s
}

func (s *UpdateDomainRecordRemarkRequest) SetUserClientIp(v string) *UpdateDomainRecordRemarkRequest {
	s.UserClientIp = &v
	return s
}

type UpdateDomainRecordRemarkResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateDomainRecordRemarkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDomainRecordRemarkResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDomainRecordRemarkResponseBody) SetRequestId(v string) *UpdateDomainRecordRemarkResponseBody {
	s.RequestId = &v
	return s
}

type UpdateDomainRecordRemarkResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDomainRecordRemarkResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDomainRecordRemarkResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDomainRecordRemarkResponse) GoString() string {
	return s.String()
}

func (s *UpdateDomainRecordRemarkResponse) SetHeaders(v map[string]*string) *UpdateDomainRecordRemarkResponse {
	s.Headers = v
	return s
}

func (s *UpdateDomainRecordRemarkResponse) SetStatusCode(v int32) *UpdateDomainRecordRemarkResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDomainRecordRemarkResponse) SetBody(v *UpdateDomainRecordRemarkResponseBody) *UpdateDomainRecordRemarkResponse {
	s.Body = v
	return s
}

type UpdateDomainRemarkRequest struct {
	// The domain name in Alibaba Cloud DNS.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The language type.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The description of your domain name.
	Remark *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
}

func (s UpdateDomainRemarkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDomainRemarkRequest) GoString() string {
	return s.String()
}

func (s *UpdateDomainRemarkRequest) SetDomainName(v string) *UpdateDomainRemarkRequest {
	s.DomainName = &v
	return s
}

func (s *UpdateDomainRemarkRequest) SetLang(v string) *UpdateDomainRemarkRequest {
	s.Lang = &v
	return s
}

func (s *UpdateDomainRemarkRequest) SetRemark(v string) *UpdateDomainRemarkRequest {
	s.Remark = &v
	return s
}

type UpdateDomainRemarkResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateDomainRemarkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDomainRemarkResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDomainRemarkResponseBody) SetRequestId(v string) *UpdateDomainRemarkResponseBody {
	s.RequestId = &v
	return s
}

type UpdateDomainRemarkResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDomainRemarkResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDomainRemarkResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDomainRemarkResponse) GoString() string {
	return s.String()
}

func (s *UpdateDomainRemarkResponse) SetHeaders(v map[string]*string) *UpdateDomainRemarkResponse {
	s.Headers = v
	return s
}

func (s *UpdateDomainRemarkResponse) SetStatusCode(v int32) *UpdateDomainRemarkResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDomainRemarkResponse) SetBody(v *UpdateDomainRemarkResponseBody) *UpdateDomainRemarkResponse {
	s.Body = v
	return s
}

type UpdateGtmAccessStrategyRequest struct {
	// The line codes of access regions.
	AccessLines *string `json:"AccessLines,omitempty" xml:"AccessLines,omitempty"`
	// The ID of the default address pool.
	DefaultAddrPoolId *string `json:"DefaultAddrPoolId,omitempty" xml:"DefaultAddrPoolId,omitempty"`
	// The ID of the failover address pool.
	FailoverAddrPoolId *string `json:"FailoverAddrPoolId,omitempty" xml:"FailoverAddrPoolId,omitempty"`
	// The language used by the user.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the access policy that you want to query for the GTM instance.
	StrategyId *string `json:"StrategyId,omitempty" xml:"StrategyId,omitempty"`
	// The name of the access policy.
	StrategyName *string `json:"StrategyName,omitempty" xml:"StrategyName,omitempty"`
}

func (s UpdateGtmAccessStrategyRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGtmAccessStrategyRequest) GoString() string {
	return s.String()
}

func (s *UpdateGtmAccessStrategyRequest) SetAccessLines(v string) *UpdateGtmAccessStrategyRequest {
	s.AccessLines = &v
	return s
}

func (s *UpdateGtmAccessStrategyRequest) SetDefaultAddrPoolId(v string) *UpdateGtmAccessStrategyRequest {
	s.DefaultAddrPoolId = &v
	return s
}

func (s *UpdateGtmAccessStrategyRequest) SetFailoverAddrPoolId(v string) *UpdateGtmAccessStrategyRequest {
	s.FailoverAddrPoolId = &v
	return s
}

func (s *UpdateGtmAccessStrategyRequest) SetLang(v string) *UpdateGtmAccessStrategyRequest {
	s.Lang = &v
	return s
}

func (s *UpdateGtmAccessStrategyRequest) SetStrategyId(v string) *UpdateGtmAccessStrategyRequest {
	s.StrategyId = &v
	return s
}

func (s *UpdateGtmAccessStrategyRequest) SetStrategyName(v string) *UpdateGtmAccessStrategyRequest {
	s.StrategyName = &v
	return s
}

type UpdateGtmAccessStrategyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateGtmAccessStrategyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGtmAccessStrategyResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGtmAccessStrategyResponseBody) SetRequestId(v string) *UpdateGtmAccessStrategyResponseBody {
	s.RequestId = &v
	return s
}

type UpdateGtmAccessStrategyResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGtmAccessStrategyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGtmAccessStrategyResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGtmAccessStrategyResponse) GoString() string {
	return s.String()
}

func (s *UpdateGtmAccessStrategyResponse) SetHeaders(v map[string]*string) *UpdateGtmAccessStrategyResponse {
	s.Headers = v
	return s
}

func (s *UpdateGtmAccessStrategyResponse) SetStatusCode(v int32) *UpdateGtmAccessStrategyResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGtmAccessStrategyResponse) SetBody(v *UpdateGtmAccessStrategyResponseBody) *UpdateGtmAccessStrategyResponse {
	s.Body = v
	return s
}

type UpdateGtmAddressPoolRequest struct {
	Addr []*UpdateGtmAddressPoolRequestAddr `json:"Addr,omitempty" xml:"Addr,omitempty" type:"Repeated"`
	// The ID of the address pool that you want to modify.
	AddrPoolId *string `json:"AddrPoolId,omitempty" xml:"AddrPoolId,omitempty"`
	// The language used by the user.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The minimum number of available addresses in the address pool.
	MinAvailableAddrNum *int32 `json:"MinAvailableAddrNum,omitempty" xml:"MinAvailableAddrNum,omitempty"`
	// The name of the address pool that you want to modify.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the address pool that you want to modify.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateGtmAddressPoolRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGtmAddressPoolRequest) GoString() string {
	return s.String()
}

func (s *UpdateGtmAddressPoolRequest) SetAddr(v []*UpdateGtmAddressPoolRequestAddr) *UpdateGtmAddressPoolRequest {
	s.Addr = v
	return s
}

func (s *UpdateGtmAddressPoolRequest) SetAddrPoolId(v string) *UpdateGtmAddressPoolRequest {
	s.AddrPoolId = &v
	return s
}

func (s *UpdateGtmAddressPoolRequest) SetLang(v string) *UpdateGtmAddressPoolRequest {
	s.Lang = &v
	return s
}

func (s *UpdateGtmAddressPoolRequest) SetMinAvailableAddrNum(v int32) *UpdateGtmAddressPoolRequest {
	s.MinAvailableAddrNum = &v
	return s
}

func (s *UpdateGtmAddressPoolRequest) SetName(v string) *UpdateGtmAddressPoolRequest {
	s.Name = &v
	return s
}

func (s *UpdateGtmAddressPoolRequest) SetType(v string) *UpdateGtmAddressPoolRequest {
	s.Type = &v
	return s
}

type UpdateGtmAddressPoolRequestAddr struct {
	// The weight of the address pool that you want to modify.
	LbaWeight *int32 `json:"LbaWeight,omitempty" xml:"LbaWeight,omitempty"`
	// The mode of the address pool that you want to modify.
	//
	// *   **SMART**: Intelligent return
	// *   **ONLINE**: Always online
	// *   **OFFLINE**: Always offline
	Mode *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The addresses in the address pool.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s UpdateGtmAddressPoolRequestAddr) String() string {
	return tea.Prettify(s)
}

func (s UpdateGtmAddressPoolRequestAddr) GoString() string {
	return s.String()
}

func (s *UpdateGtmAddressPoolRequestAddr) SetLbaWeight(v int32) *UpdateGtmAddressPoolRequestAddr {
	s.LbaWeight = &v
	return s
}

func (s *UpdateGtmAddressPoolRequestAddr) SetMode(v string) *UpdateGtmAddressPoolRequestAddr {
	s.Mode = &v
	return s
}

func (s *UpdateGtmAddressPoolRequestAddr) SetValue(v string) *UpdateGtmAddressPoolRequestAddr {
	s.Value = &v
	return s
}

type UpdateGtmAddressPoolResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateGtmAddressPoolResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGtmAddressPoolResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGtmAddressPoolResponseBody) SetRequestId(v string) *UpdateGtmAddressPoolResponseBody {
	s.RequestId = &v
	return s
}

type UpdateGtmAddressPoolResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGtmAddressPoolResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGtmAddressPoolResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGtmAddressPoolResponse) GoString() string {
	return s.String()
}

func (s *UpdateGtmAddressPoolResponse) SetHeaders(v map[string]*string) *UpdateGtmAddressPoolResponse {
	s.Headers = v
	return s
}

func (s *UpdateGtmAddressPoolResponse) SetStatusCode(v int32) *UpdateGtmAddressPoolResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGtmAddressPoolResponse) SetBody(v *UpdateGtmAddressPoolResponseBody) *UpdateGtmAddressPoolResponse {
	s.Body = v
	return s
}

type UpdateGtmInstanceGlobalConfigRequest struct {
	// The alert group of the GTM instance. Currently, only one alert group is supported.
	//
	// >  This parameter is required for the first update, but is optional for later updates.
	AlertGroup *string `json:"AlertGroup,omitempty" xml:"AlertGroup,omitempty"`
	// The CNAME record of a domain name, which must be the primary domain name. When **CnameMode** is **CUSTOM**, this parameter is required for access.
	CnameCustomDomainName *string `json:"CnameCustomDomainName,omitempty" xml:"CnameCustomDomainName,omitempty"`
	// Specifies whether the CNAME record is user-defined or automatically assigned by the system. Valid values:
	//
	// *   **SYSTEM_ASSIGN**: Assigned by the system
	// *   **CUSTOM**: User-defined
	CnameMode *string `json:"CnameMode,omitempty" xml:"CnameMode,omitempty"`
	// The ID of the GTM instance whose configuration you want to modify.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the GTM instance.
	//
	// >  This parameter is required for the first update, but is not required for later updates.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The language used by the user.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The load balancing policy. Valid values:
	//
	// *   **ALL_RR**: Load balancing
	//
	// *   **RATIO**: Weighted round robin
	//
	// > This parameter is required for the first update, but is optional for later updates.
	LbaStrategy *string `json:"LbaStrategy,omitempty" xml:"LbaStrategy,omitempty"`
	// The time when the modification takes effect.
	Ttl *int32 `json:"Ttl,omitempty" xml:"Ttl,omitempty"`
	// The primary domain name.
	//
	// >  This parameter is required for the first update, but is optional for later updates.
	UserDomainName *string `json:"UserDomainName,omitempty" xml:"UserDomainName,omitempty"`
}

func (s UpdateGtmInstanceGlobalConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGtmInstanceGlobalConfigRequest) GoString() string {
	return s.String()
}

func (s *UpdateGtmInstanceGlobalConfigRequest) SetAlertGroup(v string) *UpdateGtmInstanceGlobalConfigRequest {
	s.AlertGroup = &v
	return s
}

func (s *UpdateGtmInstanceGlobalConfigRequest) SetCnameCustomDomainName(v string) *UpdateGtmInstanceGlobalConfigRequest {
	s.CnameCustomDomainName = &v
	return s
}

func (s *UpdateGtmInstanceGlobalConfigRequest) SetCnameMode(v string) *UpdateGtmInstanceGlobalConfigRequest {
	s.CnameMode = &v
	return s
}

func (s *UpdateGtmInstanceGlobalConfigRequest) SetInstanceId(v string) *UpdateGtmInstanceGlobalConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateGtmInstanceGlobalConfigRequest) SetInstanceName(v string) *UpdateGtmInstanceGlobalConfigRequest {
	s.InstanceName = &v
	return s
}

func (s *UpdateGtmInstanceGlobalConfigRequest) SetLang(v string) *UpdateGtmInstanceGlobalConfigRequest {
	s.Lang = &v
	return s
}

func (s *UpdateGtmInstanceGlobalConfigRequest) SetLbaStrategy(v string) *UpdateGtmInstanceGlobalConfigRequest {
	s.LbaStrategy = &v
	return s
}

func (s *UpdateGtmInstanceGlobalConfigRequest) SetTtl(v int32) *UpdateGtmInstanceGlobalConfigRequest {
	s.Ttl = &v
	return s
}

func (s *UpdateGtmInstanceGlobalConfigRequest) SetUserDomainName(v string) *UpdateGtmInstanceGlobalConfigRequest {
	s.UserDomainName = &v
	return s
}

type UpdateGtmInstanceGlobalConfigResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateGtmInstanceGlobalConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGtmInstanceGlobalConfigResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGtmInstanceGlobalConfigResponseBody) SetRequestId(v string) *UpdateGtmInstanceGlobalConfigResponseBody {
	s.RequestId = &v
	return s
}

type UpdateGtmInstanceGlobalConfigResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGtmInstanceGlobalConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGtmInstanceGlobalConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGtmInstanceGlobalConfigResponse) GoString() string {
	return s.String()
}

func (s *UpdateGtmInstanceGlobalConfigResponse) SetHeaders(v map[string]*string) *UpdateGtmInstanceGlobalConfigResponse {
	s.Headers = v
	return s
}

func (s *UpdateGtmInstanceGlobalConfigResponse) SetStatusCode(v int32) *UpdateGtmInstanceGlobalConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGtmInstanceGlobalConfigResponse) SetBody(v *UpdateGtmInstanceGlobalConfigResponseBody) *UpdateGtmInstanceGlobalConfigResponse {
	s.Body = v
	return s
}

type UpdateGtmMonitorRequest struct {
	// The maximum number of consecutive exceptions detected. If the number of consecutive exceptions detected reaches the maximum number, the application service is deemed abnormal.
	EvaluationCount *int32 `json:"EvaluationCount,omitempty" xml:"EvaluationCount,omitempty"`
	// The health check interval. Unit: seconds. Set the value to 60.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The monitored nodes.
	IspCityNode []*UpdateGtmMonitorRequestIspCityNode `json:"IspCityNode,omitempty" xml:"IspCityNode,omitempty" type:"Repeated"`
	// The language of the values of specific response parameters.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The ID of the health check configuration.
	MonitorConfigId *string `json:"MonitorConfigId,omitempty" xml:"MonitorConfigId,omitempty"`
	// The extended information, that is, the parameters required for the protocol. Different protocols require different parameters:
	//
	// HTTP or HTTPS:
	//
	// *   port: the port to check.
	// *   failureRate: the failure rate.
	// *   code: the status code threshold. If the returned status code is greater than the specified threshold, the application service is deemed abnormal. Valid values: 400 and 500.
	// *   host: the host configuration.
	// *   path: the health check URL.
	//
	// PING:
	//
	// *   packetNum: the number of ping packets.
	// *   packetLossRate: the loss rate of ping packets.
	// *   failureRate: the failure rate.
	//
	// TCP:
	//
	// *   port: the port to check.
	// *   failureRate: the failure rate.
	MonitorExtendInfo *string `json:"MonitorExtendInfo,omitempty" xml:"MonitorExtendInfo,omitempty"`
	// The protocol used for the health check.
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The health check timeout period. Unit: milliseconds. Valid values: 2000, 3000, 5000, and 10000.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
}

func (s UpdateGtmMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGtmMonitorRequest) GoString() string {
	return s.String()
}

func (s *UpdateGtmMonitorRequest) SetEvaluationCount(v int32) *UpdateGtmMonitorRequest {
	s.EvaluationCount = &v
	return s
}

func (s *UpdateGtmMonitorRequest) SetInterval(v int32) *UpdateGtmMonitorRequest {
	s.Interval = &v
	return s
}

func (s *UpdateGtmMonitorRequest) SetIspCityNode(v []*UpdateGtmMonitorRequestIspCityNode) *UpdateGtmMonitorRequest {
	s.IspCityNode = v
	return s
}

func (s *UpdateGtmMonitorRequest) SetLang(v string) *UpdateGtmMonitorRequest {
	s.Lang = &v
	return s
}

func (s *UpdateGtmMonitorRequest) SetMonitorConfigId(v string) *UpdateGtmMonitorRequest {
	s.MonitorConfigId = &v
	return s
}

func (s *UpdateGtmMonitorRequest) SetMonitorExtendInfo(v string) *UpdateGtmMonitorRequest {
	s.MonitorExtendInfo = &v
	return s
}

func (s *UpdateGtmMonitorRequest) SetProtocolType(v string) *UpdateGtmMonitorRequest {
	s.ProtocolType = &v
	return s
}

func (s *UpdateGtmMonitorRequest) SetTimeout(v int32) *UpdateGtmMonitorRequest {
	s.Timeout = &v
	return s
}

type UpdateGtmMonitorRequestIspCityNode struct {
	// The code of the city where the monitored node is deployed.
	CityCode *string `json:"CityCode,omitempty" xml:"CityCode,omitempty"`
	// *   The code of the Internet service provider (ISP) to which the monitored node belongs. For more information about specific values, see the response parameters of DescribeGtmMonitorAvailableConfig.
	// *   If the value of the GroupType parameter is BGP or OVERSEAS, IspCode is optional. The default value is 465.
	// *   If the value of the GroupType parameter is not BGP or OVERSEAS, IspCode is required and is used together with CityCode.
	IspCode *string `json:"IspCode,omitempty" xml:"IspCode,omitempty"`
}

func (s UpdateGtmMonitorRequestIspCityNode) String() string {
	return tea.Prettify(s)
}

func (s UpdateGtmMonitorRequestIspCityNode) GoString() string {
	return s.String()
}

func (s *UpdateGtmMonitorRequestIspCityNode) SetCityCode(v string) *UpdateGtmMonitorRequestIspCityNode {
	s.CityCode = &v
	return s
}

func (s *UpdateGtmMonitorRequestIspCityNode) SetIspCode(v string) *UpdateGtmMonitorRequestIspCityNode {
	s.IspCode = &v
	return s
}

type UpdateGtmMonitorResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateGtmMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGtmMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGtmMonitorResponseBody) SetRequestId(v string) *UpdateGtmMonitorResponseBody {
	s.RequestId = &v
	return s
}

type UpdateGtmMonitorResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGtmMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGtmMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGtmMonitorResponse) GoString() string {
	return s.String()
}

func (s *UpdateGtmMonitorResponse) SetHeaders(v map[string]*string) *UpdateGtmMonitorResponse {
	s.Headers = v
	return s
}

func (s *UpdateGtmMonitorResponse) SetStatusCode(v int32) *UpdateGtmMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGtmMonitorResponse) SetBody(v *UpdateGtmMonitorResponseBody) *UpdateGtmMonitorResponse {
	s.Body = v
	return s
}

type UpdateGtmRecoveryPlanRequest struct {
	// The list of faulty address pools.
	FaultAddrPool *string `json:"FaultAddrPool,omitempty" xml:"FaultAddrPool,omitempty"`
	// The language in which you want the values of some response parameters to be returned. These response parameters support multiple languages.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The name of the disaster recovery plan.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the disaster recovery plan.
	RecoveryPlanId *int64 `json:"RecoveryPlanId,omitempty" xml:"RecoveryPlanId,omitempty"`
	// The remarks about the disaster recovery plan.
	Remark *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
}

func (s UpdateGtmRecoveryPlanRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateGtmRecoveryPlanRequest) GoString() string {
	return s.String()
}

func (s *UpdateGtmRecoveryPlanRequest) SetFaultAddrPool(v string) *UpdateGtmRecoveryPlanRequest {
	s.FaultAddrPool = &v
	return s
}

func (s *UpdateGtmRecoveryPlanRequest) SetLang(v string) *UpdateGtmRecoveryPlanRequest {
	s.Lang = &v
	return s
}

func (s *UpdateGtmRecoveryPlanRequest) SetName(v string) *UpdateGtmRecoveryPlanRequest {
	s.Name = &v
	return s
}

func (s *UpdateGtmRecoveryPlanRequest) SetRecoveryPlanId(v int64) *UpdateGtmRecoveryPlanRequest {
	s.RecoveryPlanId = &v
	return s
}

func (s *UpdateGtmRecoveryPlanRequest) SetRemark(v string) *UpdateGtmRecoveryPlanRequest {
	s.Remark = &v
	return s
}

type UpdateGtmRecoveryPlanResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateGtmRecoveryPlanResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateGtmRecoveryPlanResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateGtmRecoveryPlanResponseBody) SetRequestId(v string) *UpdateGtmRecoveryPlanResponseBody {
	s.RequestId = &v
	return s
}

type UpdateGtmRecoveryPlanResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateGtmRecoveryPlanResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateGtmRecoveryPlanResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateGtmRecoveryPlanResponse) GoString() string {
	return s.String()
}

func (s *UpdateGtmRecoveryPlanResponse) SetHeaders(v map[string]*string) *UpdateGtmRecoveryPlanResponse {
	s.Headers = v
	return s
}

func (s *UpdateGtmRecoveryPlanResponse) SetStatusCode(v int32) *UpdateGtmRecoveryPlanResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateGtmRecoveryPlanResponse) SetBody(v *UpdateGtmRecoveryPlanResponseBody) *UpdateGtmRecoveryPlanResponse {
	s.Body = v
	return s
}

type UpdateIspFlushCacheInstanceConfigRequest struct {
	InstanceId   *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	Lang         *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s UpdateIspFlushCacheInstanceConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateIspFlushCacheInstanceConfigRequest) GoString() string {
	return s.String()
}

func (s *UpdateIspFlushCacheInstanceConfigRequest) SetInstanceId(v string) *UpdateIspFlushCacheInstanceConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateIspFlushCacheInstanceConfigRequest) SetInstanceName(v string) *UpdateIspFlushCacheInstanceConfigRequest {
	s.InstanceName = &v
	return s
}

func (s *UpdateIspFlushCacheInstanceConfigRequest) SetLang(v string) *UpdateIspFlushCacheInstanceConfigRequest {
	s.Lang = &v
	return s
}

type UpdateIspFlushCacheInstanceConfigResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateIspFlushCacheInstanceConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateIspFlushCacheInstanceConfigResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateIspFlushCacheInstanceConfigResponseBody) SetRequestId(v string) *UpdateIspFlushCacheInstanceConfigResponseBody {
	s.RequestId = &v
	return s
}

type UpdateIspFlushCacheInstanceConfigResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateIspFlushCacheInstanceConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateIspFlushCacheInstanceConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateIspFlushCacheInstanceConfigResponse) GoString() string {
	return s.String()
}

func (s *UpdateIspFlushCacheInstanceConfigResponse) SetHeaders(v map[string]*string) *UpdateIspFlushCacheInstanceConfigResponse {
	s.Headers = v
	return s
}

func (s *UpdateIspFlushCacheInstanceConfigResponse) SetStatusCode(v int32) *UpdateIspFlushCacheInstanceConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateIspFlushCacheInstanceConfigResponse) SetBody(v *UpdateIspFlushCacheInstanceConfigResponseBody) *UpdateIspFlushCacheInstanceConfigResponse {
	s.Body = v
	return s
}

type ValidateDnsGtmCnameRrCanUseRequest struct {
	CnameMode  *string `json:"CnameMode,omitempty" xml:"CnameMode,omitempty"`
	CnameRr    *string `json:"CnameRr,omitempty" xml:"CnameRr,omitempty"`
	CnameType  *string `json:"CnameType,omitempty" xml:"CnameType,omitempty"`
	CnameZone  *string `json:"CnameZone,omitempty" xml:"CnameZone,omitempty"`
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	Lang       *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s ValidateDnsGtmCnameRrCanUseRequest) String() string {
	return tea.Prettify(s)
}

func (s ValidateDnsGtmCnameRrCanUseRequest) GoString() string {
	return s.String()
}

func (s *ValidateDnsGtmCnameRrCanUseRequest) SetCnameMode(v string) *ValidateDnsGtmCnameRrCanUseRequest {
	s.CnameMode = &v
	return s
}

func (s *ValidateDnsGtmCnameRrCanUseRequest) SetCnameRr(v string) *ValidateDnsGtmCnameRrCanUseRequest {
	s.CnameRr = &v
	return s
}

func (s *ValidateDnsGtmCnameRrCanUseRequest) SetCnameType(v string) *ValidateDnsGtmCnameRrCanUseRequest {
	s.CnameType = &v
	return s
}

func (s *ValidateDnsGtmCnameRrCanUseRequest) SetCnameZone(v string) *ValidateDnsGtmCnameRrCanUseRequest {
	s.CnameZone = &v
	return s
}

func (s *ValidateDnsGtmCnameRrCanUseRequest) SetInstanceId(v string) *ValidateDnsGtmCnameRrCanUseRequest {
	s.InstanceId = &v
	return s
}

func (s *ValidateDnsGtmCnameRrCanUseRequest) SetLang(v string) *ValidateDnsGtmCnameRrCanUseRequest {
	s.Lang = &v
	return s
}

type ValidateDnsGtmCnameRrCanUseResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ValidateDnsGtmCnameRrCanUseResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ValidateDnsGtmCnameRrCanUseResponseBody) GoString() string {
	return s.String()
}

func (s *ValidateDnsGtmCnameRrCanUseResponseBody) SetRequestId(v string) *ValidateDnsGtmCnameRrCanUseResponseBody {
	s.RequestId = &v
	return s
}

type ValidateDnsGtmCnameRrCanUseResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ValidateDnsGtmCnameRrCanUseResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ValidateDnsGtmCnameRrCanUseResponse) String() string {
	return tea.Prettify(s)
}

func (s ValidateDnsGtmCnameRrCanUseResponse) GoString() string {
	return s.String()
}

func (s *ValidateDnsGtmCnameRrCanUseResponse) SetHeaders(v map[string]*string) *ValidateDnsGtmCnameRrCanUseResponse {
	s.Headers = v
	return s
}

func (s *ValidateDnsGtmCnameRrCanUseResponse) SetStatusCode(v int32) *ValidateDnsGtmCnameRrCanUseResponse {
	s.StatusCode = &v
	return s
}

func (s *ValidateDnsGtmCnameRrCanUseResponse) SetBody(v *ValidateDnsGtmCnameRrCanUseResponseBody) *ValidateDnsGtmCnameRrCanUseResponse {
	s.Body = v
	return s
}

type ValidatePdnsUdpIpSegmentRequest struct {
	Ip   *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
}

func (s ValidatePdnsUdpIpSegmentRequest) String() string {
	return tea.Prettify(s)
}

func (s ValidatePdnsUdpIpSegmentRequest) GoString() string {
	return s.String()
}

func (s *ValidatePdnsUdpIpSegmentRequest) SetIp(v string) *ValidatePdnsUdpIpSegmentRequest {
	s.Ip = &v
	return s
}

func (s *ValidatePdnsUdpIpSegmentRequest) SetLang(v string) *ValidatePdnsUdpIpSegmentRequest {
	s.Lang = &v
	return s
}

type ValidatePdnsUdpIpSegmentResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ValidatePdnsUdpIpSegmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ValidatePdnsUdpIpSegmentResponseBody) GoString() string {
	return s.String()
}

func (s *ValidatePdnsUdpIpSegmentResponseBody) SetRequestId(v string) *ValidatePdnsUdpIpSegmentResponseBody {
	s.RequestId = &v
	return s
}

type ValidatePdnsUdpIpSegmentResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ValidatePdnsUdpIpSegmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ValidatePdnsUdpIpSegmentResponse) String() string {
	return tea.Prettify(s)
}

func (s ValidatePdnsUdpIpSegmentResponse) GoString() string {
	return s.String()
}

func (s *ValidatePdnsUdpIpSegmentResponse) SetHeaders(v map[string]*string) *ValidatePdnsUdpIpSegmentResponse {
	s.Headers = v
	return s
}

func (s *ValidatePdnsUdpIpSegmentResponse) SetStatusCode(v int32) *ValidatePdnsUdpIpSegmentResponse {
	s.StatusCode = &v
	return s
}

func (s *ValidatePdnsUdpIpSegmentResponse) SetBody(v *ValidatePdnsUdpIpSegmentResponseBody) *ValidatePdnsUdpIpSegmentResponse {
	s.Body = v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.EndpointRule = tea.String("central")
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(tea.String("alidns"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !tea.BoolValue(util.Empty(endpoint)) {
		_result = endpoint
		return _result, _err
	}

	if !tea.BoolValue(util.IsUnset(endpointMap)) && !tea.BoolValue(util.Empty(endpointMap[tea.StringValue(regionId)])) {
		_result = endpointMap[tea.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := endpointutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * In each CIDR block, the end IP address must be greater than or equal to the start IP address.
 * The CIDR blocks that are specified for all custom lines of a domain name cannot intersect.
 *
 * @param request AddCustomLineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddCustomLineResponse
 */
func (client *Client) AddCustomLineWithOptions(request *AddCustomLineRequest, runtime *util.RuntimeOptions) (_result *AddCustomLineResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.IpSegment)) {
		query["IpSegment"] = request.IpSegment
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.LineName)) {
		query["LineName"] = request.LineName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddCustomLine"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddCustomLineResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * In each CIDR block, the end IP address must be greater than or equal to the start IP address.
 * The CIDR blocks that are specified for all custom lines of a domain name cannot intersect.
 *
 * @param request AddCustomLineRequest
 * @return AddCustomLineResponse
 */
func (client *Client) AddCustomLine(request *AddCustomLineRequest) (_result *AddCustomLineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddCustomLineResponse{}
	_body, _err := client.AddCustomLineWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddDnsCacheDomainWithOptions(request *AddDnsCacheDomainRequest, runtime *util.RuntimeOptions) (_result *AddDnsCacheDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CacheTtlMax)) {
		query["CacheTtlMax"] = request.CacheTtlMax
	}

	if !tea.BoolValue(util.IsUnset(request.CacheTtlMin)) {
		query["CacheTtlMin"] = request.CacheTtlMin
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.Remark)) {
		query["Remark"] = request.Remark
	}

	if !tea.BoolValue(util.IsUnset(request.SourceDnsServer)) {
		query["SourceDnsServer"] = request.SourceDnsServer
	}

	if !tea.BoolValue(util.IsUnset(request.SourceEdns)) {
		query["SourceEdns"] = request.SourceEdns
	}

	if !tea.BoolValue(util.IsUnset(request.SourceProtocol)) {
		query["SourceProtocol"] = request.SourceProtocol
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddDnsCacheDomain"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddDnsCacheDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddDnsCacheDomain(request *AddDnsCacheDomainRequest) (_result *AddDnsCacheDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddDnsCacheDomainResponse{}
	_body, _err := client.AddDnsCacheDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddDnsGtmAccessStrategyWithOptions(request *AddDnsGtmAccessStrategyRequest, runtime *util.RuntimeOptions) (_result *AddDnsGtmAccessStrategyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DefaultAddrPool)) {
		query["DefaultAddrPool"] = request.DefaultAddrPool
	}

	if !tea.BoolValue(util.IsUnset(request.DefaultAddrPoolType)) {
		query["DefaultAddrPoolType"] = request.DefaultAddrPoolType
	}

	if !tea.BoolValue(util.IsUnset(request.DefaultLatencyOptimization)) {
		query["DefaultLatencyOptimization"] = request.DefaultLatencyOptimization
	}

	if !tea.BoolValue(util.IsUnset(request.DefaultLbaStrategy)) {
		query["DefaultLbaStrategy"] = request.DefaultLbaStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.DefaultMaxReturnAddrNum)) {
		query["DefaultMaxReturnAddrNum"] = request.DefaultMaxReturnAddrNum
	}

	if !tea.BoolValue(util.IsUnset(request.DefaultMinAvailableAddrNum)) {
		query["DefaultMinAvailableAddrNum"] = request.DefaultMinAvailableAddrNum
	}

	if !tea.BoolValue(util.IsUnset(request.FailoverAddrPool)) {
		query["FailoverAddrPool"] = request.FailoverAddrPool
	}

	if !tea.BoolValue(util.IsUnset(request.FailoverAddrPoolType)) {
		query["FailoverAddrPoolType"] = request.FailoverAddrPoolType
	}

	if !tea.BoolValue(util.IsUnset(request.FailoverLatencyOptimization)) {
		query["FailoverLatencyOptimization"] = request.FailoverLatencyOptimization
	}

	if !tea.BoolValue(util.IsUnset(request.FailoverLbaStrategy)) {
		query["FailoverLbaStrategy"] = request.FailoverLbaStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.FailoverMaxReturnAddrNum)) {
		query["FailoverMaxReturnAddrNum"] = request.FailoverMaxReturnAddrNum
	}

	if !tea.BoolValue(util.IsUnset(request.FailoverMinAvailableAddrNum)) {
		query["FailoverMinAvailableAddrNum"] = request.FailoverMinAvailableAddrNum
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.Lines)) {
		query["Lines"] = request.Lines
	}

	if !tea.BoolValue(util.IsUnset(request.StrategyMode)) {
		query["StrategyMode"] = request.StrategyMode
	}

	if !tea.BoolValue(util.IsUnset(request.StrategyName)) {
		query["StrategyName"] = request.StrategyName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddDnsGtmAccessStrategy"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddDnsGtmAccessStrategyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddDnsGtmAccessStrategy(request *AddDnsGtmAccessStrategyRequest) (_result *AddDnsGtmAccessStrategyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddDnsGtmAccessStrategyResponse{}
	_body, _err := client.AddDnsGtmAccessStrategyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddDnsGtmAddressPoolWithOptions(request *AddDnsGtmAddressPoolRequest, runtime *util.RuntimeOptions) (_result *AddDnsGtmAddressPoolResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Addr)) {
		query["Addr"] = request.Addr
	}

	if !tea.BoolValue(util.IsUnset(request.EvaluationCount)) {
		query["EvaluationCount"] = request.EvaluationCount
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspCityNode)) {
		query["IspCityNode"] = request.IspCityNode
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.LbaStrategy)) {
		query["LbaStrategy"] = request.LbaStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.MonitorExtendInfo)) {
		query["MonitorExtendInfo"] = request.MonitorExtendInfo
	}

	if !tea.BoolValue(util.IsUnset(request.MonitorStatus)) {
		query["MonitorStatus"] = request.MonitorStatus
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ProtocolType)) {
		query["ProtocolType"] = request.ProtocolType
	}

	if !tea.BoolValue(util.IsUnset(request.Timeout)) {
		query["Timeout"] = request.Timeout
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddDnsGtmAddressPool"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddDnsGtmAddressPoolResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddDnsGtmAddressPool(request *AddDnsGtmAddressPoolRequest) (_result *AddDnsGtmAddressPoolResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddDnsGtmAddressPoolResponse{}
	_body, _err := client.AddDnsGtmAddressPoolWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ***
 *
 * @param request AddDnsGtmMonitorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddDnsGtmMonitorResponse
 */
func (client *Client) AddDnsGtmMonitorWithOptions(request *AddDnsGtmMonitorRequest, runtime *util.RuntimeOptions) (_result *AddDnsGtmMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AddrPoolId)) {
		query["AddrPoolId"] = request.AddrPoolId
	}

	if !tea.BoolValue(util.IsUnset(request.EvaluationCount)) {
		query["EvaluationCount"] = request.EvaluationCount
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspCityNode)) {
		query["IspCityNode"] = request.IspCityNode
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.MonitorExtendInfo)) {
		query["MonitorExtendInfo"] = request.MonitorExtendInfo
	}

	if !tea.BoolValue(util.IsUnset(request.ProtocolType)) {
		query["ProtocolType"] = request.ProtocolType
	}

	if !tea.BoolValue(util.IsUnset(request.Timeout)) {
		query["Timeout"] = request.Timeout
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddDnsGtmMonitor"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddDnsGtmMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ***
 *
 * @param request AddDnsGtmMonitorRequest
 * @return AddDnsGtmMonitorResponse
 */
func (client *Client) AddDnsGtmMonitor(request *AddDnsGtmMonitorRequest) (_result *AddDnsGtmMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddDnsGtmMonitorResponse{}
	_body, _err := client.AddDnsGtmMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can check whether a domain name is valid based on the following topic:
 * [Domain name validity](https://www.alibabacloud.com/help/zh/doc-detail/67788.htm)
 *
 * @param request AddDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddDomainResponse
 */
func (client *Client) AddDomainWithOptions(request *AddDomainRequest, runtime *util.RuntimeOptions) (_result *AddDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddDomain"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can check whether a domain name is valid based on the following topic:
 * [Domain name validity](https://www.alibabacloud.com/help/zh/doc-detail/67788.htm)
 *
 * @param request AddDomainRequest
 * @return AddDomainResponse
 */
func (client *Client) AddDomain(request *AddDomainRequest) (_result *AddDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddDomainResponse{}
	_body, _err := client.AddDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddDomainBackupWithOptions(request *AddDomainBackupRequest, runtime *util.RuntimeOptions) (_result *AddDomainBackupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PeriodType)) {
		query["PeriodType"] = request.PeriodType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddDomainBackup"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddDomainBackupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddDomainBackup(request *AddDomainBackupRequest) (_result *AddDomainBackupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddDomainBackupResponse{}
	_body, _err := client.AddDomainBackupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddDomainGroupWithOptions(request *AddDomainGroupRequest, runtime *util.RuntimeOptions) (_result *AddDomainGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddDomainGroup"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddDomainGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddDomainGroup(request *AddDomainGroupRequest) (_result *AddDomainGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddDomainGroupResponse{}
	_body, _err := client.AddDomainGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddDomainRecordWithOptions(request *AddDomainRecordRequest, runtime *util.RuntimeOptions) (_result *AddDomainRecordResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.Line)) {
		query["Line"] = request.Line
	}

	if !tea.BoolValue(util.IsUnset(request.Priority)) {
		query["Priority"] = request.Priority
	}

	if !tea.BoolValue(util.IsUnset(request.RR)) {
		query["RR"] = request.RR
	}

	if !tea.BoolValue(util.IsUnset(request.TTL)) {
		query["TTL"] = request.TTL
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	if !tea.BoolValue(util.IsUnset(request.UserClientIp)) {
		query["UserClientIp"] = request.UserClientIp
	}

	if !tea.BoolValue(util.IsUnset(request.Value)) {
		query["Value"] = request.Value
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddDomainRecord"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddDomainRecordResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddDomainRecord(request *AddDomainRecordRequest) (_result *AddDomainRecordResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddDomainRecordResponse{}
	_body, _err := client.AddDomainRecordWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddGtmAccessStrategyWithOptions(request *AddGtmAccessStrategyRequest, runtime *util.RuntimeOptions) (_result *AddGtmAccessStrategyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccessLines)) {
		query["AccessLines"] = request.AccessLines
	}

	if !tea.BoolValue(util.IsUnset(request.DefaultAddrPoolId)) {
		query["DefaultAddrPoolId"] = request.DefaultAddrPoolId
	}

	if !tea.BoolValue(util.IsUnset(request.FailoverAddrPoolId)) {
		query["FailoverAddrPoolId"] = request.FailoverAddrPoolId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.StrategyName)) {
		query["StrategyName"] = request.StrategyName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddGtmAccessStrategy"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddGtmAccessStrategyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddGtmAccessStrategy(request *AddGtmAccessStrategyRequest) (_result *AddGtmAccessStrategyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddGtmAccessStrategyResponse{}
	_body, _err := client.AddGtmAccessStrategyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddGtmAddressPoolWithOptions(request *AddGtmAddressPoolRequest, runtime *util.RuntimeOptions) (_result *AddGtmAddressPoolResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Addr)) {
		query["Addr"] = request.Addr
	}

	if !tea.BoolValue(util.IsUnset(request.EvaluationCount)) {
		query["EvaluationCount"] = request.EvaluationCount
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspCityNode)) {
		query["IspCityNode"] = request.IspCityNode
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.MinAvailableAddrNum)) {
		query["MinAvailableAddrNum"] = request.MinAvailableAddrNum
	}

	if !tea.BoolValue(util.IsUnset(request.MonitorExtendInfo)) {
		query["MonitorExtendInfo"] = request.MonitorExtendInfo
	}

	if !tea.BoolValue(util.IsUnset(request.MonitorStatus)) {
		query["MonitorStatus"] = request.MonitorStatus
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ProtocolType)) {
		query["ProtocolType"] = request.ProtocolType
	}

	if !tea.BoolValue(util.IsUnset(request.Timeout)) {
		query["Timeout"] = request.Timeout
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddGtmAddressPool"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddGtmAddressPoolResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddGtmAddressPool(request *AddGtmAddressPoolRequest) (_result *AddGtmAddressPoolResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddGtmAddressPoolResponse{}
	_body, _err := client.AddGtmAddressPoolWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddGtmMonitorWithOptions(request *AddGtmMonitorRequest, runtime *util.RuntimeOptions) (_result *AddGtmMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AddrPoolId)) {
		query["AddrPoolId"] = request.AddrPoolId
	}

	if !tea.BoolValue(util.IsUnset(request.EvaluationCount)) {
		query["EvaluationCount"] = request.EvaluationCount
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspCityNode)) {
		query["IspCityNode"] = request.IspCityNode
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.MonitorExtendInfo)) {
		query["MonitorExtendInfo"] = request.MonitorExtendInfo
	}

	if !tea.BoolValue(util.IsUnset(request.ProtocolType)) {
		query["ProtocolType"] = request.ProtocolType
	}

	if !tea.BoolValue(util.IsUnset(request.Timeout)) {
		query["Timeout"] = request.Timeout
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddGtmMonitor"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddGtmMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddGtmMonitor(request *AddGtmMonitorRequest) (_result *AddGtmMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddGtmMonitorResponse{}
	_body, _err := client.AddGtmMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddGtmRecoveryPlanWithOptions(request *AddGtmRecoveryPlanRequest, runtime *util.RuntimeOptions) (_result *AddGtmRecoveryPlanResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FaultAddrPool)) {
		query["FaultAddrPool"] = request.FaultAddrPool
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Remark)) {
		query["Remark"] = request.Remark
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddGtmRecoveryPlan"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddGtmRecoveryPlanResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddGtmRecoveryPlan(request *AddGtmRecoveryPlanRequest) (_result *AddGtmRecoveryPlanResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddGtmRecoveryPlanResponse{}
	_body, _err := client.AddGtmRecoveryPlanWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BindInstanceDomainsWithOptions(request *BindInstanceDomainsRequest, runtime *util.RuntimeOptions) (_result *BindInstanceDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainNames)) {
		query["DomainNames"] = request.DomainNames
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BindInstanceDomains"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BindInstanceDomainsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BindInstanceDomains(request *BindInstanceDomainsRequest) (_result *BindInstanceDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BindInstanceDomainsResponse{}
	_body, _err := client.BindInstanceDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ChangeDomainGroupWithOptions(request *ChangeDomainGroupRequest, runtime *util.RuntimeOptions) (_result *ChangeDomainGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ChangeDomainGroup"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ChangeDomainGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ChangeDomainGroup(request *ChangeDomainGroupRequest) (_result *ChangeDomainGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ChangeDomainGroupResponse{}
	_body, _err := client.ChangeDomainGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  You can call this operation to change the domain name for an Alibaba Cloud DNS instance to which a domain name is bound. You can also call this operation to bind a domain name to an Alibaba Cloud DNS instance to which no domain name is bound. If you need to unbind a domain name from an Alibaba Cloud DNS instance, you can call this operation. In this case, the NewDomain parameter must not be specified.
 *
 * @param request ChangeDomainOfDnsProductRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeDomainOfDnsProductResponse
 */
func (client *Client) ChangeDomainOfDnsProductWithOptions(request *ChangeDomainOfDnsProductRequest, runtime *util.RuntimeOptions) (_result *ChangeDomainOfDnsProductResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Force)) {
		query["Force"] = request.Force
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.NewDomain)) {
		query["NewDomain"] = request.NewDomain
	}

	if !tea.BoolValue(util.IsUnset(request.UserClientIp)) {
		query["UserClientIp"] = request.UserClientIp
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ChangeDomainOfDnsProduct"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ChangeDomainOfDnsProductResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  You can call this operation to change the domain name for an Alibaba Cloud DNS instance to which a domain name is bound. You can also call this operation to bind a domain name to an Alibaba Cloud DNS instance to which no domain name is bound. If you need to unbind a domain name from an Alibaba Cloud DNS instance, you can call this operation. In this case, the NewDomain parameter must not be specified.
 *
 * @param request ChangeDomainOfDnsProductRequest
 * @return ChangeDomainOfDnsProductResponse
 */
func (client *Client) ChangeDomainOfDnsProduct(request *ChangeDomainOfDnsProductRequest) (_result *ChangeDomainOfDnsProductResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ChangeDomainOfDnsProductResponse{}
	_body, _err := client.ChangeDomainOfDnsProductWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CopyGtmConfigWithOptions(request *CopyGtmConfigRequest, runtime *util.RuntimeOptions) (_result *CopyGtmConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CopyType)) {
		query["CopyType"] = request.CopyType
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.SourceId)) {
		query["SourceId"] = request.SourceId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetId)) {
		query["TargetId"] = request.TargetId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CopyGtmConfig"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CopyGtmConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CopyGtmConfig(request *CopyGtmConfigRequest) (_result *CopyGtmConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CopyGtmConfigResponse{}
	_body, _err := client.CopyGtmConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreatePdnsAppKeyWithOptions(request *CreatePdnsAppKeyRequest, runtime *util.RuntimeOptions) (_result *CreatePdnsAppKeyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreatePdnsAppKey"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreatePdnsAppKeyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreatePdnsAppKey(request *CreatePdnsAppKeyRequest) (_result *CreatePdnsAppKeyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreatePdnsAppKeyResponse{}
	_body, _err := client.CreatePdnsAppKeyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreatePdnsUdpIpSegmentWithOptions(request *CreatePdnsUdpIpSegmentRequest, runtime *util.RuntimeOptions) (_result *CreatePdnsUdpIpSegmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreatePdnsUdpIpSegment"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreatePdnsUdpIpSegmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreatePdnsUdpIpSegment(request *CreatePdnsUdpIpSegmentRequest) (_result *CreatePdnsUdpIpSegmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreatePdnsUdpIpSegmentResponse{}
	_body, _err := client.CreatePdnsUdpIpSegmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteCustomLinesWithOptions(request *DeleteCustomLinesRequest, runtime *util.RuntimeOptions) (_result *DeleteCustomLinesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.LineIds)) {
		query["LineIds"] = request.LineIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCustomLines"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCustomLinesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteCustomLines(request *DeleteCustomLinesRequest) (_result *DeleteCustomLinesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCustomLinesResponse{}
	_body, _err := client.DeleteCustomLinesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDnsCacheDomainWithOptions(request *DeleteDnsCacheDomainRequest, runtime *util.RuntimeOptions) (_result *DeleteDnsCacheDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDnsCacheDomain"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDnsCacheDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDnsCacheDomain(request *DeleteDnsCacheDomainRequest) (_result *DeleteDnsCacheDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDnsCacheDomainResponse{}
	_body, _err := client.DeleteDnsCacheDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDnsGtmAccessStrategyWithOptions(request *DeleteDnsGtmAccessStrategyRequest, runtime *util.RuntimeOptions) (_result *DeleteDnsGtmAccessStrategyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.StrategyId)) {
		query["StrategyId"] = request.StrategyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDnsGtmAccessStrategy"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDnsGtmAccessStrategyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDnsGtmAccessStrategy(request *DeleteDnsGtmAccessStrategyRequest) (_result *DeleteDnsGtmAccessStrategyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDnsGtmAccessStrategyResponse{}
	_body, _err := client.DeleteDnsGtmAccessStrategyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDnsGtmAddressPoolWithOptions(request *DeleteDnsGtmAddressPoolRequest, runtime *util.RuntimeOptions) (_result *DeleteDnsGtmAddressPoolResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AddrPoolId)) {
		query["AddrPoolId"] = request.AddrPoolId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDnsGtmAddressPool"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDnsGtmAddressPoolResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDnsGtmAddressPool(request *DeleteDnsGtmAddressPoolRequest) (_result *DeleteDnsGtmAddressPoolResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDnsGtmAddressPoolResponse{}
	_body, _err := client.DeleteDnsGtmAddressPoolWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   Given the unique nature of a HiChina domain name, you are not allowed to delete the HiChina domain name by calling the Alibaba Cloud DNS API.
 * *   If the system prompts that a domain name does not exist, it is an unregistered domain name, it does not exist under the account, or its format in the request parameters is incorrect.
 *
 * @param request DeleteDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDomainResponse
 */
func (client *Client) DeleteDomainWithOptions(request *DeleteDomainRequest, runtime *util.RuntimeOptions) (_result *DeleteDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDomain"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   Given the unique nature of a HiChina domain name, you are not allowed to delete the HiChina domain name by calling the Alibaba Cloud DNS API.
 * *   If the system prompts that a domain name does not exist, it is an unregistered domain name, it does not exist under the account, or its format in the request parameters is incorrect.
 *
 * @param request DeleteDomainRequest
 * @return DeleteDomainResponse
 */
func (client *Client) DeleteDomain(request *DeleteDomainRequest) (_result *DeleteDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDomainResponse{}
	_body, _err := client.DeleteDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  A domain name group can be deleted only when it contains no domain names. The default group cannot be deleted.
 *
 * @param request DeleteDomainGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDomainGroupResponse
 */
func (client *Client) DeleteDomainGroupWithOptions(request *DeleteDomainGroupRequest, runtime *util.RuntimeOptions) (_result *DeleteDomainGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDomainGroup"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDomainGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  A domain name group can be deleted only when it contains no domain names. The default group cannot be deleted.
 *
 * @param request DeleteDomainGroupRequest
 * @return DeleteDomainGroupResponse
 */
func (client *Client) DeleteDomainGroup(request *DeleteDomainGroupRequest) (_result *DeleteDomainGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDomainGroupResponse{}
	_body, _err := client.DeleteDomainGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDomainRecordWithOptions(request *DeleteDomainRecordRequest, runtime *util.RuntimeOptions) (_result *DeleteDomainRecordResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.RecordId)) {
		query["RecordId"] = request.RecordId
	}

	if !tea.BoolValue(util.IsUnset(request.UserClientIp)) {
		query["UserClientIp"] = request.UserClientIp
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDomainRecord"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDomainRecordResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDomainRecord(request *DeleteDomainRecordRequest) (_result *DeleteDomainRecordResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDomainRecordResponse{}
	_body, _err := client.DeleteDomainRecordWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteGtmAccessStrategyWithOptions(request *DeleteGtmAccessStrategyRequest, runtime *util.RuntimeOptions) (_result *DeleteGtmAccessStrategyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.StrategyId)) {
		query["StrategyId"] = request.StrategyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteGtmAccessStrategy"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteGtmAccessStrategyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteGtmAccessStrategy(request *DeleteGtmAccessStrategyRequest) (_result *DeleteGtmAccessStrategyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteGtmAccessStrategyResponse{}
	_body, _err := client.DeleteGtmAccessStrategyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteGtmAddressPoolWithOptions(request *DeleteGtmAddressPoolRequest, runtime *util.RuntimeOptions) (_result *DeleteGtmAddressPoolResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AddrPoolId)) {
		query["AddrPoolId"] = request.AddrPoolId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteGtmAddressPool"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteGtmAddressPoolResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteGtmAddressPool(request *DeleteGtmAddressPoolRequest) (_result *DeleteGtmAddressPoolResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteGtmAddressPoolResponse{}
	_body, _err := client.DeleteGtmAddressPoolWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteGtmRecoveryPlanWithOptions(request *DeleteGtmRecoveryPlanRequest, runtime *util.RuntimeOptions) (_result *DeleteGtmRecoveryPlanResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.RecoveryPlanId)) {
		query["RecoveryPlanId"] = request.RecoveryPlanId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteGtmRecoveryPlan"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteGtmRecoveryPlanResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteGtmRecoveryPlan(request *DeleteGtmRecoveryPlanRequest) (_result *DeleteGtmRecoveryPlanResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteGtmRecoveryPlanResponse{}
	_body, _err := client.DeleteGtmRecoveryPlanWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If the DNS records to be deleted contain locked DNS records, locked DNS records will not be deleted.
 *
 * @param request DeleteSubDomainRecordsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSubDomainRecordsResponse
 */
func (client *Client) DeleteSubDomainRecordsWithOptions(request *DeleteSubDomainRecordsRequest, runtime *util.RuntimeOptions) (_result *DeleteSubDomainRecordsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.RR)) {
		query["RR"] = request.RR
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	if !tea.BoolValue(util.IsUnset(request.UserClientIp)) {
		query["UserClientIp"] = request.UserClientIp
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSubDomainRecords"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSubDomainRecordsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If the DNS records to be deleted contain locked DNS records, locked DNS records will not be deleted.
 *
 * @param request DeleteSubDomainRecordsRequest
 * @return DeleteSubDomainRecordsResponse
 */
func (client *Client) DeleteSubDomainRecords(request *DeleteSubDomainRecordsRequest) (_result *DeleteSubDomainRecordsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSubDomainRecordsResponse{}
	_body, _err := client.DeleteSubDomainRecordsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeBatchResultCountWithOptions(request *DescribeBatchResultCountRequest, runtime *util.RuntimeOptions) (_result *DescribeBatchResultCountResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BatchType)) {
		query["BatchType"] = request.BatchType
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeBatchResultCount"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeBatchResultCountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeBatchResultCount(request *DescribeBatchResultCountRequest) (_result *DescribeBatchResultCountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeBatchResultCountResponse{}
	_body, _err := client.DescribeBatchResultCountWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this operation, make sure that the batch tasks have been executed.
 *
 * @param request DescribeBatchResultDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBatchResultDetailResponse
 */
func (client *Client) DescribeBatchResultDetailWithOptions(request *DescribeBatchResultDetailRequest, runtime *util.RuntimeOptions) (_result *DescribeBatchResultDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BatchType)) {
		query["BatchType"] = request.BatchType
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeBatchResultDetail"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeBatchResultDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this operation, make sure that the batch tasks have been executed.
 *
 * @param request DescribeBatchResultDetailRequest
 * @return DescribeBatchResultDetailResponse
 */
func (client *Client) DescribeBatchResultDetail(request *DescribeBatchResultDetailRequest) (_result *DescribeBatchResultDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeBatchResultDetailResponse{}
	_body, _err := client.DescribeBatchResultDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCustomLineWithOptions(request *DescribeCustomLineRequest, runtime *util.RuntimeOptions) (_result *DescribeCustomLineResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.LineId)) {
		query["LineId"] = request.LineId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCustomLine"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCustomLineResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCustomLine(request *DescribeCustomLineRequest) (_result *DescribeCustomLineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCustomLineResponse{}
	_body, _err := client.DescribeCustomLineWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCustomLinesWithOptions(request *DescribeCustomLinesRequest, runtime *util.RuntimeOptions) (_result *DescribeCustomLinesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCustomLines"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCustomLinesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCustomLines(request *DescribeCustomLinesRequest) (_result *DescribeCustomLinesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCustomLinesResponse{}
	_body, _err := client.DescribeCustomLinesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDNSSLBSubDomainsWithOptions(request *DescribeDNSSLBSubDomainsRequest, runtime *util.RuntimeOptions) (_result *DescribeDNSSLBSubDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Rr)) {
		query["Rr"] = request.Rr
	}

	if !tea.BoolValue(util.IsUnset(request.UserClientIp)) {
		query["UserClientIp"] = request.UserClientIp
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDNSSLBSubDomains"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDNSSLBSubDomainsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDNSSLBSubDomains(request *DescribeDNSSLBSubDomainsRequest) (_result *DescribeDNSSLBSubDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDNSSLBSubDomainsResponse{}
	_body, _err := client.DescribeDNSSLBSubDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDnsCacheDomainsWithOptions(request *DescribeDnsCacheDomainsRequest, runtime *util.RuntimeOptions) (_result *DescribeDnsCacheDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDnsCacheDomains"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDnsCacheDomainsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDnsCacheDomains(request *DescribeDnsCacheDomainsRequest) (_result *DescribeDnsCacheDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDnsCacheDomainsResponse{}
	_body, _err := client.DescribeDnsCacheDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDnsGtmAccessStrategiesWithOptions(request *DescribeDnsGtmAccessStrategiesRequest, runtime *util.RuntimeOptions) (_result *DescribeDnsGtmAccessStrategiesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StrategyMode)) {
		query["StrategyMode"] = request.StrategyMode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDnsGtmAccessStrategies"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDnsGtmAccessStrategiesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDnsGtmAccessStrategies(request *DescribeDnsGtmAccessStrategiesRequest) (_result *DescribeDnsGtmAccessStrategiesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDnsGtmAccessStrategiesResponse{}
	_body, _err := client.DescribeDnsGtmAccessStrategiesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDnsGtmAccessStrategyWithOptions(request *DescribeDnsGtmAccessStrategyRequest, runtime *util.RuntimeOptions) (_result *DescribeDnsGtmAccessStrategyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.StrategyId)) {
		query["StrategyId"] = request.StrategyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDnsGtmAccessStrategy"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDnsGtmAccessStrategyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDnsGtmAccessStrategy(request *DescribeDnsGtmAccessStrategyRequest) (_result *DescribeDnsGtmAccessStrategyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDnsGtmAccessStrategyResponse{}
	_body, _err := client.DescribeDnsGtmAccessStrategyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDnsGtmAccessStrategyAvailableConfigWithOptions(request *DescribeDnsGtmAccessStrategyAvailableConfigRequest, runtime *util.RuntimeOptions) (_result *DescribeDnsGtmAccessStrategyAvailableConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.StrategyMode)) {
		query["StrategyMode"] = request.StrategyMode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDnsGtmAccessStrategyAvailableConfig"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDnsGtmAccessStrategyAvailableConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDnsGtmAccessStrategyAvailableConfig(request *DescribeDnsGtmAccessStrategyAvailableConfigRequest) (_result *DescribeDnsGtmAccessStrategyAvailableConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDnsGtmAccessStrategyAvailableConfigResponse{}
	_body, _err := client.DescribeDnsGtmAccessStrategyAvailableConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDnsGtmAddrAttributeInfoWithOptions(request *DescribeDnsGtmAddrAttributeInfoRequest, runtime *util.RuntimeOptions) (_result *DescribeDnsGtmAddrAttributeInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Addrs)) {
		query["Addrs"] = request.Addrs
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDnsGtmAddrAttributeInfo"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDnsGtmAddrAttributeInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDnsGtmAddrAttributeInfo(request *DescribeDnsGtmAddrAttributeInfoRequest) (_result *DescribeDnsGtmAddrAttributeInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDnsGtmAddrAttributeInfoResponse{}
	_body, _err := client.DescribeDnsGtmAddrAttributeInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDnsGtmAddressPoolAvailableConfigWithOptions(request *DescribeDnsGtmAddressPoolAvailableConfigRequest, runtime *util.RuntimeOptions) (_result *DescribeDnsGtmAddressPoolAvailableConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDnsGtmAddressPoolAvailableConfig"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDnsGtmAddressPoolAvailableConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDnsGtmAddressPoolAvailableConfig(request *DescribeDnsGtmAddressPoolAvailableConfigRequest) (_result *DescribeDnsGtmAddressPoolAvailableConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDnsGtmAddressPoolAvailableConfigResponse{}
	_body, _err := client.DescribeDnsGtmAddressPoolAvailableConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDnsGtmAvailableAlertGroupWithOptions(request *DescribeDnsGtmAvailableAlertGroupRequest, runtime *util.RuntimeOptions) (_result *DescribeDnsGtmAvailableAlertGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDnsGtmAvailableAlertGroup"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDnsGtmAvailableAlertGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDnsGtmAvailableAlertGroup(request *DescribeDnsGtmAvailableAlertGroupRequest) (_result *DescribeDnsGtmAvailableAlertGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDnsGtmAvailableAlertGroupResponse{}
	_body, _err := client.DescribeDnsGtmAvailableAlertGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDnsGtmInstanceWithOptions(request *DescribeDnsGtmInstanceRequest, runtime *util.RuntimeOptions) (_result *DescribeDnsGtmInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDnsGtmInstance"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDnsGtmInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDnsGtmInstance(request *DescribeDnsGtmInstanceRequest) (_result *DescribeDnsGtmInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDnsGtmInstanceResponse{}
	_body, _err := client.DescribeDnsGtmInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDnsGtmInstanceAddressPoolWithOptions(request *DescribeDnsGtmInstanceAddressPoolRequest, runtime *util.RuntimeOptions) (_result *DescribeDnsGtmInstanceAddressPoolResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AddrPoolId)) {
		query["AddrPoolId"] = request.AddrPoolId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDnsGtmInstanceAddressPool"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDnsGtmInstanceAddressPoolResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDnsGtmInstanceAddressPool(request *DescribeDnsGtmInstanceAddressPoolRequest) (_result *DescribeDnsGtmInstanceAddressPoolResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDnsGtmInstanceAddressPoolResponse{}
	_body, _err := client.DescribeDnsGtmInstanceAddressPoolWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDnsGtmInstanceAddressPoolsWithOptions(request *DescribeDnsGtmInstanceAddressPoolsRequest, runtime *util.RuntimeOptions) (_result *DescribeDnsGtmInstanceAddressPoolsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDnsGtmInstanceAddressPools"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDnsGtmInstanceAddressPoolsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDnsGtmInstanceAddressPools(request *DescribeDnsGtmInstanceAddressPoolsRequest) (_result *DescribeDnsGtmInstanceAddressPoolsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDnsGtmInstanceAddressPoolsResponse{}
	_body, _err := client.DescribeDnsGtmInstanceAddressPoolsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDnsGtmInstanceStatusWithOptions(request *DescribeDnsGtmInstanceStatusRequest, runtime *util.RuntimeOptions) (_result *DescribeDnsGtmInstanceStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDnsGtmInstanceStatus"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDnsGtmInstanceStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDnsGtmInstanceStatus(request *DescribeDnsGtmInstanceStatusRequest) (_result *DescribeDnsGtmInstanceStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDnsGtmInstanceStatusResponse{}
	_body, _err := client.DescribeDnsGtmInstanceStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDnsGtmInstanceSystemCnameWithOptions(request *DescribeDnsGtmInstanceSystemCnameRequest, runtime *util.RuntimeOptions) (_result *DescribeDnsGtmInstanceSystemCnameResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDnsGtmInstanceSystemCname"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDnsGtmInstanceSystemCnameResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDnsGtmInstanceSystemCname(request *DescribeDnsGtmInstanceSystemCnameRequest) (_result *DescribeDnsGtmInstanceSystemCnameResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDnsGtmInstanceSystemCnameResponse{}
	_body, _err := client.DescribeDnsGtmInstanceSystemCnameWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDnsGtmInstancesWithOptions(request *DescribeDnsGtmInstancesRequest, runtime *util.RuntimeOptions) (_result *DescribeDnsGtmInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDnsGtmInstances"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDnsGtmInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDnsGtmInstances(request *DescribeDnsGtmInstancesRequest) (_result *DescribeDnsGtmInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDnsGtmInstancesResponse{}
	_body, _err := client.DescribeDnsGtmInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDnsGtmLogsWithOptions(request *DescribeDnsGtmLogsRequest, runtime *util.RuntimeOptions) (_result *DescribeDnsGtmLogsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTimestamp)) {
		query["EndTimestamp"] = request.EndTimestamp
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartTimestamp)) {
		query["StartTimestamp"] = request.StartTimestamp
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDnsGtmLogs"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDnsGtmLogsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDnsGtmLogs(request *DescribeDnsGtmLogsRequest) (_result *DescribeDnsGtmLogsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDnsGtmLogsResponse{}
	_body, _err := client.DescribeDnsGtmLogsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDnsGtmMonitorAvailableConfigWithOptions(request *DescribeDnsGtmMonitorAvailableConfigRequest, runtime *util.RuntimeOptions) (_result *DescribeDnsGtmMonitorAvailableConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDnsGtmMonitorAvailableConfig"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDnsGtmMonitorAvailableConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDnsGtmMonitorAvailableConfig(request *DescribeDnsGtmMonitorAvailableConfigRequest) (_result *DescribeDnsGtmMonitorAvailableConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDnsGtmMonitorAvailableConfigResponse{}
	_body, _err := client.DescribeDnsGtmMonitorAvailableConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDnsGtmMonitorConfigWithOptions(request *DescribeDnsGtmMonitorConfigRequest, runtime *util.RuntimeOptions) (_result *DescribeDnsGtmMonitorConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.MonitorConfigId)) {
		query["MonitorConfigId"] = request.MonitorConfigId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDnsGtmMonitorConfig"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDnsGtmMonitorConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDnsGtmMonitorConfig(request *DescribeDnsGtmMonitorConfigRequest) (_result *DescribeDnsGtmMonitorConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDnsGtmMonitorConfigResponse{}
	_body, _err := client.DescribeDnsGtmMonitorConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDnsProductInstanceWithOptions(request *DescribeDnsProductInstanceRequest, runtime *util.RuntimeOptions) (_result *DescribeDnsProductInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.UserClientIp)) {
		query["UserClientIp"] = request.UserClientIp
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDnsProductInstance"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDnsProductInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDnsProductInstance(request *DescribeDnsProductInstanceRequest) (_result *DescribeDnsProductInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDnsProductInstanceResponse{}
	_body, _err := client.DescribeDnsProductInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  If the response parameters of an Alibaba Cloud DNS instance do not contain domain names, no domain names are bound to the instance.
 *
 * @param request DescribeDnsProductInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDnsProductInstancesResponse
 */
func (client *Client) DescribeDnsProductInstancesWithOptions(request *DescribeDnsProductInstancesRequest, runtime *util.RuntimeOptions) (_result *DescribeDnsProductInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainType)) {
		query["DomainType"] = request.DomainType
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.UserClientIp)) {
		query["UserClientIp"] = request.UserClientIp
	}

	if !tea.BoolValue(util.IsUnset(request.VersionCode)) {
		query["VersionCode"] = request.VersionCode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDnsProductInstances"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDnsProductInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  If the response parameters of an Alibaba Cloud DNS instance do not contain domain names, no domain names are bound to the instance.
 *
 * @param request DescribeDnsProductInstancesRequest
 * @return DescribeDnsProductInstancesResponse
 */
func (client *Client) DescribeDnsProductInstances(request *DescribeDnsProductInstancesRequest) (_result *DescribeDnsProductInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDnsProductInstancesResponse{}
	_body, _err := client.DescribeDnsProductInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDohAccountStatisticsWithOptions(request *DescribeDohAccountStatisticsRequest, runtime *util.RuntimeOptions) (_result *DescribeDohAccountStatisticsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		query["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		query["StartDate"] = request.StartDate
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDohAccountStatistics"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDohAccountStatisticsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDohAccountStatistics(request *DescribeDohAccountStatisticsRequest) (_result *DescribeDohAccountStatisticsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDohAccountStatisticsResponse{}
	_body, _err := client.DescribeDohAccountStatisticsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDohDomainStatisticsWithOptions(request *DescribeDohDomainStatisticsRequest, runtime *util.RuntimeOptions) (_result *DescribeDohDomainStatisticsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		query["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		query["StartDate"] = request.StartDate
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDohDomainStatistics"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDohDomainStatisticsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDohDomainStatistics(request *DescribeDohDomainStatisticsRequest) (_result *DescribeDohDomainStatisticsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDohDomainStatisticsResponse{}
	_body, _err := client.DescribeDohDomainStatisticsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDohDomainStatisticsSummaryWithOptions(request *DescribeDohDomainStatisticsSummaryRequest, runtime *util.RuntimeOptions) (_result *DescribeDohDomainStatisticsSummaryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		query["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		query["StartDate"] = request.StartDate
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDohDomainStatisticsSummary"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDohDomainStatisticsSummaryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDohDomainStatisticsSummary(request *DescribeDohDomainStatisticsSummaryRequest) (_result *DescribeDohDomainStatisticsSummaryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDohDomainStatisticsSummaryResponse{}
	_body, _err := client.DescribeDohDomainStatisticsSummaryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDohSubDomainStatisticsWithOptions(request *DescribeDohSubDomainStatisticsRequest, runtime *util.RuntimeOptions) (_result *DescribeDohSubDomainStatisticsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		query["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		query["StartDate"] = request.StartDate
	}

	if !tea.BoolValue(util.IsUnset(request.SubDomain)) {
		query["SubDomain"] = request.SubDomain
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDohSubDomainStatistics"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDohSubDomainStatisticsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDohSubDomainStatistics(request *DescribeDohSubDomainStatisticsRequest) (_result *DescribeDohSubDomainStatisticsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDohSubDomainStatisticsResponse{}
	_body, _err := client.DescribeDohSubDomainStatisticsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDohSubDomainStatisticsSummaryWithOptions(request *DescribeDohSubDomainStatisticsSummaryRequest, runtime *util.RuntimeOptions) (_result *DescribeDohSubDomainStatisticsSummaryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		query["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		query["StartDate"] = request.StartDate
	}

	if !tea.BoolValue(util.IsUnset(request.SubDomain)) {
		query["SubDomain"] = request.SubDomain
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDohSubDomainStatisticsSummary"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDohSubDomainStatisticsSummaryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDohSubDomainStatisticsSummary(request *DescribeDohSubDomainStatisticsSummaryRequest) (_result *DescribeDohSubDomainStatisticsSummaryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDohSubDomainStatisticsSummaryResponse{}
	_body, _err := client.DescribeDohSubDomainStatisticsSummaryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDohUserInfoWithOptions(request *DescribeDohUserInfoRequest, runtime *util.RuntimeOptions) (_result *DescribeDohUserInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		query["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		query["StartDate"] = request.StartDate
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDohUserInfo"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDohUserInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDohUserInfo(request *DescribeDohUserInfoRequest) (_result *DescribeDohUserInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDohUserInfoResponse{}
	_body, _err := client.DescribeDohUserInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDomainDnssecInfoWithOptions(request *DescribeDomainDnssecInfoRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainDnssecInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainDnssecInfo"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainDnssecInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDomainDnssecInfo(request *DescribeDomainDnssecInfoRequest) (_result *DescribeDomainDnssecInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainDnssecInfoResponse{}
	_body, _err := client.DescribeDomainDnssecInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDomainGroupsWithOptions(request *DescribeDomainGroupsRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.KeyWord)) {
		query["KeyWord"] = request.KeyWord
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainGroups"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDomainGroups(request *DescribeDomainGroupsRequest) (_result *DescribeDomainGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainGroupsResponse{}
	_body, _err := client.DescribeDomainGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * In this example, the domain name is bound to an Alibaba Cloud DNS instance of Enterprise Ultimate Edition. For more information about valid lines, see the return values of the RecordLines parameter.
 *
 * @param request DescribeDomainInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainInfoResponse
 */
func (client *Client) DescribeDomainInfoWithOptions(request *DescribeDomainInfoRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.NeedDetailAttributes)) {
		query["NeedDetailAttributes"] = request.NeedDetailAttributes
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainInfo"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * In this example, the domain name is bound to an Alibaba Cloud DNS instance of Enterprise Ultimate Edition. For more information about valid lines, see the return values of the RecordLines parameter.
 *
 * @param request DescribeDomainInfoRequest
 * @return DescribeDomainInfoResponse
 */
func (client *Client) DescribeDomainInfo(request *DescribeDomainInfoRequest) (_result *DescribeDomainInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainInfoResponse{}
	_body, _err := client.DescribeDomainInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDomainLogsWithOptions(request *DescribeDomainLogsRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainLogsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.KeyWord)) {
		query["KeyWord"] = request.KeyWord
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		query["StartDate"] = request.StartDate
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		query["endDate"] = request.EndDate
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainLogs"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainLogsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDomainLogs(request *DescribeDomainLogsRequest) (_result *DescribeDomainLogsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainLogsResponse{}
	_body, _err := client.DescribeDomainLogsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  This operation queries the authoritative server of the registry to obtain the name servers of a domain name. If the domain name is in the serverHold or clientHold state, an exception may occur.
 *
 * @param request DescribeDomainNsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainNsResponse
 */
func (client *Client) DescribeDomainNsWithOptions(request *DescribeDomainNsRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainNsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainNs"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainNsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  This operation queries the authoritative server of the registry to obtain the name servers of a domain name. If the domain name is in the serverHold or clientHold state, an exception may occur.
 *
 * @param request DescribeDomainNsRequest
 * @return DescribeDomainNsResponse
 */
func (client *Client) DescribeDomainNs(request *DescribeDomainNsRequest) (_result *DescribeDomainNsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainNsResponse{}
	_body, _err := client.DescribeDomainNsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDomainRecordInfoWithOptions(request *DescribeDomainRecordInfoRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainRecordInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.RecordId)) {
		query["RecordId"] = request.RecordId
	}

	if !tea.BoolValue(util.IsUnset(request.UserClientIp)) {
		query["UserClientIp"] = request.UserClientIp
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainRecordInfo"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainRecordInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDomainRecordInfo(request *DescribeDomainRecordInfoRequest) (_result *DescribeDomainRecordInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainRecordInfoResponse{}
	_body, _err := client.DescribeDomainRecordInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can specify the DomainName, PageNumber, and PageSize parameters to query the DNS records of a domain name.
 * *   You can also specify the RRKeyWord, TypeKeyWord, or ValueKeyWord parameter to query the DNS records that contain the specified keyword.
 * *   By default, the DNS records are sorted in reverse chronological order based on the time when they were added.
 *
 * @param request DescribeDomainRecordsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainRecordsResponse
 */
func (client *Client) DescribeDomainRecordsWithOptions(request *DescribeDomainRecordsRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainRecordsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Direction)) {
		query["Direction"] = request.Direction
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.KeyWord)) {
		query["KeyWord"] = request.KeyWord
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.Line)) {
		query["Line"] = request.Line
	}

	if !tea.BoolValue(util.IsUnset(request.OrderBy)) {
		query["OrderBy"] = request.OrderBy
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RRKeyWord)) {
		query["RRKeyWord"] = request.RRKeyWord
	}

	if !tea.BoolValue(util.IsUnset(request.SearchMode)) {
		query["SearchMode"] = request.SearchMode
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	if !tea.BoolValue(util.IsUnset(request.TypeKeyWord)) {
		query["TypeKeyWord"] = request.TypeKeyWord
	}

	if !tea.BoolValue(util.IsUnset(request.ValueKeyWord)) {
		query["ValueKeyWord"] = request.ValueKeyWord
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainRecords"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainRecordsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can specify the DomainName, PageNumber, and PageSize parameters to query the DNS records of a domain name.
 * *   You can also specify the RRKeyWord, TypeKeyWord, or ValueKeyWord parameter to query the DNS records that contain the specified keyword.
 * *   By default, the DNS records are sorted in reverse chronological order based on the time when they were added.
 *
 * @param request DescribeDomainRecordsRequest
 * @return DescribeDomainRecordsResponse
 */
func (client *Client) DescribeDomainRecords(request *DescribeDomainRecordsRequest) (_result *DescribeDomainRecordsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainRecordsResponse{}
	_body, _err := client.DescribeDomainRecordsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDomainResolveStatisticsSummaryWithOptions(request *DescribeDomainResolveStatisticsSummaryRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainResolveStatisticsSummaryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Direction)) {
		query["Direction"] = request.Direction
	}

	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		query["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SearchMode)) {
		query["SearchMode"] = request.SearchMode
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		query["StartDate"] = request.StartDate
	}

	if !tea.BoolValue(util.IsUnset(request.Threshold)) {
		query["Threshold"] = request.Threshold
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainResolveStatisticsSummary"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainResolveStatisticsSummaryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDomainResolveStatisticsSummary(request *DescribeDomainResolveStatisticsSummaryRequest) (_result *DescribeDomainResolveStatisticsSummaryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainResolveStatisticsSummaryResponse{}
	_body, _err := client.DescribeDomainResolveStatisticsSummaryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Real-time data is collected per hour.
 *
 * @param request DescribeDomainStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainStatisticsResponse
 */
func (client *Client) DescribeDomainStatisticsWithOptions(request *DescribeDomainStatisticsRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainStatisticsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.DomainType)) {
		query["DomainType"] = request.DomainType
	}

	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		query["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		query["StartDate"] = request.StartDate
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainStatistics"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainStatisticsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Real-time data is collected per hour.
 *
 * @param request DescribeDomainStatisticsRequest
 * @return DescribeDomainStatisticsResponse
 */
func (client *Client) DescribeDomainStatistics(request *DescribeDomainStatisticsRequest) (_result *DescribeDomainStatisticsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainStatisticsResponse{}
	_body, _err := client.DescribeDomainStatisticsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDomainStatisticsSummaryWithOptions(request *DescribeDomainStatisticsSummaryRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainStatisticsSummaryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		query["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SearchMode)) {
		query["SearchMode"] = request.SearchMode
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		query["StartDate"] = request.StartDate
	}

	if !tea.BoolValue(util.IsUnset(request.Threshold)) {
		query["Threshold"] = request.Threshold
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainStatisticsSummary"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainStatisticsSummaryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDomainStatisticsSummary(request *DescribeDomainStatisticsSummaryRequest) (_result *DescribeDomainStatisticsSummaryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainStatisticsSummaryResponse{}
	_body, _err := client.DescribeDomainStatisticsSummaryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can specify the PageNumber and PageSize parameters to query domain names.
 * *   You can specify the KeyWord parameter to query domain names that contain the specified keyword.
 * *   By default, the domain names in a list are sorted in descending order of the time they were added.
 * *   You can specify the GroupId parameter. If you do not specify this parameter, all domain names are queried by default.
 *
 * @param request DescribeDomainsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainsResponse
 */
func (client *Client) DescribeDomainsWithOptions(request *DescribeDomainsRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.KeyWord)) {
		query["KeyWord"] = request.KeyWord
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SearchMode)) {
		query["SearchMode"] = request.SearchMode
	}

	if !tea.BoolValue(util.IsUnset(request.Starmark)) {
		query["Starmark"] = request.Starmark
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomains"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can specify the PageNumber and PageSize parameters to query domain names.
 * *   You can specify the KeyWord parameter to query domain names that contain the specified keyword.
 * *   By default, the domain names in a list are sorted in descending order of the time they were added.
 * *   You can specify the GroupId parameter. If you do not specify this parameter, all domain names are queried by default.
 *
 * @param request DescribeDomainsRequest
 * @return DescribeDomainsResponse
 */
func (client *Client) DescribeDomains(request *DescribeDomainsRequest) (_result *DescribeDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainsResponse{}
	_body, _err := client.DescribeDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeGtmAccessStrategiesWithOptions(request *DescribeGtmAccessStrategiesRequest, runtime *util.RuntimeOptions) (_result *DescribeGtmAccessStrategiesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeGtmAccessStrategies"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeGtmAccessStrategiesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeGtmAccessStrategies(request *DescribeGtmAccessStrategiesRequest) (_result *DescribeGtmAccessStrategiesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeGtmAccessStrategiesResponse{}
	_body, _err := client.DescribeGtmAccessStrategiesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeGtmAccessStrategyWithOptions(request *DescribeGtmAccessStrategyRequest, runtime *util.RuntimeOptions) (_result *DescribeGtmAccessStrategyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.StrategyId)) {
		query["StrategyId"] = request.StrategyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeGtmAccessStrategy"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeGtmAccessStrategyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeGtmAccessStrategy(request *DescribeGtmAccessStrategyRequest) (_result *DescribeGtmAccessStrategyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeGtmAccessStrategyResponse{}
	_body, _err := client.DescribeGtmAccessStrategyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeGtmAccessStrategyAvailableConfigWithOptions(request *DescribeGtmAccessStrategyAvailableConfigRequest, runtime *util.RuntimeOptions) (_result *DescribeGtmAccessStrategyAvailableConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeGtmAccessStrategyAvailableConfig"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeGtmAccessStrategyAvailableConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeGtmAccessStrategyAvailableConfig(request *DescribeGtmAccessStrategyAvailableConfigRequest) (_result *DescribeGtmAccessStrategyAvailableConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeGtmAccessStrategyAvailableConfigResponse{}
	_body, _err := client.DescribeGtmAccessStrategyAvailableConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeGtmAvailableAlertGroupWithOptions(request *DescribeGtmAvailableAlertGroupRequest, runtime *util.RuntimeOptions) (_result *DescribeGtmAvailableAlertGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeGtmAvailableAlertGroup"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeGtmAvailableAlertGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeGtmAvailableAlertGroup(request *DescribeGtmAvailableAlertGroupRequest) (_result *DescribeGtmAvailableAlertGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeGtmAvailableAlertGroupResponse{}
	_body, _err := client.DescribeGtmAvailableAlertGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeGtmInstanceWithOptions(request *DescribeGtmInstanceRequest, runtime *util.RuntimeOptions) (_result *DescribeGtmInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.NeedDetailAttributes)) {
		query["NeedDetailAttributes"] = request.NeedDetailAttributes
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeGtmInstance"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeGtmInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeGtmInstance(request *DescribeGtmInstanceRequest) (_result *DescribeGtmInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeGtmInstanceResponse{}
	_body, _err := client.DescribeGtmInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeGtmInstanceAddressPoolWithOptions(request *DescribeGtmInstanceAddressPoolRequest, runtime *util.RuntimeOptions) (_result *DescribeGtmInstanceAddressPoolResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AddrPoolId)) {
		query["AddrPoolId"] = request.AddrPoolId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeGtmInstanceAddressPool"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeGtmInstanceAddressPoolResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeGtmInstanceAddressPool(request *DescribeGtmInstanceAddressPoolRequest) (_result *DescribeGtmInstanceAddressPoolResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeGtmInstanceAddressPoolResponse{}
	_body, _err := client.DescribeGtmInstanceAddressPoolWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeGtmInstanceAddressPoolsWithOptions(request *DescribeGtmInstanceAddressPoolsRequest, runtime *util.RuntimeOptions) (_result *DescribeGtmInstanceAddressPoolsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeGtmInstanceAddressPools"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeGtmInstanceAddressPoolsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeGtmInstanceAddressPools(request *DescribeGtmInstanceAddressPoolsRequest) (_result *DescribeGtmInstanceAddressPoolsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeGtmInstanceAddressPoolsResponse{}
	_body, _err := client.DescribeGtmInstanceAddressPoolsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeGtmInstanceStatusWithOptions(request *DescribeGtmInstanceStatusRequest, runtime *util.RuntimeOptions) (_result *DescribeGtmInstanceStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeGtmInstanceStatus"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeGtmInstanceStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeGtmInstanceStatus(request *DescribeGtmInstanceStatusRequest) (_result *DescribeGtmInstanceStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeGtmInstanceStatusResponse{}
	_body, _err := client.DescribeGtmInstanceStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeGtmInstanceSystemCnameWithOptions(request *DescribeGtmInstanceSystemCnameRequest, runtime *util.RuntimeOptions) (_result *DescribeGtmInstanceSystemCnameResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeGtmInstanceSystemCname"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeGtmInstanceSystemCnameResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeGtmInstanceSystemCname(request *DescribeGtmInstanceSystemCnameRequest) (_result *DescribeGtmInstanceSystemCnameResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeGtmInstanceSystemCnameResponse{}
	_body, _err := client.DescribeGtmInstanceSystemCnameWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeGtmInstancesWithOptions(request *DescribeGtmInstancesRequest, runtime *util.RuntimeOptions) (_result *DescribeGtmInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.NeedDetailAttributes)) {
		query["NeedDetailAttributes"] = request.NeedDetailAttributes
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeGtmInstances"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeGtmInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeGtmInstances(request *DescribeGtmInstancesRequest) (_result *DescribeGtmInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeGtmInstancesResponse{}
	_body, _err := client.DescribeGtmInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeGtmLogsWithOptions(request *DescribeGtmLogsRequest, runtime *util.RuntimeOptions) (_result *DescribeGtmLogsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTimestamp)) {
		query["EndTimestamp"] = request.EndTimestamp
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartTimestamp)) {
		query["StartTimestamp"] = request.StartTimestamp
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeGtmLogs"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeGtmLogsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeGtmLogs(request *DescribeGtmLogsRequest) (_result *DescribeGtmLogsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeGtmLogsResponse{}
	_body, _err := client.DescribeGtmLogsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeGtmMonitorAvailableConfigWithOptions(request *DescribeGtmMonitorAvailableConfigRequest, runtime *util.RuntimeOptions) (_result *DescribeGtmMonitorAvailableConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeGtmMonitorAvailableConfig"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeGtmMonitorAvailableConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeGtmMonitorAvailableConfig(request *DescribeGtmMonitorAvailableConfigRequest) (_result *DescribeGtmMonitorAvailableConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeGtmMonitorAvailableConfigResponse{}
	_body, _err := client.DescribeGtmMonitorAvailableConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeGtmMonitorConfigWithOptions(request *DescribeGtmMonitorConfigRequest, runtime *util.RuntimeOptions) (_result *DescribeGtmMonitorConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.MonitorConfigId)) {
		query["MonitorConfigId"] = request.MonitorConfigId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeGtmMonitorConfig"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeGtmMonitorConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeGtmMonitorConfig(request *DescribeGtmMonitorConfigRequest) (_result *DescribeGtmMonitorConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeGtmMonitorConfigResponse{}
	_body, _err := client.DescribeGtmMonitorConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeGtmRecoveryPlanWithOptions(request *DescribeGtmRecoveryPlanRequest, runtime *util.RuntimeOptions) (_result *DescribeGtmRecoveryPlanResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.RecoveryPlanId)) {
		query["RecoveryPlanId"] = request.RecoveryPlanId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeGtmRecoveryPlan"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeGtmRecoveryPlanResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeGtmRecoveryPlan(request *DescribeGtmRecoveryPlanRequest) (_result *DescribeGtmRecoveryPlanResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeGtmRecoveryPlanResponse{}
	_body, _err := client.DescribeGtmRecoveryPlanWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeGtmRecoveryPlanAvailableConfigWithOptions(request *DescribeGtmRecoveryPlanAvailableConfigRequest, runtime *util.RuntimeOptions) (_result *DescribeGtmRecoveryPlanAvailableConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeGtmRecoveryPlanAvailableConfig"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeGtmRecoveryPlanAvailableConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeGtmRecoveryPlanAvailableConfig(request *DescribeGtmRecoveryPlanAvailableConfigRequest) (_result *DescribeGtmRecoveryPlanAvailableConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeGtmRecoveryPlanAvailableConfigResponse{}
	_body, _err := client.DescribeGtmRecoveryPlanAvailableConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeGtmRecoveryPlansWithOptions(request *DescribeGtmRecoveryPlansRequest, runtime *util.RuntimeOptions) (_result *DescribeGtmRecoveryPlansResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeGtmRecoveryPlans"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeGtmRecoveryPlansResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeGtmRecoveryPlans(request *DescribeGtmRecoveryPlansRequest) (_result *DescribeGtmRecoveryPlansResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeGtmRecoveryPlansResponse{}
	_body, _err := client.DescribeGtmRecoveryPlansWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeInstanceDomainsWithOptions(request *DescribeInstanceDomainsRequest, runtime *util.RuntimeOptions) (_result *DescribeInstanceDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeInstanceDomains"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeInstanceDomainsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeInstanceDomains(request *DescribeInstanceDomainsRequest) (_result *DescribeInstanceDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeInstanceDomainsResponse{}
	_body, _err := client.DescribeInstanceDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeIspFlushCacheInstancesWithOptions(request *DescribeIspFlushCacheInstancesRequest, runtime *util.RuntimeOptions) (_result *DescribeIspFlushCacheInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Direction)) {
		query["Direction"] = request.Direction
	}

	if !tea.BoolValue(util.IsUnset(request.Isp)) {
		query["Isp"] = request.Isp
	}

	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.OrderBy)) {
		query["OrderBy"] = request.OrderBy
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeIspFlushCacheInstances"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeIspFlushCacheInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeIspFlushCacheInstances(request *DescribeIspFlushCacheInstancesRequest) (_result *DescribeIspFlushCacheInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeIspFlushCacheInstancesResponse{}
	_body, _err := client.DescribeIspFlushCacheInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeIspFlushCacheRemainQuotaWithOptions(request *DescribeIspFlushCacheRemainQuotaRequest, runtime *util.RuntimeOptions) (_result *DescribeIspFlushCacheRemainQuotaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeIspFlushCacheRemainQuota"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeIspFlushCacheRemainQuotaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeIspFlushCacheRemainQuota(request *DescribeIspFlushCacheRemainQuotaRequest) (_result *DescribeIspFlushCacheRemainQuotaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeIspFlushCacheRemainQuotaResponse{}
	_body, _err := client.DescribeIspFlushCacheRemainQuotaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeIspFlushCacheTaskWithOptions(request *DescribeIspFlushCacheTaskRequest, runtime *util.RuntimeOptions) (_result *DescribeIspFlushCacheTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeIspFlushCacheTask"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeIspFlushCacheTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeIspFlushCacheTask(request *DescribeIspFlushCacheTaskRequest) (_result *DescribeIspFlushCacheTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeIspFlushCacheTaskResponse{}
	_body, _err := client.DescribeIspFlushCacheTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeIspFlushCacheTasksWithOptions(request *DescribeIspFlushCacheTasksRequest, runtime *util.RuntimeOptions) (_result *DescribeIspFlushCacheTasksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Direction)) {
		query["Direction"] = request.Direction
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Isp)) {
		query["Isp"] = request.Isp
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.OrderBy)) {
		query["OrderBy"] = request.OrderBy
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeIspFlushCacheTasks"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeIspFlushCacheTasksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeIspFlushCacheTasks(request *DescribeIspFlushCacheTasksRequest) (_result *DescribeIspFlushCacheTasksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeIspFlushCacheTasksResponse{}
	_body, _err := client.DescribeIspFlushCacheTasksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePdnsAccountSummaryWithOptions(request *DescribePdnsAccountSummaryRequest, runtime *util.RuntimeOptions) (_result *DescribePdnsAccountSummaryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		query["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		query["StartDate"] = request.StartDate
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePdnsAccountSummary"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePdnsAccountSummaryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePdnsAccountSummary(request *DescribePdnsAccountSummaryRequest) (_result *DescribePdnsAccountSummaryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePdnsAccountSummaryResponse{}
	_body, _err := client.DescribePdnsAccountSummaryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePdnsAppKeyWithOptions(request *DescribePdnsAppKeyRequest, runtime *util.RuntimeOptions) (_result *DescribePdnsAppKeyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppKeyId)) {
		query["AppKeyId"] = request.AppKeyId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePdnsAppKey"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePdnsAppKeyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePdnsAppKey(request *DescribePdnsAppKeyRequest) (_result *DescribePdnsAppKeyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePdnsAppKeyResponse{}
	_body, _err := client.DescribePdnsAppKeyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePdnsAppKeysWithOptions(request *DescribePdnsAppKeysRequest, runtime *util.RuntimeOptions) (_result *DescribePdnsAppKeysResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePdnsAppKeys"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePdnsAppKeysResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePdnsAppKeys(request *DescribePdnsAppKeysRequest) (_result *DescribePdnsAppKeysResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePdnsAppKeysResponse{}
	_body, _err := client.DescribePdnsAppKeysWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePdnsOperateLogsWithOptions(request *DescribePdnsOperateLogsRequest, runtime *util.RuntimeOptions) (_result *DescribePdnsOperateLogsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ActionType)) {
		query["ActionType"] = request.ActionType
	}

	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		query["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		query["StartDate"] = request.StartDate
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePdnsOperateLogs"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePdnsOperateLogsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePdnsOperateLogs(request *DescribePdnsOperateLogsRequest) (_result *DescribePdnsOperateLogsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePdnsOperateLogsResponse{}
	_body, _err := client.DescribePdnsOperateLogsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePdnsRequestStatisticWithOptions(request *DescribePdnsRequestStatisticRequest, runtime *util.RuntimeOptions) (_result *DescribePdnsRequestStatisticResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		query["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		query["StartDate"] = request.StartDate
	}

	if !tea.BoolValue(util.IsUnset(request.SubDomain)) {
		query["SubDomain"] = request.SubDomain
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePdnsRequestStatistic"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePdnsRequestStatisticResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePdnsRequestStatistic(request *DescribePdnsRequestStatisticRequest) (_result *DescribePdnsRequestStatisticResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePdnsRequestStatisticResponse{}
	_body, _err := client.DescribePdnsRequestStatisticWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePdnsRequestStatisticsWithOptions(request *DescribePdnsRequestStatisticsRequest, runtime *util.RuntimeOptions) (_result *DescribePdnsRequestStatisticsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		query["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		query["StartDate"] = request.StartDate
	}

	if !tea.BoolValue(util.IsUnset(request.SubDomain)) {
		query["SubDomain"] = request.SubDomain
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePdnsRequestStatistics"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePdnsRequestStatisticsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePdnsRequestStatistics(request *DescribePdnsRequestStatisticsRequest) (_result *DescribePdnsRequestStatisticsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePdnsRequestStatisticsResponse{}
	_body, _err := client.DescribePdnsRequestStatisticsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePdnsThreatLogsWithOptions(request *DescribePdnsThreatLogsRequest, runtime *util.RuntimeOptions) (_result *DescribePdnsThreatLogsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		query["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		query["StartDate"] = request.StartDate
	}

	if !tea.BoolValue(util.IsUnset(request.ThreatLevel)) {
		query["ThreatLevel"] = request.ThreatLevel
	}

	if !tea.BoolValue(util.IsUnset(request.ThreatSourceIp)) {
		query["ThreatSourceIp"] = request.ThreatSourceIp
	}

	if !tea.BoolValue(util.IsUnset(request.ThreatType)) {
		query["ThreatType"] = request.ThreatType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePdnsThreatLogs"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePdnsThreatLogsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePdnsThreatLogs(request *DescribePdnsThreatLogsRequest) (_result *DescribePdnsThreatLogsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePdnsThreatLogsResponse{}
	_body, _err := client.DescribePdnsThreatLogsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePdnsThreatStatisticWithOptions(request *DescribePdnsThreatStatisticRequest, runtime *util.RuntimeOptions) (_result *DescribePdnsThreatStatisticResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		query["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		query["StartDate"] = request.StartDate
	}

	if !tea.BoolValue(util.IsUnset(request.ThreatSourceIp)) {
		query["ThreatSourceIp"] = request.ThreatSourceIp
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePdnsThreatStatistic"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePdnsThreatStatisticResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePdnsThreatStatistic(request *DescribePdnsThreatStatisticRequest) (_result *DescribePdnsThreatStatisticResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePdnsThreatStatisticResponse{}
	_body, _err := client.DescribePdnsThreatStatisticWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePdnsThreatStatisticsWithOptions(request *DescribePdnsThreatStatisticsRequest, runtime *util.RuntimeOptions) (_result *DescribePdnsThreatStatisticsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Direction)) {
		query["Direction"] = request.Direction
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		query["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.OrderBy)) {
		query["OrderBy"] = request.OrderBy
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		query["StartDate"] = request.StartDate
	}

	if !tea.BoolValue(util.IsUnset(request.SubDomain)) {
		query["SubDomain"] = request.SubDomain
	}

	if !tea.BoolValue(util.IsUnset(request.ThreatLevel)) {
		query["ThreatLevel"] = request.ThreatLevel
	}

	if !tea.BoolValue(util.IsUnset(request.ThreatSourceIp)) {
		query["ThreatSourceIp"] = request.ThreatSourceIp
	}

	if !tea.BoolValue(util.IsUnset(request.ThreatType)) {
		query["ThreatType"] = request.ThreatType
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePdnsThreatStatistics"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePdnsThreatStatisticsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePdnsThreatStatistics(request *DescribePdnsThreatStatisticsRequest) (_result *DescribePdnsThreatStatisticsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePdnsThreatStatisticsResponse{}
	_body, _err := client.DescribePdnsThreatStatisticsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePdnsUdpIpSegmentsWithOptions(request *DescribePdnsUdpIpSegmentsRequest, runtime *util.RuntimeOptions) (_result *DescribePdnsUdpIpSegmentsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePdnsUdpIpSegments"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePdnsUdpIpSegmentsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePdnsUdpIpSegments(request *DescribePdnsUdpIpSegmentsRequest) (_result *DescribePdnsUdpIpSegmentsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePdnsUdpIpSegmentsResponse{}
	_body, _err := client.DescribePdnsUdpIpSegmentsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePdnsUserInfoWithOptions(request *DescribePdnsUserInfoRequest, runtime *util.RuntimeOptions) (_result *DescribePdnsUserInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePdnsUserInfo"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePdnsUserInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePdnsUserInfo(request *DescribePdnsUserInfoRequest) (_result *DescribePdnsUserInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePdnsUserInfoResponse{}
	_body, _err := client.DescribePdnsUserInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeRecordLogsWithOptions(request *DescribeRecordLogsRequest, runtime *util.RuntimeOptions) (_result *DescribeRecordLogsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.KeyWord)) {
		query["KeyWord"] = request.KeyWord
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		query["StartDate"] = request.StartDate
	}

	if !tea.BoolValue(util.IsUnset(request.UserClientIp)) {
		query["UserClientIp"] = request.UserClientIp
	}

	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		query["endDate"] = request.EndDate
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRecordLogs"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRecordLogsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeRecordLogs(request *DescribeRecordLogsRequest) (_result *DescribeRecordLogsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRecordLogsResponse{}
	_body, _err := client.DescribeRecordLogsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeRecordResolveStatisticsSummaryWithOptions(request *DescribeRecordResolveStatisticsSummaryRequest, runtime *util.RuntimeOptions) (_result *DescribeRecordResolveStatisticsSummaryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Direction)) {
		query["Direction"] = request.Direction
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.DomainType)) {
		query["DomainType"] = request.DomainType
	}

	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		query["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SearchMode)) {
		query["SearchMode"] = request.SearchMode
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		query["StartDate"] = request.StartDate
	}

	if !tea.BoolValue(util.IsUnset(request.Threshold)) {
		query["Threshold"] = request.Threshold
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRecordResolveStatisticsSummary"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRecordResolveStatisticsSummaryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeRecordResolveStatisticsSummary(request *DescribeRecordResolveStatisticsSummaryRequest) (_result *DescribeRecordResolveStatisticsSummaryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRecordResolveStatisticsSummaryResponse{}
	_body, _err := client.DescribeRecordResolveStatisticsSummaryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Real-time data is collected per hour.
 *
 * @param request DescribeRecordStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRecordStatisticsResponse
 */
func (client *Client) DescribeRecordStatisticsWithOptions(request *DescribeRecordStatisticsRequest, runtime *util.RuntimeOptions) (_result *DescribeRecordStatisticsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.DomainType)) {
		query["DomainType"] = request.DomainType
	}

	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		query["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.Rr)) {
		query["Rr"] = request.Rr
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		query["StartDate"] = request.StartDate
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRecordStatistics"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRecordStatisticsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Real-time data is collected per hour.
 *
 * @param request DescribeRecordStatisticsRequest
 * @return DescribeRecordStatisticsResponse
 */
func (client *Client) DescribeRecordStatistics(request *DescribeRecordStatisticsRequest) (_result *DescribeRecordStatisticsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRecordStatisticsResponse{}
	_body, _err := client.DescribeRecordStatisticsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeRecordStatisticsSummaryWithOptions(request *DescribeRecordStatisticsSummaryRequest, runtime *util.RuntimeOptions) (_result *DescribeRecordStatisticsSummaryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.DomainType)) {
		query["DomainType"] = request.DomainType
	}

	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		query["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SearchMode)) {
		query["SearchMode"] = request.SearchMode
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		query["StartDate"] = request.StartDate
	}

	if !tea.BoolValue(util.IsUnset(request.Threshold)) {
		query["Threshold"] = request.Threshold
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRecordStatisticsSummary"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRecordStatisticsSummaryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeRecordStatisticsSummary(request *DescribeRecordStatisticsSummaryRequest) (_result *DescribeRecordStatisticsSummaryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRecordStatisticsSummaryResponse{}
	_body, _err := client.DescribeRecordStatisticsSummaryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeSubDomainRecordsWithOptions(request *DescribeSubDomainRecordsRequest, runtime *util.RuntimeOptions) (_result *DescribeSubDomainRecordsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.Line)) {
		query["Line"] = request.Line
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SubDomain)) {
		query["SubDomain"] = request.SubDomain
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	if !tea.BoolValue(util.IsUnset(request.UserClientIp)) {
		query["UserClientIp"] = request.UserClientIp
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSubDomainRecords"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSubDomainRecordsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeSubDomainRecords(request *DescribeSubDomainRecordsRequest) (_result *DescribeSubDomainRecordsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSubDomainRecordsResponse{}
	_body, _err := client.DescribeSubDomainRecordsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeSupportLinesWithOptions(request *DescribeSupportLinesRequest, runtime *util.RuntimeOptions) (_result *DescribeSupportLinesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.UserClientIp)) {
		query["UserClientIp"] = request.UserClientIp
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSupportLines"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSupportLinesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeSupportLines(request *DescribeSupportLinesRequest) (_result *DescribeSupportLinesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSupportLinesResponse{}
	_body, _err := client.DescribeSupportLinesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeTagsWithOptions(request *DescribeTagsRequest, runtime *util.RuntimeOptions) (_result *DescribeTagsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeTags"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeTags(request *DescribeTagsRequest) (_result *DescribeTagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeTagsResponse{}
	_body, _err := client.DescribeTagsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeTransferDomainsWithOptions(request *DescribeTransferDomainsRequest, runtime *util.RuntimeOptions) (_result *DescribeTransferDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.FromUserId)) {
		query["FromUserId"] = request.FromUserId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.TargetUserId)) {
		query["TargetUserId"] = request.TargetUserId
	}

	if !tea.BoolValue(util.IsUnset(request.TransferType)) {
		query["TransferType"] = request.TransferType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeTransferDomains"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeTransferDomainsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeTransferDomains(request *DescribeTransferDomainsRequest) (_result *DescribeTransferDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeTransferDomainsResponse{}
	_body, _err := client.DescribeTransferDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ExecuteGtmRecoveryPlanWithOptions(request *ExecuteGtmRecoveryPlanRequest, runtime *util.RuntimeOptions) (_result *ExecuteGtmRecoveryPlanResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.RecoveryPlanId)) {
		query["RecoveryPlanId"] = request.RecoveryPlanId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ExecuteGtmRecoveryPlan"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ExecuteGtmRecoveryPlanResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ExecuteGtmRecoveryPlan(request *ExecuteGtmRecoveryPlanRequest) (_result *ExecuteGtmRecoveryPlanResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ExecuteGtmRecoveryPlanResponse{}
	_body, _err := client.ExecuteGtmRecoveryPlanWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetMainDomainNameWithOptions(request *GetMainDomainNameRequest, runtime *util.RuntimeOptions) (_result *GetMainDomainNameResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InputString)) {
		query["InputString"] = request.InputString
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMainDomainName"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMainDomainNameResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetMainDomainName(request *GetMainDomainNameRequest) (_result *GetMainDomainNameResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMainDomainNameResponse{}
	_body, _err := client.GetMainDomainNameWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetTxtRecordForVerifyWithOptions(request *GetTxtRecordForVerifyRequest, runtime *util.RuntimeOptions) (_result *GetTxtRecordForVerifyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetTxtRecordForVerify"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetTxtRecordForVerifyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetTxtRecordForVerify(request *GetTxtRecordForVerifyRequest) (_result *GetTxtRecordForVerifyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetTxtRecordForVerifyResponse{}
	_body, _err := client.GetTxtRecordForVerifyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can specify ResourceId.N or Tag.N that consists of Tag.N.Key and Tag.N.Value in the request to specify the object to be queried.
 * *   Tag.N is a resource tag that consists of a key-value pair. If you specify only Tag.N.Key, all tag values that are assigned to the specified key are returned. If you specify only Tag.N.Value, an error message is returned.
 * *   If you specify Tag.N and ResourceId.N to filter tags, ResourceId.N must match all specified key-value pairs.
 * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
 *
 * @param request ListTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesResponse
 */
func (client *Client) ListTagResourcesWithOptions(request *ListTagResourcesRequest, runtime *util.RuntimeOptions) (_result *ListTagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTagResources"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can specify ResourceId.N or Tag.N that consists of Tag.N.Key and Tag.N.Value in the request to specify the object to be queried.
 * *   Tag.N is a resource tag that consists of a key-value pair. If you specify only Tag.N.Key, all tag values that are assigned to the specified key are returned. If you specify only Tag.N.Value, an error message is returned.
 * *   If you specify Tag.N and ResourceId.N to filter tags, ResourceId.N must match all specified key-value pairs.
 * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
 *
 * @param request ListTagResourcesRequest
 * @return ListTagResourcesResponse
 */
func (client *Client) ListTagResources(request *ListTagResourcesRequest) (_result *ListTagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.ListTagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If the operation succeeds, the name of the DNS server changes to that of an Alibaba Cloud DNS server (ending with hichina.com).
 * >  Before you call this operation, make sure that your domain name has been registered with Alibaba Cloud and the DNS server in use is not an Alibaba Cloud DNS server.
 *
 * @param request ModifyHichinaDomainDNSRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyHichinaDomainDNSResponse
 */
func (client *Client) ModifyHichinaDomainDNSWithOptions(request *ModifyHichinaDomainDNSRequest, runtime *util.RuntimeOptions) (_result *ModifyHichinaDomainDNSResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.UserClientIp)) {
		query["UserClientIp"] = request.UserClientIp
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyHichinaDomainDNS"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyHichinaDomainDNSResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If the operation succeeds, the name of the DNS server changes to that of an Alibaba Cloud DNS server (ending with hichina.com).
 * >  Before you call this operation, make sure that your domain name has been registered with Alibaba Cloud and the DNS server in use is not an Alibaba Cloud DNS server.
 *
 * @param request ModifyHichinaDomainDNSRequest
 * @return ModifyHichinaDomainDNSResponse
 */
func (client *Client) ModifyHichinaDomainDNS(request *ModifyHichinaDomainDNSRequest) (_result *ModifyHichinaDomainDNSResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyHichinaDomainDNSResponse{}
	_body, _err := client.ModifyHichinaDomainDNSWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) MoveDomainResourceGroupWithOptions(request *MoveDomainResourceGroupRequest, runtime *util.RuntimeOptions) (_result *MoveDomainResourceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.NewResourceGroupId)) {
		query["NewResourceGroupId"] = request.NewResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("MoveDomainResourceGroup"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &MoveDomainResourceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) MoveDomainResourceGroup(request *MoveDomainResourceGroupRequest) (_result *MoveDomainResourceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &MoveDomainResourceGroupResponse{}
	_body, _err := client.MoveDomainResourceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) MoveGtmResourceGroupWithOptions(request *MoveGtmResourceGroupRequest, runtime *util.RuntimeOptions) (_result *MoveGtmResourceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.NewResourceGroupId)) {
		query["NewResourceGroupId"] = request.NewResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("MoveGtmResourceGroup"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &MoveGtmResourceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) MoveGtmResourceGroup(request *MoveGtmResourceGroupRequest) (_result *MoveGtmResourceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &MoveGtmResourceGroupResponse{}
	_body, _err := client.MoveGtmResourceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) OperateBatchDomainWithOptions(request *OperateBatchDomainRequest, runtime *util.RuntimeOptions) (_result *OperateBatchDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainRecordInfo)) {
		query["DomainRecordInfo"] = request.DomainRecordInfo
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("OperateBatchDomain"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &OperateBatchDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) OperateBatchDomain(request *OperateBatchDomainRequest) (_result *OperateBatchDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &OperateBatchDomainResponse{}
	_body, _err := client.OperateBatchDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) PausePdnsServiceWithOptions(request *PausePdnsServiceRequest, runtime *util.RuntimeOptions) (_result *PausePdnsServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceType)) {
		query["ServiceType"] = request.ServiceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PausePdnsService"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PausePdnsServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) PausePdnsService(request *PausePdnsServiceRequest) (_result *PausePdnsServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PausePdnsServiceResponse{}
	_body, _err := client.PausePdnsServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) PreviewGtmRecoveryPlanWithOptions(request *PreviewGtmRecoveryPlanRequest, runtime *util.RuntimeOptions) (_result *PreviewGtmRecoveryPlanResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RecoveryPlanId)) {
		query["RecoveryPlanId"] = request.RecoveryPlanId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PreviewGtmRecoveryPlan"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PreviewGtmRecoveryPlanResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) PreviewGtmRecoveryPlan(request *PreviewGtmRecoveryPlanRequest) (_result *PreviewGtmRecoveryPlanResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PreviewGtmRecoveryPlanResponse{}
	_body, _err := client.PreviewGtmRecoveryPlanWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RemovePdnsAppKeyWithOptions(request *RemovePdnsAppKeyRequest, runtime *util.RuntimeOptions) (_result *RemovePdnsAppKeyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppKeyId)) {
		query["AppKeyId"] = request.AppKeyId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemovePdnsAppKey"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemovePdnsAppKeyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RemovePdnsAppKey(request *RemovePdnsAppKeyRequest) (_result *RemovePdnsAppKeyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemovePdnsAppKeyResponse{}
	_body, _err := client.RemovePdnsAppKeyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RemovePdnsUdpIpSegmentWithOptions(request *RemovePdnsUdpIpSegmentRequest, runtime *util.RuntimeOptions) (_result *RemovePdnsUdpIpSegmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemovePdnsUdpIpSegment"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemovePdnsUdpIpSegmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RemovePdnsUdpIpSegment(request *RemovePdnsUdpIpSegmentRequest) (_result *RemovePdnsUdpIpSegmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemovePdnsUdpIpSegmentResponse{}
	_body, _err := client.RemovePdnsUdpIpSegmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ResumePdnsServiceWithOptions(request *ResumePdnsServiceRequest, runtime *util.RuntimeOptions) (_result *ResumePdnsServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceType)) {
		query["ServiceType"] = request.ServiceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ResumePdnsService"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ResumePdnsServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ResumePdnsService(request *ResumePdnsServiceRequest) (_result *ResumePdnsServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ResumePdnsServiceResponse{}
	_body, _err := client.ResumePdnsServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RetrieveDomainWithOptions(request *RetrieveDomainRequest, runtime *util.RuntimeOptions) (_result *RetrieveDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RetrieveDomain"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RetrieveDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RetrieveDomain(request *RetrieveDomainRequest) (_result *RetrieveDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RetrieveDomainResponse{}
	_body, _err := client.RetrieveDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RollbackGtmRecoveryPlanWithOptions(request *RollbackGtmRecoveryPlanRequest, runtime *util.RuntimeOptions) (_result *RollbackGtmRecoveryPlanResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.RecoveryPlanId)) {
		query["RecoveryPlanId"] = request.RecoveryPlanId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RollbackGtmRecoveryPlan"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RollbackGtmRecoveryPlanResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RollbackGtmRecoveryPlan(request *RollbackGtmRecoveryPlanRequest) (_result *RollbackGtmRecoveryPlanResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RollbackGtmRecoveryPlanResponse{}
	_body, _err := client.RollbackGtmRecoveryPlanWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetDNSSLBStatusWithOptions(request *SetDNSSLBStatusRequest, runtime *util.RuntimeOptions) (_result *SetDNSSLBStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.Line)) {
		query["Line"] = request.Line
	}

	if !tea.BoolValue(util.IsUnset(request.Open)) {
		query["Open"] = request.Open
	}

	if !tea.BoolValue(util.IsUnset(request.SubDomain)) {
		query["SubDomain"] = request.SubDomain
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	if !tea.BoolValue(util.IsUnset(request.UserClientIp)) {
		query["UserClientIp"] = request.UserClientIp
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDNSSLBStatus"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDNSSLBStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetDNSSLBStatus(request *SetDNSSLBStatusRequest) (_result *SetDNSSLBStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDNSSLBStatusResponse{}
	_body, _err := client.SetDNSSLBStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ****
 *
 * @param request SetDnsGtmAccessModeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDnsGtmAccessModeResponse
 */
func (client *Client) SetDnsGtmAccessModeWithOptions(request *SetDnsGtmAccessModeRequest, runtime *util.RuntimeOptions) (_result *SetDnsGtmAccessModeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccessMode)) {
		query["AccessMode"] = request.AccessMode
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.StrategyId)) {
		query["StrategyId"] = request.StrategyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDnsGtmAccessMode"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDnsGtmAccessModeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ****
 *
 * @param request SetDnsGtmAccessModeRequest
 * @return SetDnsGtmAccessModeResponse
 */
func (client *Client) SetDnsGtmAccessMode(request *SetDnsGtmAccessModeRequest) (_result *SetDnsGtmAccessModeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDnsGtmAccessModeResponse{}
	_body, _err := client.SetDnsGtmAccessModeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetDnsGtmMonitorStatusWithOptions(request *SetDnsGtmMonitorStatusRequest, runtime *util.RuntimeOptions) (_result *SetDnsGtmMonitorStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.MonitorConfigId)) {
		query["MonitorConfigId"] = request.MonitorConfigId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDnsGtmMonitorStatus"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDnsGtmMonitorStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetDnsGtmMonitorStatus(request *SetDnsGtmMonitorStatusRequest) (_result *SetDnsGtmMonitorStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDnsGtmMonitorStatusResponse{}
	_body, _err := client.SetDnsGtmMonitorStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetDomainDnssecStatusWithOptions(request *SetDomainDnssecStatusRequest, runtime *util.RuntimeOptions) (_result *SetDomainDnssecStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDomainDnssecStatus"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDomainDnssecStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetDomainDnssecStatus(request *SetDomainDnssecStatusRequest) (_result *SetDomainDnssecStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDomainDnssecStatusResponse{}
	_body, _err := client.SetDomainDnssecStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetDomainRecordStatusWithOptions(request *SetDomainRecordStatusRequest, runtime *util.RuntimeOptions) (_result *SetDomainRecordStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.RecordId)) {
		query["RecordId"] = request.RecordId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.UserClientIp)) {
		query["UserClientIp"] = request.UserClientIp
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDomainRecordStatus"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDomainRecordStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetDomainRecordStatus(request *SetDomainRecordStatusRequest) (_result *SetDomainRecordStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDomainRecordStatusResponse{}
	_body, _err := client.SetDomainRecordStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetGtmAccessModeWithOptions(request *SetGtmAccessModeRequest, runtime *util.RuntimeOptions) (_result *SetGtmAccessModeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccessMode)) {
		query["AccessMode"] = request.AccessMode
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.StrategyId)) {
		query["StrategyId"] = request.StrategyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetGtmAccessMode"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetGtmAccessModeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetGtmAccessMode(request *SetGtmAccessModeRequest) (_result *SetGtmAccessModeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetGtmAccessModeResponse{}
	_body, _err := client.SetGtmAccessModeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetGtmMonitorStatusWithOptions(request *SetGtmMonitorStatusRequest, runtime *util.RuntimeOptions) (_result *SetGtmMonitorStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.MonitorConfigId)) {
		query["MonitorConfigId"] = request.MonitorConfigId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetGtmMonitorStatus"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetGtmMonitorStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetGtmMonitorStatus(request *SetGtmMonitorStatusRequest) (_result *SetGtmMonitorStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetGtmMonitorStatusResponse{}
	_body, _err := client.SetGtmMonitorStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SubmitIspFlushCacheTaskWithOptions(request *SubmitIspFlushCacheTaskRequest, runtime *util.RuntimeOptions) (_result *SubmitIspFlushCacheTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Isp)) {
		query["Isp"] = request.Isp
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitIspFlushCacheTask"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SubmitIspFlushCacheTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SubmitIspFlushCacheTask(request *SubmitIspFlushCacheTaskRequest) (_result *SubmitIspFlushCacheTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitIspFlushCacheTaskResponse{}
	_body, _err := client.SubmitIspFlushCacheTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SwitchDnsGtmInstanceStrategyModeWithOptions(request *SwitchDnsGtmInstanceStrategyModeRequest, runtime *util.RuntimeOptions) (_result *SwitchDnsGtmInstanceStrategyModeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.StrategyMode)) {
		query["StrategyMode"] = request.StrategyMode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SwitchDnsGtmInstanceStrategyMode"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SwitchDnsGtmInstanceStrategyModeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SwitchDnsGtmInstanceStrategyMode(request *SwitchDnsGtmInstanceStrategyModeRequest) (_result *SwitchDnsGtmInstanceStrategyModeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SwitchDnsGtmInstanceStrategyModeResponse{}
	_body, _err := client.SwitchDnsGtmInstanceStrategyModeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) TagResourcesWithOptions(request *TagResourcesRequest, runtime *util.RuntimeOptions) (_result *TagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TagResources"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) TagResources(request *TagResourcesRequest) (_result *TagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TagResourcesResponse{}
	_body, _err := client.TagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) TransferDomainWithOptions(request *TransferDomainRequest, runtime *util.RuntimeOptions) (_result *TransferDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainNames)) {
		query["DomainNames"] = request.DomainNames
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.Remark)) {
		query["Remark"] = request.Remark
	}

	if !tea.BoolValue(util.IsUnset(request.TargetUserId)) {
		query["TargetUserId"] = request.TargetUserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TransferDomain"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TransferDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) TransferDomain(request *TransferDomainRequest) (_result *TransferDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TransferDomainResponse{}
	_body, _err := client.TransferDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UnbindInstanceDomainsWithOptions(request *UnbindInstanceDomainsRequest, runtime *util.RuntimeOptions) (_result *UnbindInstanceDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainNames)) {
		query["DomainNames"] = request.DomainNames
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UnbindInstanceDomains"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UnbindInstanceDomainsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UnbindInstanceDomains(request *UnbindInstanceDomainsRequest) (_result *UnbindInstanceDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UnbindInstanceDomainsResponse{}
	_body, _err := client.UnbindInstanceDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UntagResourcesWithOptions(request *UntagResourcesRequest, runtime *util.RuntimeOptions) (_result *UntagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.All)) {
		query["All"] = request.All
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TagKey)) {
		query["TagKey"] = request.TagKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UntagResources"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UntagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UntagResources(request *UntagResourcesRequest) (_result *UntagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UntagResourcesResponse{}
	_body, _err := client.UntagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateAppKeyStateWithOptions(request *UpdateAppKeyStateRequest, runtime *util.RuntimeOptions) (_result *UpdateAppKeyStateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppKeyId)) {
		query["AppKeyId"] = request.AppKeyId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.State)) {
		query["State"] = request.State
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAppKeyState"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAppKeyStateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateAppKeyState(request *UpdateAppKeyStateRequest) (_result *UpdateAppKeyStateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAppKeyStateResponse{}
	_body, _err := client.UpdateAppKeyStateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * In each CIDR block, the end IP address must be greater than or equal to the start IP address.
 * The CIDR blocks that are specified for all custom lines of a domain name cannot intersect.
 *
 * @param request UpdateCustomLineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCustomLineResponse
 */
func (client *Client) UpdateCustomLineWithOptions(request *UpdateCustomLineRequest, runtime *util.RuntimeOptions) (_result *UpdateCustomLineResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IpSegment)) {
		query["IpSegment"] = request.IpSegment
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.LineId)) {
		query["LineId"] = request.LineId
	}

	if !tea.BoolValue(util.IsUnset(request.LineName)) {
		query["LineName"] = request.LineName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateCustomLine"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateCustomLineResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * In each CIDR block, the end IP address must be greater than or equal to the start IP address.
 * The CIDR blocks that are specified for all custom lines of a domain name cannot intersect.
 *
 * @param request UpdateCustomLineRequest
 * @return UpdateCustomLineResponse
 */
func (client *Client) UpdateCustomLine(request *UpdateCustomLineRequest) (_result *UpdateCustomLineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateCustomLineResponse{}
	_body, _err := client.UpdateCustomLineWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateDNSSLBWeightWithOptions(request *UpdateDNSSLBWeightRequest, runtime *util.RuntimeOptions) (_result *UpdateDNSSLBWeightResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.RecordId)) {
		query["RecordId"] = request.RecordId
	}

	if !tea.BoolValue(util.IsUnset(request.UserClientIp)) {
		query["UserClientIp"] = request.UserClientIp
	}

	if !tea.BoolValue(util.IsUnset(request.Weight)) {
		query["Weight"] = request.Weight
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDNSSLBWeight"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDNSSLBWeightResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateDNSSLBWeight(request *UpdateDNSSLBWeightRequest) (_result *UpdateDNSSLBWeightResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDNSSLBWeightResponse{}
	_body, _err := client.UpdateDNSSLBWeightWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateDnsCacheDomainWithOptions(request *UpdateDnsCacheDomainRequest, runtime *util.RuntimeOptions) (_result *UpdateDnsCacheDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CacheTtlMax)) {
		query["CacheTtlMax"] = request.CacheTtlMax
	}

	if !tea.BoolValue(util.IsUnset(request.CacheTtlMin)) {
		query["CacheTtlMin"] = request.CacheTtlMin
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.SourceDnsServer)) {
		query["SourceDnsServer"] = request.SourceDnsServer
	}

	if !tea.BoolValue(util.IsUnset(request.SourceEdns)) {
		query["SourceEdns"] = request.SourceEdns
	}

	if !tea.BoolValue(util.IsUnset(request.SourceProtocol)) {
		query["SourceProtocol"] = request.SourceProtocol
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDnsCacheDomain"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDnsCacheDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateDnsCacheDomain(request *UpdateDnsCacheDomainRequest) (_result *UpdateDnsCacheDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDnsCacheDomainResponse{}
	_body, _err := client.UpdateDnsCacheDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateDnsCacheDomainRemarkWithOptions(request *UpdateDnsCacheDomainRemarkRequest, runtime *util.RuntimeOptions) (_result *UpdateDnsCacheDomainRemarkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.Remark)) {
		query["Remark"] = request.Remark
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDnsCacheDomainRemark"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDnsCacheDomainRemarkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateDnsCacheDomainRemark(request *UpdateDnsCacheDomainRemarkRequest) (_result *UpdateDnsCacheDomainRemarkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDnsCacheDomainRemarkResponse{}
	_body, _err := client.UpdateDnsCacheDomainRemarkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateDnsGtmAccessStrategyWithOptions(request *UpdateDnsGtmAccessStrategyRequest, runtime *util.RuntimeOptions) (_result *UpdateDnsGtmAccessStrategyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccessMode)) {
		query["AccessMode"] = request.AccessMode
	}

	if !tea.BoolValue(util.IsUnset(request.DefaultAddrPool)) {
		query["DefaultAddrPool"] = request.DefaultAddrPool
	}

	if !tea.BoolValue(util.IsUnset(request.DefaultAddrPoolType)) {
		query["DefaultAddrPoolType"] = request.DefaultAddrPoolType
	}

	if !tea.BoolValue(util.IsUnset(request.DefaultLatencyOptimization)) {
		query["DefaultLatencyOptimization"] = request.DefaultLatencyOptimization
	}

	if !tea.BoolValue(util.IsUnset(request.DefaultLbaStrategy)) {
		query["DefaultLbaStrategy"] = request.DefaultLbaStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.DefaultMaxReturnAddrNum)) {
		query["DefaultMaxReturnAddrNum"] = request.DefaultMaxReturnAddrNum
	}

	if !tea.BoolValue(util.IsUnset(request.DefaultMinAvailableAddrNum)) {
		query["DefaultMinAvailableAddrNum"] = request.DefaultMinAvailableAddrNum
	}

	if !tea.BoolValue(util.IsUnset(request.FailoverAddrPool)) {
		query["FailoverAddrPool"] = request.FailoverAddrPool
	}

	if !tea.BoolValue(util.IsUnset(request.FailoverAddrPoolType)) {
		query["FailoverAddrPoolType"] = request.FailoverAddrPoolType
	}

	if !tea.BoolValue(util.IsUnset(request.FailoverLatencyOptimization)) {
		query["FailoverLatencyOptimization"] = request.FailoverLatencyOptimization
	}

	if !tea.BoolValue(util.IsUnset(request.FailoverLbaStrategy)) {
		query["FailoverLbaStrategy"] = request.FailoverLbaStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.FailoverMaxReturnAddrNum)) {
		query["FailoverMaxReturnAddrNum"] = request.FailoverMaxReturnAddrNum
	}

	if !tea.BoolValue(util.IsUnset(request.FailoverMinAvailableAddrNum)) {
		query["FailoverMinAvailableAddrNum"] = request.FailoverMinAvailableAddrNum
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.Lines)) {
		query["Lines"] = request.Lines
	}

	if !tea.BoolValue(util.IsUnset(request.StrategyId)) {
		query["StrategyId"] = request.StrategyId
	}

	if !tea.BoolValue(util.IsUnset(request.StrategyName)) {
		query["StrategyName"] = request.StrategyName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDnsGtmAccessStrategy"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDnsGtmAccessStrategyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateDnsGtmAccessStrategy(request *UpdateDnsGtmAccessStrategyRequest) (_result *UpdateDnsGtmAccessStrategyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDnsGtmAccessStrategyResponse{}
	_body, _err := client.UpdateDnsGtmAccessStrategyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateDnsGtmAddressPoolWithOptions(request *UpdateDnsGtmAddressPoolRequest, runtime *util.RuntimeOptions) (_result *UpdateDnsGtmAddressPoolResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Addr)) {
		query["Addr"] = request.Addr
	}

	if !tea.BoolValue(util.IsUnset(request.AddrPoolId)) {
		query["AddrPoolId"] = request.AddrPoolId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.LbaStrategy)) {
		query["LbaStrategy"] = request.LbaStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDnsGtmAddressPool"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDnsGtmAddressPoolResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateDnsGtmAddressPool(request *UpdateDnsGtmAddressPoolRequest) (_result *UpdateDnsGtmAddressPoolResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDnsGtmAddressPoolResponse{}
	_body, _err := client.UpdateDnsGtmAddressPoolWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateDnsGtmInstanceGlobalConfigWithOptions(request *UpdateDnsGtmInstanceGlobalConfigRequest, runtime *util.RuntimeOptions) (_result *UpdateDnsGtmInstanceGlobalConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertConfig)) {
		query["AlertConfig"] = request.AlertConfig
	}

	if !tea.BoolValue(util.IsUnset(request.AlertGroup)) {
		query["AlertGroup"] = request.AlertGroup
	}

	if !tea.BoolValue(util.IsUnset(request.CnameType)) {
		query["CnameType"] = request.CnameType
	}

	if !tea.BoolValue(util.IsUnset(request.ForceUpdate)) {
		query["ForceUpdate"] = request.ForceUpdate
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceName)) {
		query["InstanceName"] = request.InstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.PublicCnameMode)) {
		query["PublicCnameMode"] = request.PublicCnameMode
	}

	if !tea.BoolValue(util.IsUnset(request.PublicRr)) {
		query["PublicRr"] = request.PublicRr
	}

	if !tea.BoolValue(util.IsUnset(request.PublicUserDomainName)) {
		query["PublicUserDomainName"] = request.PublicUserDomainName
	}

	if !tea.BoolValue(util.IsUnset(request.PublicZoneName)) {
		query["PublicZoneName"] = request.PublicZoneName
	}

	if !tea.BoolValue(util.IsUnset(request.Ttl)) {
		query["Ttl"] = request.Ttl
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDnsGtmInstanceGlobalConfig"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDnsGtmInstanceGlobalConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateDnsGtmInstanceGlobalConfig(request *UpdateDnsGtmInstanceGlobalConfigRequest) (_result *UpdateDnsGtmInstanceGlobalConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDnsGtmInstanceGlobalConfigResponse{}
	_body, _err := client.UpdateDnsGtmInstanceGlobalConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateDnsGtmMonitorWithOptions(request *UpdateDnsGtmMonitorRequest, runtime *util.RuntimeOptions) (_result *UpdateDnsGtmMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EvaluationCount)) {
		query["EvaluationCount"] = request.EvaluationCount
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspCityNode)) {
		query["IspCityNode"] = request.IspCityNode
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.MonitorConfigId)) {
		query["MonitorConfigId"] = request.MonitorConfigId
	}

	if !tea.BoolValue(util.IsUnset(request.MonitorExtendInfo)) {
		query["MonitorExtendInfo"] = request.MonitorExtendInfo
	}

	if !tea.BoolValue(util.IsUnset(request.ProtocolType)) {
		query["ProtocolType"] = request.ProtocolType
	}

	if !tea.BoolValue(util.IsUnset(request.Timeout)) {
		query["Timeout"] = request.Timeout
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDnsGtmMonitor"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDnsGtmMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateDnsGtmMonitor(request *UpdateDnsGtmMonitorRequest) (_result *UpdateDnsGtmMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDnsGtmMonitorResponse{}
	_body, _err := client.UpdateDnsGtmMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateDomainGroupWithOptions(request *UpdateDomainGroupRequest, runtime *util.RuntimeOptions) (_result *UpdateDomainGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDomainGroup"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDomainGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateDomainGroup(request *UpdateDomainGroupRequest) (_result *UpdateDomainGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDomainGroupResponse{}
	_body, _err := client.UpdateDomainGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateDomainRecordWithOptions(request *UpdateDomainRecordRequest, runtime *util.RuntimeOptions) (_result *UpdateDomainRecordResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.Line)) {
		query["Line"] = request.Line
	}

	if !tea.BoolValue(util.IsUnset(request.Priority)) {
		query["Priority"] = request.Priority
	}

	if !tea.BoolValue(util.IsUnset(request.RR)) {
		query["RR"] = request.RR
	}

	if !tea.BoolValue(util.IsUnset(request.RecordId)) {
		query["RecordId"] = request.RecordId
	}

	if !tea.BoolValue(util.IsUnset(request.TTL)) {
		query["TTL"] = request.TTL
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	if !tea.BoolValue(util.IsUnset(request.UserClientIp)) {
		query["UserClientIp"] = request.UserClientIp
	}

	if !tea.BoolValue(util.IsUnset(request.Value)) {
		query["Value"] = request.Value
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDomainRecord"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDomainRecordResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateDomainRecord(request *UpdateDomainRecordRequest) (_result *UpdateDomainRecordResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDomainRecordResponse{}
	_body, _err := client.UpdateDomainRecordWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateDomainRecordRemarkWithOptions(request *UpdateDomainRecordRemarkRequest, runtime *util.RuntimeOptions) (_result *UpdateDomainRecordRemarkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.RecordId)) {
		query["RecordId"] = request.RecordId
	}

	if !tea.BoolValue(util.IsUnset(request.Remark)) {
		query["Remark"] = request.Remark
	}

	if !tea.BoolValue(util.IsUnset(request.UserClientIp)) {
		query["UserClientIp"] = request.UserClientIp
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDomainRecordRemark"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDomainRecordRemarkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateDomainRecordRemark(request *UpdateDomainRecordRemarkRequest) (_result *UpdateDomainRecordRemarkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDomainRecordRemarkResponse{}
	_body, _err := client.UpdateDomainRecordRemarkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateDomainRemarkWithOptions(request *UpdateDomainRemarkRequest, runtime *util.RuntimeOptions) (_result *UpdateDomainRemarkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.Remark)) {
		query["Remark"] = request.Remark
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDomainRemark"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDomainRemarkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateDomainRemark(request *UpdateDomainRemarkRequest) (_result *UpdateDomainRemarkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDomainRemarkResponse{}
	_body, _err := client.UpdateDomainRemarkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGtmAccessStrategyWithOptions(request *UpdateGtmAccessStrategyRequest, runtime *util.RuntimeOptions) (_result *UpdateGtmAccessStrategyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccessLines)) {
		query["AccessLines"] = request.AccessLines
	}

	if !tea.BoolValue(util.IsUnset(request.DefaultAddrPoolId)) {
		query["DefaultAddrPoolId"] = request.DefaultAddrPoolId
	}

	if !tea.BoolValue(util.IsUnset(request.FailoverAddrPoolId)) {
		query["FailoverAddrPoolId"] = request.FailoverAddrPoolId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.StrategyId)) {
		query["StrategyId"] = request.StrategyId
	}

	if !tea.BoolValue(util.IsUnset(request.StrategyName)) {
		query["StrategyName"] = request.StrategyName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGtmAccessStrategy"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGtmAccessStrategyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGtmAccessStrategy(request *UpdateGtmAccessStrategyRequest) (_result *UpdateGtmAccessStrategyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGtmAccessStrategyResponse{}
	_body, _err := client.UpdateGtmAccessStrategyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGtmAddressPoolWithOptions(request *UpdateGtmAddressPoolRequest, runtime *util.RuntimeOptions) (_result *UpdateGtmAddressPoolResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Addr)) {
		query["Addr"] = request.Addr
	}

	if !tea.BoolValue(util.IsUnset(request.AddrPoolId)) {
		query["AddrPoolId"] = request.AddrPoolId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.MinAvailableAddrNum)) {
		query["MinAvailableAddrNum"] = request.MinAvailableAddrNum
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGtmAddressPool"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGtmAddressPoolResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGtmAddressPool(request *UpdateGtmAddressPoolRequest) (_result *UpdateGtmAddressPoolResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGtmAddressPoolResponse{}
	_body, _err := client.UpdateGtmAddressPoolWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGtmInstanceGlobalConfigWithOptions(request *UpdateGtmInstanceGlobalConfigRequest, runtime *util.RuntimeOptions) (_result *UpdateGtmInstanceGlobalConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertGroup)) {
		query["AlertGroup"] = request.AlertGroup
	}

	if !tea.BoolValue(util.IsUnset(request.CnameCustomDomainName)) {
		query["CnameCustomDomainName"] = request.CnameCustomDomainName
	}

	if !tea.BoolValue(util.IsUnset(request.CnameMode)) {
		query["CnameMode"] = request.CnameMode
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceName)) {
		query["InstanceName"] = request.InstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.LbaStrategy)) {
		query["LbaStrategy"] = request.LbaStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.Ttl)) {
		query["Ttl"] = request.Ttl
	}

	if !tea.BoolValue(util.IsUnset(request.UserDomainName)) {
		query["UserDomainName"] = request.UserDomainName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGtmInstanceGlobalConfig"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGtmInstanceGlobalConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGtmInstanceGlobalConfig(request *UpdateGtmInstanceGlobalConfigRequest) (_result *UpdateGtmInstanceGlobalConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGtmInstanceGlobalConfigResponse{}
	_body, _err := client.UpdateGtmInstanceGlobalConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGtmMonitorWithOptions(request *UpdateGtmMonitorRequest, runtime *util.RuntimeOptions) (_result *UpdateGtmMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EvaluationCount)) {
		query["EvaluationCount"] = request.EvaluationCount
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspCityNode)) {
		query["IspCityNode"] = request.IspCityNode
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.MonitorConfigId)) {
		query["MonitorConfigId"] = request.MonitorConfigId
	}

	if !tea.BoolValue(util.IsUnset(request.MonitorExtendInfo)) {
		query["MonitorExtendInfo"] = request.MonitorExtendInfo
	}

	if !tea.BoolValue(util.IsUnset(request.ProtocolType)) {
		query["ProtocolType"] = request.ProtocolType
	}

	if !tea.BoolValue(util.IsUnset(request.Timeout)) {
		query["Timeout"] = request.Timeout
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGtmMonitor"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGtmMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGtmMonitor(request *UpdateGtmMonitorRequest) (_result *UpdateGtmMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGtmMonitorResponse{}
	_body, _err := client.UpdateGtmMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateGtmRecoveryPlanWithOptions(request *UpdateGtmRecoveryPlanRequest, runtime *util.RuntimeOptions) (_result *UpdateGtmRecoveryPlanResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FaultAddrPool)) {
		query["FaultAddrPool"] = request.FaultAddrPool
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RecoveryPlanId)) {
		query["RecoveryPlanId"] = request.RecoveryPlanId
	}

	if !tea.BoolValue(util.IsUnset(request.Remark)) {
		query["Remark"] = request.Remark
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateGtmRecoveryPlan"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateGtmRecoveryPlanResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateGtmRecoveryPlan(request *UpdateGtmRecoveryPlanRequest) (_result *UpdateGtmRecoveryPlanResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateGtmRecoveryPlanResponse{}
	_body, _err := client.UpdateGtmRecoveryPlanWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateIspFlushCacheInstanceConfigWithOptions(request *UpdateIspFlushCacheInstanceConfigRequest, runtime *util.RuntimeOptions) (_result *UpdateIspFlushCacheInstanceConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceName)) {
		query["InstanceName"] = request.InstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateIspFlushCacheInstanceConfig"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateIspFlushCacheInstanceConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateIspFlushCacheInstanceConfig(request *UpdateIspFlushCacheInstanceConfigRequest) (_result *UpdateIspFlushCacheInstanceConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateIspFlushCacheInstanceConfigResponse{}
	_body, _err := client.UpdateIspFlushCacheInstanceConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ValidateDnsGtmCnameRrCanUseWithOptions(request *ValidateDnsGtmCnameRrCanUseRequest, runtime *util.RuntimeOptions) (_result *ValidateDnsGtmCnameRrCanUseResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CnameMode)) {
		query["CnameMode"] = request.CnameMode
	}

	if !tea.BoolValue(util.IsUnset(request.CnameRr)) {
		query["CnameRr"] = request.CnameRr
	}

	if !tea.BoolValue(util.IsUnset(request.CnameType)) {
		query["CnameType"] = request.CnameType
	}

	if !tea.BoolValue(util.IsUnset(request.CnameZone)) {
		query["CnameZone"] = request.CnameZone
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ValidateDnsGtmCnameRrCanUse"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ValidateDnsGtmCnameRrCanUseResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ValidateDnsGtmCnameRrCanUse(request *ValidateDnsGtmCnameRrCanUseRequest) (_result *ValidateDnsGtmCnameRrCanUseResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ValidateDnsGtmCnameRrCanUseResponse{}
	_body, _err := client.ValidateDnsGtmCnameRrCanUseWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ValidatePdnsUdpIpSegmentWithOptions(request *ValidatePdnsUdpIpSegmentRequest, runtime *util.RuntimeOptions) (_result *ValidatePdnsUdpIpSegmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.Lang)) {
		query["Lang"] = request.Lang
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ValidatePdnsUdpIpSegment"),
		Version:     tea.String("2015-01-09"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ValidatePdnsUdpIpSegmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ValidatePdnsUdpIpSegment(request *ValidatePdnsUdpIpSegmentRequest) (_result *ValidatePdnsUdpIpSegmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ValidatePdnsUdpIpSegmentResponse{}
	_body, _err := client.ValidatePdnsUdpIpSegmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
